# 第四章 Globbing

在本章中，我们将了解 zsh 中最强大的功能之一：文件名生成。我们将学习处理系统文件和目录的新方法，甚至通过应用参数替换和修改器扩展一些更传统的命令的功能。本章还作为介绍 zmv 的一部分，这是一个内置功能，提供了许多有用的功能来处理文件的日常和更复杂的任务。我们将学会如何使用 zmv 根据我们新学到的模式来重命名、复制和链接文件。已经感到兴奋了吗？

# 引用你的字符串

安全声明字符串变量的一种方式涉及使用引号。把它看作是告诉函数“*这里*开始，*这里*结束我的字符串”的一种方式。虽然在这个特定示例中不是必需的，但是你可以在使用 `echo` 时引用短语，如下所示：

```
% echo 'this is a quoted phrase'
> this is a quoted phrase

```

单引号被 shell 视为分隔符，因此它们完全被忽略。相同的规则适用于 `print` 内置函数：

```
% print 'this is a quoted phrase'
> this is a quoted phrase

```

那么，使用引号的意义是什么呢？好吧，想象一下，你的输出看起来像以下这样：

```
% echo this is a backslash: \
~>

```

是的，这将触发一个续行，所以看起来似乎没有其他方法，除非使用引号。让我们再试一次：

```
% echo 'this is a backslash: \'
> this is a backslash: \

```

因此，作为一个经验法则，当我们的字符串中有特殊字符时，我们使用单引号如下所示：

```
% echo 'special characters like * # and \ need to be quoted'
> special characters like * # and \ need to be quoted

```

现在，是什么让这些特别呢？嗯，在本书的早些部分，我们看到注释是由 `#` 符号定义的；我们可以使用 `*` 字符作为匹配文件名的通配符，而 `\` 字符可用于转义具有特殊含义的序列。把所有这些都当作 *特殊字符*，除非引用它们，否则它们永远不会字面上意味着键盘上显示的内容。

### 提示

一些特殊字符需要“转义”。这意味着除了它们表示的字符之外，它们还会有不同的含义，除非有一个 `\` 字符在它们之前。

例如，`echo *.rb` 将列出所有具有 `.rb` 扩展名的文件。如果你想列出一个名为 `*.rb` 的目录——很奇怪，我知道——你需要调用 `echo` 并转义 `*` 特殊字符，如下所示：

```
% echo \*.rb

```

另外需要注意的是，`\` 实际上是一个特殊字符，因此在需要字面上使用反斜杠的情况下，你需要对它进行转义：

```
% echo \\
> \

```

正如我们在前一章中看到的，一个单独的反斜杠（`\`）只会触发一个续行。

### 提示

你可以通过提供 `(q)` 参数来使 shell 输出原始字符串：

```
% string="This is a *string* with various 'special' characters"
% echo ${(q)string}
> this\ is\ a\ \*string\*\ with\ various\ \'special\'\ characters
```

## 双引号

好的，那么当我们需要使用特殊字符的优点，并且需要它们显示为它们的字面值时会发生什么？进入双引号。

### 提示

选项 `RC_QUOTES` 允许你在单引号字符串内部使用单引号：

```
% setopt rcquotes
% echo 'a single ''quoted'' string'
> a single ''quoted'' string
```

双引号的工作原理是允许你保留任何字符串的值，并在其中启用 *参数替换* 和 *shell 扩展*。

认真看看以下示例：

```
% echo "My username is $(whoami) and my home folder is located at '$HOME'."
> My username is gfestari and my home folder is located at '/Users/gfestari'.

```

shell 会在双引号内执行 `$()` 结构中的命令，先于其他任何操作。在这个特定的例子中，我们使用 `whoami` 程序来告诉当前用户的 ID——在这个例子中是 `gfestari`——（如果那也是你的名字，*你好*，久违的兄弟）。

然后，shell 会扩展环境变量 `$HOME`，该变量指向当前用户的主文件夹，在我的系统中指向 `/Users/gfestari`。注意单引号在双引号内像任何其他字符一样被处理。

# 开始使用 Globbing

文件名生成，广为人知的 **Globbing**（即，全局替换），是 shell 从模式生成文件名的能力。这仅仅是允许 shell 读取模式并生成一系列文件名的过程的名称；事实上，你可能已经在本书中使用 Globbing 很久了，唯一的区别是，我们现在正式介绍这个特性。此外，请注意，当我们在本文中提到 *文件名* 时，它既指文件 *也* 指文件夹名，因为你可以使用几乎相同的模式来匹配两者。

当处理 Globbing 时，最重要的是要记住，文件名替换发生在 shell 中的 *输入行发送到命令之前*。换句话说，你输入了内容，zsh 会做替换，*然后* 才将扩展后的字符串，而不是你刚输入的内容，发送给函数或程序。虽然有绕过的方法，但请务必保持警觉。

### 提示

如果你想深入了解本章中提到的一些特性，可以随时通过输入 `man zshexpn` 查阅官方文档。

## 使用星号进行 Globbing

Globbing 的工作原理是通过一系列称为 *操作符* 的特殊字符，创建一个模式，随后 shell 会扩展这个模式为更复杂的传统字符串，而你甚至不会注意到额外的工作量。可以说，这些操作符中最常用的就是星号或星号符号（`*`）。星号作为 *通配符*，允许你匹配任何文件名，即使你根本没有提供模式：

```
% echo *
README.md todo.txt draft.txt new_file.txt

```

这将列出当前目录中的任何文件和文件夹。注意我们只需要一个 *单一的星号* 就能做到这一点。然而，如果我们想要所有扩展名为 `.txt` 的文件，只需要提供相应的模式：任何以所需扩展名结尾的文件。

```
% echo *.txt
todo.txt draft.txt new_file.txt

```

发生的情况是，zsh 会读取 `*.txt` 模式，将其转化为字面意义（所有具有 `txt` 扩展名的文件名），然后将结果作为 `echo` 的参数传递，而 `echo` 实际上并不会处理模式本身。

可以说，这颗星星最棒的特点就是它的多功能性。就像一个醉酒的水手，星星几乎可以与任何东西相处，不仅仅是文件：

```
% echo *folder
out_folder src_folder

```

### 提示

如果你想让 Globbing 不区分大小写（即将大写字母和小写字母视为相等），可以使用`NO_CASE_GLOB`选项。

```
% setopt nocaseglob
% echo *.jpg
photo.jpg pic.JPG
```

但并非所有情况都是一帆风顺的。在使用星号操作符时，有一个细节你需要注意：隐藏文件。如果你记得在第二章中，*别名与历史*一节中，我们使用了`la`别名（或`ls -a`）来列出目录中的隐藏文件；否则，命令不会列出它们。

由于像`rm *`这样的操作可能导致删除父文件夹，给你带来麻烦，大多数 Unix shell 会忽略大多数命令中的隐藏文件。使用通配符操作符时，Globbing 也遵循相同的规则。解决这种行为的方法是显式使用类似`.*some_pattern`的模式，以包含隐藏文件，如下所示：

```
% echo .*zsh*
.zsh_aliases .zsh_funcs .zsh_history .zsh_prompt .zshenv .zshrc

```

我们使用两个星号来列出所有以点开头（Unix 中的传统隐藏文件）并且文件名中包含`zsh`模式的文件。换句话说，就是我们的启动文件。

这里的关键教训是：*你可以在模式中的任何地方使用星号*，不必局限于长度或仅限于扩展名；但要注意隐藏文件，因为星号不会显示隐藏文件，你需要使用类似`.*some_pattern`的模式才能做到这一点。

### 注意

你可以通过设置`GLOBDOTS`选项来绕过“忽略以点开头的文件”行为；然而，建议你不要在启动文件中永久设置该选项，因为它可能导致你删除父目录（`.`）等问题。

在脚本或函数中使用此选项时，最重要的是在退出前确保调用`setopt NO_GLOBDOTS`。不过大多数情况下，你只需使用之前讨论过的`.*`模式就能顺利完成。

## 匹配任意单个字符的问题

问号符号的作用与星号类似，不同之处在于它匹配单个字符而非多个字符。例如，你可以使用`ls ???`来列出任何三字母的目录内容，或者更实际一点，使用以下命令列出任何两字母扩展名的文件：

```
% echo *.??
script.sh

```

我们甚至可以通过以下类似的表达式查看所有具有扩展名的文件：

```
% echo main.?*
main.c main.o main.tmp

```

这与通配符限定符类似；然而，除非显式声明，否则你无法匹配以点开头的任何文件名。

## 字符序列的方括号

你可以使用方括号构造来匹配模式中的一组字符。例如，你可以使用`[ML]*`来匹配任何以大写字母`M`或`L`开头的文件名。

```
% ls
Log.log Main.rb README.md script.sh
% echo [ML]*
Log.log Main.rb

```

注意我们需要将字符类运算符与通配符结合使用，以表示可能包含多个大写字母的文件名。

更有用的是使用连字符（或减号）来命名连续字符的范围。例如，你可以使用`[A-Z]*`模式来匹配任何以大写字母开头的文件。同样，你也可以使用相同的模式来匹配连续的自然数：

```
% echo *.log_[1-9]
out.log_1 out.log_2 out.log_3

```

很简单，对吧？记住你可以声明自己的字符类。这里有一个示例，匹配任何以 1 到 5 的数字或大写字母`M`开头的文件名：

```
% echo [1-5M]*.*
Main.rb

```

就像之前一样，`[.]*`模式不会像你预期的那样工作；事实上，它根本无法工作。

### 注意

**关于范围的说明**

如果你的系统使用的是非英语字母或其他非 ASCII 字符集，那么你可能会期望像`ü`这样的字符匹配像`[a-z]`这样的类。然而，这种行为是由`LANG`和`LC_*`系列环境变量控制的，并且*非常*依赖于系统，甚至超出了本书的讨论范围。

## 在脚本中使用更安全的范围

虽然如果你最近使用了任何现代 Shell，这个可能没什么新鲜感，但有一系列的快捷方式可以让你在处理常见的字符类时免于无聊。你可以通过`[[:shortcut:]]`模式来访问它们。

所以，例如，如果你需要任何字母（比如包括大写和小写字母的范围`[A-Za-z]`），你可以使用`alpha`快捷方式来列出任何以字母字符开头的文件名，如下所示：

```
% echo [[:alpha:]]*

```

对字符集感到兴奋了吗？以下表格列出了一些流行的字符集：

| 字符集 | 描述 |
| --- | --- |
| `ascii` | ASCII 字符集中的任何字符（请参阅`man ascii`） |
| `lower` | 小写字符 |
| `upper` | 大写字符 |
| `alpha` | 字母 |
| `digit` | 数字 |
| `alnum` | 字母数字字符 |
| `print` | 任何可打印字符 |
| `blank` | 空格或制表符 |
| `space` | 空格字符（制表符、回车符、换行符等） |
| `punct` | 任何既不是`alnum`也不是`space`的字符 |

你可以结合多个模式和字符集；只需记住，最内层的方括号属于字符集，其他内容都放在最外层的方括号之间。例如，如果我们想要所有以`digit`字符或小写字母`b`开头的文件，可以使用以下模式：

```
% echo [[:digit:]b]*.c
bindings.c

```

如你所见，内层的方括号声明了字符集，而`b`字符只是作为我们输入的`[b]`。

### 避免使用某些字符

好的，到目前为止我们一直在热烈欢迎模式，但当我们想要找到那些*不*匹配我们正在寻找的内容时会发生什么呢？原来也有一种简单的方法可以告诉 zsh“我想要的是那些与特定模式无关的文件名”，那么我们来看看吧。

假设我们在某个目录下有以下文件：

```
% ls
bindings.c  bindings.h  bindings.o  main.c  main.o

```

我们只想选择实际的代码文件，即以`.c`和`.h`结尾的文件，避免选择以`.o`结尾的文件。根据我们迄今为止学到的知识，我们可以做到类似如下：

```
% echo *.[hc]
bindings.c bindings.h main.c

```

但正如你所看到的，我们的需求越复杂，最终可能会遇到一个庞大的字符类混乱。幸运的是，我们可以通过插入符号（`^`）操作符来获取一个类的补集：

```
% echo *.[^o]
bindings.c bindings.h main.c

```

我们在这里所做的是告诉 zsh 扩展那些*不匹配*`o`扩展名的文件名的类。请注意，其余的模式保持不变，并且插入符号紧接在实际进行否定的左括号后面。你可以理解为“除了括号内的内容之外的任何东西”。

### 小贴士

你可以通过在内括号前使用插入符号来否定一个字符集。例如，如果我们想跳过以大写字母开头的文件，我们可以这样做：

```
% echo [^[:upper:]]*
```

## 处理不匹配的情况

到目前为止，我们已经看到了如何让 shell 解释我们的模式并尝试匹配它能匹配的任何文件名。在接下来的 Globbing 过程中，我们将看看那些不幸的模式，哪些未能匹配任何内容，以及 shell 如何处理它们。

让我们尝试列出一些不存在的 zip 文件：

```
% ls
bindings.c  bindings.h  bindings.o  main.c  main.o

% echo *.zip
zsh: no matches found: *.zip

```

看起来 zsh 默认会输出错误信息并中止命令的执行。幸运的是，有很多选项可以帮助我们应对这种情况。

首先，有`NULL_GLOB`，它会让 shell 丢弃任何没有正确匹配的模式。以下是一个例子，当没有匹配时会打印空行：

```
% setopt null_glob
% echo *.zip
> 

```

这种方式在传递多个模式时非常有用，但有时会导致你调用一些没有任何参数的程序，因此在随便更新启动文件之前需要考虑这一点。

```
% echo *.c *.zip
bindings.c main.c

```

第一个模式(`*.c`)匹配并列出所有`.c`扩展名的文件；而第二个模式(`*.zip`)不匹配任何内容，并被丢弃（一个空的第二个条目传递给`echo`）。

接下来，还有`NOMATCH`选项，你可以取消设置它来实现类似于 bash 的行为；任何不匹配的模式都会作为*字面参数*传递给命令。通过以下示例可以轻松测试：

```
% unsetopt nomatch
% echo *.zip
*.zip

```

你知道吗？似乎手册页是对的，现在失败的`*.zip`模式就像我们调用了`echo '*.zip'`一样。这与`NULL_GLOB`不同，因为该模式也会被 shell 忽略，但无论是否匹配任何内容，都会作为*参数*传递给程序。

### 小贴士

记得你也可以使用`setopt NO_NOMATCH`来代替`unsetopt`。

最后，还有一个选项，它模仿了`csh`的遗留行为，名为`CSH_NULL_GLOB`。是的，命名惯例可谓不惜一切代价。无论如何，设置它时会发生如下情况：

```
% setopt csh_null_glob
% echo *.zip
zsh: no match

```

看来我们又回到了“错误信息并中止命令”的区域。作为好奇的学习者，我们不妨加大一点力度，看看当处理多个模式时会发生什么：

```
% echo *.c *.zip
bindings.c main.c

```

好的，现在看起来好多了。发生的情况是，`CSH_NULL_GLOB` 会在任何单一模式不匹配时显示错误信息并中止命令行，但如果至少有一个模式匹配，它会继续执行并丢弃失败的模式。可以把它当作 zsh 默认行为和 `NULL_GLOB` 之间那晚激情碰撞的产物。而且在此期间，别怪我带来这样的心理画面。

在我们转向另一个主题之前，还有一个你应该熟悉的选项，特别是在处理模式时。但首先，让我们看看当我们尝试将一个错误的模式传递给 shell 时会发生什么：

```
% echo *[[:alpha:]
zsh: bad pattern: *[[:alpha:]

```

注意我们错过了关闭括号（`]`）吗？shell 报告了模式错误，我们则被失败的脚本弄得有些沮丧。让我们再试一次，不过这次我们会设置以下选项：

```
% setopt no_bad_pattern
% echo *[[:alpha:]
*[[:alpha:]

```

我们启用了 `NO_BAD_PATTERN`（或取消设置 `BAD_PATTERN`，随你喜欢），然后发生了什么？没错；不良模式*被 shell 扩展机制忽略*，而是作为参数传递给命令。如果你不想在实验新学的模式时看到那些烦人的警告，这个功能非常方便。

# 扩展 Globbing

如你现在可能已经注意到，当涉及到 Globbing 时，zsh 总是能超出预期，做得比要求的更多。接下来我们将讨论 Globbing 的更高级部分，通常被称为*扩展 Globbing*。简单来说，我们将学习一组新的字符和表达式，扩展我们之前使用的功能，为 shell 的操作提供更多功能。不过，在我们开始之前，先打开你的 `.zshrc` 文件，添加以下选项：

```
setopt EXTENDED_GLOB
```

或者，如果你打算稍后再添加它，可以从终端调用它。正如我们将很快看到的，扩展 Globbing 是为了赋予像 `#` 这样的字符特殊含义，回想一下，这个字符通常用于注释。现在让我们动手试试看。

## 特殊模式

Zsh 丰富的功能还包括一系列快捷方式或特殊模式，旨在使日常任务变得更加容忍。在本节中，我们将熟悉这些功能。

### 递归搜索

可以说，最受欢迎的模式之一是递归搜索。通过 `**/` 组合可以访问到这个模式，它告诉 zsh 从当前目录开始进行递归搜索，并沿着目录树向内搜索。

例如，下面是我们如何在当前工作目录中查找所有 markdown 文件（通常具有 `.md` 扩展名的文件）：

```
% echo **/*.md
README.md brew/README.md git/README.md scripts/README.md zsh/README.md

```

另外还有`***/`这种写法，它告诉 shell 跟随符号链接。不过要小心，因为它可能会导致“文件名过长”这样的错误，这是操作系统告诉你，可能是兔子洞太深，或者你在某个地方有循环引用。

### 提示

请记住，像`find`或 The Silver Searcher ([`github.com/ggreer/the_silver_searcher`](https://github.com/ggreer/the_silver_searcher))这样的专业工具在处理目录递归时会比 shell 的机制更高效。因此，你应该避免依赖它来进行“重要”的操作。

关于使用递归模式表达式的注意事项，你可能最终会收到来自系统的“参数列表过长”警告。这通常意味着在展开`**/`模式时，shell 占用了太多的内存空间，这种情况通常出现在你有一个非常复杂的目录树时。如果你坚持使用递归展开的方式，解决方法是借助`xargs`将每个参数传递出去，如下所示：

```
% find **/*.md | xargs echo

```

我知道，这个例子有点傻，因为用一个简单的`find **/*.md`就能实现多行结果。这里的重点是让你了解如何通过`xargs`分隔结果并将它们`pipe`到`echo`中，所以请耐心一点。

最后，如果你想排除当前目录，可以使用某种技巧：

```
% echo */**/*.md

```

这样，只有包含`base_dir/any_dir`的文件名才会匹配该模式。

### 替代模式

当需要在两个选项之间做出选择时，然后又给出一个明显较差的第三个选项，确实会让人重新思考自己的决定……或者故事是这么说的。幸运的是，shell 不像我们这样复杂，我们可以为它提供一个模式选择，若一个失败，它可以选择另一个。我们通过使用带管道符号的括号构造来实现这一点，像下面这个例子：

```
% echo [[:upper:]]*.(md|txt)
README.md README.txt

```

我们继续搜索`README`文件，使用命名范围来指定我们想要的文件名，文件名前需要大写字母，后面跟上`md`或`txt`扩展名。简单吧？嗯，不完全是。小心不要让命令行以括号开头，因为这可能会让它们在子 shell 中运行。Zsh 足够智能，可以区分预期的用法，所以大多数时候你应该是安全的。但还是不要冒险。

在继续之前，需要提到的是，你不能在我们刚刚学到的组内替代项中使用包含`/`字符的模式。你已被警告！

### 数字范围

你可以让 shell 匹配它遇到的任何一系列数字，使用`<->`这种特殊模式。这个构造的优势在于，它能够匹配没有长度限制的任何一系列数字（这是因为 shell 会独立处理每个数字，而不是把它们当作一个整体的整数）。

以以下目录为例：

```
% ls
log.txt      log_002.txt  log_010.txt  log_031.txt
log_001.txt  log_009.txt  log_030.txt

```

我们想处理那些符合 `log_xxx.txt` 模式的文件，其中 `xxx` 是数字。让我们把刚才学到的知识付诸实践：

```
% echo log_<->.txt
log_001.txt log_002.txt log_009.txt log_010.txt log_030.txt log_031.txt

```

如果我们想要的是从 `10` 开始的日志文件呢？Zsh 可以帮你搞定：

```
% echo log_<10->.txt
log_010.txt log_030.txt log_031.txt

```

如你所见，`<->` 模式可以定义一个具有上下限的范围。让我们再试一次，这次匹配 `10` 到 `20` 之间的文件：

```
% echo log_<10-20>.txt
log_010.txt

```

这个表达式的另一个酷炫之处在于它不会考虑前导零，这使得你可以排序类似 `00010` 和 `00013` 的内容。说到这一点，还有 `NUMERIC_GLOB_SORT` 选项，你也可以设置它来输出任何模式匹配的排序数字匹配（并且是 *任何* 匹配，而不仅仅是数字范围模式）。

```
% setopt numericglobsort
% echo log_*
log_001.txt log_002.txt log_009.txt log_010.txt log_030.txt log_031.txt

```

### 重新审视插入符号运算符

如我们之前所见，插入符号（`^`）运算符用于否定模式（记住：“匹配任何不符合此模式的内容”）。这就是使用插入符号的另一种方式：

```
% ls
README.md  README.txt  bindings.c  bindings.h  bindings.o  main.c  main.o

% echo b^*.o
bindings.c bindings.h

```

所以基本上，我们告诉 shell 扩展该模式，以匹配以 `b` 开头但没有 `.o` 扩展名的文件名。

我们可以安全地说，`pattern^other_pattern` 表达式通过匹配第一个模式并避免匹配表达式中 `other_pattern` 部分来工作。不过，现在我们使用的这些具有不同含义的特殊字符，请记住要用单引号括起来你希望字面意义理解的名称或表达式，比如以下示例：

```
% echo '^c'

```

否则，你可能会自找麻烦。

### 波浪符运算符

类似于插入符号运算符的第二种用法，波浪符（`~`）运算符可以用于定义一个由应该匹配的部分和不应该匹配的第二部分组成的模式：

```
% ls
README.md  README.txt  bindings.c  bindings.h  bindings.o  main.c  main.o

% echo b*~*.o
bindings.c bindings.h

```

基本上，这只是两个模式的组合：`b*` 和 `*.o`，通过“不要匹配后续内容”运算符 `~` 连接。我们可以这样理解：“匹配以小写字母 b 开头且不匹配以 `.o` 结尾的所有内容”。

如果你还记得，我们用了 `b^*.o` 和插入符号运算符，所以如果使用波浪符，似乎更加直观。但别听我说的，试试看，举个例子，我们可以用波浪符排除临时目录中的文件：

```
% ls tmp
delete_me.sh  out.txt

% echo **/*.sh~tmp/*
src/script.sh

```

发生的情况是，shell 运行第一个模式（`**/*.sh`），并递归地检查所有具有 `sh` 扩展名的文件。初步结果是一个可能的文件名列表，接着与第二个模式（`tmp/*`）进行匹配。与后者匹配的文件名被从列表中移除，剩下的就是我们要找的文件名。

仅出于学术目的，可能是时候提一下，`**/` 等价于 `(*/)#` 模式。就目前而言，特殊运算符 `#` 将匹配一个重复的字符（在括号内），或者一个递归的表达式（在方括号内）。

## 通配符限定符

除了操作符，zsh 还拥有限定符，本质上是您应用于模式的过滤器，用以限制诸如仅匹配文件或文件夹、文件名的权限类型，甚至是此类条目的所有者。

所以下面的示例中，我们将列出所有与 `*tmp` 模式匹配的 *目录*。注意 `(/)` 构造，这正是直观地区分文件和文件夹的方式：

```
% echo *tmp(/) 
tmp

```

那么，仅匹配普通文件呢？公平的说，`(.)` 是您为仅限文件的限制设计的限定符。

```
% ls -F
README.txt  script.zsh  zsh/  src/

```

突然，一个神秘的文件名出现了：

```
% echo *zsh(.)
script.zsh

```

我们有一个 `zsh` 目录和一个扩展名为 `.zsh` 的脚本文件。通常，我们会使用 `echo *zsh` 来列出它们两个，或者如果我们只是寻找具有特定扩展名的文件，则会使用更具限制性的 `echo *.zsh`。然而，`(.)` 限定符无疑更适合复杂的树状搜索，或者在处理大量相似文件名和目录时更为高效。

以下是最常用限定符的“备忘单”：

+   `(N)`：如果没有找到匹配项，则移除参数，静默忽略错误。充当每个命令的 `NO_GLOB` 选项。

+   `(@)`：符号链接限定符。仅用于选择符号链接。

+   `(-@)`：上一个限定符的特殊变体。用于查找任何 *损坏的* 符号链接。

+   `(/)`：仅限目录。

+   `(.)`：仅限文件。任何不是链接、目录或之前提到的内容都会被此限定符选中。

+   `(*)`：可执行文件。目录不适用。可以把它看作是对那些拥有 `+x` 权限的文件的 `(.)`。

+   `(r)`：文件对当前 shell 用户可读。

+   `(w)`：文件对当前 shell 用户可写。

+   `(x)`：文件对当前 shell 用户可执行。

+   `(U)`：文件属于当前 shell 用户。

+   `(R)`：文件对任何人可读。

+   `(W)`：文件对任何人可写。

+   `(X)`：文件对任何人可执行。

+   `(u:root:)`：文件属于用户 `root`。您可以将 `:` 字符替换为任何其他符号对，如花括号：`(u{root})`。只要避免使用管道符号（`|`）即可。

+   `(on)`：按名称排序文件名。`echo *(on)` 的构造与 `ls` 类似。

+   `(On)`：按名称逆序排序文件名。

+   `(oL)`：按文件大小排序文件名。

+   `(OL)`：按文件大小逆序排序文件名。

+   `(om)`：按修改日期排序文件名。

+   `(Om)`：按修改日期逆序排序文件名。

和往常一样，随意混合搭配以增加趣味。例如，使用 `(*r^w)` 来查找当前用户可读但不可写的普通文件，或者使用 `(@,/)` 来查找符号链接或目录。

### 提示

渴望了解更多关于限定符的知识吗？亲爱的读者，别担心，来拥抱那神秘的力量……算了，我们还是使用 *上下文补全* 吧。

输入以下内容，并记得在打开括号后按 *Tab* 键：

```
% echo *zsh*<Tab>*

```

这将生成上下文补全，用于此处列出的 glob 限定符（以及更多！）。

接下来是更复杂的一组限定符，如时间戳和文件大小，它们需要更多的解释才能深入了解它们的使用方法。

### 时间戳限定符

Unix 系统通常会在其文件系统上记录三个时间戳：修改时间、访问时间和变更时间。考虑到这一点，你可以使用以下构造来匹配文件名：

```
% echo *(mh-1)

```

这将列出过去一小时内修改过的文件。你可以通过 `ls -l` 限定符轻松查看此结果。`m` 代表修改时间，这是你最常关注的时间戳类型。不过，你也可以检查过去一小时内的访问时间（`(ah-1)`）或创建时间（`(ch-1)`）限定符。

关于“过去一小时”这一部分，它由 `h-1` 限定符表示，其中 `h` 代表小时（是的，我知道），可以替换为分钟（`m`）、周（`w`）或月份（大写的 "`M`"）。请注意，这个限定符的默认单位是天，因此 `(m-1)` 意味着一天前，或者更准确地说，是当前系统时间前最多 24 小时。

同样，`+` 操作符可以翻译为“更多”，这样你就可以描述像 `(mw+3)` 这样的模式，这是一种简洁的表达方式，意思是“从今天起超过三周”。最后，你也可以通过结合这两个操作符来指定一个范围：

```
% echo *(m-5mh+2)

```

这将列出在五到两小时之间修改过的文件。

### 文件大小限定符

今天你将学习的最后一个限定符是文件大小。正如你可能已经猜到的，我们可以根据文件在磁盘上的大小来查询文件名：

+   `(Lm+size)`：文件大小大于 `size` 兆字节。例如：`(Lm+5)`——大于五兆字节。

+   `(Lm-size)`：文件大小小于 `size` 兆字节。例如：`(Lm-2)`——小于两兆字节。

+   `(Lk+size)`：文件大小大于 `size` 千字节。例如：`(Lk+5000)`——大于 5000 千字节。

+   `(Lk-size)`：文件大小小于 `size` 千字节。例如：`(Lm-2000)`——小于 2000 千字节。

# zmv 函数

在上一章中，我们学习了 `zle`；这是 zsh 用于处理命令行的模块。现在是时候利用我们新学会的 Globbing 技能，来了解 `zmv` 了，它是为了让复制、移动和链接文件变得更加轻松而创建的函数。

那么，你可能会问，zmv 是怎么回事？与普通的 `cp` 相比，这个内建函数有什么特别之处呢？zmv 的魔力在于它基于模式进行操作。此外，正如我们在本节中将要看到的那样，zmv 默认设计为安全的，这意味着它会在执行任何可能带来风险的操作（如覆盖文件）之前，要求你确认。

不过，在我们开始之前，你需要将以下内容添加到你的 `.zshrc` 文件中，记得要执行或重新启动你选择的终端模拟器：

```
autoload zmv
```

这将使 zsh 在启动时加载该函数，使其在会话中可用。现在你只需输入`zmv`，就能看到一套相当简单明了的指令。基本上，zmv 语法需要两个模式：一个用于匹配文件名，另一个用于将结果转换成的目标模式。

```
zmv [OPTIONS] old_pattern new_pattern
```

正如你可能猜到的，zmv 涉及大量的 Globbing，这就是为什么我们现在才开始了解它。下面是如何用它将`.txt`文件重命名为 markdown 文件（`.md`）：

```
% zmv -Wv '*.txt' '*.rb'
mv -- README.txt README.md

```

我们使用了详细的`-v`选项标志，因此我们可以从输出中获取更多信息。`zmv`函数通过展开两个模式，然后将实际功能委托给更强大的命令，如`cp`、`ln`，或者在这个特定情况下，`mv`。

你可以使用`-W`选项来自动转换通配符。结合`noglob`选项，你可以为`mv`命令增加一个全新的功能，这类似于 Windows 系统的`cmd`变体的特殊行为：

```
alias mmv='noglob zmv -W'
```

现在你可以在同一个调用中移动文件并重命名它们：

```
% mmv *.c.orig orig/*.c

```

对于适用于 zmv 的其他选项标志，以下是一些最相关的：

+   `-f`：强制覆盖目标文件

+   `-i`：每个操作的交互式提示

+   `-n`：不执行操作，仅打印将会发生的事情

+   `-v`：详细输出—在执行时打印每一行

+   `-w`：在模式中的通配符上隐式添加括号

+   `-W`：类似于`-w`，但将替换模式中的通配符转换为引用

不过，别想你需要记住这些选项。正如我们将在下一章看到的那样，你可以始终使用*Tab*键进行上下文补全，或者在 zmv 的特殊情况下，你只需输入`zmv`并按*Return*键，就能获得完整的选项列表。只要知道至少有几个选项可供你使用。

### 提示

你可以通过传递`-n`标志来执行通常所说的干跑操作。这将使 zmv 仅打印出将要执行的操作，而不真正执行。这是测试和调试脚本的最佳方式，避免了……你知道的，慌乱的发生。

```
% ls foo
% zmv -n '(*)' '${(U)1}''mv -- foo FOO
```

如果你需要更高级的用法，可以使用多个表达式，例如`old_pattern`参数。匹配这些的文件名将被分组，并可以通过`new_pattern`表达式（按照`$1`、`$2`等模式）访问。例如，我们可以使用以下方法在文件夹树上递归重命名图片，以便它们的扩展名全部为小写：

```
% zmv '(**/)(*).(#i)jpg' '$1$2.jpg'

```

总结一下，通过一些 Globbing 和练习，你可以充分利用 zmv。你只需要一个合适的模式来匹配，并且有一个字符串来实际使用该模式。`zmv`实际上会忽略在扩展过程中没有改变名字的文件，它甚至不关心目标是否应该是一个目录还是一个普通文件。

### 提示

你可以通过输入`man zshcontrib`来访问 zmv 的高级文档。

# 总结

这是我们旅程的一个阶段，需要我们收拾东西，结束这一章。不过，这次我们从把 Globbing 当作“像正则表达式一样”的工具开始，最终理解它实际上是完全不同的东西。幸运的是，一旦我们学会了最常用的操作符和限定符的行为，那个“怪兽”就变得相当容易驯服。随后，我们通过更多的特殊模式扩展了这些构造，并且了解了**zmv**，使得我们的大部分日常任务变得轻松自如。总结来说，我们可以说我们：

+   学习了引号、转义符号以及双引号与其中的 shell 扩展。

+   开始了命令行中的全局匹配和参数替换。

+   提升了技巧，深入学习了扩展 Globbing，了解了递归搜索、否定和排除模式的操作符。

+   我们了解了全局限定符，如何使用它们根据系统时间和文件大小来区分文件。

+   最后发现了 zmv，它让我们将前面提到的所有内容结合起来，让处理复杂的文件名变得像散步一样轻松。

看起来到目前为止我们已经学到了很多，这些内容可以满足我们大部分的需求。如果我可以这么说的话，这其实是一个不错的交易。实际上，我可以这么说，因为这正是戴上写作者帽子的一大好处。

下一章将介绍补全功能。到目前为止，我们已经取得了相当不错的进展，所以我不会对你说谎（再一次）；补全实际上就是让大多数人一试成主顾，永不回头的原因。你目前尝试过了一部分，但更多的精彩内容就在这一页等着你。

接下来是第五章，*补全*。快点！
