# 第一章. 入门

那么，Z shell 到底有什么特别之处呢？你大概已经对现代 shell 有了一个清晰的概念，因此像命令历史、补全和自动修正这样的功能可能不会像那些刚刚发现 Bash 的人那样让你惊讶。然而，与其他可用的 shell 相比，Z shell（zsh）拥有一个非常强大的脚本语言和令人惊叹的补全系统。其实，用“惊叹”都无法形容它的强大，“快速而轻松”可能更为贴切。zsh 还融合了 Bash、ksh 和 csh 中的许多有用功能，甚至可以在脚本中模拟这些 shell，以增加额外的兼容性。

一旦你发现了多行编辑或开始依赖自动拼写修正，我保证你会回头看看自己以前用键盘乱按按钮的日子，想知道为什么没有早点切换到 zsh。所以，让我们开始吧，好吗？

本章将从了解 zsh 开始，我们会快速浏览一些使其与众不同的功能。不过，在我们开始冒险之前，我们需要安装并配置新的 shell，确保一切顺利运行。接下来，我们将进入配置部分——启动文件是什么，如何使用不同的样式、转义序列和条件表达式来自定义提示符。

# 安装 zsh

和你系统中的大多数东西一样，zsh 也需要安装和维护；因此，在本节中，我们将学习如何进行安装。不过需要注意，为了避免引入不一致性或不兼容问题，安装 zsh 的推荐方式是直接从你的软件包维护者提供的源进行安装。可以参考系统文档，或者访问 zsh 的主页（[`zsh.sourceforge.net`](http://zsh.sourceforge.net)）了解整个安装过程。

在开始之前，最好检查一下是否需要安装或更新当前的 zsh 安装，因为某些 Unix 系统可能已经安装了该软件包。打开你喜欢的终端模拟器，并输入以下命令：

```
$ echo $SHELL

```

这应该会在大多数系统上输出类似`/bin/sh`或`/bin/bash`的内容，这意味着你当前的登录 shell 不是 zsh。如果结果中显示的是`zsh`，那么可以继续执行以下命令：

```
$ zsh --version
zsh 5.0.2 (x86_64-apple-darwin12.3.0)

```

如果运气好（当然，你的系统更新工作也得做好），你应该会看到 zsh 的版本信息，类似于之前的代码片段。如果是这种情况，你可以跳过本节内容。如果你的操作系统提示你**未找到 zsh**，也没关系，这样的话你才会看到这些内容。让我们进入安装部分吧，好吗？

### 注意

本书中将以最新的稳定版——截至本书写作时为版本 5.0.2——作为参考。因此，如果你运行的是早期版本，建议尝试更新你的现有安装。请参阅你的包管理器文档以更新 zsh。

## 在 Linux 上安装

根据你当前使用的 Linux 发行版，zsh 可能（或可能不会）在其软件仓库中，或者更好的是，已经安装在你的操作系统中。在极少数情况下，如果 zsh 不可用，你应始终查阅操作系统的包列表。

在 Debian 及其众多衍生发行版（如 Ubuntu 和 Linux Mint）上，你可以通过打开终端并运行以下命令来完成整个安装过程：

```
$ sudo apt-get update
$ sudo apt-get install zsh

```

根据你的 Debian 版本及其软件仓库，你可以获得从 4.3.x 到 5.0.0 及更高版本的 zsh（至少在使用当前发行版时是如此）。再次强调，尽可能使用最新版本。

### 提示

你可以通过在终端中运行 `zsh --version` 来检查 zsh 的版本。

基于 Red Hat 的发行版，如 Fedora，你需要输入以下命令：

```
$ sudo yum check-update
$ sudo yum install zsh

```

然后是 openSuSE 用户：

```
$ sudo zypper refresh
$ sudo zypper install zsh

```

让我们也不要忘记 Arch 用户：

```
$ sudo pacman -S zsh

```

等待下载和安装脚本/触发器完成后，可以跳到下一节。

## 在 OS X 上安装

可以说，在 OS X 上获取 zsh 的最简单方法是通过 Homebrew ([`www.brew.sh`](http://www.brew.sh)) 或 MacPorts ([`www.macports.org`](http://www.macports.org))，这两款包管理器旨在扩展 OS X 用户可用的默认选项。不幸的是，这两个选项都没有捆绑在 OS X 中。你需要先安装其中一个解决方案，然后才能使用最新版本的 zsh（截至本书写作时仍为 5.0.2）。所以，打开你喜欢的终端模拟器，输入以下命令：

```
$ brew install zsh

```

或

```
$ sudo port install zsh

```

等待下载和安装脚本完成后，直接跳到下一节。同时，请参阅每个应用程序的文档，以排查安装过程中可能出现的任何问题。

## 从源代码编译

zsh 的官方网站位于[zsh.sourceforge.net](http://zsh.sourceforge.net)，你应该在浏览器中访问该网址，开始你的构建之旅。不过请记住，获取系统 zsh 二进制文件的推荐方法是通过已编译的二进制包。如果因为某些原因你想要获得最新的版本，并且不介意处理比稳定版本更多的 bug，你很可能需要使用 Git 版本控制软件克隆仓库：

```
$ git clone git://git.code.sf.net/p/zsh/code zsh

```

确保你检出了并跟踪了 master 分支，因为最新的更改都已经提交到该分支。还要记住，在你构建本地的 zsh 副本之前，有一些依赖项需要满足。这些依赖项都在已克隆到你磁盘上的多个配置文件中有详细文档说明，因此在尝试构建配置脚本等操作之前，最好仔细查看 `README` 文件。

### 注意

在你的平台上安装 Git 超出了本书的范围，但请放心，你按照[`www.git-scm.com`](http://www.git-scm.com)上的说明操作时不会遇到任何问题。

# 首次运行

现在 zsh 已经安装在你的系统上了，我们来试试它怎么样？打开你喜欢的终端模拟器，输入以下命令：

```
$ zsh

```

和许多其他应用程序一样，zsh 也有一个首次运行向导（请耐心点，它几乎像是一个向导）。它是一种神奇的工具，唯一的目的就是帮助我们通过一连串的问题和决策快速配置我们的工具。我们这次跳过新用户配置，但你可以根据自己的需要选择适合你的方法，要么一项一项地回答问题，要么直接按 *Q* 来中止操作。只需记住，`newuser` 模块在 `<zshInstallFolder>/Functions/Newuser/zsh-newuser-install` 或 `<zshInstallFolder>/functions/zsh-newuser-install` 中可以找到——如果将来需要它的帮助，随时可以使用。

为了避免每次运行时都跳过配置选项，你可以创建一个所谓的 *启动文件*：

```
% touch ~/.zshrc

```

我们刚刚创建了主偏好文件；问题是，它目前是空的。我们接下来加一些偏好设置，好吗？

### 注意

在文中会多次提到 zsh 的选项——这些设置会改变 shell 的行为——因此，现在是时候为它们制定一些约定了。首先，命名规则有些过于宽松——它是区分大小写的，并且忽略下划线。所以，以下两个选项名称是等同的。

`SOME_OPTION` 和 `SOMEOPTION`

其次，试着将选项看作是 *开关*。顾名思义，它们可以被 *开启* 或 *关闭*。在 zsh 提供的众多切换选项的方式中，最容易记住的可能就是 `setopt`/`unsetopt` 组合。

```
setopt SOME_OPTION # enables any option.
unsetopt SOME_OPTION # use this to disable an option.
```

相反，你可以通过在选项名前加上 `NO` 来否定该选项的行为，从而使 `unsetopt SOME_OPTION` 与 `setopt NO_SOME_OPTION` 或者考虑到下划线仅仅是为了便于人类阅读，等同于 `setopt NOSOMEOPTION`。

为了避免混乱，并且因为我喜欢标准化，我们将在本书中使用 `ALL_CAPS_SNAKE_CASE` 来表示选项。

用你喜欢的编辑器打开 `~/.zshrc`；你可以使用 vim、Emacs、nano 或者现在孩子们喜欢的任何编辑器，添加以下一行：

```
autoload -U promptinit # initialize the prompt system promptinit

```

让我们回顾一下刚才输入的内容：代码的第一行是我们告诉 shell 启动其 `promptinit` 模块的方式——这是一系列处理 shell 各种提示符和功能的函数。井号后面的内容仅是一个注释，用来提醒你该命令的作用和它为什么在这里。最后一行才是实际调用和初始化提示符模块的代码。看起来可能不算什么，但当你处理提示符时，它会派上用场，我保证。

随时可以省略注释，并确保保存更改。

### 注意

Zsh 会忽略每一行以井号（`#`）——或称为磅符——开头的内容。这对于调试首选项非常有用，更好的是，它可以帮助你记录功能。请看下一个例子，其中的注释以粗体显示：

```
# This is a comment and will be ignored by the shell.
HISTFILE=~/.zsh_history # sets the location of the history file

```

## 将 zsh 设置为登录 shell

如果有一件事 shell 会认真对待，那就是它们的角色。你看，shell 的问题是它们喜欢被分为非常特定的类别——它们要么是交互式的，要么是非交互式的，然后还有登录 shell。

正如你从它们的名字中可能猜到的，*交互式 shell* 允许你与它们进行交互；也就是说，它们会显示一个提示符，你输入一个命令，然后它们会返回一个答案，并准备好接受新的输入。另一方面，应用交互式 shell 会在执行脚本时被调用，并在完成任务后自行退出。

### 注意

简单来说，提示符通常是闪烁的光标，告诉你 shell 已准备好接受输入。

那么，登录 shell 怎么样呢？好吧，不像交互式 shell，*登录 shell* 通常在用户登录时被调用——无论是在本地计算机上，还是使用像 SSH 这样的工具——并且会仔细读取你的启动文件和配置项。更重要的是，登录 shell 不一定需要是交互式的。

在上一节中，我们使用了直接调用二进制文件 `zsh` 来启动 zsh。正如你可以想象的那样，这只是一个临时的解决方法，因为每次我们想使用它时都输入 shell 的名字，显得有点不切实际。更糟糕的是，你会想到前一个 shell 可能还在后台等待，一旦你结束使用 zsh，它就会准备好重新跳出来。如果你不相信我，可以输入 `exit`；我等着你。看到屏幕上显示的那个吗？那就是你以前的命令行伴侣。和它说再见后，输入 `zsh` 并按 *回车* 重新进入 zsh。

所以接下来要做的就是——你猜对了——摆脱你那个旧的 shell，省去每次想用 zsh 时都要记得调用它的麻烦。

### 注意

你可以通过在启动 zsh 时使用 `-l` 或 `--login` 标志，欺骗 zsh 和许多其他 shell，使它认为自己是一个登录 shell。打开终端并输入以下命令之一：

```
$ zsh -l
```

或

```
$ zsh --login
```

Voilà！一个带有登录功能的 shell。

幸运的是，Unix 的 `chsh` 命令似乎正是医生推荐的那个，所以请在终端中键入以下命令：

```
$ chsh -s $(which zsh)

```

在上一段代码中，我们告诉系统为当前用户更改 shell。这里使用的 `-s` 选项是用来指定 shell 二进制文件的位置的。你看到的那个复杂的 `$()` 构造是我们告诉 shell 展开括号内命令的结果，这个命令就是 `which zsh`。

你可能还记得上一节中提到的 `which`，我们用它来找出现有 zsh 安装的位置。`which` 的作用是大声宣布用户 `$PATH` 环境变量中任何程序文件的位置。因此，我们可以安全地假设，如果 `zsh` 不在其中，说明某个地方出了问题，或许我们应该回头再检查一下。

很可能，更改登录 shell 会要求以提升的权限运行该命令，因此确保你使用的是具有适当权限的账户。

从现在开始，每次启动你选择的终端模拟器时，系统都会默认启动 zsh。很可能，你已经安装并将 zsh 设置为登录 shell。接下来就是对其进行调整。

## Shell 选项

除了通过 `-l` 标志欺骗 zsh 使其认为它是一个登录 shell 外，还有许多其他有用的选项可以在启动时设置。例如，`zsh -v` 将开启详细模式，这会让 shell 在执行任何命令前先打印出该命令的内容。然后，还有 `zsh -x` —— 即 `xtrace` —— 在调试脚本时非常有用，或者 `zsh -f` 会使用默认设置启动一个干净的 zsh 实例。

这些选项中的任何一个也可以在 shell 启动后设置；你只需要通过 `set` 命令调用所需的选项标志。下面的示例在一个正在运行的会话中启用详细模式：

```
% set -v
% echo 'quite the echo in here'
> echo 'quite the echo in here'
> 'quite the echo in here'

```

### 提示

**下载示例代码**

你可以从 [`www.packtpub.com`](http://www.packtpub.com) 下载所有你购买的 Packt 书籍的示例代码文件。如果你是在其他地方购买的这本书，可以访问 [`www.packtpub.com/support`](http://www.packtpub.com/support) 并注册，以便直接通过电子邮件接收文件。

此外，你还可以使用相同的 `set` 命令禁用任何选项，只需将减号/负号替换为加号，如下所示：

```
# disables verbose mode
% set +v

```

有关各种 shell 选项及其使用方式的更多信息，请参阅 `zshoptions(1)` 手册页（`man zshoptions`）。

## 启动文件

和大多数登录 shell 一样，zsh 依赖一系列配置文件，称为 *启动* 文件，这些文件包含了在 shell 启动过程中需要执行和设置的命令和偏好设置。我们在前面章节使用了 `.zshrc` 文件，以避免被 `newuser` 函数打扰，但既然现在我们已经把 zsh 设置为登录 shell，是时候仔细看看我们可以用这些文件做些什么了。

### 注意

默认情况下，zsh 会在用户的主目录（`$HOME`，或其别名，更常见的是波浪号`~`，在本文本中我们交替使用它们作为当前用户主文件夹的路径）下查找启动文件。你可以通过在`$HOME`下的`.zshenv`文件中设置参数`ZDOTDIR`来告诉 zsh 去另一个目录查找配置文件：

```
ZDOTDIR=/etc/my_kewl_folder/.zshrc
```

在启动过程中，zsh 会在`/etc/`下查找，或称为*源文件*，一组特定的系统和用户文件名。紧接着，每个文件都有一个用户可编辑的副本，通常位于`$HOME`下，会被读取。然而，有一些规则可能会让 zsh 完全跳过这些文件。文件的顺序非常重要，因为在错误的文件中设置选项可能导致命令在错误的时间执行，产生一些奇怪的行为。因此，在设置文件偏好时，请记住以下顺序：

+   `zshenv`

+   `zprofile`

+   `zshrc`

+   `zlogin`

如果 zsh 没有作为交互式 shell 调用，`zprofile`和`zshrc`以及它们在`$HOME`中的对应文件（`~/.zprofile`和`~/.zshrc`）将不会被源文件。除此之外，如果 zsh 没有作为登录 shell 调用，`zlogin`和`$HOME/.zlogin`也会被跳过。

### 注意

根据你安装 zsh 的方式，在查找全局文件时，除了`/etc/`目录外，可能还会使用其他目录。

通常，你只希望修改自己用户的偏好设置，所以我们将重点关注位于`$HOME`下的启动文件，具体如下：

+   `~/.zshenv`：这将在`/etc/zshenv`之后立即被调用。你应该仅添加诸如`PATH`设置和任何你希望对任何类型的 shell（无论是交互式的还是非交互式的）都可用的内容。

+   `~/.zprofile`：这是`/etc/zprofile`的配套文件，是启动文件组中比较“无聊”的一个。你应该在这里放置任何希望在`~/.zshrc`之前执行的脚本。

+   `~/.zshrc`：这是你的“主力军”。大部分的用户设置和 shell 偏好会放在这里。请记住，它只会在交互式 shell 中生效。正如我们稍后所看到的，你可以通过调用多个文件来简化并扩展它的作用。

+   `~/.zlogin`：这将在`~/.zshrc`之后执行，基本上与`~/.zprofile`类似，所以你应该把希望在主启动文件后调用的脚本放在这里。

在启动文件的对立面，还有*关闭*文件。正如你所想的，这组相对较小的文件不仅按照特定的顺序调用，而且会在登录 shell 的注销序列中调用。关闭文件可以视为启动文件的子集，所以不必为此失眠。需要记住的重要一点是，当你在命令行输入`logout`时，用户可配置的`~/.zlogout`文件中的设置会被读取，然后是安装文件`/etc/zlogout`。

你可以使用 `RCS` 和 `GLOBAL_RCS` 选项来禁用启动文件的加载机制。这个偏好必须在系统文件 `/etc/zshenv` 中取消设置，如下所示：

```
unset RCS # disables loading of files other than zshenv
unset GLOBAL_RCS # disables loading of files under /etc/
```

例如，如果 `zshenv` 中取消设置了 `RCS` 选项（这是第一个被读取的文件），`~/.zshenv` 和所有其他文件将被跳过。但请记住，这两个选项可以被你加载的任何后续文件重新启用。

例如，如果你在 `/etc/shenv` 中有以下内容：

```
unset RCS
source my_options_file.zsh

```

然后，在 `my_options_file.zsh` 中添加：

```
# some more options here
set RCS

```

然后，shell 会继续加载 `.zshenv` 文件，仿佛什么都没发生过。所以，务必小心！

我们已经查看了启动文件及其严格的加载顺序；现在，到了深入了解提示符的时刻。

# shell 提示符

给任何人足够的时间使用 shell，"如何给它添加颜色？"这个问题迟早会出现。幸运的是，zsh 提供了大量的配置选项和转义序列，让你能够实现这一目标，甚至更多。在本节中，我们将深入探讨你可以用来定制提示符的选项。

## 提示符命令

Zsh 提供了丰富的预定义提示符配置，可以作为构建更符合你需求的主题的基础。除了其他内容，`prompt` 工具允许你选择你喜欢的主题。在默认安装中，各种主题和用户贡献位于 `<zshFolder>/Functions/Prompts`（或在 OS X 中的 `<zshFolder>/functions`）目录下，并遵循命名规则 `prompt_<theme>_setup`。要查看默认包中包含的内容，只需输入以下命令：

```
$ prompt –p

```

然后，你将看到一个包含所有 zsh 提供的可用提示符主题的列表。你可以使用 `-p` 选项和主题名称一起，仔细查看任何主题：

```
$ prompt -p 

```

为了使用 `prompt` 函数，你需要在 shell 中设置 `promptinit` 模块。最简单的方式是将其添加到 `.zshrc` 文件中。如果你还没有设置，请查看 *第一次运行* 部分。

### 注意

你可以参考 `zshcontrib(1)` 手册页中的 *PROMPT THEMES* 部分，获取关于 zsh 提示符的更多详细信息。在终端中输入 `man zshcontrib` 来开始。

你可以试用任何你喜欢的主题，通过输入以下命令将其暂时应用到当前的 shell 中：

```
$ prompt <theme_name>

```

一些主题，如 `adam1`，甚至可以接受一些额外的配置参数，如下所示：

```
$ prompt adam1 red yellow magenta # sets the 'adam1' theme

```

默认情况下，zsh 不太喜欢在命令行中输入注释。幸运的是，你可以通过在 `.zshrc` 文件中设置以下选项来改变这一行为：

```
setopt INTERACTIVE_COMMENTS  # allow inline comments like this one

```

在前面的代码段中，我们向主题传递了一系列选项，特别是颜色 `red`、`yellow` 和 `magenta`。你可以通过调用任何给定主题的内置帮助，获得对每个提示符主题的更详细描述：

```
$ prompt -h <theme_name>

```

尝试在你喜欢的主题上使用这些设置，看看能调整出什么其他效果。

一旦你找到一个适合你的组合，你就可以保存这些更改。只需用编辑器打开 `.zshrc` 文件，并添加以下行：

```
autoload -U promptinit
promptinit
prompt adam1 red yellow magenta

```

我们拿到了之前的偏好设置文件，并在默认提示符`adam1`中加入了一些颜色。那么，如何调整它，让它更像家一样呢？

### 注意

如果你在之前的 shell 中已经投入了大量时间来定制你的提示符，那么在将其迁移到 zsh 时，弄清楚不同的规则集可能会让你感到头痛。幸运的是，zsh 提供了一系列工具，使得这个转换过程更为顺利。你可以在 `<zshFolder>/Misc` 文件夹下找到 `bash2zshprompt` 或 `c2z` 脚本，分别用于迁移 Bash 或 csh 的偏好设置。不过需要注意的是，一些发行版可能没有包含这些脚本，在这种情况下，你可以直接前往官方仓库，获取本地副本。关于如何获取 zsh 源代码，请查看*从源代码编译*部分的详细信息。

## 自定义提示符

Zsh 提供了五种不同的提示符，你可以根据需要进行调整，每种都有其特定的用途。虽然在大多数使用场景下你可能不需要担心这些提示符，但了解它们的作用仍然是很重要的。关于每个提示符的详细描述，我建议你查看 `man zshmisc`。

Zsh 喜欢将其主要提示符变量称为 `$PS1` 或其别名 `$PROMPT`（也可以是 `$prompt`）。不过可以放心，这三者实际上是一样的，zsh 对它们的处理是相同的。然后还有 `$RPS1`，它会在屏幕右侧打印提示符。与其他提示符不同的是，它会在需要行宽时自动消失。

`$PS2` 会在 shell 等待更多输入时显示，例如在某些未完成的语法结构开始时，或者在命令行中添加内联注释时。`$PS3` 用于在 `select` 循环控制机制中进行选择。最后但同样重要的是，`$PS4` 在调试脚本时非常有用。

总的来说，这些就是我们将要使用的工具集，通过一组巧妙的工具——转义序列，扩展其功能，超越基本设置。

### 提示

你可以随时使用 `source` 命令重新加载你的 zsh 配置文件。只需保存更改并运行以下命令：

```
$ source file_path/file_name
```

如果你的文件路径中包含空格，记得使用双引号。

```
$ source "random folder/.zshenv"
```

## 使用转义序列

转义序列是一组预定义的信息快捷方式，可以添加到 zsh 的提示符设置中。它们可以显示信息，例如你登录的机器名称、系统的当前日期和时间，甚至是当前工作目录。大多数转义序列是通过模组或百分号（`%`）操作符来定义的，有些甚至接受可选参数，进一步扩展其功能。

要使魔法生效，我们首先需要在配置文件中添加一个新设置。打开`.zshrc`并添加以下行：

```
setopt PROMPT_SUBST

```

通过这样做，我们启用了`PROMPT_SUBST`选项。这样，zsh 会将`$PROMPT`视为普通的 shell 变量，并在命令替换、参数和算术扩展时进行检查。

接下来，我们将介绍许多可用的转义序列及其含义。请记住，这绝不是所有可用选项的完整列表；因此，如果您需要更全面的可用选项列表，随时可以查阅`zshmisc(1)`手册页，特别是标题为*Prompt Expansion*的部分。

### Shell 状态选项

以下选项作为当前 shell 状态的一些指示符：

+   `%#`：如果 shell 正在以提升权限运行，则显示`#`，否则显示`%`。

+   `%?`：显示最后执行的命令的退出状态代码。

+   `%h` 或 `%!`：显示当前历史事件编号。

+   `%L`：显示当前`$SHLVL`变量的值。

+   `%j`：显示当前正在执行的作业数量。

### 登录信息选项

以下选项显示有关当前 shell 正在运行的主机和机器的更多有用信息：

+   `%M`：显示机器的*主机名*。

+   `%m`：与前者相同。主机名会显示到第一个点（`.`）分隔符为止。它接受一个可选的整数，表示要显示的组件数量。

+   `%n`：与打印环境变量`$USERNAME`的效果相同。

### 目录选项

以下选项提供关于当前工作目录（`$PWD`）和文件系统目录的信息：

+   `%d` 或 `%/`：显示当前目录。与打印`$PWD`环境变量一样。

+   `%~`：与前者相同，但如果当前目录是`$HOME`，则显示`~`。

+   `%c` 或 `%.`：列出与`$PWD`相对的目录数量。它接受一个整数作为参数。因此，`%2c`会显示`$PWD`前面的两个目录。

+   `%C`：与前者相同，但目录名不会被任何符号替代。

### 日期和时间选项

以下选项提供杂项的日期和时间信息：

+   `%D`：以`yy-mm-dd`格式打印当前系统日期。

+   `%W`：与前者相同，但以`mm/dd/yy`格式显示。

+   `%w`：显示`day-dd`格式的日期。

+   `%T`：显示当前时间，24 小时格式。

+   `%t` 或 `%@`：与前者相同，使用 12 小时制，am/pm 格式。

+   `%*`：与前者相同，也显示秒数。

### 文本格式选项

与之前的转义序列不同，这些需要围绕提示符的目标部分打开和关闭。也就是说，为了给`word`加下划线，你需要输入`%Uword%u`。特别注意开头（大写字母）和结尾（小写字母）转义序列的大小写差异，如下所示：

+   `%U %u`：这启用下划线模式。

+   `%B %b`：这启用粗体模式。

+   `%K %k`：这设置背景颜色。使用方式如`%K{red}%k`。

+   `%F %f`：与前面的相似，但应用于*前景*颜色。

+   `%S %s`：这启用*突出显示*（高亮）模式。

处理转义序列时，`%`和`)`在 zsh 中都是有些特殊的；因此，如果你需要在提示符中显示字面上的`%`，记得输入`%%`。同样，字面上的`)`应该输入`%)`。这种技术通常被称为*转义字符*。

### 注意

你可以在 zsh 配置中启用`PROMPT_BANG`选项，以便在提示符中使用感叹号（`!`），从而显示当前的历史事件编号，而无需转义（`%!`）。只要记住，当你需要一个字面上的`!`时，输入`!!`。

```
setopt PROMPT_BANG # enables '!' substitution on prompt
```

## 条件表达式

我们将通过查看可用于条件扩展的转义序列来结束我们的转义序列之旅。不过幸运的是，大部分内容可以总结为以下的三元表达式：

```
%(X.true-text.false-text)

```

基本上，这意味着如果条件`X`为真，执行`true-text`中的内容，否则执行`false-text`中的内容。需要记住的重要一点是，你应该用`%()`包裹你的表达式，而且你看到的点（`.`）是完全随意的，意味着你可以将它们替换成任何字符。

关于`true-text`/`false-text`表达式，手册页（例如当你访问`man zshmisc`时）告诉我们，它们可以替换为类似`!`的符号。如果 shell 在有权限的情况下运行，那么它将评估为 true，或者是`?`，而`?`前可以跟一个整数*n*，只有在最后一个命令的退出状态匹配时才会评估为`true`。因此，为了将`#`作为你的主提示符，显示是否正在以提升的权限运行，你可以发挥想象，得到如下内容：

```
PS1=%(!.#.>)

```

同样，你可以使用以下行来包装最后运行命令的退出状态，如果它不等于`0`，也就是说：

```
PS1=%(?..(%?%))

```

## 把所有内容组合起来

正如你现在已经非常清楚的，zsh 的提示主题内置了许多强大的功能。实际上，它们如此之多，以至于大多数情况下我们自己定制的解决方案可能会让人觉得是在重新发明轮子。不过，我们仍然需要尝试自己构建一个提示符；那么，如何利用其中一个现有的主题作为起点呢？

导航到你的 zsh 安装文件夹或仓库克隆，进入 `Functions` 下的 Prompts 文件夹。正如我们之前所看到的，所有提示符都附带一个名为 `prompt_<theme_name>_setup` 的设置函数。找到 SuSE 主题的设置文件并打开它，它很可能位于 `prompt_suse_setup` 下。

你看到的其实是一个与文件同名的 shell 函数。只需调用一次这个 `prompt_suse_setup` 函数，并且不传递任何参数，就能完成两个赋值操作——一个是为 `PS1` 提示符赋值，另一个是为 `PS2` 提示符赋值。请查看下面这个为示例格式化的代码：

```
PS1="%n@%m:%~/ > "
PS2="> "

```

那么我们开始动手修改这个提示符吧！打开你的 `.zshrc` 文件，并记住，你将在 `promptinit` 调用后添加以下这一行。我们可以从突出显示用户名开始，就像在 `adam1` 提示符中一样：

```
PS1="%K{yellow}%n%k@%m:%~/ > "

```

如果你还记得前一部分，`%K%k` 转义序列定义了背景色。代码中高亮显示的部分，我们将转义序列 `%n` 包装起来，给当前会话 `$USERNAME` 添加背景色。在 `@` 符号右侧仍然是机器名称的简短版本，当然，还有一些炫酷的行指示符。

我们来为右侧添加一个错误标志，这样就可以立即检查是否有异常的命令退出码：

```
RPS1="%(?..(%?%))"

```

如果你愿意的话，可以通过调用一个会异常退出的程序来测试我们全新的右侧提示符。记住，退出状态为 0 是可以的；其他任何状态都会触发我们的提示符。像 `ls some_nonexistent_folder` 这样的命令应该就足够了：

```
gfestari@machine:~/ > ls nonexistent_folder
ls: cannot access nonexistent_folder: No such file or directory
gfestari@machine:~/ >                                  (2)

```

你可以像我们为 `PS1` 所做的那样，在右侧提示符中添加一些颜色。当你完成调整后，尝试使 `.zshrc` 文件尽可能与以下代码相似：

```
autoload -U promptinit
promptinit

PS1="%K{yellow}%n%k@%m:%~/ > "
PS2="> "
RPS1="%(?..(%?%))"

```

在前面的示例中，我们保留了 `autoload -U promptinit` 和 `promptinit` 调用，因此当你最终需要使用它时，提示符模块会被加载并准备好。需要注意的是，除非你打算使用 `prompt` 模块，否则不需要同时调用这两个命令。

保存文件并重新加载 zsh 配置。我们通过再次加载 `.zshrc` 文件来完成此操作。不过要小心，这可能需要一些时间，具体取决于你可能添加的其他文件链接：

```
% source ~/.zshrc

```

### 提示

`source` 有一个更加简洁的兄弟：点（`.`）别名。现在你已经认识了他，可以自由地执行类似以下操作：

```
% . ~/.zshrc
```

我们不妨利用终端模拟器窗口的整个宽度？你知道的，因为是宽屏显示。

一个特别有用的屏幕帮助是当前目录快捷方式，回想一下，它可以是 `%~` 或 `%d`。那么，如何在懒惰的右侧提示符中添加更多上下文信息呢？

```
RPS1=%~

```

来吧，我知道你不会以为它就这么简单吧？我们在这里添加了功能，所以不只是简单地丢掉退出状态指示符。想一想，我们还需要将当前工作目录添加到右侧的提示符中。你最初的猜测可能是类似以下命令：

```
# this won't work!
RPS1=%(?..(%?%)) %~

```

这几乎是完美的，除了它不会立刻生效。

```
% source .zshrc
> job not found: ~

```

真糟糕！不过，有个小细节缺失了，那就是双引号的使用。没错，我们可以通过 shell 的字符串处理，巧妙地让空格通过，而不报错，只需要使用双引号，像这样：

```
RPS1="%(?..(%?%)) %~"

```

这将告诉提示符函数直接使用 `RPS1` 变量，而不必担心解析多个参数。

就这样，你已经在全新的 zsh 安装中拥有了自己的提示符版本。不过，你可能会想知道我们留在那里的第二个提示符是怎么回事。我会留给你自己决定它的命运，因为我真的很喜欢现在这个老派的 `>` 指示符。

然而，在我们完成这一章之前，我想指引你查看 `zshcontrib(1)` 手册页中的 *PROMPT THEMES* 部分。若想获取更多关于创建自定义提示符主题的详细信息，可以在你喜欢的终端模拟器中输入 `man zshcontrib`。

# 总结

在这一章中，我们深入了解了 zsh，学习了它的基础特性，并将你的前一个登录 shell 替换成了新的 zsh 安装。我们甚至还更进一步，通过使用各种转义序列和配置选项定制了提示符，加入了一点自家风味。由于我的记性真的很差，这里列出了到目前为止涵盖的内容：

+   我们学习了如何配置和设置 zsh，因此可以抛弃当前的 shell，用全新的 zsh 安装替换它。

+   我们了解了启动文件，现在我们清楚了在终端模拟器窗口出现在屏幕上之前幕后发生的事情。

+   我们熟悉了 shell 提示符，发现 zsh 提供了远超表面功能的内容。

+   我们更进一步，学习了转义序列和条件表达式后，定制了提示符。

现在，你的系统应该已经完全准备好迎接接下来的冒险了。不过，我们还有很多内容要覆盖，所以最好开始下一章 *别名与历史记录*，在这一章中，我们将学习 `alias` 机制，如何为功能创建自己的快捷方式，还会开始使用 shell 的历史记录日志。
