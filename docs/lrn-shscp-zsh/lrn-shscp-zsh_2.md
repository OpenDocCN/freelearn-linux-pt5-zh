# 第二章 别名与历史

在本章中，我们将扩展 zsh 的基础知识，并重点介绍别名，这是最节省时间的功能之一。我们将仔细研究别名如何工作，学习如何用简短的版本替代冗长且无聊的命令，并在启动文件中自动化整个过程。接下来，我们将学习大括号展开，以便在可以避免时减少输入的按键。我们将学会如何使用 zsh 的历史记录和历史展开机制，并将这些新功能融入到工作流中。

# 使用别名

*别名* 是一种替代说法，表示同样的意思。可以把它看作是命令的昵称。尽管与聚会后可能获得的尴尬绰号不同，shell 提供的别名机制是一个快捷方式，可以用更友好的名称执行一系列命令和选项。别名的核心目的就是做得更多，*最好是输入更少*。

我敢打赌我刚刚用那个“输入更少”部分吸引了你的注意。让我解释一下：

`ls` 命令用于列出目录的内容。快速查看它的手册页（`man ls`）告诉我们，这里有不少选项：

```
ls -a # lists all files, even those hidden that start with a dot
ls -l # shows more information for each file, like size and permissions
```

使用别名，我们可以像下面这样操作：

```
% alias la='ls -a'

```

### 注意

等号（`=`）两侧不允许有空格。如果赋值的右侧（即等号后面的部分）包含空格或制表符，请确保使用引号将其括起来，如下所示：

```
% alias talk='echo "quack!"'
% talk
> quack!
```

现在猜猜如果你输入 `la` 会发生什么？试试看。Shell 会读取你的别名——在这个例子中是 `la`——并展开它。整个过程类似于查字典一样查找单词的含义。只不过在这里，一旦找到，意义就会被执行。

我们也可以对 `-l` 选项做类似的操作：

```
% alias ll='ls -l'

```

或者，甚至可以像下面这样混合搭配：

```
% alias lla='ls -laF' 

```

最后一段代码同时使用了 `l` 和 `a` 标志与 `F`，意味着它的行为与 `–la` 开关相同，但增加了一个格式化输出的选项，可以轻松区分文件和文件夹。

### 提示

别名仅适用于交互式 shell。如果你的 shell 以非交互模式运行，它会禁用所有现有的别名。创建脚本时请牢记这一点。

你有两种声明别名的方法。第一种是直接在命令行中声明，正如我们到目前为止所做的那样。这会创建一个可以立即使用的别名；但缺点是，修改的别名只会在当前会话期间有效。一旦关闭终端模拟器或注销系统，它就会消失。声明别名的基本语法如下：

```
alias [shortname]=<longname or command(s)>

```

你可以使用这种方法来处理一些你会频繁输入但之后不会再用到的内容。不过，大多数时候，我们需要一些更加持久的东西。需要的是每次在使用命令行时都能用到的东西。

进入启动文件；如果你还记得上一章的内容，启动文件会在每次 shell 启动时读取，并为当前会话加载配置。就像医生推荐的一样。

现在打开你的`.zshrc`文件，并添加我们到目前为止所做的别名：

```
# put this on your .zshrc
alias la='ls -aF'
alias ll='ls -lF'
alias lla='ls -laF'

```

保存你的更改，`source`（或者使用它的别名点（`.`））你的文件，别名将在每次未来的 shell 会话中设置并可用。尽管它们的行为不同，所有的别名声明方法使用的语法是相同的。

## 引号字符

任何给定字符都可以通过在其前面加上反斜杠（`\`）字符来引用。这个方法在处理具有额外含义的“特殊字符”时特别有用，比如`$`，甚至是实际的`\`字符。举个例子，考虑以下`echo`语句：

```
# this is wrong!
% echo 'that's a quoted sentence for you'
quote>

```

shell 提示符表示它在等待一个引号字符（正确）闭合。这里的问题是我们没有正确地转义“that's”中的撇号：

```
% echo 'that\'s a quoted sentence for you'
> that's a quoted sentence for you

```

这很好，且工作正常，但当我们需要做大量转义时，会发生什么呢？

```
% echo 'Escaping single quotes like this \' with backslashes \\ is really tedious'
> Escaping single quotes like this ' with backslashes \ is really tedious

```

幸运的是，zsh 提供了`RCQUOTES`选项作为解决方法，它允许你使用双单引号（`''`）进行转义：

```
% setopt rcquotes
% echo 'Look ma'' I''m escapin'' single quotes'
> Look ma' I'm escapin' single quotes

```

那么双引号呢？嗯，这些确实很特别，跟其他字符不同，因为它们允许你进行参数和命令替换，正如我们很快会看到的那样。使用双引号时你需要记住，`"`、`\`、`$`和`` ` ``这些字符需要用反斜杠转义。

让我们试试双引号：

```
% echo "'echo \"\$HOME\"' will print out '$HOME'"
> 'echo "$HOME"' will print out '/Users/gfestari'

```

在前面的示例中，当`$`字符没有被引用时，`$HOME`环境变量会被实际值（`/Users/gfestari`）替换。

你也可以在双引号内使用反引号来执行程序：

```
% echo "zshenv is located at: `locate zshenv`"
> zshenv is located at: /etc/zshenv

```

shell 会首先执行`locate zshenv`，就像执行任何其他命令一样，并将其输出替换到传递给`echo`的参数中。

如你所见，你可以在大多数日常使用中绕过单引号的限制，转而使用双引号、转义序列和参数扩展，只要在特定情况下需要这样做。

## 单引号和双引号的别名

当你在别名赋值中使用空格时，需要使用单引号（`'`）；然而，通常建议无论右侧是否有空格，都使用单引号。确实，这是一个“为了安全起见”的方法，但相信我，这会帮助你避免在声明别名时遇到一些不必要的麻烦。

另一方面，如果你希望在赋值表达式中使用像环境变量或参数替换这样的内容（想想我们在上一章看到的提示符转义序列），则需要使用双引号（`"`）。假设你想使用别名输出当前用户的名字。如我们之前所见，直接访问的方法是通过环境变量`$USERNAME`。那时，第一个想到的就是使用以下别名：

```
# This is wrong!
alias saymyname='echo $USERNAME'

```

不幸的是，这在单引号中不起作用。正确的方法是使用双引号，示例如下：

```
% alias saymyname="echo $USERNAME"
% saymyname
> gfestari

```

带有变量的复杂表达式通常需要用引号括起来，我们使用单引号来实现这一点。如果你的别名需要在使用之前扩展变量，则使用双引号。

如你所见，`alias`机制确实是一个非常强大的功能。如果使用得当，它甚至可以让你重新定义命令的意义：

```
% alias ls='ls --color=auto'

```

或者在 OS X 上使用其等效命令：

```
% alias ls='ls –G'

```

### 提示

你可以从另一个别名中定义别名。按照之前的示例，如果你执行以下操作：

```
alias ls='ls --color=auto'
alias la='ls -a'
```

`la`别名的行为就像你输入了`ls --color=auto -a`一样，你不需要在定义时再次输入`--color=auto`。

这个别名通过每次调用时添加`color`标志来改变`ls`的行为，而不是使用它的更普通版本。虽然这对于特定场景很有用，但如果在像`rm`这样的命令中使用时，若不小心，可能会带来非常危险的后果。

例如，假设你将文件强制删除的操作别名为`rm`：

```
# Be careful when doing things like this!
alias rm='rm -f'

```

在这里，你正在强制删除文件而没有任何警告。结果是，有人可能在不知情的情况下执行了错误的命令，导致误删后碰撞键盘。这里的重点是，越是避免用你的“l33t 别名”覆盖现有命令，越好。想想那些被砸坏的键盘，别做那个人。

那么，如果你不确定自己是否绕过了当前会话中的任何别名设置怎么办？别担心，有一个命令可以查看。输入`alias`会列出当前会话中的所有别名：

```
% alias
> la='ls -aF'
ll='ls -lF'
lla='ls -laF'
saymyname="echo $USERNAME"

```

你也可以通过简单地指定别名的名称来获取该别名的信息，示例如下：

```
% alias la
> la='ls -aF' 

```

你可以通过输入以下命令来禁用任何现有的别名，尽管是暂时禁用：

```
% unalias <aliasname>

```

只需将`aliasname`替换为你希望关闭的别名的名称。当你在使用某些特别严格的程序时，别名的选项，甚至是命令行语法，都可能会被覆盖，这时这个功能就非常有用了。

### 提示

你有几种方法可以防止 shell 执行仅作为其他命令调用的别名。单引号括起来的命令和以反斜杠（`\`）开头的命令，以及作为相对路径或绝对路径输入的命令，都不会被 shell 视为别名。

例如，如果你希望避免调用别名，可以使用以下任意一种方式：

```
% 'ls'
% \ls
```

甚至可以这样：

```
% /usr/bin/ls
```

Zsh 还提供了`command`，它会将任何参数作为外部命令执行，而不是作为函数或内置命令。因此，你也可以使用它来避免使用别名。这将让我们得到如下的示例：

```
% command ls
```

你可以通过`man zshbuiltins`获取更多信息。

和本书中许多其他内容一样，别名并不是万金油，因此，你不应该在终端会话中乱用别名。在你踏上“少输入”冒险之旅之前，以下是几个简单的考虑因素：

+   我的别名更容易记住吗？`echo -n`比类似`echodontprinttrail`的别名要简单得多。保持简单，不要为了别名而设置别名。两个月后，“未来的你”会非常感激。

+   我的别名更容易输入吗？一个别名如果让人觉得尴尬，那就是个糟糕的别名。比如用`alias grepcola='grep --color=auto'`替代一个简单的`grep`，真的吗？记住：简洁明了的名字很棒，但如果你连`ping`都记不住的名字就不酷了。

+   我的别名是否仅仅为了某种原因覆盖了一些行为？想想之前的`rm -f`例子。大多数时候我们希望避免类似的情况；然而，每次都提示用户似乎是一个值得添加到工具箱中的合理功能。将`rm='rm -i'`别名化，使得删除文件前需要确认，似乎更...好一些。不过要小心这些技巧，过度依赖这种别名可能会导致错误的安全感。试想，如果你习惯了`rm`总是等待确认，然后在不同的环境中不加思索地使用它会怎样？

## 全局别名

如果你喜欢别名带来的简便，那么全局别名就是锦上添花。顾名思义，*全局别名*就是可以在任何地方使用的别名，允许你将过滤器或某些命令作为简单的后缀处理。

让我们看几个例子：

```
alias -g L='|less'

```

特别注意`-g`选项，它代表全局别名。

现在你可以通过添加`L`后缀将`less`分页器附加到任何命令的输出中：

```
% ls -la /etc L

```

另一个在实际中经常看到的做法是将标准错误输出（`stderr`）和标准输出（`stdout`）重定向到`/dev/null`，这样任何给定的命令都可以静默运行：

```
alias -g NUL="> /dev/null 2>&1"

```

这样你就可以调用类似`command NUL`的命令，而不需要让当前终端窗口充斥着成千上万的日志和信息。

为了清晰起见，别管是否符合标准，建议你像定义全局变量一样定义全局别名，全部使用大写字母。

## 哈希

你可以使用哈希给特定目录设置别名。这对于你的工作空间尤其方便：

```
% echo $GOPATH
> /Users/gfestari/workspace/go

```

我不想每次都输入`/Users/gfestari/workspace/go`来访问`$GOPATH`目录中的`src`文件夹。那么，为什么不利用哈希呢？

```
% hash -d gosrc=$HOME/go/src

```

现在我们可以像输入`cd ~gosrc`一样快速到达目的地（注意前导的`~`字符）。

这里有另一个例子，这次使用`/var/www`目录：

```
% hash -d www=/var/www
% cd ~www
/var/www

```

您可以开始为您最常访问的目录生成哈希值。只需记得将必要的条目添加到您的`.zshrc`中，这样您就不必反复输入相同的内容。

额外奖励：设置`AUTO_CD`选项，这样当您想要切换工作目录时，只需输入目录名称即可：

```
% setopt autocd
% ~www
> /var/www

```

现在，去展示给您的朋友们看吧，我会在这里等着。

## 将一切结合起来

在我们进入下一个话题之前，这里有一些事情可以尝试使用我们新发现的别名。

如果您在终端会话中发现自己多次输入`cd ..`，请举手。我知道，我能感同身受。那我们来简化一下吧？

我们可以尝试以下方法：

```
% alias ..='cd ..'

```

现在，只需输入`.`即可将当前工作目录向上移动一级`.` 不错吧？我们可以进一步优化：

```
alias ...='cd ../..'
alias ....='cd ../../..'

```

我认为，进行多级目录切换有些过于复杂，但可以根据需要扩展您的别名。

那么，创建目录呢？我敢打赌，像我一样，您不止一次看到过以下情况：

```
% mkdir dir1/dir2
> mkdir: dir1: no such file or directory

```

这是因为`dir1`不存在。所以我们做的是——你猜对了——创建一个别名，让我们能够自动创建*父*目录，并且更详细地（即，“在创建目录时列出目录”）显示输出：

```
alias mkdir='mkdir -pv'

```

现在尝试执行`mkdir dir1/dir2`并观察会发生什么。您也可以将相同的开关应用于`cp`和`mv`等命令，只需记得引用您的赋值！

### 提示

您可以在启动文件中使用`COMPLETE_ALIASES`选项，以强制 shell 将别名视为独立的命令进行补全。换句话说，别名不会在尝试补全之前被替换。

# 扩展

Shell 允许您在执行一行命令之前进行不同类型的操作。在接下来的部分中，我们将学习如何利用 zsh 中的各种扩展和替换形式。

## 参数扩展

参数扩展允许您在命令行的赋值过程中替换已知的变量。简单来说，参数替换是 shell 用来更改以下内容的机制：

```
% foo=Hello

```

它将被更改为以下内容：

```
% echo "${foo}, world!"
> Hello, world!

```

请注意，我们在前一行声明的变量`foo`被替换为`echo`参数中的实际值。您应该特别关注这个特殊的`${}`结构。发生的情况是，当 zsh 读取`${foo}`结构时，它立即知道要用它所持有的值替换其中的内容。

聪明的读者可能已经注意到围绕`echo`参数的双引号。重要的是要记住，就像别名和提示序列一样，参数替换对于传递给双引号中的参数有效，就像处理其他任何变量一样。

## 命令替换

就像参数扩展一样，命令替换允许 shell 执行命令并将其输出替换到特殊的语法中。命令替换通常采取`` `command` ``的形式，即一个被反引号包围的程序名。

在像 zsh 这样的更新版 shell 中，还有另一种形式的程序替换，它的形式为`$(command)`。这两种替换形式，``` `` ```和`$()`，是一样的；不过，反引号被认为更加便携，因为几乎所有的 shell 都能识别它们。

在实际使用中，命令替换通常用于查找命令的完整路径：

```
% print $(which zsh)
/usr/local/bin/zsh

```

或者，为了让它更加便携：

```
% print `which zsh`
/usr/local/bin/zsh

```

## 算术扩展

不要被名字吓倒；就像参数替换一样，算术扩展是另一种替换形式，帮助我们快速穿越命令行。顾名思义，你可以将输入扩展成一系列元素，否则你需要输入很多内容。

让我们试试：

```
% echo $(( 5 + 4 ))
> 9

```

我们从一些相当简单的算术表达式开始（我知道，我知道；数学）。但是别担心，刚才发生的事情可以很容易地解释。我们已经知道，`echo`会将信息打印到标准输出，所以没有什么神秘的地方。接下来是一个使用`$(( ))`构造的算术表达式。注意，与参数替换不同，这种算术替换需要额外一对括号。这是我们告诉 zsh 它需要处理数字的方式，这就是为什么我们的`5 + 4`会被当作算术运算来处理。

以下情况适用相同的规则：

```
% echo $(( 5 + 4 * 3 ))
> 17

```

这使我们意识到，我们需要更多的括号来设置运算符优先级：

```
% echo $(( (5 + 4) * 3 ))
> 27

```

请记住，`$(( ))`构造只是一个特殊的构造，它告诉 zsh 将其内部的内容作为算术表达式来处理。

有趣的是，我们也可以邀请参数替换加入这个“派对”。看起来变量也可以在算术表达式中进行替换：

```
% num=5+4
% echo $(( num * 3 ))
> 27

```

在前面的代码片段中，我们声明了一个变量来保存我们的`5 + 4`表达式；这使得`num`成为一个容器，当询问它时，它会大喊出我们的`5 + 4`表达式。验证这一点的一个简单方法是：

```
% echo ${num}
> 5+4

```

然而请注意，通过在表达式中使用`num`，我们不需要额外的一对括号来设置运算符优先级。这是因为我们的`num`变量在下一行被替换成它的值，最终我们得到的表达式等同于`(5 + 4) * 3`。表达式在替换之前会被先计算，否则前一个调用的结果将是`17`。

让我们再加一把火，使用另一个实用的算术替换：

```
% num=5+
% echo $(( $num 4 ))
> 9

```

在这个例子中，我们将 `num` 表达式保留下来，类似于“将后续内容添加到其中”。这就是为什么在下一行进行求值时，它会被替换为你预期的内容，在这个例子中是 `5 +`。你看到 `num` 变量前面的那个 `$` 吗？还记得本节开头提到的参数替换吗？这就是发生的情况。如果没有 `$num`，zsh 就无法处理 `num` 赋值。

```
# This is horribly wrong!
% num=5+
% echo $(( num 4 ))
> zsh: bad math expression: operator expected at `4 '

```

记住，如果你想替换一个参数，请使用 `$`：

```
% echo $(( $num 4 ))

```

### 提示

你总是可以通过在控制台中输入 `man zshexpn` 来查看所有支持的扩展类型。

## 花括号扩展

另一种有用的扩展类型叫做花括号扩展。顾名思义，它的语法涉及使用花括号（`{}`）——我猜“花括号扩展”在命名时有点过于冗长了。花括号扩展允许你像下面这样声明一个条目的数组：

```
% echo picture.jp{eg,g}
> picture.jpeg picture.jpg

```

发生的情况是，`{eg,g}` 结构被扩展为一个包含元素 `eg` 和 `g` 的数组。Shell 然后循环遍历这些元素，将两个参数传递给 `echo` 命令，这基本上等同于输入以下内容：

```
% echo picture.jpeg
% echo picture.jpg

```

但是，你节省了不少按键和伴随而来的无聊。让我们试试另一个例子：

```
% touch log_00{1,2,3}.txt
% ls
> log_001.txt  log_002.txt  log_003.txt

```

这次我们创建简单的日志文件，模式为 `log_00<num>.txt`。Shell 会将 `{1,2,3}` 元素扩展为 `1`、`2` 和 `3`，然后调用 `touch` 命令三次：

```
% touch log_001.txt
% touch log_002.txt
% touch log_003.txt

```

如果你没注意到，我们使用了逗号（`,`）来声明大括号内的每个元素。现在，你可能会想，“如果我们使用更长的数组会怎样？”这就变得更加有趣了；声明一个值的范围：

```
% touch log_{007..011}.nfo
% ls | grep .nfo
log_007.nfo  log_008.nfo [...] log_010.nfo  log_011.nfo

```

值得注意的是，前面的例子有几个要点。我自行格式化了输出的列表。但那个（`…`）意味着文件 `007` 到 `011` 确实存在。首先，我们现在使用花括号扩展来扩展一个范围，这次是从九到十一。接下来值得一提的是，zsh 足够聪明，能够注意到前导零并将其用作其他值的填充，而不是将它们替换为普通的整数。这就是为什么你看到序列从 `log_007.nfo` 开始，直到 `log_011.nfo` 结束。

在第二行，我们使用管道符号（`|`）将不同命令之间的输出连接或重定向。这种方式我们列出了文件的内容，并将输出重定向到 `grep` 工具，以便通过 `.nfo` 扩展名过滤该输出。

当我们在数组中加入一些数学运算时，它们会变得更加有趣：

```
% foo=(A B C)
% bar=(1 2 3)
% echo $^foo-$^bar
> A-1 A-2 A-3 B-1 B-2 B-3 C-1 C-2 C-3

```

在上面的代码片段中，我们声明了两个数组，一个包含元素`A`、`B`和`C`，另一个包含元素`1`、`2`和`3`。随后对`echo`命令的调用传递了参数`${^foo}-${^bar}`。注意`^`运算符（在前一个调用中大括号是隐式的，这里为了清晰起见我加上了它们）。再次强调，我们在告诉 zsh 扩展`$`后面的变量，不过这次我们得到的是**笛卡尔积**，而不是像`A B C-1 2 3`那样的结果。这是因为`^`运算符作为数组扩展表达式。因此，在 zsh 看来，我们在独立地使用数组中的每个元素。

关于数组扩展和`^`运算符的更详细描述，请访问`man zshoptions`（特别是`RC_EXPAND_PARAM`部分）和`man zshexpn`。

### 提示

与其他序列一样，某些字符被视为“特殊”字符，需要转义。逗号和单引号需要使用反斜杠进行转义：

```
% echo \'{\,,\'}\'' needs to be escaped'
> ',' needs to be escaped ''' needs to be escaped
```

# 使用历史记录

像大象一样，许多现代 Unix shell 倾向于详细记录在使用它们时输入的大量命令。像许多其他 shell 一样，zsh 也拥有历史日志，并提供一种更便捷的方式来访问其中的每一条记录。从工作日志的角度来看，能够查看你做过的事情不仅实用，而且也有助于提高效率。想想看；你可以使用`history`命令查看（并最终编辑）之前输入的命令，获得一些关于系统状态的上下文，或者避免反复输入相同的内容。能够轻松检索过去的命令听起来很棒，因为它确实是一个非常巧妙的功能。

我们现在来看看如何使用 zsh 的历史扩展来处理命令行中的以前条目。

### 注意

**使用历史记录**

更传统的回顾历史记录条目的方法是使用键盘上的上箭头和下箭头键来浏览历史记录条目。在下一章我们将深入研究如何修改这种行为，具体是在检查 zsh 行编辑器（ZLE）模块时。现在，我们假装这些是唯一可以在历史记录中移动的按键。

## 历史扩展

zsh 为您提供访问历史记录的方式之一是通过所谓的历史扩展。只要您的输入以感叹号`!`字符开头，这种方式就会生效。正如我们在上一章看到的，`!`字符的默认行为可以通过将`histchars` shell 参数设置为不同的值来覆盖：

```
% set histchars='@^#'

```

然而，与其他 shell 不同，zsh 在设置`histchars`时最多接受三个参数。除了扩展（更改为`@`）之外，另外两个分别用于替换（`^`）和注释（`#`）。

通过将默认的感叹号（`!`）替换为`@`字符，您现在可以执行类似于以下命令，调用上次执行的命令行：

```
% ls *.txt
> readme.txt notes.txt
% @@
% ls *.txt
> readme.txt notes.txt

```

通过重新定义`histchars`，你可以使用那些实际上需要特殊字符的命令，比如`!`，而不需要转义它们或担心历史替换。你可以选择任何你想要的组合，但作为经验法则，尽量选择那些不太常用的字符，这样才值得花费精力去设置。

### 注意

历史扩展仅在你运行交互式 Shell 并且`.zshrc`文件中的`NO_BANG_HIST`选项未设置时才会生效。

访问历史记录条目是通过我们称之为*事件标识符*的方式完成的。像转义序列一样，标识符是外壳扩展的构造的花哨名称，用于精确地知道从历史记录中需要检索什么。最常见和有用的事件标识符之一是双重感叹号（`!!`），它本身指的是最后一次输入的命令：

```
% sh myscript.sh
> myscript.sh: Error: you need to be root to execute this.
% sudo !!
> myscript.sh: executing myscript.sh

```

如你所见，`!!`字符对于那些忘记使用提升权限执行命令的情况非常有用。发生的情况是，zsh 立即展开对历史中最后一个命令的引用，并将其替换为包含`sudo`调用的行，避免你再次输入整行命令。

让 Shell 进行替换并自动执行命令比我们大多数人愿意在 Shell 中投入的“盲目信任”要多一点。幸运的是，我们可以在`.zshrc`中设置`HIST_VERIFY`选项，强制 zsh 在每次你执行命令时要求确认：

```
% setopt HIST_VERIFY
% echo 'Hello!'
> Hello!
% !!
% echo 'Hello!'

```

如你所见，Shell 会在你的提示符中使用之前的命令来完成输入，但不会执行它。这对像提升权限或使用 sudo 命令非常有用。请随意将`setopt HIST_VERIFY`添加到你的`.zshrc`文件中，因为从现在开始我们假设它会被使用。

对于我们刚才输入的命令，这真是很方便，但如果前一个命令在历史记录中更久远呢？那么，我们需要使用普通的事件感叹号：

```
% !cat
% cat /etc/hosts | grep 127.0.1.1

```

这里我最后执行的包含`cat`的命令是打印出我的`hosts`文件（`cat /etc/hosts`），随后调用了`grep`，因为我在寻找包含`127.0.1.1`的行。

如果你通过 SSH 连接到远程主机，你可以使用类似以下内容来检索上次运行的连接：

```
% !ssh
% ssh gfestari@192.168.1.10

```

如你所见，历史扩展的语法相当容易记住。只需将`!`字符与要查找的命令放在一起，让 zsh 发挥它的魔力。

### 提示

*词设计符*表示将包含在历史引用中的命令行的单词。以下是可用设计符的快速参考：

+   `^`：第一个参数。

+   `$`：最后一个参数。

+   `%`：给定词语的最新匹配。

+   `x-y`：一系列单词。负索引如`-i`表示`0-i`；因此，`-1`表示“倒数第二个条目”。

+   `*`：所有参数。如果事件只有一个词，则返回 null。

请注意，`%`单词指示符只有在用作`!%`、`!:%`或`!?str?:%`时才有效；其他任何用法都会导致错误。

要更深入地了解单词指示符和历史扩展语义，请参考`man zshexpn`，特别是名为“HISTORY EXPANSION”的部分。

那么我们来提高一下难度；你可以结合使用特殊字符`^`和`$`，分别访问历史记录条目的第一个和最后一个参数：

```
% mkdir new_folder
% cd !^
% cd new_folder

```

`^`字符扩展为`mkdir`命令的第一个参数，在这个特定的例子中是`new folder`。

```
% touch log1.txt log2.txt
% nano !$
% nano log2.txt

```

这里同样使用了`$`，不过这次扩展了`touch`命令的最后一个参数，因此我们最终可以使用`nano`编辑它。

如果你熟悉正则表达式，这两个指示符的行为应该不让你感到惊讶。然而，如果你需要访问的字符串既不在历史的开始（`^`）也不在末尾（`$`），那么你就需要使用`?`指示符：

```
% !?etc
> cat /etc/hosts | grep 127.0.1.1 

```

上述表达式匹配包含`etc`的最新命令。一般来说，使用`?`事件指示符的语法可以总结如下：

```
!?str[?]

```

你看到的那个可选的`?`，只有在命令后面跟着一些不应被视为`str`一部分的文本时才是必要的；例如：

```
% !?etc?^
> /etc/hosts

```

你注意到`?`字符是如何作为`etc`关键字的定界符吗？可以把它们想象成括号，包裹着你想要匹配的表达式。插入符号操作符（`^`）表示我们对该特定命令行的第一个参数感兴趣，而巧合的是，它正是`/etc/hosts`字符串。

使用历史感叹号操作符，我们还能做很多其他的事情。另一个有趣的技巧是，它可以引用历史中的特定行。就像之前一样，语法只是对我们已经知道的内容做了些微的调整：

```
!<hist_number> 
% !103 # this retrieves the 103rd entry in your $HISTFILE.
% !4   # this retrieves the 4th entry.

```

那么如何确定我要使用哪一行呢？嗯，这要复杂一点，但也没有使用`grep`、`ack`或当今孩子们用来在历史文件中搜索的其他工具那么复杂：

```
% history | grep nano
> 2045  nano /etc/hosts

```

使用`grep`并搜索包含`nano`的条目，我可以看到我曾用它编辑过`/etc/hosts`，该记录位于我的`$HISTFILE`的第`2045`行。如果我们想再次打开 hosts 文件，只需简单地调用：

```
% !2045
% nano /etc/hosts

```

现在让我们来一些混搭：

```
% history | grep git
> 1571  cd ../git/dotfiles
 1572  git status
 1573  git diff zsh/zsh_funcs
 1574  git diff zsh/zshrc
 1584  history | grep git

```

在这个例子中，我在查找`git`条目。如你所见，结果中显示了我使用`git`做的很多事。结合我们目前学到的内容，我们能做很多事情：

```
% more !1573$
% more zsh/zsh_funcs

```

如你所见，我们将感叹号操作符与`$`选择器一起使用，以引用历史记录中第 1573 行的最后一个参数。

有趣的是，你还可以使用负整数来引用倒数第 n 个条目：

```
% !-2 # this will retrieve the 2nd to last entry in history.
% !-97 # this does the same to the 97th to last entry.

```

对一些程序员来说，负索引应该是非常熟悉的（我在看着你们，Python 和 Ruby 开发者）。

## 历史替换

zsh 历史扩展的另一个有用功能是命令替换。通过这种替换方式，你可以避免重新输入整行 shell 历史记录，仅仅为了编辑其中一个较小的部分。

如果你做过类似以下操作，请举手：

```
% ls
> dir1  file.txt
% mv fiel.txt dir1/
mv: rename fiel.txt to dir1/fiel.txt: No such file or directory

```

看来我拼错了 `file.txt` 文件名，那现在该怎么办？传统的历史记录使用方法会建议我们按上箭头键回忆上一行，左移光标到 `fiel` 错误拼写处，重新输入正确的名称，完成。可是 zsh 的方法更实用一些：

```
% ^fiel^file
% mv file.txt dir1/

```

这是什么魔法？简单来说，链式 `^` 操作符允许你匹配一个单词的第一次出现并用附加到第二个 `^` 操作符的单词进行替换。更一般的语法是：

```
^history-entry^word-replacement

```

### 提示

你可以通过在启动选项中设置`HIST_IGNORE_SPACE`来防止命令被添加到历史记录中。这样，shell 会忽略以空格开头的行。

```
% echo "this line will be recorded in history"
%  echo "this will not"
```

## 更多有用的选项

为了总结这一部分，以下是一些值得考虑在启动文件中填充的与历史记录相关的选项，除此之外，我们在本章中已经讨论过的内容。只需将其中的任何（或全部）选项添加到 `.zshrc` 中，并记得在每个条目前加上 `setopt`。

+   `EXTENDED_HISTORY`：为每个历史条目保存时间戳和持续时间。对于数据分析爱好者来说是一个非常棒的补充。

+   `HIST_IGNORE_ALL_DUPS`：在显示结果时忽略重复的条目。

+   `HIST_FIND_NO_DUPS`：不显示已经找到的行的重复项。

+   `HIST_REDUCE_BLANKS`：移除历史记录中的多余空格和制表符。

+   `INC_APPEND_HISTORY`：在输入时将条目添加到历史记录中，也就是说，不等到 shell 退出后再添加。可能是 zsh 最棒的功能之一。你知道你想要这个。

+   `SHARE_HISTORY`：在不同的 zsh 进程之间共享历史记录。另一个非常棒的选项，可以与前一个选项相得益彰。

# 总结

在本章中，我们仔细研究了 zsh 的一些最显著的节省时间的功能。我们在 shell 冒险中的目标是通过减少输入来实现更多的操作。因此，本章重点介绍了理解别名、它们的工作原理，以及如何以一种不会带来更多麻烦的方式来编写我们自己的节省敲击的定义。

接着我们学习了扩展功能，了解了算术扩展和大括号扩展，目的是让与命令行相关的工作变得更加轻松。最后，我们仔细研究了如何使用历史记录，超越了键盘上下箭头疯狂按压的方法，学习了历史扩展和事件设计符，以避免重复自己进入无尽的循环。

到现在为止，你应该对以下内容有了相当清晰的了解：

+   **别名**：我们了解了什么是别名以及如何为我们的命令定义一个有用的快捷方式，并且掌握了一些开始构建别名集合的小技巧。

+   **参数扩展、命令替换、算术和大括号扩展**：如何用任意给定程序的输出、算术表达式的结果来替换命令行中的条目，甚至如何扩展数组，以便不必重复输入相同的内容。

+   **历史扩展和替换**：如何将以上所有内容应用到 shell 的历史记录中，以及避免无聊地重复自己，特别是双感叹号（`!!`）等特定结构。

一点也不错。可以自豪地给自己一个鼓励，或者去喝杯啤酒，现在你应该对 zsh 的使用感到足够自信了。这很棒，但是我们还有更多待探索，所以不要懈怠！接下来是 ZLE，即 zsh 的行编辑器。我们将了解 zsh 的另一个很酷的特性，并发现在命令行上执行一些更高级的文本处理并不需要专门的程序。除了节省我们数百小时重复无聊的击键外，我们还将学习如何定制编辑器的快捷键和绑定，这样就不必再靠猜测了。
