# 附录 C. FEX 配置文件

许多系统都有自我配置的方法，无论是软件还是硬件。在这一点上，以 Allwinner 为基础的硬件也不例外；一些组件确实需要配置，例如 GPIO 引脚。芯片无法自我配置；也就是说，它不能解析配置文件并进行自我配置。芯片的实际配置是由各种驱动程序完成的。此过程在接下来的章节中进行说明。

# 初始启动

芯片以硬件方式启动，某些组件预先编程以在特定引脚上激活。由于这一点，芯片可以从各种启动介质启动，如第三章中所述，*安装操作系统*，并加载引导加载程序。引导加载程序也预配置为特定的硬件设置。因此，如前所述，每个板子都有自己的引导加载程序。

除了启动某些组件外，引导加载程序还有以下两个重要任务：

+   将内核加载到内存并随后执行

+   将配置文件加载到内存中，以供内核使用

然而，引导加载程序本身并不解析配置文件。

### 提示

需要提到的是，当使用主线内核时，原理是相同的：引导加载程序仍然加载一个名为设备树二进制的配置文件，内核使用该文件进行配置。

FEX 配置概念本身很有趣，其中一个文件的更改配置了整个设备。如前所述，FEX 文件由引导加载程序加载到内存中，并且引导加载程序仅检查一个特定位置。虽然 u-boot 更灵活，可以配置为允许从任何位置或任何文件名读取配置文件，但预编程在板载 NAND 闪存中的引导加载程序只会检查设备上的第一个分区，而且该分区必须是 FAT 格式。因此，这是一种常见约定，我们将在本章剩余部分遵循此约定。此外，该文件必须使用特定名称`script.bin`，并且其备份文件为`script0.bin`。当启动支持板载`nand`闪存的内核时，该文件将存储在设备节点`/dev/nanda`中。否则，将使用常规设备节点，最常见的是 SD 卡，存储在`/dev/mmcblk0p1`。

# 编译和反编译 FEX 文件

`script.bin`文件顾名思义是一个二进制文件。然而，不能直接修改该文件。linux-sunxi 社区创建了一组工具，可以将该二进制文件转换为文本文件，反之亦然。它们可以在其 GitHub 仓库中找到：[`github.com/linux-sunxi/sunxi-tools`](https://github.com/linux-sunxi/sunxi-tools)。

克隆此仓库后，运行 `make fex2bin` 命令来构建 **fexc**，即 fex 反编译工具。最好在具有舒适文本编辑器的系统上编译并运行此工具。

运行 fexc 来反编译二进制文件，命令如下：

```
[packt@packt:~]$ fexc -I bin -O fex script.bin script.fex

```

有两个符号链接作为 fexc 的简写，即 `fex2bin` 和 `bin2fex`。使用这些链接可以省去 `-I` 和 `-O` 参数。

# 理解 FEX 文件格式

使用任何文本编辑器打开，FEX 文件会显示为分为多个部分，每个部分前面都有一个用方括号 `[]` 括起来的头部。在以下示例中，UART `0` 组件的解释如下：

```
[uart_para0]
uart_used = 1
uart_port = 0
uart_tx = port:PB22<2><1><default><default>
uart_rx = port:PB23<2><1><default><default>

```

在这里，名为 `uart_para0` 的组件是第一个串口或 UART，包含四个字段，串口驱动程序将读取这些字段。每个字段以键值对的形式设置，键在等号左侧，值在等号右侧。在此例中，`uart_used` 键的值设置为数字 `1`，表示该定义应被解析并激活。

接下来是 `uart_port` 键，其值设为数字 `0`，表示该配置与 UART 0（第一个 UART 端口）相关。某些设置非常简单，采用键值对的形式，即左侧为键，右侧为字符串或数字。然而，有一对键值需要特别注意，那就是引脚配置，其中值为端口定义。每个组件可能需要特定的引脚才能正常工作。

一个基本的 UART 需要两个引脚：一个发送引脚和一个接收引脚。SoC（系统级芯片）可以提供多个 UART 和多个引脚。在上述示例中，定义了两个引脚，发送引脚 `uart_tx` 和接收引脚 `uart_rx`。SoC 上的引脚通常是分组的，通常是按相关功能来分组的。

对于 A10 来说，它有九个组，称为端口。每个端口可以包含不同数量的引脚。例如，B 端口有 24 个引脚。该组的最后两个引脚分别是 UART 发送引脚和 UART 接收引脚。引脚的编号从 0 开始，因此不难理解，在之前的示例中，`PB22` 和 `PB23` 分别是 B 端口的第 22 引脚和第 23 引脚。

如前所述，每个引脚有多个功能，或者可以说，许多功能被复用到一个引脚上。这些复用（mux）被枚举，其中 MUX 0 总是将引脚配置为 GPIO 输入，MUX 1 总是将引脚配置为 GPIO 输出。根据端口和引脚的不同，MUX 2 及以上可能有不同的含义——在 `PB22` 和 `PB23` 的例子中，MUX 2 是 UART 引脚。因此，第一个被尖括号 `<>` 括起来的参数被定义为 MUX 2。

## 引脚配置

第八章，*闪烁的灯光与感知世界*，讨论了上拉电阻和下拉电阻的作用。基于 Allwinner 的 SoC 实际上在引脚上内部附加了上拉或下拉电阻。在这种情况下，第二个角括号包围的参数`<1>`启用内部上拉，`<0>`禁用上拉/下拉功能，`<2>`启用下拉功能。然而，下拉功能仅在端口配置为输入时有效；SoC 不支持输出端口的下拉功能。另一个有效选项是使用`<default>`关键字，告诉驱动程序使用安全的默认值。

第三个角括号包围的参数定义了引脚应该输出的电流强度。有效值有四个：`0`、`1`、`2`和`3`，其中`0`对应 10 毫安，`1`对应 20 毫安，`2`对应 30 毫安，`3`对应 40 毫安。可以使用默认值让驱动程序选择一个安全的默认值。

第四个位置定义了引脚的初始输出电平，可以是低电平`<0>`或高电平`<1>`。自然，这仅在将引脚配置为输出时有效。此处的默认值意味着驱动程序使用一个安全的默认值。

### 提示

虽然在这里讨论和解释了端口 B：引脚 22 和 23，但其余的引脚及其多路复用设置可以在 linux-sunxi 社区的 wiki 上找到，[`linux-sunxi.org/PIO`](http://linux-sunxi.org/PIO)。

# 深入阅读

FEX 文件包含许多其他可以设置的组件，从配置使用哪些引脚来连接 SD 卡读卡器，到为 LCD 使用哪种颜色格式。所有已发现的选项也已在 linux-sunxi wiki 页面上进行了文档化，[`linux-sunxi.org/Fex_Guide`](http://linux-sunxi.org/Fex_Guide)。然而，由于每个驱动程序都是为读取键值对而编写的，因此根据驱动程序和内核整体的进展，事情很容易并且经常发生变化。如有疑问，始终可以检查内核源代码。

# 安装配置好的 FEX 文件

将 FEX 文件重新编译成 bin 文件几乎是一样的。

```
[packt@packt:~]$ fexc -I fex -O bin script.fex script.bin

```

根据所使用的启动介质，`script.bin`必须被复制回去，以便设备能够使用这些新更改的值。这可以是板载 NAND 闪存上的`/dev/nanda`分区，或者是 microSD 卡上第一个 FAT 格式化的分区。

在将`script.bin`放置到正确位置后，需要重启系统以使其读取这些更改。

# 总结

本附录简要介绍了 FEX 文件并展示了如何修改它。下一个附录将尝试覆盖最基本的故障排除内容，解决最常见的陷阱。
