<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Debugging SELinux"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Debugging SELinux</h1></div></div></div><p>In this chapter, we will look at SELinux debugging through the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identifying whether SELinux is to blame</li><li class="listitem" style="list-style-type: disc">Analyzing SELINUX_ERR messages</li><li class="listitem" style="list-style-type: disc">Logging positive policy decisions</li><li class="listitem" style="list-style-type: disc">Looking through SELinux constraints</li><li class="listitem" style="list-style-type: disc">Ensuring an SELinux rule is never allowed</li><li class="listitem" style="list-style-type: disc">Using strace to clarify permission issues</li><li class="listitem" style="list-style-type: disc">Using strace against daemons</li><li class="listitem" style="list-style-type: disc">Auditing system behavior</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Introduction</h1></div></div></div><p>On an SELinux-enabled system, the SELinux policy defines how applications should behave. Any change in behavior might trigger SELinux denials for certain actions of that application. As a result, end users can notice unexpected permission issues or erratic application behavior.</p><p>Troubleshooting such situations is usually done through analysis of the AVC events. Many resources already cover AVC events in great detail. The basic premise is that an AVC event uses a set of key-value pairs, as follows:</p><div class="informalexample"><pre class="programlisting">type=AVC msg=audit(1369306885.125:4702304): avc: denied { append } for pid=1787 comm="syslog-ng" name="oracle_audit.log" dev=dm-18 ino=65 scontext=system_u:system_r:syslogd_t:s0 tcontext=system_u:object_r:usr_t:s0 tclass=file</pre></div><p>In this example, we can deduce the following from the AVC event:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The event is a denial (<code class="literal">avc: denied</code>)</li><li class="listitem" style="list-style-type: disc">The operation that was denied is appending to a file (<code class="literal">{ append } … tclass=file</code>)</li><li class="listitem" style="list-style-type: disc">The process that tried to append to the file has PID <code class="literal">1787</code> and name <code class="literal">syslog-ng</code> (<code class="literal">pid=1787 comm="syslog-ng"</code>)</li><li class="listitem" style="list-style-type: disc">The process' context is <code class="literal">syslogd_t</code> (<code class="literal">scontext=system_u:system_r:syslogd_t:s0</code>)</li><li class="listitem" style="list-style-type: disc">The target file is called <code class="literal">oracle_audit.log</code> and has an inode number <code class="literal">65</code> on the filesystem, stored on the <code class="literal">/dev/dm-18</code> metadevice (<code class="literal">name="oracle_audit.log" dev=dm-18 ino=65</code>)</li><li class="listitem" style="list-style-type: disc">The file's context is <code class="literal">usr_t</code> (<code class="literal">tcontext=system_u:object_r:usr_t:s0</code>)</li></ul></div><p>However, sometimes it isn't sufficient to find out where the problem is. Luckily, there are many more options available to debug the problem.</p></div></div>
<div class="section" title="Identifying whether SELinux is to blame"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Identifying whether SELinux is to blame</h1></div></div></div><p>Before blaming the SELinux <a id="id536" class="indexterm"/>subsystem and policies for a problem, it is important to verify whether SELinux is to blame at all. Too often, hours of troubleshooting are put in analyzing the SELinux policies and subsystem only to find out that the problem also persists when SELinux is not enabled.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec163"/>How to do it…</h2></div></div></div><p>In order to be confident that SELinux is (or isn't) to blame, the following set of steps can be taken:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Is it possible to get more information through the application's internal debugging system? Consider the following instance:<div class="informalexample"><pre class="programlisting">~# puppet master
Error: Could not find class puppet::agent for foo.bar on node foo.bar
~# puppet master --debug --no-daemonize --verbose</pre></div></li><li class="listitem">Is an AVC denial related to the problem shown in the audit logs? If not, try disabling the <code class="literal">dontaudit</code> rules and try again:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# semodule -DB</strong></span>
</pre></div></li><li class="listitem">Is the application that gives problems SELinux-aware? Most SELinux-aware applications are linked with the <code class="literal">libselinux.so</code> library, so we can verify whether this is the case using <code class="literal">ldd</code> or <code class="literal">scanelf</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# ldd /usr/bin/dbus-daemon</strong></span>
<span class="strong"><strong>        linux-vdso.so.1 =&gt;  (0x00007fff56df4000)</strong></span>
<span class="strong"><strong>        libexpat.so.1 =&gt; /lib64/libexpat.so.1 (0x00007f55710ae000)</strong></span>
<span class="strong"><strong>        libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f5570e8f000)</strong></span>
<span class="strong"><strong>        libaudit.so.1 =&gt; /lib64/libaudit.so.1 (0x00007f5570c72000)</strong></span>
<span class="strong"><strong>        libcap-ng.so.0 =&gt; /lib64/libcap-ng.so.0 (0x00007f5570a6d000)</strong></span>
<span class="strong"><strong>        libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f5570850000)</strong></span>
<span class="strong"><strong>        librt.so.1 =&gt; /lib64/librt.so.1 (0x00007f5570647000)</strong></span>
<span class="strong"><strong>        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f55702b3000)</strong></span>
<span class="strong"><strong>        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f55700af000)</strong></span>
<span class="strong"><strong>        /lib64/ld-linux-x86-64.so.2 (0x0000003458000000)</strong></span>
</pre></div></li><li class="listitem">Is the issue login related? If so, an application might not be SELinux-aware but still behave differently, as it uses PAM under the hood, which calls the <code class="literal">pam_selinux.so</code> library.</li><li class="listitem">Does the problem still persist if the application domain is put in permissive mode? To check this, issue the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# semanage permissive -a portage_t</strong></span>
</pre></div></li><li class="listitem">If the application domain is unknown, try putting the entire system in permissive mode (if allowed) to see whether the problem is still showing up. If it is, then SELinux might not be the cause after all:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# setenforce 0</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec164"/>How it works…</h2></div></div></div><p>Ensuring that<a id="id537" class="indexterm"/> SELinux is the cause of a problem is the first step to enlightenment. Numerous hours of SELinux investigations to resolve issues are spent only to find out that the problem was not with SELinux to begin with.</p><p>Getting more information from the application (or applications) involved is the first step to troubleshooting issues. Many applications have command-line flags that increase logging verbosity, and many daemons can be configured to log more of their inner workings. The resulting debug information (or even trace information, if the application supports it) will provide a massive help to the administrator to troubleshoot a problem.</p><p>If additional logging does not help, then it is important to verify whether there are AVC denials in the audit logs. As some AVC denials can be hidden during regular operations, disabling the <code class="literal">dontaudit</code> rules temporarily might be necessary. Don't stare blindly at AVC denials though, and take a broader look at logfiles and audit events. For instance, in the next recipe (<span class="emphasis"><em>Analyzing SELINUX_ERR messages</em></span>), a more in-depth analysis of a particular audit event type is discussed.</p><p>Look through the various logs on the system as well. The output of <code class="literal">dmesg</code> is important if the problem is kernel, hardware, or core-system related. The <code class="literal">messages</code> logfile (in <code class="literal">/var/log/</code>) usually contains pointers when issues come up with system daemons.</p><p>When no denials are shown and there is no specific logging that can assist with the troubleshooting of an application, the next step is to assure ourselves that the application is not SELinux-aware.</p><p>SELinux-aware applications (applications that know they run on an SELinux-enabled system and interact with the SELinux subsystem) can act differently based on the SELinux policy that is loaded, without actually triggering any SELinux decision in the SELinux subsystem. On account of their awareness, the in-kernel SELinux subsystem access controls might not be called, so no logging will be shown even though the problem is somewhat SELinux-related.</p><p>Although there is not any 100 percent certain method to check whether an application is SELinux-aware, the two most common approaches are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking whether the application binary is linked with the <code class="literal">libselinux.so</code> library</li><li class="listitem" style="list-style-type: disc">Checking whether the application uses PAM</li></ul></div><p>An application that is linked <a id="id538" class="indexterm"/>with the <code class="literal">libselinux.so</code> library<a id="id539" class="indexterm"/> is SELinux-aware and will be able to query SELinux policies, possibly acting differently when SELinux is enabled and often regardless of SELinux being in the enforcing or permissive mode.</p><p>Besides the <code class="literal">ldd</code> command, it is also possible to use the <code class="literal">scanelf</code> application as provided by the <code class="literal">pax-utils</code> package. This application does not need execute privileges against the binary (which <code class="literal">ldd</code> requires) but has the downside that it only shows the requirements for the binary, while <code class="literal">ldd</code> also includes the libraries linked by the libraries themselves:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ scanelf -n /usr/bin/dbus-daemon</strong></span>
<span class="strong"><strong> TYPE   NEEDED FILE</strong></span>
<span class="strong"><strong>ET_DYN libexpat.so.1,libselinux.so.1,libaudit.so.1,libcap-ng.so.0,libpthread.so.0,librt.so.1,libc.so.6 /usr/bin/dbus-daemon</strong></span>
</pre></div><p>Applications that use PAM can also be influenced by SELinux, since their PAM configuration might call the <code class="literal">pam_selinux.so</code> library (or not call it, which can be equally damaging for the functionality of the application as no transition will occur then, having the user session still run with the context of the daemon).</p><p>If the application does not interact with the SELinux subsystem to query the SELinux policy, and it also doesn't handle SELinux labels directly (that is, it has no knowledge of SELinux labels and does not actively work with them code-wise), then running the application in the permissive mode should show us whether SELinux is to blame. In the permissive mode, the SELinux subsystem access controls do not prevent any action. If a problem still persists in the <a id="id540" class="indexterm"/>permissive mode, chances are that SELinux is not to blame at all.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec165"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information about SELinux-aware applications and how to write one is covered in <a class="link" href="ch10.html" title="Chapter 10. Handling SELinux-aware Applications">Chapter 10</a>, <span class="emphasis"><em>Handling SELinux-aware Applications</em></span></li></ul></div></div></div>
<div class="section" title="Analyzing SELINUX_ERR messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Analyzing SELINUX_ERR messages</h1></div></div></div><p>When the SELinux subsystem is asked to perform an invalid SELinux-specific operation, it will log this through the audit subsystem using the <code class="literal">SELINUX_ERR</code> message type.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec166"/>Getting ready</h2></div></div></div><p>Make sure that the audit <a id="id541" class="indexterm"/>subsystem is up and running as we will be using the <code class="literal">ausearch</code> application to (re)view audit events:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# service auditd start</strong></span>
</pre></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec167"/>How to do it…</h2></div></div></div><p>Analyzing <code class="literal">SELINUX_ERR</code> messages is done by viewing the entry in the audit logs and understanding the individual fields; this is done by completing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Note the current date/time, or reload the SELinux policy, to have a clear point in the audit logs from where to look:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# semodule -R</strong></span>
</pre></div></li><li class="listitem">Trigger the behavior in the application.</li><li class="listitem">Ask the audit subsystem to show the last events of the <code class="literal">SELINUX_ERR</code> and <code class="literal">MAC_POLICY_LOAD</code> types:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# ausearch -m SELINUX_ERR,MAC_POLICY_LOAD -ts recent</strong></span>
</pre></div></li><li class="listitem">Look at the beginning of the message to find out what problematic situation SELinux is informing us about.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec168"/>How it works…</h2></div></div></div><p>The SELinux subsystem will log any incorrect request. If it is application behavior, it is usually logged through the AVC type; but when the request is SELinux-specific and incorrect, an <code class="literal">SELINUX_ERR</code> message type is displayed. In the example, we also looked for the <code class="literal">MAC_POLICY_LOAD</code> type, so we know at which stage the SELinux policy was reloaded, giving us a good starting point for the investigation.</p><p>Some examples of the <code class="literal">SELINUX_ERR</code> messages<a id="id542" class="indexterm"/> are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">security_compute_sid</code>: Invalid context</li><li class="listitem" style="list-style-type: disc"><code class="literal">security_validate_transition</code>: Denied</li><li class="listitem" style="list-style-type: disc"><code class="literal">security_bounded_transition</code>: Denied</li></ul></div><p>Some other <a id="id543" class="indexterm"/>messages exist as well, although these are mostly for SELinux-internal problems (related to the SELinux subsystem inside the Linux kernel, such as supported netlink types), which need to be resolved by the SELinux maintainers themselves, and not by policy developers.</p><div class="section" title="Invalid contexts"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec48"/>Invalid contexts</h3></div></div></div><p>An invalid context<a id="id544" class="indexterm"/> is triggered when a context that is not valid according to the RBAC and SELinux user rules is created. This is usually the case during a domain transition, where the target type is not allowed for the role:</p><div class="informalexample"><pre class="programlisting">time-&gt;Wed Aug 4 03:19:04 2014
type=SYSCALL msg=audit(10590262134.246:135): arch=c000003e syscall=59
success=no exit=-13 a0=187b190 a1=187b120 a2=187ac30 a3=7ffff2dc3ec0 items=0
ppid=14696 pid=15085 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0
egid=0 sgid=0 fsgid=0 tty=(none) ses=21 comm="logwatch" exe="/usr/bin/perl"
subj=system_u:system_r:logwatch_t:s0-s0:c0.c1023 key=(null)
type=SELINUX_ERR msg=audit(10590262134.246:135): security_compute_sid:
invalid context system_u:system_r:logwatch_mail_t:s0-s0:c0.c1023 for
scontext=system_u:system_r:logwatch_t:s0-s0:c0.c1023
tcontext=system_u:object_r:sendmail_exec_t:s0 tclass=process</pre></div><p>Another reason for an invalid context can be that a role transition is triggered, but this role is not allowed for an SELinux user:</p><div class="informalexample"><pre class="programlisting">type=SELINUX_ERR audit(1257378096.775:46): security_compute_sid: invalid context
dbadm_u:system_r:mysqld_safe_t:s0 for scontext=dbadm_u:dbadm_r:initrc_t:s0
tcontext=system_u:object_r:mysqld_safe_exec_t:s0 tclass=process</pre></div><p>In both cases, it is important to look at the presented context and the <code class="literal">scontext</code> and <code class="literal">tcontext</code> fields. These show the contexts that SELinux finds invalid (presented context) as well as the source (domain initiating the action) and the object context (label through which the new context was decided upon). Based on these, it should be fairly easy to deduce what the error is about.</p><p>The first example shows an attempt to transition from the <code class="literal">logwatch_t</code> domain (which is allowed for the <code class="literal">system_r</code> role) to the <code class="literal">logwatch_mail_t</code> domain (which is not allowed for the <code class="literal">system_r</code> role). To solve this, <code class="literal">logwatch_mail_t</code> needs to be allowed for the <code class="literal">system_r</code> role:</p><div class="informalexample"><pre class="programlisting">allow system_r types logwatch_mail_t;</pre></div><p>The second <a id="id545" class="indexterm"/>example is triggered through a role transition. A database administrator launches an <code class="literal">init</code> script, resulting in the <code class="literal">dbadm_u:dbadm_r:initrc_t</code> context. This domain executes the <code class="literal">mysqld_safe</code> application (whose file is labeled <code class="literal">mysqld_safe_exec_t</code>) that, through the SELinux policy, attempts to perform a role transition to the <code class="literal">system_r</code> role. Although the <code class="literal">system_r:mysqld_safe_t</code> context is a valid set, the database administration user itself is not allowed the <code class="literal">system_r</code> role.</p><p>The main issue in this second example is that the context to start from (<code class="literal">dbadm_u:dbadm_r:initrc_t</code>) shouldn't be used. The <code class="literal">initrc_t</code> domain should only be allowed for the <code class="literal">system_r</code> role. This, by itself, requires that the <code class="literal">dbadm_u</code> SELinux user is also allowed the <code class="literal">system_r</code> role. So, even though allowing the <code class="literal">system_r</code> role is the right resolution, the approach taken in the example is wrong (role transition from <code class="literal">initrc_t</code> to <code class="literal">mysqld_safe_t</code> instead of role transitioning upon instantiating <code class="literal">initrc_t</code>).</p></div><div class="section" title="Denied transition validation"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec49"/>Denied transition validation</h3></div></div></div><p>Consider the following <a id="id546" class="indexterm"/>error message, which came up when an <code class="literal">init</code> script tried to increase the sensitivity of a file:</p><div class="informalexample"><pre class="programlisting">type=SELINUX_ERR audit(125482134923.234:25): security_validate_transition:
denied for oldcontext=system_u:object_r:selinux_config_t:s0
newcontext=system_u:object_r:selinux_config_t:s15:c0-c1023
taskcontext=system_u:system_r:initrc_t=s0-s16:c0.c1023 tclass=file</pre></div><p>Such a message occurs when a file transition is performed, but where the target security context is not allowed. SELinux validates whether this is allowed; if not allowed, it logs this through the message.</p><p>AVC-like denials will be in place here, but the access vector cache system is only able to validate pair-wise contexts (the source and target contexts), whereas the transition validation needs to be done on three levels (old file context, new file context, and process context).</p><p>The solution for the presented error will be to either allow <code class="literal">initrc_t</code> to raise the security level of a file (through the <code class="literal">mls_file_upgrade</code> interface) or to not have the <code class="literal">init</code> script domain try to update the MLS level of a file in the first place.</p></div><div class="section" title="Denied security-bounded transitions"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec50"/>Denied security-bounded transitions</h3></div></div></div><p>An example where <a id="id547" class="indexterm"/>security-bounded transitions occur is when the <code class="literal">mod_selinux</code> module<a id="id548" class="indexterm"/> is used with Apache (which uses bounded domains and transitions for individual requests). When the target domain is not bounded by the source domain (that is, the SELinux policy does not prevent the target domain from executing an action not allowed by the source domain, as done through the <code class="literal">typebounds</code> statement), then the following error is displayed:</p><div class="informalexample"><pre class="programlisting">type=SELINUX_ERR msg=audit(1245311998.599:17):
op=security_bounded_transition result=denied
oldcontext=system_u:system_r:httpd_t:s0
newcontext=system_u:system_r:guest_webapp_t:s0</pre></div><p>When this occurs, a bounded transition is requested by the main application domain (such as when a transition is done for threads), but the target domain is not marked as a bounded domain.</p><p>Note that this is different from when a bounded domain is given more privileges—in such cases, SELinux will deny the specific permissions when they are invoked, showing AVC denials.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec169"/>There's more...</h2></div></div></div><p>SELinux logging and audit logging is continuously being improved. Work is on the way to make the audit logs easier to parse by scripts and to provide more information. For instance, at the time of writing, a patch has just been accepted to add permissive state information in the AVC logging.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec170"/>See also</h2></div></div></div><p>More in-depth analysis and explanation of AVC messages is handled in <span class="emphasis"><em>SELinux System Administration</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>. More resources related to SELinux audit events are available at the following <a id="id549" class="indexterm"/>links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.selinuxproject.org/page/NB_AL">http://www.selinuxproject.org/page/NB_AL</a> (including an overview of all possible fields in AVC events)</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details">https://wiki.gentoo.org/wiki/SELinux/Tutorials/Where_to_find_SELinux_permission_denial_details</a></li></ul></div></div></div>
<div class="section" title="Logging positive policy decisions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Logging positive policy decisions</h1></div></div></div><p>On some occasions, the system<a id="id550" class="indexterm"/> performs actions that the administrator might not expect, but which are allowed by the SELinux policy, making it harder to debug potential problems. An application might be SELinux-aware, causing its own behavior to depend on the SELinux policy, without actually using the SELinux subsystem to enforce access. The SELinux policy might also be configured to behave differently than expected.</p><p>In such situations, it might be important to have SELinux log activities that were actually allowed rather than denied; for instance, logging domain transitions to make sure that a transition has indeed occurred.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec171"/>How to do it…</h2></div></div></div><p>In order to have domain <a id="id551" class="indexterm"/>transitions logged, create an SELinux policy by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Identify the source and target domains to look out for.</li><li class="listitem">Create an SELinux policy that calls the <code class="literal">auditallow</code> statement on the access vector we want to log:<div class="informalexample"><pre class="programlisting">auditallow initrc_t postgresql_t:process transition;</pre></div></li><li class="listitem">Build and load the SELinux policy and try to reproduce the situation.</li><li class="listitem">Look at the audit logs and check whether an AVC granted message is displayed:<div class="informalexample"><pre class="programlisting">type=AVC msg=audit(1401379369.009:6171): avc:  granted  { transition } for pid=4237 comm="rc" path="/usr/lib64/postgresql-9.3/bin/pg_ctl" dev="dm-3" ino=821490 scontext=system_u:system_r:initrc_t:s0 tcontext=system_u:system_r:postgresql_t:s0 tclass=process </pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec172"/>How it works…</h2></div></div></div><p>Of the many policy statements that SELinux supports, the <code class="literal">auditallow</code> statement is interesting and does not alter the decisions made by SELinux: having an <code class="literal">auditallow</code> statement does not allow the action, but rather has the SELinux subsystem log it if it is allowed (through another <code class="literal">allow</code> statement).</p><p>This makes it possible for SELinux policy developers and system administrators to explicitly ask the SELinux subsystem to inform them about decisions taken if the decision is to grant something rather than deny.</p><p>Using the <code class="literal">auditallow</code> statement, we can track SELinux policy decisions and assist in the development of policies and debugging of application behavior, especially when a process is invoked in a very short time frame, as this makes it difficult for administrators to see whether the context of the process is correct (<code class="literal">ps -Z</code> or by checking the <code class="literal">/proc/&lt;pid&gt;/</code> contexts).</p><p>Some administrators might want to put in some additional logging inside the scripts or commands that they invoke (such as to capture the output of <code class="literal">id -Z</code>). However, it is very much possible that the SELinux policy does not allow the script to execute the <code class="literal">id</code> command, let alone show its output or direct its output to a specific logfile.</p><p>Enhancing the SELinux policy with additional log types, enabling terminal output, allowing the execution of binaries, and more is quite some overhead just to find out whether the context of the process is as it should be. Using the <code class="literal">auditallow</code> statement<a id="id552" class="indexterm"/> is a great solution to this.</p><p>It goes beyond domain<a id="id553" class="indexterm"/> transitions, of course. If a file has been changed, and the administrator or engineer is uncertain which process or which context is causing the change, then it is possible to have SELinux audit writes on the file label, as follows:</p><div class="informalexample"><pre class="programlisting">auditallow domain postgresql_etc_t:file write;</pre></div><p>Thanks to the additional information in the AVC log, we can see which process (PID) running in a particular context (<code class="literal">scontext</code>) is responsible for writing to the file.</p></div></div>
<div class="section" title="Looking through SELinux constraints"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Looking through SELinux constraints</h1></div></div></div><p>Some denials are caused by <a id="id554" class="indexterm"/>SELinux constraints—additional restrictions imposed by the SELinux policy that are not purely based on the SELinux types, but also on the SELinux role and SELinux user. This is often not clear from the denial.</p><p>The <code class="literal">audit2why</code> application helps in informing developers that a denial came from a constraint violation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# ausearch -m avc -ts recent | grep type=AVC | audit2why</strong></span>
<span class="strong"><strong>type=AVC msg=audit(1401134596.932:62843): avc:  denied  { search } for  pid=19384 comm="mount.nfs4" scontext=system_u:system_r:mount_t:s0 tcontext=system_u:object_r:nfs_t:s0 tclass=dir</strong></span>

<span class="strong"><strong>        Was caused by:</strong></span>
<span class="strong"><strong>        Policy constraint violation.</strong></span>

<span class="strong"><strong>        May require adding a type attribute to the domain or type</strong></span>
<span class="strong"><strong>        to satisfy the constraint.</strong></span>

<span class="strong"><strong>        Constraints are defined in the policy sources in</strong></span>
<span class="strong"><strong>        policy/constraints (general), policy/mcs (MCS), and</strong></span>
<span class="strong"><strong>        policy/mls (MLS).</strong></span>
</pre></div><p>This is, however, not always the case, so we need to find a way to investigate whether denials come from constraint violations too.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec173"/>How to do it…</h2></div></div></div><p>Although SELinux <a id="id555" class="indexterm"/>constraints can be queried easily, they are currently difficult to work with. The following approach helps in validating whether a constraint is applicable for a particular AVC denial that is under investigation:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Look through the SELinux policy to see whether the (denied) access has an AVC allow rule or not:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sesearch -s staff_t -t user_home_t -c file -p read -A</strong></span>
<span class="strong"><strong>Found 1 semantic av  rules:</strong></span>
<span class="strong"><strong>  allow staff_t user_home_t : file { … read … };</strong></span>
</pre></div></li><li class="listitem">Assuming there is an allow rule, see whether there are constraints applicable to the operation. This takes into account the class (in the example, this is <code class="literal">file</code>) and the permission (in the example, this is <code class="literal">read</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seinfo --constrain | grep 'constrain .* file .* read' -A 1</strong></span>
</pre></div></li><li class="listitem">If constraints might exist, look at the attributes of the source and target contexts, as this is usually how constraints are documented in the policy:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seinfo -tstaff_t -x</strong></span>
<span class="strong"><strong>~$ seinfo -tuser_home_t -x</strong></span>
</pre></div></li><li class="listitem">Inside the SELinux policy, look through the <code class="literal">constraints</code> file (usually at <code class="literal">${POLICY_LOCATION}/policy/</code>) and the <code class="literal">mcs</code> or <code class="literal">mls</code> file (if the policy uses MCS or MLS), and look for the constraints on the class and permission requested, validating whether there are any expressions concerning the attributes mentioned.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec174"/>How it works…</h2></div></div></div><p>Constraints are currently difficult to validate. Luckily, there aren't many constraints in place, but still, not being able to easily verify and look at the constraints is a nuisance for developers.</p><p>The complexity increases as the <code class="literal">seinfo --constrain</code> output, which is the only available method to query constraints next to reading the sources, has the following drawbacks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It does not provide any name yet on the constraints (so referring to constraints is difficult)</li><li class="listitem" style="list-style-type: disc">It uses <a id="id556" class="indexterm"/><span class="strong"><strong>Reverse Polish Notation</strong></span> (<span class="strong"><strong>RPN</strong></span>), which isn't very user-friendly (although it is powerful for computers, people do not generally read RPN fluently)</li><li class="listitem" style="list-style-type: disc">It shows expanded attributes, so we get huge lists of types, rather than a limited set of attributes</li></ul></div><p>The constraint<a id="id557" class="indexterm"/> definitions inside the <code class="literal">constraints</code>, <code class="literal">mcs</code>, and <code class="literal">mls</code> files (which are only accessible through the policy source code) are easier to look at. The following example is from the <code class="literal">constraints</code> file; constraints from <code class="literal">mcs</code> and <code class="literal">mls</code> will use the <code class="literal">mlsconstrain</code> keyword:</p><div class="informalexample"><pre class="programlisting">constrain process { transition dyntransition noatsecure siginh rlimitinh }
(
..r1 == r2
..or ( t1 == can_change_process_role and t2 == process_user_target )
..or ( t1 == cron_source_domain and t2 == cron_job_domain )
..or ( t1 == can_system_change and r2 == system_r )
..or ( t1 == process_uncond_exempt )
);</pre></div><p>The controls shown use attributes, which are easier to map with a specific situation. It also shows how flexible constraints can be. Next to pure type-oriented rules (<code class="literal">t1</code> and <code class="literal">t2</code>), constraints also work with roles (<code class="literal">r1</code> and <code class="literal">r2</code>) and can deal with SELinux users (<code class="literal">u1</code> and <code class="literal">u2</code>). The number is used to differentiate between the subject (<code class="literal">1</code>) and object (<code class="literal">2</code>).</p><p>As an example, in constraint language, saying that something is allowed if the SELinux users are equal, or the SELinux user of the subject is <code class="literal">system_u</code>, will be documented as follows:</p><div class="informalexample"><pre class="programlisting">(
  u1 == u2
  or ( u1 == system_u)
)</pre></div><p>The output of the <code class="literal">seinfo --constrain</code> command has the advantage that it is easy for computer programs to interpret. Computer programs or scripts, which use the output of <code class="literal">seinfo</code> to visualize constraint information in a tree-like manner, can be created. </p><p>The following GraphViz-generated graph shows the UBAC constraints applicable to file reads, showing only the user domains and the <code class="literal">user_home_t</code> types (to not overload the graph):</p><div class="mediaobject"><img src="graphics/9669OS_08_01.jpg" alt="How it works…"/></div><p>This graph <a id="id558" class="indexterm"/>shows how the UBAC constraints are constructed. File reads are prohibited (regardless of the type enforcement rules that are made in the policy), unless they match one of the rules shown in the graph, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The SELinux user of the subject (domain) and object (resource) are the same</li><li class="listitem" style="list-style-type: disc">The SELinux user of the subject is <code class="literal">system_u</code></li><li class="listitem" style="list-style-type: disc">The SELinux user of the object is <code class="literal">system_u</code></li><li class="listitem" style="list-style-type: disc">The SELinux type of the subject does not match any of the mentioned types (only a subset is shown in the drawing)</li><li class="listitem" style="list-style-type: disc">The SELinux type of the object does not match any of the mentioned types (only a subset is shown in the drawing)</li><li class="listitem" style="list-style-type: disc">The SELinux type of the subject is <code class="literal">sysadm_t</code></li></ul></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec175"/>See also</h2></div></div></div><p>More information on SELinux constraints<a id="id559" class="indexterm"/> can be found at the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://wiki.gentoo.org/wiki/SELinux/Constraints">https://wiki.gentoo.org/wiki/SELinux/Constraints</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.selinuxproject.org/page/ConstraintStatements">http://www.selinuxproject.org/page/ConstraintStatements</a></li></ul></div></div></div>
<div class="section" title="Ensuring an SELinux rule is never allowed"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Ensuring an SELinux rule is never allowed</h1></div></div></div><p>It is possible to include statements in the SELinux policy that ensure that a particular access vector cannot be allowed, not even by enhancing the SELinux policy later. This is done with <a id="id560" class="indexterm"/>the <code class="literal">neverallow</code> statement.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec176"/>How to do it…</h2></div></div></div><p>To include the <code class="literal">neverallow</code> statements in the policy<a id="id561" class="indexterm"/> and enforce <a id="id562" class="indexterm"/>them, go through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In <code class="literal">/etc/selinux/semanage.conf</code>, enable support for the <code class="literal">neverallow</code> statements by setting the <code class="literal">expand-check</code> variable to <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting">expand-check=1</pre></div></li><li class="listitem">Create an SELinux policy in which the access vectors that should be explicitly forbidden are listed. Consider the following instance:<div class="informalexample"><pre class="programlisting">neverallow user_t system_mail_t:process transition;</pre></div></li><li class="listitem">Build and load the policy.</li><li class="listitem">Generate another policy that will allow the statement and attempt to load it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ semodule -i mytest.pp</strong></span>
<span class="strong"><strong>libsepol.check_assertion_helper:  neverallow violated by allow user_t system_mail_t:process { transition };</strong></span>
<span class="strong"><strong>libsemanage.semanage_expand_sandbox: Expand module failed</strong></span>
<span class="strong"><strong>semodule: Failed!</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec177"/>How it works…</h2></div></div></div><p>Not all distributions enable the assertion checks by default as they incur some performance penalty during policy builds. Some distributions might even have policy incompatibilities due to this, because if the assertions are disabled, then the <code class="literal">neverallow</code> statements are never processed: the <code class="literal">neverallow</code> statement isn't really a policy decision, but more a rule that influences loading of new policies, and is enforced by the policy linker (which combines the various policy modules in one final policy binary). As can be deduced from the (failure) output, the <code class="literal">neverallow</code> statements are implemented as assertions.</p><p>Some <code class="literal">neverallow</code> statements are available as part of the base policy. For instance, the following statement ensures that only the domains with the <code class="literal">selinux_unconfined_type</code> or <code class="literal">can_load_policy</code> attribute set can actually load an SELinux policy:</p><div class="informalexample"><pre class="programlisting">neverallow ~{ selinux_unconfined_type can_load_policy } security_t:security load_policy;</pre></div><p>This example uses the negation operator (<code class="literal">~</code>), which means <span class="emphasis"><em>all types except those mentioned</em></span>.</p><p>Unlike <a id="id563" class="indexterm"/>constraints (that can also be used to implement restrictions), the <code class="literal">neverallow</code> statements help by not accepting any policy <a id="id564" class="indexterm"/>that will violate the rule. It is also possible to add the <code class="literal">neverallow</code> rules through modules, unlike constraints that need to be part of the base SELinux policy (and as such, are governed by Linux distribution, an upstream policy, or developers that manage complete policies rather than individual SELinux policy modules).</p><p>The <code class="literal">expand-check</code> variable in <code class="literal">/etc/selinux/semanage.conf</code> tells the SELinux user space libraries that the assertion has to be checked. If this variable is set to <code class="literal">0</code>, then the <code class="literal">neverallow</code> statements have no impact on the policy and its loading whatsoever.</p></div></div>
<div class="section" title="Using strace to clarify permission issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Using strace to clarify permission issues</h1></div></div></div><p>The <code class="literal">strace</code> application is a popular debugging application on Linux systems. It allows developers and administrators to look at various system calls made by an application. As SELinux often has access controls on specific system calls, using <code class="literal">strace</code> can prove to be very useful in debugging permission issues.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec178"/>How to do it…</h2></div></div></div><p>To properly <a id="id565" class="indexterm"/>use <code class="literal">strace</code>, follow the next set of<a id="id566" class="indexterm"/> steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Enable the <code class="literal">allow_ptrace</code> Boolean:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# setsebool allow_ptrace on</strong></span>
</pre></div></li><li class="listitem">Run the application with <code class="literal">strace</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ strace -o strace.log -f -s 256 tmux</strong></span>
</pre></div></li><li class="listitem">In the resulting logfile, look for the error message that needs to be debugged.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec179"/>How it works…</h2></div></div></div><p>The <code class="literal">allow_ptrace</code> Boolean (on some distributions, the inverse Boolean called <code class="literal">deny_ptrace</code> is available) needs to be toggled so that the domain that calls <code class="literal">strace</code> can use <code class="literal">ptrace</code> (the method that <code class="literal">strace</code> uses to view system calls) against the target domain. As the <code class="literal">ptrace</code> method can be a security concern (it allows reading target process' memory, for instance), it is, by default, disabled.</p><p>Once an application has been executed through the <code class="literal">strace</code> application, the logfile will contain all relevant system call information. Of course, on larger applications, or on daemons, this logfile can become massive, so it makes sense to limit the <code class="literal">strace</code> operation towards a particular subset of system calls, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ strace -e open,access -o strace.log -f -s 256 tmux</strong></span>
</pre></div><p>In this example, only the <code class="literal">open</code> and <code class="literal">access</code> system calls are looked at.</p><p>In the resulting logfile, the SELinux permission usually issues results in failed system calls with an <code class="literal">EACCES (Permission denied)</code> error code:</p><div class="informalexample"><pre class="programlisting">7313  stat("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat("/home", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7313  stat("/home/swift", {st_mode=S_IFDIR|0755, st_size=12288, ...}) = 0
7313  stat("/home/swift/.pki", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  stat("/home/swift/.pki/nssdb", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7313  statfs("/home/swift/.pki/nssdb", 0x3c3cab6fa50) = -1 EACCES (Permission denied)</pre></div><p>Although an <a id="id567" class="indexterm"/>AVC denial will also be shown for<a id="id568" class="indexterm"/> most accesses, these denials often do not give a complete picture as to at what stage a denial is in. By using <code class="literal">strace</code>, we can follow the logic that the application performs.</p><p>Sometimes, it isn't obvious why a failure occurs. In this case, it might be interesting to run the application twice—once in enforcing mode and once in permissive mode—and look at the differences in the <code class="literal">strace</code> logs.</p></div></div>
<div class="section" title="Using strace against daemons"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Using strace against daemons</h1></div></div></div><p>The <code class="literal">strace</code> application not only makes sense for command-line applications but also for daemons. A popular approach to debugging daemons is to start them from the command line, possibly with a specific debug flag, so that the daemon doesn't detach and run in the background. However, this is often not possible on SELinux: the policy will not allow the daemon to run as a command-line foreground process.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec180"/>How to do it…</h2></div></div></div><p>The approach<a id="id569" class="indexterm"/> to use <code class="literal">strace</code> against daemons is similar as with command lines, focusing on the process ID rather than the command:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find out what the process ID of the daemon is:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ pidof postgres</strong></span>
<span class="strong"><strong>2557</strong></span>
</pre></div></li><li class="listitem">Use <code class="literal">strace</code> to attach to the running process:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ strace -o strace.log -f -s 256 -p 2557</strong></span>
</pre></div></li><li class="listitem">Specify which system calls to watch out for. For instance, permission issues while binding or connecting to ports or sockets can be filtered as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ strace -e poll,select,connect,recvfrom,sendto -o strace.log -f -s 256 -p 2557</strong></span>
</pre></div></li><li class="listitem">Press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> to interrupt the <code class="literal">strace</code> session; don't worry, the daemon will continue to run in the background, unharmed.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec181"/>How it works…</h2></div></div></div><p>A popular approach to debugging daemons, which is to start the daemon in the foreground from the command line, often does not work on SELinux systems:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ postgres -D /etc/postgresql-9.3 --data-directory=/srv/pgsql/data</strong></span>
<span class="strong"><strong>LOG:  could not bind IPv6 socket: Permission denied</strong></span>
<span class="strong"><strong>WARNING: could not create listen socket for "localhost"</strong></span>
<span class="strong"><strong>FATAL: could not create any TCP/IP sockets</strong></span>
</pre></div><p>If a user has <a id="id570" class="indexterm"/>the rights to execute the daemon binary directly (which isn't default either), then the daemon usually runs with the permissions of the user domain—who hardly has the privileges needed to run the daemon—as there is no transition from the user domain to the daemon domain.</p><p>By using <code class="literal">strace</code> against the daemons, it is possible to debug them in more detail. The <code class="literal">strace</code> application will bind to the process (using the <code class="literal">ptrace</code> method) and be notified of every system call that the daemon performs. The <code class="literal">-f</code> option also ensures that new processes that the daemon launches (for instance, worker processes) are also looked at by <code class="literal">strace</code>.</p><p>To end the <code class="literal">strace</code> session, it is enough to kill the <code class="literal">strace</code> session or interrupt it with <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>. The daemon itself is left untouched.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec182"/>There's more...</h2></div></div></div><p>Many other system analysis tools, which can be used in a very similar manner, exist. Some examples are SystemTap and Sysdig, with a port of DTrace to Linux being actively developed.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec183"/>See also</h2></div></div></div><p>The following resources <a id="id571" class="indexterm"/>cover the<a id="id572" class="indexterm"/> use of <code class="literal">strace</code>, SystemTap, and Sysdig<a id="id573" class="indexterm"/> in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.dedoimedo.com/computers/strace.html">http://www.dedoimedo.com/computers/strace.html</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.thegeekstuff.com/2011/11/strace-examples/">http://www.thegeekstuff.com/2011/11/strace-examples/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.sourceware.org/systemtap/">http://www.sourceware.org/systemtap/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.sysdig.org/wiki/">http://www.sysdig.org/wiki/</a></li></ul></div></div></div>
<div class="section" title="Auditing system behavior"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Auditing system behavior</h1></div></div></div><p>Another approach to<a id="id574" class="indexterm"/> debugging application behavior is through Linux auditing, especially when it is not clear which process is responsible for performing a specific action, as this might make SELinux development a lot more difficult. When developers do not know which domain(s) they need to update privileges for, or do not know how exactly a resource is created, then the Linux audit subsystem can help.</p><p>With the Linux auditing subsystem, administrators can enable rules to log activities. In the audit log, the SELinux context of the subject (process) is shown as well, allowing SELinux developers to properly identify the domain to work with.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec184"/>How to do it…</h2></div></div></div><p>Let's look at how we can ask the Linux audit subsystem which process is responsible for creating a particular directory in a user's home directory through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As the root Linux user (and in an SELinux role with sufficient privileges), tell the audit subsystem to log all write- and attribute-changing operations inside the user's home directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# auditctl -w /home/john/ -p wa -k policydev</strong></span>
</pre></div></li><li class="listitem">Perform the necessary action(s) to trigger the behavior that needs to be debugged.</li><li class="listitem">Query the audit subsystem for the recent audit events with the <code class="literal">policydev</code> key:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# ausearch -ts recent -k policydev</strong></span>
</pre></div></li><li class="listitem">Later, disable the audit rule again so that the audit logs are not cluttered with development-related events:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# auditctl -W /home/john/ -p wa -k policydev</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec185"/>How it works…</h2></div></div></div><p>The Linux audit subsystem uses audit rules to identify which activities need to be logged to the audit log. The rules can be manipulated using the<a id="id575" class="indexterm"/> <code class="literal">auditctl</code> command (audit control).</p><p>In our example, a rule was added for the <code class="literal">/home/john/</code> path (<code class="literal">-w /home/john</code>) for which the write and attribute changes (<code class="literal">-p wa</code>) are logged. The events are tagged, so to speak, with a key called <code class="literal">policydev</code>. Administrators can choose this key freely. Its purpose is to structure audit events and simplify search queries.</p><p>When the <code class="literal">auditctl</code> command is invoked, the rule is immediately active, so after executing the test, audit events will be displayed as follows:</p><div class="informalexample"><pre class="programlisting">time-&gt;Sun Jun  8 11:16:47 2014
type=PATH msg=audit(1402219007.623:80705): item=1 name=".dcinforc" inode=8364 dev=fd:0c mode=040755 ouid=475395 ogid=475395 rdev=00:00 <span class="strong"><strong>obj=user_u:object_r:user_home_t:s0</strong></span> <span class="strong"><strong>nametype=CREATE</strong></span>
type=PATH msg=audit(1402219007.623:80705): item=0 name="/home/john" inode=229 dev=fd:0c mode=040700 ouid=475395 ogid=475395 rdev=00:00 <span class="strong"><strong>obj=user_u:object_r:user_home_dir_t:s0</strong></span> nametype=PARENT
type=CWD msg=audit(1402219007.623:80705):  cwd="/home/john"
type=SYSCALL msg=audit(1402219007.623:80705): arch=c000003e <span class="strong"><strong>syscall=83</strong></span> success=yes exit=0 a0=7fff33d50330 a1=1ff a2=7fff33d50330 a3=a items=2 ppid=23132 pid=23929 auid=475395 uid=475395 gid=475395 euid=475395 suid=475395 fsuid=475395 egid=475395 sgid=475395 fsgid=475395 tty=pts3 ses=11203 comm="java" exe="/usr/bin/java" <span class="strong"><strong>subj=user_u:user_r:java_t:s0</strong></span> key="policydev"</pre></div><p>The logs <a id="id576" class="indexterm"/>show that it is a <code class="literal">java</code> process that is responsible for creating a directory called <code class="literal">.dcinforc/</code> in the user's home directory. The important fields to consider here are the <code class="literal">nametype=CREATE</code> (which tells us that an object was created) and <code class="literal">syscall=83</code> (informing us which system call was trapped by the audit subsystem—in this case, the <code class="literal">mkdir</code> system call) fields, and of course the <code class="literal">subj=</code> and <code class="literal">obj=</code> parameters.</p><p>From the example, we can see that there are two distinct <code class="literal">obj=</code> parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first, <code class="literal">obj=user_u:object_r:user_home_t:s0</code>, is mentioned for the created directory, and it tells us what label the newly created directory received</li><li class="listitem" style="list-style-type: disc">The second, <code class="literal">obj=user_u:object_r:user_home_dir_t:s0</code>, is mentioned for the parent directory (<code class="literal">nametype=PARENT</code>), informing us what the label of the directory in which <code class="literal">.dcinforc/</code> is created is</li></ul></div><p>Now, this is just an example of creating directories, but the audit system can trap many types of activities. This is where the <code class="literal">syscall=</code> field becomes important. This field tells us what specific system call was trapped and logged by the audit subsystem.</p><p>A list of system calls and their associated numbers can be found in the proper <code class="literal">C</code> header file. For instance, the <code class="literal">/usr/include/asm/unistd_64.h</code> file (referenced indirectly through <code class="literal">/usr/include/syscalls.h</code>) contains the following code:</p><div class="informalexample"><pre class="programlisting">#define __NR_rename  82  __SYSCALL(__NR_rename, sys_rename)
#define __NR_mkdir  83  __SYSCALL(__NR_mkdir, sys_mkdir)
#define __NR_rmdir  84  __SYSCALL(__NR_rmdir, sys_rmdir)</pre></div><p>Through this, we<a id="id577" class="indexterm"/> know that the directory was created using the <code class="literal">mkdir</code> system call and not by any other means (such as creating the directory as a different one first and then renaming it).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec186"/>There's more...</h2></div></div></div><p>The audit subsystem<a id="id578" class="indexterm"/> receives the rules it needs to follow up on at boot. Most Linux distributions offer a file called <code class="literal">audit.rules</code> inside <code class="literal">/etc/audit/</code>, which contains various commands, locations, and system calls that need to be trapped and logged. This file is then read at boot time by the audit daemon <code class="literal">init</code> script.</p><p>If we need to have certain rules loaded automatically—and not just for the duration of a short test—then it is recommended to add the rules to this <code class="literal">audit.rules</code> script, together with the appropriate comment explaining why this needs to be trapped.</p><p>Now, we only used path-based auditing capabilities in the example. The Linux audit subsystem, however, can do much more than just that. For instance, it is possible to audit particular system calls. This allows administrators to keep a close eye on suspicious system call usages, such as the use of <code class="literal">unshare</code> (which is used for Linux namespaces):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# auditctl -a entry,always -S unshare -k namespace_suspect</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec187"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A good set of default audit <a id="id579" class="indexterm"/>rules to work with is mentioned in the CISecurity Benchmark for Red Hat Enterprise Linux, available at <a class="ulink" href="https://benchmarks.cisecurity.org/">https://benchmarks.cisecurity.org/</a></li></ul></div></div></div></body></html>