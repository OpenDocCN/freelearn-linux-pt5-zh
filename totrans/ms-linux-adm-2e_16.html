<html><head></head><body>
<div id="_idContainer567">
<h1 class="chapter-number" id="_idParaDest-324"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-325"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.2.1">Deploying Applications with Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Whether you are a seasoned system administrator managing containerized applications or a DevOps engineer automating app orchestration workflows, </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.5.1"> could be your platform of choice. </span><span class="koboSpan" id="kobo.5.2">This chapter will introduce you to Kubernetes and will guide you through the basic process of building and configuring a </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">Kubernetes cluster</span></strong><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">We’ll use Kubernetes to run and scale a simple application in a secure and highly available environment. </span><span class="koboSpan" id="kobo.7.3">You will also learn how to interact with Kubernetes using the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">command-line </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.9.1">interface</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.10.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">CLI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">By the end of this chapter, you’ll learn how to install, configure, and manage a Kubernetes cluster on-premises. </span><span class="koboSpan" id="kobo.13.2">We’ll also show you how to deploy and scale an application </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">using Kubernetes.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">Here’s a brief outline of the topics we will cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Introducing Kubernetes architecture and the API </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">object model</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Installing and </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">configuring Kubernetes</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Working with Kubernetes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.22.1">kubectl</span></strong><span class="koboSpan" id="kobo.23.1"> command-line tool and </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">deploying applications</span></span></li>
</ul>
<h1 id="_idParaDest-326"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.25.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.26.1">You should be familiar with Linux and the CLI in general. </span><span class="koboSpan" id="kobo.26.2">A good grasp of </span><strong class="bold"><span class="koboSpan" id="kobo.27.1">TCP/IP networking</span></strong><span class="koboSpan" id="kobo.28.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.29.1">Docker</span></strong><span class="koboSpan" id="kobo.30.1"> containers would go a long way in making your journey of learning </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Kubernetes easier.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">You will also need </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.34.1">A local desktop machine with a Linux distribution of your choice to install and experiment with the CLI tools used in this chapter. </span><span class="koboSpan" id="kobo.34.2">We will use both Debian and </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Ubuntu LTS.</span></span></li>
<li><span class="koboSpan" id="kobo.36.1">A powerful desktop system with at least 8 CPU cores and at least 16 GB of RAM will allow you to replicate the necessary environment on your desktop as we’ll be devoting a relatively large section to building a Kubernetes cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">using VMs.</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">A </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">desktop hypervisor.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.40.1">Now, let’s start our journey together to </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">discover Kubernetes.</span></span></p>
<h1 id="_idParaDest-327"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.42.1">Introducing Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.43.1">Kubernetes</span><a id="_idIndexMarker2276"/><span class="koboSpan" id="kobo.44.1"> is an open source </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">container orchestrator</span></strong><span class="koboSpan" id="kobo.46.1"> initially developed by Google. </span><span class="koboSpan" id="kobo.46.2">A container orchestrator is a piece of software that automatically manages (including provisioning, deployment, and scaling) containerized applications. </span><span class="koboSpan" id="kobo.46.3">Assuming an application uses containerized microservices, a container orchestration system provides the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">following features:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Elastic orchestration (autoscaling)</span></strong><span class="koboSpan" id="kobo.49.1">: This involves automatically starting and stopping application services (containers) based on</span><a id="_idIndexMarker2277"/><span class="koboSpan" id="kobo.50.1"> specific requirements and conditions – for example, launching multiple web server instances with an increasing number of requests and eventually terminating servers when the number of requests drops below a </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">certain threshold</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Workload management</span></strong><span class="koboSpan" id="kobo.53.1">: This involves optimally</span><a id="_idIndexMarker2278"/><span class="koboSpan" id="kobo.54.1"> deploying and distributing application services across the underlying cluster to ensure mandatory dependencies and redundancy – for example, running a web server endpoint on each cluster node for </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">high availability</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Infrastructure abstraction</span></strong><span class="koboSpan" id="kobo.57.1">: This involves providing</span><a id="_idIndexMarker2279"/><span class="koboSpan" id="kobo.58.1"> container runtime, networking, and load-balancing capabilities – for example, distributing the load among multiple web server containers and autoconfiguring the underlying network connectivity with a database </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">app container</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Declarative configuration</span></strong><span class="koboSpan" id="kobo.61.1">: This involves describing</span><a id="_idIndexMarker2280"/><span class="koboSpan" id="kobo.62.1"> and ensuring the desired state of a multi-tiered application – for example, a web server should be ready for serving requests only when the database backend is up and running, and the underlying storage </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">is available</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.64.1">A classic example of workload orchestration</span><a id="_idIndexMarker2281"/><span class="koboSpan" id="kobo.65.1"> is a video-on-demand streaming service. </span><span class="koboSpan" id="kobo.65.2">With </span><a id="_idIndexMarker2282"/><span class="koboSpan" id="kobo.66.1">a popular new TV show in high demand, the number of streaming requests would significantly exceed the average during a regular season. </span><span class="koboSpan" id="kobo.66.2">With </span><strong class="bold"><span class="koboSpan" id="kobo.67.1">Kubernetes</span></strong><span class="koboSpan" id="kobo.68.1">, we could scale out the number of web servers based on the volume of streaming sessions. </span><span class="koboSpan" id="kobo.68.2">We could also control the possible scale-out of some of the middle-tier components, such as database instances (serving the authentication requests) and storage cache (serving the streams). </span><span class="koboSpan" id="kobo.68.3">When the TV show goes out of fashion, and the number of requests drops significantly, Kubernetes terminates the surplus instances, automatically reducing the application deployment’s footprint and, consequently, the </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">underlying costs.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">Here are some key benefits of deploying applications </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">with Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Speedy deployment</span></strong><span class="koboSpan" id="kobo.73.1">: Application</span><a id="_idIndexMarker2283"/><span class="koboSpan" id="kobo.74.1"> containers are created and launched relatively fast, using either a </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">declarative</span></strong><span class="koboSpan" id="kobo.76.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">imperative</span></strong><span class="koboSpan" id="kobo.78.1"> configuration model (as we’ll see in the </span><em class="italic"><span class="koboSpan" id="kobo.79.1">Introducing the Kubernetes object model</span></em><span class="koboSpan" id="kobo.80.1"> section later in </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">this chapter)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Quick iterations</span></strong><span class="koboSpan" id="kobo.83.1">: Application upgrades are relatively straightforward, with the underlying infrastructure simply seamlessly replacing the </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">related container</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Rapid recovery</span></strong><span class="koboSpan" id="kobo.86.1">: If an application crashes or becomes unavailable, Kubernetes automatically restores the application to the desired state by replacing the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">related container</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">Reduced operation costs</span></strong><span class="koboSpan" id="kobo.89.1">: The</span><a id="_idIndexMarker2284"/><span class="koboSpan" id="kobo.90.1"> containerized environment and infrastructure abstraction of Kubernetes yields minimal administration and maintenance efforts with relatively low resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">running applications</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.92.1">Now that we have introduced Kubernetes, let’s look at its basic operating </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">principles next.</span></span></p>
<h2 id="_idParaDest-328"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.94.1">Understanding the Kubernetes architecture</span></h2>
<p><span class="koboSpan" id="kobo.95.1">There</span><a id="_idIndexMarker2285"/><span class="koboSpan" id="kobo.96.1"> are three major concepts at the core of the working model </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">of Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.98.1">Declarative configuration or desired state</span></strong><span class="koboSpan" id="kobo.99.1">: This concept describes the overall application state and </span><a id="_idIndexMarker2286"/><span class="koboSpan" id="kobo.100.1">microservices, deploying</span><a id="_idIndexMarker2287"/><span class="koboSpan" id="kobo.101.1"> the required containers and related</span><a id="_idIndexMarker2288"/><span class="koboSpan" id="kobo.102.1"> resources, including network, storage, and load balancers, to achieve a running functional state of </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the application</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.104.1">Controllers or controller loops</span></strong><span class="koboSpan" id="kobo.105.1">: This </span><a id="_idIndexMarker2289"/><span class="koboSpan" id="kobo.106.1">monitors the desired state of the </span><a id="_idIndexMarker2290"/><span class="koboSpan" id="kobo.107.1">system and takes</span><a id="_idIndexMarker2291"/><span class="koboSpan" id="kobo.108.1"> corrective action when needed, such as replacing a failed application container or adding additional resources for </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">scale-out workloads</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.110.1">API object model</span></strong><span class="koboSpan" id="kobo.111.1">: This</span><a id="_idIndexMarker2292"/><span class="koboSpan" id="kobo.112.1"> model represents the actual </span><a id="_idIndexMarker2293"/><span class="koboSpan" id="kobo.113.1">implementation of the desired state, using various configuration objects and the interaction – the </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">application programming interface</span></strong><span class="koboSpan" id="kobo.115.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.116.1">API</span></strong><span class="koboSpan" id="kobo.117.1">) – between </span><a id="_idIndexMarker2294"/><span class="No-Break"><span class="koboSpan" id="kobo.118.1">these objects</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.119.1">For a better grasp of the internals of Kubernetes, we need to take a closer look at the Kubernetes object model and related API. </span><span class="koboSpan" id="kobo.119.2">Also, you can check out </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.120.1">Figure 16</span></em></span><em class="italic"><span class="koboSpan" id="kobo.121.1">.1</span></em><span class="koboSpan" id="kobo.122.1"> for a visual explanation of the Kubernetes (</span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">cluster) architecture.</span></span></p>
<h2 id="_idParaDest-329"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.124.1">Introducing the Kubernetes object model</span></h2>
<p><span class="koboSpan" id="kobo.125.1">The Kubernetes </span><a id="_idIndexMarker2295"/><span class="koboSpan" id="kobo.126.1">architecture defines a collection of objects representing the desired state of a</span><a id="_idIndexMarker2296"/><span class="koboSpan" id="kobo.127.1"> system. </span><span class="koboSpan" id="kobo.127.2">An </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">object</span></strong><span class="koboSpan" id="kobo.129.1">, in this context, is a programmatic term to describe the behavior of a subsystem. </span><span class="koboSpan" id="kobo.129.2">Multiple objects interact with one another via the API, shaping the desired state over time. </span><span class="koboSpan" id="kobo.129.3">In other words, the Kubernetes object model is the programmatic representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">desired state.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">So, what are these objects in Kubernetes? </span><span class="koboSpan" id="kobo.131.2">We’ll briefly enumerate some of the more important ones and further elaborate on each in the following sections: API server, pods, controllers, services, </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">and storage.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">We use these API objects to configure the system’s state, using either a declarative or </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">imperative model:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.135.1">With a </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">declarative configuration model</span></strong><span class="koboSpan" id="kobo.137.1">, we describe the state of the system, usually with a configuration file or </span><a id="_idIndexMarker2297"/><span class="koboSpan" id="kobo.138.1">manifest (in YAML or JSON format). </span><span class="koboSpan" id="kobo.138.2">Such a configuration may include and deploy multiple API objects and regard the system as </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">a whole.</span></span></li>
<li><span class="koboSpan" id="kobo.140.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">imperative configuration model</span></strong><span class="koboSpan" id="kobo.142.1"> uses individual commands to configure and deploy specific API objects, typically </span><a id="_idIndexMarker2298"/><span class="koboSpan" id="kobo.143.1">acting on a single target </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">or subsystem.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.145.1">Let’s look at the API server first – the central piece in the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">object model.</span></span></p>
<h3><span class="koboSpan" id="kobo.147.1">Introducing the API server</span></h3>
<p><span class="koboSpan" id="kobo.148.1">The API server</span><a id="_idIndexMarker2299"/><span class="koboSpan" id="kobo.149.1"> is the core</span><a id="_idIndexMarker2300"/><span class="koboSpan" id="kobo.150.1"> hub of the Kubernetes object model, acting as a management endpoint for the desired state of the system. </span><span class="koboSpan" id="kobo.150.2">The API server exposes an HTTP REST interface using JSON payloads. </span><span class="koboSpan" id="kobo.150.3">It is accessible in </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">two ways:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.152.1">Internally</span></strong><span class="koboSpan" id="kobo.153.1">: It is accessed internally by other </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">API objects</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.155.1">Externally</span></strong><span class="koboSpan" id="kobo.156.1">: It is accessed externally by configuration and </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">management workflows</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.158.1">The API server is essentially the gateway of interaction with the Kubernetes cluster, both from the outside and within. </span><span class="koboSpan" id="kobo.158.2">A Kubernetes cluster is a framework of different nodes that run containerized applications. </span><span class="koboSpan" id="kobo.158.3">The cluster is the basic running mode of Kubernetes itself. </span><span class="koboSpan" id="kobo.158.4">More on the Kubernetes cluster will be provided in the </span><em class="italic"><span class="koboSpan" id="kobo.159.1">Anatomy of a Kubernetes cluster</span></em><span class="koboSpan" id="kobo.160.1"> section. </span><span class="koboSpan" id="kobo.160.2">A system administrator connects to the API server endpoint to configure and manage a Kubernetes cluster, typically via a CLI. </span><span class="koboSpan" id="kobo.160.3">Internally, Kubernetes </span><a id="_idIndexMarker2301"/><span class="koboSpan" id="kobo.161.1">API objects connect to the API server to provide an update of their state. </span><span class="koboSpan" id="kobo.161.2">In return, the API </span><a id="_idIndexMarker2302"/><span class="koboSpan" id="kobo.162.1">server may further adjust the internal configuration of the API objects toward the </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">desired state.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">The API objects are the building blocks of the internal configuration or desired state of a Kubernetes cluster. </span><span class="koboSpan" id="kobo.164.2">Let’s look at a few of these API </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">objects next.</span></span></p>
<h3><span class="koboSpan" id="kobo.166.1">Introducing pods</span></h3>
<p><span class="koboSpan" id="kobo.167.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">pod</span></strong><span class="koboSpan" id="kobo.169.1"> represents </span><a id="_idIndexMarker2303"/><span class="koboSpan" id="kobo.170.1">the basic working unit in Kubernetes, running as a single- or multi-container application. </span><span class="koboSpan" id="kobo.170.2">A </span><a id="_idIndexMarker2304"/><span class="koboSpan" id="kobo.171.1">pod is also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">unit of scheduling</span></strong><span class="koboSpan" id="kobo.173.1"> in Kubernetes. </span><span class="koboSpan" id="kobo.173.2">In other </span><a id="_idIndexMarker2305"/><span class="koboSpan" id="kobo.174.1">words, containers within the same pod are guaranteed to be deployed together on the same </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">cluster node.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">A pod essentially represents a microservice (or a service) within the application’s service mesh. </span><span class="koboSpan" id="kobo.176.2">Considering the classic example of a web application, we may have the following pods running in </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">the cluster:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.178.1">Web </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">server (Nginx)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.180.1">Authentication (Vault)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.181.1">Database (PostgreSQL)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.182.1">Storage (NAS)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.183.1">Each of these services (or applications) runs within their pod. </span><span class="koboSpan" id="kobo.183.2">Multiple pods of the same application (for example, a </span><a id="_idIndexMarker2306"/><span class="koboSpan" id="kobo.184.1">web server) make up a </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">ReplicaSet</span></strong><span class="koboSpan" id="kobo.186.1">. </span><span class="koboSpan" id="kobo.186.2">We’ll look at ReplicaSets closer in the </span><em class="italic"><span class="koboSpan" id="kobo.187.1">Introducing </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.188.1">controllers</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.189.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">Some essential features of pods are </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.192.1">They have an </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">ephemeral nature</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">Once a pod is terminated, it is gone for good. </span><span class="koboSpan" id="kobo.194.3">No pod ever gets redeployed in Kubernetes. </span><span class="koboSpan" id="kobo.194.4">Consequently, pods don’t persist in any state unless they use persistent storage or a local volume to save </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">their data.</span></span></li>
<li><span class="koboSpan" id="kobo.196.1">Pods are an </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">atomic unit</span></strong><span class="koboSpan" id="kobo.198.1"> – they are </span><a id="_idIndexMarker2307"/><span class="koboSpan" id="kobo.199.1">either deployed or not. </span><span class="koboSpan" id="kobo.199.2">For a single-container pod, atomicity is almost a given. </span><span class="koboSpan" id="kobo.199.3">For multi-container pods, atomicity means that a pod is</span><a id="_idIndexMarker2308"/><span class="koboSpan" id="kobo.200.1"> deployed only when each of the constituent containers is deployed. </span><span class="koboSpan" id="kobo.200.2">If any </span><a id="_idIndexMarker2309"/><span class="koboSpan" id="kobo.201.1">of the containers fail to deploy, the pod will not be deployed, and hence there’s no pod. </span><span class="koboSpan" id="kobo.201.2">If one of the containers within a running multi-container pod fails, the whole pod </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">is terminated.</span></span></li>
<li><span class="koboSpan" id="kobo.203.1">Kubernetes uses </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">probes</span></strong><span class="koboSpan" id="kobo.205.1"> (such as </span><a id="_idIndexMarker2310"/><span class="koboSpan" id="kobo.206.1">liveliness and readiness) to monitor the </span><a id="_idIndexMarker2311"/><span class="koboSpan" id="kobo.207.1">health of an application inside a pod. </span><span class="koboSpan" id="kobo.207.2">This is because a pod could be deployed and running, but that doesn’t necessarily mean the application or service within the pod is healthy. </span><span class="koboSpan" id="kobo.207.3">For example, a web server pod can have a probe that checks a specific URL and decides whether it’s healthy based on </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">the response.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.209.1">Kubernetes tracks the state of pods using controllers. </span><span class="koboSpan" id="kobo.209.2">Let’s look at </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">controllers next.</span></span></p>
<h3><span class="koboSpan" id="kobo.211.1">Introducing controllers</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.212.1">Controllers</span></strong><span class="koboSpan" id="kobo.213.1"> in</span><a id="_idIndexMarker2312"/><span class="koboSpan" id="kobo.214.1"> Kubernetes are control loops responsible for keeping the system in the desired state or </span><a id="_idIndexMarker2313"/><span class="koboSpan" id="kobo.215.1">bringing the system closer to the desired state by constantly watching the state of the cluster. </span><span class="koboSpan" id="kobo.215.2">For example, a controller may detect that a pod is not responding and request the deployment of a new pod while terminating the old one. </span><span class="koboSpan" id="kobo.215.3">Let’s look at two key types </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">of controllers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.217.1">A controller may also add or remove pods of a specific type to and from a collection of pod replicas. </span><span class="koboSpan" id="kobo.217.2">Such controllers are</span><a id="_idIndexMarker2314"/><span class="koboSpan" id="kobo.218.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">ReplicaSets</span></strong><span class="koboSpan" id="kobo.220.1">, and their responsibility is to accommodate a particular number of pod replicas based on the current state of the application. </span><span class="koboSpan" id="kobo.220.2">For example, suppose an application requires three web server pods, and one of them becomes unavailable (due to a failed probe). </span><span class="koboSpan" id="kobo.220.3">In that case, the ReplicaSet controller ensures that the failed pod is deleted, and a new one takes </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">its place.</span></span></li>
<li><span class="koboSpan" id="kobo.222.1">When deploying applications in Kubernetes, we usually don’t use ReplicaSets directly to create pods. </span><span class="koboSpan" id="kobo.222.2">We</span><a id="_idIndexMarker2315"/><span class="koboSpan" id="kobo.223.1"> use the </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Deployment</span></strong><span class="koboSpan" id="kobo.225.1"> controller instead, which is responsible for monitoring Kubernetes Deployments. </span><span class="koboSpan" id="kobo.225.2">Given the declarative model of Kubernetes, we can define a Deployment with one or more ReplicaSets. </span><span class="koboSpan" id="kobo.225.3">It’s the Deployment controller’s job to create the ReplicaSet with the required number of pods and manage the ReplicaSet’s state; in other words, it controls which container image to load and the number of pods </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">to create.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.227.1">A Deployment controller can also manage the transition from one ReplicaSet to another, a functionality used in rollout or upgrade scenarios. </span><span class="koboSpan" id="kobo.227.2">Imagine we have a ReplicaSet (</span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">v1</span></strong><span class="koboSpan" id="kobo.229.1">) with several pods, all running version 1 of our application, and we want to upgrade them to version 2. </span><span class="koboSpan" id="kobo.229.2">Remember, pods cannot be regenerated or upgraded. </span><span class="koboSpan" id="kobo.229.3">Instead, we’ll define a second ReplicaSet (</span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">v2</span></strong><span class="koboSpan" id="kobo.231.1">), creating the version 2 pods. </span><span class="koboSpan" id="kobo.231.2">The Deployment controller will tear down the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">v1</span></strong><span class="koboSpan" id="kobo.233.1"> ReplicaSet and bring up </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">v2</span></strong><span class="koboSpan" id="kobo.235.1">. </span><span class="koboSpan" id="kobo.235.2">Kubernetes performs the rollout seamlessly, with minimal to no disruption of service. </span><span class="koboSpan" id="kobo.235.3">The Deployment controller manages the transition between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">v1</span></strong><span class="koboSpan" id="kobo.237.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">v2</span></strong><span class="koboSpan" id="kobo.239.1"> ReplicaSets </span><a id="_idIndexMarker2316"/><span class="koboSpan" id="kobo.240.1">and even</span><a id="_idIndexMarker2317"/><span class="koboSpan" id="kobo.241.1"> rolls back the transition </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">if needed.</span></span></p></li>
</ul>
<p><span class="koboSpan" id="kobo.243.1">There are many other controller types </span><a id="_idIndexMarker2318"/><span class="koboSpan" id="kobo.244.1">in Kubernetes, and we encourage you to explore them </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">at </span></span><a href="https://kubernetes.io/docs/concepts/workloads/controllers/"><span class="No-Break"><span class="koboSpan" id="kobo.246.1">https://kubernetes.io/docs/concepts/workloads/controllers/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.247.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">As applications scale-out or terminate, the related pods are deployed or removed. </span><span class="koboSpan" id="kobo.248.2">Services provide access to the dynamic and transient world of pods. </span><span class="koboSpan" id="kobo.248.3">We’ll look at </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">Services next.</span></span></p>
<h3><span class="koboSpan" id="kobo.250.1">Introducing Services</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.251.1">Services</span></strong><span class="koboSpan" id="kobo.252.1"> provide persistent </span><a id="_idIndexMarker2319"/><span class="koboSpan" id="kobo.253.1">access to the applications running in pods. </span><span class="koboSpan" id="kobo.253.2">It is the Services’ responsibility to ensure that the pods are accessible by routing the traffic to the corresponding application endpoints. </span><span class="koboSpan" id="kobo.253.3">In other words, Services provide network abstraction for communicating with pods through IP addresses, routing, and DNS resolution. </span><span class="koboSpan" id="kobo.253.4">As</span><a id="_idIndexMarker2320"/><span class="koboSpan" id="kobo.254.1"> pods are deployed or terminated based on the system’s desired state, Kubernetes dynamically updates the Service endpoint of the pods, with minimal to no disruption in terms of accessing the related applications. </span><span class="koboSpan" id="kobo.254.2">As users and applications access the Service endpoint’s persistent IP address, the Service will ensure that the routing information is up to date and traffic is exclusively routed to the running and healthy pods. </span><span class="koboSpan" id="kobo.254.3">Services can also be leveraged to load-balance the application traffic between pods and scale pods up or down based </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">on demand.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">So far, we have looked at Kubernetes API objects controlling the deployment, access, and life cycle of application Services. </span><span class="koboSpan" id="kobo.256.2">What about the persistent data that applications require? </span><span class="koboSpan" id="kobo.256.3">We’ll look at the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">storage next.</span></span></p>
<h3><span class="koboSpan" id="kobo.258.1">Introducing storage</span></h3>
<p><span class="koboSpan" id="kobo.259.1">Kubernetes</span><a id="_idIndexMarker2321"/><span class="koboSpan" id="kobo.260.1"> provides various </span><a id="_idIndexMarker2322"/><span class="koboSpan" id="kobo.261.1">storage types for applications running within the cluster. </span><span class="koboSpan" id="kobo.261.2">The most common</span><a id="_idIndexMarker2323"/><span class="koboSpan" id="kobo.262.1"> are </span><strong class="bold"><span class="koboSpan" id="kobo.263.1">volumes</span></strong><span class="koboSpan" id="kobo.264.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">persistent volumes</span></strong><span class="koboSpan" id="kobo.266.1">. </span><span class="koboSpan" id="kobo.266.2">Due to the ephemeral nature of pods, application data stored within a pod using volumes is lost when the pod is terminated. </span><span class="koboSpan" id="kobo.266.3">Persistent volumes are</span><a id="_idIndexMarker2324"/><span class="koboSpan" id="kobo.267.1"> defined and managed at the Kubernetes cluster level, and they are independent of pods. </span><span class="koboSpan" id="kobo.267.2">Applications (pods) requiring a persistent state would reserve a persistent volume (of a specific size), using a </span><strong class="bold"><span class="koboSpan" id="kobo.268.1">persistent volume claim</span></strong><span class="koboSpan" id="kobo.269.1">. </span><span class="koboSpan" id="kobo.269.2">When a </span><a id="_idIndexMarker2325"/><span class="koboSpan" id="kobo.270.1">pod using a persistent volume terminates, the new pod replacing the old one retrieves the current state </span><a id="_idIndexMarker2326"/><span class="koboSpan" id="kobo.271.1">from the persistent volume and will continue using the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">underlying storage.</span></span></p>
<p><span class="koboSpan" id="kobo.273.1">For more information on </span><a id="_idIndexMarker2327"/><span class="koboSpan" id="kobo.274.1">Kubernetes storage types, please refer </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">to </span></span><a href="https://kubernetes.io/docs/concepts/storage/"><span class="No-Break"><span class="koboSpan" id="kobo.276.1">https://kubernetes.io/docs/concepts/storage/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.277.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">Now that we are familiar with the Kubernetes API object model, let’s quickly go through the architecture of a </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">Kubernetes cluster.</span></span></p>
<h2 id="_idParaDest-330"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.280.1">The anatomy of a Kubernetes cluster</span></h2>
<p><span class="koboSpan" id="kobo.281.1">A Kubernetes cluster consists of one </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Control Plane</span></strong><span class="koboSpan" id="kobo.283.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.284.1">CP</span></strong><span class="koboSpan" id="kobo.285.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">node</span></strong><span class="koboSpan" id="kobo.287.1"> and one or more </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">worker nodes</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">The following diagram presents a high-level view of the </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">Kubernetes architecture:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer507">
<span class="koboSpan" id="kobo.291.1"><img alt="Figure 16.1 – Kubernetes cluster architecture" src="image/B19682_16_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.292.1">Figure 16.1 – Kubernetes cluster architecture</span></p>
<p><span class="koboSpan" id="kobo.293.1">The components of a Kubernetes cluster that are shown in the preceding figure are divided into the worker node and CP node as the two major components. </span><span class="koboSpan" id="kobo.293.2">The Worker nodes have different components, such as the container runtime, kubelet, and kube-proxy, and the CP node has the API server, the controller manager, and the scheduler. </span><span class="koboSpan" id="kobo.293.3">All of these components will be discussed in detail in the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">following sections.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">First, let’s look at the Kubernetes cluster nodes shown in the preceding image in some detail next, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">CP node.</span></span></p>
<h3><span class="koboSpan" id="kobo.297.1">Introducing the Kubernetes CP</span></h3>
<p><span class="koboSpan" id="kobo.298.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.299.1">Kubernetes CP</span></strong><span class="koboSpan" id="kobo.300.1"> provides </span><a id="_idIndexMarker2328"/><span class="koboSpan" id="kobo.301.1">essential Services for deploying and orchestrating application workloads, and it runs on a dedicated node in the Kubernetes cluster – the CP node. </span><span class="koboSpan" id="kobo.301.2">This node, also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">master node</span></strong><span class="koboSpan" id="kobo.303.1">, implements the core components of a</span><a id="_idIndexMarker2329"/><span class="koboSpan" id="kobo.304.1"> Kubernetes cluster, such as resource scheduling and monitoring. </span><span class="koboSpan" id="kobo.304.2">It’s also the primary access point for cluster administration. </span><span class="koboSpan" id="kobo.304.3">Here are the key subsystems of a </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">CP node:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.306.1">API server</span></strong><span class="koboSpan" id="kobo.307.1">: The</span><a id="_idIndexMarker2330"/><span class="koboSpan" id="kobo.308.1"> central communication hub between Kubernetes API objects; it also provides the cluster’s management endpoint accessible either via CLI or the Kubernetes web administration </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">console (dashboard)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.310.1">Scheduler</span></strong><span class="koboSpan" id="kobo.311.1">: This decides </span><a id="_idIndexMarker2331"/><span class="koboSpan" id="kobo.312.1">when and which nodes to deploy the pods on, depending on resource allocation and </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">administrative policies</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.314.1">Controller manager</span></strong><span class="koboSpan" id="kobo.315.1">: This maintains</span><a id="_idIndexMarker2332"/><span class="koboSpan" id="kobo.316.1"> the control loops, monitoring and shaping the desired state of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the system</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.318.1">etcd</span></strong><span class="koboSpan" id="kobo.319.1">: Also known as </span><a id="_idIndexMarker2333"/><span class="koboSpan" id="kobo.320.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.321.1">cluster store</span></strong><span class="koboSpan" id="kobo.322.1">, this is a highly available persisted database, maintaining the</span><a id="_idIndexMarker2334"/><span class="koboSpan" id="kobo.323.1"> state of the Kubernetes cluster and related API objects; the information in etcd is stored as </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">key-value pairs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">kubectl</span></strong><span class="koboSpan" id="kobo.326.1">: The </span><a id="_idIndexMarker2335"/><span class="koboSpan" id="kobo.327.1">primary administrative CLI for managing and interacting with the Kubernetes cluster; </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">kubectl</span></strong><span class="koboSpan" id="kobo.329.1"> communicates directly with the API server, and it may connect remotely to </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">a cluster</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.331.1">A detailed architectural overview of the Kubernetes CP</span><a id="_idIndexMarker2336"/><span class="koboSpan" id="kobo.332.1"> is beyond the scope of this chapter. </span><span class="koboSpan" id="kobo.332.2">You may explore the related concepts in more detail </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">at </span></span><a href="https://kubernetes.io/docs/concepts/architecture/"><span class="No-Break"><span class="koboSpan" id="kobo.334.1">https://kubernetes.io/docs/concepts/architecture/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.335.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Next, let’s take a brief look at the Kubernetes node – the workhorse of a </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">Kubernetes cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.338.1">Introducing the Kubernetes nodes</span></h3>
<p><span class="koboSpan" id="kobo.339.1">In a </span><a id="_idIndexMarker2337"/><span class="koboSpan" id="kobo.340.1">Kubernetes cluster, the </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">nodes</span></strong><span class="koboSpan" id="kobo.342.1"> – also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.343.1">worker nodes</span></strong><span class="koboSpan" id="kobo.344.1"> – run the </span><a id="_idIndexMarker2338"/><span class="koboSpan" id="kobo.345.1">actual application pods and</span><a id="_idIndexMarker2339"/><span class="koboSpan" id="kobo.346.1"> maintain their full life cycle. </span><span class="koboSpan" id="kobo.346.2">Nodes provide the compute capacity of Kubernetes and ensure that the workloads are uniformly distributed across the cluster when deploying and running pods. </span><span class="koboSpan" id="kobo.346.3">Nodes can be configured either as physical (bare metal) </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">or VMs.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Let’s enumerate the key elements of a </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">Kubernetes node:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.350.1">Kubelet</span></strong><span class="koboSpan" id="kobo.351.1">: This processes CP requests (from the scheduler) to deploy and start application pods; the kubelet</span><a id="_idIndexMarker2340"/><span class="koboSpan" id="kobo.352.1"> also monitors the node and pod state, reporting the related changes to the </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">API server</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.354.1">Kube-Proxy</span></strong><span class="koboSpan" id="kobo.355.1">: Dynamically </span><a id="_idIndexMarker2341"/><span class="koboSpan" id="kobo.356.1">configures the virtual networking environment for the applications running in the pods; it routes the network traffic, provides load balancing, and maintains the IP addresses of Services </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">and pods</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.358.1">Container runtime</span></strong><span class="koboSpan" id="kobo.359.1">: Provides the</span><a id="_idIndexMarker2342"/><span class="koboSpan" id="kobo.360.1"> runtime environment for the pods as application containers; uses </span><a id="_idIndexMarker2343"/><span class="koboSpan" id="kobo.361.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.362.1">Container Runtime Interface</span></strong><span class="koboSpan" id="kobo.363.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.364.1">CRI</span></strong><span class="koboSpan" id="kobo.365.1">) to interact with the </span><a id="_idIndexMarker2344"/><span class="koboSpan" id="kobo.366.1">underlying container engine (such</span><a id="_idIndexMarker2345"/><span class="koboSpan" id="kobo.367.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">containerd</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.369.1">and Docker)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.370.1">All the preceding Services run on </span><em class="italic"><span class="koboSpan" id="kobo.371.1">each</span></em><span class="koboSpan" id="kobo.372.1"> node in the Kubernetes cluster, including the CP node. </span><span class="koboSpan" id="kobo.372.2">These components in the CP are required by special-purpose pods, providing specific CP Services, such as DNS, ingress (load balancing), and dashboard (</span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">web console).</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">For more information on Kubernetes nodes</span><a id="_idIndexMarker2346"/><span class="koboSpan" id="kobo.375.1"> and related architectural concepts, please </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">visit </span></span><a href="https://kubernetes.io/docs/concepts/architecture/nodes/"><span class="No-Break"><span class="koboSpan" id="kobo.377.1">https://kubernetes.io/docs/concepts/architecture/nodes/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.378.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">Now that we have become familiar with some of the key concepts and cluster components, let’s get ready to install and </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">configure Kubernetes.</span></span></p>
<h1 id="_idParaDest-331"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.381.1">Installing and configuring Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.382.1">Before installing or using Kubernetes, you have to decide on the infrastructure you’ll use, whether that be on-premises or public cloud. </span><span class="koboSpan" id="kobo.382.2">Second, you’ll have to choose between an </span><strong class="bold"><span class="koboSpan" id="kobo.383.1">Infrastructure-as-a-Service</span></strong><span class="koboSpan" id="kobo.384.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.385.1">IaaS</span></strong><span class="koboSpan" id="kobo.386.1">) or a </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Platform-as-a-Service</span></strong><span class="koboSpan" id="kobo.388.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">PaaS</span></strong><span class="koboSpan" id="kobo.390.1">) model. </span><span class="koboSpan" id="kobo.390.2">With IaaS, you’ll have to</span><a id="_idIndexMarker2347"/><span class="koboSpan" id="kobo.391.1"> install, configure, manage, and maintain the Kubernetes cluster yourself, either on </span><a id="_idIndexMarker2348"/><span class="koboSpan" id="kobo.392.1">physical (bare metal) or VMs. </span><span class="koboSpan" id="kobo.392.2">The related operation efforts are not</span><a id="_idIndexMarker2349"/><span class="koboSpan" id="kobo.393.1"> straightforward and should be considered carefully. </span><span class="koboSpan" id="kobo.393.2">If you choose</span><a id="_idIndexMarker2350"/><span class="koboSpan" id="kobo.394.1"> a PaaS solution, available from all major public cloud providers, you’ll be limited to only administrative tasks but saved from the burden of maintaining the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">underlying infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">In this chapter, we’ll cover only IaaS deployments of Kubernetes. </span><span class="koboSpan" id="kobo.396.2">For IaaS, we’ll use a local desktop environment running </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">Ubuntu VMs.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">For the on-premises installation, we may also choose between a lightweight desktop version of Kubernetes or a full-blown cluster with multiple nodes. </span><span class="koboSpan" id="kobo.398.2">Let’s look at some of the most common desktop versions of </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">Kubernetes next.</span></span></p>
<h2 id="_idParaDest-332"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.400.1">Installing Kubernetes on a desktop</span></h2>
<p><span class="koboSpan" id="kobo.401.1">If you’re </span><a id="_idIndexMarker2351"/><span class="koboSpan" id="kobo.402.1">looking only to experiment with Kubernetes, a desktop </span><a id="_idIndexMarker2352"/><span class="koboSpan" id="kobo.403.1">version may fit the bill. </span><span class="koboSpan" id="kobo.403.2">Desktop versions of Kubernetes usually deploy a single-node cluster on your local machine. </span><span class="koboSpan" id="kobo.403.3">Depending on your platform of choice, whether it be Windows, macOS, or Linux, you have plenty of Kubernetes engines to select from. </span><span class="koboSpan" id="kobo.403.4">Here are just </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">a few:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.405.1">Docker Desktop (macOS, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.406.1">Windows)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">: </span></span><a href="https://www.docker.com/products/docker-desktop"><span class="No-Break"><span class="koboSpan" id="kobo.408.1">https://www.docker.com/products/docker-desktop</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.409.1">minikube (Linux, macOS, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.410.1">Windows)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">: </span></span><a href="https://minikube.sigs.k8s.io/docs/"><span class="No-Break"><span class="koboSpan" id="kobo.412.1">https://minikube.sigs.k8s.io/docs/</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.413.1">Microk8s (Linux, macOS, </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.414.1">Windows)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">: </span></span><a href="https://microk8s.io/"><span class="No-Break"><span class="koboSpan" id="kobo.416.1">https://microk8s.io/</span></span></a></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.417.1">k3s (</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.418.1">Linux)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">: </span></span><a href="https://k3s.io/"><span class="No-Break"><span class="koboSpan" id="kobo.420.1">https://k3s.io/</span></span></a></li>
</ul>
<p><span class="koboSpan" id="kobo.421.1">In this section, we’ll show you how to install Microk8s, one of the trending Kubernetes desktop engines at the time of writing. </span><span class="koboSpan" id="kobo.421.2">Microk8s is available to install via the Snap Store. </span><span class="koboSpan" id="kobo.421.3">We will use Debian 12 as the base operating system on our test computer, so we can install Microk8s from the Snap Store. </span><span class="koboSpan" id="kobo.421.4">If you don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">snapd</span></strong><span class="koboSpan" id="kobo.423.1"> installed, you will have to first proceed and install it. </span><span class="koboSpan" id="kobo.423.2">You will have to use the following command to install the </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">Snap daemon:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.425.1">
sudo apt install snapd</span></pre> <p><span class="koboSpan" id="kobo.426.1">If you already have </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">snapd</span></strong><span class="koboSpan" id="kobo.428.1"> installed, you can skip this first step. </span><span class="koboSpan" id="kobo.428.2">The following step will be to run the command to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.429.1">snapd</span></strong><span class="koboSpan" id="kobo.430.1"> core runtime environment needed to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">Snap Store:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.432.1">
sudo snap install core</span></pre> <p><span class="koboSpan" id="kobo.433.1">Only after </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">snap</span></strong><span class="koboSpan" id="kobo.435.1"> is installed, you </span><a id="_idIndexMarker2353"/><span class="koboSpan" id="kobo.436.1">can install </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">microk8s</span></strong><span class="koboSpan" id="kobo.438.1"> by using the </span><a id="_idIndexMarker2354"/><span class="No-Break"><span class="koboSpan" id="kobo.439.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.440.1">
sudo snap install microk8s --classic</span></pre> <p><span class="koboSpan" id="kobo.441.1">A successful installation of Microk8s should yield the </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">following result:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer508">
<span class="koboSpan" id="kobo.443.1"><img alt="Figure 16.2 – Installing Microk8s on Linux" src="image/B19682_16_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.444.1">Figure 16.2 – Installing Microk8s on Linux</span></p>
<p><span class="koboSpan" id="kobo.445.1">As we already had </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">snapd</span></strong><span class="koboSpan" id="kobo.447.1"> installed, we did not run the first of the commands </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">listed previously.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">To access the Microk8s CLI without </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">sudo</span></strong><span class="koboSpan" id="kobo.451.1"> permissions, you’ll have to add the local user account to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">microk8s</span></strong><span class="koboSpan" id="kobo.453.1"> group and also fix the permissions on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">~/.kube</span></strong><span class="koboSpan" id="kobo.455.1"> directory with the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.457.1">
sudo usermod -aG microk8s $USER
sudo chown -f -R $USER ~/.kube</span></pre> <p><span class="koboSpan" id="kobo.458.1">The changes will take effect on the next login, and you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">microk8s</span></strong><span class="koboSpan" id="kobo.460.1"> command-line utility with invocations that are not </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">sudo</span></strong><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">For example, the following command displays the help for </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">the tool:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.464.1">
microk8s help</span></pre> <p><span class="koboSpan" id="kobo.465.1">To get the status of the local single-node Microk8s Kubernetes cluster, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.467.1">
microk8s status</span></pre> <p><span class="koboSpan" id="kobo.468.1">As you can see, the installation steps of Microk8s on Debian are straightforward and similar to the ones used </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">in Ubuntu.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">In the next section, we will</span><a id="_idIndexMarker2355"/><span class="koboSpan" id="kobo.471.1"> show you how to install Microk8s on a VM. </span><span class="koboSpan" id="kobo.471.2">This</span><a id="_idIndexMarker2356"/><span class="koboSpan" id="kobo.472.1"> time, we will use Ubuntu 22.04 LTS as the base operating system for </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">the VM.</span></span></p>
<h2 id="_idParaDest-333"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.474.1">Installing Kubernetes on VMs</span></h2>
<p><span class="koboSpan" id="kobo.475.1">In this section, we’ll get </span><a id="_idIndexMarker2357"/><span class="koboSpan" id="kobo.476.1">closer to a real-world Kubernetes</span><a id="_idIndexMarker2358"/><span class="koboSpan" id="kobo.477.1"> environment – though at a much smaller scale – by deploying a Kubernetes cluster on Ubuntu VMs. </span><span class="koboSpan" id="kobo.477.2">You can use any hypervisor, such as KVM, Oracle VirtualBox, or VMware Fusion. </span><span class="koboSpan" id="kobo.477.3">We will use KVM as our </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">preferred hypervisor.</span></span></p>
<p><span class="koboSpan" id="kobo.479.1">We will create four VMs, and we’ll provision each VM with 2 vCPU cores, 2 GB RAM, and 20 GB disk capacity. </span><span class="koboSpan" id="kobo.479.2">You may follow the steps described in the </span><em class="italic"><span class="koboSpan" id="kobo.480.1">Installing Ubuntu</span></em><span class="koboSpan" id="kobo.481.1"> section of </span><a href="B19682_01.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.482.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.483.1">, </span><em class="italic"><span class="koboSpan" id="kobo.484.1">Installing Linux</span></em><span class="koboSpan" id="kobo.485.1">, using your hypervisor </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">of choice.</span></span></p>
<p><span class="koboSpan" id="kobo.487.1">Before we dive into the Kubernetes cluster installation details, let’s take a quick look at our </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">lab environment.</span></span></p>
<h3><span class="koboSpan" id="kobo.489.1">Preparing the lab environment</span></h3>
<p><span class="koboSpan" id="kobo.490.1">Here are the specs of our </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">VM environment:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.492.1">Hypervisor</span></strong><span class="koboSpan" id="kobo.493.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">VMware </span></span><span class="No-Break"><a id="_idIndexMarker2359"/></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">Fusion</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.496.1">Kubernetes cluster</span></strong><span class="koboSpan" id="kobo.497.1">: One CP node and three </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">worker nodes</span></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.499.1">CP node</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">192.168.122.104</span></strong></span></li></ul></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.504.1">Worker nodes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">:</span></span><ul><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">k8s-n1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">192.168.122.146</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">k8s-n2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">192.168.122.233</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">k8s-n3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">192.168.122.163</span></strong></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.515.1">VMs</span></strong><span class="koboSpan" id="kobo.516.1">: Ubuntu Server 22.04.3 LTS, 2 vCPUs, 2 GB RAM, 20 </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">GB disk</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">User</span></strong><span class="koboSpan" id="kobo.519.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">packt</span></strong><span class="koboSpan" id="kobo.521.1"> (on all nodes), with SSH </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">access enabled</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.523.1">We set the username and hostname settings on each VM node on the Ubuntu Server</span><a id="_idIndexMarker2360"/><span class="koboSpan" id="kobo.524.1"> installation wizard. </span><span class="koboSpan" id="kobo.524.2">Also, make sure to enable the OpenSSH server when prompted. </span><span class="koboSpan" id="kobo.524.3">Your VM IP addresses would most probably be different from those in the specs, but that shouldn’t matter. </span><span class="koboSpan" id="kobo.524.4">You may also choose to use static IP addresses for </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">your VMs.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">To make hostname resolution simple within the cluster, edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.528.1"> file on each node and add the related records. </span><span class="koboSpan" id="kobo.528.2">For example, we have the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">/etc/hosts</span></strong><span class="koboSpan" id="kobo.530.1"> file on the CP </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">node (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer509">
<span class="koboSpan" id="kobo.534.1"><img alt="Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)" src="image/B19682_16_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.535.1">Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)</span></p>
<p><span class="koboSpan" id="kobo.536.1">In production environments, with the firewall enabled on the cluster nodes, we have to make sure that the following rules are configured for accepting network traffic within the cluster (according </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">to </span></span><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):"><span class="No-Break"><span class="koboSpan" id="kobo.538.1">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):</span></span></a></p>
<div>
<div class="IMG---Figure" id="_idContainer510">
<span class="koboSpan" id="kobo.539.1"><img alt="Figure 16.4 – The ports used by the Kubernetes cluster nodes" src="image/B19682_16_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.540.1">Figure 16.4 – The ports used by the Kubernetes cluster nodes</span></p>
<p><span class="koboSpan" id="kobo.541.1">The following sections assume that you have the VMs provisioned and running </span><a id="_idIndexMarker2361"/><span class="koboSpan" id="kobo.542.1">according to the preceding specs. </span><span class="koboSpan" id="kobo.542.2">You may take some initial snapshots of your VMs before proceeding with the next steps. </span><span class="koboSpan" id="kobo.542.3">If anything goes wrong with the installation, you can revert to the initial state and </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">start again.</span></span></p>
<p><span class="koboSpan" id="kobo.544.1">Here are the steps we’ll follow to install the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">Kubernetes cluster:</span></span></p>
<ol>
<li><span class="No-Break"><span class="koboSpan" id="kobo.546.1">Disable swapping.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.547.1">Install </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">containerd.</span></strong></span></li>
<li><span class="koboSpan" id="kobo.549.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">kubelet</span></strong><span class="koboSpan" id="kobo.551.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">kubeadm</span></strong><span class="koboSpan" id="kobo.553.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">Kubernetes packages.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.555.1">We’ll have to perform these steps on each cluster node. </span><span class="koboSpan" id="kobo.555.2">The related commands are also captured in the accompanying chapter source code </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">on GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">Let’s start with the first step and disable the memory swap on </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">each node.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Disable swapping</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">swap</span></strong><span class="koboSpan" id="kobo.561.1"> is a disk space used when the memory is full (refer to </span><a href="https://github.com/kubernetes/kubernetes/issues/53533"><span class="koboSpan" id="kobo.562.1">https://github.com/kubernetes/kubernetes/issues/53533</span></a><span class="koboSpan" id="kobo.563.1"> for more details). </span><span class="koboSpan" id="kobo.563.2">The</span><a id="_idIndexMarker2362"/><span class="koboSpan" id="kobo.564.1"> Kubernetes kubelet package doesn’t work with </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">swap</span></strong><span class="koboSpan" id="kobo.566.1"> enabled on Linux platforms. </span><span class="koboSpan" id="kobo.566.2">This means that we will have to disable </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">swap</span></strong><span class="koboSpan" id="kobo.568.1"> on all </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">the nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">To disable </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">swap</span></strong><span class="koboSpan" id="kobo.572.1"> immediately, we run the </span><a id="_idIndexMarker2363"/><span class="koboSpan" id="kobo.573.1">following command on </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">each VM:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.575.1">
sudo swapoff -a</span></pre> <p><span class="koboSpan" id="kobo.576.1">To persist the disabled </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">swap</span></strong><span class="koboSpan" id="kobo.578.1"> with system reboots, we need to comment out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">swap</span></strong><span class="koboSpan" id="kobo.580.1">-related entries in </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">You can do this either manually, by editing </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.584.1">, or with the </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.586.1">
sudo sed -i '/\s*swap\s*/s/^\(.*\)$/# \1/g' /etc/fstab</span></pre> <p><span class="koboSpan" id="kobo.587.1">You may want to double-check that all </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">swap</span></strong><span class="koboSpan" id="kobo.589.1"> entries in </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">/etc/fstab</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.591.1">are disabled:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.592.1">
cat /etc/fstab</span></pre> <p><span class="koboSpan" id="kobo.593.1">We can see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">swap</span></strong><span class="koboSpan" id="kobo.595.1"> mount point commented out in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">etc/fstab</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1"> file:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer511">
<span class="koboSpan" id="kobo.599.1"><img alt="Figure 16.5 – Disabling swap entries in /etc/fstab" src="image/B19682_16_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.600.1">Figure 16.5 – Disabling swap entries in /etc/fstab</span></p>
<p><span class="koboSpan" id="kobo.601.1">Remember to run the preceding commands on each node in the cluster. </span><span class="koboSpan" id="kobo.601.2">Next, we’ll look at installing the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">container runtime.</span></span></p>
<h3><span class="koboSpan" id="kobo.603.1">Installing containerd</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">containerd</span></strong><span class="koboSpan" id="kobo.605.1"> is the</span><a id="_idIndexMarker2364"/><span class="koboSpan" id="kobo.606.1"> default container runtime in recent versions of Kubernetes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">containerd</span></strong><span class="koboSpan" id="kobo.608.1"> implements the </span><a id="_idIndexMarker2365"/><span class="koboSpan" id="kobo.609.1">CRI required</span><a id="_idIndexMarker2366"/><span class="koboSpan" id="kobo.610.1"> by the Kubernetes container engine abstraction layer. </span><span class="koboSpan" id="kobo.610.2">The related installation procedure is not straightforward, and we’ll follow the steps described in the official Kubernetes documentation in the following link at the time of this writing: </span><a href="https://kubernetes.io/docs/setup/production-environment/container-runtimes/"><span class="koboSpan" id="kobo.611.1">https://kubernetes.io/docs/setup/production-environment/container-runtimes/</span></a><span class="koboSpan" id="kobo.612.1">. </span><span class="koboSpan" id="kobo.612.2">These steps may change at any time, so please make sure to check the latest procedure. </span><span class="koboSpan" id="kobo.612.3">The container runtime needs to be installed on each node of the cluster. </span><span class="koboSpan" id="kobo.612.4">We will proceed by installing the needed components on the </span><a id="_idIndexMarker2367"/><span class="koboSpan" id="kobo.613.1">CP node, the VM called </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.615.1">, and then on the other nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">We’ll start by installing some </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1"> prerequisites:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.620.1">First, we enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">br_netfilter</span></strong><span class="koboSpan" id="kobo.622.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">overlay</span></strong><span class="koboSpan" id="kobo.624.1"> kernel modules </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">modprobe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.628.1">sudo modprobe br_netfilter</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.629.1">sudo modprobe overlay</span></strong></pre></li> <li><span class="koboSpan" id="kobo.630.1">We also ensure that these modules are loaded upon </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">system reboots:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.632.1">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/containerd.conf</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.633.1">br_netfilter</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.634.1">overlay</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.635.1">EOF</span></strong></pre></li> <li><span class="koboSpan" id="kobo.636.1">Next, we apply the CRI required </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">sysctl</span></strong><span class="koboSpan" id="kobo.638.1"> parameters, also persisted across </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">system reboots:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.640.1">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/containerd.conf</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.641.1">net.bridge.bridge-nf-call-iptables = 1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.642.1">net.bridge.bridge-nf-call-ip6tables = 1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.643.1">net.ipv4.ip_forward = 1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.644.1">EOF</span></strong></pre></li> <li><span class="koboSpan" id="kobo.645.1">We want the preceding changes to take effect immediately, without a </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">system reboot:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.647.1">
sudo sysctl --system</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.648.1">Here is a screenshot showing the </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">preceding commands:</span></span></p></li> </ol>
<p class="IMG---Figure"/>
<div>
<div class="IMG---Figure" id="_idContainer512">
<span class="koboSpan" id="kobo.650.1"><img alt="Figure 16.6 – Setting containerd prerequisites" src="image/B19682_16_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.651.1">Figure 16.6 – Setting containerd prerequisites</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.652.1">Next, we will verify if specific system variables are enabled in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">sysctl</span></strong><span class="koboSpan" id="kobo.654.1"> configuration by running the</span><a id="_idIndexMarker2368"/> <span class="No-Break"><span class="koboSpan" id="kobo.655.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.656.1">sudo sysctl net.bridge.bridge-nf-call-iptables net.bridge.bridge-nf-call-ip6tables net.ipv4.ip_forward</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.657.1">The output of the command should be </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer513">
<span class="koboSpan" id="kobo.659.1"><img alt="Figure 16.7 – Verifying system variables in sysctl configuration" src="image/B19682_16_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.660.1">Figure 16.7 – Verifying system variables in sysctl configuration</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.661.1">Each variable should have a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">1</span></strong><span class="koboSpan" id="kobo.663.1"> in the output, just as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">previous screenshot.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.665.1">Now, let’s make sure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">apt</span></strong><span class="koboSpan" id="kobo.667.1"> repository is up to date before installing any </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">new packages:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.669.1">sudo apt update</span></strong></pre></li> <li><span class="koboSpan" id="kobo.670.1">Now, we’re ready to </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">install </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.674.1">sudo apt install -y containerd</span></strong></pre></li> <li><span class="koboSpan" id="kobo.675.1">Next, we generate a default </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.677.1"> configuration:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.678.1">sudo mkdir -p /etc/containerd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.679.1">containerd config default | sudo tee /etc/containerd/config.toml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.680.1">These commands will create a new directory and a new default configuration file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">config.toml</span></strong><span class="koboSpan" id="kobo.682.1"> inside it. </span><span class="koboSpan" id="kobo.682.2">The output of the command is too large to show, but it will show you on </span><a id="_idIndexMarker2369"/><span class="koboSpan" id="kobo.683.1">the screen the automatically generated contents of the new file </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">we created.</span></span></p></li> <li><span class="koboSpan" id="kobo.685.1">We need to slightly</span><a id="_idIndexMarker2370"/><span class="koboSpan" id="kobo.686.1"> alter the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">containerd</span></strong><span class="koboSpan" id="kobo.688.1"> configuration to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">systemd</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.690.1">cgroup</span></strong><span class="koboSpan" id="kobo.691.1"> driver with the container runtime (</span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">runc</span></strong><span class="koboSpan" id="kobo.693.1">). </span><span class="koboSpan" id="kobo.693.2">This change is required because the underlying platform (Ubuntu in our case) uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">systemd</span></strong><span class="koboSpan" id="kobo.695.1"> as the Service manager. </span><span class="koboSpan" id="kobo.695.2">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">/etc/containerd/config.toml</span></strong><span class="koboSpan" id="kobo.697.1"> file with your editor of choice, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.699.1">sudo nano /etc/containerd/config.toml</span></strong></pre></li> <li><span class="koboSpan" id="kobo.700.1">Locate the following section (which will be inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">[plugins]</span></strong><span class="koboSpan" id="kobo.702.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">the file):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.704.1">[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]</span></strong></pre></li> <li><span class="koboSpan" id="kobo.705.1">Then, add the highlighted lines, adjusting the appropriate indentation (this is </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.706.1">very</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.707.1"> important):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.708.1">[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.709.1">  ...</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.710.1">  [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.711.1">  SystemdCgroup = true</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.712.1">Here’s the resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">configuration stub:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer514">
<span class="koboSpan" id="kobo.714.1"><img alt="Figure 16.8 – Modifying the containerd configuration" src="image/B19682_16_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.715.1">Figure 16.8 – Modifying the containerd configuration</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.716.1">Save the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">/etc/containerd/config.toml</span></strong><span class="koboSpan" id="kobo.718.1"> file and </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">restart </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.722.1">sudo systemctl restart containerd</span></strong></pre></li> <li><span class="koboSpan" id="kobo.723.1">After a few moments, you</span><a id="_idIndexMarker2371"/><span class="koboSpan" id="kobo.724.1"> can verify the status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">containerd</span></strong><span class="koboSpan" id="kobo.726.1"> Service, by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.728.1">sudo systemctl status containerd</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.729.1">The output should show that the system is running and there are </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">no issues.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.731.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">containerd</span></strong><span class="koboSpan" id="kobo.733.1"> installed</span><a id="_idIndexMarker2372"/><span class="koboSpan" id="kobo.734.1"> and configured, we can proceed with the installation of the</span><a id="_idIndexMarker2373"/><span class="koboSpan" id="kobo.735.1"> Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">packages next.</span></span></p>
<h3><span class="koboSpan" id="kobo.737.1">Installing Kubernetes packages</span></h3>
<p><span class="koboSpan" id="kobo.738.1">To install the Kubernetes packages, we’ll follow the </span><a id="_idIndexMarker2374"/><span class="koboSpan" id="kobo.739.1">steps described at </span><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/"><span class="koboSpan" id="kobo.740.1">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/</span></a><span class="koboSpan" id="kobo.741.1">. </span><span class="koboSpan" id="kobo.741.2">This procedure may also change over time, so please make sure to</span><a id="_idIndexMarker2375"/><span class="koboSpan" id="kobo.742.1"> check out the latest instructions. </span><span class="koboSpan" id="kobo.742.2">The steps presented next are applicable to Debian 12 and Ubuntu 22.04. </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">Let’s begin:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.744.1">We first install the packages required by the Kubernetes </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">apt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.746.1"> repository:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.747.1">sudo apt install -y apt-transport-https ca-certificates curl</span></strong></pre></li> <li><span class="koboSpan" id="kobo.748.1">Next, we </span><a id="_idIndexMarker2376"/><span class="koboSpan" id="kobo.749.1">download the Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">apt</span></strong><span class="koboSpan" id="kobo.751.1"> repository </span><strong class="bold"><span class="koboSpan" id="kobo.752.1">GNU Privacy Guard</span></strong><span class="koboSpan" id="kobo.753.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.754.1">GPG</span></strong><span class="koboSpan" id="kobo.755.1">) public </span><a id="_idIndexMarker2377"/><span class="koboSpan" id="kobo.756.1">signing key (for the latest Kubernetes 1.28 at the time </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">of writing):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.758.1">sudo curl -fsSL </span></strong><a href="https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key"><strong class="bold"><span class="koboSpan" id="kobo.759.1">https://pkgs.k8s.io/core:/stable:/v1.28/deb/Release.key</span></strong></a><strong class="bold"><span class="koboSpan" id="kobo.760.1"> | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg</span></strong></pre></li> <li><span class="koboSpan" id="kobo.761.1">The next command adds the Kubernetes </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">apt</span></strong><span class="koboSpan" id="kobo.763.1"> repository to </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">our system:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.765.1">echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.28/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list</span></strong></pre></li> <li><span class="koboSpan" id="kobo.766.1">Let’s read the packages available in the new repository we </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">just added:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.768.1">sudo apt update -y</span></strong></pre></li> <li><span class="koboSpan" id="kobo.769.1">We’re now ready to install the </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">Kubernetes packages:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.771.1">sudo apt install -y kubelet kubeadm kubectl</span></strong></pre></li> <li><span class="koboSpan" id="kobo.772.1">We want to pin the version of</span><a id="_idIndexMarker2378"/><span class="koboSpan" id="kobo.773.1"> these packages to avoid the inadvertent update via system security patches, and so on. </span><span class="koboSpan" id="kobo.773.2">The Kubernetes packages should exclusively be updated using the cluster upgrade procedures. </span><span class="koboSpan" id="kobo.773.3">We use</span><a id="_idIndexMarker2379"/><span class="koboSpan" id="kobo.774.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">apt-mark hold</span></strong><span class="koboSpan" id="kobo.776.1"> command to pin the version of the Kubernetes packages, </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">including </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.780.1">sudo apt-mark hold containerd kubelet kubeadm kubectl</span></strong></pre></li> <li><span class="koboSpan" id="kobo.781.1">Finally, ensure that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">containerd</span></strong><span class="koboSpan" id="kobo.783.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">kubelet</span></strong><span class="koboSpan" id="kobo.785.1"> Services are enabled upon system </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">startup (reboot):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.787.1">sudo systemctl enable containerd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.788.1">sudo systemctl enable kubelet</span></strong></pre></li> <li><span class="koboSpan" id="kobo.789.1">Now that we have finished installing the Kubernetes packages, let’s check the status of the node Services. </span><span class="koboSpan" id="kobo.789.2">We retrieve the status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">containerd</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.791.1">Service first:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.792.1">sudo systemctl status containerd</span></strong></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">containerd</span></strong><span class="koboSpan" id="kobo.794.1"> should be active and running. </span><span class="koboSpan" id="kobo.794.2">The following is a screenshot showing the output of the </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">preceding commands:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer515">
<span class="koboSpan" id="kobo.796.1"><img alt="Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd" src="image/B19682_16_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.797.1">Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.798.1">Next, let’s check the status of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">kubelet</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1"> Service:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.801.1">sudo systemctl start kubelet &amp;&amp; sudo systemctl status kubelet</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.802.1">At this time, it should be no</span><a id="_idIndexMarker2380"/><span class="koboSpan" id="kobo.803.1"> surprise that the status </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">exited</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer516">
<span class="koboSpan" id="kobo.807.1"><img alt="Figure 16.10 – The kubelet crashing without cluster configuration" src="image/B19682_16_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.808.1">Figure 16.10 – The kubelet crashing without cluster configuration</span></p>
<p><span class="koboSpan" id="kobo.809.1">As shown in the preceding screenshot, </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">kubelet</span></strong><span class="koboSpan" id="kobo.811.1"> is looking for the </span><a id="_idIndexMarker2381"/><span class="koboSpan" id="kobo.812.1">Kubernetes cluster, which is not set up yet. </span><span class="koboSpan" id="kobo.812.2">We can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">kubelet</span></strong><span class="koboSpan" id="kobo.814.1"> attempts to start and activate itself but keeps crashing, as it cannot locate the </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">required configuration.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.816.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.817.1">Please install the required Kubernetes packages on </span><em class="italic"><span class="koboSpan" id="kobo.818.1">all</span></em><span class="koboSpan" id="kobo.819.1"> cluster nodes following the previous steps before proceeding with the </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">next section.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Next, we’ll bootstrap (initialize) the Kubernetes cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">kubeadm</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.825.1">Introducing kubeadm</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">kubeadm</span></strong><span class="koboSpan" id="kobo.827.1"> is a helper</span><a id="_idIndexMarker2382"/><span class="koboSpan" id="kobo.828.1"> tool for</span><a id="_idIndexMarker2383"/><span class="koboSpan" id="kobo.829.1"> creating a Kubernetes cluster and essentially has </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">two invocations:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.832.1">: This bootstraps or initializes a </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">Kubernetes cluster</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">kubeadm join</span></strong><span class="koboSpan" id="kobo.835.1">: This adds a node to a </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">Kubernetes cluster</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.837.1">The default invocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">kubadm init [flags]</span></strong><span class="koboSpan" id="kobo.839.1"> – with no flags – performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">following tasks:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.841.1">Running preliminary checks</span></strong><span class="koboSpan" id="kobo.842.1">: In the very initial phase, </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.844.1"> ensures that we have the minimum system resources in terms of CPU and memory, the required user permissions, and a supported CRI-compliant container runtime. </span><span class="koboSpan" id="kobo.844.2">If any of these checks fail, </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.846.1"> stops the execution of creating the cluster. </span><span class="koboSpan" id="kobo.846.2">If the </span><a id="_idIndexMarker2384"/><span class="koboSpan" id="kobo.847.1">checks succeed, </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">kubeadm</span></strong><span class="koboSpan" id="kobo.849.1"> proceeds to the </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">next step.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.851.1">Creating a Certificate Authority (CA)</span></strong><span class="koboSpan" id="kobo.852.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.854.1"> creates a</span><a id="_idIndexMarker2385"/><span class="koboSpan" id="kobo.855.1"> self-signed CA used by Kubernetes to generate the certificates required to authenticate and run trusted workloads within the cluster. </span><span class="koboSpan" id="kobo.855.2">The CA files are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">/etc/kubernetes/pki</span></strong><span class="koboSpan" id="kobo.857.1">/ directory and are distributed on each node upon joining </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">the cluster.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.859.1">Generating kubeconfig files</span></strong><span class="koboSpan" id="kobo.860.1">: The kubeconfig files are</span><a id="_idIndexMarker2386"/><span class="koboSpan" id="kobo.861.1"> configuration files used by the Kubernetes cluster components to locate, communicate, and authenticate with the API server. </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.863.1"> creates a default set of kubeconfig files required to bootstrap the cluster. </span><span class="koboSpan" id="kobo.863.2">The kubeconfig files are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">etc/kubernetes/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1"> directory.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.867.1">Generating static pod manifests</span></strong><span class="koboSpan" id="kobo.868.1">: Static pods are system-specific</span><a id="_idIndexMarker2387"/><span class="koboSpan" id="kobo.869.1"> pods running exclusively</span><a id="_idIndexMarker2388"/><span class="koboSpan" id="kobo.870.1"> on the CP node and managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">kubelet</span></strong><span class="koboSpan" id="kobo.872.1"> daemon. </span><span class="koboSpan" id="kobo.872.2">Examples of static pods are the API server, the controller manager, scheduler, and etcd. </span><span class="koboSpan" id="kobo.872.3">Static pod manifests are configuration files describing the CP pods. </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.874.1"> generates the static pod manifests during the cluster bootstrapping process. </span><span class="koboSpan" id="kobo.874.2">The manifest files are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">/etc/kubernetes/manifests/</span></strong><span class="koboSpan" id="kobo.876.1"> directory. </span><span class="koboSpan" id="kobo.876.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">kubelet</span></strong><span class="koboSpan" id="kobo.878.1"> Service monitors this location and, when it finds a manifest, deploys the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">static pod.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.880.1">Waiting for the static pods to start</span></strong><span class="koboSpan" id="kobo.881.1">: After</span><a id="_idIndexMarker2389"/><span class="koboSpan" id="kobo.882.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">kubelet</span></strong><span class="koboSpan" id="kobo.884.1"> daemon deploys the static pods, </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">kubeadm</span></strong><span class="koboSpan" id="kobo.886.1"> queries </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">kubelet</span></strong><span class="koboSpan" id="kobo.888.1"> for the static pods’ state. </span><span class="koboSpan" id="kobo.888.2">When the static pods are up and running, </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.890.1"> proceeds with the </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">next stage.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.892.1">Tainting the CP node</span></strong><span class="koboSpan" id="kobo.893.1">: Tainting is the </span><a id="_idIndexMarker2390"/><span class="koboSpan" id="kobo.894.1">process of excluding a node from running</span><a id="_idIndexMarker2391"/><span class="koboSpan" id="kobo.895.1"> user pods. </span><span class="koboSpan" id="kobo.895.2">The opposite concept in a Kubernetes environment is </span><strong class="bold"><span class="koboSpan" id="kobo.896.1">toleration</span></strong><span class="koboSpan" id="kobo.897.1"> – controlling the affinity of pods to specific cluster nodes. </span><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.899.1"> follows the Kubernetes best practice of</span><a id="_idIndexMarker2392"/><span class="koboSpan" id="kobo.900.1"> tainting the CP to avoid user pods running on the CP node. </span><span class="koboSpan" id="kobo.900.2">The obvious reason is to preserve CP resources exclusively for </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">system-specific workloads.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.902.1">Generating a bootstrap token</span></strong><span class="koboSpan" id="kobo.903.1">: Bootstrap tokens are</span><a id="_idIndexMarker2393"/><span class="koboSpan" id="kobo.904.1"> simple bearer tokens used for joining new nodes to </span><a id="_idIndexMarker2394"/><span class="koboSpan" id="kobo.905.1">a Kubernetes cluster. </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.907.1"> generates a bootstrap token that can be shared with a trusted node to join </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">the cluster.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.909.1">Starting add-on pods</span></strong><span class="koboSpan" id="kobo.910.1">: Kubernetes cluster add-ons </span><a id="_idIndexMarker2395"/><span class="koboSpan" id="kobo.911.1">are specific CP components (pods) extending the functionality of the cluster. </span><span class="koboSpan" id="kobo.911.2">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.913.1"> creates and deploys the </span><em class="italic"><span class="koboSpan" id="kobo.914.1">DNS</span></em><span class="koboSpan" id="kobo.915.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.916.1">kube-proxy</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.917.1">add-on pods.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.918.1">The stages of a Kubernetes cluster’s bootstrapping process are highly customizable. </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.920.1">, when invoked without additional parameters, runs all the tasks in the preceding order. </span><span class="koboSpan" id="kobo.920.2">Alternatively, a system administrator may invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.921.1">kubeadm</span></strong><span class="koboSpan" id="kobo.922.1"> command with different option parameters to control and run any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">stages mentioned.</span></span></p>
<p><span class="koboSpan" id="kobo.924.1">For more information about </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">kubeadm</span></strong><span class="koboSpan" id="kobo.926.1">, please refer to the utility’s help with the </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.928.1">
kubeadm help</span></pre> <p><span class="koboSpan" id="kobo.929.1">For more information about bootstrapping a Kubernetes cluster using </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">kubeadm</span></strong><span class="koboSpan" id="kobo.931.1">, including installing, troubleshooting, and customizing components, you may refer to the official Kubernetes documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">at </span></span><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/"><span class="No-Break"><span class="koboSpan" id="kobo.933.1">https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.934.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.935.1">In the next section, we’ll bootstrap a Kubernetes cluster using </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">kubeadm</span></strong><span class="koboSpan" id="kobo.937.1"> to generate a cluster configuration file and then invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.939.1"> to use this configuration. </span><span class="koboSpan" id="kobo.939.2">We’ll bootstrap our cluster by creating</span><a id="_idIndexMarker2396"/><span class="koboSpan" id="kobo.940.1"> the Kubernetes CP </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">node next.</span></span></p>
<h3><span class="koboSpan" id="kobo.942.1">Creating a Kubernetes CP node</span></h3>
<p><span class="koboSpan" id="kobo.943.1">In order to</span><a id="_idIndexMarker2397"/><span class="koboSpan" id="kobo.944.1"> create the CP node, we will use a networking and security solution named </span><strong class="bold"><span class="koboSpan" id="kobo.945.1">Calico</span></strong><span class="koboSpan" id="kobo.946.1"> to manage our workloads. </span><span class="koboSpan" id="kobo.946.2">We will then generate a default cluster using </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">kubeadm</span></strong><span class="koboSpan" id="kobo.948.1">, and afterwards, we will use different tools to apply the </span><a id="_idIndexMarker2398"/><span class="koboSpan" id="kobo.949.1">configurations. </span><span class="koboSpan" id="kobo.949.2">The choice of Calico is purely subjective, but it is needed for managing communications between workloads and components. </span><span class="koboSpan" id="kobo.949.3">For more information about Calico, please visit the following </span><span class="No-Break"><span class="koboSpan" id="kobo.950.1">link: </span></span><a href="https://docs.tigera.io/calico/latest/about/"><span class="No-Break"><span class="koboSpan" id="kobo.951.1">https://docs.tigera.io/calico/latest/about/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.952.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.953.1">The commands are performed on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.955.1"> host in our VM environment. </span><span class="koboSpan" id="kobo.955.2">As the hostname suggests, we choose </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.957.1"> as the CP node of our Kubernetes cluster. </span><span class="koboSpan" id="kobo.957.2">Now, let’s get to work and configure our Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">CP node:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.959.1">We’ll start by downloading the Calico manifest for </span><strong class="bold"><span class="koboSpan" id="kobo.960.1">overlay networking</span></strong><span class="koboSpan" id="kobo.961.1">. </span><span class="koboSpan" id="kobo.961.2">The overlay network – also known as </span><strong class="bold"><span class="koboSpan" id="kobo.962.1">software-defined network</span></strong><span class="koboSpan" id="kobo.963.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.964.1">SDN</span></strong><span class="koboSpan" id="kobo.965.1">) – is a logical networking layer that accommodates a secure and </span><a id="_idIndexMarker2399"/><span class="koboSpan" id="kobo.966.1">seamless network communication between the pods over a physical network that may not be accessible for configuration. </span><span class="koboSpan" id="kobo.966.2">Exploring the internals of cluster networking is beyond the scope of </span><a id="_idIndexMarker2400"/><span class="koboSpan" id="kobo.967.1">this chapter, but we encourage you to read more at </span><a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/"><span class="koboSpan" id="kobo.968.1">https://kubernetes.io/docs/concepts/cluster-administration/networking/</span></a><span class="koboSpan" id="kobo.969.1">. </span><span class="koboSpan" id="kobo.969.2">You’ll also find references to the Calico networking add-on. </span><span class="koboSpan" id="kobo.969.3">To download the related manifest, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.971.1">curl </span></strong><a href="https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml"><strong class="bold"><span class="koboSpan" id="kobo.972.1">https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml</span></strong></a><strong class="bold"><span class="koboSpan" id="kobo.973.1"> -O</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.974.1">The command downloads the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">calico.yaml</span></strong><span class="koboSpan" id="kobo.976.1"> file in the current directory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">/home/packt/</span></strong><span class="koboSpan" id="kobo.978.1">) that we’ll use with </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">kubectl</span></strong><span class="koboSpan" id="kobo.980.1"> to configure pod networking later in </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">the process.</span></span></p></li> <li><span class="koboSpan" id="kobo.982.1">Next, let’s open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.983.1">calico.yaml</span></strong><span class="koboSpan" id="kobo.984.1"> file using a text editor and look for the following lines (starting with </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.985.1">line 3672</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.987.1"># - name: CALICO_IPV4POOL_CIDR</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.988.1">#   value: "192.168.0.0/16"</span></strong></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">CALICO_IPV4POOL_CIDR</span></strong><span class="koboSpan" id="kobo.990.1"> points to the network range associated with the pods. </span><span class="koboSpan" id="kobo.990.2">If the related subnet conflicts in any way with your local environment, you’ll have to change it here. </span><span class="koboSpan" id="kobo.990.3">We’ll leave the setting </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">as is.</span></span></p></li> <li><span class="koboSpan" id="kobo.992.1">Next, we’ll create a </span><a id="_idIndexMarker2401"/><span class="koboSpan" id="kobo.993.1">default cluster configuration file using </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">kubeadm</span></strong><span class="koboSpan" id="kobo.995.1">. </span><span class="koboSpan" id="kobo.995.2">The cluster configuration file describes the settings of the Kubernetes cluster we’re building. </span><span class="koboSpan" id="kobo.995.3">Let’s name this </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">file </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">k8s-config.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.998.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.999.1">kubeadm config print init-defaults | tee k8s-config.yaml</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1000.1">Let’s review</span><a id="_idIndexMarker2402"/><span class="koboSpan" id="kobo.1001.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1002.1">k8s-config.yaml</span></strong><span class="koboSpan" id="kobo.1003.1"> file we just generated and mention a few changes that we’ll have to make. </span><span class="koboSpan" id="kobo.1003.2">We will open it using the </span><strong class="bold"><span class="koboSpan" id="kobo.1004.1">nano</span></strong><span class="koboSpan" id="kobo.1005.1"> text editor first, then we’ll start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1006.1">localAPIEndpoint.advertiseAddress</span></strong><span class="koboSpan" id="kobo.1007.1"> configuration parameter – the IP address of the API server endpoint. </span><span class="koboSpan" id="kobo.1007.2">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">1.2.3.4</span></strong><span class="koboSpan" id="kobo.1009.1">, and we need to change it to the IP address of the VM running the CP node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1010.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.1011.1">), in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">192.168.122.104</span></strong><span class="koboSpan" id="kobo.1013.1">. </span><span class="koboSpan" id="kobo.1013.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1014.1">Preparing the lab environment</span></em><span class="koboSpan" id="kobo.1015.1"> section earlier in this chapter. </span><span class="koboSpan" id="kobo.1015.2">You’ll have to enter the IP address matching </span><span class="No-Break"><span class="koboSpan" id="kobo.1016.1">your environment:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer517">
<span class="koboSpan" id="kobo.1017.1"><img alt="Figure 16.11 – Modifying the advertiseAddress configuration parameter" src="image/B19682_16_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1018.1">Figure 16.11 – Modifying the advertiseAddress configuration parameter</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1019.1">The next change we need to make is pointing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">nodeRegistration.criSocket</span></strong><span class="koboSpan" id="kobo.1021.1"> configuration </span><a id="_idIndexMarker2403"/><span class="koboSpan" id="kobo.1022.1">parameter to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">containerd</span></strong><span class="koboSpan" id="kobo.1024.1"> socket </span><strong class="source-inline"><span class="koboSpan" id="kobo.1025.1">(/run/containerd/containerd.sock</span></strong><span class="koboSpan" id="kobo.1026.1">) and the </span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">name (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">):</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer518">
<span class="koboSpan" id="kobo.1030.1"><img alt="Figure 16.12 – Changing the criSocket configuration parameter" src="image/B19682_16_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1031.1">Figure 16.12 – Changing the criSocket configuration parameter</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1032.1">Next, we change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">kubernetesVersion</span></strong><span class="koboSpan" id="kobo.1034.1"> parameter to match the version of our </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">Kubernetes environment:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer519">
<span class="koboSpan" id="kobo.1036.1"><img alt="Figure 16.13 – Changing the kubernetesVersion parameter" src="image/B19682_16_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1037.1">Figure 16.13 – Changing the kubernetesVersion parameter</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1038.1">The default value is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">1.28.0</span></strong><span class="koboSpan" id="kobo.1040.1">, but </span><a id="_idIndexMarker2404"/><span class="koboSpan" id="kobo.1041.1">our Kubernetes version, using the following command, </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">1.28.2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1045.1">kubeadm version</span></strong></pre> <p class="list-inset"><span class="koboSpan" id="kobo.1046.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer520">
<span class="koboSpan" id="kobo.1048.1"><img alt="Figure 16.14 – Retrieving the current version of Kubernetes" src="image/B19682_16_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1049.1">Figure 16.14 – Retrieving the current version of Kubernetes</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1050.1">Our final modification of the cluster configuration file sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">cgroup</span></strong><span class="koboSpan" id="kobo.1052.1"> driver of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">kubelet</span></strong><span class="koboSpan" id="kobo.1054.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">systemd</span></strong><span class="koboSpan" id="kobo.1056.1">, matching the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">cgroup</span></strong><span class="koboSpan" id="kobo.1058.1"> driver of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">containerd</span></strong><span class="koboSpan" id="kobo.1060.1">. </span><span class="koboSpan" id="kobo.1060.2">Please note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">systemd</span></strong><span class="koboSpan" id="kobo.1062.1"> is the underlying platform’s Service manager (in Ubuntu), hence the need to yield related Service control to the Kubernetes daemons. </span><span class="koboSpan" id="kobo.1062.2">The corresponding configuration block is not yet present in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">k8s-config.yaml</span></strong><span class="koboSpan" id="kobo.1064.1">. </span><span class="koboSpan" id="kobo.1064.2">We can add it manually to the end of the file or</span><a id="_idIndexMarker2405"/><span class="koboSpan" id="kobo.1065.1"> with the</span><a id="_idIndexMarker2406"/> <span class="No-Break"><span class="koboSpan" id="kobo.1066.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1067.1">cat &lt;&lt;EOF | cat &gt;&gt; k8s-config.yaml</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1068.1">---</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1069.1">apiVersion: kubelet.config.k8s.io/v1beta1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1070.1">kind: KubeletConfiguration</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1071.1">cgroupDriver: systemd</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1072.1">EOF</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1073.1">Now, we’re ready to bootstrap the Kubernetes cluster. </span><span class="koboSpan" id="kobo.1073.2">We invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.1075.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">--config</span></strong><span class="koboSpan" id="kobo.1077.1"> option pointing to the cluster configuration file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">k8s-config.yaml</span></strong><span class="koboSpan" id="kobo.1079.1">), and with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1080.1">--cri-socket</span></strong><span class="koboSpan" id="kobo.1081.1"> option parameter pointing to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">containerd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1"> socket:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1084.1">sudo kubeadm init --config=k8s-config.yaml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1085.1">The preceding command takes a couple of minutes to run. </span><span class="koboSpan" id="kobo.1085.2">A successful bootstrap of the Kubernetes cluster </span><a id="_idIndexMarker2407"/><span class="koboSpan" id="kobo.1086.1">completes with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">following output:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer521">
<span class="koboSpan" id="kobo.1088.1"><img alt="Figure 16.15 – Successfully bootstrapping the Kubernetes cluster" src="image/B19682_16_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1089.1">Figure 16.15 – Successfully bootstrapping the Kubernetes cluster</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1090.1">At this point, our Kubernetes</span><a id="_idIndexMarker2408"/><span class="koboSpan" id="kobo.1091.1"> CP node is up and running. </span><span class="koboSpan" id="kobo.1091.2">In the output, we highlighted the relevant excerpts for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">following commands:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1093.1">A successful </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">message (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1095.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1097.1">Configuring the current user as the Kubernetes cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1098.1">administrator (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1099.1">2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.1101.1">Joining new nodes to the Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">cluster (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1103.1">3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1104.1">)</span></span></li>
</ul>
<p class="list-inset"><span class="koboSpan" id="kobo.1105.1">We recommend taking the time to go over the complete output and identify the related information for each of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.1107.1"> tasks, as captured in the </span><em class="italic"><span class="koboSpan" id="kobo.1108.1">Introducing kubeadm</span></em><span class="koboSpan" id="kobo.1109.1"> section earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">this chapter.</span></span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.1111.1">Next, to configure the current user as the Kubernetes cluster administrator, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1112.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1113.1">mkdir -p ~/.kube</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1114.1">sudo cp -i /etc/kubernetes/admin.conf ~/.kube/config</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1115.1">sudo chown $(id -u):$(id -g) ~/.kube/config</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1116.1">With our cluster up and running, let’s deploy the Calico networking manifest to create the </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">pod network:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1118.1">kubectl apply -f calico.yaml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1119.1">The preceding</span><a id="_idIndexMarker2409"/><span class="koboSpan" id="kobo.1120.1"> command creates a collection of resources related to the pod </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">overlay network.</span></span></p></li> <li><span class="koboSpan" id="kobo.1122.1">Now, we’re ready to take </span><a id="_idIndexMarker2410"/><span class="koboSpan" id="kobo.1123.1">our first peek into the state of our cluster by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">kubectl</span></strong><span class="koboSpan" id="kobo.1125.1"> command to list all the pods in </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">the system:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1127.1">kubectl get pods --all-namespaces</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1128.1">The command yields the </span><span class="No-Break"><span class="koboSpan" id="kobo.1129.1">following output:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer522">
<span class="koboSpan" id="kobo.1130.1"><img alt="Figure 16.16 – Retrieving the pods in the Kubernetes cluster" src="image/B19682_16_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1131.1">Figure 16.16 – Retrieving the pods in the Kubernetes cluster</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.1132.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">--all-namespaces</span></strong><span class="koboSpan" id="kobo.1134.1"> option retrieves the pods across all resource groups in the cluster. </span><span class="koboSpan" id="kobo.1134.2">Kubernetes uses </span><strong class="bold"><span class="koboSpan" id="kobo.1135.1">namespaces</span></strong><span class="koboSpan" id="kobo.1136.1"> to organize resources. </span><span class="koboSpan" id="kobo.1136.2">For now, the only pods running in our cluster are </span><strong class="bold"><span class="koboSpan" id="kobo.1137.1">system pods</span></strong><span class="koboSpan" id="kobo.1138.1">, as we haven’t deployed any </span><strong class="bold"><span class="koboSpan" id="kobo.1139.1">user </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1140.1">pods</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1"> yet.</span></span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.1142.1">The following command retrieves the current nodes in </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">the cluster:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1144.1">kubectl get nodes</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1145.1">The output shows </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.1147.1"> as the only node configured in the Kubernetes cluster, running as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1148.1">CP node:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer523">
<span class="koboSpan" id="kobo.1149.1"><img alt="Figure 16.17 – Listing the current nodes in the Kubernetes cluster" src="image/B19682_16_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1150.1">Figure 16.17 – Listing the current nodes in the Kubernetes cluster</span></p>
<ol>
<li value="13"><span class="koboSpan" id="kobo.1151.1">You may recall that </span><a id="_idIndexMarker2411"/><span class="koboSpan" id="kobo.1152.1">prior to bootstrapping the Kubernetes cluster, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">kubelet</span></strong><span class="koboSpan" id="kobo.1154.1"> Service was continually crashing (and attempting to restart). </span><span class="koboSpan" id="kobo.1154.2">With the cluster up and running, the status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">kubelet</span></strong><span class="koboSpan" id="kobo.1156.1"> daemon</span><a id="_idIndexMarker2412"/><span class="koboSpan" id="kobo.1157.1"> should be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1158.1">active</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1159.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">running</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1161.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1162.1">sudo systemctl status kubelet</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1163.1">The output shows </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">the following:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer524">
<span class="koboSpan" id="kobo.1165.1"><img alt="Figure 16.18 – A healthy kubelet in the cluster" src="image/B19682_16_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1166.1">Figure 16.18 – A healthy kubelet in the cluster</span></p>
<ol>
<li value="14"><span class="koboSpan" id="kobo.1167.1">We encourage you to check out the manifests created in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1168.1">/etc/kubernetes/manifests/</span></strong><span class="koboSpan" id="kobo.1169.1"> directory for each cluster component using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1171.1">ls /etc/kubernetes/manifests/</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1172.1">The output shows the configuration files describing the static (system) pods, corresponding to the API server, controller manager, scheduler, </span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">and etcd:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer525">
<span class="koboSpan" id="kobo.1174.1"><img alt="Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/" src="image/B19682_16_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1175.1">Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/</span></p>
<ol>
<li value="15"><span class="koboSpan" id="kobo.1176.1">You may also look at the kubeconfig files </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">/etc/kubernetes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1180.1">ls /etc/kubernetes/</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1181.1">As you may recall from the </span><em class="italic"><span class="koboSpan" id="kobo.1182.1">Introducing kubeadm</span></em><span class="koboSpan" id="kobo.1183.1"> section earlier in this chapter, the kubeconfig files are used by the cluster components to communicate and authenticate with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">API server.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.1185.1">As we have used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1186.1">kubectl</span></strong><span class="koboSpan" id="kobo.1187.1"> utility </span><a id="_idIndexMarker2413"/><span class="koboSpan" id="kobo.1188.1">quite extensively in this section, you can visit the official documentation to find out more about the commands and options available for it at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">link: </span></span><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands"><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1192.1">Next, let’s add the worker nodes to our </span><span class="No-Break"><span class="koboSpan" id="kobo.1193.1">Kubernetes cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.1194.1">Joining a node to a Kubernetes cluster</span></h3>
<p><span class="koboSpan" id="kobo.1195.1">As previously noted, before </span><a id="_idIndexMarker2414"/><span class="koboSpan" id="kobo.1196.1">adding a node to the Kubernetes cluster, you’ll need to</span><a id="_idIndexMarker2415"/><span class="koboSpan" id="kobo.1197.1"> run the preliminary steps described in the </span><em class="italic"><span class="koboSpan" id="kobo.1198.1">Preparing the lab environment</span></em><span class="koboSpan" id="kobo.1199.1"> section earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">To join a node to the cluster, we’ll need both the </span><strong class="bold"><span class="koboSpan" id="kobo.1202.1">bootstrap token</span></strong><span class="koboSpan" id="kobo.1203.1"> and the </span><strong class="bold"><span class="koboSpan" id="kobo.1204.1">discovery token CA certificate hash</span></strong><span class="koboSpan" id="kobo.1205.1"> generated upon successful bootstrapping of the Kubernetes cluster. </span><span class="koboSpan" id="kobo.1205.2">The tokens with the related </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">kubeadm join</span></strong><span class="koboSpan" id="kobo.1207.1"> command were provided in the output at the end of the bootstrapping process with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">kubeadm init</span></strong><span class="koboSpan" id="kobo.1209.1">. </span><span class="koboSpan" id="kobo.1209.2">Refer to the </span><em class="italic"><span class="koboSpan" id="kobo.1210.1">Creating a Kubernetes CP node</span></em><span class="koboSpan" id="kobo.1211.1"> section earlier in this chapter. </span><span class="koboSpan" id="kobo.1211.2">Keep in mind that the bootstrap token expires in 24 hours. </span><span class="koboSpan" id="kobo.1211.3">If you forget to copy the command, you can retrieve the related information by running the following commands in the CP node’s terminal (</span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1214.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1215.1">To proceed, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1217.1">Retrieve the current </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">bootstrap tokens:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1219.1">kubeadm token list</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1220.1">The output shows our </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">token (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1222.1">abcdef.0123456789abcdef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">):</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer526">
<span class="koboSpan" id="kobo.1224.1"><img alt="Figure 16.20 – Getting the current bootstrap tokens" src="image/B19682_16_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1225.1">Figure 16.20 – Getting the current bootstrap tokens</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.1226.1">Get the CA </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">certificate hash:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1228.1">openssl x509 -pubkey \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1229.1">    -in /etc/kubernetes/pki/ca.crt | \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1230.1">    openssl rsa -pubin -outform der 2&gt;/dev/null | \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1231.1">    openssl dgst -sha256 -hex | sed 's/^.* //'</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1232.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer527">
<span class="koboSpan" id="kobo.1234.1"><img alt="Figure 16.21 – Getting the CA certificate hash" src="image/B19682_16_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1235.1">Figure 16.21 – Getting the CA certificate hash</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1236.1">You may</span><a id="_idIndexMarker2416"/><span class="koboSpan" id="kobo.1237.1"> also generate a new bootstrap token</span><a id="_idIndexMarker2417"/><span class="koboSpan" id="kobo.1238.1"> with the</span><a id="_idIndexMarker2418"/> <span class="No-Break"><span class="koboSpan" id="kobo.1239.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1240.1">kubeadm token create</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1241.1">If you choose to generate a new token, you may use the following streamlined command to print out the full </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">kubeadm join</span></strong><span class="koboSpan" id="kobo.1243.1"> command with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">required parameters:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.1245.1">kubeadm token create --print-join-command</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1246.1">Now that the token has been created, we can proceed to the next </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">bootstrapping steps.</span></span></p>
<p><span class="koboSpan" id="kobo.1248.1">In the following steps, we’ll use our initial tokens as displayed in the output at the end of the bootstrapping process. </span><span class="koboSpan" id="kobo.1248.2">So, let’s switch to the node’s command-line terminal (on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">k8s-n1</span></strong><span class="koboSpan" id="kobo.1250.1">) and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">following command:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1252.1">Make sure to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">sudo</span></strong><span class="koboSpan" id="kobo.1254.1">, or the command will fail with </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">insufficient permissions:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1256.1">sudo kubeadm join 192.168.122.104:6443 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1257.1">    --token abcdef.0123456789abcdef \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1258.1">    --discovery-token-ca-cert-hash sha256:af8e659bc8a9069cf58d3100e94644bb6ee804c1372a 0ab7e74801cf8340a15d</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1259.1">We can check the status of the </span><a id="_idIndexMarker2419"/><span class="koboSpan" id="kobo.1260.1">current nodes in the cluster</span><a id="_idIndexMarker2420"/><span class="koboSpan" id="kobo.1261.1"> with the following command in the CP node </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">terminal (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1264.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1265.1">kubectl get nodes</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1266.1">The output shows our new node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">k8s-n1</span></strong><span class="koboSpan" id="kobo.1268.1">) added to </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">the cluster:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer528">
<span class="koboSpan" id="kobo.1270.1"><img alt="Figure 16.22 – The new node (k8s-n1) added to the cluster" src="image/B19682_16_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1271.1">Figure 16.22 – The new node (k8s-n1) added to the cluster</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1272.1">We encourage you to repeat the process of joining the other two cluster nodes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">k8s-n2</span></strong><span class="koboSpan" id="kobo.1274.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">k8s-n3</span></strong><span class="koboSpan" id="kobo.1276.1">). </span><span class="koboSpan" id="kobo.1276.2">During the join, while the CP pods are being deployed on the new node, you may temporarily see a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">NotReady</span></strong><span class="koboSpan" id="kobo.1278.1"> status for the new node if you query the nodes on the CP node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.1280.1">) too fast. </span><span class="koboSpan" id="kobo.1280.2">The process should take a while. </span><span class="koboSpan" id="kobo.1280.3">In the end, we should have all three nodes showing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">Ready</span></strong><span class="koboSpan" id="kobo.1282.1"> in the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">kubectl get nodes</span></strong><span class="koboSpan" id="kobo.1284.1"> command (</span><span class="No-Break"><span class="koboSpan" id="kobo.1285.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">k8s-cp1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">):</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer529">
<span class="koboSpan" id="kobo.1288.1"><img alt="Figure 16.23 – The Kubernetes cluster with all nodes running" src="image/B19682_16_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1289.1">Figure 16.23 – The Kubernetes cluster with all nodes running</span></p>
<p><span class="koboSpan" id="kobo.1290.1">We have now </span><a id="_idIndexMarker2421"/><span class="koboSpan" id="kobo.1291.1">completed the installation of our Kubernetes cluster, with </span><a id="_idIndexMarker2422"/><span class="koboSpan" id="kobo.1292.1">a CP node and three worker nodes. </span><span class="koboSpan" id="kobo.1292.2">We used a local (on-premises) VM environment, but the same process would also apply to a</span><a id="_idIndexMarker2423"/><span class="koboSpan" id="kobo.1293.1"> hosted IaaS solution running in a private or </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">public cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">In the next section, we’ll explore the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">kubectl</span></strong><span class="koboSpan" id="kobo.1297.1"> CLI to a certain extent and use it to create and manage Kubernetes resources. </span><span class="koboSpan" id="kobo.1297.2">Then, we’ll look at deploying and scaling applications using the imperative and declarative deployment models </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">in Kubernetes.</span></span></p>
<h1 id="_idParaDest-334"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.1299.1">Working with Kubernetes</span></h1>
<p><span class="koboSpan" id="kobo.1300.1">In this section, we’ll use</span><a id="_idIndexMarker2424"/><span class="koboSpan" id="kobo.1301.1"> real-world examples of interacting with a Kubernetes cluster. </span><span class="koboSpan" id="kobo.1301.2">Since we’ll be using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">kubectl</span></strong><span class="koboSpan" id="kobo.1303.1"> CLI to a considerable extent, we’re going to take a deep dive into some of its more common usage patterns. </span><span class="koboSpan" id="kobo.1303.2">Then, we will turn our focus to deploying applications to a Kubernetes cluster. </span><span class="koboSpan" id="kobo.1303.3">We’ll be using the on-premises environment we built in the </span><em class="italic"><span class="koboSpan" id="kobo.1304.1">Installing Kubernetes on </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1305.1">VMs</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.1307.1">Let’s start by taking a closer look at </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">kubectl</span></strong><span class="koboSpan" id="kobo.1309.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1">its usage.</span></span></p>
<h2 id="_idParaDest-335"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.1311.1">Using kubectl</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">kubectl</span></strong><span class="koboSpan" id="kobo.1313.1"> is the primary tool</span><a id="_idIndexMarker2425"/><span class="koboSpan" id="kobo.1314.1"> for managing a Kubernetes cluster and its resources. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">kubectl</span></strong><span class="koboSpan" id="kobo.1316.1"> communicates with the cluster’s API server endpoint using the Kubernetes REST API. </span><span class="koboSpan" id="kobo.1316.2">The general syntax of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">kubectl</span></strong><span class="koboSpan" id="kobo.1318.1"> command is </span><span class="No-Break"><span class="koboSpan" id="kobo.1319.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1320.1">
kubectl [command] [TYPE] [NAME] [flags]</span></pre> <p><span class="koboSpan" id="kobo.1321.1">In general, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">kubectl</span></strong><span class="koboSpan" id="kobo.1323.1"> commands execute </span><strong class="bold"><span class="koboSpan" id="kobo.1324.1">CRUD operations</span></strong><span class="koboSpan" id="kobo.1325.1"> – CRUD stands for </span><strong class="bold"><span class="koboSpan" id="kobo.1326.1">Create</span></strong><span class="koboSpan" id="kobo.1327.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1328.1">Read</span></strong><span class="koboSpan" id="kobo.1329.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.1330.1">Update</span></strong><span class="koboSpan" id="kobo.1331.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.1332.1">Delete</span></strong><span class="koboSpan" id="kobo.1333.1"> – against Kubernetes</span><a id="_idIndexMarker2426"/><span class="koboSpan" id="kobo.1334.1"> resources, such as pods, Deployments, </span><span class="No-Break"><span class="koboSpan" id="kobo.1335.1">and Services.</span></span></p>
<p><span class="koboSpan" id="kobo.1336.1">One of the essential features of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">kubectl</span></strong><span class="koboSpan" id="kobo.1338.1"> is the command output format, either in YAML, JSON, or plain text. </span><span class="koboSpan" id="kobo.1338.2">The output format is handy when creating or editing application Deployment manifests. </span><span class="koboSpan" id="kobo.1338.3">We can capture the YAML output of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">kubectl</span></strong><span class="koboSpan" id="kobo.1340.1"> command (such as create a resource) to a file. </span><span class="koboSpan" id="kobo.1340.2">Later, we can reuse the manifest file to perform the same operation (or sequence of operations) in a declarative way. </span><span class="koboSpan" id="kobo.1340.3">This brings us to the two basic Deployment paradigms </span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">of Kubernetes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1342.1">Imperative Deployments</span></strong><span class="koboSpan" id="kobo.1343.1">: Invoking a</span><a id="_idIndexMarker2427"/><span class="koboSpan" id="kobo.1344.1"> single or multiple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">kubectl</span></strong><span class="koboSpan" id="kobo.1346.1"> commands to operate on </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">specific resources</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1348.1">Declarative Deployments</span></strong><span class="koboSpan" id="kobo.1349.1">: Using manifest files and deploying them using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">kubectl apply</span></strong><span class="koboSpan" id="kobo.1351.1"> command, usually </span><a id="_idIndexMarker2428"/><span class="koboSpan" id="kobo.1352.1">targeting a set of resources with a </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">single invocation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1354.1">We’ll look at these two Deployment models more closely in the </span><em class="italic"><span class="koboSpan" id="kobo.1355.1">Deploying applications</span></em><span class="koboSpan" id="kobo.1356.1"> section later in this chapter. </span><span class="koboSpan" id="kobo.1356.2">For now, let’s get back to exploring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">kubectl</span></strong><span class="koboSpan" id="kobo.1358.1"> command further. </span><span class="koboSpan" id="kobo.1358.2">Here’s a short list of some of the most common </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1359.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1360.1"> commands:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">create</span></strong><span class="koboSpan" id="kobo.1362.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">apply</span></strong><span class="koboSpan" id="kobo.1364.1">: These create </span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">resources imperatively/declaratively</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">get</span></strong><span class="koboSpan" id="kobo.1367.1">: This </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">reads resources</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">edit</span></strong><span class="koboSpan" id="kobo.1370.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">set</span></strong><span class="koboSpan" id="kobo.1372.1">: These update resources or specific features </span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">of objects</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1374.1">delete</span></strong><span class="koboSpan" id="kobo.1375.1">: This </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">deletes resources</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">run</span></strong><span class="koboSpan" id="kobo.1378.1">: This starts </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">a pod</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1380.1">exec</span></strong><span class="koboSpan" id="kobo.1381.1">: This executes a command in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1382.1">pod container</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1383.1">describe</span></strong><span class="koboSpan" id="kobo.1384.1">: This displays detailed information </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">about resources</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">explain</span></strong><span class="koboSpan" id="kobo.1387.1">: This provides </span><span class="No-Break"><span class="koboSpan" id="kobo.1388.1">resource-related documentation</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">logs</span></strong><span class="koboSpan" id="kobo.1390.1">: This shows the logs in </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">pod containers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1392.1">A couple of frequently </span><a id="_idIndexMarker2429"/><span class="koboSpan" id="kobo.1393.1">used parameters of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">kubectl</span></strong><span class="koboSpan" id="kobo.1395.1"> command are also </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">worth mentioning:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1397.1">--dry-run</span></strong><span class="koboSpan" id="kobo.1398.1">: This runs the command without modifying the system state while still providing the output as if it </span><span class="No-Break"><span class="koboSpan" id="kobo.1399.1">executed normally</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">--output</span></strong><span class="koboSpan" id="kobo.1401.1">: This specifies various formats for the command output: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">yaml</span></strong><span class="koboSpan" id="kobo.1403.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">json</span></strong><span class="koboSpan" id="kobo.1405.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">wide</span></strong><span class="koboSpan" id="kobo.1407.1"> (additional information in </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">plain text)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1409.1">In the following sections, we’ll look at multiple examples of using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1410.1">kubectl</span></strong><span class="koboSpan" id="kobo.1411.1"> command. </span><span class="koboSpan" id="kobo.1411.2">Always keep in mind the general pattern of </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">the command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer530">
<span class="koboSpan" id="kobo.1413.1"><img alt="Figure 16.24 – The general usage pattern of kubectl" src="image/B19682_16_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1414.1">Figure 16.24 – The general usage pattern of kubectl</span></p>
<p><span class="koboSpan" id="kobo.1415.1">We recommend that you check out the </span><a id="_idIndexMarker2430"/><span class="koboSpan" id="kobo.1416.1">complete </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">kubectl</span></strong><span class="koboSpan" id="kobo.1418.1"> command reference at </span><a href="https://kubernetes.io/docs/reference/kubectl/overview/"><span class="koboSpan" id="kobo.1419.1">https://kubernetes.io/docs/reference/kubectl/overview/</span></a><span class="koboSpan" id="kobo.1420.1">. </span><span class="koboSpan" id="kobo.1420.2">While you are becoming proficient with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1421.1">kubectl</span></strong><span class="koboSpan" id="kobo.1422.1">, you may also want to keep the related cheat sheet at hand, which you can find at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">link: </span></span><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/"><span class="No-Break"><span class="koboSpan" id="kobo.1424.1">https://kubernetes.io/docs/reference/kubectl/cheatsheet/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1426.1">Now, let’s prepare our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1427.1">kubectl</span></strong><span class="koboSpan" id="kobo.1428.1"> environment to interact with the Kubernetes cluster we built earlier with VMs. </span><span class="koboSpan" id="kobo.1428.2">You may skip the next section if you prefer to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1429.1">kubectl</span></strong><span class="koboSpan" id="kobo.1430.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">CP node.</span></span></p>
<h3><span class="koboSpan" id="kobo.1432.1">Connecting to a Kubernetes cluster from a local machine</span></h3>
<p><span class="koboSpan" id="kobo.1433.1">In this section, we</span><a id="_idIndexMarker2431"/><span class="koboSpan" id="kobo.1434.1"> configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1435.1">kubectl</span></strong><span class="koboSpan" id="kobo.1436.1"> CLI running locally on our Linux desktop to control a remote Kubernetes cluster. </span><span class="koboSpan" id="kobo.1436.2">We are running Debian 12 on our </span><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">local machine.</span></span></p>
<p><span class="koboSpan" id="kobo.1438.1">First, we will need to install </span><strong class="source-inline"><span class="koboSpan" id="kobo.1439.1">kubectl</span></strong><span class="koboSpan" id="kobo.1440.1"> on our system. </span><span class="koboSpan" id="kobo.1440.2">We will observe the installation instructions at </span><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/"><span class="koboSpan" id="kobo.1441.1">https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/</span></a><span class="koboSpan" id="kobo.1442.1">. </span><span class="koboSpan" id="kobo.1442.2">We will download the latest </span><strong class="source-inline"><span class="koboSpan" id="kobo.1443.1">kubectl</span></strong><span class="koboSpan" id="kobo.1444.1"> release with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1446.1">
curl -LO "</span><strong class="bold"><span class="koboSpan" id="kobo.1447.1">https://dl.k8s.io/release/$(curl</span></strong><span class="koboSpan" id="kobo.1448.1"> -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"</span></pre> <p><span class="koboSpan" id="kobo.1449.1">Then we will install </span><strong class="source-inline"><span class="koboSpan" id="kobo.1450.1">kubectl</span></strong><span class="koboSpan" id="kobo.1451.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1453.1">
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl</span></pre> <p><span class="koboSpan" id="kobo.1454.1">Now that the package is installed, we can test the installation using the </span><span class="No-Break"><span class="koboSpan" id="kobo.1455.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1456.1">
kubectl version --client</span></pre> <p><span class="koboSpan" id="kobo.1457.1">The output of the</span><a id="_idIndexMarker2432"/><span class="koboSpan" id="kobo.1458.1"> preceding commands is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1459.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer531">
<span class="koboSpan" id="kobo.1460.1"><img alt="Figure 16.25 – Installing kubectl locally on a Debian system" src="image/B19682_16_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1461.1">Figure 16.25 – Installing kubectl locally on a Debian system</span></p>
<p><span class="koboSpan" id="kobo.1462.1">We want to add (merge) yet another cluster configuration to our environment. </span><span class="koboSpan" id="kobo.1462.2">This time, we connect to an on-premises Kubernetes CP, and we’ll use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1463.1">kubectl</span></strong><span class="koboSpan" id="kobo.1464.1"> to update kubeconfig. </span><span class="koboSpan" id="kobo.1464.2">Here are the steps we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">be taking:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1466.1">We first copy kubeconfig from the CP node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.1468.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1469.1">192.168.122.104</span></strong><span class="koboSpan" id="kobo.1470.1">) to a temporary </span><span class="No-Break"><span class="koboSpan" id="kobo.1471.1">location </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">(/tmp/config.cp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1473.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1474.1">scp packt@192.168.122.104:~/.kube/config /tmp/config.cp</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1475.1">Finally, we can move the new kubeconfig file to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1476.1">new location:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1477.1">mv /tmp/config.cp ~/.kube/config</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1478.1">Optionally, we can clean up the temporary files created in </span><span class="No-Break"><span class="koboSpan" id="kobo.1479.1">the process:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1480.1">rm ~/.kube/config.old /tmp/config.cp</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1481.1">Let’s get a view of the current </span><span class="No-Break"><span class="koboSpan" id="kobo.1482.1">kubeconfig contexts:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1483.1">kubectl config get-contexts</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1484.1">The output of the previous command is shown in the following screenshot. </span><span class="koboSpan" id="kobo.1484.2">At the bottom of the screenshot, you can see </span><a id="_idIndexMarker2433"/><span class="koboSpan" id="kobo.1485.1">our new Kubernetes cluster, with the related security principal (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">kubernetes-admin@kubernetes</span></strong><span class="koboSpan" id="kobo.1487.1">) and cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">name (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1489.1">kubernetes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">):</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer532">
<span class="koboSpan" id="kobo.1491.1"><img alt="Figure 16.26 – The new kubeconfig contexts" src="image/B19682_16_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1492.1">Figure 16.26 – The new kubeconfig contexts</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1493.1">For consistency, let’s change the on-premises cluster’s context name to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1494.1">k8s-local</span></strong><span class="koboSpan" id="kobo.1495.1"> and make it the default context in our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1496.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1497.1"> environment:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1498.1">kubectl config rename-context \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1499.1">    kubernetes-admin@kubernetes \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1500.1">    k8s-local</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1501.1">kubectl config use-context k8s-local</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1502.1">The current </span><strong class="source-inline"><span class="koboSpan" id="kobo.1503.1">kubectl</span></strong><span class="koboSpan" id="kobo.1504.1"> context becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1505.1">k8s-local</span></strong><span class="koboSpan" id="kobo.1506.1">, and we’re now interacting with our on-premises Kubernetes cluster (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1507.1">kubernetes</span></strong><span class="koboSpan" id="kobo.1508.1">). </span><span class="koboSpan" id="kobo.1508.2">The output is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1509.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer533">
<span class="koboSpan" id="kobo.1510.1"><img alt="Figure 16.27 – The current context set to the on-premises Kubernetes cluster" src="image/B19682_16_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1511.1">Figure 16.27 – The current context set to the on-premises Kubernetes cluster</span></p>
<p><span class="koboSpan" id="kobo.1512.1">Next, we look at some of</span><a id="_idIndexMarker2434"/><span class="koboSpan" id="kobo.1513.1"> the most common </span><strong class="source-inline"><span class="koboSpan" id="kobo.1514.1">kubectl</span></strong><span class="koboSpan" id="kobo.1515.1"> commands used with everyday Kubernetes </span><span class="No-Break"><span class="koboSpan" id="kobo.1516.1">administration tasks.</span></span></p>
<h3><span class="koboSpan" id="kobo.1517.1">Working with kubectl</span></h3>
<p><span class="koboSpan" id="kobo.1518.1">One of the first commands we </span><a id="_idIndexMarker2435"/><span class="koboSpan" id="kobo.1519.1">run when connected to a Kubernetes cluster is </span><span class="No-Break"><span class="koboSpan" id="kobo.1520.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1521.1">
kubectl cluster-info</span></pre> <p><span class="koboSpan" id="kobo.1522.1">The command shows the IP address and port of the API server listening on the CP node, among </span><span class="No-Break"><span class="koboSpan" id="kobo.1523.1">other information:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer534">
<span class="koboSpan" id="kobo.1524.1"><img alt="Figure 16.28 – The Kubernetes cluster information shown" src="image/B19682_16_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1525.1">Figure 16.28 – The Kubernetes cluster information shown</span></p>
<p><span class="koboSpan" id="kobo.1526.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">cluster-info</span></strong><span class="koboSpan" id="kobo.1528.1"> command can also help to debug and diagnose </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">cluster-related issues:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1530.1">
kubectl cluster-info dump</span></pre> <p><span class="koboSpan" id="kobo.1531.1">To get a detailed view of the cluster nodes, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1532.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1533.1">
kubectl get nodes --output=wide</span></pre> <p><span class="koboSpan" id="kobo.1534.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1535.1">--output=wide</span></strong><span class="koboSpan" id="kobo.1536.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1537.1">-o wide</span></strong><span class="koboSpan" id="kobo.1538.1">) flag yields detailed information about cluster nodes. </span><span class="koboSpan" id="kobo.1538.2">The output in the following illustration has been cropped to show it </span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1">more clearly:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer535">
<span class="koboSpan" id="kobo.1540.1"><img alt="Figure 16.29 – Getting detailed information about cluster nodes" src="image/B19682_16_29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1541.1">Figure 16.29 – Getting detailed information about cluster nodes</span></p>
<p><span class="koboSpan" id="kobo.1542.1">The following command retrieves the pods running in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1543.1">default namespace:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1544.1">
kubectl get pods</span></pre> <p><span class="koboSpan" id="kobo.1545.1">As of now, we don’t have any user pods running, and the command returns </span><span class="No-Break"><span class="koboSpan" id="kobo.1546.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1547.1">
No resources found in default namespace.</span></pre> <p><span class="koboSpan" id="kobo.1548.1">To list all the pods, we append the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1549.1">--all-namespaces</span></strong><span class="koboSpan" id="kobo.1550.1"> flag to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">preceding command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1552.1">
kubectl get pods --all-namespace</span></pre> <p><span class="koboSpan" id="kobo.1553.1">The output shows all pods </span><a id="_idIndexMarker2436"/><span class="koboSpan" id="kobo.1554.1">running in the system. </span><span class="koboSpan" id="kobo.1554.2">Since these are exclusively system pods, they are associated with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1555.1">kube-system</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1"> namespace:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer536">
<span class="koboSpan" id="kobo.1557.1"><img alt="Figure 16.30 – Getting all pods in the system" src="image/B19682_16_30.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1558.1">Figure 16.30 – Getting all pods in the system</span></p>
<p><span class="koboSpan" id="kobo.1559.1">We would get the</span><a id="_idIndexMarker2437"/><span class="koboSpan" id="kobo.1560.1"> same output if we specified </span><strong class="source-inline"><span class="koboSpan" id="kobo.1561.1">kube-system</span></strong><span class="koboSpan" id="kobo.1562.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1563.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1564.1">namespace</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1565.1"> flag:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1566.1">
kubectl get pods --namespace kube-system</span></pre> <p><span class="koboSpan" id="kobo.1567.1">For a comprehensive view of all resources running in the system, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1568.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1569.1">
kubectl get all --all-namespaces</span></pre> <p><span class="koboSpan" id="kobo.1570.1">So far, we have only mentioned some of the more common object types, such as nodes, pods, and Services. </span><span class="koboSpan" id="kobo.1570.2">There are many others, and we can view them with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1571.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1572.1">
kubectl api-resources</span></pre> <p><span class="koboSpan" id="kobo.1573.1">The output includes the</span><a id="_idIndexMarker2438"/><span class="koboSpan" id="kobo.1574.1"> name of the API object types (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">nodes</span></strong><span class="koboSpan" id="kobo.1576.1">), their short name or alias (such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">no</span></strong><span class="koboSpan" id="kobo.1578.1">), and whether they can be organized in namespaces (such </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1580.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1581.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer537">
<span class="koboSpan" id="kobo.1582.1"><img alt="Figure 16.31 – Getting all API object types (cropped)" src="image/B19682_16_31.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1583.1">Figure 16.31 – Getting all API object types (cropped)</span></p>
<p><span class="koboSpan" id="kobo.1584.1">Suppose you want to find out more about specific API objects, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">nodes</span></strong><span class="koboSpan" id="kobo.1586.1">. </span><span class="koboSpan" id="kobo.1586.2">Here’s where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">explain</span></strong><span class="koboSpan" id="kobo.1588.1"> command comes </span><span class="No-Break"><span class="koboSpan" id="kobo.1589.1">in handy:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1590.1">
kubectl explain nodes</span></pre> <p><span class="koboSpan" id="kobo.1591.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1592.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer538">
<span class="koboSpan" id="kobo.1593.1"><img alt="Figure 16.32 – Showing nodes’ detailed information (cropped)" src="image/B19682_16_32.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1594.1">Figure 16.32 – Showing nodes’ detailed information (cropped)</span></p>
<p><span class="koboSpan" id="kobo.1595.1">The output provides</span><a id="_idIndexMarker2439"/><span class="koboSpan" id="kobo.1596.1"> detailed documentation about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1597.1">nodes</span></strong><span class="koboSpan" id="kobo.1598.1"> API object type, including the related API fields. </span><span class="koboSpan" id="kobo.1598.2">One of the API fields is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1599.1">apiVersion</span></strong><span class="koboSpan" id="kobo.1600.1">, describing the versioning schema of an object. </span><span class="koboSpan" id="kobo.1600.2">You may view the related documentation with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1601.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1602.1">
kubectl explain nodes.apiVersion</span></pre> <p><span class="koboSpan" id="kobo.1603.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1604.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer539">
<span class="koboSpan" id="kobo.1605.1"><img alt="Figure 16.33 – Details about the apiVersion field (cropped)" src="image/B19682_16_33.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1606.1">Figure 16.33 – Details about the apiVersion field (cropped)</span></p>
<p><span class="koboSpan" id="kobo.1607.1">We encourage you to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">explain</span></strong><span class="koboSpan" id="kobo.1609.1"> command to learn about the various Kubernetes API object types in a cluster. </span><span class="koboSpan" id="kobo.1609.2">Please note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">explain</span></strong><span class="koboSpan" id="kobo.1611.1"> command provides documentation about </span><em class="italic"><span class="koboSpan" id="kobo.1612.1">resource types</span></em><span class="koboSpan" id="kobo.1613.1">. </span><span class="koboSpan" id="kobo.1613.2">It should not be confused with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">describe</span></strong><span class="koboSpan" id="kobo.1615.1"> command, which shows detailed information about the </span><em class="italic"><span class="koboSpan" id="kobo.1616.1">resources</span></em><span class="koboSpan" id="kobo.1617.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1618.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.1619.1">The following commands display cluster node-related information about </span><em class="italic"><span class="koboSpan" id="kobo.1620.1">all</span></em><span class="koboSpan" id="kobo.1621.1"> nodes, and then node </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">k8s-n1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1623.1">in particular:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1624.1">
kubectl describe nodes
kubectl describe nodes k8s-n1</span></pre> <p><span class="koboSpan" id="kobo.1625.1">For every </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">kubectl</span></strong><span class="koboSpan" id="kobo.1627.1"> command, you can invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.1628.1">--help</span></strong><span class="koboSpan" id="kobo.1629.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">-h</span></strong><span class="koboSpan" id="kobo.1631.1">) to get context-specific help. </span><span class="koboSpan" id="kobo.1631.2">Here are a </span><span class="No-Break"><span class="koboSpan" id="kobo.1632.1">few examples:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1633.1">
kubectl --help
kubectl config -h
kubectl get pods -h</span></pre> <p><span class="koboSpan" id="kobo.1634.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1635.1">kubectl</span></strong><span class="koboSpan" id="kobo.1636.1"> CLI is</span><a id="_idIndexMarker2440"/><span class="koboSpan" id="kobo.1637.1"> relatively rich in commands, and becoming proficient with it may take some time. </span><span class="koboSpan" id="kobo.1637.2">Occasionally, you may find yourself looking for a specific command or remembering its correct spelling or use. </span><span class="koboSpan" id="kobo.1637.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1638.1">auto-complete</span></strong><span class="koboSpan" id="kobo.1639.1"> bash for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">kubectl</span></strong><span class="koboSpan" id="kobo.1641.1"> comes to the rescue. </span><span class="koboSpan" id="kobo.1641.2">We’ll show you how to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.1642.1">this next.</span></span></p>
<h3><span class="koboSpan" id="kobo.1643.1">Enabling kubectl autocompletion</span></h3>
<p><span class="koboSpan" id="kobo.1644.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1645.1">kubectl</span></strong><span class="koboSpan" id="kobo.1646.1"> autocompletion, you’ll get</span><a id="_idIndexMarker2441"/><span class="koboSpan" id="kobo.1647.1"> context-sensitive suggestions when you hit the </span><em class="italic"><span class="koboSpan" id="kobo.1648.1">Tab</span></em><span class="koboSpan" id="kobo.1649.1"> key twice while typing the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">kubectl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1651.1"> commands.</span></span></p>
<p><span class="koboSpan" id="kobo.1652.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1653.1">kubectl</span></strong><span class="koboSpan" id="kobo.1654.1"> autocompletion feature depends</span><a id="_idIndexMarker2442"/><span class="koboSpan" id="kobo.1655.1"> on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">bash-completion</span></strong><span class="koboSpan" id="kobo.1657.1">. </span><span class="koboSpan" id="kobo.1657.2">Most Linux platforms have </span><strong class="source-inline"><span class="koboSpan" id="kobo.1658.1">bash-completion</span></strong><span class="koboSpan" id="kobo.1659.1"> enabled by default. </span><span class="koboSpan" id="kobo.1659.2">Otherwise, you’ll have to install the related package manually. </span><span class="koboSpan" id="kobo.1659.3">On Ubuntu, for example, you install it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1660.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1661.1">
sudo apt-get install -y bash-completion</span></pre> <p><span class="koboSpan" id="kobo.1662.1">Next, you need to source the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">kubectl</span></strong><span class="koboSpan" id="kobo.1664.1"> autocompletion in your shell (or </span><span class="No-Break"><span class="koboSpan" id="kobo.1665.1">similar) profile:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1666.1">
echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc</span></pre> <p><span class="koboSpan" id="kobo.1667.1">The changes will take effect on your next login to the terminal or immediately if you source the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1668.1">bash</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1"> profile:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1670.1">
source ~/.bashrc</span></pre> <p><span class="koboSpan" id="kobo.1671.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1672.1">kubectl</span></strong><span class="koboSpan" id="kobo.1673.1"> autocomplete active, you’ll get context-sensitive suggestions when you hit the </span><em class="italic"><span class="koboSpan" id="kobo.1674.1">Tab</span></em><span class="koboSpan" id="kobo.1675.1"> key twice while typing the command. </span><span class="koboSpan" id="kobo.1675.2">For example, the following sequence provides all the available resources when you try to </span><span class="No-Break"><span class="koboSpan" id="kobo.1676.1">create one:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1677.1">
kubectl create [Tab][Tab]</span></pre> <p><span class="koboSpan" id="kobo.1678.1">When typing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">kubectl create</span></strong><span class="koboSpan" id="kobo.1680.1"> command and pressing the </span><em class="italic"><span class="koboSpan" id="kobo.1681.1">Tab</span></em><span class="koboSpan" id="kobo.1682.1"> key twice, the result will be a list of resources available for </span><span class="No-Break"><span class="koboSpan" id="kobo.1683.1">the command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer540">
<span class="koboSpan" id="kobo.1684.1"><img alt="Figure 16.34 – Autocompletion use with kubectl" src="image/B19682_16_34.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1685.1">Figure 16.34 – Autocompletion use with kubectl</span></p>
<p><span class="koboSpan" id="kobo.1686.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1687.1">kubectl</span></strong><span class="koboSpan" id="kobo.1688.1"> autocompletion reaches every part of the syntax: command, resource (type and name), </span><span class="No-Break"><span class="koboSpan" id="kobo.1689.1">and flags.</span></span></p>
<p><span class="koboSpan" id="kobo.1690.1">Now that we know more about using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1691.1">kubectl</span></strong><span class="koboSpan" id="kobo.1692.1"> command, it’s time to turn our attention to deploying applications </span><span class="No-Break"><span class="koboSpan" id="kobo.1693.1">in Kubernetes.</span></span></p>
<h2 id="_idParaDest-336"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.1694.1">Deploying applications</span></h2>
<p><span class="koboSpan" id="kobo.1695.1">When we introduced</span><a id="_idIndexMarker2443"/><span class="koboSpan" id="kobo.1696.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1697.1">kubectl</span></strong><span class="koboSpan" id="kobo.1698.1"> command and its usage pattern at the beginning of the </span><em class="italic"><span class="koboSpan" id="kobo.1699.1">Using kubectl</span></em><span class="koboSpan" id="kobo.1700.1"> section, we touched upon the two ways of creating application resources in Kubernetes: imperative </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">and declarative.</span></span></p>
<p><span class="koboSpan" id="kobo.1702.1">We’ll look at both of these models closely in this section while deploying a simple web application. </span><span class="koboSpan" id="kobo.1702.2">Let’s start with the imperative </span><span class="No-Break"><span class="koboSpan" id="kobo.1703.1">model first.</span></span></p>
<h3><span class="koboSpan" id="kobo.1704.1">Working with imperative Deployments</span></h3>
<p><span class="koboSpan" id="kobo.1705.1">As a quick refresher, with imperative </span><a id="_idIndexMarker2444"/><span class="koboSpan" id="kobo.1706.1">Deployments, we follow a sequence of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">kubectl</span></strong><span class="koboSpan" id="kobo.1708.1"> commands to create the required resources and get to the cluster’s desired state, such as running the application. </span><span class="koboSpan" id="kobo.1708.2">Declarative Deployments accomplish the same, usually with a single </span><strong class="source-inline"><span class="koboSpan" id="kobo.1709.1">kubectl</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1710.1">apply</span></strong><span class="koboSpan" id="kobo.1711.1"> command using a manifest file describing </span><span class="No-Break"><span class="koboSpan" id="kobo.1712.1">multiple resources.</span></span></p>
<h4><span class="koboSpan" id="kobo.1713.1">Creating a Deployment</span></h4>
<p><span class="koboSpan" id="kobo.1714.1">Let’s begin by creating a Deployment first. </span><span class="koboSpan" id="kobo.1714.2">We’ll name our Deployment </span><strong class="source-inline"><span class="koboSpan" id="kobo.1715.1">packt</span></strong><span class="koboSpan" id="kobo.1716.1">, based on a demo Nginx container we’re pulling from the public Docker </span><a id="_idIndexMarker2445"/><span class="No-Break"><span class="koboSpan" id="kobo.1717.1">registry (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1718.1">docker.io/nginxdemos/hello</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1719.1">):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1720.1">
kubectl create deployment </span><strong class="bold"><span class="koboSpan" id="kobo.1721.1">packt</span></strong><span class="koboSpan" id="kobo.1722.1"> --image=</span><strong class="bold"><span class="koboSpan" id="kobo.1723.1">nginxdemos/hello</span></strong></pre> <p><span class="koboSpan" id="kobo.1724.1">The command output shows that our Deployment was </span><span class="No-Break"><span class="koboSpan" id="kobo.1725.1">created successfully:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1726.1">
deployment.apps/packt created</span></pre> <p><span class="koboSpan" id="kobo.1727.1">We just created a Deployment with a ReplicaSet containing a single pod running a web server application. </span><span class="koboSpan" id="kobo.1727.2">We should note that our application is managed by the controller manager within an app Deployment stack (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1728.1">deployment.apps</span></strong><span class="koboSpan" id="kobo.1729.1">). </span><span class="koboSpan" id="kobo.1729.2">Alternatively, we could just deploy a simple application pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">packt-web</span></strong><span class="koboSpan" id="kobo.1731.1">) with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1732.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1733.1">
kubectl run </span><strong class="bold"><span class="koboSpan" id="kobo.1734.1">packt-web</span></strong><span class="koboSpan" id="kobo.1735.1"> --image=</span><strong class="bold"><span class="koboSpan" id="kobo.1736.1">nginxdemos/hello</span></strong></pre> <p><span class="koboSpan" id="kobo.1737.1">The output suggests that our application pod, in this case, a standalone or bare pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">pod/packt-web</span></strong><span class="koboSpan" id="kobo.1739.1">), is not part of </span><span class="No-Break"><span class="koboSpan" id="kobo.1740.1">a Deployment:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1741.1">
pod/packt-web created</span></pre> <p><span class="koboSpan" id="kobo.1742.1">We’ll see later in this section that this pod is not part of a ReplicaSet and so is not managed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1743.1">controller manager.</span></span></p>
<p><span class="koboSpan" id="kobo.1744.1">Let’s look at the state of our system by querying the pods for </span><span class="No-Break"><span class="koboSpan" id="kobo.1745.1">detailed information:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1746.1">
kubectl get pods -o wide</span></pre> <p><span class="koboSpan" id="kobo.1747.1">Let’s analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.1748.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer541">
<span class="koboSpan" id="kobo.1749.1"><img alt="Figure 16.35 – Getting the application pods with detailed information" src="image/B19682_16_35.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1750.1">Figure 16.35 – Getting the application pods with detailed information</span></p>
<p><span class="koboSpan" id="kobo.1751.1">In the preceding output, you can see the series of commands described, and we can also see that our pods are up and running and that Kubernetes deployed them on </span><span class="No-Break"><span class="koboSpan" id="kobo.1752.1">separate nodes:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1753.1">packt-579bb9c999-rtvzr</span></strong><span class="koboSpan" id="kobo.1754.1">: On cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1755.1">node </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1756.1">k8s-n1</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1757.1">packt-web</span></strong><span class="koboSpan" id="kobo.1758.1">: On cluster </span><span class="No-Break"><span class="koboSpan" id="kobo.1759.1">node </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1760.1">k8s-n3</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1761.1">Running the pods on different nodes is due to internal load balancing and resource distribution in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1762.1">Kubernetes cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.1763.1">The application pod managed</span><a id="_idIndexMarker2446"/><span class="koboSpan" id="kobo.1764.1"> by the controller is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1765.1">packt-579bb9c999-rtvzr</span></strong><span class="koboSpan" id="kobo.1766.1">. </span><span class="koboSpan" id="kobo.1766.2">Kubernetes generates a unique name for our managed pod by appending a </span><strong class="bold"><span class="koboSpan" id="kobo.1767.1">pod template hash</span></strong><span class="koboSpan" id="kobo.1768.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1769.1">579bb9c999</span></strong><span class="koboSpan" id="kobo.1770.1">) and a </span><strong class="bold"><span class="koboSpan" id="kobo.1771.1">pod ID</span></strong><span class="koboSpan" id="kobo.1772.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1773.1">rtvzr</span></strong><span class="koboSpan" id="kobo.1774.1">) to the name of the Deployment (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1775.1">packt</span></strong><span class="koboSpan" id="kobo.1776.1">). </span><span class="koboSpan" id="kobo.1776.2">The pod template hash and pod ID are unique within </span><span class="No-Break"><span class="koboSpan" id="kobo.1777.1">a ReplicaSet.</span></span></p>
<p><span class="koboSpan" id="kobo.1778.1">In contrast, the standalone pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1779.1">packt-web</span></strong><span class="koboSpan" id="kobo.1780.1">) is left as is since it’s not part of an application Deployment. </span><span class="koboSpan" id="kobo.1780.2">Let’s describe both pods to obtain more information about them. </span><span class="koboSpan" id="kobo.1780.3">We’ll start with the managed pod first. </span><span class="koboSpan" id="kobo.1780.4">Don’t forget to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1781.1">kubectl</span></strong><span class="koboSpan" id="kobo.1782.1"> autocompletion (by pressing the </span><em class="italic"><span class="koboSpan" id="kobo.1783.1">Tab</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.1784.1">key twice</span></span><span class="No-Break"><span class="koboSpan" id="kobo.1785.1">):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1786.1">
kubectl describe pod packt-5dc77bb9bf-bnzsc</span></pre> <p><span class="koboSpan" id="kobo.1787.1">The related output is relatively large. </span><span class="koboSpan" id="kobo.1787.2">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.1788.1">relevant snippets:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer542">
<span class="koboSpan" id="kobo.1789.1"><img alt="Figure 16.36 – Pod information" src="image/B19682_16_36.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1790.1">Figure 16.36 – Pod information</span></p>
<p><span class="koboSpan" id="kobo.1791.1">In contrast, the same</span><a id="_idIndexMarker2447"/><span class="koboSpan" id="kobo.1792.1"> command for the standalone pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1793.1">packt-web</span></strong><span class="koboSpan" id="kobo.1794.1">) would be slightly different without featuring the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">Controlled </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1796.1">By</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1797.1"> field:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1798.1">
kubectl describe pod packt-web</span></pre> <p><span class="koboSpan" id="kobo.1799.1">Here are the </span><span class="No-Break"><span class="koboSpan" id="kobo.1800.1">corresponding excerpts:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer543">
<span class="koboSpan" id="kobo.1801.1"><img alt="Figure 16.37 – Relevant pod information" src="image/B19682_16_37.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1802.1">Figure 16.37 – Relevant pod information</span></p>
<p><span class="koboSpan" id="kobo.1803.1">You can also venture out to any of the cluster nodes where </span><a id="_idIndexMarker2448"/><span class="koboSpan" id="kobo.1804.1">our pods are running and take a closer look at the related containers. </span><span class="koboSpan" id="kobo.1804.2">Let’s take node </span><strong class="source-inline"><span class="koboSpan" id="kobo.1805.1">k8s-n3</span></strong><span class="koboSpan" id="kobo.1806.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1807.1">192.168.122.163</span></strong><span class="koboSpan" id="kobo.1808.1">), for example, where our standalone pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1809.1">packt-web</span></strong><span class="koboSpan" id="kobo.1810.1">) is running. </span><span class="koboSpan" id="kobo.1810.2">We’ll SSH into the node’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1811.1">terminal first:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1812.1">
ssh packt@192.168.122.163</span></pre> <p><span class="koboSpan" id="kobo.1813.1">Then we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1814.1">containerd</span></strong><span class="koboSpan" id="kobo.1815.1"> runtime to query the containers in </span><span class="No-Break"><span class="koboSpan" id="kobo.1816.1">the system:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1817.1">
sudo crictl --runtime-endpoint unix:///run/containerd/containerd.sock ps</span></pre> <p><span class="koboSpan" id="kobo.1818.1">The output shows </span><span class="No-Break"><span class="koboSpan" id="kobo.1819.1">the following:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer544">
<span class="koboSpan" id="kobo.1820.1"><img alt="Figure 16.38 – Getting the containers running on a cluster node" src="image/B19682_16_38.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1821.1">Figure 16.38 – Getting the containers running on a cluster node</span></p>
<p><span class="koboSpan" id="kobo.1822.1">Next, we’ll show you how to access processes running inside </span><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">the pods.</span></span></p>
<h4><span class="koboSpan" id="kobo.1824.1">Accessing processes in pods</span></h4>
<p><span class="koboSpan" id="kobo.1825.1">Let’s switch back to our local (on our local machine, not the VM) </span><strong class="source-inline"><span class="koboSpan" id="kobo.1826.1">kubectl</span></strong><span class="koboSpan" id="kobo.1827.1"> environment and run the following </span><a id="_idIndexMarker2449"/><span class="koboSpan" id="kobo.1828.1">command to access the shell in the container running the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1829.1">packt-web</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1830.1"> pod:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1831.1">
kubectl exec -it packt-web -- /bin/sh</span></pre> <p><span class="koboSpan" id="kobo.1832.1">The command</span><a id="_idIndexMarker2450"/><span class="koboSpan" id="kobo.1833.1"> takes us inside the container to an interactive shell prompt. </span><span class="koboSpan" id="kobo.1833.2">Here, we can run commands as if we were logged in to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1834.1">packt-web</span></strong><span class="koboSpan" id="kobo.1835.1"> host using the terminal. </span><span class="koboSpan" id="kobo.1835.2">The interactive session is produced using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1836.1">-it</span></strong><span class="koboSpan" id="kobo.1837.1"> option – interactive terminal – or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1838.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">interactive --tty</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1840.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1841.1">Let’s run a few commands, starting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1842.1">process explorer:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1843.1">
ps aux</span></pre> <p><span class="koboSpan" id="kobo.1844.1">Here’s a relevant excerpt from the output, showing the processes running inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1845.1">packt-web</span></strong><span class="koboSpan" id="kobo.1846.1"> container, and some commands running </span><span class="No-Break"><span class="koboSpan" id="kobo.1847.1">inside it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer545">
<span class="koboSpan" id="kobo.1848.1"><img alt="Figure 16.39 – The processes running inside the packt-web container" src="image/B19682_16_39.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1849.1">Figure 16.39 – The processes running inside the packt-web container</span></p>
<p><span class="koboSpan" id="kobo.1850.1">We can also retrieve the IP address with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1851.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1852.1">
ifconfig | grep 'inet addr:' | cut -d: -f2 | awk '{print $1}' | grep -v '127.0.0.1'</span></pre> <p><span class="koboSpan" id="kobo.1853.1">The output shows the pod’s IP address (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1854.1">Figure 16</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1855.1">.39</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1856.1">):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1857.1">
172.16.57.193</span></pre> <p><span class="koboSpan" id="kobo.1858.1">We can also retrieve the hostname with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1859.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1860.1">
hostname</span></pre> <p><span class="koboSpan" id="kobo.1861.1">The output shows the pod name (as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1862.1">Figure 16</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1863.1">.39</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1864.1">):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1865.1">
packt-web</span></pre> <p><span class="koboSpan" id="kobo.1866.1">Let’s leave the container shell with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1867.1">exit</span></strong><span class="koboSpan" id="kobo.1868.1"> command (as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1869.1">Figure 16</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1870.1">.39</span></em><span class="koboSpan" id="kobo.1871.1">) or by pressing </span><em class="italic"><span class="koboSpan" id="kobo.1872.1">Ctrl</span></em><span class="koboSpan" id="kobo.1873.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.1874.1">D</span></em><span class="koboSpan" id="kobo.1875.1">. </span><span class="koboSpan" id="kobo.1875.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1876.1">kubectl</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1877.1">exec</span></strong><span class="koboSpan" id="kobo.1878.1"> command, we can run any process inside a pod, assuming that the related </span><span class="No-Break"><span class="koboSpan" id="kobo.1879.1">process exists.</span></span></p>
<p><span class="koboSpan" id="kobo.1880.1">We’ll experiment next by </span><a id="_idIndexMarker2451"/><span class="koboSpan" id="kobo.1881.1">testing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1882.1">packt-web</span></strong><span class="koboSpan" id="kobo.1883.1"> application pod using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1884.1">curl</span></strong><span class="koboSpan" id="kobo.1885.1">. </span><span class="koboSpan" id="kobo.1885.2">We should note that, at this time, the only way to access the web server endpoint of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1886.1">packt-web</span></strong><span class="koboSpan" id="kobo.1887.1"> is via its internal IP address. </span><span class="koboSpan" id="kobo.1887.2">Previously, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1888.1">kubectl</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1889.1">get pods -o wide</span></strong><span class="koboSpan" id="kobo.1890.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1891.1">describe</span></strong><span class="koboSpan" id="kobo.1892.1"> commands to retrieve detailed information regarding pods, including the pod’s IP address. </span><span class="koboSpan" id="kobo.1892.2">You can also use the following one-liner to retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.1893.1">pod’s IP:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1894.1">
kubectl get pods packt-web -o jsonpath='{.status.podIP}{"\n"}'</span></pre> <p><span class="koboSpan" id="kobo.1895.1">In our case, the command returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1896.1">172.16.57.193</span></strong><span class="koboSpan" id="kobo.1897.1">. </span><span class="koboSpan" id="kobo.1897.2">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1898.1">-o jsonpath</span></strong><span class="koboSpan" id="kobo.1899.1"> output option to specify the JSON query for a specific field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1900.1">{.status.podIP}</span></strong><span class="koboSpan" id="kobo.1901.1">. </span><span class="koboSpan" id="kobo.1901.2">Remember that the pod’s IP is only accessible within the pod network (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1902.1">172.16.0.0/16</span></strong><span class="koboSpan" id="kobo.1903.1">) inside the cluster. </span><span class="koboSpan" id="kobo.1903.2">Following is a screenshot showing </span><span class="No-Break"><span class="koboSpan" id="kobo.1904.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer546">
<span class="koboSpan" id="kobo.1905.1"><img alt="Figure 16.40 – Testing the application pod" src="image/B19682_16_40.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1906.1">Figure 16.40 – Testing the application pod</span></p>
<p><span class="koboSpan" id="kobo.1907.1">Consequently, we need to probe the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1908.1">packt-web</span></strong><span class="koboSpan" id="kobo.1909.1"> endpoint using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">curl</span></strong><span class="koboSpan" id="kobo.1911.1"> command that has originated within the pod network. </span><span class="koboSpan" id="kobo.1911.2">An easy way to accomplish such a task is to run a test pod with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1912.1">curl</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1913.1">utility installed:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1914.1">The following command runs a pod named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1915.1">test</span></strong><span class="koboSpan" id="kobo.1916.1">, based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1917.1">curlimages/curl</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1918.1">Docker image:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1919.1">kubectl run test --image=curlimages/curl sleep 600</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1920.1">We keep the container artificially alive with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1921.1">sleep</span></strong><span class="koboSpan" id="kobo.1922.1"> command due to the Docker entry point of the corresponding image, which simply runs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1923.1">curl</span></strong><span class="koboSpan" id="kobo.1924.1"> command and then exits. </span><span class="koboSpan" id="kobo.1924.2">Without </span><strong class="source-inline"><span class="koboSpan" id="kobo.1925.1">sleep</span></strong><span class="koboSpan" id="kobo.1926.1">, the pod would keep coming up and crashing. </span><span class="koboSpan" id="kobo.1926.2">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1927.1">sleep</span></strong><span class="koboSpan" id="kobo.1928.1"> command, we delay the execution of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1929.1">curl</span></strong><span class="koboSpan" id="kobo.1930.1"> entry point to prevent the exit. </span><span class="koboSpan" id="kobo.1930.2">The output is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1931.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer547">
<span class="koboSpan" id="kobo.1932.1"><img alt="Figure 16.41 – Running a test with curl on the pod" src="image/B19682_16_41.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1933.1">Figure 16.41 – Running a test with curl on the pod</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1934.1">Now, we can run a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.1935.1">curl</span></strong><span class="koboSpan" id="kobo.1936.1"> command using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1937.1">test</span></strong><span class="koboSpan" id="kobo.1938.1"> pod targeting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1939.1">packt-web</span></strong><span class="koboSpan" id="kobo.1940.1"> web </span><span class="No-Break"><span class="koboSpan" id="kobo.1941.1">server endpoint:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1942.1">kubectl exec test -- curl http://172.16.57.193</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1943.1">We’ll get an HTTP response and a corresponding </span><strong class="bold"><span class="koboSpan" id="kobo.1944.1">access log trace</span></strong><span class="koboSpan" id="kobo.1945.1"> (from the Nginx server running in the </span><a id="_idIndexMarker2452"/><span class="koboSpan" id="kobo.1946.1">pod) accounting for the request. </span><span class="koboSpan" id="kobo.1946.2">A snippet of the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.1947.1">as follows:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer548">
<span class="koboSpan" id="kobo.1948.1"><img alt="Figure 16.42 – The response of running the curl test" src="image/B19682_16_42.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1949.1">Figure 16.42 – The response of running the curl test</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1950.1">To view the logs on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1951.1">packt-web</span></strong><span class="koboSpan" id="kobo.1952.1"> pod, we run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1953.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1954.1">kubectl logs packt-web</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1955.1">The output is</span><a id="_idIndexMarker2453"/> <span class="No-Break"><span class="koboSpan" id="kobo.1956.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer549">
<span class="koboSpan" id="kobo.1957.1"><img alt="Figure 16.43 – Logs for packt-web pod" src="image/B19682_16_43.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1958.1">Figure 16.43 – Logs for packt-web pod</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1959.1">The logs in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1960.1">packt-web</span></strong><span class="koboSpan" id="kobo.1961.1"> pod are produced by Nginx and redirected to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1962.1">stdout</span></strong><span class="koboSpan" id="kobo.1963.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1964.1">stderr</span></strong><span class="koboSpan" id="kobo.1965.1">. </span><span class="koboSpan" id="kobo.1965.2">We can </span><a id="_idIndexMarker2454"/><span class="koboSpan" id="kobo.1966.1">easily verify this with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1967.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1968.1">kubectl exec packt-web -- ls -la /var/log/nginx</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1969.1">The output shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.1970.1">related symlinks:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer550">
<span class="koboSpan" id="kobo.1971.1"><img alt="Figure 16.44 – Related symlinks" src="image/B19682_16_44.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1972.1">Figure 16.44 – Related symlinks</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1973.1">When you’re done using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1974.1">test</span></strong><span class="koboSpan" id="kobo.1975.1"> pod, you can delete it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1976.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1977.1">kubectl delete pods test</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.1978.1">Now that we have deployed our first application inside a Kubernetes cluster, let’s look at how to expose the related endpoint to the world. </span><span class="koboSpan" id="kobo.1978.2">Next, we will expose Deployments via </span><span class="No-Break"><span class="koboSpan" id="kobo.1979.1">a Service.</span></span></p>
<h4><span class="koboSpan" id="kobo.1980.1">Exposing Deployments as Services</span></h4>
<p><span class="koboSpan" id="kobo.1981.1">Now, let’s rewind to the command we used previously to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1982.1">packt</span></strong><span class="koboSpan" id="kobo.1983.1"> Deployment. </span><span class="koboSpan" id="kobo.1983.2">Don’t run it. </span><span class="koboSpan" id="kobo.1983.3">Here it is just as </span><span class="No-Break"><span class="koboSpan" id="kobo.1984.1">a refresher:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1985.1">
kubectl create deployment packt --image=nginxdemos/hello</span></pre> <p><span class="koboSpan" id="kobo.1986.1">The command carried out the</span><a id="_idIndexMarker2455"/> <span class="No-Break"><span class="koboSpan" id="kobo.1987.1">following sequence:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1988.1">It created a </span><span class="No-Break"><span class="koboSpan" id="kobo.1989.1">Deployment (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1990.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1991.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1992.1">The Deployment created a </span><span class="No-Break"><span class="koboSpan" id="kobo.1993.1">ReplicaSet (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1994.1">packt-579bb9c999</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1995.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1996.1">The ReplicaSet created the </span><span class="No-Break"><span class="koboSpan" id="kobo.1997.1">pod (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1998.1">packt-579bb9c999-rtvzr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1999.1">).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.2000.1">We can verify that with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2001.1">following commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2002.1">
kubectl get deployments -l app=packt
kubectl get replicasets -l app=packt
kubectl get pods -l app=packt</span></pre> <p><span class="koboSpan" id="kobo.2003.1">In the preceding commands, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2004.1">--label-columns (-l)</span></strong><span class="koboSpan" id="kobo.2005.1"> flag to filter results by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2006.1">app=packt</span></strong><span class="koboSpan" id="kobo.2007.1"> label, denoting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2008.1">packt</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2009.1">Deployment’s resources.</span></span></p>
<p><span class="koboSpan" id="kobo.2010.1">We encourage you to take a closer look at each of these resources using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2011.1">kubectl describe</span></strong><span class="koboSpan" id="kobo.2012.1"> command. </span><span class="koboSpan" id="kobo.2012.2">Don’t forget to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2013.1">kubectl</span></strong><span class="koboSpan" id="kobo.2014.1"> autocomplete feature when typing in </span><span class="No-Break"><span class="koboSpan" id="kobo.2015.1">the commands:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2016.1">
kubectl describe deployment packt | more
kubectl describe replicaset packt | more
kubectl describe pod packt-5dc77bb9bf-bnzsc | more</span></pre> <p><span class="koboSpan" id="kobo.2017.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2018.1">kubectl</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.2019.1">describe</span></strong><span class="koboSpan" id="kobo.2020.1"> command could be very resourceful when troubleshooting applications or pod Deployments. </span><span class="koboSpan" id="kobo.2020.2">Look inside the </span><em class="italic"><span class="koboSpan" id="kobo.2021.1">Events</span></em><span class="koboSpan" id="kobo.2022.1"> section in the related output for clues on pods failing to start, errors, if any, and possibly understand what </span><span class="No-Break"><span class="koboSpan" id="kobo.2023.1">went wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.2024.1">Now that we have deployed our first application inside a Kubernetes cluster, let’s look at how to expose the related endpoint to </span><span class="No-Break"><span class="koboSpan" id="kobo.2025.1">the world.</span></span></p>
<p><span class="koboSpan" id="kobo.2026.1">So far, we have deployed an</span><a id="_idIndexMarker2456"/><span class="koboSpan" id="kobo.2027.1"> application (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2028.1">packt</span></strong><span class="koboSpan" id="kobo.2029.1">) with a single pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2030.1">packt-579bb9c999-rtvzr</span></strong><span class="koboSpan" id="kobo.2031.1">) running an Nginx web server listening on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2032.1">80</span></strong><span class="koboSpan" id="kobo.2033.1">. </span><span class="koboSpan" id="kobo.2033.2">As we explained earlier, at this time, we can only </span><a id="_idIndexMarker2457"/><span class="koboSpan" id="kobo.2034.1">access the pod within the pod network, which is internal to the cluster. </span><span class="koboSpan" id="kobo.2034.2">In this section, we’ll show you how to expose the application (or Deployment) to be accessible from the outside world. </span><span class="koboSpan" id="kobo.2034.3">Kubernetes uses the Service API object, consisting of a </span><strong class="bold"><span class="koboSpan" id="kobo.2035.1">proxy</span></strong><span class="koboSpan" id="kobo.2036.1"> and a </span><strong class="bold"><span class="koboSpan" id="kobo.2037.1">selector</span></strong><span class="koboSpan" id="kobo.2038.1"> routing the network traffic to application pods in a Deployment. </span><span class="koboSpan" id="kobo.2038.2">To proceed, you can follow </span><span class="No-Break"><span class="koboSpan" id="kobo.2039.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2040.1">The following command creates a Service for our </span><span class="No-Break"><span class="koboSpan" id="kobo.2041.1">Deployment (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2042.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2043.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2044.1">kubectl expose deployment packt \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2045.1">    --port=80 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2046.1">    --target-port=80 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2047.1">    --type=NodePort</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2048.1">Here’s a brief explanation of the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.2049.1">command flags:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.2050.1">--port=80</span></strong><span class="koboSpan" id="kobo.2051.1">: This exposes the Service on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2052.1">80</span></strong><span class="koboSpan" id="kobo.2053.1"> externally within </span><span class="No-Break"><span class="koboSpan" id="kobo.2054.1">the cluster</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.2055.1">--target-port=80</span></strong><span class="koboSpan" id="kobo.2056.1">: This maps to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2057.1">80</span></strong><span class="koboSpan" id="kobo.2058.1"> internally in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2059.1">application pod</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.2060.1">--type=NodePort</span></strong><span class="koboSpan" id="kobo.2061.1">: This makes the Service available outside </span><span class="No-Break"><span class="koboSpan" id="kobo.2062.1">the cluster</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.2063.1">The output shows the Service (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2064.1">packt</span></strong><span class="koboSpan" id="kobo.2065.1">) we just created for exposing </span><span class="No-Break"><span class="koboSpan" id="kobo.2066.1">our application:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.2067.1">service/packt exposed</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2068.1">Without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2069.1">--type=NodePort</span></strong><span class="koboSpan" id="kobo.2070.1"> flag, the Service type would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.2071.1">ClusterIP</span></strong><span class="koboSpan" id="kobo.2072.1"> by default, and the Service endpoint would only be accessible within </span><span class="No-Break"><span class="koboSpan" id="kobo.2073.1">the cluster.</span></span></p></li> <li><span class="koboSpan" id="kobo.2074.1">Let’s take a closer look at our </span><span class="No-Break"><span class="koboSpan" id="kobo.2075.1">Service (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2076.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2077.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2078.1">kubectl get service packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2079.1">The output shows the cluster IP assigned to the Service (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2080.1">10.105.111.243</span></strong><span class="koboSpan" id="kobo.2081.1">) and the</span><a id="_idIndexMarker2458"/><span class="koboSpan" id="kobo.2082.1"> ports the Service is listening on for TCP </span><span class="No-Break"><span class="koboSpan" id="kobo.2083.1">traffic (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2084.1">80:32664/TCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2085.1">):</span></span></p><ul><li><span class="koboSpan" id="kobo.2086.1">port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2087.1">80</span></strong><span class="koboSpan" id="kobo.2088.1">: Within </span><span class="No-Break"><span class="koboSpan" id="kobo.2089.1">the </span></span><span class="No-Break"><a id="_idIndexMarker2459"/></span><span class="No-Break"><span class="koboSpan" id="kobo.2090.1">cluster</span></span></li><li><span class="koboSpan" id="kobo.2091.1">port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2092.1">32664</span></strong><span class="koboSpan" id="kobo.2093.1">: Outside the cluster, on any of </span><span class="No-Break"><span class="koboSpan" id="kobo.2094.1">the nodes</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.2095.1">We should note that the cluster IP is only accessible within the cluster and not from </span><span class="No-Break"><span class="koboSpan" id="kobo.2096.1">the outside:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer551">
<span class="koboSpan" id="kobo.2097.1"><img alt="Figure 16.45 – The service exposing the packt deployment" src="image/B19682_16_45.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2098.1">Figure 16.45 – The Service exposing the packt Deployment</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.2099.1">Also, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2100.1">EXTERNAL-IP</span></strong><span class="koboSpan" id="kobo.2101.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2102.1">&lt;none&gt;</span></strong><span class="koboSpan" id="kobo.2103.1">) should not be mistaken for the cluster node’s IP address where our Service is accessible. </span><span class="koboSpan" id="kobo.2103.2">The external IP is usually a load balancer IP address configured by a cloud provider hosting the Kubernetes cluster (configurable via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2104.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2105.1">external-ip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2106.1"> flag).</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.2107.1">We should now be able to access our application outside the cluster by pointing a browser to any of the cluster nodes on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2108.1">32664</span></strong><span class="koboSpan" id="kobo.2109.1">. </span><span class="koboSpan" id="kobo.2109.2">To get a list of our cluster nodes with their respective IP addresses and hostnames, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.2110.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2111.1">kubectl get nodes -o jsonpath='{range .items[*]}{.status.addresses[*].address}{"\n"}'</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2112.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.2113.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer552">
<span class="koboSpan" id="kobo.2114.1"><img alt="Figure 16.46 – List of cluster nodes" src="image/B19682_16_46.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2115.1">Figure 16.46 – List of cluster nodes</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.2116.1">Let’s choose the CP node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2117.1">192.168.122.104/k8s-cp1</span></strong><span class="koboSpan" id="kobo.2118.1">) and enter </span><a id="_idIndexMarker2460"/><span class="koboSpan" id="kobo.2119.1">the following address</span><a id="_idIndexMarker2461"/><span class="koboSpan" id="kobo.2120.1"> in a </span><span class="No-Break"><span class="koboSpan" id="kobo.2121.1">browser: </span></span><span class="No-Break"><span class="koboSpan" id="kobo.2122.1">http://192.168.122.104:32664</span></span><span class="No-Break"><span class="koboSpan" id="kobo.2123.1">.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.2124.1">The web request from the browser is directed to the Service endpoint (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2125.1">packt</span></strong><span class="koboSpan" id="kobo.2126.1">), which routes the related network packets to the application pod (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2127.1">packt-579bb9c999-rtvzr</span></strong><span class="koboSpan" id="kobo.2128.1">). </span><span class="koboSpan" id="kobo.2128.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2129.1">packt</span></strong><span class="koboSpan" id="kobo.2130.1"> web application responds with a simple Nginx </span><strong class="bold"><span class="koboSpan" id="kobo.2131.1">Hello World</span></strong><span class="koboSpan" id="kobo.2132.1"> web page, displaying the pod’s internal IP address (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2133.1">172.16.215.65</span></strong><span class="koboSpan" id="kobo.2134.1">) and </span><span class="No-Break"><span class="koboSpan" id="kobo.2135.1">name (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2136.1">packt-579bb9c999-rtvzr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2137.1">):</span></span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer553">
<span class="koboSpan" id="kobo.2138.1"><img alt="Figure 16.47 – Accessing the packt application service" src="image/B19682_16_47.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2139.1">Figure 16.47 – Accessing the packt application Service</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.2140.1">To verify that the </span><a id="_idIndexMarker2462"/><span class="koboSpan" id="kobo.2141.1">information on the web page is accurate, you may </span><a id="_idIndexMarker2463"/><span class="koboSpan" id="kobo.2142.1">run the following </span><strong class="source-inline"><span class="koboSpan" id="kobo.2143.1">kubectl</span></strong><span class="koboSpan" id="kobo.2144.1"> command, retrieving </span><span class="No-Break"><span class="koboSpan" id="kobo.2145.1">similar information:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2146.1">kubectl get pod packt-579bb9c999-rtvzr -o jsonpath='{.status.podIP}{"\n"}{.metadata.name}{"\n"}'</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2147.1">The output of the</span><a id="_idIndexMarker2464"/><span class="koboSpan" id="kobo.2148.1"> command will be the internal IP address and the name of the pod, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.2149.1">the following:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer554">
<span class="koboSpan" id="kobo.2150.1"><img alt="Figure 16.48 – Verify the information with the kubectl command" src="image/B19682_16_48.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2151.1">Figure 16.48 – Verify the information with the kubectl command</span></p>
<p><span class="koboSpan" id="kobo.2152.1">Suppose we have high traffic targeting our application, and we’d like to scale out the ReplicaSet controlling our pods. </span><span class="koboSpan" id="kobo.2152.2">We’ll show you how to accomplish this task in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2153.1">next section.</span></span></p>
<h4><span class="koboSpan" id="kobo.2154.1">Scaling application Deployments</span></h4>
<p><span class="koboSpan" id="kobo.2155.1">Currently, we have a single pod in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2156.1">packt</span></strong><span class="koboSpan" id="kobo.2157.1"> Deployment. </span><span class="koboSpan" id="kobo.2157.2">In order to scale the </span><a id="_idIndexMarker2465"/><span class="koboSpan" id="kobo.2158.1">application Deployments, we have to obtain information about the running replicas, to scale them to the desired number and test it. </span><span class="koboSpan" id="kobo.2158.2">Here are the steps </span><span class="No-Break"><span class="koboSpan" id="kobo.2159.1">to take:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2160.1">To retrieve the relevant details about the number of running replicas, we run the following </span><span class="No-Break"><span class="koboSpan" id="kobo.2161.1">command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2162.1">kubectl describe deployment packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2163.1">The relevant excerpt in the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.2164.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer555">
<span class="koboSpan" id="kobo.2165.1"><img alt="Figure 16.49 – Pod details" src="image/B19682_16_49.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2166.1">Figure 16.49 – Pod details</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.2167.1">Let’s scale up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.2168.1">packt</span></strong><span class="koboSpan" id="kobo.2169.1"> Deployment to</span><a id="_idIndexMarker2466"/><span class="koboSpan" id="kobo.2170.1"> 10 replicas with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2171.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2172.1">kubectl scale deployment packt --replicas=10</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2173.1">The command output is </span><span class="No-Break"><span class="koboSpan" id="kobo.2174.1">as follows:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.2175.1">deployment.apps/packt scaled</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2176.1">If we list the pods of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2177.1">packt</span></strong><span class="koboSpan" id="kobo.2178.1"> Deployment, we’ll see 10 </span><span class="No-Break"><span class="koboSpan" id="kobo.2179.1">pods running:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2180.1">kubectl get pods -l app=packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2181.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.2182.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer556">
<span class="koboSpan" id="kobo.2183.1"><img alt="Figure 16.50 – Scaling up the deployment replicas" src="image/B19682_16_50.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2184.1">Figure 16.50 – Scaling up the Deployment replicas</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.2185.1">Incoming requests to our application Service endpoint (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2186.1">http://192.168.122.104:32664</span></strong><span class="koboSpan" id="kobo.2187.1">) will be load balanced between the pods. </span><span class="koboSpan" id="kobo.2187.2">To illustrate this behavior, we can either use </span><strong class="source-inline"><span class="koboSpan" id="kobo.2188.1">curl</span></strong><span class="koboSpan" id="kobo.2189.1"> or a text-based browser at the command line to avoid the caching-related</span><a id="_idIndexMarker2467"/><span class="koboSpan" id="kobo.2190.1"> optimizations of a modern desktop browser. </span><span class="koboSpan" id="kobo.2190.2">For a better illustration, we’ll use </span><strong class="bold"><span class="koboSpan" id="kobo.2191.1">Lynx</span></strong><span class="koboSpan" id="kobo.2192.1">, a simple text-based browser. </span><span class="koboSpan" id="kobo.2192.2">On our Debian 12 desktop, the package is already installed. </span><span class="koboSpan" id="kobo.2192.3">You can install it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2193.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2194.1">sudo apt-get install -y lynx</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2195.1">Next, we point Lynx to our </span><span class="No-Break"><span class="koboSpan" id="kobo.2196.1">application endpoint:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2197.1">lynx 172.16.191.6:32081</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2198.1">If we refresh the page with </span><em class="italic"><span class="koboSpan" id="kobo.2199.1">Ctrl</span></em><span class="koboSpan" id="kobo.2200.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.2201.1">R</span></em><span class="koboSpan" id="kobo.2202.1"> every few seconds, we observe that the server address and name change based on the current pod processing </span><span class="No-Break"><span class="koboSpan" id="kobo.2203.1">the request:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer557">
<span class="koboSpan" id="kobo.2204.1"><img alt="Figure 16.51 – Load balancing requests across pods" src="image/B19682_16_51.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2205.1">Figure 16.51 – Load balancing requests across pods</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.2206.1">You can exit the</span><a id="_idIndexMarker2468"/><span class="koboSpan" id="kobo.2207.1"> Lynx browser by typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.2208.1">Q</span></strong><span class="koboSpan" id="kobo.2209.1"> and then </span><span class="No-Break"><span class="koboSpan" id="kobo.2210.1">pressing </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2211.1">Enter</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2212.1">.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.2213.1">We can scale back our Deployment (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2214.1">packt</span></strong><span class="koboSpan" id="kobo.2215.1">) to three replicas (or any other non-zero positive number) with</span><a id="_idIndexMarker2469"/><span class="koboSpan" id="kobo.2216.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.2217.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2218.1">kubectl scale deployment packt --replicas=3</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2219.1">If we query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2220.1">packt</span></strong><span class="koboSpan" id="kobo.2221.1"> application pods, we can see the surplus pods terminating until only three pods </span><span class="No-Break"><span class="koboSpan" id="kobo.2222.1">are remaining:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2223.1">kubectl get pods -l app=packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2224.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.2225.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer558">
<span class="koboSpan" id="kobo.2226.1"><img alt="Figure 16.52 – Scaling back to three pods" src="image/B19682_16_52.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2227.1">Figure 16.52 – Scaling back to three pods</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.2228.1">Before concluding our imperative Deployments, let’s clean up all the resources we have created </span><span class="No-Break"><span class="koboSpan" id="kobo.2229.1">thus far:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2230.1">kubectl delete service packt</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2231.1">kubectl delete deployment packt</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2232.1">kubectl delete pod packt-web</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2233.1">The following command should reflect a </span><span class="No-Break"><span class="koboSpan" id="kobo.2234.1">clean slate:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2235.1">kubectl get all</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2236.1">The output</span><a id="_idIndexMarker2470"/><span class="koboSpan" id="kobo.2237.1"> is </span><span class="No-Break"><span class="koboSpan" id="kobo.2238.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer559">
<span class="koboSpan" id="kobo.2239.1"><img alt="Figure 16.53 – The cluster in a default state" src="image/B19682_16_53.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2240.1">Figure 16.53 – The cluster in a default state</span></p>
<p><span class="koboSpan" id="kobo.2241.1">In the next section, we’ll look</span><a id="_idIndexMarker2471"/><span class="koboSpan" id="kobo.2242.1"> at how to deploy resources and applications declaratively in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2243.1">Kubernetes cluster.</span></span></p>
<h3><span class="koboSpan" id="kobo.2244.1">Working with declarative Deployments</span></h3>
<p><span class="koboSpan" id="kobo.2245.1">At the heart of a</span><a id="_idIndexMarker2472"/><span class="koboSpan" id="kobo.2246.1"> declarative Deployment is a manifest file. </span><span class="koboSpan" id="kobo.2246.2">Manifest files are generally in YAML format and authoring them usually involves a mix of autogenerated code and manual editing. </span><span class="koboSpan" id="kobo.2246.3">The manifest is then deployed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2247.1">kubectl </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2248.1">apply</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2249.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2250.1">
kubectl apply -f MANIFEST</span></pre> <p><span class="koboSpan" id="kobo.2251.1">Deploying resources declaratively in Kubernetes involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.2252.1">following stages:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2253.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.2254.1">manifest file</span></span></li>
<li><span class="koboSpan" id="kobo.2255.1">Updating </span><span class="No-Break"><span class="koboSpan" id="kobo.2256.1">the manifest</span></span></li>
<li><span class="koboSpan" id="kobo.2257.1">Validating </span><span class="No-Break"><span class="koboSpan" id="kobo.2258.1">the manifest</span></span></li>
<li><span class="koboSpan" id="kobo.2259.1">Deploying </span><span class="No-Break"><span class="koboSpan" id="kobo.2260.1">the manifest</span></span></li>
<li><span class="koboSpan" id="kobo.2261.1">Iterating between the </span><span class="No-Break"><span class="koboSpan" id="kobo.2262.1">preceding stages</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2263.1">To illustrate the declarative model, we follow the example of deploying a simple Hello World web application to the cluster. </span><span class="koboSpan" id="kobo.2263.2">The result will be similar to our previous approach of using the</span><a id="_idIndexMarker2473"/> <span class="No-Break"><span class="koboSpan" id="kobo.2264.1">imperative method.</span></span></p>
<p><span class="koboSpan" id="kobo.2265.1">So, let’s start by creating a manifest for </span><span class="No-Break"><span class="koboSpan" id="kobo.2266.1">our Deployment.</span></span></p>
<h4><span class="koboSpan" id="kobo.2267.1">Creating a manifest</span></h4>
<p><span class="koboSpan" id="kobo.2268.1">When we created our </span><strong class="source-inline"><span class="koboSpan" id="kobo.2269.1">packt</span></strong><span class="koboSpan" id="kobo.2270.1"> Deployment imperatively, we used the </span><a id="_idIndexMarker2474"/><span class="koboSpan" id="kobo.2271.1">following command (don’t run it </span><span class="No-Break"><span class="koboSpan" id="kobo.2272.1">just yet!):</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2273.1">
kubectl create deployment packt --image=nginxdemos/hello</span></pre> <p><span class="koboSpan" id="kobo.2274.1">The following command will simulate the same process without changing the </span><span class="No-Break"><span class="koboSpan" id="kobo.2275.1">system state:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2276.1">
kubectl create deployment packt --image=nginxdemos/hello \
    </span><strong class="bold"><span class="koboSpan" id="kobo.2277.1">--dry-run=client</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.2278.1">--output=yaml</span></strong></pre> <p><span class="koboSpan" id="kobo.2279.1">We used the following additional </span><span class="No-Break"><span class="koboSpan" id="kobo.2280.1">options (flags):</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2281.1">--dry-run=client</span></strong><span class="koboSpan" id="kobo.2282.1">: This runs the command in the local </span><strong class="source-inline"><span class="koboSpan" id="kobo.2283.1">kubectl</span></strong><span class="koboSpan" id="kobo.2284.1"> environment (</span><em class="italic"><span class="koboSpan" id="kobo.2285.1">client</span></em><span class="koboSpan" id="kobo.2286.1">) without modifying the </span><span class="No-Break"><span class="koboSpan" id="kobo.2287.1">system state</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.2288.1">--output=yaml</span></strong><span class="koboSpan" id="kobo.2289.1">: This formats the command output </span><span class="No-Break"><span class="koboSpan" id="kobo.2290.1">as YAML</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2291.1">The output of the command is </span><span class="No-Break"><span class="koboSpan" id="kobo.2292.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer560">
<span class="koboSpan" id="kobo.2293.1"><img alt="Figure 16.54 – Simulating a manifest creation" src="image/B19682_16_54.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2294.1">Figure 16.54 – Simulating a manifest creation</span></p>
<p><span class="koboSpan" id="kobo.2295.1">We can use the previous command’s output to analyze the changes to be made to the system. </span><span class="koboSpan" id="kobo.2295.2">Then we can redirect it to a file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2296.1">packt.yaml</span></strong><span class="koboSpan" id="kobo.2297.1">) serving as a draft of our </span><span class="No-Break"><span class="koboSpan" id="kobo.2298.1">Deployment manifest:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2299.1">
kubectl create deployment packt --image=nginxdemos/hello \
    --dry-run=client --output=yaml &gt; </span><strong class="bold"><span class="koboSpan" id="kobo.2300.1">packt.yaml</span></strong></pre> <p><span class="koboSpan" id="kobo.2301.1">We have created our first manifest file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2302.1">packt.yaml</span></strong><span class="koboSpan" id="kobo.2303.1">. </span><span class="koboSpan" id="kobo.2303.2">From here, we can edit the file to accommodate more complex</span><a id="_idIndexMarker2475"/><span class="koboSpan" id="kobo.2304.1"> configurations. </span><span class="koboSpan" id="kobo.2304.2">For now, we’ll leave the manifest as is and proceed with the next stage in our declarative </span><span class="No-Break"><span class="koboSpan" id="kobo.2305.1">Deployment workflow.</span></span></p>
<h4><span class="koboSpan" id="kobo.2306.1">Validating a manifest</span></h4>
<p><span class="koboSpan" id="kobo.2307.1">Before deploying a manifest, we recommend validating the Deployment, especially if you</span><a id="_idIndexMarker2476"/><span class="koboSpan" id="kobo.2308.1"> edited the file manually. </span><span class="koboSpan" id="kobo.2308.2">Editing mistakes can happen, particularly when working with complex YAML files with multiple </span><span class="No-Break"><span class="koboSpan" id="kobo.2309.1">indentation levels.</span></span></p>
<p><span class="koboSpan" id="kobo.2310.1">The following command validates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2311.1">packt.yaml</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2312.1">Deployment manifest:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2313.1">
kubectl apply -f packt.yaml --dry-run=client</span></pre> <p><span class="koboSpan" id="kobo.2314.1">A successful validation yields the </span><span class="No-Break"><span class="koboSpan" id="kobo.2315.1">following output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2316.1">
deployment.apps/packt created (dry run)</span></pre> <p><span class="koboSpan" id="kobo.2317.1">If there are any errors, we should edit the manifest file and correct them prior to deployment. </span><span class="koboSpan" id="kobo.2317.2">Our manifest looks good, so let’s go ahead and </span><span class="No-Break"><span class="koboSpan" id="kobo.2318.1">deploy it.</span></span></p>
<h4><span class="koboSpan" id="kobo.2319.1">Deploying a manifest</span></h4>
<p><span class="koboSpan" id="kobo.2320.1">To deploy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2321.1">packt.yaml</span></strong><span class="koboSpan" id="kobo.2322.1"> manifest, we use the </span><span class="No-Break"><span class="koboSpan" id="kobo.2323.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2324.1">
kubectl apply -f packt.yaml</span></pre> <p><span class="koboSpan" id="kobo.2325.1">A successful Deployment shows</span><a id="_idIndexMarker2477"/><span class="koboSpan" id="kobo.2326.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.2327.1">following message:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2328.1">
deployment.apps/packt created</span></pre> <p><span class="koboSpan" id="kobo.2329.1">We can check the deployed resources with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2330.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.2331.1">
kubectl get all -l app=packt</span></pre> <p><span class="koboSpan" id="kobo.2332.1">The output shows that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2333.1">packt</span></strong><span class="koboSpan" id="kobo.2334.1"> Deployment</span><a id="_idIndexMarker2478"/><span class="koboSpan" id="kobo.2335.1"> resources created declaratively are up </span><span class="No-Break"><span class="koboSpan" id="kobo.2336.1">and running:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer561">
<span class="koboSpan" id="kobo.2337.1"><img alt="Figure 16.55 – The deployment resources created declaratively" src="image/B19682_16_55.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2338.1">Figure 16.55 – The Deployment resources created declaratively</span></p>
<p><span class="koboSpan" id="kobo.2339.1">Next, we want to expose our Deployment using </span><span class="No-Break"><span class="koboSpan" id="kobo.2340.1">a Service.</span></span></p>
<h4><span class="koboSpan" id="kobo.2341.1">Exposing the Deployment with a Service</span></h4>
<p><span class="koboSpan" id="kobo.2342.1">We’ll repeat the preceding workflow by </span><a id="_idIndexMarker2479"/><span class="koboSpan" id="kobo.2343.1">creating, validating, and deploying the Service manifest (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2344.1">packt-svc.yaml</span></strong><span class="koboSpan" id="kobo.2345.1">). </span><span class="koboSpan" id="kobo.2345.2">For brevity, we simply enumerate the </span><span class="No-Break"><span class="koboSpan" id="kobo.2346.1">related commands:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2347.1">Create the manifest file (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2348.1">packt-svc.yaml</span></strong><span class="koboSpan" id="kobo.2349.1">) for the Service exposing our </span><span class="No-Break"><span class="koboSpan" id="kobo.2350.1">Deployment (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2351.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2352.1">):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2353.1">kubectl expose deployment packt \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2354.1">    --port=80 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2355.1">    --target-port=80 \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2356.1">    --type=NodePort \</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2357.1">    --dry-run=client --output=yaml &gt; packt-svc.yaml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2358.1">We explained the preceding command previously in the </span><em class="italic"><span class="koboSpan" id="kobo.2359.1">Exposing Deployments as </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.2360.1">Services</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.2361.1"> section.</span></span></p></li> <li><span class="koboSpan" id="kobo.2362.1">Next, we’ll validate</span><a id="_idIndexMarker2480"/><span class="koboSpan" id="kobo.2363.1"> the Service </span><span class="No-Break"><span class="koboSpan" id="kobo.2364.1">Deployment manifest:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2365.1">kubectl apply -f packt-svc.yaml --dry-run=client</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2366.1">If the validation is successful, we deploy the </span><span class="No-Break"><span class="koboSpan" id="kobo.2367.1">Service manifest:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2368.1">kubectl apply -f packt-svc.yaml</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2369.1">Let’s get the current status of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2370.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2371.1"> resources:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2372.1">kubectl get all -l app=packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2373.1">The output shows all of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2374.1">packt</span></strong><span class="koboSpan" id="kobo.2375.1"> application resources, including the Service endpoint (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2376.1">service/packt</span></strong><span class="koboSpan" id="kobo.2377.1">) listening on </span><span class="No-Break"><span class="koboSpan" id="kobo.2378.1">port </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2379.1">31380</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2380.1">:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer562">
<span class="koboSpan" id="kobo.2381.1"><img alt="Figure 16.56 – The packt application resources deployed" src="image/B19682_16_56.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2382.1">Figure 16.56 – The packt application resources deployed</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.2383.1">Using a browser, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2384.1">curl</span></strong><span class="koboSpan" id="kobo.2385.1">, or Lynx, we can access our application by targeting </span><a id="_idIndexMarker2481"/><span class="koboSpan" id="kobo.2386.1">any of the cluster nodes on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.2387.1">31380</span></strong><span class="koboSpan" id="kobo.2388.1">. </span><span class="koboSpan" id="kobo.2388.2">Let’s use the CP node (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2389.1">k8s-cp1</span></strong><span class="koboSpan" id="kobo.2390.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.2391.1">192.168.122.104</span></strong><span class="koboSpan" id="kobo.2392.1">) by pointing our browser </span><span class="No-Break"><span class="koboSpan" id="kobo.2393.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2394.1">http://192.168.122.104:31380</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2395.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer563">
<span class="koboSpan" id="kobo.2396.1"><img alt="Figure 16.57 – Accessing the packt application endpoint" src="image/B19682_16_57.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2397.1">Figure 16.57 – Accessing the packt application endpoint</span></p>
<p><span class="koboSpan" id="kobo.2398.1">If we want to change the existing configuration of a resource in our application Deployment, we can update the related manifest and redeploy it. </span><span class="koboSpan" id="kobo.2398.2">In the next section, we’ll modify the Deployment to accommodate a </span><span class="No-Break"><span class="koboSpan" id="kobo.2399.1">scale-out scenario.</span></span></p>
<h4><span class="koboSpan" id="kobo.2400.1">Updating a manifest</span></h4>
<p><span class="koboSpan" id="kobo.2401.1">Suppose our application is taking a high number of requests, and we’d like to add more pods to our </span><a id="_idIndexMarker2482"/><span class="koboSpan" id="kobo.2402.1">Deployment to handle the traffic. </span><span class="koboSpan" id="kobo.2402.2">We need to change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2403.1">spec.replicas</span></strong><span class="koboSpan" id="kobo.2404.1"> configuration setting in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.2405.1">pack.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.2406.1"> manifest:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2407.1">Using your editor of choice, edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2408.1">packt.yaml</span></strong><span class="koboSpan" id="kobo.2409.1"> file and locate the following </span><span class="No-Break"><span class="koboSpan" id="kobo.2410.1">configuration section:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.2411.1">
spec:
  replicas: 1</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.2412.1">Change the value from </span><strong class="source-inline"><span class="koboSpan" id="kobo.2413.1">1</span></strong><span class="koboSpan" id="kobo.2414.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.2415.1">10</span></strong><span class="koboSpan" id="kobo.2416.1"> for additional application pods in the ReplicaSet controlled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2417.1">packt</span></strong><span class="koboSpan" id="kobo.2418.1"> Deployment. </span><span class="koboSpan" id="kobo.2418.2">The configuration becomes </span><span class="No-Break"><span class="koboSpan" id="kobo.2419.1">the following:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.2420.1">spec:
  replicas: 10</span></pre></li> <li><span class="koboSpan" id="kobo.2421.1">Save the manifest file and </span><a id="_idIndexMarker2483"/><span class="koboSpan" id="kobo.2422.1">redeploy with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2423.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2424.1">kubectl apply -f packt.yaml</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2425.1">The output suggests that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2426.1">packt</span></strong><span class="koboSpan" id="kobo.2427.1"> Deployment has </span><span class="No-Break"><span class="koboSpan" id="kobo.2428.1">been reconfigured:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.2429.1">deployment.apps/packt configured</span></strong></pre></li> <li><span class="koboSpan" id="kobo.2430.1">If we query the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2431.1">packt</span></strong><span class="koboSpan" id="kobo.2432.1"> resources in the cluster, we should see the new pods up </span><span class="No-Break"><span class="koboSpan" id="kobo.2433.1">and running:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2434.1">kubectl get all -l app=packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2435.1">The output displays the application resources of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.2436.1">packt</span></strong><span class="koboSpan" id="kobo.2437.1"> Deployment, including the additional pods deployed in </span><span class="No-Break"><span class="koboSpan" id="kobo.2438.1">the cluster:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer564">
<span class="koboSpan" id="kobo.2439.1"><img alt="Figure 16.58 – The additional pods added for application scale-out" src="image/B19682_16_58.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2440.1">Figure 16.58 – The additional pods added for application scale-out</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.2441.1">We encourage you to test with the scale-out environment and verify the load balancing workload described in the </span><em class="italic"><span class="koboSpan" id="kobo.2442.1">Scaling application Deployments</span></em><span class="koboSpan" id="kobo.2443.1"> section earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.2444.1">this chapter.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.2445.1">Let’s scale back our </span><a id="_idIndexMarker2484"/><span class="koboSpan" id="kobo.2446.1">Deployment to three pods, but this time by updating the related manifest on the fly with the </span><span class="No-Break"><span class="koboSpan" id="kobo.2447.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2448.1">kubectl edit deployment packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2449.1">The command will open our default editor in the system (</span><strong class="bold"><span class="koboSpan" id="kobo.2450.1">vi</span></strong><span class="koboSpan" id="kobo.2451.1">) to make the </span><span class="No-Break"><span class="koboSpan" id="kobo.2452.1">desired change:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer565">
<span class="koboSpan" id="kobo.2453.1"><img alt="Figure 16.59 – Making deployment changes on the fly" src="image/B19682_16_59.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2454.1">Figure 16.59 – Making Deployment changes on the fly</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.2455.1">After saving and exiting the editor, we’ll get a message suggesting that our Deployment (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2456.1">packt</span></strong><span class="koboSpan" id="kobo.2457.1">) has</span><a id="_idIndexMarker2485"/> <span class="No-Break"><span class="koboSpan" id="kobo.2458.1">been updated:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2459.1">deployment.apps/packt edited</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2460.1">Please note that the modifications made on the fly with </span><strong class="source-inline"><span class="koboSpan" id="kobo.2461.1">kubectl edit</span></strong><span class="koboSpan" id="kobo.2462.1"> will not be reflected in the Deployment manifest (</span><strong class="source-inline"><span class="koboSpan" id="kobo.2463.1">packt.yaml</span></strong><span class="koboSpan" id="kobo.2464.1">). </span><span class="koboSpan" id="kobo.2464.2">Nevertheless, the related configuration changes are persisted in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2465.1">cluster (etcd).</span></span></p></li> <li><span class="koboSpan" id="kobo.2466.1">We can verify our updated Deployment with the help of the </span><span class="No-Break"><span class="koboSpan" id="kobo.2467.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2468.1">kubectl get deployment packt</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.2469.1">The output now shows only three pods running in </span><span class="No-Break"><span class="koboSpan" id="kobo.2470.1">our Deployment:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer566">
<span class="koboSpan" id="kobo.2471.1"><img alt="Figure 16.60 – Showing the number of deployments" src="image/B19682_16_60.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.2472.1">Figure 16.60 – Showing the number of Deployments</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.2473.1">Before wrapping up, let’s clean up our resources once again with the following commands to bring the cluster back to the </span><span class="No-Break"><span class="koboSpan" id="kobo.2474.1">default state:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.2475.1">kubectl delete service packt</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.2476.1">kubectl delete deployment packt</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.2477.1">We have shown you how to use Kubernetes on bare metal, and in the next section, we will briefly point you to some useful resources for using Kubernetes in </span><span class="No-Break"><span class="koboSpan" id="kobo.2478.1">the cloud.</span></span></p>
<h2 id="_idParaDest-337"><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.2479.1">Running Kubernetes in the cloud</span></h2>
<p><span class="koboSpan" id="kobo.2480.1">Managed</span><a id="_idIndexMarker2486"/><span class="koboSpan" id="kobo.2481.1"> Kubernetes Services are</span><a id="_idIndexMarker2487"/><span class="koboSpan" id="kobo.2482.1"> fairly common among public cloud providers. </span><span class="koboSpan" id="kobo.2482.2">Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.2483.1">Elastic Kubernetes Service</span></strong><span class="koboSpan" id="kobo.2484.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2485.1">EKS</span></strong><span class="koboSpan" id="kobo.2486.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.2487.1">Azure Kubernetes Services</span></strong><span class="koboSpan" id="kobo.2488.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2489.1">AKS</span></strong><span class="koboSpan" id="kobo.2490.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.2491.1">Google Kubernetes Engine</span></strong><span class="koboSpan" id="kobo.2492.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.2493.1">GKE</span></strong><span class="koboSpan" id="kobo.2494.1">) are the major cloud offerings of </span><a id="_idIndexMarker2488"/><span class="koboSpan" id="kobo.2495.1">Kubernetes at the time of this</span><a id="_idIndexMarker2489"/><span class="koboSpan" id="kobo.2496.1"> writing. </span><span class="koboSpan" id="kobo.2496.2">In this section, we’ll not focus on any of these solutions, but we will provide you with solid resources on how to use Kubernetes in the cloud. </span><span class="koboSpan" id="kobo.2496.3">For more advanced titles on this subject, please check the </span><em class="italic"><span class="koboSpan" id="kobo.2497.1">Further reading</span></em><span class="koboSpan" id="kobo.2498.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.2499.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.2500.1">We should note that we just scratched the surface of deploying and managing Kubernetes clusters. </span><span class="koboSpan" id="kobo.2500.2">Yet, here we are, at a significant milestone, where we deployed our first Kubernetes clusters on-premises. </span><span class="koboSpan" id="kobo.2500.3">We have reached the end of this journey here, but we trust that you’ll take it to the next level and further explore the exciting domain of application Deployment and scaling with Kubernetes. </span><span class="koboSpan" id="kobo.2500.4">Let’s now summarize what we have learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.2501.1">this chapter.</span></span></p>
<h1 id="_idParaDest-338"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.2502.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.2503.1">We began this chapter with a high-level overview of the Kubernetes architecture and API object model, introducing the most common cluster resources, such as pods, Deployments, and Services. </span><span class="koboSpan" id="kobo.2503.2">Next, we took on the relatively challenging task of building an on-premises Kubernetes cluster from scratch using VMs. </span><span class="koboSpan" id="kobo.2503.3">We explored various CLI tools for managing Kubernetes cluster resources on-premises. </span><span class="koboSpan" id="kobo.2503.4">At the high point of our journey, we focused on deploying and scaling applications in Kubernetes using imperative and declarative </span><span class="No-Break"><span class="koboSpan" id="kobo.2504.1">Deployment scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.2505.1">We believe that novice Linux administrators will benefit greatly from the material covered in this chapter and become more knowledgeable in managing resources across hybrid clouds and on-premises distributed environments, deploying applications at scale, and working with CLI tools. </span><span class="koboSpan" id="kobo.2505.2">We believe that the structured information in this chapter will also help seasoned system administrators refresh some of their knowledge and skills in the </span><span class="No-Break"><span class="koboSpan" id="kobo.2506.1">areas covered.</span></span></p>
<p><span class="koboSpan" id="kobo.2507.1">It’s been a relatively long chapter, and we barely skimmed the surface of the related field. </span><span class="koboSpan" id="kobo.2507.2">We encourage you to explore some resources captured in the </span><em class="italic"><span class="koboSpan" id="kobo.2508.1">Further reading</span></em><span class="koboSpan" id="kobo.2509.1"> section and strengthen your knowledge regarding some key areas of Kubernetes environments, such as networking, security, </span><span class="No-Break"><span class="koboSpan" id="kobo.2510.1">and scale.</span></span></p>
<p><span class="koboSpan" id="kobo.2511.1">In the next chapter, we’ll stay within the application deployment realm and look at </span><strong class="bold"><span class="koboSpan" id="kobo.2512.1">Ansible</span></strong><span class="koboSpan" id="kobo.2513.1">, a platform for accelerating application delivery on-premises and in </span><span class="No-Break"><span class="koboSpan" id="kobo.2514.1">the cloud.</span></span></p>
<h1 id="_idParaDest-339"><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.2515.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.2516.1">Here are a few questions for refreshing or pondering upon some of the concepts you’ve learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.2517.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.2518.1">Enumerate some of the essential Services of a Kubernetes CP node. </span><span class="koboSpan" id="kobo.2518.2">How do the worker </span><span class="No-Break"><span class="koboSpan" id="kobo.2519.1">nodes differ?</span></span></li>
<li><span class="koboSpan" id="kobo.2520.1">What command did we use to bootstrap a </span><span class="No-Break"><span class="koboSpan" id="kobo.2521.1">Kubernetes cluster?</span></span></li>
<li><span class="koboSpan" id="kobo.2522.1">What is the difference between imperative and declarative Deployments </span><span class="No-Break"><span class="koboSpan" id="kobo.2523.1">in Kubernetes?</span></span></li>
<li><span class="koboSpan" id="kobo.2524.1">What is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2525.1">kubectl</span></strong><span class="koboSpan" id="kobo.2526.1"> command for deploying a pod? </span><span class="koboSpan" id="kobo.2526.2">How about the command for creating </span><span class="No-Break"><span class="koboSpan" id="kobo.2527.1">a Deployment?</span></span></li>
<li><span class="koboSpan" id="kobo.2528.1">What is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2529.1">kubectl</span></strong><span class="koboSpan" id="kobo.2530.1"> command to access the shell within a </span><span class="No-Break"><span class="koboSpan" id="kobo.2531.1">pod container?</span></span></li>
<li><span class="koboSpan" id="kobo.2532.1">What is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.2533.1">kubectl</span></strong><span class="koboSpan" id="kobo.2534.1"> command to query all resources related to </span><span class="No-Break"><span class="koboSpan" id="kobo.2535.1">a Deployment?</span></span></li>
<li><span class="koboSpan" id="kobo.2536.1">How do you scale out a Deployment in Kubernetes? </span><span class="koboSpan" id="kobo.2536.2">Can you think of the different ways (commands) in which to accomplish </span><span class="No-Break"><span class="koboSpan" id="kobo.2537.1">the task?</span></span></li>
<li><span class="koboSpan" id="kobo.2538.1">How do you delete all resources related to a Deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.2539.1">in Kubernetes?</span></span></li>
</ol>
<h1 id="_idParaDest-340"><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.2540.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.2541.1">The following resources may help you to consolidate your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.2542.1">Kubernetes further:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.2543.1">Kubernetes documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.2544.1">online: </span></span><a href="https://kubernetes.io/docs/home/"><span class="No-Break"><span class="koboSpan" id="kobo.2545.1">https://kubernetes.io/docs/home/</span></span></a></li>
<li><span class="koboSpan" id="kobo.2546.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.2547.1">kubectl</span></strong><span class="koboSpan" id="kobo.2548.1"> cheat </span><span class="No-Break"><span class="koboSpan" id="kobo.2549.1">sheet: </span></span><a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet/"><span class="No-Break"><span class="koboSpan" id="kobo.2550.1">https://kubernetes.io/docs/reference/kubectl/cheatsheet/</span></span></a></li>
<li><em class="italic"><span class="koboSpan" id="kobo.2551.1">Kubernetes and Docker: The Container Masterclass [Video]</span></em><span class="koboSpan" id="kobo.2552.1">, </span><em class="italic"><span class="koboSpan" id="kobo.2553.1">Cerulean Canvas</span></em><span class="koboSpan" id="kobo.2554.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.2555.1">Packt Publishing</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.2556.1">Mastering Kubernetes – Third Edition</span></em><span class="koboSpan" id="kobo.2557.1">, Gigi Sayfan, </span><span class="No-Break"><span class="koboSpan" id="kobo.2558.1">Packt Publishing</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.2559.1">The following is a short list of useful links for deploying Kubernetes on Azure, Amazon, </span><span class="No-Break"><span class="koboSpan" id="kobo.2560.1">and Google:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2561.1">Amazon EKS:</span></span><ul><li><a href="https://docs.aws.amazon.com/eks/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.2562.1">https://docs.aws.amazon.com/eks/index.html</span></span></a></li><li><a href="https://docs.aws.amazon.com/eks/latest/userguide/sample-deployment.html"><span class="No-Break"><span class="koboSpan" id="kobo.2563.1">https://docs.aws.amazon.com/eks/latest/userguide/sample-deployment.html</span></span></a></li></ul></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2564.1">AKS:</span></span><ul><li><a href="https://azure.microsoft.com/en-us/services/kubernetes-service/"><span class="No-Break"><span class="koboSpan" id="kobo.2565.1">https://azure.microsoft.com/en-us/services/kubernetes-service/</span></span></a></li><li><a href="https://learn.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster?tabs=azure-cli"><span class="No-Break"><span class="koboSpan" id="kobo.2566.1">https://learn.microsoft.com/en-us/azure/aks/tutorial-kubernetes-deploy-cluster?tabs=azure-cli</span></span></a></li><li><a href="https://learn.microsoft.com/en-us/azure/aks/learn/quick-kubernetes-deploy-portal?tabs=azure-cli"><span class="No-Break"><span class="koboSpan" id="kobo.2567.1">https://learn.microsoft.com/en-us/azure/aks/learn/quick-kubernetes-deploy-portal?tabs=azure-cli</span></span></a></li></ul></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2568.1">GKE:</span></span><ul><li><a href="https://cloud.google.com/kubernetes-engine"><span class="No-Break"><span class="koboSpan" id="kobo.2569.1">https://cloud.google.com/kubernetes-engine</span></span></a></li><li><a href="https://cloud.google.com/build/docs/deploying-builds/deploy-gke"><span class="No-Break"><span class="koboSpan" id="kobo.2570.1">https://cloud.google.com/build/docs/deploying-builds/deploy-gke</span></span></a></li><li><a href="https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster"><span class="No-Break"><span class="koboSpan" id="kobo.2571.1">https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster</span></span></a></li></ul></li>
</ul>
</div>
</body></html>