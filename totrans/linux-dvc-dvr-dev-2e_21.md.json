["```\n#include <linux/input.h>\n```", "```\nstruct input_dev {\n  const char *name;\n  const char *phys;\n  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];\n  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];\n  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];\n  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];\n  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];\n  unsigned int repeat_key;\n  int rep[REP_CNT];\n  struct input_absinfo *absinfo;\n  unsigned long key[BITS_TO_LONGS(KEY_CNT)];\n  int (*open)(struct input_dev *dev);\n  void (*close)(struct input_dev *dev);\n  unsigned int users;\n  struct device dev;\n  unsigned int num_vals;\n  unsigned int max_vals;\n  struct input_value *vals;\n  bool devres_managed;\n};\n```", "```\n            set_bit(EV_KEY, my_input_dev->evbit);\n            set_bit(EV_REL, my_input_dev->evbit);\n        ```", "```\n    void input_set_abs_params(struct input_dev *dev,\n                           unsigned int axis, int min,\n                           int max, int fuzz, int flat)\n    ```", "```\n    #define ABSMAX_ACC_VAL      0x01FF\n    #define ABSMIN_ACC_VAL      -(ABSMAX_ACC_VAL)\n    [...]\n    set_bit(EV_ABS, idev->evbit);\n    input_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL,\n                         ABSMAX_ACC_VAL, 0, 0);\n    input_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL,\n                         ABSMAX_ACC_VAL, 0, 0);\n    input_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL,\n                         ABSMAX_ACC_VAL, 0, 0);\n    ```", "```\nstruct input_dev *input_allocate_device(void)\nstruct input_dev *devm_input_allocate_device(\n                                       struct device *dev)\nvoid input_free_device(struct input_dev *dev)\nint input_register_device(struct input_dev *dev)\nvoid input_unregister_device(struct input_dev *dev)\n```", "```\nstruct input_dev *idev;\nint error;\n/*\n * such allocation will take care of memory freeing and\n * device unregistering\n */\nidev = devm_input_allocate_device(&client->dev);\nif (!idev)\n    return -ENOMEM;\nidev->name = BMA150_DRIVER;\nidev->phys = BMA150_DRIVER \"/input0\";\nidev->id.bustype = BUS_I2C;\nidev->dev.parent = &client->dev;\nset_bit(EV_ABS, idev->evbit);\ninput_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL,\n                     ABSMAX_ACC_VAL, 0, 0);\ninput_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL,\n                     ABSMAX_ACC_VAL, 0, 0);\ninput_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL,\n                     ABSMAX_ACC_VAL, 0, 0);\nerror = input_register_device(idev);\nif (error)\n    return error;\nerror = devm_request_threaded_irq(&client->dev,\n            client->irq,\n            NULL, my_irq_thread,\n            IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n            BMA150_DRIVER, NULL);\nif (error) {\n    dev_err(&client->dev, \"irq request failed %d, \n           error %d\\n\", client->irq, error);\n    return error;\n}\nreturn 0;\n```", "```\nstruct input_polled_dev {\n    void *private;\n    void (*open)(struct input_polled_dev *dev);\n    void (*close)(struct input_polled_dev *dev);\n    void (*poll)(struct input_polled_dev *dev);\n    unsigned int poll_interval; /* msec */\n    unsigned int poll_interval_max; /* msec */\n    unsigned int poll_interval_min; /* msec */\n\n    struct input_dev *input;\n    bool devres_managed;\n};\n```", "```\nstruct input_polled_dev\n     *devm_input_allocate_polled_device(\n                                  struct device *dev)\nstruct input_polled_dev *input_allocate_polled_device(void)\nvoid input_free_polled_device(struct \n                               input_polled_dev *dev)\n```", "```\nint input_register_polled_device(\n                        struct input_polled_dev *dev)\nvoid  input_unregister_polled_device(\n                        struct input_polled_dev *dev)\n```", "```\nstruct my_struct {\n    struct input_pulled_dev *polldev;\n    struct gpio_desc *gpio_btn;\n    [...]\n}\n```", "```\nstatic int button_probe(struct platform_device *pdev)\n{\n    struct my_struct *ms;\n    struct input_dev *input_dev;\n    int error;\n    struct device *dev = &pdev->dev;\n    ms = devm_kzalloc(dev, sizeof(*ms), GFP_KERNEL);\n    if (!ms)\n        return -ENOMEM;\n    ms->polldev = devm_input_allocate_polled_device(dev);\n    if (!ms->polldev)\n        return -ENOMEM;\n    /* This gpio is not mapped to IRQ */\n    ms->gpio_btn = devm_gpiod_get(dev, \"my-btn\", GPIOD_IN);\n    ms->polldev->private = ms;\n    ms->polldev->poll = my_btn_poll;\n    ms->polldev->poll_interval = 200;/* Poll every 200ms */\n    ms->polldev->open = my_btn_open;\n     /* Initializing the underlying input_dev fields */\n    input_dev = ms->poll_dev->input;\n    input_dev->name = \"System Reset Btn\";\n    /* The gpio belongs to an expander sitting on I2C */\n    input_dev->id.bustype = BUS_I2C; \n    input_dev->dev.parent = dev;\n    /* Declare the events generated by this driver */\n    set_bit(EV_KEY, input_dev->evbit);\n    set_bit(BTN_0, input_dev->keybit); /* buttons */\n    retval = input_register_polled_device(ms->poll_dev);\n    if (retval) {\n        dev_err(dev, \"Failed to register input device\\n\");\n        return retval;  \n    }\n    return 0;\n}\n```", "```\nstatic void my_btn_open(struct input_polled_dev *poll_dev)\n{\n    struct my_strut *ms = poll_dev->private;\n    dev_dbg(&ms->poll_dev->input->dev, \"reset open()\\n\");\n}\n```", "```\nif(client->irq > 0){\n    /* Use generic input device */\n} else {\n    /* Use polled device */\n}\n```", "```\nvoid input_report_abs(struct input_dev *dev,\n                      unsigned int code, int value)\nvoid input_report_key(struct input_dev *dev,\n                      unsigned int code, int value)\nvoid input_report_rel(struct input_dev *dev,\n                      unsigned int code, int value)\n```", "```\nvoid input_sync(struct input_dev *dev)\n```", "```\nstatic void threaded_report_xyz(struct bma150_data *bma150)\n{\n  u8 data[BMA150_XYZ_DATA_SIZE];\n  s16 x, y, z;\n  s32 ret;\n  ret = i2c_smbus_read_i2c_block_data(bma150->client,\n                       BMA150_ACC_X_LSB_REG,\n                       BMA150_XYZ_DATA_SIZE, data);\n  if (ret != BMA150_XYZ_DATA_SIZE)\n    return;\n  x = ((0xc0 & data[0]) >> 6) | (data[1] << 2);\n  y = ((0xc0 & data[2]) >> 6) | (data[3] << 2);\n  z = ((0xc0 & data[4]) >> 6) | (data[5] << 2);\n  /* sign extension */\n  x = (s16) (x << 6) >> 6;\n  y = (s16) (y << 6) >> 6;\n  z = (s16) (z << 6) >> 6;\n  input_report_abs(bma150->input, ABS_X, x);\n  input_report_abs(bma150->input, ABS_Y, y);\n  input_report_abs(bma150->input, ABS_Z, z);\n  /* Indicate this event is complete */\n  input_sync(bma150->input);\n}\n```", "```\nstatic void my_btn_poll(struct input_polled_dev *poll_dev)\n{\n    struct my_struct *ms = polldev->private;\n    struct i2c_client *client = mcp->client;\n\n    input_report_key(polldev->input, BTN_0,\n                     gpiod_get_value(ms->rgpio_btn) & 1);\n    input_sync(poll_dev->input);\n}\n```", "```\n# udevadm info /dev/input/event0 \nP: /devices/platform/input-button.0/input/input0/event0\nN: input/event0\nS: input/by-path/platform-input-button.0-event\nE: DEVLINKS=/dev/input/by-path/platform-input-button.0-event\nE: DEVNAME=/dev/input/event0\nE: DEVPATH=/devices/platform/input-button.0/input/input0/event0\nE: ID_INPUT=1\nE: ID_PATH=platform-input-button.0\nE: ID_PATH_TAG=platform-input-button_0\nE: MAJOR=13\nE: MINOR=64\nE: SUBSYSTEM=input\nE: USEC_INITIALIZED=74842430\n```", "```\n# evtest /dev/input/event0 \ninput device opened()\nInput driver version is 1.0.1\nInput device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0\nInput device name: \"Packt Btn\"\nSupported events:\n   Event type 0 (EV_SYN)\n   Event type 1 (EV_KEY)\n      Event code 256 (BTN_0)\n```", "```\njma@labcsmart-sqy:~$ sudo evtest /dev/input/event4\nInput driver version is 1.0.1\nInput device ID: bus 0x3 vendor 0x12d1 product 0x3a07 version 0x111\nInput device name: \"Synaptics HUAWEI USB-C HEADSET\"\nSupported events:\n  Event type 0 (EV_SYN)\n  Event type 1 (EV_KEY)\n    Event code 114 (KEY_VOLUMEDOWN)\n    Event code 115 (KEY_VOLUMEUP)\n    Event code 164 (KEY_PLAYPAUSE)\n    Event code 582 (KEY_VOICECOMMAND)\n  Event type 4 (EV_MSC)\n    Event code 4 (MSC_SCAN)\nProperties:\nTesting ... (interrupt to exit)\nEvent: time 1640231369.347093, type 4 (EV_MSC), code 4 (MSC_SCAN), value c00e9\nEvent: time 1640231369.347093, type 1 (EV_KEY), code 115 (KEY_VOLUMEUP), value 1\nEvent: time 1640231369.347093, -------------- SYN_REPORT ------------\nEvent: time 1640231369.487017, type 4 (EV_MSC), code 4 (MSC_SCAN), value c00e9\nEvent: time 1640231369.487017, type 1 (EV_KEY), code 115 (KEY_VOLUMEUP), value 0\nEvent: time 1640231369.487017, -------------- SYN_REPORT ------------\n```", "```\nstruct input_event {\n  struct timeval time;\n  __u16 type;\n  __u16 code;\n  __s32 value;\n}\n```", "```\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <linux/input.h>\n#include <sys/select.h>\n```", "```\n#define INPUT_DEVICE \"/dev/input/event0\"\nint main(int argc, char **argv)\n{   \n    int fd, ret;\n    struct input_event event;\n    ssize_t bytesRead;\n    fd_set readfds;\n```", "```\n    fd = open(INPUT_DEVICE, O_RDONLY);\n    if(fd < 0){\n        fprintf(stderr,\n             \"Error opening %s for reading\", INPUT_DEVICE);\n        exit(EXIT_FAILURE);\n    }\n```", "```\n    while(1){ \n        FD_ZERO(&readfds);\n        FD_SET(fd, &readfds);\n        ret = select(fd + 1, &readfds, NULL, NULL, NULL);\n        if (ret == -1) {\n            fprintf(stderr,\n                   \"select call on %s: an error ocurred\",\n                    INPUT_DEVICE);\n            break;\n        }\n        else if (!ret) { /* If we used timeout */\n            fprintf(stderr,\n                    \"select on %s: TIMEOUT\", INPUT_DEVICE);\n            break;\n        }\n```", "```\n        /* File descriptor is now ready */\n        if (FD_ISSET(fd, &readfds)) {\n            bytesRead = read(fd, &event,\n                             sizeof(struct input_event));\n            if(bytesRead == -1)\n                /* Process read input error*/\n                [...]\n            if(bytesRead != sizeof(struct input_event))\n                /* Read value is not an input event */\n                [...] /* handle this error */\n```", "```\n            /* We could have done a switch/case if we had\n             * many codes to look for */\n            if (event.code == BTN_0) {\n                /* it concerns our button */\n                if (event.value == 0) {\n                    /* Process keyRelease if need be */\n                    [...]\n                }\n                else if(event.value == 1){\n                    /* Process KeyPress */\n                    [...]\n                }\n            }\n        }\n    }\n    close(fd);\n    return EXIT_SUCCESS;\n}\n```", "```\n# cat /sys/kernel/debug/gpio  | grep button\n gpio-195 (gpio-btn         ) in  hi    \n# cat /sys/kernel/debug/gpio  | grep button\n gpio-195 (gpio-btn         ) in  lo\n```", "```\n# cat /proc/interrupts | grep packt\n160:      0      0      0      0  gpio-mxc   0  packt-input-button\n```"]