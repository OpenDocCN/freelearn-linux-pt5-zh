<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor164"/>8</h1>
<h1 id="_idParaDest-149"><a id="_idTextAnchor165"/>Linux Shell Scripting</h1>
<p>Knowing how to use the basics of Linux shell programming and the <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) is essential for a modern-day Linux professional.</p>
<p>In this chapter, you will learn how to use the Linux shell’s programming capabilities to automate different tasks in Linux. You will learn about the structure of a basic Linux shell script and how it is organized and executed. We’ll explore most of the commands already available to you from the previous chapters, especially the ones for working with files and directories and input and output redirection. Along the way, we’ll introduce you to writing scripts, the structure and complexity of shell programming, and how to use specialized tools such as <code>sed</code> and <code>gawk</code>. We hope that by the end of this chapter, you’ll be comfortable using scripts in your day-to-day workflow and be ready for future, more advanced explorations.</p>
<p>We’re going to cover the following main topics:</p>
<ul>
<li>Introducing shell features</li>
<li>The structure of a shell script</li>
<li>Decisions, loops, variables, arrays, and functions</li>
<li>Using <code>sed</code> and (<code>g</code>)<code>awk</code></li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor166"/>Technical requirements</h1>
<p>This chapter requires a working installation of a standard Linux distribution, on either server, desktop, PC, or <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>). Our examples and case studies will use mainly Ubuntu/Debian and RHEL/Fedora platforms, but the commands and examples that will be explored are equally suitable for other Linux distributions, such as openSUSE/SLE.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor167"/>Exploring the Linux shell</h1>
<p>Back in <a href="B19682_02.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, <em class="italic">The Linux Shell and Filesystem</em>, we introduced you to the shell by exploring the available virtual consoles, command types, and the filesystem. This gave you a fair foundation for what we are about<a id="_idIndexMarker1204"/> to explore in this chapter. By now, with everything we have been showing you in this book, you are already well versed in using the command line; you know some of the most common and useful commands available in Linux as we explored file operations, package, user, and disk management, all the way up to network administration. All this knowledge will eventually be put to use in this chapter, where we will explore advanced shell features, shell variables, regular expressions, and how to take advantage of the powerful programming and automation features of the Bash shell.</p>
<p>In the next section, we will begin discovering the advanced features of the shell.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor168"/>Bash shell features</h2>
<p>The shell not only<a id="_idIndexMarker1205"/> runs commands but also has many more features that make a system administrator’s life more comfortable while at the command line. Some of these<a id="_idIndexMarker1206"/> features include the use of <code>PATH</code> and aliases.</p>
<p>Before we proceed, let’s dig into a little history about the standards the shell is based on. Back in the day, when UNIX emerged as an operating system, the need for a standard to oversee different <a id="_idIndexMarker1207"/>variants appeared. Thus, the <strong class="bold">Institute of Electrical and Electronics Engineers</strong> (<strong class="bold">IEEE</strong>) created the <strong class="bold">Portable Operating System Interface</strong> (<strong class="bold">POSIX</strong>) as a family of different standards that were<a id="_idIndexMarker1208"/> meant to assure compatibility between operating systems. Therefore, UNIX and Linux, as well as macOS (based on Darwin, the kernel of macOS derived from UNIX), AIX, HP-UX, and Oracle Solaris, are POSIX compliant. POSIX has different standards for the C language API, file format definitions, directory structures, environment variables definitions, locale specifications, character sets, and regular expressions.</p>
<p>With this short history lesson under our belts, let’s proceed. In the next section, we will show you how to use shell wildcards and metacharacters.</p>
<h3>Wildcards and metacharacters</h3>
<p>In Linux, <strong class="bold">wildcards</strong> are used to match<a id="_idIndexMarker1209"/> filenames. There are three main types of<a id="_idIndexMarker1210"/> wildcards:</p>
<ul>
<li><code>*</code>): This is used to<a id="_idIndexMarker1211"/> match any string of none or more characters</li>
<li><code>?</code>): This is used to match a<a id="_idIndexMarker1212"/> single character</li>
<li><code>[ ]</code>): This is used to match<a id="_idIndexMarker1213"/> any of the characters inside brackets</li>
</ul>
<p><strong class="bold">Metacharacters</strong> are special characters<a id="_idIndexMarker1214"/> that are used in Linux and any Unix-based system. These<a id="_idIndexMarker1215"/> metacharacters are as follows:</p>
<div><div><img alt="Figure 8.1 – Metacharacter list" src="img/B19682_08_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Metacharacter list</p>
<p>Let’s look at two examples that use metacharacters for command substitution. We use the output of one command inside another command. This can be done in two ways, as shown in the following figure:</p>
<div><div><img alt="Figure 8.2 – Example of command execution and substitution" src="img/B19682_08_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Example of command execution and substitution</p>
<p>The purpose of the preceding example is to show you how command substitution works in the shell, but perhaps we should explain further what the commands used do. We used two commands: <code>echo</code> and <code>date</code>. We used the output of the <code>date</code> command inside the output of the <code>echo</code> command. The <code>echo</code> command is one of the simplest commands in Linux as it prints the message between the quotes to the standard output. In our case, the message also consists of the <code>date</code> command, which outputs the current date of the system, in the format shown.</p>
<p>You can also combine two or more commands, and to do this in Linux, we use the pipe. The pipe sends the output of the first command that was used as the input for the second command, and so forth, depending on how many pipes you use.</p>
<p>In the following example, we’re using the <code>ls -l /etc</code> command to do a long listing of the contents of the <code>/etc</code> directory; we <a id="_idIndexMarker1216"/>will pipe this to the <code>less</code> command. Use it as shown in the following code:</p>
<pre class="console">
ls -l /etc | less</pre> <p>The <code>less</code> command will <a id="_idIndexMarker1217"/>show one display at a time, allowing you to see all the contents. You can use the arrow keys or the page up and page down keys to navigate through the <a id="_idIndexMarker1218"/>output and see all the contents of the <code>/</code><code>etc</code> directory.</p>
<p>The pipe and command substitution will be very useful, especially when you’re working with complex commands or when scripting, as you will see later in this chapter when you learn how to create and use scripts.</p>
<p>Now, let’s execute some commands in a sequence. After that, we will use metacharacters to group commands and redirect the output to a file. All this is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.3 – Example of command sequence execution" src="img/B19682_08_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Example of command sequence execution</p>
<p>As you can see in the preceding output, the two commands that were executed on the first line can easily be grouped using brackets, and their output can be redirected to a file.</p>
<p>We used three types of metacharacters – the <em class="italic">command execution sequence</em> (<code>;</code>), the brackets for <em class="italic">grouping commands</em> in the execution sequence, and the <em class="italic">output redirection</em> (<code>&gt;</code>) to redirect the output to a file. The file did not exist initially as it was created only when the command was executed. The last command we used was the <code>cat</code> command, which <em class="italic">concatenates</em> the contents of the newly created file.</p>
<p>The first two commands that were used were <code>who</code>, which prints information about the currently logged-in users to the standard <a id="_idIndexMarker1219"/>output, and <code>pwd</code>, which prints the present working directory as the location<a id="_idIndexMarker1220"/> we are in inside the filesystem. In the following section, we will show you how to use brace expansion with the shell.</p>
<h3>Brace expansion</h3>
<p>Curly brackets can also be used to<a id="_idIndexMarker1221"/> expand the arguments of a command. <strong class="bold">Braces</strong> are not<a id="_idIndexMarker1222"/> just limited to filenames, unlike a wildcard. They work with any type of string. Inside these braces, you can use a single string, a sequence, or several strings separated by commas.</p>
<p>In this section, we will show you some examples of using this type of expansion. First, we will use <code>report</code> and <code>new-report</code> inside our present working directory and we want to delete them both at once. We can use the following command:</p>
<pre class="console">
rm {report,new-report}</pre> <p>To create multiple files (five of them, for example) that share parts of their name, as in <code>file1</code>, <code>file2</code>, … <code>filen</code>, we can use the following command:</p>
<pre class="console">
touch file{1..5}</pre> <p>The following screenshot shows the output of both these commands:</p>
<div><div><img alt="Figure 8.4 – Examples of using brace expansion" src="img/B19682_08_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Examples of using brace expansion</p>
<p class="callout-heading">Important note</p>
<p class="callout">Brace expansion is a powerful tool that adds flexibility and power to any system administrator’s workflow. They will prove very useful when learning how to script, for example.</p>
<p>Now that we’ve created those<a id="_idIndexMarker1224"/> files, it should be really easy for you to figure out how to use brace expansion to delete multiple files at once. Type the following command into<a id="_idIndexMarker1225"/> your console and see what happens:</p>
<pre class="console">
rm file{1..5}</pre> <p>It will delete all five files we created previously. Use the <code>ls</code> command to see the contents of the present working directory.</p>
<p>In the next section, we will talk about shell command aliases, what they are, and how to use them.</p>
<h3>The shell’s aliases</h3>
<p>The Linux shell supports <code>ll</code> that is shorthand for <code>ls -alF</code>. You can define your own aliases too. You can make them temporary or permanent, similar to variables. In the following example, we changed the alias for the <code>ll</code> command:</p>
<div><div><img alt="Figure 8.5 – Changing the alias of a command" src="img/B19682_08_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Changing the alias of a command</p>
<p>This modification is only temporary, and it will revert to the default version after reboot or shell restart. If you want to make it permanent, you should edit the <code>~/.bashrc</code> file and add the aliases you created previously inside the file. To do this, open the file with your preferred text editor and add the lines you used in the Terminal to the file. Save the file and execute it. Also, a better practice would be to add those lines to a new file called <code>.bash_aliases</code>. You can view the default contents of <code>.bashrc</code> for more information on how to use aliases.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The <code>.bashrc</code> file is a hidden script file that consists of different Terminal session configurations. Also, the file can contain different functions that can help the user overcome repetitive tasks. It is automatically executed when the user logs in, but it can also be manually executed by using the <code>source .</code><code>bashrc</code> command.</p>
<p>In the next section, we will show<a id="_idIndexMarker1228"/> you what shell variables are and how to use them.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor169"/>Bash shell variables</h2>
<p>The Bash shell uses different types of variables, in the same way you would use them in any programming<a id="_idIndexMarker1229"/> language. The Bash shell has some built-in variables and indirect variables and offers the possibility to define your own variables as well.</p>
<p>Linux has two<a id="_idIndexMarker1230"/> major types of shell variables: <strong class="bold">global</strong> and <strong class="bold">local variables</strong>. They are generally identical for every<a id="_idIndexMarker1231"/> Linux distribution out<a id="_idIndexMarker1232"/> there, with some exceptions. You will need to consult your distribution’s documentation for any specific modifications to the environment variables.</p>
<p>We will walk you through the most widely used variables in Linux, starting with the built-in ones.</p>
<h3>Built-in shell variables</h3>
<p>Here is a short list of some of<a id="_idIndexMarker1233"/> the standard built-in variables:</p>
<ul>
<li><code>HOME</code>: The user’s home directory (for example, <code>/home/packt</code>)</li>
<li><code>LOGNAME</code>: The user’s login name (for example, <code>packt</code>)</li>
<li><code>PWD</code>: The shell’s current working directory</li>
<li><code>OLDPWD</code>: The shell’s previous working directory</li>
<li><code>PATH</code>: The shell’s search path (list of directories separated by colons)</li>
<li><code>SHELL</code>: The path to the shell</li>
<li><code>USER</code>: The user’s login name</li>
<li><code>TERM</code>: The type of the Terminal</li>
</ul>
<p>To call a variable while in the shell, all you have to do is place a dollar sign, <code>$</code>, in front of the variable’s name. Here is a <a id="_idIndexMarker1234"/>short example that shows how to use the variables that we just listed:</p>
<div><div><img alt="Figure 8.6 – Variable calling from the shell" src="img/B19682_08_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Variable calling from the shell</p>
<p>You can also assign your own shell variables, as in the following example. Here, we’re assigning the <code>sysadmin</code> string to a new variable called <code>MYVAR</code> and then printing it to standard output:</p>
<pre class="console">
MYVAR=sysadmin; echo $MYVAR</pre> <p>The variables listed at the beginning of this section are just a part of all the variables available by default inside the shell. To see all the shell variables, use the <code>printenv</code> command. If the list is too long, you can redirect it to a file. In the following example, your variables list is inside the <code>shell_variables</code> file, and you can see it by concatenating or by editing inside a text editor such as Vim:</p>
<pre class="console">
printenv &gt; ~/shell_variables</pre> <p>Here, we use the tilde symbol (<code>~</code>) to specify the logged-in user’s home directory. The shell’s variables are only available inside the shell. If you want some variables to be known to other programs that are run by the shell, you must export them by using the <code>export</code> command. Once a variable is<a id="_idIndexMarker1235"/> exported from the shell, it is known as an <strong class="bold">environment variable</strong>.</p>
<h3>The shell’s search path</h3>
<p>The <code>PATH</code> variable is an essential one in Linux. It helps the shell know where all the programs are located. When you enter a<a id="_idIndexMarker1236"/> command into your Bash shell, it first has to search for that command through the Linux filesystem. Some directories are already listed inside the <code>PATH</code> variable, but you can also add new ones. Your addition can be temporary or permanent, depending on how you do it. To make a directory’s path <a id="_idIndexMarker1237"/>available temporarily, simply add it to the <code>PATH</code> variable. In the following example, we’re adding the <code>/home/packt</code> directory to <code>PATH</code>:</p>
<div><div><img alt="Figure 8.7 – Adding a new location to PATH" src="img/B19682_08_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Adding a new location to PATH</p>
<p>To make any changes permanent, we must modify the <code>PATH</code> variable inside a file called <code>~/.bash_profile</code> or <code>~/.bashrc</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Some distributions, such as openSUSE, add an extra <code>bin</code> directory inside the user’s home directory. This is a place where you can put files that you want the shell to execute – for example, script files.</p>
<p>The shell’s <code>$PATH</code> variable is important, especially when using scripts, as you will preferably have to create scripts inside a directory that is known by the shell. In the next section, we will show you how to create your first Bash scripts.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor170"/>Basics of shell scripting</h1>
<p>We have already covered important aspects of the Linux command line, shell variables, wildcards, and <a id="_idIndexMarker1238"/>metacharacters. Now, we will start exploring what scripts are, how to create them, and how to use them in a Linux CLI. We will not use the graphical user<a id="_idIndexMarker1239"/> interface, only the CLI, which we primarily used in our previous chapters. Let’s start with some basic, but important, concepts about shell scripting.</p>
<p>First, let’s learn what a <strong class="bold">script</strong> is. If we were to check the meaning of the term in a dictionary, the answer would be that <a id="_idIndexMarker1240"/>a script is a series of instructions that are executed by a computer, mainly to automate a specific task. Instructions can easily be assimilated as commands too. Thus, a series of commands executed together by the shell can be considered a script. This is a very basic script, but it is a script. Let’s look at how we can create a script file.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor171"/>Creating a shell script file</h2>
<p>The most appropriate way to write <a id="_idIndexMarker1241"/>scripts is to create them in the form of a file, called a <code>.sh</code> extension<a id="_idIndexMarker1242"/> for clarity. However, this is not obligatory, because in Linux, files don’t use extensions, unlike in Windows. The distinctive characteristic that makes a file considered a script is the <em class="italic">very first line</em> of text inside that file. In the case of a Bash shell script, this line is in the following format:</p>
<pre class="source-code">
#!/bin/bash</pre> <p>When the file is opened and executed, the first line tells the shell’s interpreter that it is dealing with a script file that, in our case, will be run by the Bash shell. If you are using a different shell, this first line will point to it. The use of the hashtag (<code>#</code>) inside a shell script file denotes a commented line, except for this very first line, where it is used, combined with the exclamation mark (<code>!</code>), to point<a id="_idIndexMarker1243"/> to the shell’s interpreter. The <code>#!</code> combination is also called the <strong class="bold">shebang</strong>.</p>
<p>Let’s create a basic script file. We will use the following code:</p>
<pre class="source-code">
#!/bin/bash
whoami
who
date
uptime</pre> <p>Here, we used four different commands in our first, basic script. We used a separate line for each command, but there is another way to write it: by putting all commands on the same line and using semicolons to separate them. However, for clarity, it is useful to use different lines.</p>
<p>Now that we have our first script, let’s run it. We created the script file inside our home directory under the name <code>basic-script.sh</code>. Let’s try and run it by simply invoking its name at the command line:</p>
<pre class="console">
$ basic-script.sh</pre> <p>We will be prompted with <a id="_idIndexMarker1244"/>an error, as shown in the following screenshot:</p>
<div><div><img alt="Figure 8.8 – Error upon running the new script" src="img/B19682_08_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Error upon running the new script</p>
<p>You might be wondering why we get this error. It is because the shell does not know about your script. It cannot find it <a id="_idIndexMarker1245"/>inside its <code>PATH</code> variable. As you might remember from the previous section, <code>PATH</code> is a variable that the shell uses to find the location of specific files to run. To overcome this error, we have two options:</p>
<ul>
<li>We can add the directory in which our script resides to the shell’s path</li>
<li>We can use a relative or absolute path when we invoke the script at the command line</li>
</ul>
<p>We will use the second method as it is more convenient. However, you can use the first method as a good practice exercise and try to add your directory’s location to the shell’s <code>PATH</code> variable. Let’s invoke the script file with its location:</p>
<pre class="console">
$ ./basic-script.sh</pre> <p>We will get another error, this time a different one, saying <code>Permission denied</code>. This is because we do not have permission to execute the file. When we created the file inside our Ubuntu machine, it only got read and write permissions for the file’s owner and its group because of the default <code>umask</code> value. To change that, we will need to make the file executable by using the following command:</p>
<pre class="console">
$ chmod u+x basic-script.sh</pre> <p>Once we’ve set the executable permissions on the file, we can run it again, and this time, the script will be executed. The output will show that every command inside our script was executed:</p>
<div><div><img alt="Figure 8.9 – Running an executable script file" src="img/B19682_08_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Running an executable script file</p>
<p>As shown in the previous <a id="_idIndexMarker1246"/>screenshot, the script was executed, and the output showed the result of each command inside. On the first line, we have the <a id="_idIndexMarker1247"/>username (the output of the <code>whoami</code> command), on the second line, we have information about the logged-in users (the output of the <code>who</code> command), on the third line, we have information about the current date (the output of the <code>date</code> command), and on the last line, we have information about the current session (the output of the <code>uptime</code> command).</p>
<p class="callout-heading">Important note</p>
<p class="callout">As a general rule, when writing scripts, we advise you to <em class="italic">use as many comments</em> as possible to detail each variable and parameter you choose. This is considered a good programming practice, which will make your code writing more enjoyable and relevant. Documenting your coding steps will make your scripts easier to read at a later time, both by yourself and by anyone else who might come across your code. We don’t use many comments in the examples used in this book, but this is due to constraints regarding page count. Nevertheless, we encourage you to use them.</p>
<p>With that, you know how to create a shell script file and how to execute it. Let’s proceed to more advanced topics now. In the next section, we will show you how to use variables in your scripts.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor172"/>Variables in shell scripts</h2>
<p>We introduced you to<a id="_idIndexMarker1248"/> variables at the beginning of this chapter. Now, it is time to learn how to use them inside a script. To recap, let’s see what kind of variables are<a id="_idIndexMarker1249"/> used in Linux. We have <code>printenv</code> and/or <code>set</code> commands. We listed some of the most commonly used variables in the <em class="italic">Built-in shell variables</em> section earlier in this chapter.</p>
<h3>Understanding naming conventions</h3>
<p>Inside the Linux shell, the system’s environment variables use only uppercase letters. Thus, the relevant naming considerations <a id="_idIndexMarker1252"/>should be applied when creating user-specified variables. In this regard, there is not one single naming convention that applies. But you should take into consideration that the names of variables are <em class="italic">case-sensitive</em> and should be up to <em class="italic">20 characters</em> in length. The way to assign a value to a variable is by using the equals (<code>=</code>) sign.</p>
<p>If you plan on using only uppercase letters in the names of your variables, you should consider the disastrous effects this might have, considering that the environment variables only use uppercase letters. We would advise you to consider one of the following rules when creating variable names inside your shell:</p>
<ul>
<li>Use only lowercase letters, underscores, and numbers</li>
<li>Capitalize the first letter of a word in the variable name</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">When considering name length, try not to use very long names; instead, use succinct and relevant names or abbreviations. This will make your script easier to read and understand.</p>
<p>Now, let’s learn how to define and use our first variables inside a shell. We will explore this in the next section.</p>
<h3>Defining and using variables</h3>
<p>Let’s create a new file called <code>user-script.sh</code> that will show relevant user information by using environment<a id="_idIndexMarker1253"/> variables. After we create the file and enter the relevant code, we will make it executable and then we will run it. The following are the relevant commands:</p>
<div><div><img alt="Figure 8.10 – Using environment variables in a script" src="img/B19682_08_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Using environment variables in a script</p>
<p>In the preceding figure, we used two different ways to show information with the <code>echo</code> command. When we used double quotes to show information, the environment variable was used inside the<a id="_idIndexMarker1254"/> quoted string, and its value was displayed in the output. Keep in mind that when using single quotes, the value of the variable will not be passed through to the shell’s interpreter. We used four different environment variables to show information about the user. Those variables were <code>UID</code>, <code>USER</code>, <code>HOME</code>, and <code>BASH</code>. This is a very basic and straightforward way to use shell variables inside scripts.</p>
<p>You can also use your own variables, not just the ones that are provided by the shell. A very useful feature of the shell’s interpreter is that it can automatically determine the data type a variable is using. You should also know that the values of variables defined inside a shell script are only active so long as the shell is running, and they will be lost afterward. Let’s create a new shell script and use our own variables this time. The following is the output:</p>
<div><div><img alt="Figure 8.11 – A basic script using user-defined variables" src="img/B19682_08_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – A basic script using user-defined variables</p>
<p>Here, we created a file called <code>user-variables.sh</code> and defined two variables, one called <code>value</code>, which we gave a value of <code>25</code>, and another variable called <code>product</code>, with a value of <code>Shirt</code>. When we called the variables inside the <code>echo</code> command, we used the same callout sign as for environment variables.</p>
<p>Now that you know how to <a id="_idIndexMarker1255"/>name, define, and use a variable, let’s continue to more advanced topics. In the next section, we will show you how to use mathematical expressions inside your shell scripts.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor173"/>Using mathematical expressions in shell scripts</h2>
<p>The shell is a programming language, so it has <a id="_idIndexMarker1256"/>built-in features to work with numbers. The Bash shell provides the <code>expr</code> command, which is used for different mathematical operations. To learn about all the operations that are supported, please visit the internal manual page for the <code>expr</code> command, as we will not provide them fully here:</p>
<pre class="console">
man expr</pre> <p>However, we will show you how to use some of the operations that the <code>expr</code> command provides. Keep in mind that, as the manual says, you will need to escape (by using the backslash character, <code>\</code>) some of the characters used by the <code>expr</code> command, as they will be misinterpreted by the shell. Let’s create a new script file and do some basic mathematical operations. Our new file is called <code>math.sh</code> and can be created using the following code:</p>
<div><div><img alt="Figure 8.12 – Using the expr command inside scripts" src="img/B19682_08_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Using the expr command inside scripts</p>
<p>Besides the <code>expr</code> command, we can also use square brackets as a much simpler variant for mathematical operations. Let’s modify the preceding script and replace the <code>expr</code> command:</p>
<div><div><img alt="Figure 8.13 – Using square brackets for math operations" src="img/B19682_08_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Using square brackets for math operations</p>
<p>As shown in the previous example, we use integer values. You can try and use a floating-point value for the <code>vat</code> variable, for<a id="_idIndexMarker1257"/> example, and you will see that an error will be displayed when running the script. This is because the shell only supports integer arithmetic operations. There are workarounds to overcome this limitation, and the most feasible is by using the Bash calculator, or the <code>bc</code> command.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you want to have full support for floating-point operations inside your shell, you might want to consider using the <strong class="bold">Z shell</strong> (<strong class="bold">Zsh</strong>). It is <a id="_idIndexMarker1258"/>installed by default in some Linux distributions (Manjaro and Kali Linux) and on macOS. You can also install it in your distribution if you like.</p>
<p>Let’s see how we can use the <code>bc</code> command inside our <code>math.sh</code> script. We will change the code as follows:</p>
<div><div><img alt="Figure 8.14 – Using the bc command for floating-point operations" src="img/B19682_08_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Using the bc command for floating-point operations</p>
<p>In the preceding example, we assigned a floating-point value to the <code>vat</code> variable and used the <code>bc</code> command to calculate a floating-point total. We can use the <code>bc</code> command inside a variable like so:</p>
<pre class="source-code">
var=$(echo "option; expression" | bc)</pre> <p>The <code>option</code> value provides options for <code>bc</code> to use. In our case, we used a variable called <code>decs</code> (an arbitrary name we chose) to specify the number of decimals we would like to provide. The <code>expression</code> parameter specifies the operation we used, which in our case was addition. We piped the output of the <code>echo</code> command to the <code>bc</code> command and the result was assigned to the <code>var</code> variable.</p>
<p>Creating Bash shell scripts is <a id="_idIndexMarker1259"/>more than doing math operations or giving a sequence of consecutive shell commands. Sometimes, decisions need to be made inside the shell, depending on the input provided and the output expected. This is where specific programming structures intervene. We will walk you through all of them in the next section.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor174"/>Using programming structures</h1>
<p>In this section, we will show you how to use <strong class="bold">conditional</strong> and <strong class="bold">looping statements</strong>. They can prove invaluable when<a id="_idIndexMarker1260"/> creating advanced shell scripts. We will also show you how to use arrays, how input reading is used inside scripts, and how to format and print data for the output.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor175"/>Using arrays in Bash</h2>
<p>We showed you how to use<a id="_idIndexMarker1261"/> variables in previous sections. Now, it is time to step up our game and show you how to make use of <code>filename1</code>, <code>filename2</code>, <code>filename3</code> … <code>filenameN</code>, we can create an array that will hold all the filenames. If you know other programming languages, arrays may already be familiar to you. But if you don’t know any other programming languages, fear not, as Bash has a facile way of using arrays.</p>
<p>Let’s start with an easy example. Let’s say we have to work with different usernames. Instead of using different variables for<a id="_idIndexMarker1263"/> each username, we can use an <strong class="bold">indexed array</strong>:</p>
<pre class="source-code">
usernames=("paul" "janet" "mike" "john" "anna" "martha")</pre> <p>The elements inside an array start from index number <code>0</code> (zero). This is important to remember when we need to access the contents of the array. If we would like to access the third element from the usernames array (the <code>"mike"</code> string), we must use the following code:</p>
<pre class="console">
echo ${usernames[2]}</pre> <p>The output will be <code>mike</code> (without quotes). To print out the entire array, use the following code:</p>
<pre class="console">
echo ${usernames[*]} or echo ${usernames[@]}</pre> <p>To print out the size of the array, as in the number of elements, use the following code:</p>
<pre class="console">
echo ${#usernames[@]} or echo ${#usernames[*]}</pre> <p>In our case, we have six <a id="_idIndexMarker1264"/>elements inside, and the output will be <code>6</code>.</p>
<p>Let’s say we need to add a new username (<code>"alex"</code>) to the array. There are different ways to add it. If we just want to add it with no specified position from the beginning, we can use the following code:</p>
<pre class="source-code">
usernames+=("alex")</pre> <p>The new username will be appended at the end of the array. At this point, the array contains unordered names, and we will need to arrange them in alphabetical order. We will cover this in the <em class="italic">Using looping statements</em> section, after which we will teach you about output formatting and different conditional and looping statements.</p>
<p>Alternatively, we can add a new element (<code>"zack"</code>, for example) at a specific position inside the array (let’s say position 2) by using the following code:</p>
<pre class="source-code">
usernames[1]="zack"</pre> <p>So far, we’ve only used strings inside arrays as an example. You can also use integers for indexed arrays. The built-in command to create an array is <code>declare</code>. To create an indexed array, you can use the following command:</p>
<pre class="console">
declare -a array_name</pre> <p>You can also create associative arrays using the following command:</p>
<pre class="console">
declare -A array_name</pre> <p><strong class="bold">Associative arrays</strong> are based on key-value pairs of elements. The following is an example of an associative array<a id="_idIndexMarker1265"/> declaration:</p>
<pre class="console">
declare -A linux_distros=( [KDE]="openSUSE" [GNOME]="Fedora" [Xfce]="Debian" [Cinnamon]="Mint" )</pre> <p>Presented inside square brackets <a id="_idIndexMarker1266"/>are the keys that are used to map the values. Inside double quotes, we have the values. To print the values, you can use the same command you used for indexed arrays:</p>
<pre class="console">
echo ${linux_distros[@]}</pre> <p>To print the keys, use the following command:</p>
<pre class="console">
echo ${!linux_distros[@]}</pre> <p>The main difference between indexed and associative arrays is that indexed arrays are based on index value, where each element has a specific index position inside the array, whereas associative arrays use specific keys to map the values.</p>
<p>Arrays are important data structures inside Bash and we will make use of them later in this chapter when we discuss looping statements. But first, let’s learn how to read input data inside a script, and how to format output data. In the next section, we will show you how to read data from standard input.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor176"/>Reading input data</h2>
<p>By default, the shell reads the input data <a id="_idIndexMarker1267"/>from the standard input, which is the keyboard. To read from the standard input, you can use the <code>read</code> command. This command reads all input data provided until a new line is provided. This happens when you press the <em class="italic">Enter</em> key on your keyboard.</p>
<p>With the <code>read</code> command, you can provide one or more variables. If you use more variables, each word provided through standard input will be assigned to a variable. The following is an example:</p>
<div><div><img alt="Figure 8.15 – Using the read command for standard input" src="img/B19682_08_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Using the read command for standard input</p>
<p>In the preceding screenshot, we used the <code>read</code> command with four variables called <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>. When we first introduced the data, we only provided a value for the first variable, meaning that we hit <em class="italic">Enter</em> after entering the first word from the keyboard. Thus, we had only one value for <code>a</code> and no value for the others. When we used the <code>read</code> command for the second time, we provided values for every variable, thus hitting <em class="italic">Enter</em> after the word <code>Thursday</code>. This way, each <a id="_idIndexMarker1268"/>variable received a relevant value. The <code>read</code> command has several options available, but you will have to read the manual to learn about them in detail. Similar to providing values from the standard input, the <code>read</code> command can receive input from a file by using redirection. For example, if we have a file called <code>week-days</code>, we can redirect its content to the <code>read</code> command:</p>
<div><div><img alt="Figure 8.16 – Using read with file redirection" src="img/B19682_08_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Using read with file redirection</p>
<p>The <code>read</code> command is used for input reading when creating scripts. We showed you how to use the command on the command line, but we will come back to it later in this chapter when we talk about more advanced scripts. In the following section, we will introduce you to output data formats.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor177"/>Formatting output data</h2>
<p>In Linux, the standard output is<a id="_idIndexMarker1269"/> directed by default to the monitor. For this task, you will have two commands you can use. One of them is the <code>echo</code> command, which we’ve used quite extensively in this book. The other command is called <code>printf</code>, and we will cover its use in this section.</p>
<p>The <code>printf</code> command is similar to the one used in the C programming language. A quick manual search for the <code>printf</code> command will show us the form in which it should be used:</p>
<pre class="console">
printf FORMAT [ARGUMENT] …</pre> <p>All the arguments of the command are printed according to the format string provided. The format controls can have normal <a id="_idIndexMarker1270"/>characters or <strong class="bold">escape sequences</strong>, containing backslash and letters. These escape sequences are clearly presented in the available manual. Briefly, some widely used sequences are as follows:</p>
<ul>
<li><code>\</code><code>b</code>: Backspace</li>
<li><code>\</code><code>e</code>: Escape</li>
<li><code>\f</code>: Form feed</li>
<li><code>\n</code>: New line</li>
<li><code>\r</code>: Carriage return</li>
<li><code>\t</code>: Horizontal tab</li>
<li><code>\v</code>: Vertical tab</li>
</ul>
<p>When using a backslash with <code>printf</code>, it should be escaped from the shell by using double quotes or another backslash. For more details on this, please refer to the manual.</p>
<p>Besides escape sequences, the <code>printf</code> command has format specifiers. Here are some details about what some of these format specifiers represent:</p>
<ul>
<li><code>%s</code>: This is a string specifier and it’s used for basic string output</li>
<li><code>%b</code>: This is a string specifier that allows escape sequence interpretation</li>
<li><code>%d</code>: This is an integer specifier that’s used for integral values</li>
<li><code>%f</code>: This is similar to the integer specifier, but it’s used for floating-point values</li>
<li><code>%x</code>: This is used for the hexadecimal values of integers and output padding</li>
</ul>
<p>Now that you know the basics of the <code>printf</code> command, let’s look at some examples of how to use it.</p>
<p>In the following figure, we’re <a id="_idIndexMarker1271"/>using <code>printf</code> format specifiers to show you the difference between using them and not using them:</p>
<div><div><img alt="Figure 8.17 – Basic usage of the printf command" src="img/B19682_08_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Basic usage of the printf command</p>
<p>As shown here, when using the default setting, <code>printf</code> prints the string inside the double quotes but without a new line at the end. When using the <code>%s</code> format specifier, the command prints the strings provided as arguments and interprets them as characters – in our case, the strings between double quotes. Using <code>\n</code> will create a new line after each string.</p>
<p>Let’s use the <code>printf</code> command inside a script now. The following is an example of <code>printf</code> using the <code>%s</code> format specifier. Notice that we use the command using single quotes since the output is similar to when using double quotes:</p>
<div><div><img alt="Figure 8.18 – Using printf inside a script" src="img/B19682_08_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Using printf inside a script</p>
<p>The preceding figure shows a script that reads two variables from the standard input device and then shows both variables to the standard output (the monitor). We used the string specifier (<code>%s</code>) and the new line escape sequence (<code>\n</code>). Now, let’s dig deeper into formatting output. In the following <a id="_idIndexMarker1272"/>examples, we’re using the new tab escape sequence (<code>\t</code>) together with the newline escape sequence (<code>\n</code>) and the string specifier. Take a look at the following figure and see how formatting works:</p>
<div><div><img alt="Figure 8.19 – Using tab and newline escape sequences" src="img/B19682_08_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Using tab and newline escape sequences</p>
<p>The example we just showed you is using escape sequences to mimic table formatting for the output. We can do this by using a script with more complex specifiers than the ones already used. In the following example, we’re using the string (<code>%s</code>), integer (<code>%d</code>), and floating (<code>%f</code>) specifiers to format a table output:</p>
<div><div><img alt="Figure 8.20 – Using complex specifiers and escape sequences for table formatting" src="img/B19682_08_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Using complex specifiers and escape sequences for table formatting</p>
<p>Let’s detail our <code>format-output.sh</code> script. We have a variable called <code>separator</code> that’s used to print out the graphical border between the header and the contents. Then, we have the <code>header</code> and <code>format</code> variables, each using specifiers and sequences for formatting specifics. <code>header</code> starts with a new <a id="_idIndexMarker1273"/>line (<code>\n</code>), followed by a string specifier with a length of 10 characters wide aligned to the left (<code>%-10s</code>), followed by eight characters wide aligned to the right (<code>%8s</code>), 10 characters wide aligned to the right (<code>%10s</code>), and 11 characters wide aligned to the right (<code>%11s</code>) with a new line at the end (<code>\n</code>). The format variable is used to format the contents of the table by using two string columns (using the <code>%s</code> specifier), one integer (<code>%d</code>), and one floating-point (<code>%f</code>) specifier. The integer value is used for the product ID and the floating-point value is used for the price. We use the <code>%08d</code> format specifier to print the ID, which means that the output will be 8 characters wide. The <code>0</code> character in front indicates that any empty spaces will be filled with zeros. This ensures that even when the ID number has less than eight digits, the remaining width will be padded with zeros to maintain the desired width of eight characters. The result is shown in the lower part of the preceding screenshot, where we have a table with products, their IDs, placement, and prices.</p>
<p>Thus, <code>printf</code> is a very versatile and powerful tool that can be used with great results insider your scripts. Now that you know the basic tools for input and output data formatting for Bash scripting, let’s<a id="_idIndexMarker1274"/> proceed to other useful and important structures that can be used.</p>
<p>In the next section, we will cover exit statuses.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor178"/>Understanding exit statuses and testing structures</h2>
<p>To use conditional and looping statements, we <a id="_idIndexMarker1275"/>need to understand the <code>$?</code>. The question mark is the place of an integer that will give the status of the command. For example, if the command’s execution was successful, then the value of the question<a id="_idIndexMarker1277"/> mark will be <code>0</code> (zero) and the parameter will show <code>$0</code>. If the command’s execution was not<a id="_idIndexMarker1278"/> successful, the question mark can have any value starting from 1 to 255. Most regularly, the error number is <code>1</code>, so the <a id="_idIndexMarker1279"/>parameter will be <code>$1</code>. These are also called <strong class="bold">exit codes</strong>.</p>
<p>Alongside exit codes, <strong class="bold">testing structures</strong> are also important for conditional and looping statements in Bash. These testing structures are usually the building blocks for the aforementioned statements. They are considered shell’s keywords and are represented like so:</p>
<ul>
<li><code>[[ ]]</code>: Double square brackets are used to test the true or false status of a command; it can perform operations on regular expressions too</li>
<li><code>(( ))</code>: Double brackets are used for arithmetic operations</li>
<li><code>test</code>: This keyword is used to evaluate expressions such as strings, integers, and file properties</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">The syntax of Bash requires spaces to be used before and after brackets – for example, <code>[ </code><code>operation ]</code>.</p>
<p>In conditional statements, some other types of operators are used for testing. Let’s take a look at some of the most commonly used <a id="_idIndexMarker1280"/>conditional operators for <strong class="bold">integer tests</strong>:</p>
<ul>
<li><code>-eg</code>: The equality check operator</li>
<li><code>-ne</code>: The inequality check operator</li>
<li><code>-lt</code>: The less than operator</li>
<li><code>-le</code>: The less than or equal to operator</li>
<li><code>-gt</code>: The greater than operator</li>
<li><code>-ge</code>: The greater than or equal operator</li>
</ul>
<p>In addition, there are argument <a id="_idIndexMarker1281"/>operators in Linux shell scripting. The <code>$0</code> variable represents the command used to run the script, while <code>$1</code> through <code>$n</code> represents the<a id="_idIndexMarker1282"/> first through <em class="italic">n</em>th arguments passed to the command. For example, <code>$1</code> refers to the first argument, <code>$2</code> refers to the second argument, and so on, where <code>$n</code> represents the <em class="italic">n</em>th argument of the command.</p>
<p>Besides the operators shown in this section, basic mathematical operators are also currently used in conditional statements.</p>
<p>There are also testing<a id="_idIndexMarker1283"/> structures for <strong class="bold">strings</strong>:</p>
<ul>
<li><code>=</code>: Tests if strings are identical (<code>==</code> is also accepted)</li>
<li><code>!=</code>: Tests if strings are <em class="italic">NOT</em> identical</li>
<li><code>\&lt;</code> and <code>\&gt;</code>: Less than and greater are accepted for string comparison, but they must be escaped (we already used the backslash character)</li>
</ul>
<p>There are also testing <a id="_idIndexMarker1284"/>operators for <strong class="bold">file types</strong>, which are in the form of options:</p>
<ul>
<li><code>-f</code>: Tests for a regular file</li>
<li><code>-d</code>: Tests for a directory</li>
<li><code>-h</code> or <code>-L</code>: Tests for a symbolic link</li>
<li><code>-e</code>: Testing for a file’s existence</li>
</ul>
<p>Here are some other operators that are used for testing:</p>
<ul>
<li><code>-a</code>: The logical AND</li>
<li><code>-o</code>: The logical OR</li>
<li><code>-z</code>: To check if an input string was entered</li>
</ul>
<p>Testing operators are complex <a id="_idIndexMarker1285"/>and useful, so it’s very important to learn them.</p>
<p>In the next section, we will cover<a id="_idIndexMarker1286"/> Bash conditional statements.</p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor179"/>Using conditional if statements</h2>
<p>Just like in any other programming language, Bash <a id="_idIndexMarker1287"/>has conditional execution statements, such as <code>if-then-fi</code>, <code>if-then-else-fi</code>, and <em class="italic">nested </em><code>if</code>, and conditional operators such as <code>&amp;&amp;</code> (<em class="italic">AND</em>) and <code>||</code> (<em class="italic">OR</em>). We will show you how<a id="_idIndexMarker1288"/> to use them in this section.</p>
<p>We will present the <code>if</code> statement in all its appearances (<code>if-then</code>, <code>if-then-else</code>, and nested <code>if</code>) in this section:</p>
<ul>
<li> In its most common form, the <code>if-then-fi</code> statement has the following syntax:<pre class="source-code">
if [condition]
then
     commands
fi</pre><p class="list-inset">This Bash <code>if</code> statement is running <code>condition</code> after the <code>if</code> keyword. If the command is completed successfully, meaning it has an exit status of zero, then it will run the commands that are listed after the <code>then</code> keyword.</p></li> <li>The <code>if-then-else-fi</code> statement is similar to <code>if-then</code> and has the following syntax:<pre class="source-code">
if [condition]
then
     commands
else
     commands
fi</pre><p class="list-inset">Similar to the simpler <code>if-then</code> statement, <code>condition</code> is run, and depending on its exit status, the results are different. If it completes successfully, the commands after the <code>then</code> keyword are executed, but if there is another exit status (non-zero), the commands after the <code>else</code> keyword are executed. This gives more options and <a id="_idIndexMarker1289"/>alternatives, based on <a id="_idIndexMarker1290"/>the result of the condition. There are situations when you would need to check for more conditions inside a single <code>if-then</code> command, so <a id="_idIndexMarker1291"/>you can use nested if statements for this.</p></li> </ul>
<p>Now, let’s discuss some basic conditional arguments that are used in <code>if</code> statements, together with some examples:</p>
<ul>
<li>In this example, we will check if the number a user is typing is even or odd. The script will take the input from the user by using the <code>read</code> command; then, it will check if what remains from its division by two is zero or not. This way, it determines if the number is odd or even. We will use the <code>if-then-else</code> statement for this example, together with the <code>read</code> and <code>printf</code> commands. The following screenshot shows the code and the execution’s output:</li>
</ul>
<div><div><img alt="Figure 8.21 – Script to determine an even or odd number" src="img/B19682_08_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – Script to determine an even or odd number</p>
<ul>
<li>The following script checks if a filename introduced by the user is indeed a file or not by using the <code>test -f</code> operator. We<a id="_idIndexMarker1292"/> will introduce the absolute path of the file we want to run a check on. The <a id="_idIndexMarker1293"/>script is called <code>testing_file.sh</code> and its code is shown in the following screenshot:</li>
</ul>
<div><div><img alt="Figure 8.22 – Checking if a filename that’s been introduced is a file" src="img/B19682_08_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Checking if a filename that’s been introduced is a file</p>
<p class="list-inset">By running this script, you will be prompted to provide the filename and full path of an existing (or not) file. Let’s do some tests. You will see the output shown in the following figure. We tested if the script is working correctly in three different scenarios: when<a id="_idIndexMarker1294"/> we do not provide a filename, when we enter a correct filename, and when we enter the<a id="_idIndexMarker1295"/> wrong filename:</p>
<div><div><img alt="Figure 8.23 – Running the file-checking script" src="img/B19682_08_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Running the file-checking script</p>
<p>Now that we’ve covered the basics of <code>if</code> conditional statement usage, let’s proceed to other types of statements, such as looping statements.</p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor180"/>Using looping statements</h2>
<p>In Bash, <code>for</code>, <code>while</code>, and <code>until</code> commands, and we will show you how to use them in this<a id="_idIndexMarker1296"/> section. Looping statements are <a id="_idIndexMarker1297"/>used when repeating processes are needed, such as looping through several commands until a condition is met.</p>
<h3>Using the for statement</h3>
<p>As in any other programming language, the need for iterating appears when repetitive tasks have to be done. This means that some commands need to be repeated until condition(s) are met. This is similar in<a id="_idIndexMarker1298"/> Bash as in any other programming<a id="_idIndexMarker1299"/> language, and one of the commands to use is the <code>for</code> command. It has the following structure:</p>
<pre class="source-code">
for var in list
do
     commands
done</pre> <p>If you did not have any interaction with such a statement before, we will help you understand what it means. The variables provided through the <code>var</code> parameter are assigned with a series of values provided through the <code>list</code> parameter, in a series of iterations. At the start of the iteration, the variable is set with the current (or starting) value in the list. Each iteration will use another value from the list, until the last item in the list. The number of items in the list will set the number of iterations. For each iteration, the commands inside the <code>commands</code> block will be executed. This is a basic loop we described.</p>
<p>Let’s see some basic uses of the <code>for</code> command. We will loop through a statically declared array. This means that we will not use the input from our user; instead, we will specify the array directly inside the script. We will use a temporary variable (or counter) called <code>i</code> to iterate through the entire length of the array. We use <code>${array[@]}</code> to specify the array’s length. The loop will stop when the counter (<code>i</code>) reaches this length. The following figure shows the script’s code, the commands used to run it, and the output. Keep in mind that we provided an array that had values already ordered. This is not a sorting algorithm:</p>
<div><div><img alt="Figure 8.24 – Iterating through an array using the for statement" src="img/B19682_08_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Iterating through an array using the for statement</p>
<p>In the following example, we will <a id="_idIndexMarker1300"/>bring back the discussion on arrays and use some of them inside a <code>for</code> statement. This time, we will show you how to sort an array. We will use most of the structures we’ve<a id="_idIndexMarker1301"/> already learned about, such as input reading, output formatting, arrays, and <code>for</code> statements.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Sorting algorithms are outside the scope of this book. We will only use one type of sort (bubble) to show you how to use arrays and <code>for</code> statements and how powerful Bash can be. However, if you plan on doing any serious programming while using the shell, we advise you to use another programming language that is more suited for this type of action, such as Python. Python is incredibly versatile and can successfully be used for many administrative tasks.</p>
<p>Let’s get back to our sorting issue. Let’s say we have a random array that we would like to sort. We will use an array that has integer elements only. To make things more interesting, we will prompt the user to introduce the array elements from the standard input. The following figure shows the code of the script:</p>
<div><div><img alt="Figure 8.25 – Using the bubble sort algorithm to sort an array" src="img/B19682_08_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – Using the bubble sort algorithm to sort an array</p>
<p>Let’s explain the code. We used a variable, <code>n</code>, to specify the length of the array. Then, we used this variable to iterate<a id="_idIndexMarker1302"/> through all the numbers provided by the user. In the first <code>for</code> statement, we iterate<a id="_idIndexMarker1303"/> through all the numbers and carefully increase the counter (with the <code>I</code> variable) by each step (the <code>i++</code> structure). The numbers provided by the user are then stored inside an array called <code>num</code>. When the sorting starts, we use two nested <code>for</code> statements and one <code>if</code> statement. We make use of a new counter called <code>j</code>, which is used to store the value of a new consecutive number inside the array. The <code>if</code> statement compares which of two consecutive numbers inside the array is greater, thus performing the switch between the first two elements inside the array. To perform the switch, we use a temporary counter called <code>k</code> to keep the value of the greater number to make the switch between the two numbers that are being compared. The loop is finished when all the numbers have been cycled through. The final <code>for</code> statement prints the contents of the new, sorted array.</p>
<p>The user input and the output of the<a id="_idIndexMarker1304"/> command are shown<a id="_idIndexMarker1305"/> here:</p>
<div><div><img alt="Figure 8.26 – Showing the input and output for our sorting script" src="img/B19682_08_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – Showing the input and output for our sorting script</p>
<p>In the preceding example, bubble sort is working as follows:</p>
<ul>
<li>The first step is to compare the first two elements in the array, which are <code>45</code> and <code>24</code>, and see which is greater; <code>45</code> is greater than <code>24</code>, so the new array will be <code>24 45</code> <code>56</code> (the algorithm swaps between <code>45</code> and <code>24</code>).</li>
<li>The second step is to compare the next two elements, which are now <code>45</code> and <code>56</code> (because <code>45</code> was greater than <code>24</code> and is now in the second position; as <code>45</code> is not greater than <code>56</code>, their position will remain unchanged).</li>
<li>The third step is to do one more pass through all the elements and still do the comparison.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">Bubble sort is not an efficient sorting algorithm, but it was a good example of how to use arrays, <code>for</code> and <code>if</code> statements, input from the user, and output formatting. For more information on the bubble sort algorithm or any other type of sorting algorithm, we would advise a thorough online search or that you read the titles we have provided in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
<p>Now that you know how to use the <code>for</code> statement, let’s proceed to the <code>while</code> statement.</p>
<h3>Using the while statement</h3>
<p>The <code>while</code> loop is similar to the <code>for</code> loop, with the difference that it is somehow also a combination of the <code>if</code> statement. So long as<a id="_idIndexMarker1306"/> a condition is true, the loop <a id="_idIndexMarker1307"/>is executing the commands. The syntax is as follows:</p>
<pre class="source-code">
while condition
do
     commands
done</pre> <p>The condition is tested every time an iteration is started. If the condition remains true, the exit status is zero, and the commands are executed until the condition changes its status. Let’s see some examples.</p>
<p>In the following script, we’re using a <code>while</code> statement to go through a list of numbers in descending order:</p>
<div><div><img alt="Figure 8.27 – Using a while statement" src="img/B19682_08_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – Using a while statement</p>
<p>The <code>while</code> statement will evaluate the <code>[ $max -gt 0 ]</code> condition and iterate until the condition is false. This means that so long as the number you provide is greater than (<code>-gt</code>) zero, the commands <a id="_idIndexMarker1308"/>will be executed. The commands inside the <code>while</code> loop are simply decreasing the number with every iteration. Otherwise, you <a id="_idIndexMarker1309"/>will end up in an infinite loop. Thus, the value of the max variable will be lower by one point every time the <code>while</code> loop executes. We tested with two values, once with 10 and again with 30; you can see the output in <em class="italic">Figure 8</em><em class="italic">.27</em>.</p>
<p>The <code>while</code> statement is very useful and straightforward, being a great addition to the <code>for</code> statement. Now, let’s see the <code>until</code> statement.</p>
<h3>Using the until statement</h3>
<p>This looping structure is the opposite of <code>while</code>. It uses a<a id="_idIndexMarker1310"/> condition that is false from the start, and while the condition <a id="_idIndexMarker1311"/>remains false, the commands inside the structure will be executed. The syntax is as follows:</p>
<pre class="source-code">
until condition
do
     commands
done</pre> <p>For a very quick example, let’s redo the <code>while</code> loop from the previous example by using the <code>until</code> statement this <a id="_idIndexMarker1312"/>time. Here’s the code:</p>
<div><div><img alt="Figure 8.28 – An example of an until statement" src="img/B19682_08_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – An example of an until statement</p>
<p>Can you spot the differences<a id="_idIndexMarker1313"/> between the <code>until</code> and <code>while</code> loops? In the case of <code>until</code>, the iteration continues until the value of the variable is equal to zero, <code>[ $max -eq 0 ]</code>. The commands inside the <code>until</code> loop are the same as the ones used inside the <code>while</code> loop. The condition is different. The output, as you might expect, is the same as when using a <code>while</code> loop.</p>
<p>Before we move on and learn about more advanced programming structures, we’ll provide some basic information about controlling the execution of a loop by using specific keywords.</p>
<h3>Exiting loop statements</h3>
<p>The two commands that are <a id="_idIndexMarker1314"/>used in Bash to exit loops are <code>break</code> and <code>continue</code>. They are relatively straightforward. Whenever you want to exit<a id="_idIndexMarker1315"/> a loop, you can use one of them. Let’s use a simple script that iterates through a series of integer numbers until a specified value is reached and it exits the iteration. Here is the code:</p>
<div><div><img alt="Figure 8.29 – Exiting a loop using the break command" src="img/B19682_08_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 – Exiting a loop using the break command</p>
<p>When executing, the user is asked to introduce the maximum value for the sequence and the value of <code>break</code>. The <code>for</code> loop goes through the sequence until the value of break is reached, and it exits<a id="_idIndexMarker1316"/> the loop. We used the <code>break</code> command to exit the loop and started the iteration from<a id="_idIndexMarker1317"/> zero. You can test the outcome with different values. The following is the output when using a value of <code>10</code> for the maximum sequence and a value of <code>5</code> for <code>break</code>:</p>
<div><div><img alt="Figure 8.30 – Output of using the break script example" src="img/B19682_08_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 – Output of using the break script example</p>
<p>As you can see, the loop exits after 5 is reached. However, it shows the value of 5, it does not skip it. This can be fixed (it is not necessarily an issue, more of an algorithm design decision). Let’s look at the following code:</p>
<div><div><img alt="Figure 8.31 – Breaking loop optimized" src="img/B19682_08_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.31 – Breaking loop optimized</p>
<p>For the breaking value to not be shown, we moved the <code>echo $i</code> command after the conditional if-then statement. This will prevent the script from showing the breaking value provided by the user. Both <a id="_idIndexMarker1318"/>use cases are valid and they provide the same output, so the position of the output printing command is only relevant to your needs.</p>
<p>In the following example, we<a id="_idIndexMarker1319"/> will show you how to use the <code>continue</code> command to exit a loop. The algorithm is similar to the one used in the <code>break</code> example, except this time, the value provided by the user will not be shown in the output. The <code>break</code> command will exit the loop when a condition is met, whereas the <code>continue</code> command will skip the rest of the command execution that is present after the condition, when a certain condition is met, and will continue to the next iteration of the loop sequence. This difference is sufficient for you to understand the differences between <code>break</code> and <code>continue</code>. Let’s see the code for the same script, using the <code>continue</code> command:</p>
<div><div><img alt="Figure 8.32 – Using the continue command inside a loop" src="img/B19682_08_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.32 – Using the continue command inside a loop</p>
<p>As you can see, the code is similar to what <a id="_idIndexMarker1320"/>was used in the<a id="_idIndexMarker1321"/> previous example. The only difference is the use of the <code>continue</code> command instead of <code>break</code>. Now, let’s see the output that’s obtained:</p>
<div><div><img alt="Figure 8.33 – The output when using the continue command" src="img/B19682_08_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.33 – The output when using the continue command</p>
<p>As shown in the preceding figure, the number 5 is not shown, meaning that the loop skipped it when the <code>continue</code> command is used.</p>
<p>You now know quite a bit about scripting in Linux. You know how to use variables, arrays, if and looping statements, and even exiting loops. In the next section, we will show you how to use more advanced <a id="_idIndexMarker1322"/>programming structures, such <a id="_idIndexMarker1323"/>as functions.</p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor181"/>Working with functions</h2>
<p>As in most programming languages, <code>function</code> keyword, followed by the function’s name, as shown in the following syntax:</p>
<pre class="source-code">
function name {
     commands
}</pre> <p>Alternatively, you can use parentheses after the function’s name, as shown in the following syntax:</p>
<pre class="source-code">
name() {
     commands
}</pre> <p>The name from the syntax is a unique name that the function will use throughout the script. The commands are represented by one or more shell commands that are executed by the function in their order of appearance. Simplified, you can look at functions as scripts inside scripts. Let’s see some examples.</p>
<p>With the risk of being redundant, we will use one of the scripts we already created and use it as a function, just to show you how functions work, for starters. We will use the script that sorts numbers in descending order and make it a function. But before that, let’s give you a word of caution regarding functions.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Functions must be created before they are called. Calling a function is the process of running it inside a script. If you create the function after you call it, the script will give you an error because Bash is a single-pass interpreter. A good practice is to create the functions at the beginning of a script. This way, they will be available whenever they’re needed throughout the script.</p>
<p>So, here it is – our first function is shown in the following screenshot. As you can see, first, we created the <code>sorting</code> function, and<a id="_idIndexMarker1326"/> then we called it:</p>
<div><div><img alt="Figure 8.34 – Running our first function" src="img/B19682_08_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.34 – Running our first function</p>
<p>At this point, you know how to create and call a function inside a shell script, but there is much more to this matter than just that. We will try and give you all the necessary information about functions so that you will be able to use them in your scripts, but if you want to learn more, please consider the titles provided in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<p>In the next section, we will walk you through different function capabilities, such as output, variables, and array handling.</p>
<h3>Advanced function capabilities</h3>
<p>Every function inside the Bash shell, as stated before, works like a script by itself. This means that it can manage<a id="_idIndexMarker1327"/> variables, arrays, and output in the same way as a script. In this section, we will show you how to use variables, arrays, and output inside functions.</p>
<h4>Using variables inside functions</h4>
<p>Both types of variables (global and local) can be used inside functions. Let’s provide an overview of the differences between <a id="_idIndexMarker1328"/>these two types of variables. The global ones are visible and available throughout the system, while the local ones are only available inside the function where they were declared. By default, all variables in Bash are defined as global variables, including the ones defined inside functions. To declare local variables inside functions, we can use the <code>local</code> keyword. Let’s see a basic example to understand how this works:</p>
<div><div><img alt="Figure 8.35 – Showing how local and global variables work in functions" src="img/B19682_08_35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.35 – Showing how local and global variables work in functions</p>
<p>The preceding figure shows how the variables were declared. For example, first, we declared the <code>var1='1'</code> and <code>var2='2'</code> variables. By default, they are set as global variables. Then, inside the <code>var_function</code> function, we modified the values of the two variables, but for one of them, we used the <code>local</code> keyword to define it local to the function. For the other one, we did not use the same keyword – we defined it as we did before the function. Thus, when printing the variables to the standard output after the function is run, only <code>var2</code> will keep <a id="_idIndexMarker1329"/>the value given to it inside the variable, compared to <code>var1</code>, which was declared locally and had a different value only inside the function.</p>
<h4>Using arrays inside functions</h4>
<p>Unlike variables, arrays inside functions are<a id="_idIndexMarker1330"/> somewhat problematic. There are two scenarios to consider: one when you need to pass arrays from the script to the function, and one when you would need to pass an array from the function back to the script. In the first case, you can’t use the array as a function parameter because only the first value of the array will be used by the function. Thus, the convenient way is to break the array and then rebuild it inside the function, even though it sounds and proves unpractical. In the second case, the practice of handling arrays is similar to the first scenario as the function will output the values in the correct order and the script will reassemble the value into an array. Let’s see an example:</p>
<div><div><img alt="Figure 8.36 – Using arrays inside functions" src="img/B19682_08_36.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.36 – Using arrays inside functions</p>
<p>In the preceding example, we used two functions, one for each of the scenarios described at the beginning of this<a id="_idIndexMarker1331"/> subsection. The <code>test_function_1</code> function inside the script shows the way we can pass array elements to the function. The <code>test_function_2</code> function shows how arrays are being returned from functions. Here’s the output:</p>
<div><div><img alt="Figure 8.37 – Output of using arrays in functions" src="img/B19682_08_37.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.37 – Output of using arrays in functions</p>
<p>At this point, you’ve learned how to create scripts and how to use arrays, variables, programming structures, and functions. Now, it’s <a id="_idIndexMarker1332"/>time to learn how to use <code>sed</code> and (<code>g</code>)<code>awk</code> both at the command line and in scripts.</p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor182"/>Using sed and (g)awk commands</h2>
<p>Both <code>sed</code> and (<code>g</code>)<code>awk</code> are advanced tools that<a id="_idIndexMarker1333"/> are used for manipulating text files. <code>sed</code> is a stream editor and <code>awk</code> is a<a id="_idIndexMarker1334"/> programming language. We also use the <code>gawk</code> reference (thus the letter <code>g</code> used inside<a id="_idIndexMarker1335"/> parentheses) as it is the GNU implementation of <code>awk</code>, offering more features and extensions. Let’s learn how to use both of them at the command line.</p>
<h3>Using sed at the command line</h3>
<p><code>sed</code> is more than a simple<a id="_idIndexMarker1336"/> command. It is a data stream editor that<a id="_idIndexMarker1337"/> edits files based on a strict set of rules supplied beforehand. Based on these rules, the command reads the file line by line and the data inside the file is then manipulated. <code>sed</code> is a non-interactive stream editor that makes changes based on a script, and in this respect, it is well suited for editing more files at once or for doing mundane repetitive tasks. The <code>sed</code> command’s general syntax is as follows:</p>
<pre class="console">
sed OPTIONS… [SCRIPT] [FILE…]</pre> <p>The <code>sed</code> command uses different script subcommands, and one of the common subcommands that’s used is for text substitution. There are many other use cases that we will not discuss here, but if you feel the need to learn more about the <code>sed</code> tool, there are plenty of great materials online and in print. For example, the following link could be useful: <a href="https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command">https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command</a>.</p>
<p>The common syntax that’s used for text substitution is as follows:</p>
<pre class="console">
sed 's/regex/replacement/flag'</pre> <p>Here are some examples of the most common use cases of <code>sed</code>:</p>
<ul>
<li>Replace one name with another inside a text file. For this example, we will use a new file called <code>poem</code> in our home directory. Inside it, we generated a random poem. The task is to replace the name <code>Jane</code> with <code>Elane</code> from within the file. The letter <code>g</code>, as a flag of the <a id="_idIndexMarker1338"/>command, specifies that the operation should be global – that is, it should be applied to the entire text<a id="_idIndexMarker1339"/> document. Here is the result:</li>
</ul>
<div><div><img alt="Figure 8.38 – Using the sed command to replace a string in a text file" src="img/B19682_08_38.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.38 – Using the sed command to replace a string in a text file</p>
<p class="list-inset">If you check the original file using the <code>cat</code> command, you will see that <code>sed</code> only delivered the changed name result to the standard output and did not make any changes to the original file. To make the changes to the file permanent, you will have to use the <code>-</code><code>i</code> attribute.</p>
<ul>
<li>In the following example, we’re adding new spaces at the beginning of each line and redirecting the output to a new file. We’re using the same <code>poem</code> file as before. The beginning of a file is represented by the <code>^</code> character:</li>
</ul>
<div><div><img alt="Figure 8.39 – Using sed to add spaces" src="img/B19682_08_39.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.39 – Using sed to add spaces</p>
<ul>
<li>We will use <code>sed</code> to show only the second<a id="_idIndexMarker1340"/> line from the <code>poem</code> file and to show all the lines except for <em class="italic">line 2</em>:</li>
</ul>
<div><div><img alt="Figure 8.40 – Using sed to show specific lines in a file" src="img/B19682_08_40.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.40 – Using sed to show specific lines in a file</p>
<ul>
<li>Let’s show only <em class="italic">lines 4 to 6</em> from a<a id="_idIndexMarker1341"/> file – in our case, the <code>/</code><code>etc/passwd</code> file:</li>
</ul>
<div><div><img alt="Figure 8.41 – Using sed to show a specific number of lines in a text file" src="img/B19682_08_41.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.41 – Using sed to show a specific number of lines in a text file</p>
<ul>
<li>Here is a more practical exercise. We will show the contents of <code>/etc/apt/sources.list</code> from Ubuntu without the commented lines. To do this, use the following command:<pre class="source-code">
<code>#</code>) character, represented by the <code>^#</code> characters inside the command. Those are the comments inside the file. We also use the <code>g</code> flag to specify that the operation is global for that file. The following<a id="_idIndexMarker1342"/> is part of the output provided by the command. Use it on your Ubuntu system and analyze your output as well:</p></li> </ul>
<div><div><img alt="Figure 8.42 – Use of sed to show only lines with no comments" src="img/B19682_08_42.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.42 – Use of sed to show only lines with no comments</p>
<p>In the following subsection, we<a id="_idIndexMarker1343"/> will explore the <code>awk</code> command at the<a id="_idIndexMarker1344"/> command line.</p>
<h3>Using awk from the command line</h3>
<p><code>awk</code> is much more than <a id="_idIndexMarker1345"/>a simple command – it is a pattern-matching language. It is a full-fledged programming language that was the base for PERL. It is used for data extraction from text files, with a syntax similar to C. It sees a file as being<a id="_idIndexMarker1346"/> composed of fields and records. The general structure of the <code>awk</code> command is as follows:</p>
<pre class="console">
awk '/search pattern 1/ {actions} /search pattern 2/ {actions}' file</pre> <p>The true power of <code>awk</code> is beyond the scope of this chapter, so we will show no more than one simple example of its use that could prove practical for a future system administrator.</p>
<p>As an example, we will generate a list containing the names of all the packages installed by Ubuntu. We only want to print the name of each package, not all the other details. For this, we will use the following command:</p>
<pre class="console">
sudo dpkg -l | awk '{print $2}' &gt; package-list</pre> <p>This command is only showing the names of the packages that have been installed. Here is the output:</p>
<div><div><img alt="Figure 8.43 – Using awk to generate a list of package names" src="img/B19682_08_43.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.43 – Using awk to generate a list of package names</p>
<p>Generally, to see the installed<a id="_idIndexMarker1347"/> packages in Ubuntu, we would run the <code>dpkg -l</code> command. In the preceding example, we piped the output of that command to the <code>awk</code> command, which printed the second <a id="_idIndexMarker1348"/>column (field) from the <code>dpkg -l</code> output (<code>'{print $2}'</code>). Then, we redirected everything to a new file called <code>package-list</code> and used the <code>tail</code> command to see the last 10 lines of the newly created file.</p>
<p>Both <code>sed</code> and <code>awk</code> are very powerful tools, and we have merely scratched the surface of what they can do. Please feel free to dig deeper into these two awesome tools.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor183"/>Using scripts to showcase interprocess communication</h1>
<p><code>producer.sh</code> and <code>consumer.sh</code>), thus mimicking the producer and consumer processes. We hope that the use of such simple models will still provide a reasonable analogy for real-world applications.</p>
<p>Now, let’s look at shared<a id="_idIndexMarker1352"/> storage, named and unnamed pipes, and sockets IPC mechanisms, all of which we introduced in <a href="B19682_05.xhtml#_idTextAnchor104"><em class="italic">Chapter 5</em></a> but did not cover in detail.</p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor184"/>Shared storage</h2>
<p>In its simplest<a id="_idIndexMarker1353"/> form, the <code>storage</code> file.</p>
<p>In this simple use case, the obvious <a id="_idIndexMarker1354"/>challenge is the integrity of the read/write operations due to possible race conditions between the underlying operations. To avoid race conditions, the file must be locked during write operations to prevent overlapping I/O with another read or write action. To keep things simple, we’re not going to resolve this problem in our naive examples, but we thought it’s worth calling it out.</p>
<p>In our example, the producer writes a new set of data (<code>10</code> random UUID strings) every <code>5</code> seconds to the <code>storage</code> file. The following screenshot shows the producer’s script:</p>
<div><div><img alt="Figure 8.44 – The producer script (using shared storage)" src="img/B19682_08_44.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.44 – The producer script (using shared storage)</p>
<p>The consumer reads the content of the <code>storage</code> file every second. The following screenshot shows the consumer’s script:</p>
<div><div><img alt="Figure 8.45 – The consumer script (using shared storage)" src="img/B19682_08_45.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.45 – The consumer script (using shared storage)</p>
<p>When running both scripts, the producer<a id="_idIndexMarker1355"/> creates random strings and writes them to the <code>storage</code> file, and the consumer reads the producer’s output from the same file. The output is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.46 – The producer (left) and consumer (right) communicating through shared storage" src="img/B19682_08_46.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.46 – The producer (left) and consumer (right) communicating through shared storage</p>
<p>Next, we will show you how unnamed pipes work.</p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor185"/>Unnamed pipes</h2>
<p><strong class="bold">Unnamed</strong> or <strong class="bold">anonymous</strong> pipes, also known as <strong class="bold">regular</strong> pipes, feed the output of a process to <a id="_idIndexMarker1356"/>the input <a id="_idIndexMarker1357"/>of another one. Using our producer-consumer model, the <a id="_idIndexMarker1358"/>simplest way to illustrate an unnamed pipe as an IPC mechanism between the two processes would be to do the following:</p>
<pre class="source-code">
producer.sh | consumer.sh</pre> <p>The key element of the preceding illustration is the pipe (<code>|</code>) symbol. The left-hand side of the pipe produces an output that’s fed directly<a id="_idIndexMarker1359"/> to the right-hand side of the pipe for consumption. To accommodate the anonymous pipe IPC layer, we’ll make two new scripts called <code>producer2.sh</code> and <code>consumer2.sh</code>. The code is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.47 – The producer2 (left) and consumer2 (right) scripts (using an unnamed pipe)" src="img/B19682_08_47.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.47 – The producer2 (left) and consumer2 (right) scripts (using an unnamed pipe)</p>
<p>In our modified implementation, <code>producer2.sh</code> prints some data to the console (<code>10</code> random UUID strings). <code>consumer2.sh</code> reads and displays either the data coming through the <code>/dev/stdin</code> pipe or the input <a id="_idIndexMarker1360"/>arguments if the pipe is empty. <em class="italic">Line 6</em> in the <code>consumer2.sh</code> script checks the presence of piped data in <code>/dev/stdin</code> (<code>0</code> for <code>fd0</code>):</p>
<pre class="source-code">
if [ -t 0 ]</pre> <p>The output of the producer-consumer communication is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.48 – The producer feeding data into a consumer through an unnamed pipe" src="img/B19682_08_48.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.48 – The producer feeding data into a consumer through an unnamed pipe</p>
<p>The output clearly shows the data being printed out by the consumer process. (Note the <code>"Consumer data:"</code> header preceding the UUID strings.)</p>
<p>One of the problems with IPC anonymous<a id="_idIndexMarker1361"/> pipes is that the data that’s fed between the producer and consumer is not persisted through any kind of storage layer. If the producer <a id="_idIndexMarker1362"/>or consumer processes are terminated, the pipe is gone, and <a id="_idIndexMarker1363"/>the underlying data is lost. Named pipes solve this problem, as we will show you in the next section.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor186"/>Named pipes</h2>
<p><strong class="bold">Named pipes</strong>, also <a id="_idIndexMarker1364"/>known as <strong class="bold">First In, First Outs</strong> (<strong class="bold">FIFOs</strong>), are similar to traditional (unnamed) pipes but substantially different in terms of their semantics. An unnamed pipe only persists<a id="_idIndexMarker1365"/> for as long as the related <a id="_idIndexMarker1366"/>process is running. However, a named pipe has backing storage and will last so long as the system is up, regardless of the running status of the processes attached to the related IPC channel.</p>
<p>Typically, a named pipe acts as a file, and it can be deleted when it’s no longer being used. Let’s modify our producer and consumer scripts so that we can use a named pipe as their IPC channel:</p>
<div><div><img alt="Figure 8.49 – The producer3 (left) and consumer3 (right) scripts (using named pipe)" src="img/B19682_08_49.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.49 – The producer3 (left) and consumer3 (right) scripts (using named pipe)</p>
<p>The named pipe is <code>pipe.fifo</code> (<em class="italic">line 3</em> in both scripts). The pipe file is created (if it’s not already present) by either the producer or consumer when they start (<em class="italic">line 6</em>). The related command is <code>mkfifo</code> (see <code>man mkfifo</code> for more information).</p>
<p>The producer writes a random UUID to the named <a id="_idIndexMarker1367"/>pipe every second (<em class="italic">line 14</em> in <code>producer3.sh</code>), where the consumer immediately reads it (<em class="italic">lines 10</em> to <em class="italic">12</em> in <code>consumer3.sh</code>):</p>
<div><div><img alt="Figure 8.50 – producer3 (left) and consumer3 (right) communicating through a named pipe" src="img/B19682_08_50.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.50 – producer3 (left) and consumer3 (right) communicating through a named pipe</p>
<p>We started both scripts – the producer and the consumer – in an arbitrary order. After a while, we stopped (interrupted) the consumer (<em class="italic">step 1</em>). The producer continued to run but automatically stopped sending data to the pipe. Then, we started the consumer again. The <a id="_idIndexMarker1368"/>producer immediately resumed sending data to the pipe. After a while, we stopped the producer (<em class="italic">step 2</em>). This time, the consumer became idle. After starting the producer again, both resumed normal operation, and data began flowing through the named pipe. This workflow has <a id="_idIndexMarker1369"/>shown the persistence and resilience of the named pipe, regardless of the running status of the producer or consumer processes.</p>
<p>Named pipes are essentially queues, where data is queued and dequeued on a first-come-first-served basis. When more than two processes communicate on the IPC named pipe channel, the FIFO approach may not fit the bill, especially when specific processes demand a higher priority for data processing. Next, we will show you how sockets work.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor187"/>Sockets</h2>
<p>There are <a id="_idIndexMarker1370"/>two types <a id="_idIndexMarker1371"/>of IPC <strong class="bold">socket-based facilities</strong>:</p>
<ul>
<li><strong class="bold">IPC sockets</strong>: Also known <a id="_idIndexMarker1372"/>as Unix domain sockets</li>
<li><strong class="bold">Network sockets</strong>: <strong class="bold">Transport Control Protocol</strong> (<strong class="bold">TCP</strong>) and <strong class="bold">User Datagram Protocol </strong>(<strong class="bold">UDP</strong>) sockets</li>
</ul>
<p>IPC sockets use a local file as a <strong class="bold">socket address</strong> and enable bidirectional communication between processes on the same host. On the other hand, <strong class="bold">network sockets</strong> extend the IPC data <a id="_idIndexMarker1373"/>connectivity layer beyond the local machine <a id="_idIndexMarker1374"/>via TCP/UDP networking. Apart from the obvious implementation differences, the IPC socket’s and network socket’s data communication channels behave the same.</p>
<p>Both sockets are configured as streams, support bidirectional communication, and emulate a client/server pattern. The socket’s communication channel is active until it’s closed on either end, thereby breaking the IPC connection.</p>
<p>Let’s adapt our producer-consumer model to simulate an IPC socket (Unix domain socket) data connectivity layer. We’ll use <code>netcat</code> to handle <a id="_idIndexMarker1375"/>the underlying client/server IPC socket’s connectivity. <code>netcat</code> is a powerful networking tool for reading and writing data using TCP, UDP, and ICP socket connections. If <code>netcat</code> is not installed by default on your<a id="_idIndexMarker1376"/> Linux distribution of choice, you may look to install it as follows.</p>
<p>On Ubuntu/Debian, use the following command:</p>
<pre class="console">
sudo apt install netcat</pre> <p>On Fedora/RHEL, use the following command:</p>
<pre class="console">
sudo dnf install nmap</pre> <p>For more information about <code>netcat</code>, please refer to the related system reference manual (<code>man netcat</code>).</p>
<p>In the following example, we will use a <code>producer4.sh</code> file and a <code>consumer4.sh</code> file. The code for each file is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.51 – The producer4 (left) and consumer4 (right) scripts (using IPC sockets)" src="img/B19682_08_51.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.51 – The producer4 (left) and consumer4 (right) scripts (using IPC sockets)</p>
<p>The producer acts as the server by initiating a <code>netcat</code> listener endpoint using an IPC socket (the last line in <code>producer4.sh</code>):</p>
<pre class="console">
nc -lU "${SOCKET}"</pre> <p>The <code>-l</code> option indicates the listener (server) mode, while the <code>-U "${SOCKET}"</code> option parameter specifies the IPC socket type (Unix domain socket). The consumer connects to the <code>netcat</code> server endpoint as a client with a similar command (the last line in <code>consumer4.sh</code>). The producer and consumer both use the same (shared) IPC socket file descriptor (<code>/var/tmp/ipc.sock</code>) for communication.</p>
<p>The producer <a id="_idIndexMarker1377"/>sends random UUID strings every second to the consumer (the <code>while</code>-<code>do</code>-<code>done</code> structure in <code>producer4.sh</code>). The related output is captured in <code>stdout</code> with the <code>tee</code> command before being <a id="_idIndexMarker1378"/>piped to <code>netcat</code>:</p>
<div><div><img alt="Figure 8.52 – producer4 (left) and consumer4 (right) communicating through an IPC socket" src="img/B19682_08_52.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.52 – producer4 (left) and consumer4 (right) communicating through an IPC socket</p>
<p>The consumer gets all the messages (UUIDs) that have been generated by the producer. To show you that the consumer listens, we first started the consumer script, which generated two errors, so long as the producer was not sending data through the socket. Once we started the producer script, the consumer started to receive data. When we interrupted the producer, the consumer stopped immediately.</p>
<p>In our producer-consumer<a id="_idIndexMarker1379"/> model, we used <code>netcat</code> for the IPC socket communication layer. Alternatively, we could use <code>socat</code>, a similar networking tool. In the next section, we will show you a quick example of using a script for a specific Linux administrative task. As a bonus, we will also show you how to build applications from source.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor188"/>Scripting for administrative tasks</h1>
<p>Scripting in a Linux operating<a id="_idIndexMarker1380"/> system is mainly useful when it can help with mundane administrative tasks. This way, you can automate your workflow in ways that will make your job easier and more enjoyable. There are many use cases of shell scripts, and we will only provide you with a quick and easy example, hoping that it will suffice for understanding how a script can be used for a sysadmin task.</p>
<p>In the following sections, we will show you how to build a distribution-specific package from a source. This is something that should have been presented to you in <a href="B19682_04.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, but at that time, you did not know how to create a script. In this chapter, we only used Ubuntu 22.04.2 LTS for our<a id="_idIndexMarker1381"/> examples. In the following sections, we will use Fedora 37 Server Edition for our examples.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor189"/>Creating scripts for system administrative tasks</h2>
<p>In this section, we will show you a couple of scripts for administrative tasks. As we stated at the beginning of this chapter, a shell <a id="_idIndexMarker1382"/>script is a sequence of Bash commands that are executed when the file is running. In the following subsections, we will create two scripts that will do two different administrative tasks.</p>
<h3>An updating script example</h3>
<p>This script will use the <code>dnf update</code> command to update the system at a specified time. It is a very basic script that runs just a simple command and shows some messages to standard output. Remember that we will be <a id="_idIndexMarker1383"/>using a Fedora Server distribution this time. The simplest way would be to run the following command inside the script:</p>
<pre class="console">
sudo dnf update -y</pre> <p>The issue is that it requires the <code>sudo</code> password. This defies the purpose of automation because the user must provide the password manually. Let’s learn how to overcome this issue. First, let’s see the code of the script:</p>
<div><div><img alt="Figure 8.53 – A simple update script" src="img/B19682_08_53.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.53 – A simple update script</p>
<p>Now, if you want the command to be run without the <code>sudo</code> password, you will have to edit the <code>/etc/sudoers</code> file and modify/add some things.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Please take into consideration that this method will have system-wide effects, not only on the script you want to run. It is not considered a safe measure and we advise you to use it with extreme care and consideration on any production system.</p>
<p>Remove the comment before <code>%wheel</code> in the following line:</p>
<pre class="source-code">
%wheel  ALL=(ALL)       NOPASSWD: ALL</pre> <p>This will provide a password-less<a id="_idIndexMarker1384"/> action for every user that is in the wheel group. This should include the user you are using. If it wasn’t inside the <code>wheel</code> group, you wouldn’t be able to use <code>sudo</code> with it. In our case, the <code>packt</code> user is inside the <code>wheel</code> group. To test if it works, you can run the script as a regular user and see if the prompt for the <code>sudo</code> password will appear.</p>
<p>Now, we will have to schedule the script to run at a certain time. Don’t forget to make your script file executable to be able to run it. As we are using a server distribution, we assume that this machine is running 24/7 without interruptions, so running at startup would make no sense. Furthermore, we want to ensure that the system is always up to date. To schedule the script, we will use <code>cron</code> and <code>crontab</code>. We will show you how they work in the next section.</p>
<h3>Scheduling scripts in Linux with cron</h3>
<p>Using <code>crontab</code> might look scary at first, but <a id="_idIndexMarker1385"/>once you get to know it, you will find it very useful. Perhaps the<a id="_idIndexMarker1386"/> most intimidating aspect of using <code>cron</code> jobs is the <a id="_idIndexMarker1387"/>definition process, especially the <code>cron</code> date is provided inside the <code>/</code><code>etc/crontab</code> file:</p>
<div><div><img alt="Figure 8.54 – Example of a cron job definition in /etc/crontab" src="img/B19682_08_54.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.54 – Example of a cron job definition in /etc/crontab</p>
<p>We believe that the preceding screenshot is self-explanatory. Now, let’s set up a new <code>cron</code> job for our updating script. We will use the <code>crontab -e</code> command. This command will use the default shell text editor, which in our case (in Fedora) is Vim. Running the <code>crontab -e</code> command will start a new Vim instance where the job should be written. Here is our code:</p>
<pre class="console">
00 23 * * 0 packt /home/packt/update_script.sh</pre> <p>Let’s explain this. In the preceding example, we set the new update script file to run at 23:00 every Sunday. The user that is running it is <code>packt</code>.</p>
<p>Once the line of code is created, you can check if the <code>cron</code> job was created by using the <code>crontab -l</code> command. If you <a id="_idIndexMarker1388"/>want to see the <code>cron</code> jobs of certain users, you can use the following command:</p>
<pre class="console">
sudo crontab -u packt -l</pre> <p>Here, <code>packt</code> is our user. The following snippet shows the code, which can be enhanced inside <code>crontab</code> with an output and error message redirection to <code>/dev/null</code>. This could be useful when we don’t want to see the command’s output or if any errors occur and we don’t need to see them. The line would be modified as follows:</p>
<pre class="console">
00 23 * * 0 packt /home/packt/update_script.sh &gt; /dev/null 2&gt;&amp;1</pre> <p><code>crontab</code> is a powerful tool <a id="_idIndexMarker1389"/>that will prove of great help whenever you need to schedule tasks in Linux. However, it is not the only tool available for the job. Feel free to explore other tools available, such as the <code>at</code> command. Next, we will go through another short script for backing up files.</p>
<h3>A backup script example</h3>
<p>Another common use for scripting is for <strong class="bold">backing up</strong> files. We will create a new script for this task and we will schedule it <a id="_idIndexMarker1390"/>according to our needs. The script’s code is shown in the following screenshot:</p>
<div><div><img alt="Figure 8.55 – A short backup script" src="img/B19682_08_55.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.55 – A short backup script</p>
<p>The code is backing up the <code>/home/packt</code> directory to the <code>/mnt/backup</code> directory. The contents of <code>/home/packt</code> will be archived using the <code>tar</code> command and saved as <code>.tgz</code> files using the current date and<a id="_idIndexMarker1391"/> hostname for the filename.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Using the date format can be daunting and intimidating at first, but knowing how to use it in your scripts will prove invaluable. Use the <code>date --help</code> command for more information.</p>
<p>In the next subsection, we will show you how to create a small random password generator in Bash.</p>
<h3>A random password generator script</h3>
<p>Keeping your online or local accounts secure is extremely important, so secure passwords should be used as a general rule. We<a id="_idIndexMarker1392"/> will provide you with an example of a script that generates random passwords.</p>
<p>There are many password generators available to use in Linux, but we thought that it would be fun if you created such a small script by yourself. One default password-generating app available in Bash is <code>pwmake</code>, for example. However, we will create our own password-generating script. We will use <code>openssl</code> and an encoding mechanism called <code>base64</code>. For more information, go to <a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64">https://developer.mozilla.org/en-US/docs/Glossary/Base64</a>. Keep in mind that there are many other ways to generate random characters in Linux, one highly used being the <code>/dev/urandom</code> pseudo-random number generator. Feel free to <a id="_idIndexMarker1393"/>explore as many ways as you like. In the meantime, here is our code for the password-generating script:</p>
<div><div><img alt="Figure 8.56 – Password-generating script" src="img/B19682_08_56.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.56 – Password-generating script</p>
<p>When running the script, you will be prompted to provide the number of characters you want to use and the number of passwords to be generated:</p>
<div><div><img alt="Figure 8.57 – The output of running the password-generating script" src="img/B19682_08_57.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.57 – The output of running the password-generating script</p>
<p>Scripting is an invaluable task you should master. We barely scratched the surface of shell scripting, but the information in this chapter should give you a good start so that you can start developing sysadmin scripts.</p>
<p>In the next subsection, we will <a id="_idIndexMarker1394"/>show you how to package your scripts into full-fledged apps that can be installed on the Linux command line. This is an addition to <a href="B19682_03.xhtml#_idTextAnchor075"><em class="italic">Chapter 3</em></a>, where you learned about Linux package management.</p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor190"/>Packaging scripts</h2>
<p>Bash scripts are pieces of software like any other, so they can be deployed with Linux distributions as platform-specific<a id="_idIndexMarker1395"/> packages. Just like you would package any other piece of software code, you can package a piece of shell scripting code. In this section, as an add-on to the knowledge you gathered in <a href="B19682_03.xhtml#_idTextAnchor075"><em class="italic">Chapter 3</em></a>, we will show you how to package a Bash script. As stated before, the information provided here can easily be used for other software sources (usually, in Linux, there is C/C++, Python, Rust, Java, or Go). In the next subsection, we will show you how to create an RPM package for RHEL-based distributions. We will use Fedora Linux 37 in our example.</p>
<h3>Creating RPM packages from source</h3>
<p>To create an RPM package, we will use the password generator script we developed in the previous section. Before <a id="_idIndexMarker1396"/>going into more details, we’ll provide a<a id="_idIndexMarker1397"/> short word on programming language types and where Bash fits in.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Usually, software programs are developed using human-readable source code. This code needs to be translated into machine code so that the computer will understand it. There are several large generic types of programming languages: <strong class="bold">interpreted</strong> (such as Python or Bash – which is a CLI language but still considered an interpreted language) and <strong class="bold">compiled</strong> (such as C/C++, Java, and Go) are the widely known ones. The Bash source code is executed line by line, without prior compilation into specific machine code. For more information, check out <a href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type">https://en.wikipedia.org/wiki/List_of_programming_languages_by_type</a>.</p>
<p>Often, the software source code is distributed in the form of compressed archives (<code>.tar.gz</code> files or tarballs) that are then packaged into RPM packages. The archive usually consists of the source code file and a license file. This license file offers information about the type of license the software<a id="_idIndexMarker1398"/> is distributed with. In the case of <strong class="bold">free and open source software</strong> (<strong class="bold">FOSS</strong>), the license is usually GPLv3<a id="_idIndexMarker1399"/> or GLPLv3, but other types such as the MIT license or Apache and BSD licenses are also used.</p>
<p class="callout-heading">Important note</p>
<p class="callout">For detailed information on FOSS license types, check out <a href="https://en.wikipedia.org/wiki/Comparison_of_free_and_open-source_software_licenses">https://en.wikipedia.org/wiki/Comparison_of_free_and_open-source_software_licenses</a>.</p>
<p>The following are the necessary steps for creating an RPM package from a Bash script:</p>
<ol>
<li><code>passgen-0.1</code>.</li>
<li><code>LICENSE.txt</code> and placed inside the newly created directory. We will use the GPLv3 open source license. The text to be added to your file can be found under the <em class="italic">How to Apply These Terms to Your New Programs</em> section at <a href="https://www.gnu.org/licenses">https://www.gnu.org/licenses</a>.</li>
<li><code>passgen_script.sh</code> file inside the new directory and change its name to <code>passgen-0.1.sh</code>.</li>
<li><code>passgen-0.1.sh</code> script to the Filesystem Hierarchy Standard <code>$PATH</code> using the <code>install</code> command. We use the <code>install</code> command because our simple Bash script does not need any dependencies:<pre class="source-code">
<code>passgen</code> script without using the full path.</p></li> <li><code>tar.gz</code> archive with the following command:<pre class="source-code">
<code>rpmdevtools</code> package. We can install it using the following command:<pre class="source-code">
<strong class="bold">sudo dnf install rpmdevtools</strong></pre><p class="list-inset">This will install all additional<a id="_idIndexMarker1402"/> packages and dependencies to set up the packaging workspace.</p></li> <li><strong class="bold">Set up the workspace</strong>: To set up the workspace, we will run the following application:<pre class="source-code">
<code>rpmbuild</code> directory and sub-directories inside your home directory. The new <code>rpmbuild</code> directory has the following structure:</p></li> </ol>
<div><div><img alt="Figure 8.58 – The rpmbuild’s directory structure" src="img/B19682_08_58.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.58 – The rpmbuild’s directory structure</p>
<p class="list-inset">The <code>BUILD</code> directory contains information about the build process; the <code>RPMS</code> directory contains binary RPMs; the <code>SOURCES</code> directory contains the tarball of the compressed source code; the <code>SPECS</code> directory contains the SPEC file; and the <code>SRPMS</code> directory contains source RPMs.</p>
<ol>
<li value="8"><code>~/rpmbuild/SOURCES</code> directory with the following command (from within the <code>passgen-0.1</code> directory):<pre class="source-code">
<code>SPEC</code> file by running the <code>rpmdev-newspec</code> command from inside the <code>~/</code><code>rpmbuild/SPECS</code> directory:<pre class="source-code">
<code>~/rpmbuild/SPECS/</code> directory, after which you will see that a new<a id="_idIndexMarker1404"/> file called <code>passgen.spec</code> was created.</p><p class="list-inset">The new <code>SPEC</code> file contains automatically generated lines with specific RPM macros defined. We will not get into much detail about macros, but you can find more information at <a href="https://rpm-software-management.github.io/rpm/manual/macros.html">https://rpm-software-management.github.io/rpm/manual/macros.html</a>. As Bash is an interpreted language, some default specifications from the <code>SPEC</code> file are not needed, such as <code>BuildRequires</code>, which was deleted. For the <code>%build</code> section, we did not provide any information as Bash does not need anything specific. The <code>SPEC</code> file is shown in the following screenshot:</p></li> </ol>
<div><div><img alt="Figure 8.59 – The SPEC file’s entries" src="img/B19682_08_59.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.59 – The SPEC file’s entries</p>
<ol>
<li value="10"><code>SPEC</code> file, but there are other use cases, such as building an RPM <a id="_idIndexMarker1406"/>from a <code>rpmbuild</code>, but the options are different. When building source RPMs, we will use the <code>-bs</code> option, when rebuilding RPMs from source, we will use the <code>--rebuild</code> option, and when building binary RPMs from source, we will use the <code>-bb</code> option. In our case, we will create a binary from source and use the following command:<pre class="source-code">
<code>.rpm</code> file was created. We can check this at <code>~/rpmbuild/RPMS/</code>, where we will have a new directory based on the CPU <a id="_idIndexMarker1408"/>architecture. In our case, we will have a new <code>noarch</code> directory that contains the <code>.rpm</code> file for our<a id="_idIndexMarker1409"/> password generator. The following is the output:</p></li> </ol>
<div><div><img alt="Figure 8.60 – The new RPM binary package" src="img/B19682_08_60.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.60 – The new RPM binary package</p>
<p>Here you are, building your very first RPM binary package from a Bash script file! You can do this for any type of source file you might develop. Building binary packages is not a very difficult task, and with good documentation about the specifics of macros used in the <code>SPEC</code> file, you are good to go. More information about the available documentation on this matter can be found in the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor191"/>Summary</h1>
<p>In this chapter, you learned how to create Bash scripts in Linux. You now know about shell variables and script variables, as well as how to use programming structures such as loops, conditionals, and arrays inside scripts. You now further understand how interprocess communication works. The skills you have learned will help you create scripts in any Linux distribution. When you are creating scripts, you will put your text editor knowledge into action too. You will use the skills that you’ve learned regarding Bash scripting in many aspects of your everyday job as a system administrator too.</p>
<p>In the next chapter, you will learn how to manage security in Linux, the access control mechanisms, AppArmor and SELinux, and firewalls. This skill is important for any administrator and must be part of any advanced training.</p>
<h1 id="_idParaDest-176"><a id="_idTextAnchor192"/>Questions</h1>
<p>In this chapter, we covered Linux Bash scripting. Here are some questions for you to test your knowledge and for further practice:</p>
<ol>
<li>What are arrays and how are they used in Bash scripts? Can there be hybrid types?<p class="list-inset"><strong class="bold">Hint</strong>: Think of their types, how they are defined, and how they are used.</p></li>
<li>What is an infinite loop?<p class="list-inset"><strong class="bold">Hint</strong>: This is something you would not like to use but should know how to escape if needed.</p></li>
<li>How many types of loops can be used in a Bash script?<p class="list-inset"><strong class="bold">Hint</strong>: Not that many, but more than conditional loops.</p></li>
<li>Find out how to build a DEB binary package.<p class="list-inset"><strong class="bold">Hint</strong>: Use the examples from Debian, which can be found at <a href="https://www.debian.org/doc/manuals/maint-guide/build.en.html">https://www.debian.org/doc/manuals/maint-guide/build.en.html</a> and <a href="https://wiki.debian.org/HowToPackageForDebian">https://wiki.debian.org/HowToPackageForDebian</a>.</p></li>
</ol>
<h1 id="_idParaDest-177"><a id="_idTextAnchor193"/>Further reading</h1>
<p>For more information about what was covered in this chapter, please refer to the following resources:</p>
<ul>
<li><em class="italic">Linux Administration Best Practices</em>, by Scott Alan Miller, published by Packt</li>
<li><em class="italic">Linux Command Line and Shell Scripting Techniques</em>, by Vedran Dakic and Jasmin Redzepagic, published by Packt</li>
<li>Official documentation from <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/packaging_and_distributing_software/index">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/packaging_and_distributing_software/index</a>, <a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/">https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/</a> (RPM macros), and <a href="http://rpm.org">rpm.org</a></li>
</ul>
</div>
</body></html>