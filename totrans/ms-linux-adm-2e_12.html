<html><head></head><body>
<div id="_idContainer429">
<h1 class="chapter-number" id="_idParaDest-239"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-240"><span class="koboSpan" id="kobo.2.1">Managing C</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.3.1">ontainers with Docker</span></h1>
<p><span class="koboSpan" id="kobo.4.1">In this chapter, you will learn about one of the most well-known tools for creating and managing containers – </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Docker</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">The topics in this chapter will prepare you for the future of Linux, as it is the foundation of every modern cloud technology. </span><span class="koboSpan" id="kobo.6.3">If you wish to remain up to date in a constantly changing landscape, this chapter will be the essential starting point for </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">your journey.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Linux containers</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">with Docker</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">with </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.16.1">Dockerfiles</span></strong></span></li>
<li><span class="koboSpan" id="kobo.17.1">Deploying a containerized application </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">with Docker</span></span></li>
</ul>
<h1 id="_idParaDest-241"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.19.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.20.1">No specific technical requirements are needed, just a working installation of Linux on your system. </span><span class="koboSpan" id="kobo.20.2">Both Ubuntu/Debian and Fedora/RHEL are equally suitable for this chapter’s exercises. </span><span class="koboSpan" id="kobo.20.3">We will use Debian GNU/Linux 12 for most of our examples, but where appropriate, we will discuss the specifics of Fedora Linux installation </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">and use.</span></span></p>
<h1 id="_idParaDest-242"><a id="_idTextAnchor260"/><span class="koboSpan" id="kobo.22.1">Understanding Linux containers</span></h1>
<p><span class="koboSpan" id="kobo.23.1">As we have demonstrated in the previous chapter, there are two main types of virtualization: </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">virtual machine</span></strong><span class="koboSpan" id="kobo.25.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.26.1">VM</span></strong><span class="koboSpan" id="kobo.27.1">)</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">-based</span></strong><span class="koboSpan" id="kobo.29.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">container-based</span></strong><span class="koboSpan" id="kobo.31.1">. </span><span class="koboSpan" id="kobo.31.2">We discussed VM-based virtualization in the previous chapter, and now it is time to explain what containers are. </span><span class="koboSpan" id="kobo.31.3">At a very basic, conceptual level, containers are similar to VMs. </span><span class="koboSpan" id="kobo.31.4">They have similar purposes – allowing an isolated environment to run – but they are different in so many ways that they can hardly be called similar. </span><span class="koboSpan" id="kobo.31.5">Let’s compare these two concepts in </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">more detail.</span></span></p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.33.1">Comparing containers and VMs</span></h2>
<p><span class="koboSpan" id="kobo.34.1">As you</span><a id="_idIndexMarker1805"/><span class="koboSpan" id="kobo.35.1"> already know, a VM emulates the machine’s hardware and uses it as if there were several machines available. </span><span class="koboSpan" id="kobo.35.2">By comparison, containers do not replicate the physical machine’s hardware; they do not </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">emulate anything.</span></span></p>
<p><span class="koboSpan" id="kobo.37.1">A container </span><a id="_idIndexMarker1806"/><span class="koboSpan" id="kobo.38.1">shares the base OS kernel with shared libraries and binaries needed for certain applications to run. </span><span class="koboSpan" id="kobo.38.2">The applications are contained inside the container, isolated from the rest of the system. </span><span class="koboSpan" id="kobo.38.3">They also share a network interface with the host to offer similar connectivity to </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">a VM.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">Containers run on top </span><a id="_idIndexMarker1807"/><span class="koboSpan" id="kobo.41.1">of a </span><strong class="bold"><span class="koboSpan" id="kobo.42.1">container engine</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">Container engines offer OS-level virtualization, used to deploy and test applications by using only the requisite libraries and dependencies. </span><span class="koboSpan" id="kobo.43.3">This way, containers make sure that applications can run on any machine by providing the same expected behavior as intended by the developer. </span><span class="koboSpan" id="kobo.43.4">The following is a visual comparison between containers </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">and VMs:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer405">
<span class="koboSpan" id="kobo.45.1"><img alt="Figure 12.1 – Containers versus VMs (general scheme)" src="image/B19682_12_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.46.1">Figure 12.1 – Containers versus VMs (general scheme)</span></p>
<p><span class="koboSpan" id="kobo.47.1">As you can see, the containers only use</span><a id="_idIndexMarker1808"/><span class="koboSpan" id="kobo.48.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">userspace</span></strong><span class="koboSpan" id="kobo.50.1">, sharing the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">OS-level architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Historically speaking, containerization has been around for some time now. </span><span class="koboSpan" id="kobo.52.2">With the Unix OS, </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">chroot</span></strong><span class="koboSpan" id="kobo.54.1"> has </span><a id="_idIndexMarker1809"/><span class="koboSpan" id="kobo.55.1">been the tool used for containerization </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">since 1982.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">On Linux, some of the </span><a id="_idIndexMarker1810"/><span class="koboSpan" id="kobo.58.1">newest and most frequently used tools</span><a id="_idIndexMarker1811"/><span class="koboSpan" id="kobo.59.1"> are </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Linux containers</span></strong><span class="koboSpan" id="kobo.61.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.62.1">LXC</span></strong><span class="koboSpan" id="kobo.63.1">), with </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">LXD</span></strong><span class="koboSpan" id="kobo.65.1"> as a </span><a id="_idIndexMarker1812"/><span class="koboSpan" id="kobo.66.1">newer and extended version of the former, introduced in 2008, and Docker, introduced</span><a id="_idIndexMarker1813"/><span class="koboSpan" id="kobo.67.1"> in 2013. </span><span class="koboSpan" id="kobo.67.2">Why this LXC/LXD nomenclature? </span><span class="koboSpan" id="kobo.67.3">Well, LXC was the first kid on the containers block, with LXD being a newer, redesigned version </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">In the next section, we will dissect the underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">container technology.</span></span></p>
<h2 id="_idParaDest-244"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.71.1">Understanding the underlying container technology</span></h2>
<p><span class="koboSpan" id="kobo.72.1">As mentioned earlier, LXC was</span><a id="_idIndexMarker1814"/><span class="koboSpan" id="kobo.73.1"> one of the earliest forms of containers, introduced 12 years ago. </span><span class="koboSpan" id="kobo.73.2">The newer form of containers, and the ones that changed the entire container landscape and started all the DevOps hype (more on this in </span><a href="B19682_14.xhtml#_idTextAnchor299"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.74.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.75.1">), is called Docker. </span><span class="koboSpan" id="kobo.75.2">Containers do not abstract the hardware level as hypervisors do. </span><span class="koboSpan" id="kobo.75.3">They use a specific userspace interface that benefits from the kernel’s techniques to isolate specific resources. </span><span class="koboSpan" id="kobo.75.4">By using Linux containers, you can replicate a default Linux system without using a different kernel, as you would do by using </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">a VM.</span></span></p>
<p><span class="koboSpan" id="kobo.77.1">What made LXC appealing when it first appeared were the APIs it uses for multiple programming languages, including Python 3, Go, Ruby, and Haskell. </span><span class="koboSpan" id="kobo.77.2">So, even though LXC is no longer that popular, it is still worth knowing. </span><span class="koboSpan" id="kobo.77.3">Docker has taken the crown and center stage in container engine usage. </span><span class="koboSpan" id="kobo.77.4">We will not use LXC/LXD in our examples, but we will still discuss it for backward compatibility purposes. </span><span class="koboSpan" id="kobo.77.5">As of the time of writing this book, there are two supported versions of LXC, version 4.0, with support until June 2025, and version 5.0, with support until </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">June 2027.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">According to its developers, LXC uses features to create an isolated environment that is as close as possible to a default Linux installation. </span><span class="koboSpan" id="kobo.79.2">Among the kernel technologies that it uses, we could </span><a id="_idIndexMarker1815"/><span class="koboSpan" id="kobo.80.1">bring up the most important one, which is the backbone of any container inside </span><a id="_idIndexMarker1816"/><span class="koboSpan" id="kobo.81.1">Linux: kernel </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">namespaces</span></strong><span class="koboSpan" id="kobo.83.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">cgroups</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">Besides those, there are still chroots and security profiles for both AppArmor </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">and SELinux.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Let’s now explain these basic features that Linux </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">containers use.</span></span></p>
<h3><span class="koboSpan" id="kobo.89.1">Linux namespaces</span></h3>
<p><span class="koboSpan" id="kobo.90.1">What are </span><strong class="bold"><span class="koboSpan" id="kobo.91.1">Linux namespaces</span></strong><span class="koboSpan" id="kobo.92.1">? </span><span class="koboSpan" id="kobo.92.2">In a</span><a id="_idIndexMarker1817"/><span class="koboSpan" id="kobo.93.1"> nutshell, namespaces are kernel global system resources responsible for the isolation that containers provide. </span><span class="koboSpan" id="kobo.93.2">Namespaces wrap a global system resource inside an abstraction layer. </span><span class="koboSpan" id="kobo.93.3">This process fools any app process that is running inside the namespace into believing that the resource it is using is its own. </span><span class="koboSpan" id="kobo.93.4">A namespace provides isolation at a logical level inside the kernel and also provides visibility for any </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">running processes.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">To better understand how namespaces work, think of any user on a Linux system and how it can view different system resources and processes. </span><span class="koboSpan" id="kobo.95.2">As a user, you can see the global system resources, the running processes, other users, and kernel modules, for example. </span><span class="koboSpan" id="kobo.95.3">This amount of transparency could be harmful when wanting to use containers as virtualized environments at the OS level. </span><span class="koboSpan" id="kobo.95.4">As it cannot provide the encapsulation and emulation level of a VM, the container engine must overcome this somehow, and the kernel’s low-level mechanisms of virtualization of the environment come in the form of namespaces </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">and cgroups.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">There are several types of namespaces inside the Linux kernel, and we will describe </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">them briefly:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.99.1">Mount</span></strong><span class="koboSpan" id="kobo.100.1">: They</span><a id="_idIndexMarker1818"/><span class="koboSpan" id="kobo.101.1"> restrict visibility for available filesystem mount points within a single namespace so that processes from that namespace have visibility of the filesystem list; processes can have their own root filesystem and different private or </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">shared mounts</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Unix Time Sharing</span></strong><span class="koboSpan" id="kobo.104.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.105.1">UTS</span></strong><span class="koboSpan" id="kobo.106.1">): This</span><a id="_idIndexMarker1819"/><span class="koboSpan" id="kobo.107.1"> isolates the system’s hostname and </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">domain name</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.109.1">Interprocess Communication</span></strong><span class="koboSpan" id="kobo.110.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.111.1">IPC</span></strong><span class="koboSpan" id="kobo.112.1">): This</span><a id="_idIndexMarker1820"/><span class="koboSpan" id="kobo.113.1"> allows processes to have their own IPC shared memory, queues, </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">and semaphores</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Process Identification</span></strong><span class="koboSpan" id="kobo.116.1">: This allows mapping </span><a id="_idIndexMarker1821"/><span class="koboSpan" id="kobo.117.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">process IDs</span></strong><span class="koboSpan" id="kobo.119.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">PIDs</span></strong><span class="koboSpan" id="kobo.121.1">) with the possibility of </span><a id="_idIndexMarker1822"/><span class="koboSpan" id="kobo.122.1">a process with PID 1 (the root of the process tree) to spin off a new tree with its own root process; processes inside a PID namespace only see the processes inside the same </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">PID namespace</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Network</span></strong><span class="koboSpan" id="kobo.125.1">: Abstraction</span><a id="_idIndexMarker1823"/><span class="koboSpan" id="kobo.126.1"> at the network protocol level; processes inside a network namespace have a private network stack with private network interfaces, routing tables, sockets, and </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">iptables rules</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.128.1">User</span></strong><span class="koboSpan" id="kobo.129.1">: This </span><a id="_idIndexMarker1824"/><span class="koboSpan" id="kobo.130.1">allows mapping of UID and GID, including root UID 0 as a </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">non-privileged user</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">cgroup</span></strong><span class="koboSpan" id="kobo.133.1">: A</span><a id="_idIndexMarker1825"/><span class="koboSpan" id="kobo.134.1"> cgroup namespace process can see filesystem paths relative to the root of </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">the namespace</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.136.1">The namespaces can be viewed by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">lsns</span></strong><span class="koboSpan" id="kobo.138.1"> command in Linux. </span><span class="koboSpan" id="kobo.138.2">The following is an excerpt from the </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">command’s output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer406">
<span class="koboSpan" id="kobo.140.1"><img alt="Figure 12.2 – Using lsns to view the available namespaces" src="image/B19682_12_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.141.1">Figure 12.2 – Using lsns to view the available namespaces</span></p>
<p><span class="koboSpan" id="kobo.142.1">In the following section, we will break down cgroups as the second major building block </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">of containers.</span></span></p>
<h3><span class="koboSpan" id="kobo.144.1">Linux cgroups</span></h3>
<p><span class="koboSpan" id="kobo.145.1">What are </span><a id="_idIndexMarker1826"/><span class="koboSpan" id="kobo.146.1">cgroups? </span><span class="koboSpan" id="kobo.146.2">Their </span><a id="_idIndexMarker1827"/><span class="koboSpan" id="kobo.147.1">name comes from </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">control groups</span></strong><span class="koboSpan" id="kobo.149.1">, and they are kernel features that restrict and manage resource allocation to processes. </span><span class="koboSpan" id="kobo.149.2">Cgroups control how memory, CPU, I/O, and network are used. </span><span class="koboSpan" id="kobo.149.3">They provide a mechanism that determines specific sets of tasks that limit how many resources a process can use. </span><span class="koboSpan" id="kobo.149.4">They are based on the</span><a id="_idIndexMarker1828"/><span class="koboSpan" id="kobo.150.1"> concept of </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">hierarchies</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">Every child group will inherit the attributes of its parent group, and multiple cgroups hierarchies can exist at the same time in </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">one system.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Cgroups and namespaces combined are creating the isolation that containers are built upon. </span><span class="koboSpan" id="kobo.154.2">By using cgroups and namespaces, resources are allocated and managed for each container separately. </span><span class="koboSpan" id="kobo.154.3">Compared to VMs, containers are lightweight and run as </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">isolated entities.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">As stated earlier, there are two types of containers used, LXC and Docker. </span><span class="koboSpan" id="kobo.156.2">As we have already discussed LXC, let us see in the following section what </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">Docker is.</span></span></p>
<h2 id="_idParaDest-245"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.158.1">Understanding Docker</span></h2>
<p><span class="koboSpan" id="kobo.159.1">Docker, similar to LXC/LXD, is based, among other technologies, on kernel namespaces and cgroups. </span><span class="koboSpan" id="kobo.159.2">Docker</span><a id="_idIndexMarker1829"/><span class="koboSpan" id="kobo.160.1"> is a platform that is used for developing and shipping applications. </span><span class="koboSpan" id="kobo.160.2">The Docker platform provides the underlying infrastructure for containers to operate securely. </span><span class="koboSpan" id="kobo.160.3">Docker containers are lightweight entities that run directly on the host’s kernel. </span><span class="koboSpan" id="kobo.160.4">The platform offers features such as tools to create and manage isolated, containerized applications. </span><span class="koboSpan" id="kobo.160.5">Thus, the container is the base unit used for application development, testing, and distribution. </span><span class="koboSpan" id="kobo.160.6">When apps are production-ready and fit for deployment, they can be shipped as containers or as orchestrated services (we will discuss orchestration in </span><a href="B19682_16.xhtml#_idTextAnchor342"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.161.1">Chapter 16</span></em></span></a><span class="koboSpan" id="kobo.162.1">, </span><em class="italic"><span class="koboSpan" id="kobo.163.1">Deploying Applications</span></em><em class="italic"> </em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.164.1">with Kubernetes</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">In the following diagram, we will show you how the </span><a id="_idIndexMarker1830"/><span class="koboSpan" id="kobo.167.1">Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">architecture works:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer407">
<span class="koboSpan" id="kobo.169.1"><img alt="Figure 12.3 – Docker architecture" src="image/B19682_12_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.170.1">Figure 12.3 – Docker architecture</span></p>
<p><span class="koboSpan" id="kobo.171.1">Let’s explain</span><a id="_idIndexMarker1831"/><span class="koboSpan" id="kobo.172.1"> the preceding diagram. </span><span class="koboSpan" id="kobo.172.2">Docker uses both namespaces and cgroups available in the Linux kernel, and is split into two </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">major components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.174.1">Container runtime</span></strong><span class="koboSpan" id="kobo.175.1">: The</span><a id="_idIndexMarker1832"/><span class="koboSpan" id="kobo.176.1"> overseeing authoritative structure that </span><a id="_idIndexMarker1833"/><span class="koboSpan" id="kobo.177.1">governs the specification for container runtimes is called the </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Open Container Initiative</span></strong><span class="koboSpan" id="kobo.179.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.180.1">OCI</span></strong><span class="koboSpan" id="kobo.181.1">) and </span><a id="_idIndexMarker1834"/><span class="koboSpan" id="kobo.182.1">defines the open industry standards for containers. </span><span class="koboSpan" id="kobo.182.2">The container runtime is split into the following for namespaces and </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">cgroups management:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.184.1">containerd</span></strong><span class="koboSpan" id="kobo.185.1"> is </span><a id="_idIndexMarker1835"/><span class="koboSpan" id="kobo.186.1">responsible for downloading Docker images and then </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">running them.</span></span></li><li><span class="koboSpan" id="kobo.188.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">runc</span></strong><span class="koboSpan" id="kobo.190.1"> component </span><a id="_idIndexMarker1836"/><span class="koboSpan" id="kobo.191.1">follows OCI specifications and is responsible for managing namespaces and cgroups for </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">each container.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.193.1"> According to the OCI, the runtime specification defines how to download an image, unpack it, and run it using a specific filesystem bundle. </span><span class="koboSpan" id="kobo.193.2">The OCI is part of the Linux Foundation. </span><span class="koboSpan" id="kobo.193.3">Docker donated </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">runc</span></strong><span class="koboSpan" id="kobo.195.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">containerd</span></strong><span class="koboSpan" id="kobo.197.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.198.1">Cloud Native Computing Foundation</span></em><span class="koboSpan" id="kobo.199.1"> so that more organizations would be able to contribute to both. </span><span class="koboSpan" id="kobo.199.2">The following is a diagram showing the details of the Docker architecture, with the core components, the Docker engine and the container runtime, being shown </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">in detail:</span></span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer408">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 12.4 – Docker architecture details" src="image/B19682_12_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 12.4 – Docker architecture details</span></p>
<ul>
<li><span class="koboSpan" id="kobo.203.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">Docker engine</span></strong><span class="koboSpan" id="kobo.205.1">: This</span><a id="_idIndexMarker1837"/><span class="koboSpan" id="kobo.206.1"> engine is what is split into </span><a id="_idIndexMarker1838"/><span class="koboSpan" id="kobo.207.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">dockerd</span></strong><span class="koboSpan" id="kobo.209.1"> daemon, the </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">API</span></strong><span class="koboSpan" id="kobo.211.1"> interface, and the </span><strong class="bold"><span class="koboSpan" id="kobo.212.1">command-line interface</span></strong><span class="koboSpan" id="kobo.213.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.214.1">CLI</span></strong><span class="koboSpan" id="kobo.215.1">). </span><span class="koboSpan" id="kobo.215.2">The </span><a id="_idIndexMarker1839"/><span class="koboSpan" id="kobo.216.1">Docker engine </span><a id="_idIndexMarker1840"/><span class="koboSpan" id="kobo.217.1">comprises the API interface and the dockerd daemon, while the container runtime has two main components – the </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">containerd</span></strong><span class="koboSpan" id="kobo.219.1"> daemon</span><a id="_idIndexMarker1841"/><span class="koboSpan" id="kobo.220.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.221.1">runc</span></strong><span class="koboSpan" id="kobo.222.1"> for </span><a id="_idIndexMarker1842"/><span class="koboSpan" id="kobo.223.1">namespaces and cgroups management. </span><span class="koboSpan" id="kobo.223.2">Besides the components listed in the previous point, a number of other components are used to run and deploy Docker containers. </span><span class="koboSpan" id="kobo.223.3">Docker has a client-server architecture and the workflow involves a </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">host</span></strong><span class="koboSpan" id="kobo.225.1">, or server daemon, a </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">client</span></strong><span class="koboSpan" id="kobo.227.1">, and a </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">registry</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">The host consists of images and containers (downloaded from the registry), and the client provides the commands needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">manage containers.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.231.1">The workflow </span><a id="_idIndexMarker1843"/><span class="koboSpan" id="kobo.232.1">of these components is </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">as follows:</span></span></p><ul><li><span class="koboSpan" id="kobo.234.1">The dockerd daemon listens for API requests to manage services and objects (such as images, containers, networks, </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">and volumes).</span></span></li><li><span class="koboSpan" id="kobo.236.1">The client is the way for users to interact with the daemon through </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">the API.</span></span></li><li><span class="koboSpan" id="kobo.238.1">The registries store images, and Docker Hub is a public registry for anyone to use freely. </span><span class="koboSpan" id="kobo.238.2">In addition to this, there are private registries that can </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">be used.</span></span></li></ul><p class="list-inset"><span class="koboSpan" id="kobo.240.1">The following is a graphical representation of Docker’s workflow, showing the client component, the API, and </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">the daemon:</span></span></p></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer409">
<span class="koboSpan" id="kobo.242.1"><img alt="Figure 12.5 – Docker workflow" src="image/B19682_12_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.243.1">Figure 12.5 – Docker workflow</span></p>
<p><span class="koboSpan" id="kobo.244.1">Docker may </span><a id="_idIndexMarker1844"/><span class="koboSpan" id="kobo.245.1">seem difficult, even disarming, to a beginner. </span><span class="koboSpan" id="kobo.245.2">All the different components that work together, all those new typologies, and specific workflows are complicated. </span><span class="koboSpan" id="kobo.245.3">Do you feel like you know how Docker works just after reading this section? </span><span class="koboSpan" id="kobo.245.4">Of course not. </span><span class="koboSpan" id="kobo.245.5">The process of learning Docker has just begun. </span><span class="koboSpan" id="kobo.245.6">Having a strong foundation on which to build your Docker knowledge is extremely important. </span><span class="koboSpan" id="kobo.245.7">This is why, in the next section, we will show you how to </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">use Docker.</span></span></p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor264"/><span class="koboSpan" id="kobo.247.1">Working with Docker</span></h1>
<p><span class="koboSpan" id="kobo.248.1">We will </span><a id="_idIndexMarker1845"/><span class="koboSpan" id="kobo.249.1">use Debian GNU/Linux 12 for this section’s exercises, installed on a VM with 2 vCPUs and 2 GB of RAM as a host. </span><span class="koboSpan" id="kobo.249.2">But before we start installing Docker, let’s go into a little detail about how Docker, as an entity, operates, to help us identify which version to choose for our </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">use case.</span></span></p>
<h2 id="_idParaDest-247"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.251.1">Which Docker version to choose?</span></h2>
<p><span class="koboSpan" id="kobo.252.1">In order </span><a id="_idIndexMarker1846"/><span class="koboSpan" id="kobo.253.1">for the business to be viable, the corporation behind Docker (the Docker corporation) offers a series of products, all revolving around their primary product, Docker. </span><span class="koboSpan" id="kobo.253.2">In the</span><a id="_idIndexMarker1847"/><span class="koboSpan" id="kobo.254.1"> past, it had two different products </span><a id="_idIndexMarker1848"/><span class="koboSpan" id="kobo.255.1">available, the Docker </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">Community Edition</span></strong><span class="koboSpan" id="kobo.257.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.258.1">CE</span></strong><span class="koboSpan" id="kobo.259.1">) and the Docker </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">Enterprise Edition</span></strong><span class="koboSpan" id="kobo.261.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.262.1">EE</span></strong><span class="koboSpan" id="kobo.263.1">). </span><span class="koboSpan" id="kobo.263.2">Out of these two, only the EE version was responsible for the revenue </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">of Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Recently, the </span><a id="_idIndexMarker1849"/><span class="koboSpan" id="kobo.266.1">portfolio evolved to different products and offerings, such as </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">Docker Personal</span></strong><span class="koboSpan" id="kobo.268.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.269.1">Docker Pro</span></strong><span class="koboSpan" id="kobo.270.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Docker Team</span></strong><span class="koboSpan" id="kobo.272.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">Docker Business</span></strong><span class="koboSpan" id="kobo.274.1">. </span><span class="koboSpan" id="kobo.274.2">Among those, only </span><a id="_idIndexMarker1850"/><span class="koboSpan" id="kobo.275.1">Docker Personal is free to use; the other three products are subscription-based. </span><span class="koboSpan" id="kobo.275.2">Docker Personal is suitable for individual developers, education, and open source communities, but has some limitations (which can be seen here: </span><a href="https://www.docker.com/products/personal/"><span class="koboSpan" id="kobo.276.1">https://www.docker.com/products/personal/</span></a><span class="koboSpan" id="kobo.277.1">). </span><span class="koboSpan" id="kobo.277.2">Using Docker Personal implies the existence of a Docker user account, and it includes Docker Desktop for Linux (and all other major platforms) and Docker Engine </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">for servers.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">On the server side, Docker Engine is available for </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">x86</span></strong><span class="koboSpan" id="kobo.281.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">arm</span></strong><span class="koboSpan" id="kobo.283.1"> architectures using both </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">.deb</span></strong><span class="koboSpan" id="kobo.285.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">.rpm</span></strong><span class="koboSpan" id="kobo.287.1"> package formats and is available for Ubuntu, Debian, Fedora, and CentOS. </span><span class="koboSpan" id="kobo.287.2">For our examples, we will use Docker Personal. </span><span class="koboSpan" id="kobo.287.3">We will show you how to install Docker in the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">next section.</span></span></p>
<h2 id="_idParaDest-248"><a id="_idTextAnchor266"/><span class="koboSpan" id="kobo.289.1">Installing Docker</span></h2>
<p><span class="koboSpan" id="kobo.290.1">Depending </span><a id="_idIndexMarker1851"/><span class="koboSpan" id="kobo.291.1">on the version of your preferred Linux distribution that you choose, the package available inside the official repository may be out of date. </span><span class="koboSpan" id="kobo.291.2">Nevertheless, you have two options: one is to use the official package from our Linux distribution’s own repository, and the other is to download the latest available version from the official </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">Docker website.</span></span></p>
<p><span class="koboSpan" id="kobo.293.1">As we are using a fresh system, with no prior Docker installation, we will not need to worry about older versions of the software and possible incompatibilities with the new versions. </span><span class="koboSpan" id="kobo.293.2">We will use Docker’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">apt</span></strong><span class="koboSpan" id="kobo.295.1"> repository, which will ensure that our package versions will always be up to date. </span><span class="koboSpan" id="kobo.295.2">Remember that we are using a </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">Debian host.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">The procedure to install Docker is </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">as follows:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.299.1">First, add the requisite certificates for the Docker repository using the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.301.1">sudo apt update -y &amp;&amp; sudo apt install ca-certificates curl gnupg</span></strong></pre></li> <li><span class="koboSpan" id="kobo.302.1">In order to use the official Docker repository, you will need to add the Docker GPG key. </span><span class="koboSpan" id="kobo.302.2">For this, use the </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">following commands:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.304.1">sudo install -m 0755 -d /etc/apt/keyrings</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.305.1">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.306.1">sudo chmod a+r /etc/apt/keyrings/docker.gpg</span></strong></pre></li> <li><span class="koboSpan" id="kobo.307.1">Set up the</span><a id="_idIndexMarker1852"/><span class="koboSpan" id="kobo.308.1"> repository needed to install the version of Docker </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">we want:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.310.1">echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian $(. </span><span class="koboSpan" id="kobo.310.2">/etc/os-release &amp;&amp; echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></strong></pre></li> <li><span class="koboSpan" id="kobo.311.1">The next logical step is to update the repository list. </span><span class="koboSpan" id="kobo.311.2">When you do this, you should see the official Docker repository. </span><span class="koboSpan" id="kobo.311.3">Use the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.313.1">sudo apt update -y</span></strong></pre></li> <li><span class="koboSpan" id="kobo.314.1">Install the Docker packages. </span><span class="koboSpan" id="kobo.314.2">In our case, we will install the latest packages available using the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.316.1">sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span></strong></pre></li> <li><span class="koboSpan" id="kobo.317.1">To verify that you installed the packages from the official Docker repository and not the ones from the Debian repositories, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.319.1">apt-cache policy docker-ce</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.320.1">If the output shows the source from the </span><a href="http://docker.com"><span class="koboSpan" id="kobo.321.1">docker.com</span></a><span class="koboSpan" id="kobo.322.1"> website, this means that the source repository is the official </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">Docker one:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer410">
<span class="koboSpan" id="kobo.324.1"><img alt="Figure 12.6 – Verifying the source repository" src="image/B19682_12_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.325.1">Figure 12.6 – Verifying the source repository</span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.326.1">Check the </span><a id="_idIndexMarker1853"/><span class="koboSpan" id="kobo.327.1">status of the Docker daemon. </span><span class="koboSpan" id="kobo.327.2">It should be started right </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">after installation:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.329.1">sudo systemctl status docker</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.330.1">If everything went without issues, the output should show that the Docker daemon </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">is running.</span></span></p></li> <li><span class="koboSpan" id="kobo.332.1">At the time of installation, a group called </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">docker</span></strong><span class="koboSpan" id="kobo.334.1"> is created. </span><span class="koboSpan" id="kobo.334.2">In order to be able to use Docker, your user should be added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">docker</span></strong><span class="koboSpan" id="kobo.336.1"> group. </span><span class="koboSpan" id="kobo.336.2">The existing groups in Linux are inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">/etc/group</span></strong><span class="koboSpan" id="kobo.338.1"> file. </span><span class="koboSpan" id="kobo.338.2">You can list the last lines (new groups are appended at the end of the file) to see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">docker</span></strong><span class="koboSpan" id="kobo.340.1"> group as the last </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">one created:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.342.1">tail /etc/group</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.343.1">You can either add your existing user or create a new one. </span><span class="koboSpan" id="kobo.343.2">We will add our already existing user. </span><span class="koboSpan" id="kobo.343.3">Add the user with the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">following command:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.345.1">sudo usermod -aG docker ${USER}</span></strong></pre></li> <li><span class="koboSpan" id="kobo.346.1">After you add the user, log out and back in again and check whether you were added to the new group with the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.348.1">groups</span></strong></pre></li> <li><span class="koboSpan" id="kobo.349.1">You have completed the installation of Docker. </span><span class="koboSpan" id="kobo.349.2">Now you can enable the Docker daemon to begin at </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">system startup:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.351.1">sudo systemctl enable docker</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.352.1">Installing Docker is </span><a id="_idIndexMarker1854"/><span class="koboSpan" id="kobo.353.1">only the first step. </span><span class="koboSpan" id="kobo.353.2">Now let’s explore what we can do with it. </span><span class="koboSpan" id="kobo.353.3">In the following section, you will learn about the commands available </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">in Docker.</span></span></p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor267"/><span class="koboSpan" id="kobo.355.1">Using some Docker commands</span></h2>
<p><span class="koboSpan" id="kobo.356.1">Working </span><a id="_idIndexMarker1855"/><span class="koboSpan" id="kobo.357.1">with Docker means using its CLI. </span><span class="koboSpan" id="kobo.357.2">It has a significant number of sub-commands available. </span><span class="koboSpan" id="kobo.357.3">If you want to see them all, you should run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">docker -–help</span></strong><span class="koboSpan" id="kobo.359.1"> command. </span><span class="koboSpan" id="kobo.359.2">There are two main command </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">groups shown:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.361.1">The first group shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">management commands</span></span></li>
<li><span class="koboSpan" id="kobo.363.1">The second group shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">regular commands</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.365.1">We will not discuss all the commands in this section. </span><span class="koboSpan" id="kobo.365.2">We will only focus on the ones that you will need to get started </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">with Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">Before learning anything about the commands, let’s first perform a test to see whether the installation is working. </span><span class="koboSpan" id="kobo.367.2">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">docker run</span></strong><span class="koboSpan" id="kobo.369.1"> command to check whether we can access Docker Hub and run containers. </span><span class="koboSpan" id="kobo.369.2">Our testing command will be </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.371.1">
sudo docker run hello-world</span></pre> <p><span class="koboSpan" id="kobo.372.1">This command downloads an image from Docker Hub and runs it as a container. </span><span class="koboSpan" id="kobo.372.2">The following is a screenshot of </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">the output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer411">
<span class="koboSpan" id="kobo.374.1"><img alt="Figure 12.7 – Running the first docker run command" src="image/B19682_12_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.375.1">Figure 12.7 – Running the first docker run command</span></p>
<p><span class="koboSpan" id="kobo.376.1">The </span><a id="_idIndexMarker1856"/><span class="koboSpan" id="kobo.377.1">preceding screenshot is self-explanatory and a nice touch from the Docker team. </span><span class="koboSpan" id="kobo.377.2">It explains what the command did in the background using clear and easy-to-understand language. </span><span class="koboSpan" id="kobo.377.3">By running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">docker run</span></strong><span class="koboSpan" id="kobo.379.1"> command, you both learn about the workflow and the success of the installation. </span><span class="koboSpan" id="kobo.379.2">Also, it is one of the basic Docker commands that you will use </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">relatively often.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Let’s now dig deeper and search for other images available on Docker Hub. </span><span class="koboSpan" id="kobo.381.2">Let’s search for an Ubuntu image to run containers on. </span><span class="koboSpan" id="kobo.381.3">To search for the image, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">search</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.384.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.385.1">
docker search ubuntu</span></pre> <p><span class="koboSpan" id="kobo.386.1">The output of the command should list all the Ubuntu images available inside </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">Docker Hub:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer412">
<span class="koboSpan" id="kobo.388.1"><img alt="Figure 12.8 – Searching for the Ubuntu image" src="image/B19682_12_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.389.1">Figure 12.8 – Searching for the Ubuntu image</span></p>
<p><span class="koboSpan" id="kobo.390.1">As you can</span><a id="_idIndexMarker1857"/><span class="koboSpan" id="kobo.391.1"> see, the output has </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">five columns:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.393.1">NAME</span></strong><span class="koboSpan" id="kobo.394.1">: The first column shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">image’s name</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.396.1">DESCRIPTION</span></strong><span class="koboSpan" id="kobo.397.1">: The second column shows the description, which is a short text providing information about a </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">specific image</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.399.1">STARS</span></strong><span class="koboSpan" id="kobo.400.1">: The third column shows the number of stars it has (representing popularity based on </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">user opinion)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.402.1">OFFICIAL</span></strong><span class="koboSpan" id="kobo.403.1">: The fourth column shows whether that image is an official one supported by the company behind </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">the distribution/software</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.405.1">AUTOMATED</span></strong><span class="koboSpan" id="kobo.406.1">: The fifth column shows whether the image has </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">automated scripts</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.408.1">Once you find the image you are looking for, you can download it onto your system using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">docker pull</span></strong><span class="koboSpan" id="kobo.410.1"> command. </span><span class="koboSpan" id="kobo.410.2">Let us download the first image from the list shown in the preceding screenshot, the one called </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">ubuntu</span></strong><span class="koboSpan" id="kobo.412.1">. </span><span class="koboSpan" id="kobo.412.2">We will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.414.1">
docker pull ubuntu</span></pre> <p><span class="koboSpan" id="kobo.415.1">With this command, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">ubuntu</span></strong><span class="koboSpan" id="kobo.417.1"> image is downloaded locally onto your computer. </span><span class="koboSpan" id="kobo.417.2">Now, containers can be run using this image. </span><span class="koboSpan" id="kobo.417.3">To list the images that are already available on your computer, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">images</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.420.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer413">
<span class="koboSpan" id="kobo.421.1"><img alt="Figure 12.9 – Running the docker images command" src="image/B19682_12_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.422.1">Figure 12.9 – Running the docker images command</span></p>
<p><span class="koboSpan" id="kobo.423.1">Please </span><a id="_idIndexMarker1858"/><span class="koboSpan" id="kobo.424.1">note the small size of the Ubuntu Docker image. </span><span class="koboSpan" id="kobo.424.2">You may be wondering why it is so small. </span><span class="koboSpan" id="kobo.424.3">This is because Docker images contain only the base and minimum packages needed to run. </span><span class="koboSpan" id="kobo.424.4">This makes the container running on the image extremely efficient in </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">resource usage.</span></span></p>
<p><span class="koboSpan" id="kobo.426.1">The few commands we showed you in this section are the most basic ones needed to start using Docker. </span><span class="koboSpan" id="kobo.426.2">Now that you know how to download an image, let’s show you how to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">Docker containers.</span></span></p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor268"/><span class="koboSpan" id="kobo.428.1">Managing Docker containers</span></h2>
<p><span class="koboSpan" id="kobo.429.1">In </span><a id="_idIndexMarker1859"/><span class="koboSpan" id="kobo.430.1">this section, we will learn how to run, list, start, stop, and remove Docker containers, and also how to </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">manage networking.</span></span></p>
<h3><span class="koboSpan" id="kobo.432.1">Running containers</span></h3>
<p><span class="koboSpan" id="kobo.433.1">We will </span><a id="_idIndexMarker1860"/><span class="koboSpan" id="kobo.434.1">use the Ubuntu image that we just downloaded. </span><span class="koboSpan" id="kobo.434.2">To run it, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">docker run</span></strong><span class="koboSpan" id="kobo.436.1"> command with two arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">-i</span></strong><span class="koboSpan" id="kobo.438.1"> for interactive output and </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">-t</span></strong><span class="koboSpan" id="kobo.440.1"> for starting a pseudo TTY, which will give us interactive access to </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">the shell:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.442.1">
docker run -it ubuntu</span></pre> <p><span class="koboSpan" id="kobo.443.1">You will notice that your command prompt will change. </span><span class="koboSpan" id="kobo.443.2">Now it will contain the container ID. </span><span class="koboSpan" id="kobo.443.3">The user, by default, is the root user. </span><span class="koboSpan" id="kobo.443.4">Basically, you are now inside an Ubuntu image, so you can use it exactly as you would use any Ubuntu command line. </span><span class="koboSpan" id="kobo.443.5">You can update the repository, install the requisite applications, remove unnecessary apps, and so on. </span><span class="koboSpan" id="kobo.443.6">Any changes that you make to the container image stay inside the container. </span><span class="koboSpan" id="kobo.443.7">To exit the container, simply type </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">exit</span></strong><span class="koboSpan" id="kobo.445.1">. </span><span class="koboSpan" id="kobo.445.2">Now, we will show you how to list containers, but before we do that, we should ask you not to close the terminal in which the Ubuntu-based container is </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">currently running.</span></span></p>
<h3><span class="koboSpan" id="kobo.447.1">Listing containers</span></h3>
<p><span class="koboSpan" id="kobo.448.1">You can</span><a id="_idIndexMarker1861"/><span class="koboSpan" id="kobo.449.1"> open a new terminal on your system and check to see how many Docker containers are actively running, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">In the command’s output, you will see the ID of the container that is running in the other terminal. </span><span class="koboSpan" id="kobo.453.2">There are also details about the command that runs inside the container and the </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">creation time.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">There are a couple of arguments that you can use with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1"> command:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.459.1">If you want to see all active and inactive containers, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">docker ps -</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">a</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.462.1"> command</span></span></li>
<li><span class="koboSpan" id="kobo.463.1">If you want to see the latest created container, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.464.1">docker ps -</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">l</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.466.1"> command</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.467.1">The following is the output of all three variants of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.470.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer414">
<span class="koboSpan" id="kobo.471.1"><img alt="Figure 12.10 – Listing containers with the docker ps command" src="image/B19682_12_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.472.1">Figure 12.10 – Listing containers with the docker ps command</span></p>
<p><span class="koboSpan" id="kobo.473.1">In the output, you will also see names assigned to containers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">amazing_hopper</span></strong><span class="koboSpan" id="kobo.475.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">recursing_murdock</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">Those are random names automatically given to containers by the daemon. </span><span class="koboSpan" id="kobo.477.3">Now, we will learn how to start, stop, and remove </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">running containers.</span></span></p>
<h3><span class="koboSpan" id="kobo.479.1">Starting, stopping, and removing running containers</span></h3>
<p><span class="koboSpan" id="kobo.480.1">When</span><a id="_idIndexMarker1862"/><span class="koboSpan" id="kobo.481.1"> managing containers, such as starting and stopping, you can refer to them by using the container ID or the name assigned by Docker. </span><span class="koboSpan" id="kobo.481.2">Let’s now show you how to start, stop, and remove </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">a container.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">To start a Docker container, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">docker start</span></strong><span class="koboSpan" id="kobo.485.1"> command, followed by the name or ID of the container. </span><span class="koboSpan" id="kobo.485.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">an example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.487.1">
docker start amazing_hopper</span></pre> <p><span class="koboSpan" id="kobo.488.1">To stop a </span><a id="_idIndexMarker1863"/><span class="koboSpan" id="kobo.489.1">container, use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">docker stop</span></strong><span class="koboSpan" id="kobo.491.1"> command, followed by the name of the ID of the container. </span><span class="koboSpan" id="kobo.491.2">Here is </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">an example:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.493.1">
docker stop amazing_hopper</span></pre> <p><span class="koboSpan" id="kobo.494.1">In our case, the Ubuntu container, named </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">amazing_hopper</span></strong><span class="koboSpan" id="kobo.496.1">, is already running, so the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">start</span></strong><span class="koboSpan" id="kobo.498.1"> command will not do anything. </span><span class="koboSpan" id="kobo.498.2">But the </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">stop</span></strong><span class="koboSpan" id="kobo.500.1"> command will stop the container. </span><span class="koboSpan" id="kobo.500.2">After stopping, if you run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">docker ps</span></strong><span class="koboSpan" id="kobo.502.1"> command, there will be no more containers in </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">the list.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">Let’s take a look at the output of both </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">these commands:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer415">
<span class="koboSpan" id="kobo.506.1"><img alt="Figure 12.11 – Starting and stopping containers" src="image/B19682_12_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.507.1">Figure 12.11 – Starting and stopping containers</span></p>
<p><span class="koboSpan" id="kobo.508.1">To remove a</span><a id="_idIndexMarker1864"/><span class="koboSpan" id="kobo.509.1"> container, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">docker rm</span></strong><span class="koboSpan" id="kobo.511.1"> command. </span><span class="koboSpan" id="kobo.511.2">For example, if we would like to remove the initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">hello-world</span></strong><span class="koboSpan" id="kobo.513.1"> container (also called </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">recursing_murdock</span></strong><span class="koboSpan" id="kobo.515.1"> in our case), we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.517.1">
docker rm recursing_murdock</span></pre> <p><span class="koboSpan" id="kobo.518.1">Once you remove the container, any changes that you made and you did not save (commit) will be lost. </span><span class="koboSpan" id="kobo.518.2">Let us show you how to commit changes you made in a container to the Docker image. </span><span class="koboSpan" id="kobo.518.3">This means that you will save a specific state of a container as a new </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">Docker image.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.520.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.521.1">Please take into consideration that removing a container will not erase the existing image downloaded from </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">Docker Hub.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Let’s say that you would like to develop, test, and deploy a Python application on Ubuntu. </span><span class="koboSpan" id="kobo.523.2">The default Docker image of Ubuntu doesn’t have </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">Python installed.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">Next, we will show you how to troubleshoot Docker networking and how to commit a </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">new image.</span></span></p>
<h3><span class="koboSpan" id="kobo.527.1">Docker networking and committing a new image</span></h3>
<p><span class="koboSpan" id="kobo.528.1">The scenario for </span><a id="_idIndexMarker1865"/><span class="koboSpan" id="kobo.529.1">this section’s exercise is that you would like to modify the</span><a id="_idIndexMarker1866"/><span class="koboSpan" id="kobo.530.1"> existing Ubuntu image by installing the Python packages that you need for your application. </span><span class="koboSpan" id="kobo.530.2">To do this, we follow </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.532.1">First, we start the container and check to see whether Python is installed </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">or not:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer416">
<span class="koboSpan" id="kobo.534.1"><img alt="Figure 12.12 – Checking for Python inside the container" src="image/B19682_12_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.535.1">Figure 12.12 – Checking for Python inside the container</span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.536.1">We check for both Python 2 and Python 3, but neither version is installed on the image. </span><span class="koboSpan" id="kobo.536.2">As we want to use the latest version of the programming language, we will use the following command to install Python 3 support (running </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">as root):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.538.1">apt install python3</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.539.1">In doing so, you will get in contact with Docker networking for the first time, as the container needs to reach out to the official Ubuntu repositories in order to download and install the packages you need. </span><span class="koboSpan" id="kobo.539.2">It might be the case for you, too, as it was in ours, that when trying to install Python, you will be greeted with an error, such as the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer417">
<span class="koboSpan" id="kobo.541.1"><img alt="Figure 12.13 – Error while trying to install Python" src="image/B19682_12_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.542.1">Figure 12.13 – Error while trying to install Python</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.543.1">This error shows that the package named </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">python3</span></strong><span class="koboSpan" id="kobo.545.1"> cannot be located, meaning that our container does not have access to the repositories. </span><span class="koboSpan" id="kobo.545.2">A quick thought would be that there</span><a id="_idIndexMarker1867"/><span class="koboSpan" id="kobo.546.1"> is something wrong with Docker’s networking. </span><span class="koboSpan" id="kobo.546.2">In order to troubleshoot this, we have a useful command called </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">docker network</span></strong><span class="koboSpan" id="kobo.548.1">. </span><span class="koboSpan" id="kobo.548.2">It is used to </span><a id="_idIndexMarker1868"/><span class="koboSpan" id="kobo.549.1">manage network connections for the Docker container. </span><span class="koboSpan" id="kobo.549.2">In our case, the fault for the error message could be a missing connection between the container and the network. </span><span class="koboSpan" id="kobo.549.3">In this case, we can investigate first with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">docker network </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">ls</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.552.1"> command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.553.1">docker network ls</span></strong></pre> <p class="list-inset"><span class="koboSpan" id="kobo.554.1">This command will show all the active networks that are used by Docker. </span><span class="koboSpan" id="kobo.554.2">In our case, when running the preceding command, we can see that there are three available networks for Docker, each with a network ID and a name assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">to it:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer418">
<span class="koboSpan" id="kobo.556.1"><img alt="Figure 12.14 – Showing the available networks" src="image/B19682_12_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.557.1">Figure 12.14 – Showing the available networks</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.558.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.559.1">The issue described in this example may not appear in your case. </span><span class="koboSpan" id="kobo.559.2">However, it is a good exercise to show you how to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">docker network</span></strong><span class="koboSpan" id="kobo.561.1"> command </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">in action.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.563.1">Before starting to solve our issue, let us see once again what the containers are that are running and what their given names are. </span><span class="koboSpan" id="kobo.563.2">As we started the new container once again, it should have another ID and name. </span><span class="koboSpan" id="kobo.563.3">We will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.565.1">docker ps</span></strong></pre></li> <li><span class="koboSpan" id="kobo.566.1">Now, in order to try and solve our issue, we will connect the Ubuntu container that we use (name according to your output from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">docker ps</span></strong><span class="koboSpan" id="kobo.568.1"> command) to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">bridge</span></strong><span class="koboSpan" id="kobo.570.1"> network. </span><span class="koboSpan" id="kobo.570.2">This will be done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.572.1">docker network connect bridge [container_name]</span></strong></pre></li> <li><span class="koboSpan" id="kobo.573.1">Running the </span><a id="_idIndexMarker1869"/><span class="koboSpan" id="kobo.574.1">command will not show any kind of output, but we</span><a id="_idIndexMarker1870"/><span class="koboSpan" id="kobo.575.1"> will test the result by running the command to update the repositories inside the container to see that </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">it works:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.577.1">apt update -y</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.578.1">The output of the command shows that the repositories are accessible from our container, meaning that we can now install Python. </span><span class="koboSpan" id="kobo.578.2">The following screenshot shows an excerpt of </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the output:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer419">
<span class="koboSpan" id="kobo.580.1"><img alt="Figure 12.15 – Proof that the network connection is working" src="image/B19682_12_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.581.1">Figure 12.15 – Proof that the network connection is working</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.582.1">By connecting a container to a network, it will be able to communicate with other containers on the same </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">network too.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.584.1">Now, before going further with our Python installation, we would like to show you that there is a command that we can use to automatically connect a container to a network when starting </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the container:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.586.1">docker run -itd --network=bridge [container_name]</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.587.1">In our example, we provide two arguments, the network name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">bridge</span></strong><span class="koboSpan" id="kobo.589.1">) and the container’s name. </span><span class="koboSpan" id="kobo.589.2">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">-i</span></strong><span class="koboSpan" id="kobo.591.1"> option for interactive output, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">-t</span></strong><span class="koboSpan" id="kobo.593.1"> option for opening a pseudo TTY, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">-d</span></strong><span class="koboSpan" id="kobo.595.1"> option for detaching the container and running in </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">the background.</span></span></p></li> <li><span class="koboSpan" id="kobo.597.1">Now, let us proceed with our initial Python installation. </span><span class="koboSpan" id="kobo.597.2">We can once again run the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.599.1">apt install python3</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.600.1">This time, the command will not give any errors and it will proceed with the installation. </span><span class="koboSpan" id="kobo.600.2">The</span><a id="_idIndexMarker1871"/><span class="koboSpan" id="kobo.601.1"> following is an excerpt from the </span><a id="_idIndexMarker1872"/><span class="No-Break"><span class="koboSpan" id="kobo.602.1">command’s output:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer420">
<span class="koboSpan" id="kobo.603.1"><img alt="Figure 12.16 – Installing Python packages inside a Docker container" src="image/B19682_12_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.604.1">Figure 12.16 – Installing Python packages inside a Docker container</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.605.1">Now, with Python 3 installed and the necessary modifications made to the image used inside the container, we can save the instance of the container to a new Docker image. </span><span class="koboSpan" id="kobo.605.2">For this, we will use the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.607.1">docker commit -m "added python3 to ubuntu" -a "packt user" 260ead99f7ca packt/ubuntu-python3</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.608.1">Make sure that you use your own container ID with the preceding command; don’t use the one from our example. </span><span class="koboSpan" id="kobo.608.2">When using this command, you will save the new image onto your local computer, but there is also the possibility to save it to Docker Hub for others to use, too. </span><span class="koboSpan" id="kobo.608.3">To save to Docker Hub, you will need to have an active Docker user </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">account created.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.610.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">-m</span></strong><span class="koboSpan" id="kobo.612.1"> option to add a comment that details our commit process and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">-a</span></strong><span class="koboSpan" id="kobo.614.1"> option to specify the account user and the ID of the base image we used, in our case, the ID of the running container. </span><span class="koboSpan" id="kobo.614.2">The following screenshot shows a series of commands to help you to understand the </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">process better:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer421">
<span class="koboSpan" id="kobo.616.1"><img alt="Figure 12.17 – A new image committed locally" src="image/B19682_12_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.617.1">Figure 12.17 – A new image committed locally</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.618.1">As shown </span><a id="_idIndexMarker1873"/><span class="koboSpan" id="kobo.619.1">in the preceding screenshot, we first used </span><a id="_idIndexMarker1874"/><span class="koboSpan" id="kobo.620.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">docker ps</span></strong><span class="koboSpan" id="kobo.622.1"> command to see the ID of the container we are running, then we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">docker commit</span></strong><span class="koboSpan" id="kobo.624.1"> command (with the options described earlier) to save the new image locally. </span><span class="koboSpan" id="kobo.624.2">Notice the increased size of the image we just saved. </span><span class="koboSpan" id="kobo.624.3">Installing Python 3 more than doubled the size of the initial Ubuntu image. </span><span class="koboSpan" id="kobo.624.4">The last command used was </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">docker images</span></strong><span class="koboSpan" id="kobo.626.1">, to see the existing images, including the one we just </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">created (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">ubuntu-python3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.630.1">By now, you have learned how to use extremely basic Docker commands for opening, running, and saving containers. </span><span class="koboSpan" id="kobo.630.2">In the next section, we will introduce you to Dockerfiles and the process of building </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">container images.</span></span></p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor269"/><span class="koboSpan" id="kobo.632.1">Working with Dockerfiles</span></h1>
<p><span class="koboSpan" id="kobo.633.1">Before starting to </span><a id="_idIndexMarker1875"/><span class="koboSpan" id="kobo.634.1">work with Dockerfiles, let’s see what a Dockerfile is. </span><span class="koboSpan" id="kobo.634.2">It is a text file that consists of instructions defined by the user for Docker to execute, and respecting some basic structure, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.636.1">
INSTRUCTION arguments</span></pre> <p><span class="koboSpan" id="kobo.637.1">The Dockerfile is mainly used for creating new container images. </span><span class="koboSpan" id="kobo.637.2">This file is used by Docker to automatically build images based on the information the user provides inside the file. </span><span class="koboSpan" id="kobo.637.3">There are some keywords that define a Dockerfile. </span><span class="koboSpan" id="kobo.637.4">Those keywords, which are referred to as</span><a id="_idIndexMarker1876"/><span class="koboSpan" id="kobo.638.1"> instructions, are </span><span class="No-Break"><span class="koboSpan" id="kobo.639.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">FROM</span></strong><span class="koboSpan" id="kobo.641.1">: This must be the first instruction inside a Dockerfile as it tells Docker what the image is that you </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">build upon</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">LABEL</span></strong><span class="koboSpan" id="kobo.644.1">: This instruction adds some more information, such as a description, or anything that could help describe the new image you are creating; the use of such instructions needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">be limited</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">RUN</span></strong><span class="koboSpan" id="kobo.647.1">: This is the instruction that offers direct interaction with the image, the place where commands or scripts to be run inside the image </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">are written</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">ADD</span></strong><span class="koboSpan" id="kobo.650.1">: This</span><a id="_idIndexMarker1877"/><span class="koboSpan" id="kobo.651.1"> instruction is used to transfer files inside the image; it copies files or directories to the filesystem of </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">the image</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">COPY</span></strong><span class="koboSpan" id="kobo.654.1">: This instruction is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">ADD</span></strong><span class="koboSpan" id="kobo.656.1">, as it is also used to copy files or directories from one source to the </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">image’s filesystem</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">CMD</span></strong><span class="koboSpan" id="kobo.659.1">: This instruction can occur only once in a Dockerfile, as it provides defaults for an image that </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">is executed</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">USER</span></strong><span class="koboSpan" id="kobo.662.1">: This instruction is used to set a username that will be used when a command is executed; it can be used on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">RUN</span></strong><span class="koboSpan" id="kobo.664.1"> or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">CMD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.666.1"> instructions</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">WORKDIR</span></strong><span class="koboSpan" id="kobo.668.1">: This instruction will set the default working directory for other instructions inside a Dockerfile, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">RUN</span></strong><span class="koboSpan" id="kobo.670.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">CMD</span></strong><span class="koboSpan" id="kobo.672.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">COPY</span></strong><span class="koboSpan" id="kobo.674.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">ADD</span></strong><span class="koboSpan" id="kobo.676.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">ENTRYPOINT</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">ENTRYPOINT</span></strong><span class="koboSpan" id="kobo.680.1">: This instruction is used to configure containers that will run </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">as executables</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.682.1">The instructions listed </span><a id="_idIndexMarker1878"/><span class="koboSpan" id="kobo.683.1">here are just the ones that are usually used in a Dockerfile, but they do not represent all the instructions available. </span><span class="koboSpan" id="kobo.683.2">You can visit </span><a href="https://docs.docker.com/engine/reference/builder/"><span class="koboSpan" id="kobo.684.1">https://docs.docker.com/engine/reference/builder/</span></a><span class="koboSpan" id="kobo.685.1"> for a complete listing of all the instructions available for a Dockerfile. </span><span class="koboSpan" id="kobo.685.2">In the next section, we will show you how to build a container image using </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">a Dockerfile.</span></span></p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.687.1">Building container images from Dockerfiles</span></h2>
<p><span class="koboSpan" id="kobo.688.1">In this </span><a id="_idIndexMarker1879"/><span class="koboSpan" id="kobo.689.1">section, we will create a Dockerfile</span><a id="_idIndexMarker1880"/><span class="koboSpan" id="kobo.690.1"> that will be used for building a new Docker container image. </span><span class="koboSpan" id="kobo.690.2">Let us present the scenario on which our exercise is built. </span><span class="koboSpan" id="kobo.690.3">Similar to the exercise used in the </span><em class="italic"><span class="koboSpan" id="kobo.691.1">Docker networking and committing a new image</span></em><span class="koboSpan" id="kobo.692.1"> section, we will prepare an image for the Python programming environment. </span><span class="koboSpan" id="kobo.692.2">In order to create the new Docker image, we will first need to </span><a id="_idIndexMarker1881"/><span class="koboSpan" id="kobo.693.1">create the Dockerfile. </span><span class="koboSpan" id="kobo.693.2">The following are the steps </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">to take:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.695.1">Create a</span><a id="_idIndexMarker1882"/><span class="koboSpan" id="kobo.696.1"> new directory inside your home directory using the </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.698.1">mkdir ~/my_docker_images &amp;&amp; cd ~/my_docker_images</span></strong></pre></li> <li><span class="koboSpan" id="kobo.699.1">Create a new file inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">new directory:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.701.1">touch py_env_dockerfile</span></strong></pre></li> <li><span class="koboSpan" id="kobo.702.1">Open and edit the new Dockerfile. </span><span class="koboSpan" id="kobo.702.2">Now, let us dissect the contents of the new Dockerfile. </span><span class="koboSpan" id="kobo.702.3">As stated earlier, we want to install the needed packages and dependencies for a Python 3 programming environment. </span><span class="koboSpan" id="kobo.702.4">This time we will use another base image, not Ubuntu. </span><span class="koboSpan" id="kobo.702.5">We will use a Debian Linux image (based on Debian 11). </span><span class="koboSpan" id="kobo.702.6">If you use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">docker search debian</span></strong><span class="koboSpan" id="kobo.704.1"> command, the second image name on the output list will be the official Debian Linux image, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">debian</span></strong><span class="koboSpan" id="kobo.706.1">. </span><span class="koboSpan" id="kobo.706.2">We will use that. </span><span class="koboSpan" id="kobo.706.3">The contents of the Dockerfile are shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer422">
<span class="koboSpan" id="kobo.708.1"><img alt="Figure 12.18 – Creating the Dockerfile" src="image/B19682_12_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.709.1">Figure 12.18 – Creating the Dockerfile</span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.710.1">Now that the Dockerfile is created, we will run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">docker build</span></strong><span class="koboSpan" id="kobo.712.1"> command to create the new Docker image. </span><span class="koboSpan" id="kobo.712.2">The command we used is </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">as follows:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.714.1">docker build ~/my_docker_images -f py_env_dockerfile -t pydeb</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.715.1">We used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">-f</span></strong><span class="koboSpan" id="kobo.717.1"> option to specify the Dockerfile name and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">-t</span></strong><span class="koboSpan" id="kobo.719.1"> option to specify the name of the image we want to create, in our case </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">pydeb</span></strong><span class="koboSpan" id="kobo.721.1">. </span><span class="koboSpan" id="kobo.721.2">In the next screenshot, you will see the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">docker build</span></strong><span class="koboSpan" id="kobo.723.1"> command, showing all</span><a id="_idIndexMarker1883"/><span class="koboSpan" id="kobo.724.1"> the steps needed to build the image, as specified in the Dockerfile. </span><span class="koboSpan" id="kobo.724.2">The build </span><a id="_idIndexMarker1884"/><span class="No-Break"><span class="koboSpan" id="kobo.725.1">was successful:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer423">
<span class="koboSpan" id="kobo.726.1"><img alt="Figure 12.19 – Building a new custom image from a Dockerfile" src="image/B19682_12_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.727.1">Figure 12.19 – Building a new custom image from a Dockerfile</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.728.1">We can verify if the image was created by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">docker images</span></strong><span class="koboSpan" id="kobo.730.1"> command. </span><span class="koboSpan" id="kobo.730.2">As shown in the preceding screenshot, the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">pydeb</span></strong><span class="koboSpan" id="kobo.732.1"> image was </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">successfully created.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.734.1">We can use the new image and create a new container with the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.736.1">docker run -it pydeb</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.737.1">This will run a new container based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">pydeb</span></strong><span class="koboSpan" id="kobo.739.1"> images we </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">just created.</span></span></p></li> <li><span class="koboSpan" id="kobo.741.1">To verify the container running, open a new terminal window and run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">docker ps</span></strong><span class="koboSpan" id="kobo.743.1"> command, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">following screenshot:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer424">
<span class="koboSpan" id="kobo.745.1"><img alt="Figure 12.20 – New container based on our custom image" src="image/B19682_12_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.746.1">Figure 12.20 – New container based on our custom image</span></p>
<p><span class="koboSpan" id="kobo.747.1">By now, you</span><a id="_idIndexMarker1885"/><span class="koboSpan" id="kobo.748.1"> already</span><a id="_idIndexMarker1886"/><span class="koboSpan" id="kobo.749.1"> know enough about Docker to feel comfortable using it in production. </span><span class="koboSpan" id="kobo.749.2">In the next section, we will show you how to use Docker to deploy a very basic application. </span><span class="koboSpan" id="kobo.749.3">We will make it so simple that the app to deploy will be a basic static </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">presentation website.</span></span></p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.751.1">Deploying a containerized application with Docker</span></h1>
<p><span class="koboSpan" id="kobo.752.1">So far, we </span><a id="_idIndexMarker1887"/><span class="koboSpan" id="kobo.753.1">have shown you how to use Docker and how to manage containers. </span><span class="koboSpan" id="kobo.753.2">Docker is so much more than that, but this is enough to get you started and make you want to learn more. </span><span class="koboSpan" id="kobo.753.3">Docker is a great tool for developers as it offers a streamlined way to deploy applications by removing the necessity to replicate development environments. </span><span class="koboSpan" id="kobo.753.4">In the next section, we will show you how to deploy a simple website </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">using Docker.</span></span></p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.755.1">Deploying a website using Docker</span></h2>
<p><span class="koboSpan" id="kobo.756.1">To </span><a id="_idIndexMarker1888"/><span class="koboSpan" id="kobo.757.1">deploy a </span><a id="_idIndexMarker1889"/><span class="koboSpan" id="kobo.758.1">website using Docker, follow </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.760.1">We will use a free website template randomly downloaded from the internet (the download link is </span><a href="https://www.free-css.com/free-css-templates/page262/focus)"><span class="koboSpan" id="kobo.761.1">https://www.free-css.com/free-css-templates/page262/focus)</span></a><span class="koboSpan" id="kobo.762.1">. </span><span class="koboSpan" id="kobo.762.2">We will copy the download location from the website and download the file inside our home directory using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">wget</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.764.1"> utility:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.765.1">wget https://www.free-css.com/assets/files/free-css-templates/download/page262/focus.zip</span></strong></pre></li> <li><span class="koboSpan" id="kobo.766.1">The new file is a compressed ZIP file, so we will have to extract it. </span><span class="koboSpan" id="kobo.766.2">We will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">unzip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.768.1"> command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.769.1">unzip focus.zip</span></strong></pre></li> <li><span class="koboSpan" id="kobo.770.1">The file</span><a id="_idIndexMarker1890"/><span class="koboSpan" id="kobo.771.1"> has to be downloaded and extracted inside </span><a id="_idIndexMarker1891"/><span class="koboSpan" id="kobo.772.1">our home directory. </span><span class="koboSpan" id="kobo.772.2">You can use another directory, and we advise you to do so for clarity. </span><span class="koboSpan" id="kobo.772.3">We will create a new directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">docker_webapp</span></strong><span class="koboSpan" id="kobo.774.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">~/my_docker_images</span></strong><span class="koboSpan" id="kobo.776.1"> directory created in the previous section, and move the extracted file inside of it. </span><span class="koboSpan" id="kobo.776.2">Therefore, the new location in our case will be </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.778.1">~/my_docker_images/docker_webapp/focus</span></strong></pre></li> <li><span class="koboSpan" id="kobo.779.1">Once the files are moved to the desired location, we can proceed to create a Dockerfile inside the same directory. </span><span class="koboSpan" id="kobo.779.2">We will create a Dockerfile called </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">webapp_dockerfile</span></strong><span class="koboSpan" id="kobo.781.1"> inside our present working directory. </span><span class="koboSpan" id="kobo.781.2">The contents of the Dockerfile are </span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">as follows:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer425">
<span class="koboSpan" id="kobo.783.1"><img alt="Figure 12.21 – Contents of a new Dockerfile" src="image/B19682_12_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.784.1">Figure 12.21 – Contents of a new Dockerfile</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.785.1">The file is simple and has only </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">two lines:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.787.1">The first line, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">FROM</span></strong><span class="koboSpan" id="kobo.789.1"> keyword, specifies the base image that we will use, which will be the official NGINX image available on Docker Hub. </span><span class="koboSpan" id="kobo.789.2">As you will see in </span><a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic"><span class="koboSpan" id="kobo.790.1">Chapter 13</span></em></a><span class="koboSpan" id="kobo.791.1">, NGINX is a widely used type of </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">web server.</span></span></li>
<li><span class="koboSpan" id="kobo.793.1">The second line, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">COPY</span></strong><span class="koboSpan" id="kobo.795.1"> keyword, specifies the location where the contents of our present working directory will be copied inside the </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">new container.</span></span></li>
</ul>
<p class="list-inset"><span class="koboSpan" id="kobo.797.1">The following action builds the Docker image using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">docker </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">build</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1"> command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.801.1">docker build ~/my_docker_images/docker_webapp/focus -f webapp_dockerfile -t webapp</span></strong></pre> <ol>
<li value="5"><span class="koboSpan" id="kobo.802.1">The new image was created, so we can now check for it using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">docker images</span></strong><span class="koboSpan" id="kobo.804.1"> command. </span><span class="koboSpan" id="kobo.804.2">In our case, the output is </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">as follows:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer426">
<span class="koboSpan" id="kobo.806.1"><img alt="Figure 12.22 – The new webapp Docker image was created" src="image/B19682_12_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.807.1">Figure 12.22 – The new webapp Docker image was created</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.808.1">As the </span><a id="_idIndexMarker1892"/><span class="koboSpan" id="kobo.809.1">output shows, the new image called </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">webapp</span></strong><span class="koboSpan" id="kobo.811.1"> was created, and we can start a new container using it. </span><span class="koboSpan" id="kobo.811.2">As we will need to </span><a id="_idIndexMarker1893"/><span class="koboSpan" id="kobo.812.1">access the container from the outside, we will need to open specific ports, and we will do that using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">-p</span></strong><span class="koboSpan" id="kobo.814.1"> parameter inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">docker run</span></strong><span class="koboSpan" id="kobo.816.1"> command. </span><span class="koboSpan" id="kobo.816.2">We can either specify a single port or a range of ports. </span><span class="koboSpan" id="kobo.816.3">When specifying ports, we will give the ports for the container and for the host, too. </span><span class="koboSpan" id="kobo.816.4">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">-d</span></strong><span class="koboSpan" id="kobo.818.1"> parameter to detach the container and run it in the background. </span><span class="koboSpan" id="kobo.818.2">The command is </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">as follows:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.820.1">docker run -it -d -p 8080:80 webapp</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.821.1">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">as follows:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer427">
<span class="koboSpan" id="kobo.823.1"><img alt="Figure 12.23 – The output of the docker run command" src="image/B19682_12_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.824.1">Figure 12.23 – The output of the docker run command</span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.825.1">We are exposing host port </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">8080</span></strong><span class="koboSpan" id="kobo.827.1"> to port </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">80</span></strong><span class="koboSpan" id="kobo.829.1"> on the container. </span><span class="koboSpan" id="kobo.829.2">We could have used both ports </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">80</span></strong><span class="koboSpan" id="kobo.831.1">, but on the host, it might be occupied by </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">other services.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.833.1">You can now access the new containerized application by going to your web browser and typing the local IP address and port </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">8080</span></strong><span class="koboSpan" id="kobo.835.1"> into the address bar. </span><span class="koboSpan" id="kobo.835.2">As we are using a VM and not the host, we will point to the VM’s IP address, in our case </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">192.168.122.48</span></strong><span class="koboSpan" id="kobo.837.1">, followed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">8080</span></strong><span class="koboSpan" id="kobo.839.1"> port. </span><span class="koboSpan" id="kobo.839.2">In the next screenshot, you will see our </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">Docker-deployed website:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer428">
<span class="koboSpan" id="kobo.841.1"><img alt="Figure 12.24 – Running the ﻿web app in our web browser" src="image/B19682_12_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.842.1">Figure 12.24 – Running the web app in our web browser</span></p>
<p><span class="koboSpan" id="kobo.843.1">As you</span><a id="_idIndexMarker1894"/><span class="koboSpan" id="kobo.844.1"> can see </span><a id="_idIndexMarker1895"/><span class="koboSpan" id="kobo.845.1">in the preceding image, the website is accessible from localhost. </span><span class="koboSpan" id="kobo.845.2">For deploying a website on a virtual private server, please visit </span><a href="B19682_13.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.846.1">Chapter 13</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.847.1">.</span></span></p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.848.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.849.1">In this chapter, we emphasized the importance of containerization. </span><span class="koboSpan" id="kobo.849.2">We showed you what containers are, how they work, and why they are so important. </span><span class="koboSpan" id="kobo.849.3">Containers are the foundation of the modern DevOps revolution, and you are now ready to use them. </span><span class="koboSpan" id="kobo.849.4">We also taught you about Docker, the basic commands for sleek use. </span><span class="koboSpan" id="kobo.849.5">You are now ready to start the cloud journey. </span><span class="koboSpan" id="kobo.849.6">Virtualization and container technologies are at the heart of cloud and </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">server technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">In the next chapter, we will show you how to install and configure different Linux-based servers, such as web servers, DNS servers, DHCP servers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">mail servers.</span></span></p>
<h1 id="_idParaDest-256"><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.853.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.854.1">Here’s a brief quiz about some of the essential concepts that were covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.856.1">What is the major difference between containers </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">and VMs?</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.858.1">Hint</span></strong><span class="koboSpan" id="kobo.859.1">: Revisit </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.860.1">Figure 12</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.861.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">.</span></span></p></li>
<li><span class="koboSpan" id="kobo.863.1">How does container </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">technology work?</span></span></li>
<li><span class="koboSpan" id="kobo.865.1">What are the two major components of </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">Docker architecture?</span></span></li>
<li><span class="koboSpan" id="kobo.867.1">Which Docker command shows the </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">running containers?</span></span></li>
<li><span class="koboSpan" id="kobo.869.1">Which command is used for container </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">network management?</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.871.1">Hint</span></strong><span class="koboSpan" id="kobo.872.1">: See the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">docker network</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.874.1">command’s help.</span></span></p></li>
</ol>
<h1 id="_idParaDest-257"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.875.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.876.1">For more information on the topics covered in this chapter, you can refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">Packt titles:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.878.1">Docker Quick Start Guide</span></em><span class="koboSpan" id="kobo.879.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">Earl Waud</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.881.1">Mastering Docker – Fourth Edition</span></em><span class="koboSpan" id="kobo.882.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">Russ McKendrick</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.884.1">Containerization with LXC</span></em><span class="koboSpan" id="kobo.885.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">Konstantin Ivanov</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.887.1">A Developer’s Essential Guide to Docker Compose</span></em><span class="koboSpan" id="kobo.888.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">Emmanouil Gkatziouras</span></span></li>
</ul>
</div>
</body></html>