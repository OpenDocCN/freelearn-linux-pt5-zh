<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Cold Starts</h1></div></div></div><p>In the Northern Hemisphere, I think we can all relate to the analogy of the cold start; those bleak January mornings where you are frantically trying to start your car. When it does finally splutter into some form of life, we then have to contend with a steering wheel too cold to hold. Thankfully, starting up a Linux system is not so unpleasant; perhaps air-conditioned server rooms have something to do with this, I am not sure…</p><p>Working through this chapter, we are going to build upon what you have already mastered—helping you understand your Linux systems. You will learn about the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The GRUB and the MBR</strong>: In this section, you will learn about the relationship that the <strong>GRand Unified Bootloader</strong> (<strong>GRUB</strong>) enjoys with the <strong>Master Boot Record</strong> (<strong>MBR</strong>), being able to slip its slender 466 bytes easily inside the 512-byte limit.</li><li class="listitem" style="list-style-type: disc"><strong>When is the root filesystem not the root filesystem?</strong>: In this section, we will understand the term <em>root</em> when used as a directive within a GRUB stanza, which is a<a class="indexterm" id="id29"/> little hurdle we shall overcome.</li><li class="listitem" style="list-style-type: disc"><strong>Working on the </strong><a class="indexterm" id="id30"/><strong>GRUB console</strong>: In this section, you will learn how to enable some powerful recovery tools.</li><li class="listitem" style="list-style-type: disc"><strong>Protecting the GRUB menu with passwords</strong>: In this section, you will learn how to enforce physical security of your systems: desktops or servers.</li><li class="listitem" style="list-style-type: disc"><strong>Boot splashing with plymouth</strong>: A little fun to finish the section with, we will look at the range of boot splash screens that we can use with CentOS. By the end of this chapter, your Linux system will never have been so well dressed.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>The GRUB and MBR</h1></div></div></div><p>This is not just a competition to see how many acronyms we can fit into a chapter heading, although, out of four words, having used two already is not a bad start. The <strong>GRUB</strong> is the system-supplied bootloader that ships with CentOS and Red Hat Enterprise Linux 6. This<a class="indexterm" id="id31"/> tiny piece of bootstrap code is used to load the kernel and allows us to dual boot different Linux versions or even with Microsoft Windows operating systems. The GRUB has been the bootloader of choice for many years, although other <a class="indexterm" id="id32"/>bootloaders do exist. These include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Lilo</strong>: This<a class="indexterm" id="id33"/> is the original Linux loader</li><li class="listitem" style="list-style-type: disc"><strong>EXTLinux</strong>: This <a class="indexterm" id="id34"/>is part of the SYSLinux<a class="indexterm" id="id35"/> family that includes the following:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">EXTLinux to boot from fixed drives</li><li class="listitem" style="list-style-type: disc">ISOLinux to boot from CDs and DVDs</li><li class="listitem" style="list-style-type: disc">SYSLinux to boot from a USB device</li><li class="listitem" style="list-style-type: disc">PXELinux to boot from the network</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>GRUB2</strong>: More <a class="indexterm" id="id36"/>recently, this is making its <a class="indexterm" id="id37"/>appearance as a replacement to GRUB, or what is now referred to as the legacy GRUB. GRUB2 is likely to debut in CentOS 7 in 2014.</li></ul></div><p>The GRUB <a class="indexterm" id="id38"/>bootloader is most commonly stored in the MBR of the bootable drive.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Although generally stored within the MBR, it is possible to install GRUB into the superblock, or the first 512 bytes, of a partition.</p></div></div><p>The MBR makes up the first 512 bytes of the disk, allowing up to 466 bytes of storage for the bootloader; the additional space will be used to store the partition table for that drive.</p><p>We can back up the MBR to a file using the <code class="literal">dd</code> command as follows:</p><div><pre class="programlisting">
<strong># dd if=/dev/sda of=/tmp/sda.mbr count=1 bs=512</strong>
</pre></div><p>The <code class="literal">dd</code> command<a class="indexterm" id="id39"/> is used to duplicate a disk. In the previous command, we read from the first disk, <code class="literal">/dev/sda</code>, and backed it up to the <code class="literal">/tmp/sda.mbr</code> file. Rather than duplicating the entire disk, we limit the backup to a count of one block of 512 bytes.</p><p>Now that we have a backup for the MBR, we can investigate this fact a little more by running the following command:</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The following commands can be destructive, in that they will destroy the MBR, so please take care if you will be running commands on your own system, and I would recommend running only the following demonstration commands on a test system.</p></div></div><div><pre class="programlisting">
<strong># dd if=/dev/zero of=/dev/sda count=1 bs=512</strong>
</pre></div><p>With the preceding command, we have wiped the data stored within the first 512 bytes of the disk <code class="literal">/dev/sda</code>. The MBR now is effectively cleared. We can verify this by using the following command:</p><div><pre class="programlisting">
<strong>$ lsblk /dev/sda</strong>
</pre></div><p>The<a class="indexterm" id="id40"/> output should display an empty partition table. The system remains <a class="indexterm" id="id41"/>usable as the partition table is resident to the RAM on the running system; however, until we are able to restore the MBR, a reboot will soon identify how much of a disaster we are in. Never fear, we can restore the MBR from the backup. What <code class="literal">dd</code> takes away, <code class="literal">dd</code> can return, simply by using the <code class="literal">dd</code> command as follows. Quickly, before someone notices!</p><div><pre class="programlisting">
<strong># dd if=/tmp/sda.mbr of=/dev/sda</strong>
</pre></div><p>We do not need to limit the amount of data to be read from the specified file. Remember, it only contains the 512 bytes that make up the MBR. With a little luck, using the <code class="literal">fdisk</code> command will now show the partition table correctly as it was before, and you can begin to breathe easy again:</p><div><pre class="programlisting">
<strong>$ fdisk /dev/sda</strong>
</pre></div><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Using<a class="indexterm" id="id42"/> the <code class="literal">dd</code> command to wipe a disk completely with the <code class="literal">/dev/zero</code> input file is useful should you wish to wipe a disk before selling a computer, ensuring that the operating system, applications, and most importantly, the data is not sold with the device. We use <code class="literal">fdisk</code> in the second example as <code class="literal">lsblk</code> reads from memory and not the disk.</p></div></div><p>Once we <a class="indexterm" id="id43"/>have booted into GRUB, a menu will be shown allowing the user to select the <strong>operating system</strong> (<strong>OS</strong>) to enter. In general, the default selection is loaded without user interaction. We can configure the menu choices using the <code class="literal">/boot/grub/menu.lst</code> file. You will learn more about this file later.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>When is the root filesystem not the root filesystem?</h1></div></div></div><p>We now need to break down the menu entries within the file, identifying the core components so that we can understand how they relate to the system and, most importantly, how we can correct errors.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Editing stanzas in GRUB</h2></div></div></div><p>Each <a class="indexterm" id="id44"/>entry in the GRUB menu is known as a <strong>stanza</strong>, and each stanza <a class="indexterm" id="id45"/>will start with the <code class="literal">title</code> word, containing three directives as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">root</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">kernel</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">initd</code></li></ul></div><p>The title of the stanza also becomes the displayed item in the menu. Let's consider a stanza that begins with the following title:</p><div><pre class="programlisting">title CentOS 6.5 OS</pre></div><p>The menu will display <code class="literal">CentOS 6.5 OS</code> as the selectable item, and it is important to note that we do not add quotes around the text as they will also be displayed to the user. This is unless, of course, you want or need to display these quotes; we are most certainly not quote unfriendly at Packt Publishing!</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Adding a root entry to a stanza</h2></div></div></div><p>Directly<a class="indexterm" id="id46"/> following the stanza title will be a line that starts <a class="indexterm" id="id47"/>with the <code class="literal">root</code> directive. This identifies the root filesystem to GRUB and not the OS root; in simple terms, this should point to the partition that is marked as bootable in the partition table.</p><p>We can use the <code class="literal">fdisk</code> or <code class="literal">parted</code> command to display the bootable partition. If you are using<a class="indexterm" id="id48"/> the <code class="literal">fdisk</code> command to display the partition information, the command would be similar to the following where we want to list the partitions of the first hard drive within the system:</p><div><pre class="programlisting">
<strong># fdisk -l /dev/sda</strong>
</pre></div><p>The partition marked as bootable will be identified with an asterisk mark. If you are using the <code class="literal">parted</code> command<a class="indexterm" id="id49"/> to display the partition table, you will be able to identify the bootable partition by the boot flag by executing the following command:</p><div><pre class="programlisting">
<strong># parted /dev/sda print</strong>
</pre></div><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>The <code class="literal">fdisk</code> shows the bootable partition with <code class="literal">*</code> and parted with the word <code class="literal">boot</code>.</p></div></div><p>The bootable partition can be <code class="literal">/boot</code> or the actual root filesystem itself <code class="literal">/</code>. This relates to how the system was configured as it was installed. It might often be the case that <code class="literal">/boot</code> will have its own partition to ease access by the bootloader. The legacy GRUB, for example, cannot access a filesystem built on <strong>Logical Volume Management</strong> (<strong>LVM</strong>); this is the<a class="indexterm" id="id50"/> default partitioning proposal in<a class="indexterm" id="id51"/> CentOS 6. The same applies to software <strong>Redundant Array of Inexpensive Disks</strong> (<strong>RAID</strong>) arrays.</p><p>Consider<a class="indexterm" id="id52"/> the following stanza:</p><div><pre class="programlisting">title CentOS 6.5 OS
  root (hd0,0)</pre></div><p>From<a class="indexterm" id="id53"/> this, we can determine that GRUB should mount the first partition on the first drive (both the drive and partition numbering starts at 0) as the bootable partition.</p><p>To summarize, the <code class="literal">root</code> directive in a GRUB stanza indicates the partition that the MBR marks as bootable.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Adding a kernel entry to a stanza</h2></div></div></div><p>The directive, <code class="literal">kernel</code>, directs the bootloader to the target operating system kernel. The path to <a class="indexterm" id="id54"/>that kernel will be related to the GRUB root<a class="indexterm" id="id55"/> partition, or the bootable partition. If the path reads <code class="literal">/vmlinuz.version</code>, then this would be an indication that the kernel is located at the root of the bootable partition, whereas the path <code class="literal">/boot/vmlinuz.version</code> would indicate that the bootable partition is the Linux or OS root partition. The path has to include the <code class="literal">/boot</code> directory to be able to locate the kernel.</p><p>Following the filename of the kernel are the arguments used when loading the kernel, or more simply referred to as the kernel options. These options include, among others, the device name where the real root filesystem is located and the device name for the swap filesystem, which can be used to suspend the system, perhaps on a laptop build. An example of the OS root option would be <code class="literal">root=/dev/sda2</code>; this being the second partition on the first hard drive or <code class="literal">root=/dev/mapper/vg_centos-vg_root</code>. This indicates that the operating system root is built upon an LVM. The swap filesystem to be suspended is indicated by the <code class="literal">resume</code> option.</p><p>The following extract from a stanza indicates that the boot partition is <code class="literal">/dev/sda1 (hd0,0)</code> and the operating system root is <code class="literal">/dev/sda2</code>, with the swap located on <code class="literal">/dev/sda3</code>:</p><div><pre class="programlisting">title CentOS 6.5 OS
  root (hd0,0)
  kernel /vmlinuz.version root=/dev/sda2 resume=/dev/sda3</pre></div><p>If the OS root is also the bootable partition, the corresponding GRUB stanza would read similar to the following:</p><div><pre class="programlisting">title CentOS 6.5 OS
  root (hd0,0)
  kernel /boot/vmlinuz.version root=/dev/sda1 resume=/dev/sda2</pre></div><p>We can see that the path to the kernel is now the full operating system path and both the GRUB root and the OS root correspond to the same partition.</p><p>Given a<a class="indexterm" id="id56"/> running system where the boot process is <a class="indexterm" id="id57"/>completed and we are logged in, it is possible to <a class="indexterm" id="id58"/>view the version of the kernel with either of the following commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$ cat /proc/version</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$ uname –r</code></li></ul></div><p>You should look at both commands and see which one best suits your needs; the <code class="literal">/proc/version</code> file will give a little more information. However, the <code class="literal">uname -r</code> command<a class="indexterm" id="id59"/> summarizes the information well. This is your system and it is your choice.</p><p>Should we need to list the options with which the kernel was booted, we can display those options with the following command:</p><div><pre class="programlisting">
<strong>$ cat /proc/cmdline</strong>
</pre></div><p>By this stage, I am hoping you have a little more understanding of when the root filesystem may not actually be the root filesystem and when it can be the root filesystem. You are now ready to use this riddle anytime that you wish to confuse your colleagues. It really is a simple matter of knowing where the partition that holds the kernel is; this then becomes the root of the bootable partition. The OS root is what we normally think as of the root filesystem but this happens only once the system has completed the boot process. The kernel directive simply points to the kernel file with a path relative to the root of the boot partition along with any options that we may wish to pass through to the kernel when it is loaded.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>The <code class="literal">/proc</code> directory is a pseudo filesystem, meaning that it is transient and resides only in the RAM. It contains up-to-date information for the currently running system. This directory is worth becoming acquainted with.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Adding an initrd entry to a stanza</h2></div></div></div><p>Similar to the <code class="literal">kernel</code> directive, the <code class="literal">initrd</code> directive will point to the initialization RAM disk; a<a class="indexterm" id="id60"/> mini OS that is compiled with the drivers needed<a class="indexterm" id="id61"/> to access the OS root filesystem. The RAM disk loads prior to the kernel and mounts the OS root filesystem as read-only. Filesystem integrity checks are performed before handing it to the kernel to continue with the boot process and mounting as read/write. This means that the kernel does not have to have the drivers for the root filesystem internally compiled, allowing more flexibility in changes to the OS root and a more lean kernel. The RAM disk can be recompiled if the root filesystem changes or the drivers need to access the hardware change with the <code class="literal">mkinitrd</code> command.</p><p>Continuing with our example stanza, we can insert a line for the <code class="literal">initrd</code> directive to read as follows:</p><div><pre class="programlisting">title CentOS 6.5 OS
  root (hd0,0)
  kernel /boot/vmlinuz.version root=/dev/sda1 resume=/dev/sda2
  initrd /boot/initramfs.version</pre></div><p>Not<a class="indexterm" id="id62"/> wishing to be out performed by the preceding <a class="indexterm" id="id63"/>simple text, the following screenshot shows an extract from a real GRUB stanza on my CentOS 6.5 system.</p><div><img alt="Adding an initrd entry to a stanza" src="img/5902OS_02_01.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Working on the GRUB console</h1></div></div></div><p>When presented with the GRUB menu, as well as selecting the entry we wish to boot, we can either <a class="indexterm" id="id64"/>edit existing entries or shell out to the GRUB console. Working on the GRUB console enables us to enter our own sets of commands. Remember the trilogy that should accompany each stanza:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">root</li><li class="listitem" style="list-style-type: disc">kernel</li><li class="listitem" style="list-style-type: disc">initrd</li></ul></div><p>We can enter these commands, but also reinstall GRUB if required. More simply, in the console, we can also edit or append to the exiting entries; using the <em>e</em> key, we can edit an entry, and <em>a</em> can be used to append an option to the kernel line. From the following screenshot, we can view these options:</p><div><img alt="Working on the GRUB console" src="img/5902OS_02_02.jpg"/></div><p>Editing the kernel arguments allows you to specify the runlevel target to boot to; using this method, it is possible to reset the password of the root user.</p><p>To <a class="indexterm" id="id65"/>recover a forgotten root password, we can boot the system to runlevel 1; by default, this will log you in directly as root.</p><div><ol class="orderedlist arabic"><li class="listitem">Firstly, we must select the entry in the menu to boot to. If there is more than one, do not use the <em>Enter</em> key.</li><li class="listitem">With the menu entry highlighted, choose the letter <em>a</em>.</li><li class="listitem">This will take you directly to the end of the kernel line where you can add the number 1 to boot to runlevel 1.<div><div><h3 class="title"><a id="note02"/>Note</h3><p>It is important to note that <em>CentOS System Administration Essentials</em> assumes that no prior runlevel has already been specified in the kernel arguments.</p></div></div></li></ol></div><p>With the number added, just hit the <em>Enter</em> key, and the system will boot to the single user mode and logged in as root. Once the system has been booted, you can effectively change a password using <a class="indexterm" id="id66"/>the <code class="literal">passwd</code> command.</p><p>It is possible to prevent this behavior; we have to be cautious to avoiding the prevention genuine recovery mechanisms of our server. If there is enough physical protection of the server, then perhaps we do not need to make any changes. However, if we cannot ensure physical security of the server, we can edit the <code class="literal">/etc/sysconfig/init</code> file by changing the <code class="literal">SINGLE=/sbin/sushell</code> line to the following:</p><div><pre class="programlisting">SINGLE=/sbin/sulogin</pre></div><p>The <code class="literal">sulogin</code> command<a class="indexterm" id="id67"/> will prompt for the root user's password.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If <code class="literal">sulogin</code> has been set and you still need emergency access as root, it is possible by specifying <code class="literal">init=/bin/bash</code> instead of 1 as the runlevel.</p></div></div><p>If our boot situation is a little more serious, or in human terms, it won't boot, then we can enter the GRUB command prompt using the option <code class="literal">c</code>. Using the command <code class="literal">help</code>, we can determine what commands are available from the minimal shell. To reinstall GRUB with the correct drivers to access the boot partition, execute the following command:</p><div><pre class="programlisting">
<strong>grub&gt; setup(hd0)</strong>
</pre></div><p>The preceding command will check to see if <code class="literal">/boot/grub/stage1</code> or <code class="literal">/grub/stage1</code> exists on the bootable partition. This way, it determines which partition to use as root and copies the <code class="literal">stage1</code> file to the MBR complete with the drivers needed to access the bootable<a class="indexterm" id="id68"/> partition. We can then choose to restart the system <a class="indexterm" id="id69"/>with the <code class="literal">reboot</code> command.</p><p>Not only can we use the GRUB console to repair GRUB, we can use it to boot the system and verify the menu items. By specifying the root filesystem to be used for booting, we can check the path required to access the kernel and <code class="literal">initrd</code>. We can use the normal tab completion on the GRUB shell to see directories and filenames.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Protecting the GRUB menu with passwords</h1></div></div></div><p>Now I can imagine that all of this talk to gain root access from the physical server can be quite alarming; the truth is that it really shouldn't be, as securing physical access to the server is <a class="indexterm" id="id70"/>normally not difficult or onerous. However, where there is a desire or need to take the security further, it can easily be implemented through GRUB passwords. Any password settings will normally be added to the global section that precedes any stanza. Firstly, let's review some of the GRUB global options before setting some passwords.</p><p>On visiting the <code class="literal">/boot/grub/menu.lst</code> file on CentOS, we will see that the first lines are commented out <a class="indexterm" id="id71"/>and generated by the installer <strong>anaconda</strong>, and that the file is named as <code class="literal">grub.conf</code>.</p><p>The <code class="literal">menu.lst</code> file does exist in Red Hat and CentOS but is in the guise of a symbolic link to <code class="literal">/boot/grub/grub.conf</code>. From the legacy GRUB documentation, the file should be <code class="literal">menu.lst</code>; CentOS provides this with the link, but I feel that the file is more logically named <code class="literal">grub.conf</code>.</p><p>For ease of access, a symbolic link <code class="literal">/etc/grub.conf</code> links through the <code class="literal">/boot/grub/grub.conf</code> file. The single file can then be accessed as follows:</p><div><pre class="programlisting">/boot/grub/grub.conf
/boot/grub/menu.lst
/etc/grub.conf</pre></div><p>The <code class="literal">default</code> directive will direct GRUB to the default stanza or entry if no choice is made before the timeout.</p><div><pre class="programlisting">default=0
timeout=5
hiddenmenu</pre></div><p>Here, we will select the first stanza, stanza 0, if no selection has been made within 5 seconds of the menu loading. The directive, <code class="literal">hiddenmenu</code>, prevents the menu from showing unless the <em>Esc </em>key is pressed. This is especially helpful where there is only one entry in the menu, which is often the case, making good and practical sense.</p><p>If you <a class="indexterm" id="id72"/>need to prevent users from selecting anything other than what is provided via the menu, then we can add a password to the global settings. This will ensure that, unless the password is entered, only the menu items provided by the menu are available and the option to enter the GRUB shell or append or edit the entries is restricted. The following snippet of code illustrates how this is possible:</p><div><pre class="programlisting">default=0
timeout=5
hiddenmenu
password=secret</pre></div><p>If you do not like the idea of a clear text password in the GRUB menu file, then you can use the <code class="literal">grub-md5-crypt</code> command. You can add the encrypted password as follows:</p><div><pre class="programlisting">default=0
timeout=5
hiddenmenu
password --md5 &lt;password-hash&gt;</pre></div><p>You can also add a password directly to a stanza. Adding a password to a stanza ensures that users can only choose that selection from the menu if they know the password. In this way, should you want, you can always have a runlevel 1 entry in the menu but protected by the password as follows</p><div><pre class="programlisting">title CentOS 6.5 Single User
  password --md5 &lt;password-hash&gt;
  root (hd0,0)
  kernel /boot/vmlinuz.version root=/dev/sda1 resume=/dev/sda2 1
initrd /boot/initramfs.version</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Boot splashing with plymouth</h1></div></div></div><p>As soon as we have begun the boot process and just prior to handing control to the kernel, a boot splash <a class="indexterm" id="id73"/>screen can be displayed. This, as the name suggests, controls<a class="indexterm" id="id74"/> the splash screen you may see during the boot<a class="indexterm" id="id75"/> process. In CentOS, this defaults to the plymouth theme: rings. Plymouth is the boot splash manager; we can use other themes should we wish. Some of these are installed as standard, while others are included in the standard <a class="indexterm" id="id76"/>repositories. Yet, more themes can be found in third-party repositories.</p><p>You can, of<a class="indexterm" id="id77"/> course, build your own theme. Essentially, a <a class="indexterm" id="id78"/>minimal theme is just a wallpaper.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Applying different themes</h2></div></div></div><p>Most of the time during the boot process, you will not see the splash screen unless CentOS is your desktop machine. However, I would recommend still working with plymouth <a class="indexterm" id="id79"/>to change the default splash from rings to basic. With<a class="indexterm" id="id80"/> the basic theme, we can see the services loading during the boot process rather than the rings that merely show the boot progress. I would humbly suggest that if you are looking at the server during the boot process, then there are issues and you might want to see the services loading and messages they report back. If you want to be a little more relaxed in your approach, try the theme solar. This shows a planet and some asteroids whizzing around it to illustrate the boot process.</p><p>On the command line, we display the default theme as follows:</p><div><pre class="programlisting">
<strong>$ plymouth-set-default-theme</strong>
</pre></div><p>To display the available themes on the system, we can use the command as follows:</p><div><pre class="programlisting">
<strong>$ plymouth-set-default-theme --list</strong>
</pre></div><p>CentOS, by default, provides three themes as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>details</strong>: This <a class="indexterm" id="id81"/>shows us the services as they load</li><li class="listitem" style="list-style-type: disc"><strong>rings</strong>: This is<a class="indexterm" id="id82"/> the default theme and includes the CentOS logo with a spinning ring below the logo</li><li class="listitem" style="list-style-type: disc"><strong>text</strong>: This <a class="indexterm" id="id83"/>is a blank splash screen with just the horizontal progress bar at the base of the display</li></ul></div><p>These themes are all located in sub directories under the path: <code class="literal">/usr/share/plymouth/themes</code>. Should we want to change the theme to <code class="literal">details</code>, we can do so by using the following command. Please note that the command does take a few minutes to run as the process rebuilds the RAM disk to include the new theme.</p><div><pre class="programlisting">
<strong># plymouth-set-default-theme --rebuild-initrd details</strong>
</pre></div><p>With this done, you can reboot and even see the difference as the system shuts down. Instead of the infernal rings, we see meaningful messages from our services as they close down.</p><p>If we want to be a little more adventurous, then standard CentOS repositories include the additional themes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">fade-in</li><li class="listitem" style="list-style-type: disc">solar</li><li class="listitem" style="list-style-type: disc">spinfinity</li></ul></div><p>In order to<a class="indexterm" id="id84"/> install and set the theme <code class="literal">spinfinity</code>, execute<a class="indexterm" id="id85"/> the following commands:</p><div><pre class="programlisting">
<strong># yum -y install plymouth-theme-spinfinity</strong>
<strong># plymouth-set-default-theme --rebuild-initrd spinfinity</strong>
</pre></div><p>A partial screenshot from the spinfinity theme is as shown in the following screenshot:</p><div><img alt="Applying different themes" src="img/5902OS_02_03.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Summary</h1></div></div></div><p>Well, here we are, we have made it to the end of another glorious chapter! You, my dear reader, yes you (there is only one of you), are a little closer to stardom in the Linux Hall of Fame.</p><p>We should now have been able to understand that GRUB is the bootloader commonly used in Enterprise Linux, and it will consist of stanzas to boot operating systems. Each stanza consists of three commands. The triumvirate of commands being root, kernel, and initrd. We also made sure we could edit the GRUB menu and solidly protect the GRUB console using passwords that are encrypted and unencrypted.</p><p>Finally, we ended up in the paddling pool, the watery shallows of Linux on a summer evening, learning to boot splash with plymouth. This decorated the dawn and dusk of a Linux day with a little color, or a lot of red in the case of spinfinity.</p><p>In the next section, we are going to walk into the Linux filesystems within CentOS, gaining an understanding of their makeup and structure. Starting with traditional systems based on disks or logical volumes, we will investigate how filenames relate to inodes and inodes relate to data. We will then move through to links, pipes, and sockets, and finally, finish off by taking a look at the <strong>Better FS</strong> (<strong>btrfs</strong>).</p></div></body></html>