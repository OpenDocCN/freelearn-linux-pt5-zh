- en: '*Chapter 9*: Writing SPI Device Drivers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Serial Peripheral Interface** (**SPI**) is (at least) a 4-wire bus – **Master
    Input Slave Output** (**MISO**), **Master Output Slave Input** (**MOSI**), **Serial
    Clock** (**SCK**), and **Chip Select** (**CS**) – which is used to connect serial
    flash and analog-to-digital/digital-to-analog converters. The master always generates
    the clock. Its speed can reach up to 80 MHz, though there is no real speed limitation
    (this is much faster than I2C as well). The same applies to the CS line, which
    is always managed by the master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these signal names has a synonym:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you see **Slave Input Master Output** (**SIMO**), **Slave Data Input**
    (**SDI**), or **Data Input** (**DI**), they refer to MOSI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave Output Master Input** (**SOMI**), **Slave Data Output** (**SDO**),
    and **Data Output** (**DO**) refer to MISO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Clock** (**SCK**), **Clock** (**CLK**), and **Serial Clock** (**SCL**)
    refer to SCK.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: S̅ S̅ is the Slave Select line, also called CS. CSx can be used (where *x* is
    an index such as CS0, CS1), EN and ENB too, meaning enable. CS is usually an active
    low signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows how SPI devices are connected to the controller
    via the bus it exposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – SPI slave devices and master interconnection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_09_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – SPI slave devices and master interconnection
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can represent the Linux kernel SPI framework
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The CPU is the master hosting the SPI controller, also known as the SPI master,
    which manages the bus segment hosting the SPI slave devices. In the kernel SPI
    framework, the bus is managed by a platform driver while the slave is driven by
    an SPI device driver. However, both drivers use APIs provided by the SPI core.
    In this chapter, we will be focusing on SPI (slave) device drivers, though references
    to the controller will be mentioned if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will walk through SPI driver concepts such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the SPI framework abstraction in the Linux kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with the SPI driver abstraction and architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how not to write SPI device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the SPI framework abstractions in the Linux kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel SPI framework is made up of a few data structures, the most
    important of which are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spi_controller`, used to abstract the SPI master device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_device`, used to abstract a slave device sitting on the SPI bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_driver`, the driver of the slave device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_transfer`, which is the low-level representation of one segment of a protocol.
    It represents a single operation between the master and slave. It expects Tx and/or
    Rx buffers as well as the length of the data to be exchanged and an optional CS
    behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_message`, which is an atomic sequence of transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now introduce each of these data structures, one after the other, starting
    with the most complex, which represents the SPI controller's data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Brief introduction to struct spi_controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will reference the controller because it is deeply
    coupled with the slaves and other data structures that the SPI framework is made
    up of. It is necessary therefore to introduce its data structure, represented
    by `struct spi_controller` and defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the important elements required for a better understanding of the data
    structure used in this chapter are listed in the preceding code. The following
    list explains their use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`num_chipselect` indicates the number of CSs assigned to this controller. CSs
    are used to distinguish individual SPI slaves and are numbered from 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_speed_hz` and `max_speed_hz` are the lowest and the highest transfer speeds
    supported by this controller, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_cs_timing` is a method provided if the SPI controller supports CS timing
    configuration, in which case the client drivers would call `spi_set_cs_timing()`
    with the requested timings. It has been deprecated in recent kernel versions by
    this patch: [https://lore.kernel.org/lkml/20210609071918.2852069-1-gregkh@linuxfoundation.org/](https://lore.kernel.org/lkml/20210609071918.2852069-1-gregkh@linuxfoundation.org/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer` adds a message to the transfer queue of the controller. On the controller
    registration path (thanks to `spi_register_controller()`), the SPI core checks
    whether this field is `NULL` or not:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `NULL`, the SPI core will check if either `transfer_one` or `transfer_one_message`
    is set, in which case it assumes this controller supports message queuing and
    invokes `spi_controller_initialize_queue()`, which will set this field with `spi_queued_transfer`
    (which is the SPI core helper to queue SPI messages to the controller's queue
    and to schedule the message pump `kworker` if it is not already running or busy).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, `spi_controller_initialize_queue()` will create both a dedicated kthread
    worker (`kworker` element) and a work struct (`pump_messages` element) for this
    controller. This worker will be scheduled quite often in order to process the
    message queue in a FIFO order.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the controller's `queued` element is set to true by the SPI core.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the controller's `rt` element has been set to true by the driver
    prior to calling the registration API, the SPI core will set the scheduling policy
    of the worker thread to the real-time FIFO policy, with a priority of 50.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `NULL`, and both `transfer_one` and `transfer_one_message` are also `NULL`,
    this is an error, and the controller is not registered.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If not `NULL`, the SPI core assumes the controller does not support queuing
    and does not call `spi_controller_initialize_queue()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer_one` and `transfer_one_message` are mutually exclusive. If both are
    set, the former won''t be invoked by the SPI core. `transfer_one` transfers a
    single SPI transfer and has no notion of `spi_message`. `transfer_one_message`,
    if provided by the driver, must work on the basis of `spi_message` and will be
    responsible for all the transfers in the messages. Controller drivers that need
    not bother with message-handling algorithms just have to set the `transfer_one`
    callback, in which case the SPI core will set `transfer_one_message` to `spi_transfer_one_message`.
    `spi_transfer_one_message` will take care of all the message logic, timings, CS,
    and other hardware-related properties prior to calling the driver provided `transfer_one`
    callback for each transfer in the message. CS remains active throughout the message
    transfers unless it is modified by a transfer that has `spi_transfer.cs_change
    = 1`. The message transfers will be performed using the clock and SPI mode parameters
    previously applied by `setup()` for this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kworker`: This is the kernel thread dedicated to the message pump processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pump_messages`: This is an abstraction of a work struct data structure for
    scheduling the function that processes the SPI message queue. It is scheduled
    in `kworker`. This work struct is backed by the `spi_pump_messages()` method,
    which checks if there are any SPI messages in the queue that need to be processed,
    and if so, it calls the driver to initialize the hardware and transfer each message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue_lock`: The spinlock to synchronize access to the message queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queue`: The message queue for this controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idling`: This indicates whether the controller device is entering an idle
    state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cur_msg`: The currently in-flight SPI message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`busy`: This indicates the busyness of the message pump.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running`: This indicates that the message pump is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rt`: This indicates whether `kworker` will run the message pump with real-time
    priority.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dma_tx`: The DMA transmit channel (when supported by the controller).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dma_rx`: The DMA receiving channel (when supported by the controller).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SPI transfers always read and write the same number of bytes, which means even
    when the client driver issues a half-duplex transfer, full duplex is emulated
    by the SPI core with `dummy_rx` and `dummy_tx` used to achieve this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dummy_rx`: This is a dummy receive buffer used for full-duplex devices, such
    that if a transfer''s receive buffer is `NULL`, received data will be shifted
    to this dummy receive buffer before being discarded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dummy_tx`: This is a dummy transmit buffer used for full-duplex devices, such
    that if a transfer''s transmit buffer is `NULL`, this dummy transmit buffer will
    be zero-filled and used as a transmit buffer for the transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do note that the SPI core names the SPI message pump worker task with the controller
    device name (dev->name), set in `spi_register_controller()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Later, when the worker is created during the queue initialization (remember,
    `spi_controller_initialize_queue()`), it is given this name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To recognize the SPI message pump worker on your system, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we can see the worker's name made up of the bus name
    along with the bus number.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we analyzed the concepts on the controller side to help get
    an understanding of the whole SPI slave implementation in the Linux kernel. The
    importance of this data structure is so great that I recommend you read this section
    whenever you feel you don't understand any mechanism in the coming sections. Now
    we can switch to SPI device data structures for real.
  prefs: []
  type: TYPE_NORMAL
- en: The struct spi_device structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first and most obvious data structure, `struct spi_device` represents an
    SPI device and is defined in `include/linux/spi/spi.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of readability, the number of fields listed is reduced to the
    strict minimum needed for the purpose of the book. The following list details
    the meaning of each element in this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`controller` represents the SPI controller this slave device belongs to. In
    other words, it represents the SPI controller (bus) on which the device is connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `master` element is still there for compatibility reasons and will be deprecated
    soon. It was the old name of the controller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_speed_hz` is the maximum clock rate to be used with this slave; this parameter
    can be changed from within the driver. We can override that parameter using `spi_transfer.speed_hz`
    for each transfer. We will discuss SPI transfer later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chip_select` is the CS line assigned to this device. It is active low by default.
    This behavior can be changed in `mode` by adding the `SPI_CS_HIGH` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rt`, if `true`, will make the message pump worker of the `controller` run
    as a real-time task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode` defines how data should be clocked. The device driver may change this.
    The data clocking is MSB by default for each word in a transfer. This behavior
    can be overridden by specifying `SPI_LSB_FIRST`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq` represents the interrupt number (registered as a device resource in your
    board initialization file or through the device tree) you should pass to `request_irq()`
    to receive interrupts from this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cs_gpio` and `cs_gpiod` are both optional. The former is the legacy integer-based
    GPIO number of the CS line, while the latter is the new and recommended interface,
    based on the GPIO descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A word about SPI modes – they are built using two characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CPOL, which is the initial clock polarity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: The initial clock state is low, and the first edge is rising.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: The initial clock state is high, and the first state is falling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPHA is the clock phase, determining at which edge the data will be sampled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0`: Data is latched at the falling edge (high to low transition), whereas
    the output changes at the rising edge.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Data is latched at rising edge (low to high transition), and the output
    changes at the falling edge.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This allows us to distinguish four SPI modes, which are derived macros made
    up of a mix of two main macros, defined in `include/linux/spi/spi.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The combinations of these macros give the following SPI modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 9.1 – SPI modes kernel definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_9.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9.1 – SPI modes kernel definition
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram is the representation of each SPI mode, in the same order
    as defined in the preceding array. That being said, only the MOSI line is represented,
    but the principle is the same for MISO.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – SPI operating modes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_09_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – SPI operating modes
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the SPI device data structure and the modes such
    a device can operate in, we can switch to the second-most important structure,
    the one representing the SPI device driver.
  prefs: []
  type: TYPE_NORMAL
- en: The spi_driver structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Also called the protocol driver, an SPI device driver is responsible for driving
    devices sitting on the SPI bus. It is abstracted in the kernel by `struct spi_driver`,
    declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list outlines the meanings of the elements in this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id_table`: This is the list of SPI devices supported by this driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`probe`: This method binds this driver to the SPI device. This function will
    be invoked on any device claiming this driver and will decide whether this driver
    is in charge of that device or not. If yes, the binding process occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: Unbinds this driver from the SPI device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown`: This is invoked during system state changes such as powering down
    and halting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver`: This is the low-level driver structure for the device and driver
    model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all we can say for now on this data structure, except that each SPI
    device driver must fill and expose one instance of this type.
  prefs: []
  type: TYPE_NORMAL
- en: The message transfer data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SPI I/O model consists of a set of queued messages, each of which can be
    made up of one or more SPI transfers. While a single message consists of one or
    more `struct spi_transfer` objects, each transfer represents a full duplex SPI
    transaction. Messages are submitted and processed either synchronously or asynchronously.
    The following is a diagram explaining the concept of message and transfer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Example SPI message structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_09_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Example SPI message structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are familiar with the theoretical aspects, we can introduce the
    SPI transfer data structure, declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of each element in the data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tx_buf` is a pointer to the buffer that contains the data to be written. If
    set to `NULL`, this transfer will be considered as half duplex as a read-only
    transaction. It should be DMA-safe when you need to perform an SPI transaction
    through DMA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx_buf` is a buffer for data to be read (with the same properties as `tx_buf`),
    or `NULL` in a write-only transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tx_dma` is the `tx_buf`, in case `spi_message.is_dma_mapped` is set to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rx_dma` is the same as `tx_dma`, but for `rx_buf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len` represents the size of the `rx` and `tx` buffers in bytes. Only `len`
    bytes shift out (or in) and attempting to shift out a partial word would result
    in an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speed_hz` supersedes the default speed specified in `spi_device.max_speed_hz`,
    but only for the current transfer. If `0`, the default (from `spi_device`) is
    used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bits_per_word`: A data transfer involves one or more words. A word is a unit
    of data whose size in bits varies according to the needs. Here, `bits_per_word`
    represents the size in bits of a word for this SPI transfer. This overrides the
    default value provided in `spi_device.bits_per_word`. If `0`, the default (from
    `spi_device`) is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cs_change` determines whether the CS becomes inactive after this transfer
    completes. All SPI transfers begin with the appropriate CS signal active. Normally,
    it remains selected until the last transfer in the message is completed. Using
    `cs_change`, drivers can change the CS signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This flag is used to make the CS temporarily inactive in the middle of the message
    (that is, before processing the `spi_transfer` on which it is specified) if the
    transfer isn't the last one in the message. Toggling CS in this way may be required
    to complete a chip command, allowing a single SPI message to handle the entire
    set of chip transactions.
  prefs: []
  type: TYPE_NORMAL
- en: '`delay_usecs` represents the delay (in microseconds) following this transfer
    before (optionally) changing the `chip_select` status, then starting the next
    transfer or completing this `spi_message`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SPI transfers always write the same number of bytes as they read, even in half-duplex
    transactions. The SPI core achieves this thanks to the controller's `dummy_rx`
    and `dummy_tx` elements. When the transmit buffer is null, `spi_transfer->tx_buf`
    will be set with the controller's `dummy_tx`. Then, zeroes will be shifted out
    while filling `rx_buf` with the data coming from the slave. If the receive buffer
    is null, `spi_transfer->rx_buf` will be set with the controller's `dummy_rx` and
    the data shifted in will be discarded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: struct spi_message
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`spi_message` is used to atomically issue a sequence of transfers, each represented
    by a `struct spi_transfer` instance. We say *atomically* because no other `spi_message`
    may use that SPI bus until the ongoing sequence completes. Do however note that
    there are platforms that can handle many such sequences with a single programmed
    DMA transfer. An SPI message structure has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list outlines the meanings of elements in this data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`transfers` is the list of transfers that constitute the message. We will see
    later how to add a transfer to this list. Using the `spi_transfer.cs_change` flag
    on the last transfer in that atomic group may potentially save costs for chip
    deselect and select operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_dma_mapped` informs the controller whether to use DMA (or not) to perform
    the transaction. Your code is then responsible for providing DMA and CPU virtual
    addresses for each transfer buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complete` is a callback called when the transaction is done, and `context`
    is the parameter to be given to the callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame_length` will be set automatically with the total number of bytes in
    the message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actual_length` is the number of bytes transferred in all successful segments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status` reports the transfer''s status. This is `0` on success; otherwise,
    it''s `-errno`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi_transfer` elements in a message are processed in FIFO order. Until the
    message is completed (that is, until the completion callback is executed), you
    must make sure not to use transfer buffers in order to avoid data corruption.
    The code that submits a `spi_message` (and its `spi_transfers`) to the lower layers
    is responsible for managing its memory. Drivers must ignore the message (and its
    transfers) once submitted at least until its completion callback is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the SPI device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An SPI controller is able to communicate with one or more slaves, that is, one
    or more `struct spi_device`. They form a tiny bus that shares MOSI, MISO, and
    SCK signals but not CS. Because those shared signals are ignored unless the chip
    is selected, each device can be programmed to utilize a different clock rate.
    The SPI controller driver manages communication with those devices through a queue
    of `spi_message` transactions, moving data between CPU memory and an SPI slave
    device. For each message instance it queues, it calls the message's completion
    callback when the transaction completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before a message can be submitted to the bus, it has to be initialized with
    `spi_message_init()`, which has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will zero each element in the structure and initialize the transfers
    list. For each transfer to be added to the message, you should call `spi_message_add_tail()`
    on that transfer, which will result in enqueuing the transfer into the message''s
    transfers list. It has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, you have two choices to start the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int spi_sync(struct spi_device *spi, struct spi_message *message)`, which
    returns `0` on success, else a negative error code. This function may sleep and
    is not to be used in interrupt contexts. Do however note that this function may
    sleep in a non-interruptible manner, and does not allow specifying a timeout.
    A DMA-capable controller''s driver may leverage this DMA feature to push/pull
    data directly into/from the message buffers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SPI device's CS is activated by the core during an entire message (from
    the first transfer to the last), and is then normally disabled between messages.
    There are drivers which, in order to minimize the impacts of selecting a chip
    (to save power for example), leave it selected, anticipating that the next message
    will go to the same chip.
  prefs: []
  type: TYPE_NORMAL
- en: '`spi_async()` function, which can be used in an any context (atomic or not),
    and whose prototype is `int spi_async(struct spi_device *spi, struct spi_message
    *message)`. This function is context agnostic since only submission is done and
    the processing is asynchronous. However, the completion callback is invoked in
    a context that can''t sleep. Before this callback is invoked, the value of `message->status`
    is undefined. At the time it is invoked, `message->status` holds the completion
    status, which is either `0` (to indicate complete success) or a negative error
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that callback returns, the driver that initiated the transfer request
    may deallocate the associated memory since it's no longer in use by any SPI core
    or controller driver code. Until the completion callback of the currently processed
    message returns, no subsequent `spi_message` queued to that device will be processed.
    This rule applies to synchronous transfer calls as well, since they are wrappers
    around this core asynchronous primitive. This function returns `0` on success,
    else a negative error code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt from a driver demonstrating SPI message and transfer
    initialization and submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding excerpt however shows static initialization, on the fly, where
    both messages and transfers are discarded on the return path of the function.
    There may be cases where the driver would like to pre-allocate messages along
    with their transfers for the lifetime of the driver in order to avoid a frequent
    initialization overhead. In such cases, dynamic allocation can be used thanks
    to `spi_message_alloc()`, and freed using `spi_message_free()`. They have the
    following prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, `ntrans` is the number of transfers to allocate for
    this new `spi_message`, and `flags` represents the flags for the freshly allocated
    memory, where using `GFP_KERNEL` is enough. On success, this function returns
    the new allocated message structure along with its transfers. You can access transfer
    elements using kernel list-related macros such as `list_first_entry`, `list_next_entry`,
    or even `list_for_each_entry`. The following is an example showing the usage of
    these macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding excerpt, we have not only shown how to use dynamic message
    and transfer allocation. We have also seen how `spi_async()` is used. This example
    is quite useless since the allocated message and transfers are immediately freed
    upon completion. A best practice with dynamic allocation is to allocate Tx and
    Rx buffers dynamically as well, and keep them within arm's reach for the lifetime
    of the driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note however that the device driver is responsible for organizing the messages
    and transfer in the most appropriate way for the device, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When bidirectional reads and writes start and how its sequence of `spi_transfer`
    requests are arranged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O buffer preparation, knowing that each `spi_transfer` wraps a buffer for
    each transfer direction, supporting full duplex transfers (even if one pointer
    is `NULL`, in which case the controller will use one of its dummy buffers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally using `spi_transfer.delay_usecs` to define short delays after transfers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether CS should change (becoming inactive) after a transfer and any delay
    by using the `spi_transfer.cs_change` flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `spi_async`, the device driver queues the messages, registers a completion
    callback, wakes the message pump, and immediately returns. The completion callback
    will be invoked when the transfers are complete. Because neither message queuing
    nor message pump scheduling can block, the `spi_async` function is considered
    context agnostic. However, it requires that you wait for the completion callback
    before you can access the buffers in the `spi_transfer` pointers you submitted.
    On the other hand, `spi_sync` queues the messages and blocks until they are complete.
    It does not require completion callback. When `spi_sync` returns, it is safe to
    access your data buffers. If you look at its implementation in `drivers/spi/spi.c`,
    you'll see it uses `spi_async` to put the calling thread to sleep until the completion
    callback is called. Since the 4.0 kernel there has been an improvement for `spi_sync`
    where, when there is nothing in the queue, the message pump will get executed
    in the context of the caller instead of the message pump thread, which avoids
    the cost of a context switch.
  prefs: []
  type: TYPE_NORMAL
- en: After the most important data structures and APIs of the SPI framework have
    been introduced, we can discuss the real driver implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the SPI driver abstraction and architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where the driver logic takes place. It consists of filling `struct spi_driver`
    with a set of driving functions that allow probing and controlling the underlying
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Probing the device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SPI device is probed by the `spi_driver.probe` callback. The probe callback
    is responsible for making sure the driver recognizes the given device before they
    can be bound together. This callback has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method must return `0` on success, or a negative error number otherwise.
    The only argument is the SPI device to be probed, whose structure has been pre-initialized
    by the core according to its description in the device tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, most (if not all) of the properties of the SPI device can be overridden,
    as we have seen while describing its data structure. SPI protocol drivers may
    need to update the transfer mode if the device doesn''t work with its default.
    They may likewise need to update clock rates or word sizes from their initial
    values. This is possible thanks to the `spi_setup()` helper, which has the following
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This function must be called from a context that can sleep exclusively. It expects
    as a parameter an SPI device structure whose properties to override must have
    been set in their respective fields. Changes will be effective at the next device
    access (either for a read or write operation after it has been selected) except
    for `SPI_CS_HIGH`, which takes effect immediately. The SPI device is deselected
    on the return path of this function. This function returns `0` on success or a
    negative error on failure. It is worth paying attention to its return value because
    this call won't succeed if the driver provides an option that is not supported
    by the underlying controller or its driver. For instance, some hardware handles
    wire transfers using nine-bit words, **least significant bit** (**LSB**)-first
    wire encoding, or active-high CS, and others do not.
  prefs: []
  type: TYPE_NORMAL
- en: You likely want to call `spi_setup()`from `probe()` before submitting any I/O
    request to the device. However, it can be called anywhere in the code provided
    no message is pending for that device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a probing example that sets up the SPI device, checks its
    family ID, and returns `0` (device recognized) on success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A real probing method would also probably deal with some driver state data
    structures or other per-device data structures. Regarding the `get_chip_version()`
    function, it may have the following body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to probe an SPI device, it will be useful to discuss
    how to tell the SPI core which devices the driver can support.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The SPI core allows setting/getting driver state data using `spi_get_drvdata()`
    and `spi_set_drvdata()` in the same way as we did while discussing I2C device
    drivers in [*Chapter 8*](B17934_08_Epub.xhtml#_idTextAnchor117)*, Writing I2C
    Device Drivers*.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning devices in the driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we need a list of i`2c_device_id` to tell I2C core what devices an I2C driver
    can support, we must provide an array of `spi_device_id` to inform the SPI core
    what devices our SPI driver supports. After that array has been filled, it must
    be assigned to the `spi_driver.id_table` field. Additionally, for device matching
    and module loading purposes, this same array needs to be given to the `MODULE_DEVICE_TABLE`
    macro. `struct spi_device_id` has the following declaration in `include/linux/mod_devicetable.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding data structure, `name` is a descriptive name for the device,
    and `driver_data` is the driver state value. It can be set with a pointer to a
    per-device data structure. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to match the devices declared in the device tree, we need to define
    an array of `struct of_device_id` elements and both assign it to `spi_driver.of_match_table`
    and call the `MODULE_DEVICE_TABLE` macro on it. The following is an example, which
    also shows what the final `spi_driver` structure would look like when it is set
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following excerpt shows the final `spi_driver` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, we can see what an SPI driver structure looks like after it
    has been set up. There is however a missing element, the `spi_driver.remove` callback,
    which is used to undo what was done in the probing function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the spi_driver.remove method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `remove` callback must be used to release every resource grabbed and undo
    what was done at probing. This callback has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, `spi` is the SPI device data structure, the same
    given to the `probe` callback, which simplifies device state data structure tracking
    between the probing and the removal of the device. This method returns `0` on
    success or a negative error code on failure. You must make sure that the device
    is left in a coherent and stable state as well. The following is an example implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the code dealt with unregistering from the frameworks
    and releasing the resources. This is the classic case that you will face in 90%
    of cases.
  prefs: []
  type: TYPE_NORMAL
- en: Driver initialization and registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this step of implementation, your code is almost ready, and you would like
    to inform the SPI core of your SPI driver. This is driver registration. For SPI
    device drivers, the SPI core provides `spi_register_driver()` and `spi_unregister_driver()`
    both to register and unregister and SPI device driver with the SPI core. Those
    methods have the following prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In both functions, `sdrv` is the SPI driver structure that has been previously
    set up. The registration API returns zero on success or a negative error code
    on failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Driver registration and unregistering usually take place in the module initialization
    and module exit method. The following is a typical demonstration of SPI driver
    registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do nothing at module initialization other than registering/unregistering
    the driver, you can use `module_spi_driver()` to factor your code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This macro will populate module initialization and cleanup functions and will
    call `spi_register_driver` and `spi_unregister_driver` inside.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating SPI devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SPI slave nodes must be children of the SPI controller node. In master mode,
    one or more slave nodes (up to the number of CSs) can be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required properties are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compatible`: The compatible string as defined in the driver for matching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reg`: The CS index of the device relative to the controller'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-max-frequency`: The maximum SPI clocking speed of the device in Hz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All slave nodes can contain the following optional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spi-cpol`: Boolean property which, if present, indicates that the device requires
    inverse **clock polarity** (**CPOL**) mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-cpha`: Boolean property indicating that this device requires shifted **clock
    phase** (**CPHA**) mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-cs-hi–h`: Empty property indicating that the device requires CS active
    high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-3wire`: This is a Boolean property that indicates that this device requires
    3-wire mode to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-lsb-first`: This is a Boolean property that indicates that this device
    requires LSB first mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-tx-bus-width`: This property indicates the bus width used for MOSI. If
    not present, it defaults to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-rx-bus-width`: This property is used to indicate the bus width used for
    MISO. If not present, it defaults to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-rx-delay-–s`: This is used to specify a delay in microseconds after a
    read transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spi-tx-delay-us`: This is used to specify a delay in microseconds after a
    write transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a real device tree listing for SPI devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding device tree excerpt, `ecspi1` represents the master SPI controller.
    `fake_spi_device` and `mcp2515can` represent SPI slave devices, and their `reg`
    properties represents their respective CS indices relative to the master.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with all the kernel aspects of the SPI slave-oriented
    framework, let's see how we might avoid dealing with the kernel and try to implement
    everything in the user space.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how not to write SPI device drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usual way to deal with SPI devices is to write kernel code to drive this
    device. Nowadays the `spidev` interface makes it possible to deal with such devices
    without even writing a line of kernel code. The use of this interface should be
    limited, however, to simple use cases such as talking to a slave microcontroller
    or for prototyping. Using this interface, you will not be able to deal with various
    **interrupts** (**IRQs**) the device may support nor leverage other kernel frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The `spidev` interface exposes a character device node in the form `/dev/spidevX.Y`
    where `X` represents the bus our device sits on, and `Y` represents the CS index
    (relative to the controller) assigned to the device node in the device tree. For
    example, `/dev/spidev1.0` means device `0` on SPI bus `1`. The same applies to
    the sysfs directory entry, which would be in the form `/sys/class/spidev/spidevX.Y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the character device appearing in the user space, the device node
    must be declared in the device tree as a child of the SPI controller node. The
    following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `spidev@0` corresponds to our SPI device node. `reg
    = <0>` tells the controller that this device is using the first CS line (index
    starting from 0). The `compatible="semtech,sx1301"` property is used to match
    an entry in the `spidev` driver. It is no longer recommended to use `"spidev"`
    as a compatible string – you'll get a warning if you try. Finally, `spi-max-frequency
    = <20000000>` sets the default clock speed (20 MHz in this case) that our device
    will operate at, unless it is changed using the appropriate API.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the user space, the required header files to deal with the `spidev` interface
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Because it is a character device, it is allowed (this is the only option, in
    fact) to use basic system calls such as `open()`, `read()`, `write()`, `ioctl()`,
    and `close()`. The following example shows some basic usage, with `read()` and
    `write()` operations only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you should note that the standard `read()` and `write()`
    operations are half-duplex only, and that the CS is deactivated between each operation.
    To be able to work in full duplex, you have no choice but to use the `ioctl()`
    interface, where you can pass both input and output buffers at your convenience.
    Moreover, with the `ioctl()` interface, you can use a set of `SPI_IOC_RD_*` and
    `SPI_IOC_WR_*` commands to get `RD` and set `WR` to override the device's current
    setting. The complete list and documentation for this can be found in `Documentation/spi/spidev`
    in the kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ioctl()` interface allows composite operations without CS deactivation
    and is available using the `SPI_IOC_MESSAGE(N)` request. A new data structure
    takes place, the `struct spi_ioc_transfer`, which is the user space equivalent
    of `struct spi_transfer`. The following is an example of the ioctl commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, getters are used for demonstration purposes only.
    It is not mandatory to issue the `SPI_IOC_RD_*` command after you have executed
    its `SPI_IOC_WR_*` equivalent. Now that we have seen most of those ioctl commands,
    let''s see how to start transfers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding shows the concept of message and transfer transactions in the
    user space. Now that our helpers have been defined, we can write the main code
    to use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are now done with the main function. This section taught us to use the user
    space SPI APIs and commands to interact with the device. We are limited, however,
    in that we can't take advantage of device interrupt lines or other kernel frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we tackled SPI drivers and can now take the advantage of this
    serial (and full duplex) bus, which is way faster than I2C. We walked through
    all the data structures in this framework and discussed transferring over SPI,
    which is the most important section we covered. That said, the memory we accessed
    over those buses was off-chip – we may need more abstraction in order to avoid
    the SPI and I2C APIs.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the next chapter comes in, dealing with the regmap API, which
    offers a higher and more unified level of abstraction so that SPI (and I2C) commands
    will become transparent to you.
  prefs: []
  type: TYPE_NORMAL
