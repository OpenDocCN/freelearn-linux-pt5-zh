- en: File In, File Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件输入，文件输出
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Generating files of any size
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成任意大小的文件
- en: The intersection and set difference (A-B) on text files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文本文件进行交集和差集（A-B）操作
- en: Finding and deleting duplicate files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并删除重复文件
- en: Working with file permissions, ownership, and the sticky bit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件权限、所有权和粘滞位
- en: Making files immutable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使文件不可变
- en: Generating blank files in bulk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量生成空白文件
- en: Finding symbolic links and their targets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找符号链接及其目标
- en: Enumerating file type statistics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举文件类型统计信息
- en: Using loopback files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回环文件
- en: Creating ISO files and hybrid ISO
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ISO 文件和混合 ISO
- en: Finding the difference between files, and patching
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件之间的差异，并进行修补
- en: Using head and tail for printing the last or first 10 lines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 head 和 tail 打印最后或最前面的 10 行
- en: Listing only directories - alternative methods
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅列出目录 - 替代方法
- en: Fast command-line navigation using `pushd` and `popd`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pushd` 和 `popd` 快速导航命令行
- en: Counting the number of lines, words, and characters in a file
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文件中的行数、单词数和字符数
- en: Printing the directory tree
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印目录树
- en: Manipulating video and image files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作视频和图像文件
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Unix provides a file-style interface to all devices and system features. The
    special files provide direct access to devices such as USB sticks and disk drives
    and provide access to system functions such as memory usage, sensors, and the
    process stack. For example, the command terminal we use is associated with a device
    file. We can write to the terminal by writing to the corresponding device file.
    We can access directories, regular files, block devices, character-special devices,
    symbolic links, sockets, named pipes, and so on as files. Filename, size, file
    type, modification time, access time, change time, inode, links associated, and
    the filesystem the file is on are all attributes and properties files can have.
    This chapter deals with recipes to handle operations or properties related to
    files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 提供了一种文件式接口来访问所有设备和系统功能。特殊文件提供了直接访问设备（如 USB 闪存和磁盘驱动器）的方式，还提供了访问系统功能（如内存使用情况、传感器和进程栈）的功能。例如，我们使用的命令终端与一个设备文件相关联。通过写入对应的设备文件，我们可以向终端写入数据。我们可以像操作文件一样访问目录、常规文件、块设备、字符特殊设备、符号链接、套接字、命名管道等。文件名、大小、文件类型、修改时间、访问时间、变更时间、inode、关联的链接以及文件所在的文件系统，都是文件可能具备的属性和特性。本章将介绍与文件相关的操作或属性的处理方法。
- en: Generating files of any size
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成任意大小的文件
- en: A file of random data is useful for testing. You can use such files to test
    application efficiency, to confirm that an application is truly input-neutral,
    to confirm there's no size limitations in your application, to create loopback
    filesystems (**loopback files** are files that can contain a filesystem itself
    and these files can be mounted similarly to a physical device using the `mount`
    command), and more. Linux provides general utilities to construct such files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数据文件对于测试非常有用。你可以使用此类文件来测试应用程序效率，确认应用程序是否真正对输入数据中立，确认应用程序没有大小限制，创建回环文件系统（**回环文件**是可以包含文件系统本身的文件，并且这些文件可以像物理设备一样通过
    `mount` 命令进行挂载），等等。Linux 提供了通用的工具来构建此类文件。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'The easiest way to create a large file of a given size is with the `dd` command.
    The `dd` command clones the given input and writes an exact copy to the output.
    Input can be `stdin`, a device file, a regular file, and so on. Output can be
    `stdout`, a device file, a regular file, and so on. An example of the `dd` command
    is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建指定大小的大文件最简单的方法是使用 `dd` 命令。`dd` 命令将给定的输入克隆并将精确副本写入输出。输入可以是 `stdin`、设备文件、常规文件等。输出可以是
    `stdout`、设备文件、常规文件等。以下是 `dd` 命令的示例：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command creates a file called `junk.data` containing exactly 1 MB of zeros.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建一个名为 `junk.data` 的文件，文件大小为 1 MB，全是零。
- en: 'Let''s go through the parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下参数：
- en: '`if` defines the `input` file'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 定义 `input` 文件'
- en: '`of` defines the `output` file'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of` 定义 `output` 文件'
- en: '`bs` defines bytes in a block'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bs` 定义块中的字节数'
- en: '`count` defines the number of blocks to be copied'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 定义要复制的块数'
- en: Be careful while using the `dd` command as root, as it operates on a low level
    with the devices. A mistake could wipe your disk or corrupt the data. Double-check
    your `dd` command syntax, especially your of `=` parameter for accuracy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dd` 命令时要小心，因为它以低级方式操作设备。错误的操作可能会清除磁盘或破坏数据。务必仔细检查你的 `dd` 命令语法，尤其是 `=` 参数的准确性。
- en: In the previous example, we created a 1 MB file, by specifying `bs` as 1 MB
    with a count of 1\. If `bs` was set to `2M` and `count` to `2`, the total file
    size would be 4 MB.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过将`bs`设置为1 MB并设置`count`为1创建了一个1 MB的文件。如果`bs`设置为`2M`，`count`设置为`2`，那么总文件大小将为4
    MB。
- en: 'We can use various units for **block****size** (**bs**). Append any of the
    following characters to the number to specify the size:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的单位来指定**块大小**（**bs**）。将以下任何字符附加到数字后面来指定大小：
- en: '| **Unit size** | **Code** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **单位大小** | **代码** |'
- en: '| Byte (1 B) | `C` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 字节 (1 B) | `C` |'
- en: '| Word (2 B) | `W` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 字节 (2 B) | `W` |'
- en: '| Block (512 B) | `B` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 块 (512 B) | `B` |'
- en: '| Kilobyte (1024 B) | `K` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 千字节 (1024 B) | `K` |'
- en: '| Megabyte (1024 KB) | `M` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 兆字节 (1024 KB) | `M` |'
- en: '| Gigabyte (1024 MB) | `G` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 千兆字节 (1024 MB) | `G` |'
- en: We can generate a file of any size using **bs**. Instead of MB we can use any
    other unit notations, such as the ones mentioned in the previous table.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**bs**生成任何大小的文件。除了MB外，我们还可以使用表格中提到的其他单位表示法。
- en: '`/dev/zero` is a character special device, which returns the zero byte (`\0`).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/zero`是一个字符特殊设备，返回零字节（`\0`）。'
- en: If the input parameter (`if`) is not specified, dd will read input from `stdin`.
    If the output parameter (`of`) is not specified, `dd` will use `stdout`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定输入参数（`if`），`dd`将从`stdin`读取输入。如果没有指定输出参数（`of`），`dd`将使用`stdout`。
- en: The `dd` command can be used to measure the speed of memory operations by transferring
    a large quantity of data to `/dev/null` and checking the command output (for example,
    `1048576 bytes (1.0 MB) copied, 0.00767266 s, 137 MB/s`, as seen in the previous
    example).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令可以通过将大量数据传输到`/dev/null`并检查命令输出（例如，`1048576 bytes (1.0 MB) copied, 0.00767266
    s, 137 MB/s`，如前面的示例所示）来测量内存操作的速度。'
- en: The intersection and set difference (A-B) on text files
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本文件的交集和集合差异 (A-B)
- en: Intersection and set difference operations are common in mathematics classes
    on set theory. Similar operations on strings are useful in some scenarios.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 交集和集合差异操作在数学课程中的集合理论中很常见。对字符串进行类似的操作在某些场景中也很有用。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: The `comm` command is a utility to perform a comparison between two sorted files.
    It displays lines that are unique to file 1, file 2, and lines in both files.
    It has options to suppress one more column, making it easy to perform intersection
    and difference operations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`comm`命令是一个用于比较两个已排序文件的工具。它显示文件1、文件2中的唯一行以及两个文件中共有的行。它有选项可以抑制某一列，使得执行交集和差异操作变得更加容易。'
- en: '**Intersection**: The intersection operation will print the lines the specified
    files have in common with one another'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：交集操作将打印指定文件之间共有的行。'
- en: '**Difference**: The difference operation will print the lines the specified
    files contain and that are not the same in all of those files'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差异**：差异操作将打印指定文件中存在的行，这些行在所有这些文件中并不相同。'
- en: '**Set difference**: The set difference operation will print the lines in file
    `A` that do not match those in all of the set of files specified (`B` plus `C`,
    for example)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合差异**：集合差异操作将打印文件`A`中不与所有指定文件的集合（例如，`B`和`C`）匹配的行。'
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: 'Note that `comm` takes two sorted files as input. Here are our sample input
    files:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`comm`需要两个已排序的文件作为输入。以下是我们的示例输入文件：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, execute `comm` without any options:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，执行没有任何选项的`comm`：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first column of the output contains lines that are only in `A.txt`. The
    second column contains lines that are only in `B.txt`. The third column contains
    the common lines from `A.txt` and `B.txt`. Each of the columns are delimited using
    the tab (`\t`) character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一列包含仅出现在`A.txt`中的行。第二列包含仅出现在`B.txt`中的行。第三列包含来自`A.txt`和`B.txt`的共有行。每列都使用制表符（`\t`）字符进行分隔。
- en: 'In order to print the intersection of two files, we need to remove the first
    and second columns and print the third column. The `-1` option removes the first
    column, and the `-2` option removes the second column, leaving the third column:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了打印两个文件的交集，我们需要移除第一列和第二列，并打印第三列。`-1`选项移除第一列，`-2`选项移除第二列，剩下第三列：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Print only the lines that are uncommon between the two files by removing column
    `3`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅打印两个文件之间不同的行，方法是移除第3列：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This output uses two columns with blanks to show the unique lines in file1
    and file2\. We can make this more readable as a list of unique lines by merging
    the two columns into one, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出使用两列并带有空白，显示文件1和文件2中的唯一行。我们可以通过将两列合并成一列，使其更加易读，如下所示：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The lines can be merged by removing the tab characters with `tr` (discussed
    in [Chapter 2](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml), *Have a Good Command*)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `tr` 去除制表符字符，可以合并这些行（具体内容见 [第2章](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml)，*掌握命令行*）
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By removing the unnecessary columns, we can produce the set difference for
    `A.txt` and `B.txt`, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过去除不必要的列，我们可以生成 `A.txt` 和 `B.txt` 的集合差异，如下所示：
- en: 'Set difference for `A.txt`:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A.txt` 的集合差异：'
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`-2 -3` removes the second and third columns'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`-2 -3` 删除第二列和第三列'
- en: 'Set difference for `B.txt`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B.txt` 的集合差异：'
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`-2 -3` removes the second and third columns'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`-2 -3` 删除第二列和第三列'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'These command-line options reduce the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令行选项可以减少输出：
- en: '`-1`: Removes the first column'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`：删除第一列'
- en: '`-2`: Removes the second column'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-2`：删除第二列'
- en: '`-3`: Removes the third column'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-3`：删除第三列'
- en: The set difference operation enables you to compare two files and print all
    the lines that are in the `A.txt` or `B.txt` file excluding the common lines in
    `A.txt` and `B.txt`. When `A.txt` and `B.txt` are given as arguments to the `comm`
    command, the output will contain column-1 with the set difference for `A.txt`
    with regard to `B.txt` and column-2 will contain the set difference for `B.txt`
    with regard to `A.txt`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 集合差异操作允许你比较两个文件，并打印出 `A.txt` 或 `B.txt` 中的所有行，排除 `A.txt` 和 `B.txt` 中的公共行。当 `A.txt`
    和 `B.txt` 作为参数传递给 `comm` 命令时，输出将包含第一列为 `A.txt` 相对于 `B.txt` 的集合差异，第二列为 `B.txt`
    相对于 `A.txt` 的集合差异。
- en: The `comm` command will accept a `-` character on the command line to read one
    file from `stdin`. This provides a way to compare more than one file with a given
    input.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`comm` 命令允许在命令行中使用 `-` 字符来从 `stdin` 读取一个文件。这为比较多个文件与给定输入提供了一种方式。'
- en: 'Suppose we have a `C.txt` file, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `C.txt` 文件，内容如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can compare the `B.txt` and `C.txt` files with `A.txt`, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `B.txt` 和 `C.txt` 文件与 `A.txt` 比较，像这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finding and deleting duplicate files
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和删除重复文件
- en: 'If you need to recover backups or you use your laptop in a disconnected mode
    or download images from a phone, you''ll eventually end up with duplicates: files
    with the same content. You''ll probably want to remove duplicate files and keep
    a single copy. We can identify duplicate files by examining the content with shell
    utilities. This recipe describes finding duplicate files and performing operations
    based on the result.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要恢复备份，或者在断网模式下使用笔记本电脑，或者从手机下载图片，你最终会遇到重复文件：内容相同的文件。你可能会想删除重复的文件，并保留一份副本。我们可以通过使用
    shell 工具来检查内容，从而识别重复文件。这个方法描述了如何找到重复文件并根据结果执行操作。
- en: Getting ready
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We identify the duplicate files by comparing file content. Checksums are ideal
    for this task. Files with the same content will produce the same checksum values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过比较文件内容来识别重复文件。校验和非常适合此任务。内容相同的文件会产生相同的校验和值。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Follow these steps for finding or deleting duplicate files:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤查找或删除重复文件：
- en: 'Generate some test files:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一些测试文件：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The code for the script to remove the duplicate files uses `awk`, an interpreter
    that''s available on all Linux/Unix systems:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除重复文件的脚本代码使用了 `awk`，这是在所有 Linux/Unix 系统中都可以使用的解释器：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the code as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式运行代码：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: The preceding code will find the copies of the same file in a directory and
    remove all except one copy of the file. Let's go through the code and see how
    it works.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码会在一个目录中找到相同文件的副本，并删除除一份副本之外的所有文件。让我们来逐步了解这段代码是如何工作的。
- en: '`ls -lS` lists the details of the files in the current folder sorted by file
    size. The `--time-style=long-iso` option tells `ls` to print dates in the ISO
    format. `awk` reads the output of `ls -lS` and performs comparisons on columns
    and rows of the input text to find duplicate files.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls -lS` 按文件大小列出当前文件夹中文件的详细信息。`--time-style=long-iso` 选项告诉 `ls` 以 ISO 格式打印日期。`awk`
    读取 `ls -lS` 的输出，并对输入文本的列和行进行比较，以查找重复文件。'
- en: 'The logic behind the code is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码背后的逻辑如下：
- en: We list the files sorted by size, so files of the same size will be adjacent.
    The first step in finding identical files is to find ones with the same size.
    Next, we calculate the checksum of the files. If the checksums match, the files
    are duplicates and one set of the duplicates are removed.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们按文件大小列出文件，所以相同大小的文件将相邻。查找相同文件的第一步是找到大小相同的文件。接下来，我们计算文件的校验和。如果校验和匹配，则这些文件是重复文件，并且会删除其中一组副本。
- en: 'The `BEGIN{}` block of `awk` is executed before the main processing. It reads
    the "total" lines and initializes the variables. The bulk of the processing takes
    place in the `{}` block, when `awk` reads and processes the rest of the `ls` output.
    The `END{}` block statements are executed after all input has been read. The output
    of `ls -lS` is as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awk` 的 `BEGIN{}` 块在主要处理之前执行。它读取 "total" 行并初始化变量。大部分处理发生在 `{}` 块中，当 `awk` 读取并处理其余的
    `ls` 输出时。`END{}` 块中的语句在所有输入读取完成后执行。`ls -lS` 的输出如下：'
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output of the first line tells us the total number of files, which in this
    case is not useful. We use `getline` to read the first line and then dump it.
    We need to compare each of the lines and the following line for size. In the `BEGIN`
    block, we read the first line and store the name and size (which are the eighth
    and fifth columns). When `awk` enters the `{}` block, the rest of the lines are
    read, one by one. This block compares the size obtained from the current line
    and the previously stored size in the `size` variable. If they are equal, it means
    that the two files are duplicates by size and must be further checked by `md5sum`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行的输出告诉我们文件的总数，在这种情况下没有用处。我们使用 `getline` 来读取第一行，然后丢弃它。我们需要比较每一行和随后的行的大小。在 `BEGIN`
    块中，我们读取第一行并存储文件名和大小（分别是第八列和第五列）。当 `awk` 进入 `{}` 块时，剩余的行会逐行读取。此块比较当前行获取的大小和先前存储在
    `size` 变量中的大小。如果它们相等，则意味着这两个文件通过大小是重复的，必须通过 `md5sum` 进一步检查。
- en: We have played some tricks on the way to the solution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在解决方案的过程中玩了一些小技巧。
- en: 'The external command output can be read inside `awk` as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式在 `awk` 中读取外部命令的输出：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the line is read, the entire line is in `$0` and each column is available
    in `$1`, `$2`, ..., `$n`. Here, we read the md5sum checksum of files into the
    `csum1` and `csum2` variables. The `name1` and `name2` variables store the consecutive
    filenames. If the checksums of two files are the same, they are confirmed to be
    duplicates and are printed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取了行，整行内容就会存储在 `$0` 中，每一列的内容可通过 `$1`、`$2`、...、`$n` 获取。在这里，我们将文件的 md5sum 校验和读取到
    `csum1` 和 `csum2` 变量中。`name1` 和 `name2` 变量存储连续的文件名。如果两个文件的校验和相同，则它们被确认是重复文件并被打印出来。
- en: We need to find a file from each group of duplicates so we can remove all other
    duplicates. We calculate the `md5sum` value of the duplicates and print one file
    from each group of duplicates by finding unique lines, comparing `md5sum` from
    each line using `-w 32` (the first 32 characters in the `md5sum` output; usually,
    the `md5sum` output consists of a 32-character hash followed by the filename).
    One sample from each group of duplicates is written to `unique_files`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从每一组重复文件中找到一个文件，这样我们就可以删除所有其他的重复文件。我们计算重复文件的 `md5sum` 值，并通过查找唯一行来打印每组重复文件中的一个文件，通过使用
    `-w 32` 来比较每行的 `md5sum`（`md5sum` 输出的前32个字符；通常 `md5sum` 的输出是一个32字符的哈希值，后跟文件名）。每组重复文件中的一个样本被写入
    `unique_files`。
- en: Now, we need to remove the files listed in `duplicate_files`, excluding the
    files listed in `unique_files`. The `comm` command prints files in `duplicate_files`
    but not in `unique_files`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要删除 `duplicate_files` 中列出的文件，排除 `unique_files` 中列出的文件。`comm` 命令打印出在 `duplicate_files`
    中但不在 `unique_files` 中的文件。
- en: For that, we use a set difference operation (refer to the recipes on intersection,
    difference, and set difference).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用集合差操作（参见交集、差集和集合差集的相关操作）。
- en: '`comm` only processes sorted input. Therefore, `sort -u` is used to filter
    `duplicate_files` and `unique_files`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`comm` 仅处理排序后的输入。因此，使用 `sort -u` 来过滤 `duplicate_files` 和 `unique_files`。'
- en: The `tee` command is used to pass filenames to the `rm` command as well as `print`.
    The `tee` command sends its input to both `stdout and a file`. We can also print
    text to the terminal by redirecting to `stderr`. `/dev/stderr` is the device corresponding
    to `stderr` (standard error). By redirecting to a `stderr` device file, text sent
    to `stdin` will be printed in the terminal as standard error.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee` 命令用于将文件名传递给 `rm` 命令以及 `print`。`tee` 命令将其输入发送到 `stdout 和文件`。我们还可以通过重定向到
    `stderr` 将文本打印到终端。`/dev/stderr` 是对应 `stderr`（标准错误）的设备。通过重定向到 `stderr` 设备文件，发送到
    `stdin` 的文本将作为标准错误在终端中打印出来。'
- en: Working with file permissions, ownership, and the sticky bit
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件权限、所有权和粘滞位
- en: File permissions and ownership are one of the distinguishing features of the
    Unix/Linux filesystems. These features protect your information in a multi-user
    environment. Mismatched permissions and ownership can also make it difficult to
    share files. These recipes explain how to use a file's permission and ownership
    effectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文件权限和所有权是Unix/Linux文件系统的一个重要特征。这些特性在多用户环境中保护你的信息。不匹配的权限和所有权也可能导致共享文件变得困难。这些内容解释了如何有效地使用文件的权限和所有权。
- en: Each file possesses many types of permissions. Three sets of permissions (user,
    group, and others) are commonly manipulated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件都有多种权限类型。通常会操作三组权限（用户、组和其他）。
- en: The **user** is the owner of the file, who commonly has all access permitted.
    The **group** is the collection of users (as defined by the system administrator)
    that may be permitted some access to the file. **Others** are any users other
    than the owner or members of the owner's group.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**是文件的所有者，通常拥有所有的访问权限。**组**是由系统管理员定义的用户集合，可能被授权访问该文件。**其他用户**是指除了所有者或所有者组成员之外的任何用户。'
- en: 'The `ls` command''s `-l` option displays many aspects of the file including
    type, permissions, owner, and group:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令的`-l`选项显示文件的多个方面，包括类型、权限、所有者和组：'
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first column of the output defines the file type as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一列定义了文件类型，具体如下：
- en: '`-`: This is used if it is a regular file'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：如果是常规文件，则使用此标识'
- en: '`d`: This is used if it is a directory'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：如果是目录，则使用此标识'
- en: '`c`: This is used for a character device'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：用于字符设备'
- en: '`b`: This is used for a block device'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：用于块设备'
- en: '`l`: This is used if it is a symbolic link'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：如果是符号链接，则使用此标识'
- en: '`s`: This is used for a socket'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：用于套接字'
- en: '`p`: This is used for a pipe'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：用于管道'
- en: The next nine characters are divided into three groups of three letters each
    (--- --- ---). The first three characters correspond to the permissions of the
    user (owner), the second sets of three characters correspond to the permissions
    of the group, and the third sets of three characters correspond to the permissions
    of others. Each character in the nine-character sequence (nine permissions) specifies
    whether permission is set or unset. If the permission is set, a character appears
    in the corresponding position, otherwise a `-` character appears in that position,
    which means that the corresponding permission is unset (unavailable).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的九个字符分为三组，每组三个字母（--- --- ---）。前三个字符对应用户（所有者）的权限，第二组三个字符对应组的权限，第三组三个字符对应其他用户的权限。九个字符中的每个字符指定是否设置权限。如果权限已设置，相应位置会出现一个字符，否则会出现`-`字符，这意味着对应的权限未设置（不可用）。
- en: 'The three common letters in the trio are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 三个常见的字母组合如下：
- en: '`r Read`: When this is set, the file, device, or directory can be read.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r 读取`：当这个设置时，文件、设备或目录可以被读取。'
- en: '`w Write`: When this is set, the file, device, or directory can be modified.
    On folders, this defines whether files can be created or deleted.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w 写入`：当这个设置时，文件、设备或目录可以被修改。在文件夹上，这定义了是否可以创建或删除文件。'
- en: '`x execute`: When this is set, the file, can be executed. On folders, this
    defines whether the files in the folder can be accessed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x 执行`：当这个设置时，文件可以被执行。在文件夹上，这定义了文件夹中的文件是否可以被访问。'
- en: 'Let''s take a look at what each of these three character sets mean for the
    user, group, and others:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些三个字符集对用户、组和其他的含义：
- en: '**User** (permission string: `rwx------`): These define the options a user
    has. Usually, the user''s permission is `rw-` for a data file and `rwx` for a
    script or executable. The user has one more special permission called `setuid`
    (`S`), which appears in the position of execute (`x`). The `setuid` permission
    enables an executable file to be executed effectively as its owner, even when
    the executable is run by another user. An example of a file with `setuid` permission
    set is `-rwS------`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**（权限字符串：`rwx------`）：这些定义了用户的选项。通常，数据文件的用户权限是`rw-`，而脚本或可执行文件的用户权限是`rwx`。用户还有一个特殊的权限，称为`setuid`（`S`），它出现在执行（`x`）的位置。`setuid`权限使得可执行文件即使由其他用户运行，也能像其所有者一样有效地执行。设置了`setuid`权限的文件示例是`-rwS------`。'
- en: '**Group** (permission string: `---rwx---`): The second set of three characters
    specifies the group permissions. Instead of `setuid`, the group has a `setgid`
    (`S`) bit. This enables the item to run an executable file with an effective group
    as the owner group. But the group, which initiates the command, may be different.
    An example of group permission is `----rwS---`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**（权限字符串：`---rwx---`）：第二组三字符指定组权限。与`setuid`不同，组有一个`setgid`（`S`）位。这使得项目能够以其有效组为所有者组来运行可执行文件。但执行命令的组可能与文件所有者的组不同。一个组权限的例子是`----rwS---`。'
- en: '**Others** (permission string: `------rwx`): Other permissions appear as the
    last three characters in the permission string. If these are set, anyone can access
    this file or folder. As a rule you will want to set these bits to `---`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他**（权限字符串：`------rwx`）：其他权限出现在权限字符串的最后三个字符中。如果这些权限被设置，任何人都可以访问该文件或文件夹。通常，您会希望将这些位设置为`---`。'
- en: 'Directories have a special permission called a **sticky bit**. When a sticky
    bit is set for a directory, only the user who created the directory can delete
    the files in the directory, even if the group and others have write permissions.
    The sticky bit appears in the position of execute character (`x`) in the others
    permission set. It is represented as character `t` or `T`. The `t` character appears
    in the `x` position if the execute permission is unset and the sticky bit is set.
    If the sticky bit and the execute permission are set, the `T` character appears
    in the `x` position. Consider this example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 目录有一个特殊权限，称为**粘滞位**。当目录设置了粘滞位时，即使组和其他用户有写权限，只有创建该目录的用户可以删除该目录中的文件。粘滞位出现在其他用户权限集中的执行字符（`x`）位置。若执行权限未设置且粘滞位已设置，`x`位置会显示为字符`t`。如果粘滞位和执行权限都已设置，则`x`位置显示为`T`。考虑这个例子：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A typical example of a directory with sticky bit turned on is `/tmp`, where
    anyone can create a file, but only the owner can delete one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的启用了粘滞位的目录是`/tmp`，在该目录下，任何人都可以创建文件，但只有文件所有者可以删除文件。
- en: In each of the `ls -l` output lines, the string `slynux users` corresponds to
    the user and group. Here, `slynux` is the owner who is a member of the group users.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行`ls -l`输出中，字符串`slynux users`表示用户和组。这里，`slynux`是文件所有者，且是`users`组的成员。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: In order to set permissions for files, we use the `chmod` command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置文件权限，我们使用`chmod`命令。
- en: Assume that we need to set the permission, `rwx rw- r-`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要设置权限为`rwx rw- r-`。
- en: 'Set these permissions with chmod:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用chmod设置这些权限：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The options used here are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的选项如下：
- en: '`u`: This specifies user permissions'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：此项指定用户的权限'
- en: '`g`: This specifies group permissions'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：此项指定组的权限'
- en: '`o`: This specifies others permissions'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`：此项指定其他用户的权限'
- en: Use `+` to add permission to a user, group, or others, and use `-` to remove
    the permissions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`+`可以向用户、组或其他用户添加权限，使用`-`可以删除权限。
- en: 'Add the executable permission to a file, which has the permission, `rwx rw-
    r-`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给一个已经拥有权限`rwx rw- r-`的文件添加执行权限：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command adds the `x` permission for others.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为其他用户添加了`x`权限。
- en: 'Add the executable permission to all permission categories, that is, for user,
    group, and others:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给所有权限类别添加执行权限，即用户、组和其他用户：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here `a` means all.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`a`表示所有用户。
- en: In order to remove a permission, use `-`. For example, **$ chmod a-x filename**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 若要移除权限，请使用`-`。例如，**$ chmod a-x 文件名**。
- en: Permissions can be denoted with three-digit octal numbers in which each digit
    corresponds to user, group, and other, in that order.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以用三位八进制数字表示，每一位分别对应用户、组和其他用户，顺序为用户、组、其他。
- en: 'Read, write, and execute permissions have unique octal numbers, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 读取、写入和执行权限有各自独特的八进制值，如下所示：
- en: '`r` = 4'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` = 4'
- en: '`w` = 2'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` = 2'
- en: '`x` = 1'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` = 1'
- en: 'We calculate the required combination of permissions by adding the octal values.
    Consider this example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过加和八进制值来计算所需的权限组合。考虑这个例子：
- en: '`rw-` = 4 + 2 = 6'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw-` = 4 + 2 = 6'
- en: '`r-x` = 4 + 1 = 5'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r-x` = 4 + 1 = 5'
- en: 'The permission `rwx rw- r--` in the numeric method is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 权限`rwx rw- r--`的数字表示方法如下：
- en: '`rwx` = 4 + 2 + 1 = 7'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx` = 4 + 2 + 1 = 7'
- en: '`rw-` = 4 + 2 = 6'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw-` = 4 + 2 = 6'
- en: '`r--` = 4'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--` = 4'
- en: Therefore, `rwx rw- r--` is equal to `764`, and the command to set the permissions
    using octal values is `$ chmod 764 filename`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`rwx rw- r--`等于`764`，使用八进制值设置权限的命令是`$ chmod 764 文件名`。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Let's examine more tasks we can perform on files and directories.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看还可以对文件和目录执行哪些任务。
- en: Changing ownership
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改所有权
- en: 'The `chown` command will change the ownership of files and folders:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`chown` 命令将更改文件和文件夹的所有权：'
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Consider this example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `slynux` is the user, and `users` is the group.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`slynux` 是用户，`users` 是组。
- en: Setting the sticky bit
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置粘滞位
- en: The sticky bit can be applied to directories. When the sticky bit is set, only
    the owner can delete files, even though others have write permission for the folder.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 粘滞位可以应用于目录。当设置了粘滞位时，只有文件的所有者可以删除文件，即使其他人对文件夹有写权限。
- en: 'The sticky bit is set with the `+t` option to `chmod`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 粘滞位通过 `+t` 选项传递给 `chmod` 来设置：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Applying permissions recursively to files
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归应用文件权限
- en: 'Sometimes, you may need to change the permissions of all the files and directories
    inside the current directory recursively. The `-R` option to `chmod` supports
    recursive changes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要递归地更改当前目录中所有文件和目录的权限。`chmod` 的 `-R` 选项支持递归更改：
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-R` option specifies to change the permissions recursively.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`-R` 选项指定递归地更改权限。'
- en: We used `.` to specify the path as the current working directory. This is equivalent
    to `$ chmod 777 "$(pwd)" -R`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `.` 来指定路径为当前工作目录。这相当于 `$ chmod 777 "$(pwd)" -R`。
- en: Applying ownership recursively
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归应用所有权
- en: 'The `chown` command also supports the `-R` flag to recursively change ownership:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`chown` 命令也支持 `-R` 标志来递归地更改所有权：'
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Running an executable as a different user (setuid)
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以其他用户身份运行可执行文件（setuid）
- en: Some executables need to be executed as a user other than the current user.
    For example, the http server may be initiated during the boot sequence by root,
    but the task should be owned by the `httpd` user. The `setuid` permission enables
    the file to be executed as the file owner when any other user runs the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可执行文件需要以当前用户之外的用户身份执行。例如，http 服务器可能会在启动过程中由 root 启动，但该任务应该由 `httpd` 用户拥有。`setuid`
    权限使得文件可以在其他用户运行程序时，以文件所有者身份执行。
- en: 'First, change the ownership to the user that needs to execute it and then log
    in as the user. Then, run the following commands:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将所有权更改为需要执行操作的用户，然后以该用户身份登录。接着，运行以下命令：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now it executes as the root user regardless of who invokes it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在无论谁调用它，都以 root 用户身份执行。
- en: The `setuid` is only valid for Linux ELF binaries. You cannot set a shell script
    to run as another user. This is a security feature.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid` 仅对 Linux ELF 二进制文件有效。你无法将 shell 脚本设置为以另一个用户身份运行。这是一项安全功能。'
- en: Making files immutable
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使文件不可变
- en: The Read, Write, Execute, and Setuid fields are common to all Linux file systems.
    The **Extended File Systems** (ext2, ext3, and ext4) support more attributes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 读取、写入、执行和 Setuid 字段在所有 Linux 文件系统中都是常见的。**扩展文件系统**（ext2、ext3 和 ext4）支持更多属性。
- en: One of the extended attributes makes files immutable. When a file is made immutable,
    any user or super user cannot remove the file until the immutable attribute is
    removed from the file. You can determine the type of filesystem with the `df -T`
    command, or by looking at the `/etc/mtab` file. The first column of the file specifies
    the partition device path (for example, `/dev/sda5`) and the third column specifies
    the filesystem type (for example, ext3).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展属性之一使文件不可变。当文件被设置为不可变时，任何用户或超级用户都无法删除该文件，直到不可变属性被从文件中移除。你可以使用 `df -T` 命令来确定文件系统的类型，或者通过查看
    `/etc/mtab` 文件来确定。该文件的第一列指定了分区设备路径（例如，`/dev/sda5`），第三列指定了文件系统类型（例如，ext3）。
- en: Making a file immutable is one method for securing files from modification.
    One example is to make the `/etc/resolv.conf` file immutable. The `resolv.conf`
    file stores a list of DNS servers, which convert domain names (such as packtpub.com)
    to IP addresses. The DNS server is usually your ISP's DNS server. However, if
    you prefer a third-party server, you can modify `/etc/resolv.conf` to point to
    that DNS. The next time you connect to your ISP, `/etc/resolv.conf` will be overwritten
    to point to ISP's DNS server. To prevent this, make `/etc/resolv.conf` immutable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件不可变是一种防止文件被修改的方法。一个例子是将 `/etc/resolv.conf` 文件设置为不可变。`resolv.conf` 文件存储了 DNS
    服务器的列表，这些服务器将域名（如 packtpub.com）转换为 IP 地址。DNS 服务器通常是你 ISP 的 DNS 服务器。但是，如果你更喜欢使用第三方服务器，可以修改
    `/etc/resolv.conf` 来指向该 DNS。下次连接到 ISP 时，`/etc/resolv.conf` 会被覆盖为 ISP 的 DNS 服务器。为了防止这种情况发生，可以将
    `/etc/resolv.conf` 设置为不可变。
- en: In this recipe, we will see how to make files immutable and make them mutable
    when required.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使文件不可变，并在需要时将其恢复为可变。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `chattr` command is used to change extended attributes. It can make files
    immutable, as well as modify attributes to tune filesystem sync or compression.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`chattr` 命令用于更改扩展属性。它可以使文件不可变，还可以修改属性以调整文件系统同步或压缩。'
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To make the files immutable, follow these steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使文件不可变，请按照以下步骤操作：
- en: 'Use `chattr` to make a file immutable:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `chattr` 使文件不可变：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The file is now immutable. Try the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该文件现在是不可变的。尝试以下命令：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to make it writable, remove the immutable attribute, as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其可写，请移除不可变属性，如下所示：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Generating blank files in bulk
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量生成空白文件
- en: Scripts must be tested before they are used on a live system. We may need to
    generate thousands of files to confirm that there are no memory leaks or processes
    left hanging. This recipe shows how to generate blank files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本必须在实际系统中使用之前进行测试。我们可能需要生成数千个文件，以确认没有内存泄漏或进程未结束。这个示例演示了如何生成空白文件。
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备
- en: The `touch` command creates blank files or modifies the timestamp of existing
    files.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 命令用于创建空白文件或修改现有文件的时间戳。'
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To generate blank files in bulk, follow these steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要批量生成空白文件，请按照以下步骤操作：
- en: 'Invoking the touch command with a non-existent filename creates an empty file:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不存在的文件名调用 touch 命令会创建一个空文件：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Generate bulk files with a different name pattern:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照不同的命名模式生成批量文件：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, `{1..100}` will be expanded to a string `1, 2, 3, 4,
    5, 6, 7...100`. Instead of `{1..100}.txt`, we can use various shorthand patterns
    such as `test{1..200}.c`, `test{a..z}.txt`, and so on.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`{1..100}` 将扩展为字符串 `1, 2, 3, 4, 5, 6, 7...100`。我们可以使用各种简写模式，比如 `test{1..200}.c`、`test{a..z}.txt`
    等，代替 `{1..100}.txt`。
- en: 'If a file already exists, the `touch` command changes all timestamps associated
    with the file to the current time. These options define a subset of timestamps
    to be modified:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已存在，`touch` 命令会将与文件相关的所有时间戳更改为当前时间。以下选项定义了要修改的时间戳子集：
- en: '`touch -a`: This modifies the access time'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch -a`：修改访问时间'
- en: '`touch -m`: This modifies the modification time'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch -m`：这会修改修改时间'
- en: 'Instead of the current time, we can specify the time and date:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定时间和日期，而不是使用当前时间：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The date string used with `-d` need not be in this exact format. It will accept
    many simple date formats. We can omit time from the string and provide only dates
    such as *Jan 20*, *2010*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `-d` 一起使用的日期字符串不必是这个确切格式。它可以接受许多简单的日期格式。我们可以省略时间，只提供日期，如 *Jan 20*、*2010*。
- en: Finding symbolic links and their targets
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找符号链接及其目标
- en: Symbolic links are common in Unix-like systems. Reasons for using them range
    from convenient access, to maintaining multiple versions of the same library or
    program. This recipe will discuss the basic techniques for handling symbolic links.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接在类 Unix 系统中很常见。使用它们的原因包括方便访问、维护同一库或程序的多个版本等。这个示例将讨论处理符号链接的基本技术。
- en: Symbolic links are pointers to other files or folders. They are similar in function
    to aliases in MacOS X or shortcuts in Windows. When symbolic links are removed,
    it does not affect the original file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接是指向其他文件或文件夹的指针。它们的功能类似于 MacOS X 中的别名或 Windows 中的快捷方式。当符号链接被删除时，不会影响原始文件。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following steps will help you handle symbolic links:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你处理符号链接：
- en: 'To create a symbolic link run the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建符号链接，请运行以下命令：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Consider this example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考此示例：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This creates a symbolic link (called **web**) in the current user's home directory,
    which points to `/var/www/`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在当前用户的主目录中创建一个符号链接（称为 **web**），指向 `/var/www/`。
- en: 'To verify the link was created, run this command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证链接是否创建，运行此命令：
- en: '[PRE35]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`web -> /var/www` specifies that `web` points to `/var/www`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`web -> /var/www` 指定 `web` 指向 `/var/www`。'
- en: 'To print symbolic links in the current directory, use this command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印当前目录中的符号链接，请使用此命令：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To print all symbolic links in the current directory and subdirectories, run
    this command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印当前目录及子目录中的所有符号链接，请运行此命令：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To display the target path for a given symbolic link, use the `readlink` command:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示给定符号链接的目标路径，使用 `readlink` 命令：
- en: '[PRE38]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: When using `ls` and `grep` to display symbolic links in the current folder,
    the `grep ^l` command filters the `ls -l` output to only display lines starting
    with `l`. The `^` specifies the start of the string. The following `l` specifies
    that the string must start with l, the identifier for a link.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `ls` 和 `grep` 显示当前文件夹中的符号链接时，`grep ^l` 命令过滤 `ls -l` 输出，仅显示以 `l` 开头的行。`^`
    指定字符串的开始，紧随其后的 `l` 表示字符串必须以 `l` 开头，这是链接的标识符。
- en: When using `find`, we use the argument -`type``l`, which instructs find to search
    for symbolic link files. The `-print` option prints the list of symbolic links
    to the standard output (`stdout`). The initial path is given as the current directory.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `find` 时，我们使用参数 `-type l`，指示 `find` 查找符号链接文件。`-print` 选项将符号链接的列表打印到标准输出（`stdout`）。初始路径设置为当前目录。
- en: Enumerating file type statistics
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举文件类型统计信息
- en: Linux supports many file types. This recipe describes a script that enumerates
    through all the files inside a directory and its descendants, and prints a report
    with details on types of files (files with different file types), and the count
    of each file type. This recipe is an exercise on writing scripts to enumerate
    through many files and collect details.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 支持多种文件类型。本示例描述了一个脚本，它遍历一个目录及其子目录中的所有文件，并打印一个报告，报告中包含文件类型的详细信息（不同文件类型的文件）以及每种文件类型的计数。这个示例是一个练习，旨在编写脚本以遍历大量文件并收集细节。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正在准备
- en: On Unix/Linux systems, file types are not defined by the file extension (as
    Microsoft Windows does). Unix/Linux systems use the file command, which examines
    the file's contents to determine a file's type. This recipe collects file type
    statistics for a number of files. It stores the count of files of the same type
    in an associative array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix/Linux 系统中，文件类型并非由文件扩展名定义（如微软 Windows 所做）。Unix/Linux 系统使用 `file` 命令，通过检查文件的内容来确定文件类型。此示例收集了多个文件的文件类型统计信息。它将相同类型文件的计数存储在一个关联数组中。
- en: The associative arrays are supported in bash version 4 and newer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组在 bash 4 及更高版本中得到支持。
- en: How to do it...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To enumerate file type statistics, follow these steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要枚举文件类型统计信息，请按照以下步骤操作：
- en: 'To print the type of a file, use the following command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印文件的类型，请使用以下命令：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Print the file type without the filename:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印文件类型而不打印文件名：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The script for file statistics is as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件统计脚本如下：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The usage is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A sample output is shown as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例输出如下所示：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This script relies on the associative array `statarray`. This array is indexed
    by the type of file: **PDF**, **ASCII**, and so on. Each index holds the count
    for that type of file. It is defined by the `declare -A statarray` command.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本依赖于关联数组 `statarray`。该数组按文件类型索引：**PDF**、**ASCII** 等等。每个索引存储该类型文件的计数。它由 `declare
    -A statarray` 命令定义。
- en: 'The script then consists of two loops: a while loop, that processes the output
    from the find command, and a `for` loop, that iterates through the indices of
    the `statarray` variable and generates output.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包含两个循环：一个 `while` 循环处理来自 `find` 命令的输出，另一个是 `for` 循环，遍历 `statarray` 变量的索引并生成输出。
- en: 'The while loop syntax looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环的语法如下所示：'
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For this script, we use the output of the find command instead of a file as
    input to `while`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个脚本，我们使用 `find` 命令的输出，而不是文件，作为 `while` 的输入。
- en: The `(find $path -type f -print)` command is equivalent to a filename, but it substitutes
    the filename with a subprocess output.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`(find $path -type f -print)` 命令等同于文件名，但它将文件名替换为子进程输出。'
- en: Note that the first `<` is for input redirection and the second `<` is for converting
    the subprocess output to a filename. Also, there is a space between these two
    so the shell won't interpret it as the `<<` operator.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个 `<` 用于输入重定向，第二个 `<` 用于将子进程的输出转换为文件名。同时，它们之间有一个空格，以防止 shell 将其解释为 `<<`
    操作符。
- en: The `find` command uses the `-type``f` option to return a list of files under
    the subdirectory defined in $path. The filenames are read one line at a time by
    the `read` command. When the read command receives an **EOF** (**End of File**),
    it returns a *fail* and the `while` command exits.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令使用 `-type f` 选项来返回 `$path` 中定义的子目录下的文件列表。文件名由 `read` 命令逐行读取。当 `read`
    命令接收到 **EOF**（**文件结束符**）时，它返回一个 *失败* 并且 `while` 命令退出。'
- en: Within the `while` loop, the file command is used to determine a file's type.
    The `-b` option is used to display the file type without the name.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，使用file命令来确定文件的类型。`-b`选项用于显示文件类型而不显示文件名。
- en: 'The file command provides more details than we need, such as image encoding
    and resolution (in the case of an image file). The details are comma-separated,
    as in the following example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: file命令提供了比我们需要的更多的详细信息，如图像编码和分辨率（对于图像文件）。这些详细信息是以逗号分隔的，示例如下：
- en: '[PRE45]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We need to extract only `ELF 32-bit LSB executable` from the previous details.
    Hence, we use the `-d,` option to specify `,` as the delimiter and `-f1` to select
    the first field.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从之前的详细信息中提取出`ELF 32-bit LSB executable`。因此，我们使用`-d,`选项指定`,`为分隔符，并使用`-f1`选项选择第一个字段。
- en: '`<(find $path -type f -print)` is equivalent to a filename, but it substitutes
    the filename with a subprocess output. Note that the first `<` is for input redirection
    and the second `<` is for converting the subprocess output to a filename. Also,
    there is a space between these two so that the shell won''t interpret it as the
    `<<` operator.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`<(find $path -type f -print)`相当于一个文件名，但它通过子进程输出替代文件名。注意，第一个`<`用于输入重定向，第二个`<`用于将子进程输出转换为文件名。同时，这两个`<`之间有一个空格，以免Shell将其解释为`<<`操作符。'
- en: 'In Bash 3.x and higher, we have a new operator `<<<` that lets us use a string
    output as an input file. Using this operator, we can write the done line of the
    loop, as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash 3.x及更高版本中，我们有一个新的操作符`<<<`，它允许我们将字符串输出作为输入文件。使用这个操作符，我们可以写出循环的完成行，如下所示：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`${!statarray[@]}` returns the list of array indexes.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`${!statarray[@]}` 返回数组索引的列表。'
- en: Using loopback files
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回环文件
- en: Linux filesystems normally exist on devices such as disks or memory sticks.
    A file can also be mounted as a filesystem. This filesystem-in-a-file can be used
    for testing, for customized filesystems, or even as an encrypted disk for confidential
    information.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Linux文件系统通常存在于硬盘或内存棒等设备上。文件也可以作为文件系统挂载。这个文件中的文件系统可以用于测试、自定义文件系统，甚至作为加密磁盘存储机密信息。
- en: How to do it...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a 1 GB ext4 filesystem in a file, follow these steps:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件中创建1 GB的ext4文件系统，请按照以下步骤操作：
- en: 'Use `dd` to create a 1 GB file:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dd`创建一个1 GB的文件：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The size of the created file exceeds 1 GB because the hard disk is a block device,
    and hence, storage must be allocated by integral multiples of blocks size.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的文件大小超过1 GB，因为硬盘是块设备，因此存储必须按块大小的整数倍分配。
- en: 'Format the 1 GB file to ext4 using the `mkfs` command:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkfs`命令将1 GB的文件格式化为ext4：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check the file type with the file command:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用file命令检查文件类型：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a mount point and mount the loopback file with `mkdir` and mount:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mkdir`和mount创建挂载点，并挂载回环文件：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `-o loop` option is used to mount loopback filesystems.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o loop`选项用于挂载回环文件系统。'
- en: This is a short method that attaches the loopback filesystem to a device chosen
    by the operating system named something similar to `/dev/loop1` or `/dev/loop2`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的方法，将回环文件系统附加到操作系统选择的设备上，设备名称类似于`/dev/loop1`或`/dev/loop2`。
- en: 'To specify a specific loopback device, run the following command:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指定特定的回环设备，请运行以下命令：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To umount (`unmount`), use the following syntax:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要umount（卸载），请使用以下语法：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Consider this example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also use the device file path as an argument to the `umount` command:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用设备文件路径作为`umount`命令的参数：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the mount and umount commands should be executed as a root user, since
    it is a privileged command.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，mount和umount命令应该以root用户身份执行，因为它们是特权命令。
- en: How it works...
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First we had to create a file to make a loopback filesystem. For this, we used
    `dd`, which is a generic command for copying raw data. It copies data from the
    file specified in the `if` parameter to the file specified in the `of` parameter.
    We instruct `dd` to copy data in blocks of size 1 GB and copy one such block,
    creating a 1 GB file. The `/dev/zero` file is a special file, which will always
    return 0 when you read from it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个文件来制作回环文件系统。为此，我们使用`dd`，它是一个通用的原始数据复制命令。它将`if`参数指定的文件中的数据复制到`of`参数指定的文件中。我们指示`dd`以1
    GB的块大小复制数据，并复制一个这样的块，从而创建一个1 GB的文件。`/dev/zero`文件是一个特殊文件，从中读取数据时总是返回0。
- en: We used the `mkfts.ext4` command to create an ext4 filesystem in the file. A
    filesystem is needed on any device that can be mounted. Common filesystems include
    ext4, ext3, and vfat.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mkfts.ext4`命令在文件中创建一个ext4文件系统。任何可以挂载的设备都需要一个文件系统。常见的文件系统包括ext4、ext3和vfat。
- en: The `mount` command attaches the loopback file to a **mountpoint** (`/mnt/loopback`
    in this case). A mountpoint makes it possible for users to access the files stored
    on a filesystem. The mountpoint must be created using the `mkdir` command before
    executing the `mount` command. We pass the `-o loop` option to mount to tell it
    that we are mounting a loopback file, not a device.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 命令将环回文件附加到 **挂载点**（在此情况下为 `/mnt/loopback`）。挂载点使用户能够访问文件系统上存储的文件。挂载点必须在执行
    `mount` 命令之前使用 `mkdir` 命令创建。我们传递 `-o loop` 选项给 `mount`，告诉它我们挂载的是一个环回文件，而不是一个设备。'
- en: When `mount` knows it is operating on a loopback file, it sets up a device in
    `/dev` corresponding to the loopback file and then mounts it. If we wish to do
    it manually, we use the `losetup` command to create the device and then the `mount`
    command to mount it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mount` 知道它正在操作一个环回文件时，它会在 `/dev` 中设置一个与环回文件对应的设备，然后挂载它。如果我们希望手动执行此操作，我们可以使用
    `losetup` 命令来创建设备，然后使用 `mount` 命令挂载它。
- en: There's more...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Let's explore some more possibilities with loopback files and mounting.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些环回文件和挂载的其他可能性。
- en: Creating partitions inside loopback images
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在环回镜像中创建分区
- en: Suppose we want to create a loopback file, partition it, and finally mount a
    sub-partition. In this case, we cannot use `mount -o loop`. We must manually set
    up the device and mount the partitions in it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个环回文件，进行分区，然后最终挂载一个子分区。在这种情况下，我们不能使用 `mount -o loop`。我们必须手动设置设备并挂载其中的分区。
- en: 'To partition a file of zeros:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个零文件进行分区：
- en: '[PRE55]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`fdisk` is a standard partitioning tool on Linux systems. A very concise tutorial
    on creating partitions using `fdisk` is available at [http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html](http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html)
    (make sure to use `/dev/loop1` instead of `/dev/hdb` in this tutorial).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdisk` 是 Linux 系统上的标准分区工具。关于使用 `fdisk` 创建分区的简明教程可在 [http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html](http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html)
    上找到（请确保在本教程中使用 `/dev/loop1` 而不是 `/dev/hdb`）。'
- en: 'Create partitions in `loopback.img` and mount the first partition:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `loopback.img` 中创建分区并挂载第一个分区：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, `/dev/loop2` represents the first partition,`-o` is the offset flag, and `32256`
    bytes are for a DOS partition scheme. The first partition starts 32256 bytes from
    the start of the hard disk.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/dev/loop2` 代表第一个分区，`-o` 是偏移标志，`32256` 字节用于 DOS 分区方案。第一个分区从硬盘开始的第 `32256`
    字节处开始。
- en: We can set up the second partition by specifying the required offset. After
    mounting, we can perform all regular operations as we can on physical devices.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定所需的偏移量来设置第二个分区。挂载后，我们可以像在物理设备上进行所有常规操作一样进行操作。
- en: Mounting loopback disk images with partitions more quickly
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快速地挂载带有分区的环回磁盘镜像
- en: 'We can manually pass partition offsets to `losetup` to mount partitions inside
    a loopback disk image. However, there is a quicker way to mount all the partitions
    inside such an image using `kpartx`. This utility is usually not installed, so
    you will have to install it using your package manager:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将分区偏移量传递给 `losetup` 来挂载环回磁盘镜像中的分区。然而，使用 `kpartx` 有一种更快捷的方法来挂载该镜像中的所有分区。此工具通常未安装，因此您需要通过包管理器安装它：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This creates mappings from the partitions in the disk image to devices in `/dev/mapper`,
    which you can then mount. For example, to mount the first partition, use the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建磁盘镜像中分区到 `/dev/mapper` 中设备的映射，之后您可以将其挂载。例如，要挂载第一个分区，请使用以下命令：
- en: '[PRE58]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When you''re done with the devices (and unmounting any mounted partitions using
    `umount`), remove the mappings by running the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成设备操作（并使用 `umount` 卸载所有挂载的分区）后，通过运行以下命令删除映射：
- en: '[PRE59]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Mounting ISO files as loopback
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 ISO 文件作为环回文件挂载
- en: An ISO file is an archive of an optical media. We can mount ISO files in the
    same way that we mount physical disks using loopback mounting.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 文件是光盘介质的归档。我们可以像挂载物理磁盘一样，使用环回挂载来挂载 ISO 文件。
- en: 'We can even use a nonempty directory as the mount path. Then, the mount path
    will contain data from the devices rather than the original contents, until the
    device is unmounted. Consider this example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用一个非空目录作为挂载路径。然后，挂载路径将包含来自设备的数据，而不是原始内容，直到设备被卸载为止。考虑以下示例：
- en: '[PRE60]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, perform operations using files from `/mnt/iso`. ISO is a read-only filesystem.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 `/mnt/iso` 执行操作。ISO 是一个只读文件系统。
- en: Flush changing immediately with sync
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `sync` 立即刷新更改
- en: 'Changes on a mounted device are not immediately written to the physical device.
    They are only written when the internal memory buffer is full. We can force writing
    with the `sync` command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载设备上进行的更改不会立即写入物理设备。它们仅在内部内存缓冲区满时才会被写入。我们可以使用`sync`命令强制写入：
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Creating ISO files and hybrid ISO
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ISO文件和混合ISO
- en: An ISO image is an archive format that stores the exact image of an optical
    disk such as CD-ROM, DVD-ROM, and so on. ISO files are commonly used to store
    content to be burned to optical media.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ISO镜像是一种存储光盘（如CD-ROM、DVD-ROM等）精确映像的归档格式。ISO文件通常用于存储将要刻录到光盘介质的内容。
- en: This section will describe how to extract data from an optical disk into an
    ISO file that can be mounted as a loopback device, and then explain ways to generate
    your own ISO file systems that can be burned to an optical media.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将描述如何将光盘中的数据提取到一个可以作为回环设备挂载的ISO文件中，然后解释如何生成可以刻录到光盘介质上的自定义ISO文件系统。
- en: We need to distinguish between bootable and non-bootable optical disks. Bootable
    disks are capable of booting from themselves and also running an operating system
    or another product. Bootable DVDs include installation kits and *Live* systems
    such as Knoppix and Puppy.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分可引导光盘和不可引导光盘。可引导光盘能够从自身启动，并运行操作系统或其他产品。可引导的DVD包括安装包和*Live*系统，如Knoppix和Puppy。
- en: Non-bootable ISOs cannot do that. Upgrade kits, source code DVDs, and so on
    are non-bootable.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 不可引导的ISO无法做到这一点。升级包、源代码DVD等都是不可引导的。
- en: Note that copying files from a bootable CD-ROM to another CD-ROM is not sufficient
    to make the new one bootable. To preserve the bootable nature of a CD-ROM, it
    must be copied as a disk image using an ISO file.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从可引导的CD-ROM复制文件到另一个CD-ROM并不足以使新光盘可引导。为了保留CD-ROM的引导特性，必须将其作为磁盘映像使用ISO文件进行复制。
- en: Many people use flash drives as a replacement for optical disks. When we write
    a bootable ISO to a flash drive, it will not be bootable unless we use a special
    hybrid ISO image designed specifically for the purpose.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人使用闪存驱动器来替代光盘。当我们将可引导的ISO写入闪存驱动器时，除非使用专门为此目的设计的混合ISO镜像，否则它将无法引导。
- en: These recipes will give you an insight into ISO images and manipulations.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些教程将为你提供有关ISO镜像及其操作的深入理解。
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As mentioned previously, Unix handles everything as files. Every device is a
    file. Hence, if we want to copy an exact image of a device, we need to read all
    data from it and write to a file. An optical media reader will be in the `/dev`
    folder with a name such as `/dev/cdrom`, `/dev/dvd`, or perhaps `/dev/sd0`. Be
    careful when accessing an `sd*.` Multiple disk-type devices are named `sd#`. Your
    hard drive may be `sd0` and the CD-ROM `sd1`, for instance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Unix将一切视为文件。每个设备都是一个文件。因此，如果我们想复制设备的精确映像，我们需要从中读取所有数据并写入文件。光盘读取器将在`/dev`文件夹中，名称可能为`/dev/cdrom`、`/dev/dvd`，或者可能是`/dev/sd0`。访问`sd*`时需要小心。多个磁盘类型设备被命名为`sd#`。例如，你的硬盘可能是`sd0`，CD-ROM可能是`sd1`。
- en: The `cat` command will read any data, and redirection will write that data to
    a file. This works, but we'll also see better ways to do it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令将读取任何数据，并且重定向将该数据写入文件。这是可行的，但我们还将看到更好的方法来完成这项操作。'
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to create an ISO image from `/dev/cdrom`, use the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`/dev/cdrom`创建ISO镜像，请使用以下命令：
- en: '[PRE62]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Though this will work, the preferred way to create an ISO image is with `dd`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这也可以工作，但创建ISO镜像的首选方法是使用`dd`命令：
- en: '[PRE63]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `mkisofs` command creates an ISO image in a file. The output file created
    by `mkisofs` can be written to CD-ROM or DVD-ROM with utilities such as `cdrecord`.
    The `mkisofs` command will create an ISO file from a directory containing all
    the files to be copied to the ISO file:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkisofs`命令创建一个ISO镜像文件。由`mkisofs`创建的输出文件可以通过`cdrecord`等工具刻录到CD-ROM或DVD-ROM上。`mkisofs`命令将从包含所有要复制到ISO文件中的文件的目录中创建ISO文件：'
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `-o` option in the `mkisofs` command specifies the ISO file path. The `source_dir`
    is the path of the directory to be used as content for the ISO file and the `-V`
    option specifies the label to use for the ISO file.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkisofs`命令中的`-o`选项指定ISO文件的路径。`source_dir`是作为ISO文件内容的目录路径，`-V`选项指定用于ISO文件的标签。'
- en: There's more...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: Let's learn more commands and techniques related to ISO files.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习更多与ISO文件相关的命令和技术。
- en: Hybrid ISO that boots off a flash drive or hard disk
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从闪存驱动器或硬盘引导的混合ISO
- en: Bootable ISO files cannot usually be transferred to a USB storage device to
    create a bootable USB stick. However, special types of ISO files called hybrid
    ISOs can be flashed to create a bootable device.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 启动ISO文件通常不能直接传输到USB存储设备上以创建可启动的USB闪存盘。然而，某些特殊类型的ISO文件称为混合ISO，它们可以被刷写到设备上，生成一个可启动的设备。
- en: We can convert standard ISO files into hybrid ISOs with the `isohybrid` command.
    The `isohybrid` command is a new utility and most Linux distros don't include
    this by default. You can download the [syslinux package](http://syslinux.zytor.com/)
    from [http://www.syslinux.org](http://www.syslinux.org). The command may also
    be available in your yum or `apt-get` repository as `syslinux-utils`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`isohybrid`命令将标准ISO文件转换为混合ISO。`isohybrid`命令是一个新的工具，大多数Linux发行版默认不包含它。你可以从[syslinux包](http://syslinux.zytor.com/)下载，网址是[http://www.syslinux.org](http://www.syslinux.org)。该命令也可能在你的yum或`apt-get`软件库中作为`syslinux-utils`提供。
- en: 'This command will make an ISO file bootable:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将使ISO文件变得可启动：
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The ISO file can now be written to USB storage devices.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将ISO文件写入USB存储设备。
- en: 'To write the ISO to a USB storage device, use the following command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要将ISO写入USB存储设备，使用以下命令：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Use the appropriate device instead of `/dev/sdb1`, or you can use `cat`, as
    follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的设备代替`/dev/sdb1`，或者你也可以使用`cat`，如下所示：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Burning an ISO from the command line
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从命令行刻录ISO文件
- en: The `cdrecord` command burns an ISO file to a CD-ROM or DVD-ROM.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdrecord`命令将ISO文件刻录到CD-ROM或DVD-ROM上。'
- en: 'To burn the image to the CD-ROM, run the following command:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要将映像刻录到CD-ROM上，运行以下命令：
- en: '[PRE68]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Useful options include the following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的选项包括：
- en: 'Specify the burning speed with the `-speed` option:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-speed`选项指定刻录速度：
- en: '[PRE69]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Consider this example:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE70]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `8` is the speed specified as 8x.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`8`表示指定的速度为8倍速。
- en: 'A CD-ROM can be burned in multi-sessions such that we can burn data multiple
    times on a disk. Multisession burning can be done with the `-multi` option:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD-ROM可以使用多重会话进行刻录，从而允许我们多次向同一磁盘写入数据。可以使用`-multi`选项进行多会话刻录：
- en: '[PRE71]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Playing with the CD-ROM tray
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操控CD-ROM托盘
- en: 'If you are on a desktop computer, try the following commands and have fun:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在桌面电脑上，尝试以下命令并享受乐趣：
- en: '[PRE72]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This command will eject the tray.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会弹出托盘。
- en: '[PRE73]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This command will close the tray.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将关闭托盘。
- en: For extra points, write a loop that opens and closes the tray a number of times.
    It goes without saying that one would never slip this into a co-workers `.bashrc`
    while they are out getting a coffee.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加分，编写一个循环，使托盘反复打开和关闭几次。显然，你永远不会在同事去喝咖啡的时候悄悄地把这个脚本加到他们的`.bashrc`文件里。
- en: Finding the difference between files, and patching
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件之间的差异并打补丁
- en: When multiple versions of a file are available, it is useful to highlight the
    differences between files rather than comparing them manually. This recipe illustrates
    how to generate differences between files. When working with multiple developers,
    changes need to be distributed to the others. Sending the entire source code to
    other developers is time consuming. Sending a difference file instead is helpful,
    as it consists of only lines which are changed, added, or removed, and line numbers
    are attached with it. This difference file is called a **patch file**. We can
    add the changes specified in the patch file to the original source code with the
    `patch` command. We can revert the changes by patching again.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当有多个版本的文件可用时，突出显示文件之间的差异比手动比较它们更为有用。这个例子演示了如何生成文件之间的差异。在与多个开发者合作时，需要将更改分发给其他人。将整个源代码发送给其他开发者既耗时又麻烦。发送一个差异文件更为方便，因为它只包含被更改、添加或删除的行，并且附带行号。这个差异文件被称为**补丁文件**。我们可以使用`patch`命令将补丁文件中指定的更改应用到原始源代码中。如果需要，也可以通过再次应用补丁来撤销这些更改。
- en: How to do it...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `diff` utility reports the differences between two files.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`工具报告两个文件之间的差异。'
- en: 'To demonstrate diff behavior, create the following files:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示`diff`的行为，创建以下文件：
- en: 'File 1: `version1.txt`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 文件1：`version1.txt`
- en: '[PRE74]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'File 2: `version2.txt`'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 文件2：`version2.txt`
- en: '[PRE75]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Nonunified `diff` output (without the `-u` flag) is:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非统一的`diff`输出（没有`-u`标志）是：
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The unified `diff` output is:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 统一的`diff`输出是：
- en: '[PRE77]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `-u` option produces a unified output. Unified diff output is more readable
    and is easier to interpret.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`选项会生成统一格式的输出。统一格式的差异输出更具可读性，也更容易解读。'
- en: In unified `diff`, the lines starting with `+` are the added lines and the lines
    starting with `-` are the removed lines.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在统一`diff`中，以`+`开头的行表示添加的行，以`-`开头的行表示删除的行。
- en: 'A patch file can be generated by redirecting the `diff` output to a file:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过将 `diff` 输出重定向到文件来生成补丁文件：
- en: '[PRE78]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `patch` command can apply changes to either of the two files. When applied
    to `version1.txt`, we get the `version2.txt` file. When applied to `version2.txt`,
    we generate `version1.txt`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch` 命令可以对两个文件应用更改。当应用到 `version1.txt` 时，我们得到 `version2.txt` 文件。当应用到 `version2.txt`
    时，我们生成 `version1.txt`。'
- en: 'This command applies the patch:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令应用补丁：
- en: '[PRE79]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We now have `version1.txt` with the same contents as `version2.txt`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了 `version1.txt`，它的内容与 `version2.txt` 相同。
- en: 'To revert the changes, use the following command:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要撤销更改，请使用以下命令：
- en: '[PRE80]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As shown, patching an already patched file reverts the changes. To avoid prompting
    the user with `y/n`, we can use the `-R` option along with the `patch` command.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，给已应用补丁的文件再次打补丁会撤销更改。为了避免提示用户进行 `y/n` 选择，我们可以使用 `-R` 选项与 `patch` 命令一起使用。
- en: There's more...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through additional features available with `diff`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解 `diff` 的其他功能。
- en: Generating difference against directories
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成目录间的差异
- en: 'The `diff` command can act recursively against directories. It will generate
    a difference output for all the descendant files in the directories. Use the following
    command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff` 命令可以递归地作用于目录。它将为目录中的所有子文件生成差异输出。使用以下命令：'
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The interpretation of each of the options in this command is as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中每个选项的解释如下：
- en: '`-N`: This is used for treating missing files as empty'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-N`：用于将缺失的文件视为空文件'
- en: '`-a`: This is used to consider all files as text files'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：用于将所有文件视为文本文件'
- en: '`-u`: This is used to produce unified output'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`：用于生成统一格式的输出'
- en: '`-r`: This is used to recursively traverse through the files in the directories'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：用于递归遍历目录中的文件'
- en: Using head and tail for printing the last or first 10 lines
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `head` 和 `tail` 打印文件的最后或前 10 行
- en: When examining a large file, thousands of lines long, the `cat` command, which
    will display all the line,s is not suitable. Instead, we want to view a subset
    (for example, the first 10 lines of the file or the last 10 lines of the file).
    We may need to print the first *n* lines or last *n* lines or print all except
    the last *n* lines or all except the first *n* lines, or the lines between two
    locations.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查一个非常大的文件时，`cat` 命令（会显示所有行）并不适用。相反，我们希望查看文件的某个子集（例如，文件的前 10 行或最后 10 行）。我们可能需要打印前
    *n* 行或最后 *n* 行，或者打印除去最后 *n* 行或除去前 *n* 行的内容，或者打印两个位置之间的行。
- en: The `head` and `tail` commands can do this.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`head` 和 `tail` 命令可以做到这一点。'
- en: How to do it...
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何执行...
- en: The `head` command reads the beginning of the input file.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`head` 命令读取输入文件的开头部分。'
- en: 'Print the first 10 lines:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印前 10 行：
- en: '[PRE82]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Read the data from `stdin`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `stdin` 读取数据：
- en: '[PRE83]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Specify the number of first lines to be printed:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定要打印的前几行数量：
- en: '[PRE84]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This command prints the first four lines.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印前四行。
- en: 'Print all lines excluding the last `M` lines:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印所有行，但不包括最后 `M` 行：
- en: '[PRE85]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Note that it is negative M.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它是负 M。
- en: 'For example, to print all the lines except the last five lines, use the following
    command line:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印所有行，但不包括最后五行，可以使用以下命令：
- en: '[PRE86]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This command prints lines 1 to 5:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打印第 1 到第 5 行：
- en: '[PRE87]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Printing everything except the last lines is a common use for `head`. When examining
    log files we most often want to view the most recent (that is, the last) lines.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印除去最后几行是 `head` 的常见用途。在查看日志文件时，我们最常想查看最新的（即最后）几行。
- en: 'To print the last 10 lines of a file, use this command:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印文件的最后 10 行，请使用此命令：
- en: '[PRE88]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To read from `stdin`, use the following command:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从 `stdin` 读取数据，请使用以下命令：
- en: '[PRE89]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Print the last five lines:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印最后五行：
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To print all lines excluding the first M lines, use this command:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印所有行，但不包括前 M 行，请使用此命令：
- en: '[PRE91]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For example, to print all lines except the first five lines, *M + 1 = 6*, the
    command is as follows:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印所有行，但不包括前五行，*M + 1 = 6*，则命令如下：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This will print from 6 to 100.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印第 6 行到第 100 行。
- en: 'One common use for `tail` is to monitor new lines in a growing file, for instance,
    a system log file. Since new lines are appended to the end of the file, `tail`
    can be used to display them as they are written. To monitor the growth of the
    file, `tail` has a special option `-f` or `--follow`, which enables `tail` to
    follow the appended lines and display them as data is added:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 的一个常见用途是监控增长中的文件中的新行，例如系统日志文件。由于新行会追加到文件的末尾，`tail` 可以用于在数据写入时显示它们。为了监控文件的增长，`tail`
    有一个特殊选项 `-f` 或 `--follow`，它允许 `tail` 跟踪追加的行并在数据被添加时显示它们：'
- en: '[PRE93]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You will probably want to use this on logfiles. The command to monitor the
    growth of the files would be this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会希望将此用在日志文件上。监控文件增长的命令是：
- en: '[PRE94]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Alternatively, this command can be used:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用以下命令：
- en: '[PRE95]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `dmesg` command returns contents of the kernel ring buffer messages. We
    can use this to debug USB devices, examine disk behavior, or monitor network connectivity.
    The `-f` tail can add a sleep interval `-s` to set the interval during which the
    file updates are monitored.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`dmesg` 命令返回内核环形缓冲区的消息内容。我们可以使用它来调试 USB 设备、检查磁盘行为或监控网络连接。`-f` 参数的 `tail` 可以添加一个休眠间隔
    `-s`，用于设置监控文件更新时的间隔。'
- en: The `tail` command can be instructed to terminate after a given process ID dies.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 命令可以指示在给定的进程 ID 终止后停止运行。'
- en: Suppose a process `Foo` is appending data to a file that we are monitoring.
    The `-f` tail should be executed until the process `Foo` dies.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 假设进程 `Foo` 正在向我们正在监控的文件中附加数据。`-f` 参数的 `tail` 命令应当在进程 `Foo` 结束前一直执行。
- en: '[PRE96]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: When the process `Foo` terminates, `tail` also terminates.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程 `Foo` 终止时，`tail` 也会终止。
- en: Let's work on an example.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个例子。
- en: Create a new file `file.txt` and open the file in your favorite text editor.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件 `file.txt`，并在你喜欢的文本编辑器中打开该文件。
- en: 'Now run the following commands:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行以下命令：
- en: '[PRE97]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Add new lines to the file and make frequent file saves.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件添加新行并频繁保存文件。
- en: When you add new lines to the end of the file, the new lines will be written
    to the terminal by the `tail` command. When you close the edit session, the `tail`
    command will terminate.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向文件末尾添加新行时，`tail` 命令会将新行写入终端。当你关闭编辑会话时，`tail` 命令将终止。
- en: Listing only directories - alternative methods
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅列出目录 - 替代方法
- en: Listing only directories via scripting is deceptively difficult. This recipe
    introduces multiple ways of listing only directories.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过脚本列出目录是相当困难的。此配方介绍了多种仅列出目录的方法。
- en: Getting ready
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: g ready There are multiple ways of listing directories only. The `dir` command
    is similar to `ls`, but with fewer options. We can also list directories with
    `ls` and `find`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作 有多种方法可以仅列出目录。`dir` 命令类似于 `ls`，但选项较少。我们还可以使用 `ls` 和 `find` 来列出目录。
- en: How to do it...
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Directories in the current path can be displayed in the following ways:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当前路径中的目录可以通过以下方式显示：
- en: 'Use `ls` with `-d` to print directories:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ls` 和 `-d` 参数来打印目录：
- en: '[PRE98]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Use `ls -F` with `grep`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ls -F` 和 `grep`：
- en: '[PRE99]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Use `ls -l` with `grep`:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `ls -l` 和 `grep`：
- en: '[PRE100]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Use `find` to print directories:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `find` 打印目录：
- en: '[PRE101]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: How it works...
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the `-F` parameter is used with `ls`, all entries are appended with some
    type of file character such as `@`, `*`, `|`, and so on. For directories, entries
    are appended with the `/` character. We use `grep` to filter only entries ending
    with the `/$` end-of-line indicator.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `-F` 参数与 `ls` 一起使用时，所有条目都会附加一些文件字符，如 `@`、`*`、`|` 等等。对于目录，条目会附加 `/` 字符。我们使用
    `grep` 来过滤出仅以 `/$` 结束的条目。
- en: The first character of any line in the `ls -l` output is the type of file character.
    For a directory, the type of file character is `d`. Hence, we use `grep` to filter
    lines starting with `"d`.`"``^` is a start-of-line indicator.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls -l` 输出的每一行的第一个字符是文件类型字符。对于目录，文件类型字符为 `d`。因此，我们使用 `grep` 来过滤以 `"d."` 开头的行。`^`
    是行首指示符。'
- en: The `find` command can take the parameter type as directory and `maxdepth` is
    set to `1` since we don't want it to search inside the subdirectories.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令可以将参数类型设置为目录，并将 `maxdepth` 设置为 `1`，因为我们不希望它在子目录中进行搜索。'
- en: Fast command-line navigation using pushd and popd
  id: totrans-490
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `pushd` 和 `popd` 进行快速命令行导航
- en: When navigating around multiple locations in the filesystem, a common practice
    is to cd to paths you copy and paste. This is not efficient if we are dealing
    with several locations. When we need to navigate back and forth between locations,
    it is time consuming to type or paste the path with each `cd` command. Bash and
    other shells support `pushd` and `popd` to cycle between directories.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中导航多个位置时，一种常见做法是通过复制和粘贴路径来 `cd`。如果涉及多个位置，这种做法效率较低。当我们需要在不同位置之间来回切换时，每次使用
    `cd` 命令输入或粘贴路径会非常浪费时间。Bash 和其他 Shell 支持 `pushd` 和 `popd` 用于在目录之间循环切换。
- en: Getting ready
  id: totrans-492
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`pushd` and `popd` are used to switch between multiple directories without
    retyping directory paths. `pushd` and `popd` create a stack of paths-a **Last****In****First****Out**
    (**LIFO**) list of the directories we''ve visited.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd` 和 `popd` 用于在多个目录之间切换，而无需重新输入目录路径。`pushd` 和 `popd` 会创建一个路径栈——一个 **后进先出**（**LIFO**）的目录列表，记录我们访问过的目录。'
- en: How to do it...
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The `pushd` and `popd` commands replace cd for changing your working directory.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd` 和 `popd` 命令替代 `cd` 来更改工作目录。'
- en: 'To push and change a directory to a path, use this command:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要推入并切换到一个目录路径，使用此命令：
- en: '[PRE102]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now the stack contains `/var/www ~` and the current directory is changed to
    `/var/www`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在栈中包含 `/var/www ~`，当前目录已经切换到 `/var/www`。
- en: 'Now, push the next directory path:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，推入下一个目录路径：
- en: '[PRE103]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Now the stack contains `/usr/src``/var/www ~` and the current directory is `/usr/src`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在栈中包含 `/usr/src` `/var/www ~`，当前目录是 `/usr/src`。
- en: You can push as many directory paths as needed.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要推入任意数量的目录路径。
- en: 'View the stack contents:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看栈的内容：
- en: '[PRE104]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now when you want to switch to any path in the list, number each path from
    `0` to `n`, then use the path number for which we need to switch. Consider this
    example:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你想切换到列表中的任何路径时，给每个路径编号，从 `0` 到 `n`，然后使用需要切换的路径编号。考虑以下示例：
- en: '[PRE105]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Now it will rotate the stack and switch to the `/usr/share` directory.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它将旋转栈并切换到 `/usr/share` 目录。
- en: '`pushd` will always add paths to the stack. To remove paths from the stack,
    use `popd`.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd` 总是将路径添加到栈中。要从栈中移除路径，使用 `popd`。'
- en: 'Remove a last pushed path and change to the next directory:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除最后一个推入的路径并切换到下一个目录：
- en: '[PRE106]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Suppose the stack is `/usr/src /var/www ~ /usr/share /etc`, and the current
    directory is `/usr/src`. The `popd` command will change the stack to `/var/www
    ~ /usr/share /etc` and change the current directory to `/var/www`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 假设栈是 `/usr/src /var/www ~ /usr/share /etc`，当前目录是 `/usr/src`。执行 `popd` 命令会将栈更改为
    `/var/www ~ /usr/share /etc`，并将当前目录更改为 `/var/www`。
- en: To remove a specific path from the list, use `popd +num`. `num` is counted as
    `0` to `n` from left to right.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从列表中移除特定路径，使用 `popd +num`。`num` 是从左到右按 `0` 到 `n` 计数的。
- en: There's more...
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through the essential directory navigation practices.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看基本的目录导航操作。
- en: pushd and popd are useful when there are more than three directory paths used.
    However, when you use only two locations, there is an alternative and easier way,
    that is, cd -.
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当使用超过三个目录路径时，`pushd` 和 `popd` 非常有用。然而，当你只使用两个位置时，有一种更简单的替代方法，即 `cd -`。
- en: The current path is `/var/www`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当前路径是 `/var/www`。
- en: '[PRE107]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, to switch back to `/var/www`, you don''t have to type `/var/www`, just
    execute:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要切换回 `/var/www`，你不需要重新输入 `/var/www`，只需执行：
- en: '[PRE108]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To switch to `/usr/src`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到 `/usr/src`：
- en: '[PRE109]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Counting the number of lines, words, and characters in a file
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算文件中的行数、单词数和字符数
- en: Counting the number of lines, words, and characters in a text file is frequently
    useful. This book includes some tricky examples in other chapters where the counts
    are used to produce the required output. **Counting LOC** (**Lines of Code**)
    is a common application for developers. We may need to count a subset of files,
    for example, all source code files, but not object files. A combination of `wc`
    with other commands can perform that.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 计算文本文件中的行数、单词数和字符数是非常常用的操作。本书的其他章节包含一些复杂的示例，这些计数用于生成所需的输出。**计算 LOC**（**代码行数**）是开发人员常见的应用场景。我们可能需要计算某些文件的子集，例如，所有源代码文件，但不包括目标文件。结合
    `wc` 和其他命令可以实现这个目的。
- en: The `wc` utility counts lines, words, and characters. It stands for **word count**.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc` 工具用于统计行数、单词数和字符数。它代表 **word count**（字数统计）。'
- en: How to do it...
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `wc` command supports options to count the number of lines, words, and
    characters:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc` 命令支持选项来计算行数、单词数和字符数：'
- en: 'Count the number of lines:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算行数：
- en: '[PRE110]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'To use `stdin` as input, use this command:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `stdin` 作为输入，使用此命令：
- en: '[PRE111]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Count the number of words:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算单词数：
- en: '[PRE112]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Count the number of characters:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字符数：
- en: '[PRE113]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'To count the characters in a text string, use this command:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算文本字符串中的字符数，使用此命令：
- en: '[PRE114]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here, `-n` deletes the final newline character.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-n` 会删除最后一个换行符。
- en: 'To print the number of lines, words, and characters, execute `wc` without any
    options:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印行数、单词数和字符数，执行没有任何选项的 `wc`：
- en: '[PRE115]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Those are the number of lines, words, and characters.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是行数、单词数和字符数。
- en: 'Print the length of the longest line in a file with the `-L` option:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `-L` 选项打印文件中最长行的长度：
- en: '[PRE116]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Printing the directory tree
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印目录树
- en: Graphically representing directories and filesystems as a tree hierarchy makes
    them easier to visualize. This representation is used by monitoring scripts to
    present the filesystem in an easy-to-read format.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 通过树状层级图形表示目录和文件系统，可以更容易地进行可视化。监控脚本使用这种表示方式将文件系统以易读的格式展示出来。
- en: Getting ready
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `tree` command prints graphical trees of files and directories. The `tree`
    command does not come with preinstalled Linux distributions. You must install
    it using the package manager.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令打印文件和目录的图形化树状结构。`tree` 命令并没有预安装在 Linux 发行版中，你需要通过包管理器安装它。'
- en: How to do it...
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a sample Unix filesystem tree to show an example:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例 Unix 文件系统树，用于展示一个例子：
- en: '[PRE117]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `tree` command supports several options:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令支持多个选项：'
- en: 'To display only files that match a pattern, use the `-P` option:'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅显示与模式匹配的文件，请使用 `-P` 选项：
- en: '[PRE118]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Consider this example:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 看这个例子：
- en: '[PRE119]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'To display only files that do not match a pattern, use the `-I` option:'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示与模式不匹配的文件，请使用 `-I` 选项：
- en: '[PRE120]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'To print the size along with files and directories, use the `-h` option:'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要显示文件和目录的大小，请使用 `-h` 选项：
- en: '[PRE121]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: There's more...
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: The tree command can generate output in HTML as well as to a terminal.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令可以生成 HTML 输出，也可以输出到终端。'
- en: HTML output for tree
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`tree` 的 HTML 输出'
- en: 'This command creates an HTML file with the tree output:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建一个带有 `tree` 输出的 HTML 文件：
- en: '[PRE122]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Replace `http://localhost` with the URL where you are planning to host the file.
    Replace `PATH` with a real path for the base directory. For the current directory,
    use `.` as `PATH`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `http://localhost` 替换为你打算托管文件的 URL。将 `PATH` 替换为真实的基础目录路径。对于当前目录，使用 `.` 作为
    `PATH`。
- en: 'The web page generated from the directory listing will look as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录列表生成的网页将如下所示：
- en: '![](img/Ch03_img.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Ch03_img.jpg)'
- en: Manipulating video and image files
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理视频和图像文件
- en: Linux and Unix support many applications and tools for working with images and
    video files. Most Linux distributions include the **imageMagick** suite with the
    **convert** application for manipulating images. The full-function video editing
    applications such as **kdenlive** and **openshot** are built on top of the **ffmpeg**
    and **mencoder** command line applications.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 Unix 支持许多用于处理图像和视频文件的应用程序和工具。大多数 Linux 发行版都包括 **ImageMagick** 套件及其用于图像处理的
    **convert** 应用程序。功能全面的视频编辑应用程序如 **kdenlive** 和 **openshot** 是基于 **ffmpeg** 和 **mencoder**
    命令行工具构建的。
- en: The convert application has hundreds of options. We'll just use the one that
    extracts a portion of an image.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert` 应用程序有数百个选项。我们只使用一个用于提取图像部分的选项。'
- en: '`ffmpeg` and `mencoder` have enough options and features to fill a book all
    by themselves. We''ll just look at a couple simple uses.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`ffmpeg` 和 `mencoder` 选项和功能足够多，几乎可以写成一本书。我们只看几个简单的用法。'
- en: This section has some recipes for manipulating still images and videos.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含一些处理静态图像和视频的命令。
- en: Getting ready
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Most Linux distributions include the **ImageMagick** tools. If your system does
    not include them, or if they are out of date, there are instructions for downloading
    and installing the latest tools on the ImageMagick website at [www.imagemagick.org](http://www.imagemagick.org/).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都包含了 **ImageMagick** 工具。如果你的系统没有包含，或者工具版本过旧，可以参考 ImageMagick 网站上的说明下载和安装最新版本：[www.imagemagick.org](http://www.imagemagick.org/)。
- en: Like ImageMagick, many Linux distributions already include the `ffmpeg` and
    `mencoder` toolsets. The latest releases can be found at the `ffmpeg` and `mencoder`
    websites at [http://www.ffmpeg.org](http://www.ffmpeg.org/) and [http://www.mplayerhq.hu](http://www.mplayerhq.hu/).
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ImageMagick 类似，许多 Linux 发行版已经包含了 `ffmpeg` 和 `mencoder` 工具集。最新版本可以在 `ffmpeg`
    和 `mencoder` 的官网找到：[http://www.ffmpeg.org](http://www.ffmpeg.org/) 和 [http://www.mplayerhq.hu](http://www.mplayerhq.hu/)。
- en: Building and installing the video tools will probably require loading codecs
    and other ancillary files with confusing version dependencies. If you intend to
    use your Linux system for audio and video editing, it's simplest to use a Linux
    distribution that's designed for this, such as the Ubuntu Studio distributions.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和安装视频工具可能需要加载编解码器和其他带有复杂版本依赖的附加文件。如果你打算将 Linux 系统用于音视频编辑，最简单的方法是使用专为此设计的 Linux
    发行版，比如 Ubuntu Studio。
- en: 'Here are some recipes for a couple of common audio-video conversions:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个常见音视频转换的示例：
- en: Extracting Audio from a movie file (mp4)
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从电影文件（mp4）中提取音频
- en: 'Music videos are fun to watch, but the point of music is to listen to it. Extracting
    the audio portion from a video is simple:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 音乐视频很好看，但音乐的重点是听。提取视频中的音频部分很简单：
- en: How to do it...
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following command accepts an `mp4` video file (`FILE.mp4`) and extracts
    the audio portion into a new file (`OUTPUTFILE.mp3`) as an `mp3`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令接受一个`mp4`视频文件（`FILE.mp4`），并将音频部分提取到一个新的文件（`OUTPUTFILE.mp3`）中，以`mp3`格式保存：
- en: '[PRE123]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Making a video from a set of still images
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一组静态图像制作视频
- en: Many cameras support taking pictures at intervals. You can use this feature
    to do your own time-lapse photography or create stop-action videos. There are
    examples of this on [www.cwflynt.com](http://www.cwflynt.com/). You can convert
    a set of still images into a video with the OpenShot video editing package or
    from a command line using the mencoder tool.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 许多相机支持间隔拍摄。你可以利用这个功能进行自己的延时摄影或制作定格动画视频。在[www.cwflynt.com](http://www.cwflynt.com/)上有相关示例。你可以使用OpenShot视频编辑包或者通过命令行工具mencoder将一组静态图像转换为视频。
- en: How to do it...
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This script will accept a list of images and will create an MPEG video file
    from it:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将接受一个图像列表，并从中创建一个MPEG视频文件：
- en: '[PRE124]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To use this script, copy/paste the commands into a file named `stills2mpg.sh`,
    make it executable and invoke it as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个脚本，复制/粘贴命令到一个名为`stills2mpg.sh`的文件中，使其具有可执行权限，并按如下方式调用：
- en: '[PRE125]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Alternatively, use this to invoke it:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下方式调用它：
- en: '[PRE126]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works...
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mencoder` command requires that the input file be formatted as one image
    file per line. The first line of the script echoes the command line arguments
    to the tr command to convert the space delimiters to newlines. This transforms
    the single-line list into a list of files arranged one per line.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`mencoder`命令要求输入文件格式为每行一个图像文件。脚本的第一行通过tr命令回显命令行参数，将空格分隔符转换为换行符。这将把单行列表转换为每行一个文件的文件列表。'
- en: You can change the speed of the video by resetting the **FPS** (**frames-per-second**)
    parameter. For example, setting the fps value to `1` will make a slide show that
    changes images every second.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过重置**FPS**（**每秒帧数**）参数来改变视频的速度。例如，将fps值设置为`1`将制作一个每秒换图的幻灯片。
- en: Creating a panned video from a still camera shot
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从静态相机拍摄制作推移视频
- en: If you decide to create your own video, you'll probably want a panned shot of
    some landscape at some point. You can record a video image with most cameras,
    but if you only have a still image you can still make a panned video.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定制作自己的视频，可能会想在某个时刻录制一段景观的推移镜头。你可以用大多数相机录制视频图像，但如果你只有一张静态图像，仍然可以制作推移视频。
- en: How to do it...
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Cameras commonly take a larger image than will fit on a video. You can create
    a motion-picture pan using the convert application to extract sections of a large
    image, and stitch them together into a video file with `mencoder`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 相机通常拍摄的图像比视频所能容纳的要大。你可以使用convert应用程序从大图像中提取部分，利用`mencoder`将它们拼接成一个视频文件，从而制作一个动态电影效果：
- en: '[PRE127]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How it works...
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This script is more complex than the ones we've looked at so far. It uses seven
    command-line arguments to define the input image, a prefix to use for the output
    files, the width and height for the intermediate images, and the starting offset
    into the original image.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本比我们之前看到的脚本更复杂。它使用七个命令行参数来定义输入图像、输出文件的前缀、中间图像的宽度和高度以及原始图像的起始偏移量。
- en: Within the `for` loop, it creates a set of image files and stores the names
    in a file named `tmpFiles`. Finally, the script uses `mencoder` to merge the extracted
    image files into an MPEG video that can be imported into a video editor such as
    kdenlive or OpenShot.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，它创建一组图像文件，并将文件名存储在名为`tmpFiles`的文件中。最后，脚本使用`mencoder`将提取的图像文件合并成一个MPEG视频，可以导入到视频编辑器中，如kdenlive或OpenShot。
