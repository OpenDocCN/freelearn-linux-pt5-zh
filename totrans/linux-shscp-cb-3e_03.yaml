- en: File In, File Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating files of any size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection and set difference (A-B) on text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and deleting duplicate files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with file permissions, ownership, and the sticky bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making files immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating blank files in bulk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding symbolic links and their targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating file type statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using loopback files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ISO files and hybrid ISO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the difference between files, and patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using head and tail for printing the last or first 10 lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing only directories - alternative methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast command-line navigation using `pushd` and `popd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the number of lines, words, and characters in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the directory tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating video and image files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix provides a file-style interface to all devices and system features. The
    special files provide direct access to devices such as USB sticks and disk drives
    and provide access to system functions such as memory usage, sensors, and the
    process stack. For example, the command terminal we use is associated with a device
    file. We can write to the terminal by writing to the corresponding device file.
    We can access directories, regular files, block devices, character-special devices,
    symbolic links, sockets, named pipes, and so on as files. Filename, size, file
    type, modification time, access time, change time, inode, links associated, and
    the filesystem the file is on are all attributes and properties files can have.
    This chapter deals with recipes to handle operations or properties related to
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Generating files of any size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A file of random data is useful for testing. You can use such files to test
    application efficiency, to confirm that an application is truly input-neutral,
    to confirm there's no size limitations in your application, to create loopback
    filesystems (**loopback files** are files that can contain a filesystem itself
    and these files can be mounted similarly to a physical device using the `mount`
    command), and more. Linux provides general utilities to construct such files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to create a large file of a given size is with the `dd` command.
    The `dd` command clones the given input and writes an exact copy to the output.
    Input can be `stdin`, a device file, a regular file, and so on. Output can be
    `stdout`, a device file, a regular file, and so on. An example of the `dd` command
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a file called `junk.data` containing exactly 1 MB of zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` defines the `input` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of` defines the `output` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bs` defines bytes in a block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` defines the number of blocks to be copied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful while using the `dd` command as root, as it operates on a low level
    with the devices. A mistake could wipe your disk or corrupt the data. Double-check
    your `dd` command syntax, especially your of `=` parameter for accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we created a 1 MB file, by specifying `bs` as 1 MB
    with a count of 1\. If `bs` was set to `2M` and `count` to `2`, the total file
    size would be 4 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use various units for **block****size** (**bs**). Append any of the
    following characters to the number to specify the size:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Unit size** | **Code** |'
  prefs: []
  type: TYPE_TB
- en: '| Byte (1 B) | `C` |'
  prefs: []
  type: TYPE_TB
- en: '| Word (2 B) | `W` |'
  prefs: []
  type: TYPE_TB
- en: '| Block (512 B) | `B` |'
  prefs: []
  type: TYPE_TB
- en: '| Kilobyte (1024 B) | `K` |'
  prefs: []
  type: TYPE_TB
- en: '| Megabyte (1024 KB) | `M` |'
  prefs: []
  type: TYPE_TB
- en: '| Gigabyte (1024 MB) | `G` |'
  prefs: []
  type: TYPE_TB
- en: We can generate a file of any size using **bs**. Instead of MB we can use any
    other unit notations, such as the ones mentioned in the previous table.
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/zero` is a character special device, which returns the zero byte (`\0`).'
  prefs: []
  type: TYPE_NORMAL
- en: If the input parameter (`if`) is not specified, dd will read input from `stdin`.
    If the output parameter (`of`) is not specified, `dd` will use `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` command can be used to measure the speed of memory operations by transferring
    a large quantity of data to `/dev/null` and checking the command output (for example,
    `1048576 bytes (1.0 MB) copied, 0.00767266 s, 137 MB/s`, as seen in the previous
    example).
  prefs: []
  type: TYPE_NORMAL
- en: The intersection and set difference (A-B) on text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intersection and set difference operations are common in mathematics classes
    on set theory. Similar operations on strings are useful in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `comm` command is a utility to perform a comparison between two sorted files.
    It displays lines that are unique to file 1, file 2, and lines in both files.
    It has options to suppress one more column, making it easy to perform intersection
    and difference operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Intersection**: The intersection operation will print the lines the specified
    files have in common with one another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference**: The difference operation will print the lines the specified
    files contain and that are not the same in all of those files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set difference**: The set difference operation will print the lines in file
    `A` that do not match those in all of the set of files specified (`B` plus `C`,
    for example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that `comm` takes two sorted files as input. Here are our sample input
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, execute `comm` without any options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first column of the output contains lines that are only in `A.txt`. The
    second column contains lines that are only in `B.txt`. The third column contains
    the common lines from `A.txt` and `B.txt`. Each of the columns are delimited using
    the tab (`\t`) character.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print the intersection of two files, we need to remove the first
    and second columns and print the third column. The `-1` option removes the first
    column, and the `-2` option removes the second column, leaving the third column:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Print only the lines that are uncommon between the two files by removing column
    `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This output uses two columns with blanks to show the unique lines in file1
    and file2\. We can make this more readable as a list of unique lines by merging
    the two columns into one, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The lines can be merged by removing the tab characters with `tr` (discussed
    in [Chapter 2](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml), *Have a Good Command*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By removing the unnecessary columns, we can produce the set difference for
    `A.txt` and `B.txt`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set difference for `A.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`-2 -3` removes the second and third columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set difference for `B.txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`-2 -3` removes the second and third columns'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These command-line options reduce the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1`: Removes the first column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-2`: Removes the second column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-3`: Removes the third column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set difference operation enables you to compare two files and print all
    the lines that are in the `A.txt` or `B.txt` file excluding the common lines in
    `A.txt` and `B.txt`. When `A.txt` and `B.txt` are given as arguments to the `comm`
    command, the output will contain column-1 with the set difference for `A.txt`
    with regard to `B.txt` and column-2 will contain the set difference for `B.txt`
    with regard to `A.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The `comm` command will accept a `-` character on the command line to read one
    file from `stdin`. This provides a way to compare more than one file with a given
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a `C.txt` file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare the `B.txt` and `C.txt` files with `A.txt`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finding and deleting duplicate files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need to recover backups or you use your laptop in a disconnected mode
    or download images from a phone, you''ll eventually end up with duplicates: files
    with the same content. You''ll probably want to remove duplicate files and keep
    a single copy. We can identify duplicate files by examining the content with shell
    utilities. This recipe describes finding duplicate files and performing operations
    based on the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We identify the duplicate files by comparing file content. Checksums are ideal
    for this task. Files with the same content will produce the same checksum values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps for finding or deleting duplicate files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate some test files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the script to remove the duplicate files uses `awk`, an interpreter
    that''s available on all Linux/Unix systems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code will find the copies of the same file in a directory and
    remove all except one copy of the file. Let's go through the code and see how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: '`ls -lS` lists the details of the files in the current folder sorted by file
    size. The `--time-style=long-iso` option tells `ls` to print dates in the ISO
    format. `awk` reads the output of `ls -lS` and performs comparisons on columns
    and rows of the input text to find duplicate files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic behind the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We list the files sorted by size, so files of the same size will be adjacent.
    The first step in finding identical files is to find ones with the same size.
    Next, we calculate the checksum of the files. If the checksums match, the files
    are duplicates and one set of the duplicates are removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BEGIN{}` block of `awk` is executed before the main processing. It reads
    the "total" lines and initializes the variables. The bulk of the processing takes
    place in the `{}` block, when `awk` reads and processes the rest of the `ls` output.
    The `END{}` block statements are executed after all input has been read. The output
    of `ls -lS` is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output of the first line tells us the total number of files, which in this
    case is not useful. We use `getline` to read the first line and then dump it.
    We need to compare each of the lines and the following line for size. In the `BEGIN`
    block, we read the first line and store the name and size (which are the eighth
    and fifth columns). When `awk` enters the `{}` block, the rest of the lines are
    read, one by one. This block compares the size obtained from the current line
    and the previously stored size in the `size` variable. If they are equal, it means
    that the two files are duplicates by size and must be further checked by `md5sum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have played some tricks on the way to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external command output can be read inside `awk` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once the line is read, the entire line is in `$0` and each column is available
    in `$1`, `$2`, ..., `$n`. Here, we read the md5sum checksum of files into the
    `csum1` and `csum2` variables. The `name1` and `name2` variables store the consecutive
    filenames. If the checksums of two files are the same, they are confirmed to be
    duplicates and are printed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to find a file from each group of duplicates so we can remove all other
    duplicates. We calculate the `md5sum` value of the duplicates and print one file
    from each group of duplicates by finding unique lines, comparing `md5sum` from
    each line using `-w 32` (the first 32 characters in the `md5sum` output; usually,
    the `md5sum` output consists of a 32-character hash followed by the filename).
    One sample from each group of duplicates is written to `unique_files`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to remove the files listed in `duplicate_files`, excluding the
    files listed in `unique_files`. The `comm` command prints files in `duplicate_files`
    but not in `unique_files`.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we use a set difference operation (refer to the recipes on intersection,
    difference, and set difference).
  prefs: []
  type: TYPE_NORMAL
- en: '`comm` only processes sorted input. Therefore, `sort -u` is used to filter
    `duplicate_files` and `unique_files`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `tee` command is used to pass filenames to the `rm` command as well as `print`.
    The `tee` command sends its input to both `stdout and a file`. We can also print
    text to the terminal by redirecting to `stderr`. `/dev/stderr` is the device corresponding
    to `stderr` (standard error). By redirecting to a `stderr` device file, text sent
    to `stdin` will be printed in the terminal as standard error.
  prefs: []
  type: TYPE_NORMAL
- en: Working with file permissions, ownership, and the sticky bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File permissions and ownership are one of the distinguishing features of the
    Unix/Linux filesystems. These features protect your information in a multi-user
    environment. Mismatched permissions and ownership can also make it difficult to
    share files. These recipes explain how to use a file's permission and ownership
    effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Each file possesses many types of permissions. Three sets of permissions (user,
    group, and others) are commonly manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: The **user** is the owner of the file, who commonly has all access permitted.
    The **group** is the collection of users (as defined by the system administrator)
    that may be permitted some access to the file. **Others** are any users other
    than the owner or members of the owner's group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ls` command''s `-l` option displays many aspects of the file including
    type, permissions, owner, and group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first column of the output defines the file type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-`: This is used if it is a regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: This is used if it is a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: This is used for a character device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This is used for a block device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l`: This is used if it is a symbolic link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: This is used for a socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: This is used for a pipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next nine characters are divided into three groups of three letters each
    (--- --- ---). The first three characters correspond to the permissions of the
    user (owner), the second sets of three characters correspond to the permissions
    of the group, and the third sets of three characters correspond to the permissions
    of others. Each character in the nine-character sequence (nine permissions) specifies
    whether permission is set or unset. If the permission is set, a character appears
    in the corresponding position, otherwise a `-` character appears in that position,
    which means that the corresponding permission is unset (unavailable).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three common letters in the trio are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r Read`: When this is set, the file, device, or directory can be read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w Write`: When this is set, the file, device, or directory can be modified.
    On folders, this defines whether files can be created or deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x execute`: When this is set, the file, can be executed. On folders, this
    defines whether the files in the folder can be accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at what each of these three character sets mean for the
    user, group, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User** (permission string: `rwx------`): These define the options a user
    has. Usually, the user''s permission is `rw-` for a data file and `rwx` for a
    script or executable. The user has one more special permission called `setuid`
    (`S`), which appears in the position of execute (`x`). The `setuid` permission
    enables an executable file to be executed effectively as its owner, even when
    the executable is run by another user. An example of a file with `setuid` permission
    set is `-rwS------`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group** (permission string: `---rwx---`): The second set of three characters
    specifies the group permissions. Instead of `setuid`, the group has a `setgid`
    (`S`) bit. This enables the item to run an executable file with an effective group
    as the owner group. But the group, which initiates the command, may be different.
    An example of group permission is `----rwS---`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others** (permission string: `------rwx`): Other permissions appear as the
    last three characters in the permission string. If these are set, anyone can access
    this file or folder. As a rule you will want to set these bits to `---`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directories have a special permission called a **sticky bit**. When a sticky
    bit is set for a directory, only the user who created the directory can delete
    the files in the directory, even if the group and others have write permissions.
    The sticky bit appears in the position of execute character (`x`) in the others
    permission set. It is represented as character `t` or `T`. The `t` character appears
    in the `x` position if the execute permission is unset and the sticky bit is set.
    If the sticky bit and the execute permission are set, the `T` character appears
    in the `x` position. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A typical example of a directory with sticky bit turned on is `/tmp`, where
    anyone can create a file, but only the owner can delete one.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the `ls -l` output lines, the string `slynux users` corresponds to
    the user and group. Here, `slynux` is the owner who is a member of the group users.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to set permissions for files, we use the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that we need to set the permission, `rwx rw- r-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set these permissions with chmod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The options used here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u`: This specifies user permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: This specifies group permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o`: This specifies others permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `+` to add permission to a user, group, or others, and use `-` to remove
    the permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the executable permission to a file, which has the permission, `rwx rw-
    r-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command adds the `x` permission for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the executable permission to all permission categories, that is, for user,
    group, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here `a` means all.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove a permission, use `-`. For example, **$ chmod a-x filename**.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions can be denoted with three-digit octal numbers in which each digit
    corresponds to user, group, and other, in that order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read, write, and execute permissions have unique octal numbers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r` = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` = 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` = 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We calculate the required combination of permissions by adding the octal values.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw-` = 4 + 2 = 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r-x` = 4 + 1 = 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The permission `rwx rw- r--` in the numeric method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rwx` = 4 + 2 + 1 = 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw-` = 4 + 2 = 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r--` = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, `rwx rw- r--` is equal to `764`, and the command to set the permissions
    using octal values is `$ chmod 764 filename`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine more tasks we can perform on files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Changing ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chown` command will change the ownership of files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `slynux` is the user, and `users` is the group.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the sticky bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sticky bit can be applied to directories. When the sticky bit is set, only
    the owner can delete files, even though others have write permission for the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sticky bit is set with the `+t` option to `chmod`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Applying permissions recursively to files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you may need to change the permissions of all the files and directories
    inside the current directory recursively. The `-R` option to `chmod` supports
    recursive changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `-R` option specifies to change the permissions recursively.
  prefs: []
  type: TYPE_NORMAL
- en: We used `.` to specify the path as the current working directory. This is equivalent
    to `$ chmod 777 "$(pwd)" -R`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying ownership recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `chown` command also supports the `-R` flag to recursively change ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Running an executable as a different user (setuid)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some executables need to be executed as a user other than the current user.
    For example, the http server may be initiated during the boot sequence by root,
    but the task should be owned by the `httpd` user. The `setuid` permission enables
    the file to be executed as the file owner when any other user runs the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change the ownership to the user that needs to execute it and then log
    in as the user. Then, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now it executes as the root user regardless of who invokes it.
  prefs: []
  type: TYPE_NORMAL
- en: The `setuid` is only valid for Linux ELF binaries. You cannot set a shell script
    to run as another user. This is a security feature.
  prefs: []
  type: TYPE_NORMAL
- en: Making files immutable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Read, Write, Execute, and Setuid fields are common to all Linux file systems.
    The **Extended File Systems** (ext2, ext3, and ext4) support more attributes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the extended attributes makes files immutable. When a file is made immutable,
    any user or super user cannot remove the file until the immutable attribute is
    removed from the file. You can determine the type of filesystem with the `df -T`
    command, or by looking at the `/etc/mtab` file. The first column of the file specifies
    the partition device path (for example, `/dev/sda5`) and the third column specifies
    the filesystem type (for example, ext3).
  prefs: []
  type: TYPE_NORMAL
- en: Making a file immutable is one method for securing files from modification.
    One example is to make the `/etc/resolv.conf` file immutable. The `resolv.conf`
    file stores a list of DNS servers, which convert domain names (such as packtpub.com)
    to IP addresses. The DNS server is usually your ISP's DNS server. However, if
    you prefer a third-party server, you can modify `/etc/resolv.conf` to point to
    that DNS. The next time you connect to your ISP, `/etc/resolv.conf` will be overwritten
    to point to ISP's DNS server. To prevent this, make `/etc/resolv.conf` immutable.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to make files immutable and make them mutable
    when required.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `chattr` command is used to change extended attributes. It can make files
    immutable, as well as modify attributes to tune filesystem sync or compression.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the files immutable, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `chattr` to make a file immutable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is now immutable. Try the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make it writable, remove the immutable attribute, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Generating blank files in bulk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripts must be tested before they are used on a live system. We may need to
    generate thousands of files to confirm that there are no memory leaks or processes
    left hanging. This recipe shows how to generate blank files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `touch` command creates blank files or modifies the timestamp of existing
    files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate blank files in bulk, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking the touch command with a non-existent filename creates an empty file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate bulk files with a different name pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `{1..100}` will be expanded to a string `1, 2, 3, 4,
    5, 6, 7...100`. Instead of `{1..100}.txt`, we can use various shorthand patterns
    such as `test{1..200}.c`, `test{a..z}.txt`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a file already exists, the `touch` command changes all timestamps associated
    with the file to the current time. These options define a subset of timestamps
    to be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '`touch -a`: This modifies the access time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch -m`: This modifies the modification time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of the current time, we can specify the time and date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The date string used with `-d` need not be in this exact format. It will accept
    many simple date formats. We can omit time from the string and provide only dates
    such as *Jan 20*, *2010*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding symbolic links and their targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbolic links are common in Unix-like systems. Reasons for using them range
    from convenient access, to maintaining multiple versions of the same library or
    program. This recipe will discuss the basic techniques for handling symbolic links.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links are pointers to other files or folders. They are similar in function
    to aliases in MacOS X or shortcuts in Windows. When symbolic links are removed,
    it does not affect the original file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps will help you handle symbolic links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a symbolic link run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This creates a symbolic link (called **web**) in the current user's home directory,
    which points to `/var/www/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the link was created, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`web -> /var/www` specifies that `web` points to `/var/www`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To print symbolic links in the current directory, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To print all symbolic links in the current directory and subdirectories, run
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the target path for a given symbolic link, use the `readlink` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `ls` and `grep` to display symbolic links in the current folder,
    the `grep ^l` command filters the `ls -l` output to only display lines starting
    with `l`. The `^` specifies the start of the string. The following `l` specifies
    that the string must start with l, the identifier for a link.
  prefs: []
  type: TYPE_NORMAL
- en: When using `find`, we use the argument -`type``l`, which instructs find to search
    for symbolic link files. The `-print` option prints the list of symbolic links
    to the standard output (`stdout`). The initial path is given as the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating file type statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports many file types. This recipe describes a script that enumerates
    through all the files inside a directory and its descendants, and prints a report
    with details on types of files (files with different file types), and the count
    of each file type. This recipe is an exercise on writing scripts to enumerate
    through many files and collect details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Unix/Linux systems, file types are not defined by the file extension (as
    Microsoft Windows does). Unix/Linux systems use the file command, which examines
    the file's contents to determine a file's type. This recipe collects file type
    statistics for a number of files. It stores the count of files of the same type
    in an associative array.
  prefs: []
  type: TYPE_NORMAL
- en: The associative arrays are supported in bash version 4 and newer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enumerate file type statistics, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the type of a file, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the file type without the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The script for file statistics is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script relies on the associative array `statarray`. This array is indexed
    by the type of file: **PDF**, **ASCII**, and so on. Each index holds the count
    for that type of file. It is defined by the `declare -A statarray` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script then consists of two loops: a while loop, that processes the output
    from the find command, and a `for` loop, that iterates through the indices of
    the `statarray` variable and generates output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The while loop syntax looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: For this script, we use the output of the find command instead of a file as
    input to `while`.
  prefs: []
  type: TYPE_NORMAL
- en: The `(find $path -type f -print)` command is equivalent to a filename, but it substitutes
    the filename with a subprocess output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first `<` is for input redirection and the second `<` is for converting
    the subprocess output to a filename. Also, there is a space between these two
    so the shell won't interpret it as the `<<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `find` command uses the `-type``f` option to return a list of files under
    the subdirectory defined in $path. The filenames are read one line at a time by
    the `read` command. When the read command receives an **EOF** (**End of File**),
    it returns a *fail* and the `while` command exits.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `while` loop, the file command is used to determine a file's type.
    The `-b` option is used to display the file type without the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file command provides more details than we need, such as image encoding
    and resolution (in the case of an image file). The details are comma-separated,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We need to extract only `ELF 32-bit LSB executable` from the previous details.
    Hence, we use the `-d,` option to specify `,` as the delimiter and `-f1` to select
    the first field.
  prefs: []
  type: TYPE_NORMAL
- en: '`<(find $path -type f -print)` is equivalent to a filename, but it substitutes
    the filename with a subprocess output. Note that the first `<` is for input redirection
    and the second `<` is for converting the subprocess output to a filename. Also,
    there is a space between these two so that the shell won''t interpret it as the
    `<<` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bash 3.x and higher, we have a new operator `<<<` that lets us use a string
    output as an input file. Using this operator, we can write the done line of the
    loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`${!statarray[@]}` returns the list of array indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Using loopback files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux filesystems normally exist on devices such as disks or memory sticks.
    A file can also be mounted as a filesystem. This filesystem-in-a-file can be used
    for testing, for customized filesystems, or even as an encrypted disk for confidential
    information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a 1 GB ext4 filesystem in a file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `dd` to create a 1 GB file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The size of the created file exceeds 1 GB because the hard disk is a block device,
    and hence, storage must be allocated by integral multiples of blocks size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Format the 1 GB file to ext4 using the `mkfs` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the file type with the file command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mount point and mount the loopback file with `mkdir` and mount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `-o loop` option is used to mount loopback filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: This is a short method that attaches the loopback filesystem to a device chosen
    by the operating system named something similar to `/dev/loop1` or `/dev/loop2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a specific loopback device, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To umount (`unmount`), use the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the device file path as an argument to the `umount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the mount and umount commands should be executed as a root user, since
    it is a privileged command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First we had to create a file to make a loopback filesystem. For this, we used
    `dd`, which is a generic command for copying raw data. It copies data from the
    file specified in the `if` parameter to the file specified in the `of` parameter.
    We instruct `dd` to copy data in blocks of size 1 GB and copy one such block,
    creating a 1 GB file. The `/dev/zero` file is a special file, which will always
    return 0 when you read from it.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `mkfts.ext4` command to create an ext4 filesystem in the file. A
    filesystem is needed on any device that can be mounted. Common filesystems include
    ext4, ext3, and vfat.
  prefs: []
  type: TYPE_NORMAL
- en: The `mount` command attaches the loopback file to a **mountpoint** (`/mnt/loopback`
    in this case). A mountpoint makes it possible for users to access the files stored
    on a filesystem. The mountpoint must be created using the `mkdir` command before
    executing the `mount` command. We pass the `-o loop` option to mount to tell it
    that we are mounting a loopback file, not a device.
  prefs: []
  type: TYPE_NORMAL
- en: When `mount` knows it is operating on a loopback file, it sets up a device in
    `/dev` corresponding to the loopback file and then mounts it. If we wish to do
    it manually, we use the `losetup` command to create the device and then the `mount`
    command to mount it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore some more possibilities with loopback files and mounting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating partitions inside loopback images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we want to create a loopback file, partition it, and finally mount a
    sub-partition. In this case, we cannot use `mount -o loop`. We must manually set
    up the device and mount the partitions in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To partition a file of zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`fdisk` is a standard partitioning tool on Linux systems. A very concise tutorial
    on creating partitions using `fdisk` is available at [http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html](http://www.tldp.org/HOWTO/Partition/fdisk_partitioning.html)
    (make sure to use `/dev/loop1` instead of `/dev/hdb` in this tutorial).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create partitions in `loopback.img` and mount the first partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, `/dev/loop2` represents the first partition,`-o` is the offset flag, and `32256`
    bytes are for a DOS partition scheme. The first partition starts 32256 bytes from
    the start of the hard disk.
  prefs: []
  type: TYPE_NORMAL
- en: We can set up the second partition by specifying the required offset. After
    mounting, we can perform all regular operations as we can on physical devices.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting loopback disk images with partitions more quickly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can manually pass partition offsets to `losetup` to mount partitions inside
    a loopback disk image. However, there is a quicker way to mount all the partitions
    inside such an image using `kpartx`. This utility is usually not installed, so
    you will have to install it using your package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates mappings from the partitions in the disk image to devices in `/dev/mapper`,
    which you can then mount. For example, to mount the first partition, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re done with the devices (and unmounting any mounted partitions using
    `umount`), remove the mappings by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Mounting ISO files as loopback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ISO file is an archive of an optical media. We can mount ISO files in the
    same way that we mount physical disks using loopback mounting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even use a nonempty directory as the mount path. Then, the mount path
    will contain data from the devices rather than the original contents, until the
    device is unmounted. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now, perform operations using files from `/mnt/iso`. ISO is a read-only filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Flush changing immediately with sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Changes on a mounted device are not immediately written to the physical device.
    They are only written when the internal memory buffer is full. We can force writing
    with the `sync` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Creating ISO files and hybrid ISO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ISO image is an archive format that stores the exact image of an optical
    disk such as CD-ROM, DVD-ROM, and so on. ISO files are commonly used to store
    content to be burned to optical media.
  prefs: []
  type: TYPE_NORMAL
- en: This section will describe how to extract data from an optical disk into an
    ISO file that can be mounted as a loopback device, and then explain ways to generate
    your own ISO file systems that can be burned to an optical media.
  prefs: []
  type: TYPE_NORMAL
- en: We need to distinguish between bootable and non-bootable optical disks. Bootable
    disks are capable of booting from themselves and also running an operating system
    or another product. Bootable DVDs include installation kits and *Live* systems
    such as Knoppix and Puppy.
  prefs: []
  type: TYPE_NORMAL
- en: Non-bootable ISOs cannot do that. Upgrade kits, source code DVDs, and so on
    are non-bootable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that copying files from a bootable CD-ROM to another CD-ROM is not sufficient
    to make the new one bootable. To preserve the bootable nature of a CD-ROM, it
    must be copied as a disk image using an ISO file.
  prefs: []
  type: TYPE_NORMAL
- en: Many people use flash drives as a replacement for optical disks. When we write
    a bootable ISO to a flash drive, it will not be bootable unless we use a special
    hybrid ISO image designed specifically for the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: These recipes will give you an insight into ISO images and manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, Unix handles everything as files. Every device is a
    file. Hence, if we want to copy an exact image of a device, we need to read all
    data from it and write to a file. An optical media reader will be in the `/dev`
    folder with a name such as `/dev/cdrom`, `/dev/dvd`, or perhaps `/dev/sd0`. Be
    careful when accessing an `sd*.` Multiple disk-type devices are named `sd#`. Your
    hard drive may be `sd0` and the CD-ROM `sd1`, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` command will read any data, and redirection will write that data to
    a file. This works, but we'll also see better ways to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create an ISO image from `/dev/cdrom`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Though this will work, the preferred way to create an ISO image is with `dd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mkisofs` command creates an ISO image in a file. The output file created
    by `mkisofs` can be written to CD-ROM or DVD-ROM with utilities such as `cdrecord`.
    The `mkisofs` command will create an ISO file from a directory containing all
    the files to be copied to the ISO file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` option in the `mkisofs` command specifies the ISO file path. The `source_dir`
    is the path of the directory to be used as content for the ISO file and the `-V`
    option specifies the label to use for the ISO file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn more commands and techniques related to ISO files.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid ISO that boots off a flash drive or hard disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bootable ISO files cannot usually be transferred to a USB storage device to
    create a bootable USB stick. However, special types of ISO files called hybrid
    ISOs can be flashed to create a bootable device.
  prefs: []
  type: TYPE_NORMAL
- en: We can convert standard ISO files into hybrid ISOs with the `isohybrid` command.
    The `isohybrid` command is a new utility and most Linux distros don't include
    this by default. You can download the [syslinux package](http://syslinux.zytor.com/)
    from [http://www.syslinux.org](http://www.syslinux.org). The command may also
    be available in your yum or `apt-get` repository as `syslinux-utils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will make an ISO file bootable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The ISO file can now be written to USB storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write the ISO to a USB storage device, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the appropriate device instead of `/dev/sdb1`, or you can use `cat`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Burning an ISO from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cdrecord` command burns an ISO file to a CD-ROM or DVD-ROM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To burn the image to the CD-ROM, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Useful options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the burning speed with the `-speed` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, `8` is the speed specified as 8x.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CD-ROM can be burned in multi-sessions such that we can burn data multiple
    times on a disk. Multisession burning can be done with the `-multi` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Playing with the CD-ROM tray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are on a desktop computer, try the following commands and have fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This command will eject the tray.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This command will close the tray.
  prefs: []
  type: TYPE_NORMAL
- en: For extra points, write a loop that opens and closes the tray a number of times.
    It goes without saying that one would never slip this into a co-workers `.bashrc`
    while they are out getting a coffee.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the difference between files, and patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When multiple versions of a file are available, it is useful to highlight the
    differences between files rather than comparing them manually. This recipe illustrates
    how to generate differences between files. When working with multiple developers,
    changes need to be distributed to the others. Sending the entire source code to
    other developers is time consuming. Sending a difference file instead is helpful,
    as it consists of only lines which are changed, added, or removed, and line numbers
    are attached with it. This difference file is called a **patch file**. We can
    add the changes specified in the patch file to the original source code with the
    `patch` command. We can revert the changes by patching again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `diff` utility reports the differences between two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate diff behavior, create the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'File 1: `version1.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'File 2: `version2.txt`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Nonunified `diff` output (without the `-u` flag) is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The unified `diff` output is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `-u` option produces a unified output. Unified diff output is more readable
    and is easier to interpret.
  prefs: []
  type: TYPE_NORMAL
- en: In unified `diff`, the lines starting with `+` are the added lines and the lines
    starting with `-` are the removed lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'A patch file can be generated by redirecting the `diff` output to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `patch` command can apply changes to either of the two files. When applied
    to `version1.txt`, we get the `version2.txt` file. When applied to `version2.txt`,
    we generate `version1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command applies the patch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We now have `version1.txt` with the same contents as `version2.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To revert the changes, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As shown, patching an already patched file reverts the changes. To avoid prompting
    the user with `y/n`, we can use the `-R` option along with the `patch` command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through additional features available with `diff`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating difference against directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `diff` command can act recursively against directories. It will generate
    a difference output for all the descendant files in the directories. Use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpretation of each of the options in this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-N`: This is used for treating missing files as empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: This is used to consider all files as text files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: This is used to produce unified output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This is used to recursively traverse through the files in the directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using head and tail for printing the last or first 10 lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When examining a large file, thousands of lines long, the `cat` command, which
    will display all the line,s is not suitable. Instead, we want to view a subset
    (for example, the first 10 lines of the file or the last 10 lines of the file).
    We may need to print the first *n* lines or last *n* lines or print all except
    the last *n* lines or all except the first *n* lines, or the lines between two
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: The `head` and `tail` commands can do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `head` command reads the beginning of the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the first 10 lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the data from `stdin`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the number of first lines to be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This command prints the first four lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print all lines excluding the last `M` lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is negative M.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print all the lines except the last five lines, use the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prints lines 1 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Printing everything except the last lines is a common use for `head`. When examining
    log files we most often want to view the most recent (that is, the last) lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To print the last 10 lines of a file, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To read from `stdin`, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the last five lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'To print all lines excluding the first M lines, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to print all lines except the first five lines, *M + 1 = 6*, the
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This will print from 6 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common use for `tail` is to monitor new lines in a growing file, for instance,
    a system log file. Since new lines are appended to the end of the file, `tail`
    can be used to display them as they are written. To monitor the growth of the
    file, `tail` has a special option `-f` or `--follow`, which enables `tail` to
    follow the appended lines and display them as data is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'You will probably want to use this on logfiles. The command to monitor the
    growth of the files would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `dmesg` command returns contents of the kernel ring buffer messages. We
    can use this to debug USB devices, examine disk behavior, or monitor network connectivity.
    The `-f` tail can add a sleep interval `-s` to set the interval during which the
    file updates are monitored.
  prefs: []
  type: TYPE_NORMAL
- en: The `tail` command can be instructed to terminate after a given process ID dies.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose a process `Foo` is appending data to a file that we are monitoring.
    The `-f` tail should be executed until the process `Foo` dies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When the process `Foo` terminates, `tail` also terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work on an example.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file `file.txt` and open the file in your favorite text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Add new lines to the file and make frequent file saves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you add new lines to the end of the file, the new lines will be written
    to the terminal by the `tail` command. When you close the edit session, the `tail`
    command will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Listing only directories - alternative methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Listing only directories via scripting is deceptively difficult. This recipe
    introduces multiple ways of listing only directories.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: g ready There are multiple ways of listing directories only. The `dir` command
    is similar to `ls`, but with fewer options. We can also list directories with
    `ls` and `find`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directories in the current path can be displayed in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ls` with `-d` to print directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ls -F` with `grep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ls -l` with `grep`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `find` to print directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `-F` parameter is used with `ls`, all entries are appended with some
    type of file character such as `@`, `*`, `|`, and so on. For directories, entries
    are appended with the `/` character. We use `grep` to filter only entries ending
    with the `/$` end-of-line indicator.
  prefs: []
  type: TYPE_NORMAL
- en: The first character of any line in the `ls -l` output is the type of file character.
    For a directory, the type of file character is `d`. Hence, we use `grep` to filter
    lines starting with `"d`.`"``^` is a start-of-line indicator.
  prefs: []
  type: TYPE_NORMAL
- en: The `find` command can take the parameter type as directory and `maxdepth` is
    set to `1` since we don't want it to search inside the subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: Fast command-line navigation using pushd and popd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When navigating around multiple locations in the filesystem, a common practice
    is to cd to paths you copy and paste. This is not efficient if we are dealing
    with several locations. When we need to navigate back and forth between locations,
    it is time consuming to type or paste the path with each `cd` command. Bash and
    other shells support `pushd` and `popd` to cycle between directories.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pushd` and `popd` are used to switch between multiple directories without
    retyping directory paths. `pushd` and `popd` create a stack of paths-a **Last****In****First****Out**
    (**LIFO**) list of the directories we''ve visited.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pushd` and `popd` commands replace cd for changing your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push and change a directory to a path, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Now the stack contains `/var/www ~` and the current directory is changed to
    `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, push the next directory path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Now the stack contains `/usr/src``/var/www ~` and the current directory is `/usr/src`.
  prefs: []
  type: TYPE_NORMAL
- en: You can push as many directory paths as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'View the stack contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you want to switch to any path in the list, number each path from
    `0` to `n`, then use the path number for which we need to switch. Consider this
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Now it will rotate the stack and switch to the `/usr/share` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`pushd` will always add paths to the stack. To remove paths from the stack,
    use `popd`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove a last pushed path and change to the next directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the stack is `/usr/src /var/www ~ /usr/share /etc`, and the current
    directory is `/usr/src`. The `popd` command will change the stack to `/var/www
    ~ /usr/share /etc` and change the current directory to `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a specific path from the list, use `popd +num`. `num` is counted as
    `0` to `n` from left to right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through the essential directory navigation practices.
  prefs: []
  type: TYPE_NORMAL
- en: pushd and popd are useful when there are more than three directory paths used.
    However, when you use only two locations, there is an alternative and easier way,
    that is, cd -.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current path is `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to switch back to `/var/www`, you don''t have to type `/var/www`, just
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch to `/usr/src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Counting the number of lines, words, and characters in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Counting the number of lines, words, and characters in a text file is frequently
    useful. This book includes some tricky examples in other chapters where the counts
    are used to produce the required output. **Counting LOC** (**Lines of Code**)
    is a common application for developers. We may need to count a subset of files,
    for example, all source code files, but not object files. A combination of `wc`
    with other commands can perform that.
  prefs: []
  type: TYPE_NORMAL
- en: The `wc` utility counts lines, words, and characters. It stands for **word count**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `wc` command supports options to count the number of lines, words, and
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count the number of lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `stdin` as input, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'To count the characters in a text string, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Here, `-n` deletes the final newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the number of lines, words, and characters, execute `wc` without any
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Those are the number of lines, words, and characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the length of the longest line in a file with the `-L` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Printing the directory tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphically representing directories and filesystems as a tree hierarchy makes
    them easier to visualize. This representation is used by monitoring scripts to
    present the filesystem in an easy-to-read format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tree` command prints graphical trees of files and directories. The `tree`
    command does not come with preinstalled Linux distributions. You must install
    it using the package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a sample Unix filesystem tree to show an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tree` command supports several options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display only files that match a pattern, use the `-P` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To display only files that do not match a pattern, use the `-I` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the size along with files and directories, use the `-h` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tree command can generate output in HTML as well as to a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: HTML output for tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command creates an HTML file with the tree output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Replace `http://localhost` with the URL where you are planning to host the file.
    Replace `PATH` with a real path for the base directory. For the current directory,
    use `.` as `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web page generated from the directory listing will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Ch03_img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating video and image files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux and Unix support many applications and tools for working with images and
    video files. Most Linux distributions include the **imageMagick** suite with the
    **convert** application for manipulating images. The full-function video editing
    applications such as **kdenlive** and **openshot** are built on top of the **ffmpeg**
    and **mencoder** command line applications.
  prefs: []
  type: TYPE_NORMAL
- en: The convert application has hundreds of options. We'll just use the one that
    extracts a portion of an image.
  prefs: []
  type: TYPE_NORMAL
- en: '`ffmpeg` and `mencoder` have enough options and features to fill a book all
    by themselves. We''ll just look at a couple simple uses.'
  prefs: []
  type: TYPE_NORMAL
- en: This section has some recipes for manipulating still images and videos.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Linux distributions include the **ImageMagick** tools. If your system does
    not include them, or if they are out of date, there are instructions for downloading
    and installing the latest tools on the ImageMagick website at [www.imagemagick.org](http://www.imagemagick.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Like ImageMagick, many Linux distributions already include the `ffmpeg` and
    `mencoder` toolsets. The latest releases can be found at the `ffmpeg` and `mencoder`
    websites at [http://www.ffmpeg.org](http://www.ffmpeg.org/) and [http://www.mplayerhq.hu](http://www.mplayerhq.hu/).
  prefs: []
  type: TYPE_NORMAL
- en: Building and installing the video tools will probably require loading codecs
    and other ancillary files with confusing version dependencies. If you intend to
    use your Linux system for audio and video editing, it's simplest to use a Linux
    distribution that's designed for this, such as the Ubuntu Studio distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some recipes for a couple of common audio-video conversions:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Audio from a movie file (mp4)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Music videos are fun to watch, but the point of music is to listen to it. Extracting
    the audio portion from a video is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following command accepts an `mp4` video file (`FILE.mp4`) and extracts
    the audio portion into a new file (`OUTPUTFILE.mp3`) as an `mp3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Making a video from a set of still images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many cameras support taking pictures at intervals. You can use this feature
    to do your own time-lapse photography or create stop-action videos. There are
    examples of this on [www.cwflynt.com](http://www.cwflynt.com/). You can convert
    a set of still images into a video with the OpenShot video editing package or
    from a command line using the mencoder tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script will accept a list of images and will create an MPEG video file
    from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this script, copy/paste the commands into a file named `stills2mpg.sh`,
    make it executable and invoke it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this to invoke it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mencoder` command requires that the input file be formatted as one image
    file per line. The first line of the script echoes the command line arguments
    to the tr command to convert the space delimiters to newlines. This transforms
    the single-line list into a list of files arranged one per line.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the speed of the video by resetting the **FPS** (**frames-per-second**)
    parameter. For example, setting the fps value to `1` will make a slide show that
    changes images every second.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a panned video from a still camera shot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decide to create your own video, you'll probably want a panned shot of
    some landscape at some point. You can record a video image with most cameras,
    but if you only have a still image you can still make a panned video.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cameras commonly take a larger image than will fit on a video. You can create
    a motion-picture pan using the convert application to extract sections of a large
    image, and stitch them together into a video file with `mencoder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is more complex than the ones we've looked at so far. It uses seven
    command-line arguments to define the input image, a prefix to use for the output
    files, the width and height for the intermediate images, and the starting offset
    into the original image.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `for` loop, it creates a set of image files and stores the names
    in a file named `tmpFiles`. Finally, the script uses `mencoder` to merge the extracted
    image files into an MPEG video that can be imported into a video editor such as
    kdenlive or OpenShot.
  prefs: []
  type: TYPE_NORMAL
