- en: Chapter 6. LDAP Schemas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 LDAP 架构
- en: The focus of this chapter will be LDAP Schemas. Schemas are the standard way
    of describing the structure of objects that may be stored inside the directory.
    The first few sections are designed to provide foundational knowledge of what
    schemas do and how they work—a foundation necessary for our work, later in this
    chapter, using and implementing schemas. But we will continue on from there to
    a number of more practical topics, including adding pre-defined schemas and defining
    our own custom schemas.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是 LDAP 架构。架构是描述可能存储在目录中的对象结构的标准方式。本章的前几节旨在提供架构的基本知识，解释架构的作用和工作原理——这是我们在本章后续部分使用和实现架构所需的基础知识。但我们将继续探讨一些更实际的主题，包括添加预定义架构和定义我们自己的自定义架构。
- en: 'We will begin with a general examination of schemas. From there, we will look
    at schema hierarchies. Like the directory information tree itself, schemas are
    organized into hierarchies. Next, we will examine some of the basic schemas that
    are included with OpenLDAP. We will also look at two overlays that require their
    own schemas. Finally, we will create a custom schema consisting of a pair of new
    object classes, each with new attributes. The main topics we will discuss in this
    chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对架构的一般性检查开始。从那里，我们将深入探讨架构的层次结构。像目录信息树本身一样，架构也被组织成层次结构。接下来，我们将研究 OpenLDAP
    中包括的一些基本架构。我们还将查看需要自己架构的两个覆盖。最后，我们将创建一个自定义架构，由一对新的对象类组成，每个类都有新的属性。本章我们将讨论的主要主题包括：
- en: The basics of schema definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构定义的基础
- en: The three types of object classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三种类型的对象类
- en: Using different schemas in OpenLDAP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenLDAP 中使用不同的架构
- en: Configuring the Accesslog and Password Policy Overlays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置访问日志和密码策略覆盖
- en: Obtaining and using an Object Identifier (OID)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和使用对象标识符（OID）
- en: Creating new schemas by hand
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建新架构
- en: Introduction to LDAP Schemas
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 架构简介
- en: We have already looked at a variety of attributes and object classes used in
    OpenLDAP. For example, we created entries for our users using the `person`, `organizationalPerson`,
    and `inetOrgPerson` object classes and, in so doing, we used attributes like `cn`,
    `sn`, `uid`, `mail`, and `userPassword`. We also created groups using the `groupOfNames`
    and `groupOfUniqueNames` object classes, paying special attention to the `member`
    and `uniqueMember` attributes. We even looked briefly (in Chapter 3) at object
    classes and attributes for describing documents and collections of documents (`document`
    and `documentCollection` respectively).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过 OpenLDAP 中使用的各种属性和对象类。例如，我们使用 `person`、`organizationalPerson` 和 `inetOrgPerson`
    对象类为用户创建了条目，并在此过程中使用了诸如 `cn`、`sn`、`uid`、`mail` 和 `userPassword` 等属性。我们还使用 `groupOfNames`
    和 `groupOfUniqueNames` 对象类创建了组，并特别注意了 `member` 和 `uniqueMember` 属性。我们甚至简要地（在第三章中）看过用于描述文档和文档集合的对象类和属性（分别为
    `document` 和 `documentCollection`）。
- en: Each of these object classes and attributes has a strict definition. The definitions
    of attributes and object classes are bundled together into larger collections
    called schemas. OpenLDAP applications use these schemas to determine how records
    should be structured and where (in the hierarchical structure) each entry can
    be located.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象类和属性都有严格的定义。属性和对象类的定义被捆绑在一起，形成较大的集合，称为架构。OpenLDAP 应用程序使用这些架构来确定记录应该如何结构化，以及每个条目在层次结构中的位置。
- en: Why Do They Look So Complicated?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它们看起来如此复杂？
- en: LDAP schemas have a bad reputation. They are viewed as complex, arcane, hyper-technical,
    and difficult to implement. The goal of this chapter is to overcome this perception.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 架构有一个不好的声誉。它们被认为是复杂的、神秘的、超技术的，并且难以实现。本章的目标是克服这种看法。
- en: It is understandable why this reputation persists though. I think there are
    a few aspects of LDAP schemas that are daunting to the neophyte.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这种声誉仍然是可以理解的。我认为，LDAP架构中有几个方面对于新手来说是令人生畏的。
- en: 'First, LDAP schemas are based on generations of technical specifications coming
    out of the complex X.500 system. Because of this heritage, LDAP schemas make frequent
    use of equipment that is not particularly human-friendly, such as object identifier
    numbers that look like this: `1.3.6.1.4.1.1466.115.121.1.25`. However, a little
    bit of background knowledge can overcome this hurdle.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，LDAP 架构基于多代技术规范，这些规范来源于复杂的 X.500 系统。由于这种遗产，LDAP 架构频繁使用一些不特别适合人类理解的设备，例如像这样看起来的对象标识符：`1.3.6.1.4.1.1466.115.121.1.25`。然而，掌握一点背景知识就能克服这个障碍。
- en: Second, the LDAP schema definition language is notably different from the sorts
    of definition languages (DDL) familiar to SQL developers. This is largely due
    to the different nature of the backend database. LDAP is not inherently tabular
    as relational databases are, while it does make frequent use of concepts like
    inheritance (a rarity in SQL DDL languages, though some do support the idea).
    Finally, while SQL DDL takes the form of a SQL command, LDAP schema definitions
    are purely descriptive.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，LDAP模式定义语言与SQL开发人员熟悉的定义语言（DDL）显著不同。这主要是由于后端数据库的性质不同。LDAP不像关系型数据库那样固有地是表格化的，尽管它经常使用像继承这样的概念（在SQL
    DDL语言中是罕见的，尽管一些支持这种概念）。最后，虽然SQL DDL是以SQL命令的形式出现，但LDAP模式定义则是纯粹的描述性。
- en: But the LDAP schema language is actually quite compact and typically only two
    directives (`attributetype` and `objectclasstype`), each with a handful of arguments,
    are needed in order to create custom schemas. For this reason, the learning curve
    is short, and by the end of this chapter you should be able to comfortably create
    your own schemas.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，LDAP模式语言实际上相当简洁，通常只需要两个指令（`attributetype`和`objectclasstype`），每个指令有一些参数，就可以创建自定义模式。因此，学习曲线较短，到了本章结束时，你应该能够轻松创建自己的模式。
- en: Typically schemas are written in plain-text files and stored in a subdirectory
    of the OpenLDAP configuration folder. In Ubuntu these files are located at `/etc/ldap/schema`.
    If you built from source the schema files are located by default at `/usr/local/etc/openldap/schema`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模式是以纯文本文件形式编写并存储在OpenLDAP配置文件夹的子目录中。在Ubuntu中，这些文件位于`/etc/ldap/schema`。如果是从源代码构建，模式文件默认位于`/usr/local/etc/openldap/schema`。
- en: SLAPD does not automatically use all of the schemas in the schema directory.
    When SLAPD starts up, it loads only the schemas specified in the `slapd.conf`
    file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD不会自动使用模式目录中的所有模式。SLAPD启动时，它只加载在`slapd.conf`文件中指定的模式。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is an exception to this rule: certain vital LDAP schema components, like
    `objectclass`, are hard-coded into OpenLDAP, since they are fundamental to the
    operation of the server.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个例外：某些重要的LDAP模式组件，如`objectclass`，是硬编码到OpenLDAP中的，因为它们对服务器的操作至关重要。
- en: 'Usually schemas are included using the `include` directive. In Chapter 2 we
    included three schema files in our `slapd.conf` file. The include section, near
    the top of the file, looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模式是通过`include`指令来包含的。在第2章中，我们在`slapd.conf`文件中包含了三个模式文件。文件顶部附近的include部分如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line imports the core schema, which contains the schemas of attributes
    and object classes necessary for standard LDAP use. The second imports a number
    of commonly used object classes and attributes, including those used for storing
    document information and DNS records. The `inetorgperson.schema` file includes
    the inetOrgPerson object class definition and its associated attribute definitions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行导入核心模式，其中包含标准LDAP使用所必需的属性和对象类的模式。第二行导入了一些常用的对象类和属性，包括用于存储文档信息和DNS记录的属性。`inetorgperson.schema`文件包含了inetOrgPerson对象类定义及其相关的属性定义。
- en: In the coming sections we will look at the format of these files, implementing
    some existing schemas, and finally creating our own schema.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看这些文件的格式，实现一些现有的模式，最后创建我们自己的模式。
- en: Schema Definitions
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式定义
- en: LDAP schemas are used to formally define attributes, object classes, and various
    rules for structuring the directory information tree. The term **schema** refers
    to a collection of (conceptually related) schema definitions. The `inetOrgPerson`
    schema, for example, contains the definition of the `inetOrgPerson` object class,
    as well as all of the extra (non-core) attributes that are allowed or required
    by the `inetOrgPerson` object class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP模式用于正式定义属性、对象类和各种结构化目录信息树的规则。术语**模式**指的是一组（概念上相关的）模式定义。例如，`inetOrgPerson`模式包含`inetOrgPerson`对象类的定义，以及所有由`inetOrgPerson`对象类允许或要求的额外（非核心）属性。
- en: 'A **schema definition** is a special type of directive that provides information
    about how a particular entity in SLAPD is to be structured. There are four different
    types of schema definition that can be included in `slapd.conf` (or an included
    schema definition):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式定义**是一种特殊类型的指令，用于提供关于如何构建SLAPD中某个特定实体的信息。可以在`slapd.conf`（或包含的模式定义）中包含四种不同类型的模式定义：'
- en: '**Object class definitions**: This defines an object class, including its unique
    identifier, its name, and the attributes it may or must have.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类定义**：这定义了一个对象类，包括它的唯一标识符、名称以及它可能或必须具备的属性。'
- en: '**Attribute definitions**: This defines an attribute, including its unique
    identifier, its name or names, the rules for what types of content will be allowed
    as values, and how matching operations are performed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性定义**：这定义了一个属性，包括它的唯一标识符、名称或名称、允许作为值的内容类型规则，以及如何执行匹配操作。'
- en: '**Object identifiers**: This attaches a string name to a unique identifier.
    It is primarily used to expedite creating schemas.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象标识符**：这将一个字符串名称附加到唯一标识符。它主要用于加速创建模式。'
- en: '**DIT content rules**: This specifies rules for what additional (auxiliary)
    object classes an entry with a particular structural object class may have.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DIT内容规则**：这指定了具有特定结构对象类的条目可以拥有的附加（辅助）对象类的规则。'
- en: 'In addition to these four, there are other schema definitions that are not
    typically placed in a schema. Instead, most of these are generated by OpenLDAP
    code. Here is a brief description of what each does (for more information see
    RFC 4512, which defines the LDAP schema language):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四种，还有其他不通常放置在模式中的模式定义。大多数这些是由OpenLDAP代码生成的。以下是每种的简要描述（更多信息请参见定义LDAP模式语言的RFC
    4512）：
- en: '**Matching rule definitions**: These define a rule used for matching operations.
    Searches may use matching rules (such as equality and substring matching) to find
    specific attribute values. For example, the `distinguishedNameMatch` matching
    rule (with unique identifier `2.5.13.1`) defines the matching rule for exactly
    matching DNs. This rule is used by attributes like `member` (for group membership)
    and `seeAlso`. Searching with this rule will return successful results only if
    an attribute''s value matches the given DN. The matching rules for any attribute
    determine what indexes can be created for that attribute.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配规则定义**：这些定义了用于匹配操作的规则。搜索可以使用匹配规则（例如相等匹配和子串匹配）来查找特定的属性值。例如，`distinguishedNameMatch`匹配规则（唯一标识符为`2.5.13.1`）定义了用于精确匹配DN的匹配规则。该规则被像`member`（用于组成员）和`seeAlso`这样的属性使用。使用此规则进行搜索时，只有当属性值与给定的DN匹配时，才会返回成功的结果。任何属性的匹配规则决定了可以为该属性创建哪些索引。'
- en: '**Matching rule uses**: These map attributes to matching rules, and is usually
    created dynamically by SLAPD. Based on this definition, a client can tell which
    attributes a particular matching rule can be applied to. It can be used, for example,
    to find out all of the attribute values that support exact DN matches (the `distinguishedNameMatch`
    matching rule). The schema definition for a matching rule use (`matchingRuleUse`)
    contains a unique identifier, the matching rule name, and all of the attributes
    that this matching rule applies to.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配规则使用**：这些将属性映射到匹配规则，通常由SLAPD动态创建。根据此定义，客户端可以判断某个特定的匹配规则适用于哪些属性。例如，它可以用来查找支持精确DN匹配的所有属性值（`distinguishedNameMatch`匹配规则）。匹配规则使用的模式定义（`matchingRuleUse`）包含一个唯一标识符、匹配规则名称以及该匹配规则适用的所有属性。'
- en: '**LDAP syntaxes**: These describe the syntax allowed for the content of an
    attribute value. The exact type and syntax of data for an attribute value can
    be specified when an attribute is defined. There are a number of supported syntaxes
    (`ldapSyntaxes`) defined for SLAPD, including a syntax for the DN structure, one
    for binary data, several for kinds of plain text data, and so on. We will talk
    about supported syntaxes more when we look at attribute definitions.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LDAP语法**：这些描述了允许用于属性值内容的语法。定义属性时，可以指定属性值的确切类型和语法。SLAPD定义了多个支持的语法（`ldapSyntaxes`），包括DN结构的语法、二进制数据的语法、几种纯文本数据的语法等。当我们查看属性定义时，我们会进一步讨论支持的语法。'
- en: '**Structure rules**: These define where in a directory information tree a given
    entry can be located. It is based on the structural object class of the entry.
    Structural object classes and the object class hierarchy are discussed later in
    the section *The* *Object* *Class* *Hierarchy* section.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构规则**：这些定义了给定条目可以在目录信息树中位于何处。它基于条目的结构化对象类。结构化对象类和对象类层次结构将在后面的*对象类层次结构*部分进行讨论。'
- en: '**Name forms**: These specify what attributes may or must be used in the RDN
    portion of an entry''s DN (based on the entry''s structural object class).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称格式**：这些指定了在条目的DN的RDN部分（基于条目的结构对象类）中可能或必须使用的属性。'
- en: SLAPD builds this part of the schema in code. For example, matching rule uses
    are generated based on what matching rules exist and what attributes implement
    those matching rules. Like the rest of the schema, matching rules, LDAP syntaxes,
    structure rules, and name forms can all be accessed over the LDAP protocol. See
    the *Retrieving* *Schemas* *from* *SLAPD* section for more information.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD通过代码构建架构的这一部分。例如，匹配规则的使用是基于现有的匹配规则以及哪些属性实现了这些匹配规则。像架构的其他部分一样，匹配规则、LDAP语法、结构规则和名称格式都可以通过LDAP协议进行访问。有关更多信息，请参见*从SLAPD检索架构*部分。
- en: For the time being though, we will focus primarily on the four schema definitions
    that can be included in the `slapd.conf` file. In particular, we will focus on
    creating new object classes and attributes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将主要关注可以包含在`slapd.conf`文件中的四个架构定义。特别是，我们将重点讨论如何创建新的对象类和属性。
- en: Object Classes and Attributes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类和属性
- en: 'There are two different types of schema definition that we need in order to
    extend the types of information that our directory server will store:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两种不同类型的架构定义，以便扩展我们的目录服务器将存储的信息类型：
- en: '**Attribute type definition**: An attribute type definition defines an attribute,
    including what attribute names it may have (for example, `cn` and `commonName`),
    what sort of values an attribute may contain (numbers, string, DNs, and so on),
    what rules to use when trying to match values, and whether it may have more than
    one value.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性类型定义**：属性类型定义定义一个属性，包括该属性可能拥有的名称（例如，`cn`和`commonName`）、属性可能包含的值类型（数字、字符串、DN等）、匹配值时使用的规则，以及该属性是否可以有多个值。'
- en: Any given attribute may require that its value or values be composed of certain
    characters or data types. For example, the `description` attribute allows long
    strings of characters, which makes it possible to include a sentence or two of
    information as a value to a description field.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个属性可能要求其值或多个值由特定的字符或数据类型组成。例如，`description`属性允许长字符串字符，这使得可以将一句或两句信息作为描述字段的值。
- en: '**Object class definition**: An object class definition specifies the name
    of the object class, what attributes it must have, what attributes it may have,
    and what kind of object it is.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象类定义**：对象类定义指定对象类的名称、必须拥有的属性、可拥有的属性以及它是何种类型的对象。'
- en: 'We will look at each of these in turn. To start, let''s take another look at
    one of the schemas introduced in Chapter 3\. Here is a graphical representation
    of the `person` object class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一查看这些内容。首先，回顾一下在第3章中介绍的一个架构。以下是`person`对象类的图示：
- en: '![Object Classes and Attributes](img/1021_06_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![对象类和属性](img/1021_06_01.jpg)'
- en: 'The `person` object class has two required attributes (`cn` and `sn`) and four
    more attributes that are allowed, but not required: `userPassword`, `telephoneNumber`,
    `seeAlso`, and `description`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`person`对象类有两个必需的属性（`cn`和`sn`），以及四个允许的但非必需的属性：`userPassword`、`telephoneNumber`、`seeAlso`和`description`。'
- en: 'A new record that is of object class `person` (and has no other object classes)
    might look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的`person`对象类记录（且没有其他对象类）可能如下所示：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This record contains all, and only, the attributes in the `person` object class.
    Attempting to add a different attribute type not mentioned in the schema would
    lead to an error. Similarly, trying to remove all values for the `cn` or `sn`
    attributes would also lead to an error since their presence is required.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该记录包含`person`对象类中的所有属性，并且仅包含这些属性。尝试添加架构中未提到的其他属性类型会导致错误。同样，试图删除`cn`或`sn`属性的所有值也会导致错误，因为这些属性是必需的。
- en: But how does OpenLDAP know which attributes are required and which are allowed?
    This information is stored in the schema definition for the `person` object class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，OpenLDAP是如何知道哪些属性是必需的，哪些是允许的呢？这些信息存储在`person`对象类的架构定义中。
- en: Object Class Definitions
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类定义
- en: 'The schema definition is stored in the `core.schema` (and also in `core.ldif`)
    file at `/etc/ldap/schema` (or `/usr/local/etc/openldap/schema` if you compiled
    from source). Have a look at this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 架构定义存储在`core.schema`（以及`core.ldif`）文件中，路径为`/etc/ldap/schema`（如果从源代码编译，则为`/usr/local/etc/openldap/schema`）。请查看以下内容：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple object class definition. It begins with a descriptor, `objectclass`,
    which tells the schema interpreter what type of definition is being made. The
    rest of the definition is enclosed in parentheses. Extra whitespace characters,
    including line breaks, are generally ignored (unless enclosed in a quoted string),
    but remember that
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的对象类定义。它以描述符`objectclass`开头，告诉模式解释器正在创建什么类型的定义。其余部分被圆括号括起来。额外的空白字符，包括换行符，通常会被忽略（除非被引用的字符串包含其中），但请记住
- en: since `objectclass` is a directive in the `slapd.conf` file format, every line
    other than the first must start with a whitespace character.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`objectclass`是`slapd.conf`文件格式中的指令，因此除了第一行外，每一行必须以空白字符开头。
- en: 'The first field within the definition is the numeric identifier for the object
    class: `2.5.6.6`. This unique identifier is called an **Object IDentifier** (**OID**).
    Every schema definition has a unique OID that distinguishes that definition from
    any other definition in the world. Because this OID is supposed to be globally
    unique there is an official procedure for giving a definition a unique identifier.
    This will be described later in the chapter. For now it is sufficient to note
    that these OIDs must be universally unique.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的第一个字段是对象类的数字标识符：`2.5.6.6`。这个唯一标识符称为**对象标识符**（**OID**）。每个模式定义都有一个唯一的OID，它将该定义与世界上任何其他定义区分开来。因为这个OID应是全球唯一的，所以为定义指定唯一标识符有一个官方程序。稍后会在章节中描述这一点。现在，值得注意的是，这些OID必须是全局唯一的。
- en: Any LDAP application may refer to a definition by its OID. Object classes, attributes,
    matching rules, and many other LDAP entities have OIDs.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任何LDAP应用程序都可以通过OID引用定义。对象类、属性、匹配规则以及许多其他LDAP实体都有OID。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Root DSE record is a good example of how LDAP clients can learn important
    information about a server's capabilities based on the OIDs that the server presents
    to the client. See [Appendix C](apc.html "Appendix C. Useful LDAP Commands") for
    an example.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 根DSE记录是LDAP客户端如何根据服务器提供给客户端的OID了解服务器能力的一个好例子。请参阅[附录C](apc.html "附录C. 有用的LDAP命令")中的示例。
- en: 'The second field in the definition is the `NAME` field. While an OID is easily
    used by a computer, it is not so easily used by humans. So, in addition to an
    OID, server-unique names (in character strings) may be specified. The above object
    class only has one name: `person`. Multiple names can be given to a single object
    class, but usually a single one will suffice.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的第二个字段是`NAME`字段。虽然OID易于计算机使用，但人类并不容易理解它。因此，除了OID外，还可以指定服务器唯一的名称（以字符字符串形式）。上面的对象类只有一个名称：`person`。一个对象类可以有多个名称，但通常一个名称就足够了。
- en: 'In a schema definition, the string names should always be enclosed in single
    quotation marks. In a list of string values, each value must be enclosed in single
    quotes and the entire list must be enclosed in parentheses. For example, if the
    person definition specified two names, `person` and `humanBeing`, the `NAME` field
    would look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式定义中，字符串名称应始终用单引号括起来。在字符串值的列表中，每个值必须用单引号括起，并且整个列表必须用圆括号括起来。例如，如果人员定义指定了两个名称，`person`和`humanBeing`，则`NAME`字段应如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note also that spaces are not allowed in the values of the `NAME` field, so
    `'human` `being'` would be an illegal name.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，`NAME`字段的值中不允许有空格，因此`'human` `being'`将是一个非法名称。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In attribute definitions, it is more common to give attributes a long name and
    an abbreviated name. For example, `cn` and `commonName` are both names for the
    attribute with OID `2.5.4.3`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性定义中，通常会给属性指定一个长名称和一个简称。例如，`cn`和`commonName`都是属性`2.5.4.3`的名称。
- en: Most of the time object classes and attributes are referred to by the values
    in the `NAME` field rather than by OID.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，对象类和属性是通过`NAME`字段中的值来引用，而不是通过OID。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'By convention, names that consist of multiple words are concatenated by capitalizing
    the first letter of each word after the first. For example, `commonName` is composed
    of two words: `common` and `name`. Only the second word is capitalized. Underscores,
    dashes, and other special characters are typically not used to concatenate words.
    Thus, you should not use names like `common_name` or `common-name`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，由多个单词组成的名称通过大写每个单词的首字母来连接，首个单词除外。例如，`commonName`由两个单词组成：`common`和`name`，只有第二个单词的首字母大写。通常不会使用下划线、连字符或其他特殊字符来连接单词。因此，您不应使用像`common_name`或`common-name`这样的名称。
- en: The `DESC` field is a brief description of what this schema definition is to
    be used for. In this case the description field refers to an RFC (RFC 4519) that
    gives a detailed explanation of the object class. Of course it is not necessary
    to create an RFC to formally define your schemas, though if you plan on distributing
    the schema widely writing an RFC is a good idea.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`DESC`字段是对该模式定义用途的简要描述。在此情况下，描述字段指的是RFC（RFC 4519），该RFC详细解释了对象类。当然，并不需要为正式定义模式创建RFC，但如果计划广泛分发该模式，编写RFC是一个好主意。'
- en: The next field, `SUP`, which is short for 'superior,' indicates what the parent
    object class of this object class is. The parent of the `person` object class
    is the object class called `top`. Object classes, like directory information trees,
    are organized in hierarchies. The `top` object class is at the top of the object
    class hierarchy. The `STRUCTURAL` keyword also pertains to how this schema definition
    fits into the schema hierarchy. We will discuss schema hierarchies in the next
    part.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的字段是`SUP`，即“上级”的缩写，指示该对象类的父对象类是什么。`person`对象类的父对象类是名为`top`的对象类。对象类像目录信息树一样按层次结构组织，`top`对象类位于对象类层次结构的顶端。`STRUCTURAL`关键字也与该模式定义如何适应模式层次结构相关。我们将在下一部分讨论模式层次结构。
- en: The last two fields are less mysterious. They define which attributes a `person`
    object must (`MUST`) contain, and which attributes an object may (`MAY`) contain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个字段比较简单。它们定义了`person`对象必须（`MUST`）包含的属性，以及该对象可以（`MAY`）包含的属性。
- en: 'The syntax for the `MUST` and `MAY` fields is straightforward. Each description
    takes a list of attributes:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`MUST`和`MAY`字段的语法很简单。每个描述都包含一组属性：'
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The list of attribute values (designated either by OID or by an attribute name)
    is enclosed in parentheses. Values are separated with the dollar sign (`$`). The
    example above indicates that the four values, `userPassword`, `telephoneNumber`,
    `seeAlso`, and `description`, are all attributes that a person object is allowed
    to have.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值的列表（可以通过OID或属性名称指定）被括在圆括号内。值之间用美元符号（`$`）分隔。上面的例子表示，`userPassword`、`telephoneNumber`、`seeAlso`和`description`四个值是一个人对象可以具有的属性。
- en: An attribute should be specified in only one of the two lists. There is no need
    to put an attribute in both a `MAY` and a `MUST` list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 属性应该仅在两个列表中的一个中指定。无需将一个属性同时放入`MAY`和`MUST`列表。
- en: 'Of course, the names can be replaced with OIDs instead. Thus, the following
    two lines are equivalent:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，名称也可以用OID替代。因此，以下两行是等价的：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: and
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The OID for the `cn` attribute is `2.5.4.3`, and either identifier will work.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`cn`属性的OID是`2.5.4.3`，无论使用哪个标识符都可以。'
- en: There are a few fields that may be present in an object class definition but
    which are not present in the previous code. The first is the `OBSOLETE` keyword,
    which appears after the `DESC` field. This is used to designate an object class
    as obsolete but still (temporarily) supported.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类定义中可能包含一些字段，但这些字段在前面的代码中没有出现。第一个是`OBSOLETE`关键字，它出现在`DESC`字段之后。这个关键字用于标记一个对象类已经过时，但仍然（暂时）支持。
- en: The second is the extensions section, which is used for providing implementation-specific
    extensions to a schema. At the end of the schema one or more extensions may be
    specified. An extension is a keyword followed by a list enclosed in parentheses.
    By default, none of the schemas included in OpenLDAP's `schema/` directory have
    any extensions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是扩展部分，用于为模式提供特定于实现的扩展。在模式的末尾可以指定一个或多个扩展。扩展是一个关键字，后跟括号中的列表。默认情况下，OpenLDAP的`schema/`目录中包含的所有模式都没有扩展。
- en: 'In summary then, an object class definition begins with the `objectclasstype`
    directive, and can contain the following fields:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，对象类定义以`objectclasstype`指令开始，可以包含以下字段：
- en: 'A unique OID to identify this object class (example: `2.5.6.6`).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个唯一的OID，用于标识该对象类（例如：`2.5.6.6`）。
- en: A `NAME` field with a unique name (`NAME` `'person'`).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`NAME`字段，带有一个唯一的名称（`NAME` `'person'`）。
- en: A `DESC` field with a brief description of the purpose of the object class (`DESC`
    `'RFC4519:` `a` `person'`).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`DESC`字段，用于简要描述该对象类的目的（`DESC` `'RFC4519:` `a` `person'`）。
- en: Optionally, it may contain an `OBSOLETE` tag if the class is obsolete and should
    not be used.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该类已经过时并不应再使用，可以选择性地包含`OBSOLETE`标签。
- en: 'A `SUP` line, indicating what object class is the parent (superior) of this
    one. Also, this line should specify the type of object class (`STRUCTURAL`, `ABSTRACT`,
    or `AUXILLIARY`). Example: `SUP` `top` `STRUCTURAL`. Abstract classes do not have
    superiors. When defining an abstract class `SUP` can be omitted.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUP`行表示此对象类的父类（上级）。此外，该行应指定对象类的类型（`STRUCTURAL`、`ABSTRACT`或`AUXILLIARY`）。例如：`SUP`
    `top` `STRUCTURAL`。抽象类没有上级。在定义抽象类时，可以省略`SUP`。'
- en: 'A `MUST` field with a list of attributes that must be specified for an instance
    of this object class. Example: `MUST` `(` `sn` `$` `cn` `)`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUST`字段列出必须为该对象类实例指定的属性。例如：`MUST` `(` `sn` `$` `cn` `)`。'
- en: 'A `MAY` field with a list of attributes that can optionally be added to records
    of this object class. Example: `MAY` `(` `userPassword` `$` `telephoneNumber`
    `$` `seeAlso` `$` `description` `)`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAY`字段列出可以选择性地添加到此对象类记录中的属性。例如：`MAY` `(` `userPassword` `$` `telephoneNumber`
    `$` `seeAlso` `$` `description` `)`。'
- en: One or more extensions.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个扩展。
- en: Object class definitions are an important part of schemas and we will look back
    at these concepts several times in this chapter. After covering other definition
    types, we will take a detailed look at the object class hierarchy. As we do that
    the role of the `SUP` line will become clearer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类定义是模式的重要部分，我们将在本章中多次回顾这些概念。在涵盖其他定义类型后，我们将详细研究对象类层次结构。在这个过程中，`SUP`行的作用将变得更加明确。
- en: Further on we will look at some specific object classes and we will also write
    our own custom object class. But before we move on to those things we will look
    at the other schema definitions. Next, we will look at attribute definitions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将查看一些特定的对象类，并编写我们自己的自定义对象类。但在我们继续这些内容之前，我们将查看其他模式定义。接下来，我们将查看属性定义。
- en: Attribute Definitions
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性定义
- en: The `person` object class that we examined now can have six different attributes—the
    two necessary `sn` and `cn` attributes, and the optional `userPassword`, `telephoneNumber`,
    `seeAlso`, and `description` attributes. Just as the object class was defined
    in the schema, so each attribute is also defined. The syntax for attribute definitions
    is similar though the fields allowed in the definition are different and more
    numerous.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在检查的`person`对象类可以拥有六个不同的属性——两个必要的`sn`和`cn`属性，以及可选的`userPassword`、`telephoneNumber`、`seeAlso`和`description`属性。正如对象类在模式中被定义一样，每个属性也都有定义。属性定义的语法类似，但定义中允许的字段不同且更多。
- en: 'The schema definition for the `telephoneNumber` attribute is a good example
    of a basic attribute definition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`telephoneNumber`属性的模式定义是一个基本属性定义的好例子：'
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The attribute definition begins with an `attributetype` directive. The rest
    of the definition is enclosed in parentheses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义以`attributetype`指令开始。定义的其余部分被括号括起来。
- en: The first field in the definition is the unique OID for this attribute. As with
    all OIDs, this identifier must be globally unique. The OID `2.5.4.20` should only
    be used to refer to a `telephoneNumber` attribute. Later in this chapter, in the
    section *Getting* *an* *OID*, we will discuss getting and using a base OID.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的第一个字段是此属性的唯一OID。与所有OID一样，这个标识符必须是全局唯一的。OID `2.5.4.20` 应仅用于表示`telephoneNumber`属性。本章稍后，在*获取*
    *OID*一节中，我们将讨论如何获取和使用基本OID。
- en: After the OID comes the `NAME` field that associates one or more names with
    the attribute.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: OID之后是`NAME`字段，用于将一个或多个名称与属性关联。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The names given in the `NAME` field are usually called *attribute* *descriptions*
    (see the discussion of the search operation in Chapter 3). This term is confusing
    when talking about schema definitions because the attribute schema definition
    has a description field, and that field is not the attribute description.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NAME`字段中给出的名称通常被称为*属性* *描述*（请参见第3章中对搜索操作的讨论）。在讨论模式定义时，这个术语可能会令人混淆，因为属性模式定义中有一个描述字段，而该字段并不是属性描述。
- en: 'It is not uncommon for attributes to have two names—a long name (such as `commonName`
    or `surname`) and an abbreviated name (`cn` or `sn` respectively). When an attribute
    has multiple names, the list of names should be enclosed in parentheses. As an
    example, consider the `NAME` field for the `fax` attribute:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 属性通常有两个名称——一个长名称（例如`commonName`或`surname`）和一个缩写名称（分别为`cn`或`sn`）。当一个属性有多个名称时，名称列表应放在括号中。例如，考虑`fax`属性的`NAME`字段：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the syntax of the highlighted line. Each name in the list of names is enclosed
    in single quotes (`'`) and the entire list is enclosed in parentheses.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意高亮行的语法。列表中的每个名称都用单引号（`'`）括起来，并且整个列表被括号包围。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SLAPD will refer to attributes by the first name. Thus, if you search for the
    `fax` attribute SLAPD will return the matching attributes as `facsimileTelephoneNumber`
    not as `fax`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD将通过第一个名称引用属性。因此，如果你搜索`fax`属性，SLAPD会返回匹配的属性`facsimileTelephoneNumber`，而不是`fax`。
- en: The `DESC` field provides a brief description of the purpose of the attribute.
    In the `telephoneNumber` attribute definition, the value of this field is `'RFC2256:`
    `Telephone` `Number'`, indicating that the attribute is defined in RFC 2256.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`DESC`字段提供了属性目的的简要描述。在`telephoneNumber`属性定义中，该字段的值为`''RFC2256:` `Telephone`
    `Number''`，表示该属性在RFC 2256中有定义。'
- en: One important aspect of defining an attribute is specifying how an application
    should test two attribute values to see if they match. Do `TEST` and `test` match?
    In some cases we might want them to, while in others we might not. Does `t*st`
    match `test`? Again, in some cases, this is desirable while in others it is not.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义属性时，一个重要的方面是指定应用程序应如何测试两个属性值是否匹配。`TEST`和`test`匹配吗？在某些情况下我们可能希望它们匹配，而在其他情况下则不希望它们匹配。`t*st`是否与`test`匹配？同样，在某些情况下，这是可以接受的，而在其他情况下则不是。
- en: 'We can determine, in the attribute definition, which matching rules should
    be used to test whether one value matches another. When we discussed the search
    operation in Chapter 3 we saw four different comparison operators that could be
    used in search filters:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在属性定义中确定应使用哪些匹配规则来测试一个值是否匹配另一个值。当我们在第3章讨论搜索操作时，我们看到可以在搜索筛选器中使用四种不同的比较运算符：
- en: The equality operator (`=`)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等运算符（`=`）
- en: The approximation operator (`~=`)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近似运算符（`~=`）
- en: The greater-than-or-equal-to operator (`>=`)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于或等于运算符（`>=`）
- en: 'The less-than-or-equal-to operator: (`<=`)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于或等于运算符：（`<=`）
- en: In addition to these we looked at using regular expression characters, such
    as the asterisk (`*`), to match portions, or substrings, of an attribute value.
    The behavior of each of these is determined, to a large degree, by the matching
    rules in the attribute definition.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还考虑了使用正则表达式字符，如星号（`*`），来匹配属性值的部分或子字符串。这些行为在很大程度上由属性定义中的匹配规则决定。
- en: 'When the LDAP server processes a comparison (during operations like binding,
    comparing, and searching) it uses the schema to determine how to handle these
    comparisons. The schema specifies which matching rules should be used. There are
    three different sorts of matching rules that can be assigned in a schema:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当LDAP服务器处理比较操作（如绑定、比较和搜索操作）时，它会使用模式来确定如何处理这些比较。模式指定应使用哪些匹配规则。可以在模式中分配三种不同类型的匹配规则：
- en: The equality rule, EQUALITY
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等性规则，EQUALITY
- en: The ordering rule, ORDERING
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序规则，ORDERING
- en: The substring matching rule, SUBSTRING
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子字符串匹配规则，SUBSTRING
- en: 'An attribute schema may specify rules for one, two, or all three of these.
    The value of each can be either the OID or the name of a matching rule. In the
    `telephoneNumber` schema, `EQUALITY` and `SUBSTRING` are used:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 属性模式可以为这三种规则之一、两种或三种都指定规则。每个规则的值可以是OID或匹配规则的名称。在`telephoneNumber`模式中，使用了`EQUALITY`和`SUBSTRING`规则：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When an equality test for a telephone number is requested, such as the evaluation
    of the filter `(telephoneNumber=+1` `234` `567` `8901)`, the `telephoneNumberMatch`
    rule is used. Note that the plus sign (`+`) is part of the telephone number, not
    part of the operator. If the filter includes a wild-card match, such as `(telephoneNumber=+1`
    `234` `567*)`, then the `telephoneNumberSubstringsMatch` rule is used instead.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求对电话号码进行相等性测试时，例如评估筛选器`(telephoneNumber=+1` `234` `567` `8901)`，会使用`telephoneNumberMatch`规则。请注意，`+`符号是电话号码的一部分，而不是运算符的一部分。如果筛选器包含通配符匹配，例如`(telephoneNumber=+1`
    `234` `567*)`，则会使用`telephoneNumberSubstringsMatch`规则。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With no `ORDERING` rule defined, SLAPD will not process matching tests for `>=`
    or `<=` operators. Any comparison will return false.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义`ORDERING`规则，SLAPD将不会处理`>=`或`<=`运算符的匹配测试。任何比较都会返回假。
- en: 'How do these two matching rules perform? Let''s look at an example. When we
    defined the user with UID `matt`, we assigned that user a telephone number. Here,
    we will search for that entry, requesting only the `telephoneNumber` attribute:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种匹配规则如何执行呢？我们来看一个例子。当我们定义UID为`matt`的用户时，我们为该用户分配了电话号码。这里，我们将搜索该条目，只请求`telephoneNumber`属性：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the search result is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果如下：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `telephoneNumber` attribute has the value `+1` `555` `555` `4321`. Now
    let''s perform a search using the telephone number:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`telephoneNumber`属性的值为`+1 555 555 4321`。现在让我们使用电话号码进行搜索：'
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And the search result is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索结果如下：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As expected a search using the exact phone number returned a result. This looks
    no different from what we would expect a string matching rule to do. Using the
    special `telephoneNumberMatch` rule in the schema has some advantages though.
    When using this matching rule, SLAPD will ignore certain telephone number formatting
    characters. Here''s an example using a substring search:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，使用准确的电话号码进行搜索返回了一个结果。这看起来与我们预期的字符串匹配规则没有什么不同。不过，使用架构中的特殊`telephoneNumberMatch`规则有一些优势。当使用此匹配规则时，SLAPD会忽略某些电话号码格式化字符。下面是一个使用子字符串搜索的示例：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the result:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The filter in this example uses dashes (`-`) where the previous filter used
    spaces. Using the `telphoneNumberSubstringMatch` rule, SLAPD ignored the dashes.
    With the `telephoneNumberMatch` and `telephoneNumberSubstringMatch` rules, the
    numbers `+15555554321`, `+1` `555` `555` `4321`, `1-5-5-55554-3-2-1`, and `+1`
    `555-555-4321` are all treated as identical matches.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的过滤器使用了破折号（`-`），而之前的过滤器使用了空格。使用`telephoneNumberSubstringMatch`规则时，SLAPD忽略了破折号。使用`telephoneNumberMatch`和`telephoneNumberSubstringMatch`规则时，`+15555554321`、`+1
    555 555 4321`、`1-5-5-55554-3-2-1`和`+1 555-555-4321`这些号码都被视为相同的匹配项。
- en: This illustrates the virtue of being able to specify matching rules in the schema.
    For attributes such as `cn`, `sn`, or `mail` (email address), we certainly wouldn't
    want dashes to be treated the same as white space characters. We wouldn't want
    `Dan` `Forth` to match `Danforth`. But it is certainly a desirable feature when
    matching phone numbers. The LDAP answer to this problem is to assign matching
    rules fitting to the type of information stored in the attribute.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了能够在架构中指定匹配规则的优点。对于`cn`、`sn`或`mail`（电子邮件地址）等属性，我们当然不希望破折号被当作空格字符来处理。我们也不希望`Dan`和`Forth`与`Danforth`匹配。但是，当匹配电话号码时，这显然是一个理想的功能。LDAP对此问题的解决方案是为存储在属性中的信息类型分配适当的匹配规则。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Other attributes, like `homePhone`, `pagerTelephoneNumber`, and `mobileTelephoneNumber`
    (all defined in `cosine.schema`) all use the `telephoneNumberMatch` and `telelphoneNumberSubstringMatch`
    matching rules too. Since they all share the same format there is no need to assign
    each a different specialized matching rule.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性，如`homePhone`、`pagerTelephoneNumber`和`mobileTelephoneNumber`（都在`cosine.schema`中定义），也都使用`telephoneNumberMatch`和`telephoneNumberSubstringMatch`匹配规则。由于它们共享相同的格式，因此无需为每个属性分配不同的专用匹配规则。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Matching Rules and Indexes**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**匹配规则和索引**'
- en: Some backends, such as BDB and HDB, support indexes (using the `index` directive
    in `slapd.conf`). The index supported is determined by the matching rules defined
    for an attribute. For example, an attribute with an equality matching rule can
    have an equality (`eq`) index. Likewise, one with a substring matching rule supports
    `sub` indexes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一些后端，如BDB和HDB，支持索引（使用`slapd.conf`中的`index`指令）。支持的索引由为属性定义的匹配规则决定。例如，具有相等匹配规则的属性可以拥有相等（`eq`）索引。同样，具有子字符串匹配规则的属性支持`sub`索引。
- en: The last field in the `telephoneNumber` matching scheme is the `SYNTAX` field.
    This relates to the type and structure of the data stored in values for `telephoneNumber`
    attributes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`telephoneNumber`匹配方案中的最后一个字段是`SYNTAX`字段。这与存储在`telephoneNumber`属性值中的数据类型和结构有关。'
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The value of the `SYNTAX` parameter has two parts. The first is the OID (or
    the name) of the LDAP syntax, and the second, set off in curly braces (`{` and
    `}`) is the maximum length (usually the number of characters) for the field. The
    length specifier is optional, and the server is not obligated to enforce the maximum
    length.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYNTAX`参数的值有两个部分。第一个是LDAP语法的OID（或名称），第二部分是用大括号（`{`和`}`）括起来的最大长度（通常是字符数）。长度说明符是可选的，服务器没有义务强制执行最大长度。'
- en: The OID mentioned earlier, `1.3.6.1.4.1.1466.115.121.1.50`, is the telephone
    number syntax. This indicates that attribute values for instances of the `telephoneNumber`
    attribute are to contain the characters (integers, dashes, spaces, and so on)
    that a phone number would require. SLAPD will reject attempts to add phone numbers
    that contain letters and other special characters. Later in this chapter, in the
    *Creating* *a* *Schema* part, we will look at the list of common LDAP syntaxes
    that OpenLDAP supports.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的OID，`1.3.6.1.4.1.1466.115.121.1.50`，是电话号语法。这表明，`telephoneNumber`属性的实例的属性值应包含电话号码所需的字符（整数、破折号、空格等）。SLAPD会拒绝包含字母和其他特殊字符的电话号码。稍后在本章的*创建*
    *模式*部分，我们将查看OpenLDAP支持的常见LDAP语法列表。
- en: 'As far as complexity goes the `telephoneNumber` attribute is about average.
    However, many attribute definitions are much shorter, taking advantage of the
    fields set in similar attributes. Thus, there are many attributes that, because
    they inherit most of their features from their superior (parent) attribute, have
    only an OID, a `NAME` field, and a `DESC` field. The schema definition for the
    ever popular `cn` attribute looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就复杂性而言，`telephoneNumber`属性属于中等水平。然而，许多属性定义要短得多，利用了在类似属性中设置的字段。因此，许多属性由于从其上级（父级）属性继承了大部分特性，仅具有OID、`NAME`字段和`DESC`字段。广受欢迎的`cn`属性的模式定义如下：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, the `SUP` name field indicates that the `name` attribute is the
    parent of the `cn` attribute. Attributes, like object classes, can be organized
    hierarchically. A superior attribute is the parent or prototype for this attribute
    and certain properties, if left unspecified in the schema definition, are inherited
    from the superior. Syntax and matching rules, for example, can be inherited from
    a parent.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`SUP`名称字段表明`name`属性是`cn`属性的父属性。属性和对象类一样，可以按层次结构组织。上级属性是该属性的父级或原型，如果在模式定义中未指定某些属性，它们将从上级继承。例如，语法和匹配规则可以从父级继承。
- en: In the previous example no matching rules and no LDAP syntax were specified.
    Therefore, the `cn` attribute type inherits these values from its superior. The
    `name` attribute uses the `caseIgnoreMatch` `EQUALITY` matching rule and the `caseIgnoreSubstringMatch`
    `SUBSTR` rule, and uses the Directory String LDAP syntax (`1.3.6.1.4.1.1466.115.121.1.15`).
    A directory string is a UTF-8 encoded string intended to store text.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中没有指定匹配规则和LDAP语法。因此，`cn`属性类型从其上级继承了这些值。`name`属性使用`caseIgnoreMatch` `EQUALITY`匹配规则和`caseIgnoreSubstringMatch`
    `SUBSTR`规则，并使用目录字符串LDAP语法（`1.3.6.1.4.1.1466.115.121.1.15`）。目录字符串是一个UTF-8编码的字符串，用于存储文本。
- en: There are a handful of other fields that the previous examples do not make use
    of. These are `OBSOLETE`, `SINGLE-VALUE`, `COLLECTIVE`, `NO-USER-MODIFICATION`,
    `USAGE`, and the extension area. Let's briefly look at those.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例中没有涉及的一些其他字段包括`OBSOLETE`、`SINGLE-VALUE`、`COLLECTIVE`、`NO-USER-MODIFICATION`、`USAGE`和扩展区。我们来简要看一下这些字段。
- en: The `OBSOLETE` flag, which usually appears after the `DESC` field, plays the
    same role in attribute definitions as it does in object class definitions. It
    labels an attribute obsolete. While obsolete attributes are still supported and
    can be used for records in the directory information tree, they are to be treated
    as deprecated, subject to removal in future versions of the schema or software.
    `OBSOLETE` takes no parameters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`OBSOLETE`标志通常出现在`DESC`字段后，在属性定义中与在对象类定义中起到相同的作用。它标记一个属性为过时。虽然过时的属性仍然受到支持，并且可以用于目录信息树中的记录，但它们应该被视为已弃用，并可能在未来的模式或软件版本中被移除。`OBSOLETE`不接受任何参数。'
- en: The `SINGLE-VALUE` flag indicates that the defined attribute can only have one
    attribute value. Typically, an attribute can have an arbitrary number of values.
    But any attribute whose schema includes the `SINGLE-VALUE` flag can have no more
    than one. The domain component (`dc`) attribute that we looked at in Chapters
    3 and 4 is an example of this. An object that has a `dc` attribute can only assign
    one value to that attribute. `SINGLE-VALUE` takes no parameters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`SINGLE-VALUE`标志表示定义的属性只能有一个属性值。通常，一个属性可以有任意数量的值。但任何包含`SINGLE-VALUE`标志的属性，其值不能超过一个。我们在第3章和第4章中看到的域组件（`dc`）属性就是一个例子。拥有`dc`属性的对象只能为该属性分配一个值。`SINGLE-VALUE`不接受任何参数。'
- en: The `COLLECTIVE` flag indicates that this attribute is a collective attribute.
    Entries can be grouped, with collective attributes, into an **entry collection**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`COLLECTIVE` 标志表示该属性是一个集合属性。条目可以与集合属性一起分组，形成 **条目集合**。'
- en: Collectives are implemented in OpenLDAP via the `collect` overlay, which is
    not compiled or installed by default, though it can be found in the `servers/slapd/overlays`
    directory of the source code. The schemas necessary for collective support are
    also not included by default in the OpenLDAP distribution, and must be copied
    from another source (such as RFC 3671).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 集合在 OpenLDAP 中通过 `collect` 覆盖实现，该覆盖默认并未编译或安装，但可以在源代码的 `servers/slapd/overlays`
    目录中找到。支持集合的模式在 OpenLDAP 分发版中也没有默认包含，必须从其他来源（如 RFC 3671）复制。
- en: 'Here''s a rough idea of how entry collections work:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是条目集合如何工作的粗略示意：
- en: One record is the collection record, and must use the `collectiveAttributeSubentry`
    object class. This becomes the authority for that collective attribute. All other
    subordinate records then inherit the attribute (and its value) and the attribute
    is visible (though read-only) as an attribute of each of these records. For more
    information on collectives see RFC 3671 ([http://www.ietf.org/rfc/rfc3671.txt](http://www.ietf.org/rfc/rfc3671.txt)).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个记录是集合记录，必须使用 `collectiveAttributeSubentry` 对象类。这将成为该集合属性的权威。所有其他下级记录都继承该属性（及其值），并且该属性作为每个记录的属性可见（但为只读）。有关集合的更多信息，请参见
    RFC 3671（[http://www.ietf.org/rfc/rfc3671.txt](http://www.ietf.org/rfc/rfc3671.txt)）。
- en: The `NO-USER-MODIFICATION` flag is used to indicate that the attribute is an
    operational attribute (used by SLAPD or an overlay), and cannot be modified by
    an LDAP client. This is not usually used in user-defined schemas. Use it only
    when writing a custom overlay that will make use of its own operational attributes.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NO-USER-MODIFICATION` 标志用于表示该属性是一个操作性属性（由 SLAPD 或覆盖使用），不能被 LDAP 客户端修改。这通常不用于用户定义的模式。只有在编写自定义覆盖并使用其操作属性时，才使用该标志。'
- en: The `USAGE` field provides SLAPD with information about what will use the attribute.
    There are four possible values. The first three, `directoryOperation`, `distributedOperation`,
    and `dSAOperation`, all indicate that SLAPD itself uses the attribute. The last,
    `userApplication`, is the default and it indicates that the attribute is primarily
    intended to be used by client applications. Since most schemas are intended for
    client application use, the default is usually what is desired and the `USAGE`
    field is rarely used.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`USAGE` 字段提供 SLAPD 该属性的使用信息。该字段有四个可能的值。前三个值 `directoryOperation`、`distributedOperation`
    和 `dSAOperation` 表示 SLAPD 自身使用该属性。最后一个值 `userApplication` 是默认值，表示该属性主要用于客户端应用程序。由于大多数模式是为客户端应用程序设计的，因此默认值通常是所需的，`USAGE`
    字段很少使用。'
- en: Finally, `attributetype` definitions can also use extensions, though there are
    no extensions used in the main schemas included in OpenLDAP. The syntax for extensions
    is the same for attribute types as it is for object class definitions.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`attributetype` 定义还可以使用扩展，尽管在 OpenLDAP 中包含的主要模式中没有使用扩展。扩展的语法对于属性类型与对象类定义相同。
- en: 'In summary, an attribute schema definition begins with the `attributetype`
    directive which is followed by a schema definition enclosed in parentheses. The
    following fields are allowed in attribute definitions:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，属性模式定义以 `attributetype` 指令开始，后跟一个括号括起来的模式定义。属性定义中允许包含以下字段：
- en: 'A unique OID number, which is required. Example: `2.5.4.15`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个唯一的 OID 编号，这是必需的。例如：`2.5.4.15`。
- en: 'A `NAME` field, with one or more names for the attribute. Example: `NAME` `''businessCategory''`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `NAME` 字段，包含该属性的一个或多个名称。例如：`NAME` `'businessCategory'`。
- en: 'A `DESC` field containing a description of the attribute type. Example: `DESC`
    `''RFC2256:` `business` `category''`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `DESC` 字段，包含该属性类型的描述。例如：`DESC` `'RFC2256:` `business` `category'`。
- en: A `DEPRECATED` tag, if the attribute is deprecated.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性已弃用，则有一个 `DEPRECATED` 标签。
- en: 'A `SUP` field with the name or OID of the superior attribute type. Example:
    `SUP` `postalAddress`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `SUP` 字段，包含上级属性类型的名称或 OID。例如：`SUP` `postalAddress`。
- en: 'An `EQUALITY` matching rule OID or name. Example: `EQUALITY` `caseIgnoreMatch`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `EQUALITY` 匹配规则的 OID 或名称。例如：`EQUALITY` `caseIgnoreMatch`。
- en: An `ORDERING` matching rule OID or name.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `ORDERING` 匹配规则的 OID 或名称。
- en: 'A `SUBSTR` matching rule OID or name. Example: `SUBSTR` `caseIgnoreSubstringsMatch`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `SUBSTR` 匹配规则的 OID 或名称。例如：`SUBSTR` `caseIgnoreSubstringsMatch`。
- en: 'A `SYNTAX` field with an LDAP syntax OID, and an optional length. Example:
    `SYNTAX` `1.3.6.1.4.1.1466.115.121.1.15{128}`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有 LDAP 语法 OID 和可选长度的 `SYNTAX` 字段。示例：`SYNTAX` `1.3.6.1.4.1.1466.115.121.1.15{128}`。
- en: The `SINGLE-VALUE` flag, if the attribute can only have one value.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLE-VALUE` 标志，如果该属性只能有一个值。'
- en: The `COLLECTIVE` flag, if the attribute is a collective attribute.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COLLECTIVE` 标志，如果该属性是一个集合属性。'
- en: The `NO-USER-MODIFICATION` flag, if the attribute is an operational attribute
    that client applications should not be able to modify.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO-USER-MODIFICATION` 标志，如果该属性是一个操作性属性，客户端应用程序不应能够修改它。'
- en: The `USAGE` field, together with one of the four keywords (`userApplication`,
    `directoryOperation`, `distributedOperation`, or `dSAOperation`) used to indicate
    what the attribute is to be used for.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USAGE` 字段，与四个关键字中的一个一起使用（`userApplication`、`directoryOperation`、`distributedOperation`
    或 `dSAOperation`），用来指示该属性的用途。'
- en: Any extensions that the attribute definition requires.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性定义所需的任何扩展。
- en: At this point we have looked at both object class definitions and attribute
    definitions. When creating your own custom schemas it is most likely that these
    are the only two types of schema definitions that you will need to use.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经看过了对象类定义和属性定义。当创建自定义模式时，最可能需要使用的就是这两种类型的模式定义。
- en: We have discussed the basics of schemas and seen a few examples in the text.
    Later in this chapter we will look at some other specific examples. But if you
    want to take a look at more examples of attribute and object class schemas peruse
    the files in the schema directory for OpenLDAP (`/etc/ldap/schema` or `/usr/local/etc/openldap/schema`).
    The best place to start is with the `core.schema` schema, which defines the standard
    LDAPv3 schemas.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了模式的基础知识，并在文本中看了一些例子。在本章的后面部分，我们将查看一些其他具体的示例。如果你想查看更多属性和对象类模式的示例，可以浏览
    OpenLDAP 模式目录中的文件（`/etc/ldap/schema` 或 `/usr/local/etc/openldap/schema`）。最好的起点是
    `core.schema` 模式，它定义了标准的 LDAPv3 模式。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While reading `core.schema` you might notice that several very important object
    classes and attribute types are commented out. Why? Because they are included
    in the **system schema**, which is hard-coded into OpenLDAP. This schema is found
    in the OpenLDAP source code in `slapd/schema_prep.c`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读 `core.schema` 时，你可能会注意到一些非常重要的对象类和属性类型被注释掉了。为什么？因为它们包含在 **系统模式** 中，硬编码在
    OpenLDAP 中。这个模式可以在 OpenLDAP 源代码中的 `slapd/schema_prep.c` 找到。
- en: The `cosine.schema` file contains many other commonly used schemas and is also
    a good place to look. The `inetOrgPerson.schema` schema is a good example of what
    a user-defined schema file ought to look like. Or, for a shorter example of a
    user-defined schema, see `openldap.schema`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`cosine.schema` 文件包含了许多其他常用的模式，也是一个很好的参考地方。`inetOrgPerson.schema` 模式是一个很好的示例，展示了用户自定义模式文件的样子。或者，作为一个简短的用户自定义模式示例，可以查看
    `openldap.schema`。'
- en: While `attributetype` and `objectclass` are the two primary directives used
    in schema creation there are a few others which we will cover, albeit more briefly,
    in the next two sections.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `attributetype` 和 `objectclass` 是模式创建中使用的两个主要指令，但还有一些其他指令，我们将在接下来的两节中简要介绍。
- en: Object Identifier Definitions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象标识符定义
- en: The object identifier directive (`objectidentifier`) is an extension to the
    standard definition language. While it doesn't provide additional functionality
    to the schema language, it serves as a time-saving (and human-friendly) utility.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对象标识符指令（`objectidentifier`）是对标准定义语言的扩展。虽然它并没有为模式语言提供额外的功能，但它作为一个省时且人性化的工具，发挥着作用。
- en: 'The `objectidentifier` directive is used to assign a string alias to an OID.
    When SLAPD processes OID fields for `attributetype`, `objectclasstype`, and `ditcontentrule`
    directives, if it encounters a string instead of an OID, it will check to see
    if this string is an alias to an OID and, if so, it will use the value of the
    OID. The `telephoneNumber` schema we examined in the last section provides a good
    example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`objectidentifier` 指令用于为 OID 分配字符串别名。当 SLAPD 处理 `attributetype`、`objectclasstype`
    和 `ditcontentrule` 指令中的 OID 字段时，如果遇到的是字符串而不是 OID，它会检查该字符串是否是 OID 的别名，如果是，它将使用
    OID 的值。在上一节中我们检查的 `telephoneNumber` 模式就是一个很好的例子：'
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Instead of using the OID for the telephone number equality and substring matching
    rules (`1.3.6.1.4.1.1466.115.121.1.50` and `1.3.6.1.4.1.1466.115.121.1.58`, respectively),
    the schema refers to the names of the matching rules: `telephoneNumberMatch` and
    `telephoneNumberSubstringMatch`. This later form is much easier for humans to
    read.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 替代使用电话号平等和子串匹配规则的OID（分别是`1.3.6.1.4.1.1466.115.121.1.50`和`1.3.6.1.4.1.1466.115.121.1.58`），schema引用了匹配规则的名称：`telephoneNumberMatch`和`telephoneNumberSubstringMatch`。这种形式更容易让人类阅读。
- en: 'The `objectidentifier` directive makes it easy to define such aliases for OID
    numbers, in whole or in part. Here is a simple example of assigning a name to
    an OID:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`objectidentifier`指令使得为OID数字定义别名变得容易，可以是整个OID或部分OID。以下是为OID分配名称的简单示例：'
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using a directive like this at the top of a schema makes it possible to refer
    to the OID using the name `exampleComDemo` later.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在schema的顶部使用类似的指令使得后续可以通过`exampleComDemo`来引用OID。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The given OID is valid and is registered to the author. If you are developing
    your own LDAP schemas, you should register your own OID (see the *Getting* *an*
    *OID* section). While you are free to use this OID when recreating these examples,
    do not use it to write your own extensions. Otherwise, there will be no way to
    ensure that such OIDs are globally unique which defeats the purpose of the OID.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的OID是有效的，并且已经注册给作者。如果你正在开发自己的LDAP schema，你应该注册你自己的OID（请参见*获取OID*部分）。虽然你可以在重新创建这些示例时使用这个OID，但不要用它来编写你自己的扩展。否则，就无法确保这些OID在全球范围内的唯一性，这就违背了OID的目的。
- en: 'For example, we could create a schema like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建如下的schema：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that instead of using the OID number for the object, we used the `exampleComDemo`
    alias. But, generally, we would not assign one alias per object class. It would
    be more convenient to alias a common root OID and then append just the last part
    of the OID number. For example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用的是`exampleComDemo`别名，而不是使用该对象的OID号。但通常，我们不会为每个对象类分配一个别名。更方便的做法是别名化一个公共的根OID，然后仅附加OID号的最后一部分。例如：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example we used the `objectidentifier` directive to create an alias
    for the OID base that will be used for all of my object class definitions. Thus,
    when SLAPD encounters the name `exampleComOC`, it will expand it to `1.3.6.1.4.1.8254.1021.1`.
    The object class definition for `myPersonObjectClass` should have the OID `1.3.6.1.4.1.8254.1021.1.1`
    (note the extra `.1` at the end). Rather than writing out the entire number we
    use the `exampleComOC` alias and append a colon (`:`) and then the numeric suffix
    for the object class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`objectidentifier`指令为OID基础创建了一个别名，所有我的对象类定义将使用这个基础。因此，当SLAPD遇到名称`exampleComOC`时，它会将其展开为`1.3.6.1.4.1.8254.1021.1`。`myPersonObjectClass`的对象类定义应该具有OID
    `1.3.6.1.4.1.8254.1021.1.1`（注意末尾的额外`.1`）。我们使用`exampleComOC`别名，并附加一个冒号（`:`），然后加上对象类的数字后缀，而不是写出整个数字。
- en: When SLAPD encounters `exampleComOC:1` it will expand it to `1.3.6.1.4.1.8254.1021.1.1`.
    Likewise, if I were to create a second object class with the desired OID `1.3.6.1.4.1.8254.1021.1.2`,
    I could use `exampleComOC:2` instead of typing out the entire long OID.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当SLAPD遇到`exampleComOC:1`时，它会将其展开为`1.3.6.1.4.1.8254.1021.1.1`。同样，如果我创建第二个对象类并使用所需的OID
    `1.3.6.1.4.1.8254.1021.1.2`，我可以使用`exampleComOC:2`，而不必输入整个长的OID。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `objectidentifier` attribute can not only save typing, but reduce
    typos in an area particularly prone to typos (and with typos particularly difficult
    to spot).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objectidentifier`属性不仅可以减少打字量，还可以减少在容易出错的地方（且难以发现错误的地方）出现的拼写错误。
- en: For more examples of the `objectidentifier` directive, see `openldap.schema`
    in the schema directory for OpenLDAP.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`objectidentifier`指令的更多示例，请参阅OpenLDAP的schema目录中的`openldap.schema`文件。
- en: DIT Content Rules
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DIT内容规则
- en: The last schema directive we will look at is the `ditcontentrule` directive
    which is used for creating **DIT Content Rules**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个schema指令是`ditcontentrule`指令，它用于创建**DIT内容规则**。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*DIT* stands for Directory Information Tree. This abbreviation is a frequently
    used bit of LDAP parlance.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*DIT* 代表目录信息树（Directory Information Tree）。这是LDAP术语中一个常用的缩写。'
- en: A DIT content rule identifies a particular structural object class, and indicates
    which auxiliary object classes are allowed (or not allowed) to be included in
    entries that use that object class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: DIT内容规则标识特定的结构化对象类，并指示哪些辅助对象类可以（或不可以）包含在使用该对象类的条目中。
- en: 'For an example, let''s use a few of the object classes introduced in Chapter
    3\. In the *Anatomy* *of* *an* *LDIF* *File* section we created an entry representing
    a document. It implemented the `document` object class, whose schema (located
    in `cosine.schema`) looks like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用第3章中介绍的一些对象类。在《LDIF文件的结构》部分，我们创建了一个表示文档的条目。它实现了`document`对象类，其模式（位于`cosine.schema`中）如下所示：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is a structural object class. Also in Chapter 3, in the *Adding* *System*
    *Records* section we added the entry for `uid=authenticate,ou=System,dc=example,dc=com`.
    This entry implemented the `simpleSecurityObject` object class. Here is the schema
    for `simpleSecurityObject`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个结构对象类。同样在第3章中，在《添加系统记录》部分，我们为`uid=authenticate,ou=System,dc=example,dc=com`添加了条目。该条目实现了`simpleSecurityObject`对象类。这里是`simpleSecurityObject`的模式：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This object class is an auxiliary object class, meaning that it can be added
    to entries that already have a structural object class, the result being that
    the attributes of the auxiliary object class are now available for that entry.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象类是一个辅助对象类，意味着它可以添加到已经具有结构对象类的条目中，结果是该条目现在可以使用辅助对象类的属性。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more discussion on the different sorts of object classes and how they function,
    see the discussion in Chapter 3 and the section in this chapter called *The* *Object*
    *Class* *Hierarchy*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有关不同类型对象类及其功能的更多讨论，请参见第3章中的讨论以及本章中的《对象类层次结构》部分。
- en: 'According to default OpenLDAP settings, if we had an entry with the `document`
    structural object class, we could give this document a password (for binding to
    the directory) by adding `objectclass:` `simpleSecurityObject` to the record,
    and then adding a `userPassword` attribute. This would give us a record looking
    something like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 根据默认的OpenLDAP设置，如果我们有一个使用`document`结构对象类的条目，我们可以通过向记录中添加`objectclass:` `simpleSecurityObject`，然后添加`userPassword`属性，来为该文档设置密码（用于绑定到目录）。这样，我们就能得到一个类似这样的记录：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This entry is essentially a document that has the ability to log in! A client
    that used this record's DN and the correct password could log in as this document.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目本质上是一个能够登录的文档！一个使用此记录的DN和正确密码的客户端可以以该文档身份登录。
- en: Perhaps there are cases where this is desirable, but for the sake of this example,
    let us suppose that this is a configuration that we do not want to allow.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在某些情况下这是可取的，但为了这个示例，我们假设这是我们不想允许的配置。
- en: Normally, decisions about which entries have which object classes are left to
    external applications. But what if we wanted to make sure that no application
    could give `document` a `userPassword` attribute?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，关于哪些条目具有哪些对象类的决定是由外部应用程序来做的。但如果我们想确保没有应用程序能为`document`添加`userPassword`属性怎么办？
- en: 'The best method for solving this problem is to create a DIT content rule that
    disallows adding the `userPassword` attribute to any entry that has the `document`
    object class. This is done with the `ditcontentrule` directive:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最佳方法是创建一个DIT内容规则，禁止向任何具有`document`对象类的条目添加`userPassword`属性。这可以通过`ditcontentrule`指令来实现：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The form of the `ditcontentrule` directive should be familiar by now. Like the
    `objectclass` and `attributetype` directives, this directive encloses the DIT
    content rule definition inside of parentheses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`ditcontentrule`指令的格式现在应该很熟悉了。像`objectclass`和`attributetype`指令一样，这个指令将DIT内容规则定义包裹在括号内。'
- en: The first field is an OID. But unlike the other schema definitions, this OID
    is not the OID for this definition. Instead, it is the OID of the structural object
    class that we are targeting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是一个OID。但与其他模式定义不同，这个OID并不是该定义的OID。相反，它是我们目标的结构化对象类的OID。
- en: In this case, the OID `0.9.2342.19200300.100.4.6` is the OID for the `document`
    object class. You can verify this with a glance at the document schema listed
    a few pages back or by browsing the cosine schema.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，OID `0.9.2342.19200300.100.4.6`是`document`对象类的OID。你可以通过查看前面几页列出的文档模式，或者浏览cosine模式来验证这一点。
- en: The `NAME` field should contain a unique name used for referencing this rule.
    For the most part, the value of this field is used in reporting references to
    this rule in the log file, and in responses to the client.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`NAME`字段应该包含用于引用此规则的唯一名称。在大多数情况下，该字段的值用于报告日志文件中对该规则的引用，并且用于客户端的响应中。'
- en: The `DESC` field contains a short-text description of what the rule does.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`DESC`字段包含该规则功能的简短文本描述。'
- en: The `NOT` field contains a list of OIDs or names of attributes that should be
    disallowed. The name `userPassword` comes from the `NAME` field in the `userPassword`
    attribute definition.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT`字段包含一组OID或属性名称，指定应该禁止的内容。名称`userPassword`来源于`userPassword`属性定义中的`NAME`字段。'
- en: 'With this content rule in place, what will happen if we try to add a `userPassword`
    attribute to a document? Here is an example using `ldapmodify`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个内容规则，如果我们尝试将`userPassword`属性添加到文档中，会发生什么呢？以下是使用`ldapmodify`的一个示例：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The highlighted portion in this example is the attempted modification. We attempted
    to add the `simpleSecurityObject` object class and the `userPassword` attribute
    to the record. But the server responded with an **Object class violation** error,
    giving the following reason:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例中的高亮部分是尝试的修改。我们尝试将`simpleSecurityObject`对象类和`userPassword`属性添加到记录中。但服务器响应了一个**对象类违规**错误，并给出了以下原因：
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our custom DIT content rule did its job—it prevented the addition of the `userPassword`
    attribute to the `document` entry.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的DIT内容规则成功地执行了它的任务——它阻止了将`userPassword`属性添加到`document`条目中。
- en: 'This DIT content rule we created above is a negative rule—it defines what attributes
    an entry *cannot* have. But `ditcontentrule` can also be used to create positive
    rules: rules that specify which attributes (or auxiliary object classes) are allowed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面创建的DIT内容规则是一个负面规则——它定义了条目*不能*拥有的属性。但是，`ditcontentrule`也可以用来创建正面规则：即指定允许哪些属性（或辅助对象类）的规则。
- en: 'For example, we could write a rule that says that every entry that is an `inetOrgPerson`
    must have a `userPassword`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个规则，要求每个`inetOrgPerson`条目必须拥有`userPassword`属性：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The OID used in this rule is the OID for the `inetOrgPerson` object class. The
    `MUST` field indicates that any entry with the structural object class `inetOrgPerson`
    must also have the `userPassword` attribute set.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则中使用的OID是`inetOrgPerson`对象类的OID。`MUST`字段表示任何具有结构性对象类`inetOrgPerson`的条目必须设置`userPassword`属性。
- en: 'Because of this rule, an attempt to add a new `inetOrgPerson` entry without
    a `userPassword` would result in an error similar to the one we looked at earlier:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此规则，尝试添加没有`userPassword`的`inetOrgPerson`条目将导致与我们之前看到的类似的错误：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The record being added (highlighted) is a valid `inetOrgPerson` entry, according
    to the `inetOrgPerson` object class definition. But, because of the DIT content
    rule, adding the record failed because there is no `userPassword` attribute value
    specified.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正在添加的记录（已高亮）是一个有效的`inetOrgPerson`条目，符合`inetOrgPerson`对象类定义。但由于DIT内容规则的限制，添加该记录失败，因为没有指定`userPassword`属性值。
- en: Now let's expand this rule to take advantage of the `AUX` field. The `AUX` field
    may be used to explicitly state which auxiliary classes can be combined with this
    structural object class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们扩展这个规则，利用`AUX`字段。`AUX`字段可用来明确声明可以与此结构性对象类组合的辅助类。
- en: In our newly revised DIT content rule we will make it so that only the `pkiUser`
    and the `labeledURIObject` auxiliary object classes can be added to an `inetOrgUser`
    record.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新修订的DIT内容规则中，我们将确保只有`pkiUser`和`labeledURIObject`辅助对象类可以添加到`inetOrgUser`记录中。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `pkiUser` object class is an auxiliary object class designed to indicate
    that an entry is capable of performing **public key infrastructure** (**PKI**)
    secure transactions. It has one attribute, `userCertificate`, that contains the
    user''s cryptographic certificate. See the Wikipedia page for a quick introduction
    to PKI: [http://en.wikipedia.org/wiki/Public_key_infrastructure](http://en.wikipedia.org/wiki/Public_key_infrastructure).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkiUser`对象类是一个辅助对象类，用于指示条目能够执行**公钥基础设施**（**PKI**）安全事务。它有一个属性`userCertificate`，包含用户的加密证书。请参阅维基百科页面以快速了解PKI：[http://en.wikipedia.org/wiki/Public_key_infrastructure](http://en.wikipedia.org/wiki/Public_key_infrastructure)。'
- en: 'The `labeledURIObject` object class allows an additional attribute, `labeledURI`,
    which takes a URI (such as a URL) and a plain text description:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`labeledURIObject`对象类允许添加一个额外的属性`labeledURI`，该属性接受一个URI（如URL）和一个纯文本描述：'
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The URI is separated from the label by a white space. So the URI is [http://aleph-null.tv](http://aleph-null.tv)
    and the label is `Home` `Page`. The `labeledURIObject` is defined in RFC 2079
    ([http://www.ietf.org/rfc/rfc2079.txt](http://www.ietf.org/rfc/rfc2079.txt)).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: URI与标签之间用空格分隔。因此，URI是[http://aleph-null.tv](http://aleph-null.tv)，标签是`Home`
    `Page`。`labeledURIObject`在RFC 2079中定义（[http://www.ietf.org/rfc/rfc2079.txt](http://www.ietf.org/rfc/rfc2079.txt)）。
- en: 'Also, we will change the `NAME` and `DESC` elements to reflect the fact that
    our rule now does more than just require a `userPassword`. The DIT content rule
    now looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将修改`NAME`和`DESC`元素，以反映我们规则现在做的不仅仅是要求`userPassword`。现在的DIT内容规则如下所示：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the syntax of the `AUX` field. To list multiple values in a field it is
    necessary to enclose the list of values, separated by a dollar sign (`$`), inside
    of parentheses.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`AUX`字段的语法。要在字段中列出多个值，必须将值列表（用美元符号`$`分隔）括在括号中。
- en: 'Using this DIT content rule, we can successfully add a URL (using the `labeledURIObject`
    auxiliary object class) to my record:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此DIT内容规则，我们可以成功地将一个URL（使用`labeledURIObject`辅助对象类）添加到我的记录中：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The entry, highlighted above, was added successfully because the `labeledURIObject`
    (which allows the `labeledURI` attribute) is allowed by the content rule. But
    if I try to add a different auxiliary object class—one not explicitly allowed
    in the DIT content rule – the change request will be denied:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上面突出显示的条目已成功添加，因为`labeledURIObject`（允许`labeledURI`属性）是内容规则所允许的。但如果我尝试添加一个不同的辅助对象类——一个在DIT内容规则中没有明确允许的类——更改请求将被拒绝：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The DIT content rule prevented the addition of an auxiliary object class because
    this class is not specified in the `AUX` field of the rule.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: DIT内容规则阻止了添加辅助对象类，因为此类未在规则的`AUX`字段中指定。
- en: Like the other definitions, the `ditcontentrule` directive also allows the `OBSOLETE`
    flag.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他定义一样，`ditcontentrule`指令也允许`OBSOLETE`标志。
- en: 'In summary, the `ditcontentrule` directive takes a definition of a DIT content
    rule enclosed in parentheses. The following fields are supported:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ditcontentrule`指令采用一个括号括起来的DIT内容规则定义。支持以下字段：
- en: The OID of the structural object class to which this rule applies.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于此规则的结构对象类的OID。
- en: The `NAME` field, which provides a short name used to identify the rule.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`字段，提供用于标识规则的简短名称。'
- en: The `DESC` field, which contains a description of the rule.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESC`字段，其中包含规则的描述。'
- en: The `OBSOLETE` flag to mark this rule as obsolete.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBSOLETE`标志，用于标记该规则为过时。'
- en: The `AUX` field, which contains the names or OIDs of all auxiliary classes that
    the entries of this object class are allowed to implement.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUX`字段，其中包含所有允许此对象类条目实现的辅助类的名称或OID。'
- en: The `MUST` field, which contains a list of all of the (not already mandatory)
    attributes that entries of this object class must have.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MUST`字段，其中包含此对象类条目必须拥有的所有（尚未强制要求的）属性的列表。'
- en: The `MAY` field, which lists all of the fields that a member of this object
    class may have. As of OpenLDAP 2.3.30, this is not exclusive. Attributes not in
    this list but allowed by object class schema definitions are still allowed. In
    other words, `MAY` does not impose any restrictions.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAY`字段，其中列出此对象类成员可能拥有的所有字段。自OpenLDAP 2.3.30起，这不是排他性的。未在此列表中的属性但被对象类模式定义允许的，仍然允许。换句话说，`MAY`并不施加任何限制。'
- en: The `NOT` field, which contains a list of attributes that an entry of this object
    class cannot have. This cannot be applied to attributes that are required by the
    object classes schema definition.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT`字段，其中包含此对象类条目不能拥有的属性的列表。不能应用于对象类模式定义所要求的属性。'
- en: Now we have looked at the four different schema definition directives allowed
    in the `slapd.conf` file (or included files). With this information you should
    be able to read through and understand any of the schemas defined in OpenLDAP.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了`slapd.conf`文件（或包含文件）中允许的四种不同的模式定义指令。通过这些信息，你应该能够阅读并理解OpenLDAP中定义的任何模式。
- en: Next we will take a quick look at how to get schema information out of a SLAPD
    server using the LDAP protocol.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要了解如何使用LDAP协议从SLAPD服务器获取模式信息。
- en: Retrieving the Schemas from SLAPD
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从SLAPD检索模式
- en: When SLAPD loads the schemas, it stores them in a special part of the directory
    information tree, along with the Root DSE record; a special entry holds schema
    information. Having this information is useful for debugging, but more importantly
    it provides a way for client applications to find out about what types of objects
    and attributes may be stored in this directory server.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当SLAPD加载模式时，它将它们存储在目录信息树的一个特殊部分，与Root DSE记录一起；一个特殊条目保存模式信息。拥有这些信息对调试很有用，但更重要的是，它为客户端应用程序提供了一种了解此目录服务器中可能存储的对象和属性类型的方式。
- en: Obtaining the information from the directory is as easy as issuing an `ldapsearch`
    command.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录中获取信息就像执行一个`ldapsearch`命令一样简单。
- en: 'The schema information is stored in a special record called the **subschema
    subentry**. You can access the subschema subentry using `ldapsearch`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 架构信息存储在一个特殊的记录中，称为**subschema subentry**。你可以使用`ldapsearch`访问subschema subentry：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Access to the `cn=subschema` record is governed by global ACLs (ACLs that appear
    before the database section). For example, to grant access to the subschema to
    users only, you can use a rule like this: `access` `to` `dn.exact="cn=subschema"`
    `by` `users` `read`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对`cn=subschema`记录的访问受全局ACL（在数据库部分之前出现的ACL）管理。例如，为了仅允许用户访问subschema，你可以使用这样的规则：`access`
    `to` `dn.exact="cn=subschema"` `by` `users` `read`。
- en: This will retrieve the entire schema specification from the server including
    not only the attribute and object class definitions, but also definitions of matching
    rules, matching rule uses, structure rules, name forms, and LDAP syntaxes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从服务器中检索整个架构规范，包括不仅仅是属性和对象类定义，还包括匹配规则、匹配规则使用、结构规则、名称格式和LDAP语法的定义。
- en: 'But, as with any other record in an LDAP server, we can use search filters
    to get just the values of specific attributes. For example, we can find out what
    all of the existing DIT content rules are:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与LDAP服务器中的任何其他记录一样，我们可以使用搜索过滤器仅获取特定属性的值。例如，我们可以找出所有现有的DIT内容规则：
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This search returns all of the DIT content rules currently included in the schema
    definitions for this server. Of course, the only two there are the ones we created
    in the last section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此搜索将返回当前包含在此服务器架构定义中的所有DIT内容规则。当然，唯一的两个规则就是我们在上一节中创建的规则。
- en: 'The following schema-related attributes are included in the `cn=Subschema`
    record:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下与架构相关的属性包含在`cn=Subschema`记录中：
- en: '`ldapSyntaxes`: This attribute has one value for every LDAP syntax supported
    in the directory. Example: `ldapSyntaxes:` `(` `1.3.6.1.1.16.1` `DESC` `''UUID''`
    `)`.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ldapSyntaxes`：此属性为目录中每种支持的LDAP语法提供一个值。示例：`ldapSyntaxes:` `(` `1.3.6.1.1.16.1`
    `DESC` `''UUID''` `)`。'
- en: '`matchingRules`: This attribute has one value for every matching rule in the
    directory. Example: `matchingRules:` `(` `2.5.13.14` `NAME` `''integerMatch''`
    `SYNTAX` `1.3.6.1.4.1.1466.115.121.1.27` `)`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matchingRules`：此属性为目录中的每个匹配规则提供一个值。示例：`matchingRules:` `(` `2.5.13.14` `NAME`
    `''integerMatch''` `SYNTAX` `1.3.6.1.4.1.1466.115.121.1.27` `)`。'
- en: '`matchingRuleUse`: This attribute has one value for every matching rule use,
    which pairs matching rule OIDs with a list of all of the attributes that implement
    that matching rule. Example: `matchingRuleUse:` `(` `2.5.13.27` `NAME` `''generalizedTimeMatch''`
    `APPLIES` `(` `createTimestamp` `$` `modifyTimestamp` `)` `)`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matchingRuleUse`：此属性为每个匹配规则使用提供一个值，该值将匹配规则OID与实施该匹配规则的所有属性列表配对。示例：`matchingRuleUse:`
    `(` `2.5.13.27` `NAME` `''generalizedTimeMatch''` `APPLIES` `(` `createTimestamp`
    `$` `modifyTimestamp` `)` `)`。'
- en: '`attributeTypes`: This attribute has one value for every attribute definition
    in this directory. Example: `attributeTypes:` `(` `2.5.4.3` `NAME` `(` `''cn''`
    `''commonName''` `)` `DESC` `''RFC2256:` `common` `name(s)` `for` `which` `the`
    `entity` `is` `known` `by''` `SUP` `name` `)`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributeTypes`：此属性为目录中每个属性定义提供一个值。示例：`attributeTypes:` `(` `2.5.4.3` `NAME`
    `(` `''cn''` `''commonName''` `)` `DESC` `''RFC2256:` `common` `name(s)` `for`
    `which` `the` `entity` `is` `known` `by''` `SUP` `name` `)`。'
- en: '`objectClasses`: This attribute contains one value for every object class definition.
    Example: `objectClasses:` `(` `2.5.6.2` `NAME` `''country''` `DESC` `''RFC2256:`
    `a` `country''` `SUP` `top` `STRUCTURAL` `MUST` `c` `MAY` `(` `searchGuide` `$`
    `description` `)` `)`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectClasses`：此属性包含每个对象类定义的一个值。示例：`objectClasses:` `(` `2.5.6.2` `NAME` `''country''`
    `DESC` `''RFC2256:` `a` `country''` `SUP` `top` `STRUCTURAL` `MUST` `c` `MAY`
    `(` `searchGuide` `$` `description` `)` `)`。'
- en: '`dITContentRules`: This attribute contains one value for every DIT content
    rule defined.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dITContentRules`：此属性包含每个已定义DIT内容规则的一个值。'
- en: Other standard attributes, such as `cn`, `objectclass`, and the basic operational
    attributes, are also part of the record.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准属性，如`cn`、`objectclass`以及基本操作属性，也是记录的一部分。
- en: Examining schemas this way is an alternative to simply reading the schema files.
    While it has less documentation (since there are no comments), using filters can
    be helpful. Also, information not in the standard schemas (such as schema definitions
    for operational attributes) is also available in this record.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式检查架构是另一种替代直接读取架构文件的方法。虽然它的文档较少（因为没有注释），但使用过滤器仍然是有帮助的。此外，不在标准架构中的信息（例如操作属性的架构定义）也可以在此记录中找到。
- en: 'Later in the chapter we will begin implementing schemas in SLAPD, first by
    including some already written schemas, then by writing our own. But next we will
    take a quick look at one more theoretical component of schemas: the schema hierarchy.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将开始在SLAPD中实现架构，首先包括一些已编写好的架构，然后编写我们自己的架构。但接下来我们将快速浏览架构的另一个理论组成部分：架构层次结构。
- en: The ObjectClass Hierarchy
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象类层次结构
- en: Object classes and attributes in LDAP can be organized into hierarchical relationships.
    A hierarchical relationship is one in which one entity stands in a parent or superior
    relationship to one or more subordinate entities.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP中的对象类和属性可以组织成层次关系。层次关系是指一个实体与一个或多个下属实体之间存在父级或上级关系。
- en: Attribute hierarchies tend to be simple, and require only a short explanation.
    Object classes, on the other hand, use a more complicated hierarchical model and
    will be the focus of this part of the chapter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 属性层次结构通常很简单，只需要简短的解释。另一方面，对象类则使用更为复杂的层次模型，并将在本章中成为焦点。
- en: In the cases of both attribute and object class hierarchies, the mechanism for
    creating the hierarchy is the schema definition. Schema definitions for both attributes
    and object classes use the `SUP` field to indicate a relationship to a parent,
    or superior.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性和对象类层次结构的案例中，创建层次结构的机制是架构定义。属性和对象类的架构定义都使用`SUP`字段来表示与父级或上级的关系。
- en: We will start out with a brief discussion of attribute hierarchies, and then
    move on to the more complicated object class hierarchies.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简短的属性层次结构讨论开始，然后转向更复杂的对象类层次结构。
- en: Attribute Hierarchies
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性层次结构
- en: Attribute hierarchies are simple relationships wherein one attribute can, through
    its subordinate relationship to another attribute, inherit certain features, such
    as matching rules and LDAP syntaxes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 属性层次结构是简单的关系，其中一个属性可以通过其与另一个属性的从属关系，继承某些特征，例如匹配规则和LDAP语法。
- en: 'The simplicity of attribute hierarchies manifests itself in a few ways:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 属性层次结构的简单性表现为几个方面：
- en: There is no requirement that an attribute have any relation to other attributes.
    In other words, there is no requirement that attributes be part of a hierarchy.
    Many, such as the `telephoneNumber` attribute we looked at in the previous part,
    stand on their own.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并没有要求属性与其他属性有任何关系。换句话说，并没有要求属性必须属于某个层次结构。许多属性，比如我们在前一部分中看到的`telephoneNumber`属性，是独立存在的。
- en: Attribute hierarchies do not play a significant role in how attributes are used.
    Attribute hierarchies exist primarily to keep attribute schema definitions clean
    and succinct, minimizing repetition.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性层次结构在属性的使用中并没有发挥重要作用。属性层次结构主要存在是为了保持属性架构定义的简洁和清晰，减少重复。
- en: The `name` attribute, which is conventionally not used directly in any object
    class, is a good example of the use of superior/subordinate relationships in attribute
    definitions. Thirteen attributes in the core schema list `name` as their superior.
    The `cn` attribute is one example.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`属性通常不直接用于任何对象类，它是属性定义中使用上级/下级关系的一个很好例子。核心架构中有十三个属性将`name`作为它们的上级。`cn`属性就是一个例子。'
- en: '![Attribute Hierarchies](img/1021_06_02.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![属性层次结构](img/1021_06_02.jpg)'
- en: The schema definition for `cn` uses only the `NAME`, `DESC`, and `SUP` fields,
    with `SUP` indicating that the `name` attribute is the superior of `cn`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`cn`的架构定义只使用了`NAME`、`DESC`和`SUP`字段，其中`SUP`表示`name`属性是`cn`的上级。'
- en: Since the `cn` attribute definition does not specify any matching rules or an
    LDAP syntax, these are inherited from the name attribute. Hence, `cn` is assigned
    the equality and substring matching rules defined in `name`, as well as the LDAP
    syntax and length.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`cn`属性定义没有指定任何匹配规则或LDAP语法，因此这些规则是从`name`属性继承的。因此，`cn`继承了在`name`中定义的相等性和子字符串匹配规则，以及LDAP语法和长度。
- en: But there is not much more that can be done with attribute hierarchies. Other
    than matching rules and syntax nothing else is automatically inherited from the
    superior, and there are no other benefits in using attribute hierarchies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，属性层次结构可以做的事情并不多。除了匹配规则和语法外，其他内容不会自动从上级继承，并且使用属性层次结构没有其他好处。
- en: Subordinate Attributes and Searching
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下属属性与搜索
- en: 'There is one interesting effect that results from attribute hierarchies. A
    request for a superior attribute may return subordinate attributes as matches.
    For example, here is a search requesting just a single attribute: `name`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从属性层级中会产生一个有趣的效果。请求一个上级属性时，可能会返回作为匹配项的下级属性。例如，下面是一个仅请求一个属性的搜索：`name`：
- en: '[PRE36]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: According to the search parameters, the search should return any `name` attribute
    values for records with `uid=matt`. But the record returned (highlighted) has
    more than that. In addition to the DN, which is always returned, the record also
    has `ou`, `cn`, `sn`, `givenName`, `title`, `st`, and `l` values.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 根据搜索参数，搜索应返回`uid=matt`的记录中的任何`name`属性值。但返回的记录（已高亮显示）包含的不止这些。除了总是返回的DN，记录中还包含了`ou`、`cn`、`sn`、`givenName`、`title`、`st`和`l`等值。
- en: Why is this? This happens simply because all of those attribute types have `name`
    as the superior.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样呢？这仅仅是因为所有这些属性类型都有`name`作为上级属性。
- en: 'Such behavior extends to search filter behavior, as well. For example, a search
    filter like (`name=Marcus`) will result in a search being performed against all
    attributes that use `name` as a superior:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为也会扩展到搜索过滤器行为中。例如，一个搜索过滤器（如`(name=Marcus)`）将会对所有使用`name`作为上级属性的属性进行搜索：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The record for `uid=cicero` matched because the `givenName` field has the value
    `Marcus`. As can be seen in the attribute type definition, the `givenName` attribute
    has `name` as a superior attribute type:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid=cicero`的记录匹配是因为`givenName`字段的值为`Marcus`。正如在属性类型定义中所看到的，`givenName`属性的上级属性类型是`name`：'
- en: '[PRE38]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While this feature can cause some unexpected behavior for those unfamiliar with
    schemas, it can prove quite useful at times.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一特性可能会对不熟悉架构的人造成一些意外行为，但有时它也非常有用。
- en: For the most part, attribute hierarchies are fairly simple. Object class hierarchies
    are more complex though. And we will now take a look at them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，属性层级相对简单。然而，对象类层级要复杂得多。接下来，我们将对其进行详细探讨。
- en: 'Object Class Types: Abstract, Structural, and Auxiliary'
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象类类型：抽象、结构化和辅助
- en: Like attributes, object classes can be organized into hierarchies. Typically,
    there is one major object class hierarchy. But while the hierarchical organization
    of object classes plays an important part in the structure of the directory, not
    all object classes are part of the hierarchy. To understand why this is we must
    begin by examining the different types of object classes.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 像属性一样，对象类也可以组织成层级结构。通常情况下，会有一个主要的对象类层级。但尽管对象类的层级组织在目录结构中发挥着重要作用，并非所有的对象类都属于这个层级结构。要理解为什么会这样，我们必须首先检查不同类型的对象类。
- en: 'There are three types of object class: abstract, structural, and auxiliary
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的对象类：抽象、结构化和辅助，如下所示：
- en: An **abstract object class** holds a place at the top of the object class hierarchy.
    It may set required and allowed attributes for all object classes beneath it in
    the hierarchy, but no record can be an instance of that object class only. Further,
    any parent of an abstract object class must also be abstract.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象对象类**位于对象类层级的顶部。它可以为所有位于其下层级的对象类设置所需和允许的属性，但没有记录仅能是该对象类的实例。此外，任何抽象对象类的父类也必须是抽象的。'
- en: A **structural object class** also holds a place in the hierarchy, and is a
    subordinate of (or, to phrase it differently, inherits from) either another structural
    object class or an abstract object class. An entry in the directory is an instance
    of a structural object class. When one structural object class subclasses another
    structural object class, the parent class is treated as if it were abstract. So,
    operationally speaking, for any given record it has only one structural object
    class—the structural object class is lowest on the object class hierarchy.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化对象类**也在层级中占有一席之地，并且是另一个结构化对象类或抽象对象类的子类（或者换句话说，它继承自其他结构化对象类或抽象对象类）。目录中的一项条目是结构化对象类的一个实例。当一个结构化对象类是另一个结构化对象类的子类时，父类会被视作抽象类。因此，从操作角度讲，对于任何给定的记录，它只有一个结构化对象类——结构化对象类在对象类层级中是最低的。'
- en: An **auxiliary object class** is not required to be part of the object class
    hierarchy, though it can be. An auxiliary object class is intended to allow extra
    attributes to be defined for a record that already has a structural object class.
    For example, a record that describes a system account may not be in the person
    part of the hierarchy but may still need a password. The `simpleSecurityObject`
    is an auxiliary object class that can be added to other structural object classes
    to allow (and, in fact, require) that a `userPassword` attribute be set.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**辅助对象类**不要求成为对象类层次结构的一部分，尽管它可以是。辅助对象类旨在为已经具有结构对象类的记录定义额外的属性。例如，一个描述系统账户的记录可能不在层次结构中的人员部分，但仍然可能需要一个密码。`simpleSecurityObject`
    是一个辅助对象类，可以添加到其他结构对象类中，以允许（并且实际上要求）设置 `userPassword` 属性。'
- en: 'Abstract and structural object classes are organized into a hierarchy, with
    abstract classes at the top, and structural object classes as subordinates of
    those. In core schema (`core.schema`), there is only one abstract object class:
    `top`. This object class marks the top of the object class hierarchy—the ancestor
    (the highest superior) of all object classes.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象和结构对象类被组织成一个层次结构，抽象类位于最上层，结构对象类是它们的下级。在核心模式（`core.schema`）中，只有一个抽象对象类：`top`。这个对象类标志着对象类层次结构的顶端——所有对象类的祖先（最高的上级）。
- en: 'The Object Class Hierarchy: An Overview'
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象类层次结构：概述
- en: The hierarchy begins with the abstract object class `top`. Beneath it are any
    number of structural object classes, all of which are either direct or indirect
    subordinates. A direct subordinate is one that lists `top` as its superior object
    class (in the `SUP` field of the schema definition). An indirect subordinate is
    farther down the object class hierarchy. It lists another abstract or structural
    object class as its superior, but that superior either itself refers to `top`
    as its superior, or refers to another indirect subordinate.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构从抽象对象类 `top` 开始。它下面有任意数量的结构对象类，所有这些类都是直接或间接的下级。直接下级是指在模式定义的 `SUP` 字段中列出
    `top` 作为其上级对象类的类。间接下级则在对象类层次结构的更深层次，它列出了另一个抽象或结构对象类作为其上级，但该上级要么自身将 `top` 作为上级，要么引用另一个间接下级。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In other LDAP references, a superior class is sometimes called a **superclass**,
    while a superior attribute (in the attribute hierarchy) is called a **supertype**.
    Likewise, the terms **subclass** and **subtype** can be used to indicate the subordinate
    relationships in classes and attributes.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 LDAP 参考中，超级类有时称为 **超类**，而上级属性（在属性层次结构中）称为 **超类型**。同样，**子类** 和 **子类型** 这两个术语可以用来表示类和属性中的从属关系。
- en: Structural object classes have either an abstract object class or another structural
    object class as their superior.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 结构对象类的上级可以是抽象对象类，也可以是另一个结构对象类。
- en: Auxiliary object classes may or may not be in the object class hierarchy. They
    can have superiors, but they are not required to.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助对象类可能在对象类层次结构中，也可能不在。它们可以有上级，但不要求一定有。
- en: 'Here is a pictorial representation of a simple object class hierarchy (consisting
    of four object classes) and a pair of records in the directory information tree
    that we created in Chapter 3:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的对象类层次结构的示意图（由四个对象类组成），以及我们在第 3 章中创建的目录信息树中的一对记录：
- en: '![The Object Class Hierarchy: An Overview](img/1021_06_03.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![对象类层次结构：概述](img/1021_06_03.jpg)'
- en: The `account` and `groupOfNames` structural object classes both have `top` listed
    as their superior (as indicated by the solid lines). `simpleSecurityObject`, an
    auxiliary object class, has no superiors.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`account` 和 `groupOfNames` 结构对象类都将 `top` 列为它们的上级（如实线所示）。`simpleSecurityObject`，作为一个辅助对象类，则没有上级。'
- en: Beneath the object class hierarchy are two records, with the DN and object class
    attributes displayed. The dotted lines indicate which schemas these entries implement.
    Each of the two records (the `uid=authenticate` user and the `cn=Admins` group)
    are related to a different part of the object class hierarchy. `cn=Admins` is
    a `groupOfNames`, while `uid=authenticate` is an account that also has the attributes
    of a `simpleSecurityObject`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象类层次结构下方有两个记录，显示了 DN 和对象类属性。虚线表示这些条目所实现的模式。两个记录（`uid=authenticate` 用户和 `cn=Admins`
    组）与对象类层次结构的不同部分相关。`cn=Admins` 是一个 `groupOfNames`，而 `uid=authenticate` 是一个账户，也具有
    `simpleSecurityObject` 的属性。
- en: This representation of the object class hierarchy is designed to show how the
    organization of schemas is related to the entries within the directory.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对象类层次结构的表示方式旨在展示模式的组织结构与目录中的条目之间的关系。
- en: It is important to keep in mind that there are two different hierarchies in
    play here. The two entries above are part of the directory information tree hierarchy.
    Their position in that hierarchy is indicated by their DNs. The `uid=authenticate`
    entry, for example, is a child of the `ou=System` entry, which in turn is a child
    of the `dc=example,dc=com` entry (the root entry for our directory information
    tree).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的是，这里有两个不同的层次结构。上面的两个条目属于目录信息树层次结构。它们在该层次结构中的位置由其DN表示。例如，`uid=authenticate`条目是`ou=System`条目的子条目，而`ou=System`条目又是`dc=example,dc=com`条目（我们目录信息树的根条目）的子条目。
- en: But by their object classes, the entries can also be related to the object class
    hierarchy, as is illustrated. For the time being it is only this second hierarchy—the
    object class hierarchy—that we are interested in.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过它们的对象类，条目也可以与对象类层次结构相关联，如图所示。目前，我们只对第二个层次结构——对象类层次结构感兴趣。
- en: Let's take a look at each of the three types of object classes. Understanding
    the differences between the three, and the respective role each plays, will illuminate
    the concepts at play in the object class hierarchy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这三种对象类类型。理解它们之间的区别，以及每种类型所扮演的角色，将有助于阐明对象类层次结构中的概念。
- en: Abstract Classes
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象类
- en: The first of the three types that we will examine is the **abstract class**.
    While abstract classes are only rarely used, they play a major role in the development
    of the object class hierarchy.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的三种类型中的第一种是**抽象类**。尽管抽象类的使用较为罕见，但它们在对象类层次结构的开发中起着重要作用。
- en: 'We have already talked about the special `top` object class. The most commonly
    used LDAP schemas do not use any other abstract object classes beside `top`. The
    `top` object class definition looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过特殊的`top`对象类。最常用的LDAP模式除了`top`之外不会使用任何其他抽象对象类。`top`对象类的定义如下：
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It requires only one attribute: `objectclass`. All structural object classes
    should be related, either directly or indirectly, to `top`. And any abstract object
    class that will have structural object classes subordinate to it must also be
    related to `top`. While it is possible to create an abstract class without a superior
    class, effectively starting a new tree of object classes, this is rarely done.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 它只需要一个属性：`objectclass`。所有结构化对象类都应该与`top`相关联，无论是直接还是间接。而任何抽象对象类，如果其下有结构化对象类，则必须与`top`相关联。虽然可以创建没有父类的抽象类，实际上启动一个新的对象类树，但这通常不这么做。
- en: Tip
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Abstracts without Superiors**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有父类的抽象类**'
- en: The main circumstance for defining abstract classes without superiors is when
    all of the classes that inherit from that abstract class will be auxiliary object
    classes. Structural object classes, according to RFC 4512, must be related (directly
    or indirectly) to the top object class.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 定义没有父类的抽象类的主要情况是，所有从该抽象类继承的类都将是辅助对象类。根据RFC 4512，结构化对象类必须与`top`对象类（直接或间接）相关联。
- en: But `top` is not the only abstract object class in frequent use. There are a
    few common schemas included with OpenLDAP, notably the `java.schema` and `corba.schema`,
    which make use of abstract object classes whose superiors are `top`. If an abstract
    object class has a superior, it must be an abstract superior.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 但`top`并不是唯一常用的抽象对象类。OpenLDAP中包含了一些常见的模式，特别是`java.schema`和`corba.schema`，它们使用了抽象对象类，而这些类的父类是`top`。如果一个抽象对象类有父类，它必须是一个抽象父类。
- en: Abstract object classes can have lists of attributes in the `MUST` and `MAY`
    fields of their definition. The `top` object class, as we just saw, requires the
    `objectclass` attribute. Any entry that implements a structural object class subordinate
    to this abstract object class inherits the `MUST` and `MAY` constraints of the
    parent.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象对象类可以在其定义的`MUST`和`MAY`字段中列出属性。正如我们刚刚看到的，`top`对象类要求有`objectclass`属性。任何实现了结构化对象类且隶属于这个抽象对象类的条目，都会继承父类的`MUST`和`MAY`约束。
- en: 'For example, in the `java.schema` the class `javaObject` is abstract. Here
    is its definition:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`java.schema`中，`javaObject`类是抽象的。以下是其定义：
- en: '[PRE40]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: According to the `SUP` field, this object class is subordinate to `top`. It
    requires that any entry that implements `javaObject` has a `javaClassName` attribute.
    It also defines several attributes—`javaClassNames`, `javaCodebase`, `javaDoc`,
    and `description`—that entries may include.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`SUP`字段，该对象类从属于`top`。它要求任何实现了`javaObject`的记录必须具有`javaClassName`属性。它还定义了几个属性——`javaClassNames`、`javaCodebase`、`javaDoc`和`description`——记录可以包含这些属性。
- en: Note
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Java schema is used to store serialized Java objects in a directory server.
    It is defined in RFC 2713.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Java架构用于在目录服务器中存储序列化的Java对象。它在RFC 2713中进行了定义。
- en: 'There are no structural object classes subordinate to `javaObject`. However,
    there are a couple of auxiliary object classes that are subordinate to `javaObject`:
    `javaSerializedObject` and `javaMarshalledObject`. Here is the `javaSerializedObject`
    schema definition:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`javaObject`没有从属的结构性对象类。然而，有几个从属于`javaObject`的辅助对象类：`javaSerializedObject`和`javaMarshalledObject`。以下是`javaSerializedObject`架构的定义：'
- en: '[PRE41]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Only one attribute is required in this class: `javaSerializedData`. There are
    no optional attributes specified in this definition.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中只需要一个属性：`javaSerializedData`。在这个定义中没有指定可选属性。
- en: If some entry uses the `javaSerializedData` object class what fields *must*
    it have? And what fields *may* it have?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个记录使用了`javaSerializedData`对象类，它*必须*具有哪些字段？它*可以*具有哪些字段？
- en: 'It must have a `javaSerializedData` attribute. We can see that from the `javaSerializedObject`
    schema. But it also must have the `javaClassName` attribute because that is required
    in the object class of the superior `javaObject` object class. And a `javaSerializedData`
    entry may have any of the attributes listed in the `MAY` field of the `javaObject`
    schema: `javaClassNames`, `javaCodebase`, `javaDoc`, and `description`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须具有`javaSerializedData`属性。我们可以从`javaSerializedObject`架构中看到这一点。但它还必须具有`javaClassName`属性，因为这是在上级`javaObject`对象类中要求的。而`javaSerializedData`记录可以包含`javaObject`架构中`MAY`字段列出的任何属性：`javaClassNames`、`javaCodebase`、`javaDoc`和`description`。
- en: This example illustrates the use of the abstract object class as a way of organizing
    object classes into hierarchies, grouping similar object classes (here, `javaSerializedObject`
    and `javaMarshalledObject`) under a common (and more generic) ancestor, `javaObject`.
    The `javaObject` abstract object class is then used to specify the common attributes
    that both of the subordinate object classes need included.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了如何使用抽象对象类作为将对象类组织成层次结构的一种方式，将类似的对象类（这里是`javaSerializedObject`和`javaMarshalledObject`）归类于一个共同的（更加通用的）祖先`javaObject`。然后，`javaObject`抽象对象类被用来指定这两个从属对象类需要包含的公共属性。
- en: Thus, one of the major uses of abstract object classes is to collect common
    attributes that should be (or may be) included in object classes that are defined
    as subordinate to it.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象对象类的主要用途之一是收集应当（或可以）包含在定义为从属的对象类中的公共属性。
- en: Abstract classes are rare. In contrast, the most commonly used object class
    type is the structural object class.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是罕见的。相比之下，最常用的对象类类型是结构性对象类。
- en: Structural Object Classes
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构性对象类
- en: As we have seen in a number of examples, every record has a DN and one or more
    object classes. From there, what other attributes it has depends on the object
    classes. But there are constraints on which object classes an entry has. One major
    factor that determines what object classes an entry may have is the structural
    object class hierarchy.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在多个示例中看到的，每个记录都有一个DN和一个或多个对象类。从这些对象类出发，记录的其他属性取决于对象类。然而，记录可以拥有哪些对象类是有限制的。决定记录可以有哪些对象类的一个主要因素是结构性对象类的层次结构。
- en: Every record in the directory must have at least one structural object class.
    The structural object class determines what type of entry a record is. For example,
    an entry with the structural object class `organization` is an `organization`
    entry.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的每个记录必须至少有一个结构性对象类。结构性对象类决定了记录的类型。例如，具有结构性对象类`organization`的记录是一个`organization`记录。
- en: Note
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once an entry has been created in the directory, its structural object class
    cannot be changed. Adding and removing auxiliary object classes is allowed, but
    the structural object class is unalterable (as is, *ipso* *facto*, the chain of
    superior object classes).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦记录在目录中创建，其结构性对象类就无法更改。可以添加或移除辅助对象类，但结构性对象类是不可更改的（*ipso* *facto*，同样，优先级对象类的链条也是如此）。
- en: 'An entry may implement more than one object class, and not all the object classes
    that it implements need be structural. Let''s take a look at the organization
    record we created in Chapter 3:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个条目可以实现多个对象类，并且它实现的所有对象类并不一定都是结构性对象类。我们来看一下我们在第3章创建的组织记录：
- en: '[PRE42]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are three object classes for this entry:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个条目有三个对象类：
- en: '`top`—an abstract object class'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`—一个抽象对象类'
- en: '`dcObject`—an auxiliary object class'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dcObject`—一个辅助对象类'
- en: '`organization`—a structural object class'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`organization`—一个结构性对象类'
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `top` object class is not strictly necessary in this entry. SLAPD implicitly
    includes `top` in all entries, since all structural object classes derive from
    it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`对象类在此条目中并非严格必要。SLAPD会隐式地将`top`包括在所有条目中，因为所有结构性对象类都源自它。'
- en: How do we know which object classes are of which type? The schema definitions
    for these object classes are the primary source of such information.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道哪些对象类属于哪种类型？这些对象类的模式定义是此类信息的主要来源。
- en: The structural object class locates this entry in the hierarchy of object classes,
    a hierarchy composed of abstract and structural object classes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 结构性对象类将该条目定位在对象类的层级结构中，这个层级由抽象对象类和结构性对象类组成。
- en: An entry may have more than one structural object class as long as they are
    all related by superior/subordinate relationships.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一个条目可以有多个结构性对象类，只要它们之间存在上级/下级关系。
- en: In the case where there are multiple structural object classes in one record,
    the most subordinate object class (the one farthest from the root object class,
    `top`) will have all of the rest of the structural object classes as ancestors.
    That is, for the object class farthest from `top` in the object class hierarchy,
    all other structural object classes must be superior to it. This lowest object
    class is then treated as the structural object class.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个记录中有多个结构性对象类的情况下，最下级的对象类（距离根对象类`top`最远的那个）将具有所有其他结构性对象类作为祖先。也就是说，对于对象类层级中距离`top`最远的对象类，所有其他结构性对象类必须是它的上级。然后，这个最下级的对象类将被视为结构性对象类。
- en: 'For example, in Chapter 3 we created a record for the user `barbara`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第3章中我们为用户`barbara`创建了一个记录：
- en: '[PRE43]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This user belongs to four object classes. Three of these were explicitly stated
    earlier: `person`, `organizationalPerson`, and `inetOrgPerson`. All three of these
    happen to be structural object classes. The fourth, the `top` object class, is
    implicitly included.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户属于四个对象类。前三个对象类在之前已经明确提到：`person`、`organizationalPerson`和`inetOrgPerson`。这三者恰好都是结构性对象类。第四个对象类是`top`，它是隐式包含的。
- en: 'All four of these object classes are related in the hierarchy. The `top` abstract
    object class sits at the top of the object class hierarchy. The `person` object
    class is directly subordinate to top. That is, the `person` object class definition
    lists `top` as its parent:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个对象类在层级结构中是相关的。`top`抽象对象类位于对象类层级的顶端。`person`对象类直接从属于`top`。也就是说，`person`对象类的定义将`top`列为其父类：
- en: '[PRE44]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'While `person` points to `top` as its superior, `organizationalPerson` points
    to `person`. And `inetOrgPerson` points to `organizationalPerson` as its superior.
    Thus, we get a hierarchy of object classes:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`person`指向`top`作为它的上级，`organizationalPerson`指向`person`，而`inetOrgPerson`指向`organizationalPerson`作为它的上级。因此，我们得到了一个对象类的层级结构：
- en: '![abstract object classworking ofStructural Object Classes](img/1021_06_04.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![抽象对象类与结构性对象类的工作原理](img/1021_06_04.jpg)'
- en: 'So, according to this hierarchy, any entry that is an `inetOrgPerson` must
    also abide by definitions of all of its superiors: `organizationalPerson`, `person`,
    and `top`. Any required attributes of any of those object classes will be required
    for an `inetOrgPerson` entry, and any optional attributes for any of those classes
    is optional for an `inetOrgPerson` entry.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据这个层级结构，任何作为`inetOrgPerson`的条目必须遵守其所有上级定义：`organizationalPerson`、`person`和`top`。这些对象类的任何必需属性都将是`inetOrgPerson`条目的必需属性，任何这些类的可选属性对于`inetOrgPerson`条目来说是可选的。
- en: Thus, the required fields for `inetOrgPerson` are `sn` and `cn`, both of which
    it gets from the `person` object class, and the `objectclass` attribute, which
    it inherits from `top`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`inetOrgPerson`的必需字段是`sn`和`cn`，这两个字段分别来自`person`对象类，`objectclass`属性来自`top`。
- en: Note
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of fields required by and allowed by `inetOrgPerson`, see
    the subsection *Adding* *User* *Records* in Chapter 3.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`inetOrgPerson`所需和允许的字段的完整列表，请参见第3章中*添加* *用户* *记录*的子节。
- en: In the previous figure, the `pilotPerson` object class is also included, which
    represents another branch of the hierarchy. Like `organizationalPerson` and `inetOrgPerson`,
    `pilotPerson` describes a person within an organization, but it includes a number
    of attributes not present in `organizationalPerson` and `inetOrgPerson`, including
    the `favouriteDrink` and `janetMailBox` attributes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，还包括了`pilotPerson`对象类，它表示层次结构的另一个分支。与`organizationalPerson`和`inetOrgPerson`一样，`pilotPerson`描述了组织中的一个人，但它包含了一些`organizationalPerson`和`inetOrgPerson`中没有的属性，包括`favouriteDrink`和`janetMailBox`属性。
- en: While `pilotPerson` is not officially obsolete, it is not usually used; `inetOrgPerson`
    is typically used instead. But like `organizationalPerson`, `pilotPerson` lists
    `person` as its superior. Thus, it inherits the attributes of `person` and `top`.
    However, it is not related, directly or indirectly, to `organizationalPerson`
    or `inetOrgPerson`, and thus inherits none of their attributes.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`pilotPerson`并未正式废弃，但它通常不被使用；通常使用的是`inetOrgPerson`。但是，像`organizationalPerson`一样，`pilotPerson`将`person`列为其上级。因此，它继承了`person`和`top`的属性。然而，它与`organizationalPerson`或`inetOrgPerson`没有直接或间接关系，因此不会继承它们的任何属性。
- en: 'Because `pilotPerson` is not related to `organizationalPerson` or `inetOrgPerson`,
    and because all of these are structural object classes, SLAPD will not allow any
    record to implement the `pilotPerson` object class and `organizationalPerson`
    or its subordinates. For example, if we try to add a record with all four of the
    person-describing object classes, we will get an error:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`pilotPerson`与`organizationalPerson`或`inetOrgPerson`没有关系，并且这些都是结构化对象类，SLAPD
    不允许任何记录实现`pilotPerson`对象类与`organizationalPerson`或其子类的组合。例如，如果我们尝试添加包含所有四个描述人的对象类的记录，我们会得到一个错误：
- en: '[PRE45]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When the client requests that the record above be added, SLAPD responds with
    an **Object class violation** error, indicating that the chain of object classes
    is not correct. This is because `pilotPerson` is not related to `organizationalPerson`
    or `inetOrgPerson`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求添加上述记录时，SLAPD 会返回**对象类违规**错误，表明对象类链不正确。这是因为`pilotPerson`与`organizationalPerson`或`inetOrgPerson`没有关系。
- en: 'Returning to our record for `uid=barbara`, that entry lists three object classes:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`uid=barbara`记录，该条目列出了三个对象类：
- en: '[PRE46]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we saw in the previous figure, `inetOrgPerson` is the lowest object class
    on the hierarchy—the far most from `top`. That means that SLAPD considers this
    object class to be the structural object class for the record. It even sets a
    special operational attribute, `structuralObjectClass`, that stores this value.
    Thus, you can get information on the structural object class through `ldapsearch`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图中看到的，`inetOrgPerson`是层次结构中最低的对象类——最远离`top`的对象类。这意味着 SLAPD 将此对象类视为记录的结构化对象类。它甚至设置了一个特殊的操作属性`structuralObjectClass`，用来存储此值。因此，你可以通过`ldapsearch`获取有关结构化对象类的信息：
- en: '[PRE47]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the information:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关信息：
- en: '[PRE48]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When handling operations and evaluating rules, such as DIT content rules, SLAPD
    will treat this record as an `inetOrgPerson` record.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理操作和评估规则时，如 DIT 内容规则，SLAPD 会将此记录视为`inetOrgPerson`记录。
- en: 'Within this discussion of structural object classes we have covered the gist
    of the object class hierarchy. An entry''s place in the hierarchy is determined
    by its structural object class. But not all object classes affect a record''s
    placement in the object class hierarchy. Let''s turn to the third type of object
    class: auxiliary object classes.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，我们已经涵盖了对象类层次结构的要点。一个条目在层次结构中的位置由其结构化对象类决定。但并非所有对象类都会影响记录在对象类层次结构中的位置。让我们来看看第三种类型的对象类：辅助对象类。
- en: Auxiliary Object Classes
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 辅助对象类
- en: Auxiliary object classes provide a mechanism for adding one or more attributes
    to an entry with an existing structural object class. Think of it as a modular
    system for defining a collection of related attributes that can be attached to
    otherwise (conceptually) unrelated object classes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助对象类提供了一种机制，可以向具有现有结构化对象类的条目添加一个或多个属性。可以将其视为一种模块化系统，用于定义一组相关的属性集合，这些属性可以附加到其他（在概念上）不相关的对象类。
- en: 'To get an idea of how this works let''s take another look at the `uid=authenticate`
    entry:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解其工作原理，我们再看一遍`uid=authenticate`条目：
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The structural object class for this entry is `account`. The `simpleSecurityObject`
    object class is auxiliary.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 该条目的结构化对象类是`account`。`simpleSecurityObject`对象类是辅助对象类。
- en: 'The `account` schema, found in `cosine.schema`, looks like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`account`模式，位于`cosine.schema`中，类似于：'
- en: '[PRE50]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This entry, according to the COSINE standard (RFC 4524), is to define a system
    account on a computer.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 根据COSINE标准（RFC 4524），此条目用于在计算机上定义一个系统账户。
- en: For whatever reason, the creators of the standard did not include the attributes
    necessary to give the account a password. This makes sense. It is probably not
    typical that a system account would need to authenticate against LDAP. However,
    the system account we have created needs to perform directory operations and so
    we need this account to have a `userPassword` attribute.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 无论出于什么原因，标准的创建者没有包括赋予账户密码所需的属性。这是有道理的。系统账户通常不需要通过LDAP进行身份验证。然而，我们创建的系统账户需要执行目录操作，因此我们需要该账户具有`userPassword`属性。
- en: 'One way to achieve this is to create a new structural object class subordinate
    to account, but which requires a `userPassword` attribute. But there is also an
    object class in `core.schema` designed specifically for the purpose of giving
    non-person entries in the directory a `userPassword` to allow them to bind. In
    other words, there is an existing object class that provides exactly the functionality
    we require: the `simpleSecurityObject` object class.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方法是创建一个新的结构化对象类，作为账户的下级，但需要一个`userPassword`属性。但在`core.schema`中也有一个专门用于给目录中的非个人条目提供`userPassword`以便允许它们绑定的对象类。换句话说，已经存在一个提供我们所需功能的对象类：`simpleSecurityObject`对象类。
- en: Note
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `simpleSecurityObject` is also defined in the COSINE schema.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleSecurityObject`也在COSINE模式中定义。'
- en: 'The `simpleSecurityObject` schema looks like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`simpleSecurityObject`模式定义如下：'
- en: '[PRE51]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This schema definition adds one required attribute to any implementing entry,
    `userPassword`. Effectively then, the `simpleSecurityObject` object class can
    be added to an entry in order to allow it to bind to the directory (assuming the
    ACLs allow).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式定义向任何实现的条目添加了一个必需的属性：`userPassword`。因此，`simpleSecurityObject`对象类可以添加到条目中，以允许它绑定到目录（假设ACLs允许）。
- en: 'Given the combination of the structural object class, `account`, and the auxiliary
    object class, `simpleSecurityObject`, our `uid=authenticate` record now has three
    required fields:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 结合`account`结构化对象类和`simpleSecurityObject`辅助对象类，我们的`uid=authenticate`记录现在有三个必需字段：
- en: '`objectclass`, inherited from `top`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectclass`，继承自`top`'
- en: '`uid`, from the `account` structural object class'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid`，来自`account`结构化对象类'
- en: '`userPassword`, from the `simpleSecurityObject` auxiliary object class.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userPassword`，来自`simpleSecurityObject`辅助对象类。'
- en: This example illustrates how the auxiliary object class can be used to add additional
    attributes to an entry that already belongs to a structural object class.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了如何使用辅助对象类向已经属于结构化对象类的条目添加额外的属性。
- en: Rather than creating new structural object classes for each set of attributes
    you want an entry to have, the auxiliary object class mechanism makes it possible
    to define a modular collection of add-on attributes that can be attached to entries
    as needed.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每组属性创建新的结构化对象类，不如使用辅助对象类机制，它可以定义一个模块化的附加属性集合，根据需要将这些属性附加到条目中。
- en: By default, any auxiliary object class can be added to a record regardless of
    the structural object class of that record.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，可以向记录中添加任何辅助对象类，而不管该记录的结构化对象类是什么。
- en: In other words, by default it is legal to take an entry with a `person` structural
    object class (an entry obviously intended to represent a human being) and attach
    to it the `javaSerializedObject` auxiliary object class (an entry intended to
    describe a stored representation of a Java binary class).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，默认情况下，将具有`person`结构化对象类（显然是用于表示一个人的条目）的条目与`javaSerializedObject`辅助对象类（用于描述Java二进制类的存储表示的条目）连接起来是合法的。
- en: Historically, the responsibility for judiciously choosing which auxiliary object
    classes ought to be added to an entry has been left to LDAP client applications
    and users. However, you can use DIT content rules (see the previous part of this
    chapter) to formalize which auxiliary object classes an entry of a given structural
    object class is allowed to have.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，合理选择应当添加到条目的辅助对象类的责任一直由LDAP客户端应用程序和用户负责。然而，你可以使用DIT内容规则（请参见本章前面部分）来正式化给定结构化对象类的条目允许具备哪些辅助对象类。
- en: Moving Onward
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续前进
- en: Up to this point, this chapter has focused on the details of the LDAP schema
    system, and has focused as much on theoretical points as it has on practice.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章主要关注 LDAP 模式系统的细节，理论与实践并重。
- en: In these pages, I have tried to provide a condensed explanation of LDAP schemas,
    focusing on the aspects most applicable to the goals of this book. This material
    should provide the necessary background knowledge for reading schema definitions,
    wisely selecting which schemas to use for your own directory needs, and writing
    custom schemas.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些页面中，我尝试提供关于 LDAP 模式的简明解释，重点关注最适用于本书目标的方面。这些材料应该提供阅读模式定义、明智选择适合自己目录需求的模式以及编写自定义模式所需的背景知识。
- en: However, if you intend to work on the OpenLDAP code, write overlays or modules,
    or even write schemas intended for public standardization, you ought to read the
    LDAP RFCs, particularly RFC 4512, which defines the LDAP schema language.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你打算在 OpenLDAP 代码上进行工作，编写覆盖模块或模块，甚至编写旨在进行公共标准化的模式，你应该阅读 LDAP 的 RFC，特别是 RFC
    4512，它定义了 LDAP 模式语言。
- en: Now we are ready to move on to more practical matters. In the next section,
    we will implement a few overlays that require extra schemas. As we configure those
    overlays we will examine the schemas and the role those schemas play in the functioning
    of the overlay.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备继续处理更实际的事务。在下一节中，我们将实现一些需要额外模式的覆盖模块。在配置这些覆盖模块时，我们将检查模式及其在覆盖模块功能中所扮演的角色。
- en: After that, we will create our own short schema.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建我们自己的简短模式。
- en: 'Schemas: Accesslog and Password Policy Overlays'
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式：Accesslog 和密码策略覆盖模块
- en: In the last chapter we saw OpenLDAP's overlay technology, and we implemented
    a few simple overlays. In this chapter we have seen how LDAP schemas work. Now
    we are going to take a look at a few overlays that require custom schemas.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了 OpenLDAP 的覆盖模块技术，并实现了一些简单的覆盖模块。在本章中，我们了解了 LDAP 模式是如何工作的。现在我们将看看几个需要自定义模式的覆盖模块。
- en: The two overlays that we will examine are the `accesslog` overlay and the `ppolicy`
    (Password Policy) overlay.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的两个覆盖模块是 `accesslog` 覆盖模块和 `ppolicy`（密码策略）覆盖模块。
- en: Because they require their own schemas, and because each provides a robust feature
    set, these two overlays have a more complicated configuration. However, since
    the basic concepts are familiar already, we will move quickly.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们需要自己的模式，并且每个模式都提供强大的功能集，这两个覆盖模块的配置更为复杂。然而，由于基本概念已经熟悉，我们将快速进行。
- en: Logging with the Accesslog Overlay
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Accesslog 覆盖模块进行日志记录
- en: The Access Logging overlay (`accesslog`) extends the logging abilities of the
    SLAPD server. First, it makes it possible to track client access to the directory
    server. Second, it stores this logging data within the directory, making it possible
    to retrieve access logs from any authorized LDAP client.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 访问日志覆盖模块（`accesslog`）扩展了 SLAPD 服务器的日志记录能力。首先，它使得能够跟踪客户端对目录服务器的访问。其次，它将这些日志数据存储在目录中，使得任何授权的
    LDAP 客户端都可以检索访问日志。
- en: Since it stores information inside of the directory server, and since the format
    for access log entries is not already described in any of the familiar schemas,
    the access logging overlay needs its own schema.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它将信息存储在目录服务器内，并且由于访问日志条目的格式在任何已知的模式中尚未描述，因此访问日志覆盖模块需要自己的模式。
- en: The access log schema is still considered experimental, and has not yet been
    finalized. Nor is it included in the schema directory (`/etc/ldap/schema` or `/usr/local/etc/openldap/schema`).
    The object classes are defined in the man page (`man` `slapo-accesslog`).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 访问日志模式仍然被视为实验性，尚未最终确定。它也未包含在模式目录（`/etc/ldap/schema` 或 `/usr/local/etc/openldap/schema`）中。对象类在手册页（`man`
    `slapo-accesslog`）中定义。
- en: However, the access log overlay automatically loads its own schema, so there
    is no manual schema configuration to be done.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，访问日志覆盖模块会自动加载其自己的模式，因此不需要手动配置模式。
- en: 'The process of installing the `accesslog` is of four steps:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `accesslog` 的过程分为四个步骤：
- en: Load the `accesslog` module
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `accesslog` 模块
- en: Configure the `accesslog` backend section
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置 `accesslog` 后端部分
- en: Create a database to store the access log
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据库来存储访问日志
- en: Configure the directory backend to log to the new database
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置目录后端以将日志写入新的数据库
- en: Loading the accesslog Module
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 accesslog 模块
- en: 'By now, this step should be familiar. Along with the other `moduleload` statements
    at the top of `slapd.conf`, we need to add one to load the `accesslog` module:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这一步应该已经很熟悉了。和`slapd.conf`文件顶部的其他`moduleload`语句一起，我们需要添加一条来加载`accesslog`模块：
- en: '[PRE52]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When SLAPD is restarted the `accesslog` module, which contains the `accesslog`
    overlay, will be loaded.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当SLAPD重新启动时，包含`accesslog`覆盖模块的`accesslog`模块将被加载。
- en: Configuring the Access Log Backend
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置访问日志后台
- en: The `accesslog` overlay needs a location within the directory server to write
    the access information. We will create an extra database backend that will hold
    the logging data.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`accesslog`覆盖模块需要在目录服务器中有一个位置来写入访问信息。我们将创建一个额外的数据库后台来存储日志数据。'
- en: 'There is nothing particularly special about this backend. It functions just
    like any other, and we will use the standard set of configuration directives.
    But there is one catch to implementing `accesslog`: the database where the access
    logs are stored must appear in `slapd.conf` *before* the database that it is going
    to record access data about.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个后台并没有什么特别之处。它的功能与其他后台一样，我们将使用标准的配置指令集。但实现`accesslog`时有一个要注意的地方：存储访问日志的数据库必须出现在`slapd.conf`中*在*将要记录访问数据的数据库之前。
- en: 'We want to log access to our first database (the one with suffix `dc=example,dc=com`),
    so we need to insert the configuration directives for the access log before the
    `dc=example,dc=com` database. Here''s the beginning of the original Example.Com
    database definition:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望记录对第一个数据库（即后缀为`dc=example,dc=com`的数据库）的访问日志，因此需要在`dc=example,dc=com`数据库之前插入访问日志的配置指令。以下是原始Example.Com数据库定义的开头部分：
- en: '[PRE53]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will insert our access log configuration above the `database` directive
    in the previous example:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把访问日志的配置插入到之前示例中的`database`指令上方：
- en: '[PRE54]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The highlighted section is the definition for the access log database.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分是访问日志数据库的定义。
- en: As with the other databases, this one uses the HDB backend. The suffix for our
    logging directory will simply be `cn=log`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他数据库一样，这个数据库使用HDB后台。我们的日志目录的后缀将仅为`cn=log`。
- en: Each logging event will be stored as an LDAP record, and each entry in the logging
    directory will have a DN composed of two attributes. The RDN is the `reqStart`
    attribute (which contains the timestamp indicating when the request started),
    and ends with the suffix which, in our case, is `cn=log`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志事件将作为LDAP记录存储，并且日志目录中的每一条记录都会有一个由两个属性组成的DN。RDN是`reqStart`属性（该属性包含表示请求开始时间的时间戳），并以后缀结尾，在我们的案例中是`cn=log`。
- en: This database also has its own manager account and password (`rootdn` and `rootpw`).
    The Berkeley DB files will be stored at `/var/lib/ldap/accesslog`—a directory
    we will create on the file system in the next step.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据库还拥有自己的管理帐户和密码（`rootdn`和`rootpw`）。Berkeley DB文件将存储在`/var/lib/ldap/accesslog`目录中——我们将在下一步中在文件系统上创建该目录。
- en: Finally, the `index` directive configures an equality (`eq`) index for the `reqStart`
    attribute, which is the attribute SLAPD uses to create DNs. It uses this attribute
    when performing maintenance operations, so it is a good idea to have this attribute
    indexed.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`index`指令为`reqStart`属性配置了一个相等（`eq`）索引，这个属性是SLAPD用来创建DN的属性。在执行维护操作时，SLAPD会使用这个属性，因此为这个属性建立索引是个好主意。
- en: There are a few more things to do in `slapd.conf`. But before doing those, we
    will create a directory for the Berkeley DB files.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在`slapd.conf`中还需要做几件事。但在进行这些之前，我们将为Berkeley DB文件创建一个目录。
- en: Creating A Directory for the Access Log Files
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为访问日志文件创建目录
- en: Like the other HDB databases, this new database needs a location on the server's
    file system to store Berkeley DB database files. In the earlier configuration,
    we pointed SLAPD to the directory `/var/lib/ldap/accesslog`. Now, we need to create
    that directory and configure it for a Berkeley DB environment.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他HDB数据库一样，这个新数据库也需要一个存储Berkeley DB数据库文件的服务器文件系统位置。在之前的配置中，我们已经将SLAPD指向了`/var/lib/ldap/accesslog`目录。现在，我们需要创建这个目录并为Berkeley
    DB环境配置它。
- en: 'The first thing to do is create the new directory. From a shell this can be
    done easily:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要做的就是创建新目录。在shell中，可以轻松地完成这项操作：
- en: '[PRE55]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From there, all we need to do is copy the `DB_CONFIG` to the new `accesslog/`
    directory:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要将`DB_CONFIG`复制到新的`accesslog/`目录中：
- en: '[PRE56]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Depending on the traffic on your server and the amount of data you are logging,
    you may want to increase or decrease the cache size allocated in `DB_CONFIG`.
    See the discussion in the previous chapter for more information on tuning the
    `DB_CONFIG` file.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你服务器的流量和你记录的数据量，你可能需要增加或减少在 `DB_CONFIG` 中分配的缓存大小。有关如何调优 `DB_CONFIG` 文件的更多信息，请参见上一章的讨论。
- en: Note
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Check the DB_CONFIG files**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查 DB_CONFIG 文件**'
- en: The `DB_CONFIG` file we created in the last chapter did not have any absolute
    references to locations on the file system. But some directives in the `DB_CONFIG`
    file (like `set_lg_dir`) might have absolute path references, which could result
    in two databases using the same log. That would have catastrophic consequences.
    Make sure you adjust the `DB_CONFIG` file accordingly.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章创建的 `DB_CONFIG` 文件没有任何对文件系统位置的绝对引用。但 `DB_CONFIG` 文件中的某些指令（如 `set_lg_dir`）可能会有绝对路径引用，这可能导致两个数据库使用相同的日志。那样会导致灾难性的后果。确保根据需要调整
    `DB_CONFIG` 文件。
- en: Make sure that the new `accesslog/` directory is readable and writable for the
    user account that runs the SLAPD process, and also make sure that that user can
    read the `DB_CONFIG` file.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 确保新的 `accesslog/` 目录对运行 SLAPD 进程的用户账户是可读写的，并且确保该用户可以读取 `DB_CONFIG` 文件。
- en: Enabling Logging for the Main Backend
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为主后端启用日志记录
- en: Now we have the logging environment set up. The next thing to do is configure
    our `dc=example,dc=com` backend to start using the new logging backend.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了日志记录环境，接下来的工作是配置我们的 `dc=example,dc=com` 后端开始使用新的日志记录后端。
- en: 'Back in `slapd.conf`, we need to add some new overlay-specific directives inside
    of the `dc=example,dc=com` backend. These directives must come after the database
    definition for the Example.Com database:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `slapd.conf`，我们需要在 `dc=example,dc=com` 后端中添加一些新的特定于覆盖层的指令。这些指令必须放在 Example.Com
    数据库的数据库定义之后：
- en: '[PRE57]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first directive, `overlay` `accesslog`, loads the access logging overlay
    within the context of this particular database. The next five directives are the
    accesslog-specific directives.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令 `overlay` `accesslog` 在这个特定数据库的上下文中加载了访问日志覆盖层。接下来的五个指令是与访问日志相关的特定指令。
- en: The `logdb` directive is the only one required by the `accesslog` overlay. All
    the rest are optional.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`logdb` 指令是 `accesslog` 覆盖层所必需的，其他的都是可选的。'
- en: The `logdb` directive specifies which database will be treated as an access
    log. In our case we want to use the `cn=log` database. For a site hosting multiple
    directory information trees, separate logging databases could be set up for each
    suffix.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`logdb` 指令指定了哪个数据库将被用作访问日志。在我们的例子中，我们希望使用 `cn=log` 数据库。对于托管多个目录信息树的网站，可以为每个后缀设置单独的日志数据库。'
- en: 'The `logops` directive is used to specify exactly which LDAP operations should
    be logged. In this example, the keyword `all` indicates that all operations will
    be logged. But the following options are supported:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`logops` 指令用于精确指定哪些 LDAP 操作应该被记录。在这个例子中，关键字 `all` 表示所有操作都会被记录。但以下选项也被支持：'
- en: 'Any operation can be specified by name: `add`, `delete`, `modify`, `modrdn`,
    `search`, `compare`, `extended`, `bind`, `unbind`, and `abandon`.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以按名称指定任何操作：`add`，`delete`，`modify`，`modrdn`，`search`，`compare`，`extended`，`bind`，`unbind`
    和 `abandon`。
- en: 'There are a few special keywords that include a collection of operations. These
    are:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些特殊的关键字包含了一组操作，它们是：
- en: '`read` (search, compare)'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`（搜索，比较）'
- en: '`write` (add, delete, modify, modrdn)'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`（添加，删除，修改，modrdn）'
- en: '`session` (bind, unbind, abandon)'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session`（绑定，解除绑定，放弃）'
- en: There is the `all` keyword, which includes all operations.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个 `all` 关键字，表示包含所有操作。
- en: More than one value can be placed on a `logops` line. Values should be separated
    by an empty space. For example, `logops` `modify` `modrdn` will log all modify
    and modrdn operations.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`logops` 行可以放置多个值，值之间应以空格分隔。例如，`logops` `modify` `modrdn` 会记录所有的 modify 和 modrdn
    操作。'
- en: 'The `logold` ("log old") directive takes a search filter. When a delete or
    modify operation is successfully executed, then `accesslog` will check to see
    if the record matches the filter. If it does match, then `accesslog` will store
    a complete record of the change, including what attributes were added, and what
    attributes were changed or removed. For example, when I modified a user with the
    `ldapmodify` command-line tool, an entry detailing the changes was written to
    the accesslog directory information tree:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`logold`（“日志旧”）指令带有搜索过滤器。当删除或修改操作成功执行时，`accesslog`将检查记录是否匹配该过滤器。如果匹配，`accesslog`将存储该变更的完整记录，包括添加了哪些属性，哪些属性被更改或删除。例如，当我使用`ldapmodify`命令行工具修改用户时，访问日志目录信息树中会写入一条详细变更的记录：'
- en: '[PRE58]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `reqMod` values show the new modifications, while the `reqOld` attribute
    values show the old lines. Note that two lines were added (the object class and
    the `labeledURI`), and two were changed (`modifiersName`, `modifyTimestamp`).
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`reqMod`值显示新的修改，而`reqOld`属性值显示旧的条目。请注意，添加了两行（对象类和`labeledURI`），而两行发生了更改（`modifiersName`，`modifyTimestamp`）。'
- en: Why use `logold`? It may not be particularly useful for log evaluation but,
    when combined with SyncRepl, synchronization between SLAPD servers can be done
    more efficiently. (This form of SyncRepl is called **Delta-SyncRepl**.) If you
    are not using SyncRepl, you probably won't want to use `logold` at all. We will
    discuss SyncRepl (and Delta-SyncRepl) in detail in the next chapter.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要使用`logold`？它可能对日志评估没有特别大的用处，但当与SyncRepl结合使用时，SLAPD服务器之间的同步可以更高效地完成。（这种形式的SyncRepl称为**Delta-SyncRepl**。）如果你没有使用SyncRepl，可能根本不需要使用`logold`。我们将在下一章详细讨论SyncRepl（以及Delta-SyncRepl）。
- en: 'The `logpurge` directive directs SLAPD to periodically check the access log
    and delete old entries. It takes two parameters that provide the following information:
    how old an entry must be before it is a candidate for being purged, and how long
    of an interval should pass between checking for entries to remove.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`logpurge`指令要求SLAPD定期检查访问日志并删除旧条目。它需要两个参数来提供以下信息：条目多旧时才是删除候选，并且检查删除条目的时间间隔是多久。'
- en: 'The format of the two parameters is the same:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数的格式是相同的：
- en: '[PRE59]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Where number of days and number of seconds are optional fields. Our `logpurge`
    parameter looked like this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 天数和秒数是可选字段。我们的`logpurge`参数如下所示：
- en: '[PRE60]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This indicates that logs seven days old are to be considered for deletion. And
    after running a check, SLAPD will wait the indicated amount of time—two days—before
    checking for new deletions.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示七天前的日志将被视为可以删除的条目。并且在运行检查后，SLAPD将在指定的时间——两天——后再次检查是否有新的删除操作。
- en: The last parameter is `logsuccess`. By default, `accesslog` records all attempted
    operations, whether successful or not. To log only the operations that are successfully
    completed set `logsuccess` to `TRUE`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是`logsuccess`。默认情况下，`accesslog`会记录所有尝试的操作，无论成功与否。若只记录成功完成的操作，请将`logsuccess`设置为`TRUE`。
- en: That's all there is to configuring `accesslog`. SLAPD will need to be restarted
    for the new overlay to be added.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 配置`accesslog`就这么简单。需要重新启动SLAPD以便添加新的覆盖层。
- en: The Log Records
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: Now that we have our new logging overlay running, let's test it out. The first
    step is to generate some logging data. Since we are logging all operations (`logops`
    `all`), any LDAP operation will do.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了新的日志记录覆盖层，让我们测试一下。第一步是生成一些日志数据。因为我们正在记录所有操作（`logops` `all`），所以任何LDAP操作都可以。
- en: 'Here is a simple `ldapsearch`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的`ldapsearch`：
- en: '[PRE61]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This uses a simple bind, and searches for my own record (`uid=matt`), retrieving
    the values for the `mail`, `gn` (given name) and `sn` attributes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了简单的绑定，并搜索我的记录（`uid=matt`），检索`mail`、`gn`（名字）和`sn`属性的值。
- en: 'With a search like this, what is written to the access log? To find out, we
    can use `ldapsearch`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的搜索，访问日志中会写入什么？为了找出答案，我们可以使用`ldapsearch`：
- en: '[PRE62]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output for this command, even with the results of only one command, is
    surprisingly large:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 即便只有一条命令的结果，这个命令的输出也出奇的大：
- en: '[PRE63]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are four different entries returned from the `ldapsearch` and each one
    has a different structural object class. We will look at each in turn.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldapsearch`返回四个不同的条目，每个条目有不同的结构化对象类。我们将依次查看每个条目。'
- en: 'The first LDIF entry it displays is the base record for `cn=log`:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示的第一个LDIF条目是`cn=log`的基础记录：
- en: '[PRE64]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `auditContainer` object class is designed as a sort of general-purpose
    object class for the access log. It''s schema looks like this:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`auditContainer`对象类被设计为一种通用对象类，用于访问日志。它的模式如下所示：'
- en: '[PRE65]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The base record only uses the optional `cn` attribute.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 基本记录只使用了可选的`cn`属性。
- en: 'In the `accesslog` schema there are object classes defined for each LDAP operation:
    `auditAbandon`, `auditAdd`, `auditBind`, `auditCompare`, `auditDelete`, `auditModify`,
    `auditModRDN`, `auditSearch`, and `auditExtended`. In addition, there is a special
    object class called `auditObject` that describes general events.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在`accesslog`模式中，为每个LDAP操作定义了对象类：`auditAbandon`、`auditAdd`、`auditBind`、`auditCompare`、`auditDelete`、`auditModify`、`auditModRDN`、`auditSearch`和`auditExtended`。此外，还有一个名为`auditObject`的特殊对象类，用于描述一般事件。
- en: In fact (in the current version) all of the operation object classes listed
    are subordinates to the `auditObject` object class. Because it is the parent of
    these other object classes, we will begin by looking at the `auditObject` schema
    definition.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上（在当前版本中），所有列出的操作对象类都是`auditObject`对象类的子类。因为它是这些对象类的父类，所以我们将首先查看`auditObject`的模式定义。
- en: 'The `auditObject` object class definition looks like this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`auditObject`对象类的定义如下所示：'
- en: '[PRE66]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The three required attributes are:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的三个属性是：
- en: '`reqStart`:A timestamp indicating the starting time of the operation'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqStart`：表示操作开始时间的时间戳。'
- en: '`reqType`: A string indicating the operation being executed'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqType`：一个字符串，表示正在执行的操作。'
- en: '`reqSession`: The connection ID number used (internally) by SLAPD'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqSession`：SLAPD（内部）使用的连接ID号。'
- en: 'In addition to these required attributes, there are eight optional attributes:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些必需属性外，还有八个可选属性：
- en: '`reqDN`: This records the DN of the record the operation is currently operating
    on.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqDN`：记录操作当前操作的记录的DN。'
- en: '`reqAuthzID`: This records the DN of the user performing the operation. If
    the user is Anonymous the value is left blank.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqAuthzID`：记录执行操作的用户的DN。如果用户是匿名用户，则该值为空。'
- en: '`reqControls` and `reqRespControls`: If the client sets any controls, they
    are indicated here.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqControls`和`reqRespControls`：如果客户端设置了任何控制项，这里会显示。'
- en: '`reqEnd`: This stores the timestamp indicating when the operation was completed.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqEnd`：记录操作完成时的时间戳。'
- en: '`reqResult`: This contains the numeric error code if an error was encountered.
    If the operation is successful this returns `0`.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqResult`：如果操作遇到错误，这里会包含数字错误代码。如果操作成功，则返回`0`。'
- en: '`reqMessage`: If the error code is accompanied by a text message, the message
    is put in this attribute.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqMessage`：如果错误代码伴随有文本消息，则该消息会放入此属性中。'
- en: '`reqReferral`: If the operation returned a referral, the referral is noted
    here.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqReferral`：如果操作返回了引用，这里会记录该引用。'
- en: 'The second entry returned in the search records the client''s bind operation:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的第二个条目记录了客户端的绑定操作：
- en: '[PRE67]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This first entry records the bind operation, and is an instance of the `auditBind`
    object class. The `auditBind` object class is a subordinate of `auditObject`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这一条记录了绑定操作，并且是`auditBind`对象类的一个实例。`auditBind`对象类是`auditObject`的一个子类：
- en: '[PRE68]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It adds two required attributes: `reqVersion`, which records the version of
    LDAP used for the connection and `reqMethod`, which indicates what method was
    used in binding.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了两个必需的属性：`reqVersion`，用于记录用于连接的LDAP版本，以及`reqMethod`，指示在绑定时使用的方法。
- en: Looking at the bind entry, we can see that it records the details of a successful
    bind operation. The start and end times are recorded in `reqStart` and `reqEnd`
    respectively. The `reqType` indicates that the operation performed is a bind operation.
    The `reqSession` indicates the internal ID of the request (which happens to be
    zero because this is the first operation run since we started SLAPD, and connection
    IDs increment starting at `0`).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 看着绑定条目，我们可以看到它记录了成功绑定操作的详细信息。开始和结束时间分别记录在`reqStart`和`reqEnd`中。`reqType`表示执行的操作是一个绑定操作。`reqSession`表示请求的内部ID（由于这是我们启动SLAPD以来的第一次操作，连接ID从`0`开始递增，因此它的值恰好是0）。
- en: Since the bind was performed by the anonymous user, the `reqAuthzID` attribute
    is present, but has no value. The `reqDN` indicates that the client was attempting
    to bind as `uid=matt,ou=users,dc=example,dc=com`, and the `reqResult` of `0` indicates
    that the bind operation was completed successfully. The bottom two attributes
    are the attributes that belong to the `auditBind` object class. The `reqVersion`
    attribute indicates that the client used the LDAPv3 protocol and, according to
    `reqMethod`, the bind was a simple bind.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绑定是由匿名用户执行的，`reqAuthzID` 属性存在，但没有值。`reqDN` 表示客户端正在尝试以 `uid=matt,ou=users,dc=example,dc=com`
    进行绑定，而 `reqResult` 的值为 `0`，表示绑定操作已成功完成。底部的两个属性属于 `auditBind` 对象类。`reqVersion`
    属性表示客户端使用的是 LDAPv3 协议，并且根据 `reqMethod`，该绑定是简单绑定。
- en: 'So, the first operation performed in this LDAP session was a bind. The second
    operation is the search:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这个 LDAP 会话中执行的第一个操作是绑定。第二个操作是搜索：
- en: '[PRE69]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since it describes a search operation, this entry uses the `auditSearch` object
    class, which has the following schema definition:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 由于描述的是搜索操作，因此此条目使用了 `auditSearch` 对象类，其具有以下模式定义：
- en: '[PRE70]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that `auditSearch` is a subordinate not of `auditObject` but of `auditReadObject`,
    another structural object class that is itself subordinate to `auditObject`. In
    other words, `auditSearch` is an indirect subclass of `auditObject`. The `auditReadObject`
    (as of OpenLDAP 2.3.30) does not add any additional attributes.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`auditSearch` 是 `auditObject` 的下属，而不是直接下属，而是 `auditReadObject` 的下属，`auditReadObject`
    是另一个结构性对象类，且它本身是 `auditObject` 的下属。换句话说，`auditSearch` 是 `auditObject` 的间接子类。`auditReadObject`（从
    OpenLDAP 2.3.30 起）并未添加任何额外的属性。
- en: For the most part the attributes inherited from `auditObject` perform in the
    same capacity here as they did in the entry for the bind operation. The `reqAuthzID`
    in this case is the authenticated user's DN, instead of empty, and the `reqDN`
    shows the base DN for the search operation.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，从 `auditObject` 继承的属性在此处执行的作用与绑定操作中的条目相同。此时的 `reqAuthzID` 是已认证用户的 DN，而不是空值，`reqDN`
    显示的是搜索操作的基础 DN。
- en: The next set of attributes provide detailed information about the nature of
    the search request.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组属性提供了有关搜索请求性质的详细信息。
- en: '`reqScope` indicates the scope of the search. `reqDerefAliases` indicates that
    aliased entries (entries mapped to other entries elsewhere in the directory, a
    concept similar to symbolic linking in Linux file systems) are never dereferenced
    during searches. The `reqAttrsOnly` flag indicates that the search did not request
    that only the attribute names be returned. Instead, the names and values were
    to be returned.'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqScope` 表示搜索的范围。`reqDerefAliases` 表示在搜索过程中，别名条目（映射到目录中其他条目的条目，这类似于 Linux
    文件系统中的符号链接）永远不会被解除引用。`reqAttrsOnly` 标志表示搜索没有请求只返回属性名称，而是要求返回名称和值。'
- en: '`reqFilter` contains the LDAP search filter. This is the filter we specified
    on the command line when running the `ldapsearch` command.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqFilter` 包含 LDAP 搜索过滤器。这是我们在运行 `ldapsearch` 命令时在命令行中指定的过滤器。'
- en: '`reqAttr` has three values, `mail`, `gn`, and `sn`, corresponding to the three
    attributes I requested in the `ldapsearch` command. And `reqEntries` indicates
    the total number of matching records found in the directory.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqAttr` 有三个值：`mail`、`gn` 和 `sn`，对应于我在 `ldapsearch` 命令中请求的三个属性。`reqEntries`
    表示在目录中找到的匹配记录的总数。'
- en: '`reqTimeLimit` and `reqSizeLimit` indicate the (soft) size and time limits
    requested in the search.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reqTimeLimit` 和 `reqSizeLimit` 表示搜索中请求的（软）大小和时间限制。'
- en: Taken as a whole, this entry provides a detailed record of what my LDAP search
    was and, from this record alone, it would be trivial to replicate the exact search.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来看，此条目提供了关于我 LDAP 搜索的详细记录，仅凭这一记录，就可以轻松地复制完全相同的搜索。
- en: There is one final (short) entry left, the entry that records the client's unbind.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一条最终的（简短的）条目，记录客户端的解除绑定操作。
- en: '[PRE71]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Since there are no paramters to the unbind operation (just the closing of a
    connection), there is no specific object class to model this event. Instead, the
    `auditObject` object class is used as the structural object class for this entry.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解除绑定操作没有参数（只是关闭连接），因此没有特定的对象类来表示这一事件。相反，`auditObject` 对象类被用作此条目的结构性对象类。
- en: When clients perform other kinds of LDAP operations, such as additions and modifications,
    different object classes will be used. The object class definitions (and attribute
    definitions) can be found in the `cn=sucbschema` record. See the earlier section
    *Retrieving* *the* *Schema* *from* *SLAPD* for information on how to do this.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端执行其他类型的LDAP操作（如添加和修改）时，将使用不同的对象类。对象类定义（和属性定义）可以在`cn=sucbschema`记录中找到。有关如何执行此操作的信息，请参见前面的章节*从SLAPD检索架构*。
- en: Now we have finished looking at the `accesslog` overlay. This overlay can come
    in use not only for record keeping but for debugging troublesome issues, discovering
    which attributes would most benefit form indexing, and even adding performance-enhancing
    functionality to directory replication. In the next section, we will look at the
    password policy overlay.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了对`accesslog`覆盖层的学习。这个覆盖层不仅在记录保持方面有用，还能在调试问题时帮助发现哪些属性最适合索引，甚至为目录复制添加性能增强功能。在下一章节中，我们将讨论密码策略覆盖层。
- en: 'Implementing a Complex Overlay: Password Policy'
  id: totrans-554
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现复杂覆盖层：密码策略
- en: One of the proposed extensions to LDAP is a standardized method for implementing
    password policies in an LDAP directory. The Password Policy (`ppolicy`) overlay
    implements the "Password Policy for LDAP Directories" IETF draft, which is likely
    to soon become an RFC.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP的一个提议扩展是为在LDAP目录中实现密码策略提供标准化的方法。密码策略（`ppolicy`）覆盖层实现了“LDAP目录的密码策略”IETF草案，该草案可能很快成为RFC。
- en: A password policy provides account aging, password expirations, password strength
    checking, grace logins, and a variety of other password maintenance services.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略提供账户老化、密码过期、密码强度检查、宽限登录和多种其他密码维护服务。
- en: How does this work in OpenLDAP? Password policy information is stored inside
    of the directory information tree in records described by a specialized schema.
    The `ppolicy` overlay monitors connections, updating password information and
    enforcing the password policy as appropriate.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 这在OpenLDAP中是如何工作的？密码策略信息存储在目录信息树内的记录中，这些记录由专门的架构描述。`ppolicy`覆盖层监控连接，更新密码信息并根据需要强制执行密码策略。
- en: Note
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Password policies operate on the `userPassword` attribute. That means that if
    you use SASL and store the passwords outside of the directory information tree
    (in a place such as the `sasldb`), then the `ppolicy` overlay will not function.
    In this chapter we will be using simple binding.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略作用于`userPassword`属性。这意味着，如果你使用SASL并将密码存储在目录信息树之外（如存储在`sasldb`中），那么`ppolicy`覆盖层将无法起作用。在本章中，我们将使用简单绑定。
- en: The password policy schema defines the object class, `pwdPolicy`, that is implemented
    by password policy entries. There are no object classes for user records. Instead,
    operational attributes (attributes used internally by SLAPD) are used to store
    password policy information in user records. These operational attributes are
    used to store internal information (such as when a user last changed the password),
    and usually managed solely by the `ppolicy` overlay.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略架构定义了由密码策略条目实现的对象类`pwdPolicy`。没有用于用户记录的对象类。相反，操作属性（SLAPD内部使用的属性）用于存储用户记录中的密码策略信息。这些操作属性用于存储内部信息（例如用户上次更改密码的时间），通常仅由`ppolicy`覆盖层管理。
- en: The password policy extension has many features, all documented in the man page,
    as well as in the IETF draft standard. Since the draft has not been finalized,
    and is still in a state of change, this module is marked as experimental. New
    features may be added, or current features altered or even removed, as the standard
    changes. But the experimental categorization does not reflect on the stability
    of the code. Administrators of large systems have reported this module to be production
    quality.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 密码策略扩展具有许多功能，所有这些都在手册页中记录，也在IETF草案标准中说明。由于该草案尚未最终确定，并且仍在变化中，因此此模块被标记为实验性。随着标准的变化，可能会添加新功能，或者当前功能可能会被修改甚至移除。但实验性分类并不反映代码的稳定性。大型系统的管理员报告称，该模块具有生产质量。
- en: 'Because of the wealth of features, the `ppolicy` overlay is not a quick and
    easy install. It will require the following steps:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 由于功能丰富，`ppolicy`覆盖层并非一个快速简单的安装过程。它需要以下步骤：
- en: Include the password policy schema and load the module
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括密码策略架构并加载模块
- en: Create a password policy
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建密码策略
- en: Configure the `ppolicy` overlay
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`ppolicy`覆盖层
- en: Once the password policy overlay is implemented, we will do some testing.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密码策略覆盖层实现完成，我们将进行一些测试。
- en: 'Setting the Global Directives in slapd.conf: Schema and Module'
  id: totrans-567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在slapd.conf中设置全局指令：模式和模块
- en: The first thing we need to do is configure the global (basic) section of the
    `slapd.conf` file. As with the other overlays we will need to load the `ppolicy`
    module. And since we are using a new schema—one stored in the `schema/` directory—we
    will need to include that too.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是配置`slapd.conf`文件的全局（基础）部分。像其他覆盖层一样，我们需要加载`ppolicy`模块。由于我们使用的是存储在`schema/`目录中的新模式，我们还需要将其包含进来。
- en: 'Since the directives are close together, we can look at both additions at once:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指令很接近，我们可以一起查看两个添加项：
- en: '[PRE72]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The two highlighted lines show the necessary changes:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行高亮显示的内容展示了必要的更改：
- en: The highlighted `include` directive imports the `ppolicy.schema` file into the
    configuration
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示的`include`指令将`ppolicy.schema`文件导入配置中。
- en: The `moduleload` directive loads the `ppolicy` module
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moduleload`指令加载`ppolicy`模块'
- en: 'In step 3 we come back to the `slapd.conf` file and make a few more changes,
    but next we need to create a password policy and load it into the directory. That
    will require restarting SLAPD to pick up the new schema definitions:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们回到`slapd.conf`文件并进行一些进一步的更改，接下来我们需要创建密码策略并将其加载到目录中。这将需要重新启动SLAPD以应用新的模式定义：
- en: '[PRE73]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Creating a Password Policy
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建密码策略
- en: This step is more demanding than the previous. Our goal is to load a new password
    policy into the directory. To do this, we will need to get acquainted with the
    `pwdPolicy` object class in the `ppolicy` schema, create the requisite LDIF entries
    for our directory information tree, and then load these into the directory with
    `ldapadd`.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步比之前的更具挑战性。我们的目标是将新的密码策略加载到目录中。为此，我们需要了解`ppolicy`模式中的`pwdPolicy`对象类，创建所需的LDIF条目，并使用`ldapadd`将这些条目加载到目录中。
- en: The `pwdPolicy` object class contains a number of attributes that can be used
    for storing information about a password policy. A password policy is a set of
    conditions determining what constraints will be placed on password usage within
    the LDAP server.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdPolicy`对象类包含多个属性，用于存储有关密码策略的信息。密码策略是一组条件，用于确定在LDAP服务器中对密码使用施加哪些约束。'
- en: 'Here is the schema for the `pwdPolicy` object class:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`pwdPolicy`对象类的模式：
- en: '[PRE74]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This object class is an auxiliary object class so, when we create an entry to
    hold the policy, it will need a structural object class.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象类是一个辅助对象类，因此，在创建存储策略的条目时，它需要一个结构性对象类。
- en: 'There is only one required attribute for `pwdPolicy`: `pwdAttribute`. The value
    of this attribute should be set to the OID of the attribute used for password
    storage. Since the schema is part of a proposed standard, the purpose of this
    attribute is to make it possible for different directory servers to all use the
    same schema (since different directory server implementations use different attributes
    for storing password values). However, for OpenLDAP''s SLAPD, the only attribute
    that can be used here is the OID for `userPassword`, which is `2.5.4.35`.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdPolicy`只有一个必需的属性：`pwdAttribute`。该属性的值应设置为用于存储密码的属性的OID。由于该模式是提议的标准的一部分，这个属性的目的是使不同的目录服务器能够使用相同的模式（因为不同的目录服务器实现使用不同的属性来存储密码值）。然而，对于OpenLDAP的SLAPD，唯一可以在此使用的属性是`userPassword`的OID，值为`2.5.4.35`。'
- en: Note
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `authPassword` attribute, defined in RFC 3112, is a candidate for replacing
    `userPassword` in future versions of OpenLDAP. However, at this time it is not
    completely implemented.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 3112中定义的`authPassword`属性是未来OpenLDAP版本中替代`userPassword`的候选属性。然而，目前它尚未完全实现。
- en: 'The remaining attributes, all of which are optional, are used to store policy
    information. Here is a brief explanation of what each attribute is used for:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的属性，全部是可选的，用于存储策略信息。以下是每个属性的简要说明：
- en: '`pwdMinAge`: This specifies how much time must pass (in seconds) between the
    last time the password was changed and the next time SLAPD will allow the password
    to be changed. Setting this prevents an account from having the password changed
    multiple times in rapid succession.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdMinAge`：此参数指定在密码最后一次更改和下一次SLAPD允许更改密码之间必须经过的时间（以秒为单位）。设置此项可以防止账户在短时间内多次更改密码。'
- en: '`pwdMaxAge`: This specifies how long (in seconds) a password will be considered
    good. This is calculated from the time when the password was last changed. After
    the elapsed time, the password will be marked as expired.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdMaxAge`：此项指定密码的有效期限（以秒为单位）。该期限从密码上次更改的时间开始计算。超过该时间后，密码将被标记为已过期。'
- en: '`pwdInHistory`: If you store your passwords in plain text (unencrypted) in
    the directory then the `ppolicy` overlay can be configured to maintain a password
    history and prevent users from re-using passwords. This attribute is used to specify
    the maximum number of passwords that `ppolicy` will maintain for each user. Unless
    this attribute is set, and to a value greater than zero, no history will be maintained.'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdInHistory`：如果您将密码以明文（未加密）存储在目录中，那么`ppolicy`覆盖可以配置为维护密码历史记录，并防止用户重复使用密码。此属性用于指定`ppolicy`为每个用户维护的最大密码数。除非设置此属性且其值大于零，否则不会维护密码历史。'
- en: '`pwdCheckQuality`: There are two quality checks done by `ppolicy` if `pwdCheckQuality`
    is set to check passwords. The first is length checking (discussed next). The
    second is running a custom quality checking function. It is possible (using the
    `pwdCheckModule` object class and some custom C code) to add your own password
    quality checking module to SLAPD, and then use it to check password quality. This
    attribute takes one of three integer values: `0`, `1`, and `2`. Now we have three
    cases:'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdCheckQuality`：如果设置为检查密码，`ppolicy`会进行两项质量检查。第一项是长度检查（下文讨论）。第二项是运行自定义的质量检查功能。可以通过使用`pwdCheckModule`对象类和一些自定义C代码，将您自己的密码质量检查模块添加到SLAPD中，然后用它来检查密码质量。此属性有三个整数值：`0`，`1`和`2`。现在我们有三种情况：'
- en: If the value is `0` (the default), then `ppolicy` will not attempt to do any
    quality checking.
  id: totrans-590
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值为`0`（默认值），则`ppolicy`不会尝试进行任何质量检查。
- en: If `1`, then `ppolicy` will attempt checking, but if the password is encrypted
    and certain checking functions cannot be performed, it will return successful.
  id: totrans-591
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`1`，则`ppolicy`将尝试检查，但如果密码被加密且某些检查功能无法执行，则会返回成功。
- en: If `2`, then if the password checking function cannot run, it will return an
    error message.
  id: totrans-592
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为`2`，则当密码检查功能无法运行时，它将返回错误消息。
- en: '`pwdMinLength`: If `pwdCheckQuality` is set to `1` or `2`, then `ppolicy` will
    make sure that new passwords meet a minimum length requirement. This attribute,
    which takes a positive integer, can be used to set the minimum acceptable length
    for a password.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdMinLength`：如果`pwdCheckQuality`设置为`1`或`2`，则`ppolicy`将确保新密码满足最低长度要求。此属性为正整数，用于设置密码的最小接受长度。'
- en: '`pwdExpireWarning`: When a password approaches its expiration date (set in
    `pwdMaxAge`), `ppolicy` can provide a warning to the user when the user logs in.
    This attribute takes the time, in seconds, prior to when the password expires
    that it should start warning the user. In other words, at `pwdMaxAge`—`pwdExpireWarning`
    from when the password was set—the user will start getting warning messages. If
    this is set to `0` (the default) then no expiration warning will be sent.'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdExpireWarning`：当密码接近到期日期（由`pwdMaxAge`设置）时，`ppolicy`可以在用户登录时向用户提供警告。此属性表示密码过期前多少秒开始提醒用户。换句话说，在从设置密码时的`pwdMaxAge`减去`pwdExpireWarning`的时间点，用户将开始收到警告消息。如果此值设置为`0`（默认值），则不会发送过期警告。'
- en: '`pwdGraceAuthNLimit`: By default (or if this attribute is set to `0`), when
    a password expires the account is locked and the user can no longer bind to the
    directory server. But using this attribute we can allow grace logins. The value
    of this attribute should be a non-negative integer, which will specify how many
    grace logins a user with an expired password will be allowed before the account
    is locked.'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdGraceAuthNLimit`：默认情况下（或如果将此属性设置为`0`），当密码过期时，帐户将被锁定，用户将无法再绑定到目录服务器。但通过使用此属性，我们可以允许宽限期登录。此属性的值应为非负整数，表示在帐户被锁定之前，密码过期的用户可以进行多少次宽限登录。'
- en: '`pwdLockout`: This attribute allows you to turn on password lockouts. If this
    is turned on, then when a user fails to bind a certain number of times (`pwdMaxFailures`)
    in a row, then the account will be locked for some duration of time (`pwdLockoutDuration`).
    To turn on `pwdLockout`, which is off by default, set the value of this attribute
    to `TRUE`.'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdLockout`：此属性允许启用密码锁定。如果启用，当用户连续失败绑定指定次数（`pwdMaxFailures`）后，帐户将被锁定一段时间（`pwdLockoutDuration`）。要启用`pwdLockout`，其默认值为关闭，将此属性的值设置为`TRUE`即可。'
- en: '`pwdLockoutDuration`: This attribute specifies the amount of time, in seconds,
    that an account will be locked out if `pwdLockout` is set to `TRUE` and the user
    fails to log in too many times (the number set in `pwdMaxFailures`). If this is
    set to `0` or is not set, then the account will be locked until an administrator
    re-enables it.'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdLockoutDuration`：此属性指定账户在`pwdLockout`设置为`TRUE`且用户登录失败次数过多时（超过`pwdMaxFailures`设置的次数）被锁定的持续时间，单位为秒。如果此属性设置为`0`或未设置，则账户将被锁定，直到管理员重新启用它。'
- en: '`pwdMaxFailures`: This specifies the number of times in a row that a user can
    fail a login before being locked out. `pwdLockout` must be set to `TRUE` before
    this constraint will be enforced though.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdMaxFailures`：此属性指定用户连续失败登录的次数，超过此次数后账户将被锁定。不过，在执行此限制之前，必须先将`pwdLockout`设置为`TRUE`。'
- en: '`pwdFailureCountInterval`: This attribute can be used to fine-tune the timing
    involved in password lockouts. By default (or when this attribute is set to `0`),
    failed login attempts are stored until a successful login is made. But the value
    of this attribute can be set to a number of seconds that `ppolicy` will wait before
    clearing the password failure count.'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdFailureCountInterval`：此属性可用于微调密码锁定的时间设置。默认情况下（或当此属性设置为`0`时），失败的登录尝试会被存储，直到成功登录为止。但此属性的值可以设置为一个秒数，`ppolicy`将在清除密码失败计数之前等待这个时间。'
- en: '`pwdMustChange`: This determines whether or not a user must change their password
    after an administrator sets it. By default, the user is not prompted to change
    a password. But if this is set to `TRUE`, if an administrator changes (or initially
    sets) a password, the user will be prompted to reset the password.'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdMustChange`：此属性决定在管理员设置密码后，用户是否必须更改密码。默认情况下，用户不会被提示更改密码。但如果此设置为`TRUE`，当管理员更改（或初次设置）密码时，用户将被提示重置密码。'
- en: '`pwdAllowUserChange`: By default, users are allowed to change their own passwords.
    But if this is set to `FALSE`, users under this policy will not be allowed to
    change their own passwords. Since different policies can be assigned to different
    groups of users, this allows finer-grained control of write permissions to a password
    than ACLs do.'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdAllowUserChange`：默认情况下，用户可以更改自己的密码。但如果此属性设置为`FALSE`，则在此策略下的用户将无法更改自己的密码。由于可以将不同的策略分配给不同的用户组，因此这比访问控制列表（ACL）提供了更细粒度的密码写权限控制。'
- en: '`pwdSafeModify`: By default, once a user has successfully performed a bind
    operation, the user can change passwords without having to re-send the original
    password. But if `pwdSafeModify` is set to `TRUE`, then the user will have to
    send both the old password and the new password in order to change the password
    value. This adds an extra level of security to the password changing process.'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdSafeModify`：默认情况下，一旦用户成功执行绑定操作，用户可以更改密码，而无需重新发送原始密码。但如果`pwdSafeModify`被设置为`TRUE`，那么用户必须同时发送旧密码和新密码才能更改密码值。这为密码更改过程增加了额外的安全层。'
- en: Some of the policy attributes—primarily the password checking functions and
    password history—require that the password be stored in cleartext within the directory.
    This is the case simply because comparison functions do not work on encrypted
    values. Two identical password values, if using different salt sequences, will
    result in different ciphertexts. Two different hashing algorithms (like MD5 and
    SHA) will generate different hashes for the same password even if the same salt
    is used. Likewise, given certain hashing algorithms, two different strings could
    generate the same ciphertext (though the possibility of this happening to a particular
    user is negligible).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 一些策略属性——主要是密码检查功能和密码历史——要求密码以明文存储在目录中。之所以如此，是因为比较函数无法对加密值进行操作。如果使用不同的盐值序列，两个相同的密码值将产生不同的密文。即使使用相同的盐值，采用不同的哈希算法（如
    MD5 和 SHA）也会对相同的密码生成不同的哈希。同样，考虑到某些哈希算法，两个不同的字符串也可能生成相同的密文（尽管这种情况发生在特定用户身上的可能性微乎其微）。
- en: Most of the other features though, work regardless of how the values are stored
    in the directory.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数其他功能无论目录中存储的值如何，都能正常工作。
- en: Now we are ready to create an LDIF file to hold our policy. By convention, password
    policies are usually located in a separate OU in the directory information tree.
    We will add a new OU for that purpose.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个 LDIF 文件来存储我们的策略。根据惯例，密码策略通常位于目录信息树中的一个单独的组织单位（OU）中。我们将为此目的添加一个新的
    OU。
- en: 'And for our policy we will use the majority of the possible attributes:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的策略，我们将使用大多数可能的属性：
- en: '[PRE75]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The first entry is for our organizational unit. The second is our password policy.
    Since the `pwdPolicy` object class is auxiliary we have to give the entry another
    object class, a structural object class. The `device` object class is typically
    used (based on the testing schema used in the source distribution of OpenLDAP).
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目是我们的组织单位。第二个是我们的密码策略。由于`pwdPolicy`对象类是辅助对象类，我们必须为条目指定另一个对象类，一个结构化对象类。通常使用`device`对象类（基于OpenLDAP源分发中使用的测试模式）。
- en: Tip
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why is pwdPolicy Auxiliary?**'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么pwdPolicy是辅助对象类？**'
- en: There are a few reasons why the creators of the password policy specification
    might have made such a choice. First, according to RFC 4512, a structural object
    class must represent a physical entity. Second, making the class auxiliary makes
    it possible to integrate this schema with other existing schemas. For us, though,
    this presents the minor difficulty that there are no good candidates for a structural
    object class.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因可能导致密码策略规范的创建者做出这样的选择。首先，根据RFC 4512，结构化对象类必须表示物理实体。其次，将该类设为辅助类使得可以将此模式与其他现有模式集成。然而，对于我们来说，这也带来了一个小小的难题，因为没有合适的候选结构化对象类。
- en: 'We can now add this LDIF with `ldapadd`. We have the above LDIF saved in a
    file called `ppolicy.ldif`, so we can add it with the following command:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ldapadd`添加这个LDIF。我们已经将上述LDIF保存到名为`ppolicy.ldif`的文件中，因此可以使用以下命令将其添加：
- en: '[PRE76]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This adds our two new entries to the directory.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的两个新条目添加到目录中。
- en: Note
  id: totrans-615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you have restarted the server since adding the schema. If the `ppolicy`
    schema has not been loaded, the above will not work.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在添加模式后重新启动服务器。如果未加载`ppolicy`模式，以上操作将无法正常工作。
- en: Now that we have our entries loaded it is time to return to `slapd.conf` and
    configure the overlay.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了条目，是时候返回`slapd.conf`并配置覆盖层了。
- en: Configure the Overlay Directives
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置覆盖层指令
- en: In the first step of setting up the password policy overlay, we added directives
    to `slapd.conf` to include the `ppolicy` schema definitions and load the `ppolicy`
    module. Now we will look at the backend configuration for the overlay.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置密码策略覆盖层的第一步中，我们向`slapd.conf`添加了指令，以包括`ppolicy`模式定义并加载`ppolicy`模块。现在我们将查看覆盖层的后端配置。
- en: As with the other overlays, all of the configuration directives are backend
    specific. Also, since the `ppolicy` overlay does a lot of writing to the directory
    information tree, not all features work on read-only databases.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他覆盖层一样，所有配置指令都是特定于后端的。此外，由于`ppolicy`覆盖层会大量写入目录信息树，因此并非所有功能都能在只读数据库上工作。
- en: 'While this overlay is sophisticated, there are only three directives for the
    overlay, and these are all straightforward. The relevant section in our `slapd.conf`
    file, in the `dc=example,dc=com` directory tree, looks like this:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个覆盖层很复杂，但它只有三个指令，并且这些指令都非常直接。在我们的`slapd.conf`文件中的相关部分，在`dc=example,dc=com`目录树中，像这样：
- en: '[PRE77]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once the overlay is applied to this database using the `overlay` directive,
    there are three overlay-specific directives.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`overlay`指令将覆盖层应用于此数据库，就会有三个特定于覆盖层的指令。
- en: The first, `ppolicy_default`, points to the DN of the entry in the directory
    information tree that is to be treated as the default password policy entry. As
    we will see shortly different entries can use different policies. But the one
    indicated by `ppolicy_default` is the one that `ppolicy` will use when another
    is not explicitly set. For our example above, it is set to the DN of the entry
    that we created in the previous step.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个，`ppolicy_default`，指向目录信息树中将作为默认密码策略条目的条目的DN。如我们很快将看到的，不同的条目可以使用不同的策略。但由`ppolicy_default`指示的条目是`ppolicy`在未显式设置其他条目时将使用的条目。对于上面的示例，它被设置为我们在上一步创建的条目的DN。
- en: The second directive is `ppolicy_use_lockout`. This directive alters how SLAPD
    reports error messages due to account lockouts. When a user's account is locked
    by the password policy overlay the user is not allowed to bind again. By default
    (when this directive is not included), the client is notified that the bind failed
    because of invalid credentials (the generic LDAP error) but no additional information
    is given. When this directive is present though, then SLAPD sends the *Account*
    *Locked* error code.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个指令是`ppolicy_use_lockout`。这个指令改变了SLAPD如何报告由于帐户锁定导致的错误消息。当用户的帐户被密码策略覆盖层锁定时，用户将无法再次绑定。默认情况下（当未包含此指令时），客户端会被通知绑定失败是因为凭证无效（通用LDAP错误），但不会提供更多的错误信息。然而，当此指令存在时，SLAPD会发送*帐户*
    *已锁定*错误代码。
- en: Note
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this extra error message might be helpful to the user, it could have negative
    consequences. An attacker might be able to determine, based on this information,
    that the server is using the password lockout features. Such an attacker could
    then perform a denial of service attack against known accounts on the server simply
    by attempting to login on each known account until the account was locked.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个额外的错误消息可能对用户有帮助，但它可能会带来负面影响。攻击者可能根据这些信息判断出服务器正在使用密码锁定功能。这样的攻击者可以通过尝试在每个已知账户上登录，直到账户被锁定，从而对服务器上的已知账户发起拒绝服务攻击。
- en: The last `ppolicy` directive, `ppolicy_hash_cleartext`, modifies the way SLAPD
    handles changes to the password. In short, if this directive is present, then
    SLAPD will automatically hash cleartext passwords when they are changed using
    the LDAP modify operation (as opposed to the LDAP password modify extended operation).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`ppolicy`指令，`ppolicy_hash_cleartext`，修改了SLAPD处理密码更改的方式。简而言之，如果存在此指令，则SLAPD将在使用LDAP修改操作时自动对明文密码进行哈希处理（与LDAP密码修改扩展操作不同）。
- en: 'To understand what this means, let''s look at an example. In our directory
    we have the following record (created in Chapter 3):'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这意味着什么，我们来看一个示例。在我们的目录中，我们有以下记录（在第3章创建）：
- en: '[PRE78]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This user does not yet have a password. One way to set such a password would
    be to use the `ldappasswd` too, which (as we saw in Chapter 3) uses the LDAP password
    modify extended operation. This is the best way to change passwords as the server
    handles the password encryption. Here''s an example of setting a password with
    `ldappasswd`:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户尚未设置密码。设置密码的一种方法是使用`ldappasswd`工具，正如我们在第3章看到的，它使用LDAP密码修改扩展操作。这是更改密码的最佳方式，因为服务器会处理密码加密。以下是使用`ldappasswd`设置密码的示例：
- en: '[PRE79]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This sets the password for `uid=adam` to `secret`. What will the record look
    like now? Like this:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`uid=adam`的密码设置为`secret`。现在记录会是什么样子呢？像这样：
- en: '[PRE80]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `userPassword` value is base64 encoded. Its decoded value is this:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '`userPassword`的值是Base64编码的。解码后的值是：'
- en: '[PRE81]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: SLAPD performed the SSHA hashing of the value.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: SLAPD对该值执行了SSHA哈希。
- en: There is a second way of modifying the password and this is with the LDAP modify
    operation (as used by the `ldapmodify` client). When a `userPassword` value is
    changed with LDAP modify it is assumed that the client is sending the password
    value in the form in which it should be stored. In fact, the LDAP standard states
    that this is how the server should act when performing a modification of an attribute
    value. Thus, SLAPD will not encrypt the password.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 修改密码的第二种方式是使用LDAP修改操作（如`ldapmodify`客户端所用）。当使用LDAP修改更改`userPassword`的值时，假定客户端发送的是应该存储的密码值的形式。实际上，LDAP标准规定，当进行属性值修改时，服务器应当按这种方式操作。因此，SLAPD不会对密码进行加密。
- en: 'Here''s an example of using `ldapmodify` to set the password:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`ldapmodify`设置密码的示例：
- en: '[PRE82]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The highlighted portion above is the LDIF information to be modified. The value
    of the `userPassword` attribute was set to `secret`—the same password used in
    the `ldappasswd` example. But this time, if we look at the entry, the `userPassword`
    value is not encrypted:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的高亮部分是需要修改的LDIF信息。`userPassword`属性的值被设置为`secret`——这是在`ldappasswd`示例中使用的相同密码。但这次，如果我们查看条目，`userPassword`的值并没有被加密：
- en: '[PRE83]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The password is not hashed. Instead, it is just base64 encoded. The decoded
    value is `secret`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 密码没有被哈希处理。相反，它只是被Base64编码。解码后的值是`secret`。
- en: Including the `ppolicy_hash_cleartext` directive modifies this behavior. During
    modifications the `ppolicy` overlay checks to see if the modified attribute is
    `userPassword` and if the value is in cleartext. If the value is in cleartext
    then `ppolicy` hashes it.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`ppolicy_hash_cleartext`指令会修改这种行为。在修改期间，`ppolicy`叠加层会检查修改的属性是否为`userPassword`，且该值是否为明文。如果值是明文，`ppolicy`将对其进行哈希处理。
- en: Note
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In effect, turning on this feature causes SLAPD to perform in a nonstandard
    way, but for the sake of additional security.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，启用此功能会导致SLAPD以非标准方式执行，但为了额外的安全性。
- en: 'For example, we can re-run the same `ldapmodify`:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以重新运行相同的`ldapmodify`：
- en: '[PRE84]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'But this time, since `ppolicy_hash_cleartext` is on, the password is encrypted:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 但这次，由于`ppolicy_hash_cleartext`已启用，密码被加密了：
- en: '[PRE85]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `userPassword` value, decoded, is `{SSHA}CC7AGRAIO0n/c/+mVbDOyl/Zbzj4w1wT`.
    When hashing cleartext is enabled, LDAP modify operations (for the `userPassword`
    attribute only) behave more like LDAP password modify extended operations.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后的`userPassword`值是`{SSHA}CC7AGRAIO0n/c/+mVbDOyl/Zbzj4w1wT`。当启用明文密码哈希时，LDAP修改操作（仅针对`userPassword`属性）行为更像是LDAP密码修改扩展操作。
- en: We've now configured the overlay completely. It will take a restart for SLAPD
    to pick up the changes to `slapd.conf` though. Now we are ready to test some of
    these features.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已完全配置了覆盖层。然而，SLAPD需要重新启动才能加载`slapd.conf`中的更改。现在我们可以开始测试这些功能。
- en: Test the Overlay
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试覆盖层
- en: As it is configured now, SLAPD will enforce policy controls on any entry with
    a `userPassword` attribute. Let's do a little testing to see how the password
    policy works.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的配置是，SLAPD将对任何具有`userPassword`属性的条目执行策略控制。让我们进行一些小测试，看看密码策略是如何工作的。
- en: Tip
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The Administrator**'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理员**'
- en: As I work through the examples I use the `uid=matt` account as a managing account.
    This account is allowed (by the ACLs) to perform administrative tasks. But it
    is also subject to the constraints of the `ppolicy` overlay.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在我执行示例时，我使用`uid=matt`账户作为管理账户。该账户被ACL允许执行管理任务。但它也受`ppolicy`覆盖层的约束。
- en: The root DN account `(cn=manager,dc=example,dc=com on this server)` is treated
    differently. For example, the manager can set a password for a user without having
    to know the user's old password, even if `pwdSafeModify` is on.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: root DN账户`(cn=manager,dc=example,dc=com on this server)`会被特殊处理。例如，管理员可以为用户设置密码，而不需要知道用户的旧密码，即使`pwdSafeModify`已开启。
- en: 'First, let''s see how the policy responds to some password changes. And let''s
    start this examination with an `ldapmodify` attempt:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看策略如何响应一些密码更改。我们从一次`ldapmodify`尝试开始：
- en: '[PRE86]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The modification attempt fails because the the `pwdSafeModify` is set to `TRUE`.
    There is no way to satisfy this requirement with `ldapmodify`. Instead we will
    have to use `ldappasswd` to change the password and we will have to set it to
    supply the server with the old password. This is what we will get:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 修改尝试失败，因为`pwdSafeModify`设置为`TRUE`。无法通过`ldapmodify`满足此要求。相反，我们必须使用`ldappasswd`来更改密码，并且必须设置以提供旧密码。这是我们得到的结果：
- en: '[PRE87]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `-s` flag is used to specify the new password, while the `-a` flag is used
    to provide the old password (and then `ldappasswd` prompts for the password of
    the DN that is binding too). With both of these set we meet the requirements of
    `pwdSafeModify`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`-s`标志用于指定新密码，而`-a`标志用于提供旧密码（然后`ldappasswd`会提示输入绑定DN的密码）。设置这两个后，我们就满足了`pwdSafeModify`的要求。'
- en: 'Since we have password checking turned on we should be able to test password
    length:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们启用了密码检查功能，因此我们应该能够测试密码长度：
- en: '[PRE88]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this case the new password, `short`, is (as the name implies) too short.
    The `pwdMinLength` of the policy states that the password must be seven characters
    long, and when the password quality checking function is performed (which it will
    since `pwdCheckQuality` is set to `1`), the server returns an error noting that
    it failed. Unfortunately for the user the message does not indicate the precise
    reason.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，新的密码`short`（顾名思义）太短了。策略中的`pwdMinLength`规定密码必须至少七个字符长，当执行密码质量检查功能时（由于`pwdCheckQuality`设置为`1`，它会被执行），服务器会返回一个错误，指出验证失败。不幸的是，系统未能提供具体的失败原因。
- en: 'Next, let''s look at password expiration warnings and password expirations.
    This will require some minor changes to our policy for the sake of testing—namely
    we will want to set the values for `pwdMaxAge` and `pwdExpireWarning` to lower
    values (values that would normally be too low for a production environment). Let''s
    set the password to expire every ten minutes, and the expiration message to come
    up for the last nine minutes:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看密码过期警告和密码过期。为了测试，我们需要对策略做一些小的调整——具体来说，我们将把`pwdMaxAge`和`pwdExpireWarning`的值设置为较低的值（这些值通常对生产环境来说太低）。我们将设置密码每十分钟过期，过期警告将在最后九分钟内显示：
- en: '[PRE89]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, when `uid=adam` binds, the following message is logged in the LDAP log:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`uid=adam`绑定时，以下消息会记录在LDAP日志中：
- en: '[PRE90]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Unfortunately, no message is sent to the client so the user does not see the
    message. This may be due to the fact that the draft specification doesn't require
    that the messages be sent to the client. Expiry warnings then, are useful mainly
    to administrators.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有消息发送到客户端，因此用户看不到该消息。这可能是因为草案规范没有要求将消息发送到客户端。因此，过期警告主要对管理员有用。
- en: 'After ten minutes the `userPassword` value will be past the expiration point
    and, the next time the user logs in, SLAPD will mark the password as expired.
    Again, the user gets no explicit warning of this fact. An entry in the log file
    indicates the expiration of the account:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 十分钟后，`userPassword`值将超过过期点，下次用户登录时，SLAPD将标记密码为过期。再次提示，用户不会收到此事实的明确警告。日志文件中的一条记录指示帐户过期：
- en: '[PRE91]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But in addition to this log entry, a new operational attribute is added to
    the user''s record. The `pwdGraceUseTime` attribute is added to the user''s record,
    and the time stamp there indicates the last time the user performed a bind operation:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这条日志记录外，用户的记录中还添加了一个新的操作属性。`pwdGraceUseTime`属性被添加到用户的记录中，其中的时间戳指示用户最后一次执行绑定操作的时间：
- en: '[PRE92]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Each time a DN with an expired `userPassword` binds to the directory, a new
    value is added to the `pwdGraceUseTime` attribute. So after `uid=adam` has performed
    three binds after the password expiration date, the user''s record will contain
    three `pwdGraceUseTime` attribute values:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 每次一个具有过期`userPassword`的DN绑定到目录时，都会在`pwdGraceUseTime`属性中添加一个新值。因此，在`uid=adam`的密码过期后进行了三次绑定，用户的记录将包含三个`pwdGraceUseTime`属性值：
- en: '[PRE93]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'After the number of `pwdGraceUseTime` values reaches the number in the `pwdGraceAuthNLimit`
    attribute of the policy, the account will be treated as locked, and that DN (`uid=adam`,
    in this case) will not be allowed to bind anymore. If `uid=adam` attempts to bind
    he will get an error message:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pwdGraceUseTime`值的数量达到策略中`pwdGraceAuthNLimit`属性的数量时，帐户将被视为已锁定，并且该DN（在此例中为`uid=adam`）将不再允许绑定。如果`uid=adam`尝试绑定，他将收到一条错误消息：
- en: '[PRE94]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Furthermore, a message is added to the log noting the problem:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还会向日志中添加一条消息，指出该问题：
- en: '[PRE95]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: At this point an administrator will have to take steps to enable the account
    again.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，管理员需要采取措施重新启用该帐户。
- en: Password Policy Operational Attributes
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码策略操作属性
- en: In the previous section we tested several different features of the password
    policy. Now we will look at performing administration operations on accounts.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分中，我们测试了密码策略的几个不同功能。现在我们将着眼于对帐户执行管理操作。
- en: The `ppolicy` overlay stores information about a user's adherence to a password
    policy in that user's record. The information is stored in operational attributes.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`ppolicy`覆盖层在用户记录中存储有关用户遵守密码策略的信息。这些信息存储在操作属性中。'
- en: Unlike regular attributes, operational attributes are not returned to clients
    unless the client explicitly requests them (either by name, or with the special
    plus (`+`) attribute specifier, which matches any operational attribute). And
    SLAPD can prevent clients from being able to modify operational attributes.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规属性不同，操作属性不会返回给客户端，除非客户端明确请求它们（无论是通过名称，还是使用特殊的加号（`+`）属性说明符，该说明符匹配任何操作属性）。而且，SLAPD可以阻止客户端修改操作属性。
- en: To begin we will look at an example of what happens when password lockout (`pwdLockout`)
    is turned on, and an account gets locked out. The `ppolicy` overlay uses operational
    attributes to store information about failures and lockouts.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将查看启用密码锁定（`pwdLockout`）并且帐户被锁定时发生的情况示例。`ppolicy`覆盖层使用操作属性来存储失败和锁定的信息。
- en: In our policy, when a user fails to authenticate correctly three times in a
    row (according to `pwdMaxFailure`), they will be locked out of their account for
    some period of time (determined by `pwdLockoutDuration`).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的策略中，当用户连续三次验证失败（根据`pwdMaxFailure`），他们的帐户将被锁定一段时间（由`pwdLockoutDuration`决定）。
- en: 'One of the other users in our directory is `uid=dave,ou=users,dc=example,dc=com`.
    This user has failed to authenticate three times. The next time the user attempts
    to authenticate, even if he uses the right password, he will be disallowed from
    binding:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目录中的其他用户之一是`uid=dave,ou=users,dc=example,dc=com`。该用户已失败验证三次。下次用户尝试验证时，即使使用正确的密码，也将无法绑定：
- en: '[PRE96]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'A few operational attributes in that user''s record indicate what the problem
    is:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 该用户记录中的几个操作属性指示了问题所在：
- en: '[PRE97]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note that the `ldapsearch` in the example is for all of (and only) the operational
    attributes for entries that match the filter—that's what the plus sign (`+`) does.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，示例中的 `ldapsearch` 仅查询（且只查询）与过滤器匹配的条目的所有操作属性——这就是加号 (`+`) 的作用。
- en: 'The highlighted lines show the attributes in which we are interested: `pwdFailureTime`
    and `pwdAccountLockedTime`.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮显示的行展示了我们感兴趣的属性：`pwdFailureTime` 和 `pwdAccountLockedTime`。
- en: The `pwdFailureTime` operational attribute has a timestamp for every time the
    user failed a login. When a user has a successful login, the values of `pwdFailureTime`
    are cleared, so having three values indicates that three logins in a row have
    failed.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdFailureTime` 操作属性包含用户每次登录失败的时间戳。当用户成功登录时，`pwdFailureTime` 的值会被清除，因此有三个值意味着连续三次登录失败。'
- en: The `pwdAccountLockedTime` indicates what time the password was locked. According
    to our configuration, the lockout should only last for twenty minutes, after which
    the user will be allowed to try again.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwdAccountLockedTime` 指示密码被锁定的时间。根据我们的配置，锁定应只持续二十分钟，之后用户可以重新尝试登录。'
- en: 'If the user succeeds the `pwdFailureTime` and `pwdAccountLockedTime` attributes
    will be removed from the user''s record:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户成功登录，`pwdFailureTime` 和 `pwdAccountLockedTime` 属性将从用户记录中删除：
- en: '[PRE98]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In such cases administrators do not have to make any special changes to a user's
    entry. But what if the user gets locked out? This can happen if `pwdLockDuration`
    is set to `0` and the user fails to login too many times. It can also happen,
    as we saw in the example, if the user's password has expired and the user has
    exhausted the allowed grace logins.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，管理员无需对用户条目进行任何特殊更改。但是如果用户被锁定怎么办？如果将 `pwdLockDuration` 设置为 `0`，且用户登录失败次数过多，就会发生这种情况。如我们在示例中看到的，如果用户的密码已过期且用户已用尽允许的宽限登录次数，也会发生这种情况。
- en: Once the account has been locked, the user will not even be allowed to change
    his or her password. That means that the manager will need to intervene on the
    user's behalf and change the password using `ldappasswd`, `ldapmodify`, or another
    similar tool.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦账户被锁定，用户甚至无法更改其密码。这意味着管理员需要代表用户介入，并使用 `ldappasswd`、`ldapmodify` 或其他类似工具来更改密码。
- en: 'In rare cases, it may be desirable to modify the operational attributes directly.
    For example, `pwdAccountLockedTime`, `pwdReset`, and `pwdPolicySubentry` can be
    modified by the manager:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，可能需要直接修改操作属性。例如，`pwdAccountLockedTime`、`pwdReset` 和 `pwdPolicySubentry`
    可以由管理员进行修改：
- en: '[PRE99]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In this example, the `pwdReset` flag for the `uid=adam` account was set to `TRUE`.
    This will require the user to change the password the next time a bind is performed.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`uid=adam` 账户的 `pwdReset` 标志被设置为 `TRUE`。这将要求用户在下一次绑定时更改密码。
- en: But SLAPD may not allow the other operational attributes to be modified by the
    standard LDAP modification. This is because the `ppolicy` schema sets the `NO-USER-MODIFICATION`
    flag on these schema definitions.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，SLAPD 可能不允许通过标准 LDAP 修改操作其他操作属性。这是因为 `ppolicy` 模式在这些模式定义上设置了 `NO-USER-MODIFICATION`
    标志。
- en: Can these operational attributes ever be modified? Using a special control,
    the **Relax Rules control** (formerly called ManageDIT), managers can change the
    values of operational parameters that usually do not allow such changes. However,
    the Relax Rules control is not yet officially released and is not enabled by default
    in OpenLDAP. We would have to build the development version of OpenLDAP to enable
    the control.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作属性能否被修改？使用特殊控制，**Relax Rules 控制**（以前称为 ManageDIT），管理员可以更改通常不允许更改的操作参数的值。但是，Relax
    Rules 控制尚未正式发布，并且在 OpenLDAP 中默认未启用。我们需要构建 OpenLDAP 的开发版本来启用该控制。
- en: Summary of ppolicy Operational Attributes
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ppolicy 操作属性摘要
- en: 'We have looked at a few more operational attributes that `ppolicy` can attach
    to a record used for bindng. Here''s a list of all of the possible attributes
    along with a brief description of each:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了 `ppolicy` 可以附加到绑定记录的一些其他操作属性。以下是所有可能的属性及其简短描述：
- en: '`pwdChangedTime`: This contains a timestamp indicating when the password was
    last changed. There can only be one value for this attribute. Passwords in entries
    that do not have this attribute will never expire.'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdChangedTime`：这是一个时间戳，表示密码最后一次更改的时间。此属性只能有一个值。没有此属性的条目中的密码将永不过期。'
- en: '`pwdAccountLockedTime`: This attribute is added to an entry when the entry
    is locked. It contains a timestamp indicating at what time SLAPD marked the account
    as locked. We saw this used when a user failed to authenticate too many times
    in a row.'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdAccountLockedTime`：当条目被锁定时，会添加此属性。它包含一个时间戳，表示SLAPD标记账户为锁定的时间。我们看到，当用户连续多次身份验证失败时，会使用此属性。'
- en: '`pwdFailureTime`: A `pwdFailureTime` attribute value is added to a record every
    time a user tries to bind, but fails to supply the right password. A successful
    login clears all `pwdFailureTime` attributes.'
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdFailureTime`：每当用户尝试绑定但未能提供正确密码时，都会将`pwdFailureTime`属性值添加到记录中。成功登录时会清除所有`pwdFailureTime`属性。'
- en: '`pwdGraceUseTime`: If a user''s account has expired, and the policy allows
    grace logins, a new `pwdGraceUseTime` value will be added every time the user
    logs in with an expired password. Resetting the password clears all `pwdGraceUseTime`
    values.'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdGraceUseTime`：如果用户的账户已过期，并且策略允许宽限期登录，则每次用户使用过期密码登录时，都会添加一个新的`pwdGraceUseTime`值。重置密码时会清除所有`pwdGraceUseTime`值。'
- en: '`pwdHistory`: If password history tracking is turned on then every time a user
    changes passwords, the old password is stored in a `pwdHistory` attribute value.
    Only the number of password specified in the policy are retained in the history'
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdHistory`：如果开启了密码历史跟踪，那么每次用户更改密码时，旧密码会存储在`pwdHistory`属性值中。只有策略中指定的密码数量会保留在历史中。'
- en: '`pwdPolicySubentry`: This attribute, which allows only one value, takes the
    DN of the password policy that this record should use. If this attribute is not
    found, SLAPD uses the default policy (as specified by the `ppolicy_default` directive
    in `slapd.conf`).'
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdPolicySubentry`：此属性仅允许一个值，采用此记录应使用的密码策略的DN。如果未找到此属性，SLAPD将使用默认策略（如`slapd.conf`中的`ppolicy_default`指令所指定）。'
- en: '`pwdReset`: This attribute takes a boolean value. When a manager changes the
    password the flag is set to `TRUE`. If the policy also has `pwdMustChange` set
    to `TRUE` then the user will have to change her or his password on the next bind
    (using `ldappasswd`).'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwdReset`：此属性采用布尔值。当管理员更改密码时，标志被设置为`TRUE`。如果策略中同时设置了`pwdMustChange`为`TRUE`，则用户必须在下次绑定时（使用`ldappasswd`）更改其密码。'
- en: At this point we are done working with the Password Policy overlay. Next we
    will move on to create our own schema.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了与密码策略覆盖层的工作。接下来，我们将开始创建我们自己的架构。
- en: Creating a Schema
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建架构
- en: Up to this point we have taken an in-depth look at schema definitions and then
    implemented a few overlays that made use of custom schemas. By now you should
    be comfortable working with and reading schemas. Here we are going to create our
    own schema.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经深入研究了架构定义，并实现了一些使用自定义架构的覆盖层。到现在为止，你应该已经能熟练地操作和阅读架构。接下来我们将创建我们自己的架构。
- en: Our goal in this section is to create a small schema for adding blog information
    to our directory. We want to be able to store a record in the directory to represent
    a blog, and also link existing entries to these blogs, indicating, for example,
    that a particular user maintains a particular blog.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是创建一个小型架构，用于将博客信息添加到我们的目录中。我们希望能够在目录中存储一个表示博客的记录，并将现有条目与这些博客链接起来，例如，表明某个用户维护了特定的博客。
- en: To do this we are going to add two object classes—one structural and one auxiliary—and
    a handful of new attributes. The structural object class, `blog`, will describe
    an individual blog. It will contain the necessary attributes to describe a blog.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将添加两个对象类——一个结构性和一个辅助性——以及一些新属性。结构性对象类`blog`将描述一个独立的博客。它将包含描述博客所需的属性。
- en: The auxiliary class `blogOwner`, will be used to add blog ownership information
    to a particular entry. Since the information about the blog will be stored in
    a `blog` entry, the `blogOwner` object class will only need one attribute that
    can be used to point to the appropriate `blog` entry.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类`blogOwner`将用于向特定条目添加博客所有权信息。由于博客信息将存储在一个`blog`条目中，`blogOwner`对象类只需要一个属性，用于指向相应的`blog`条目。
- en: The first thing we will do is walk through the process of obtaining an OID.
    Then we will create our object classes. After the object classes are created we
    will define our new attributes. Finally, we will try out our new schema.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先走一遍获取OID的过程。然后我们将创建我们的对象类。对象类创建完成后，我们将定义新的属性。最后，我们将尝试使用我们的新架构。
- en: Getting an OID
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取OID
- en: As we have seen so far the OID (Object Identifier) plays an important role in
    defining a schema.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们到目前为止看到的，OID（对象标识符）在定义架构时起着重要作用。
- en: 'An OID is a sequence of integers separated by dots (`.`). But OIDs are not
    arbitrary combinations of digits. They are structured to represent the pedigree
    of an object. As we will use them here, for creating a new schema, we will treat
    the OID as being composed of three parts:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: OID 是由整数组成的序列，数字之间用点（`.`）分隔。但 OID 并不是任意的数字组合。它们是有结构的，用于表示对象的来源。在这里，我们将它们用于创建新架构时，会将
    OID 视为由三个部分组成：
- en: The base OID
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 OID
- en: The type number
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型号码
- en: The item number
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目号码
- en: The base part of an OID number is assigned by a naming authority. We will get
    ours from the **Internet Assigned Numbers Authority** (**IANA**).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: OID 号码的基础部分由命名机构分配。我们将从 **互联网号码分配局**（**IANA**）获得我们的 OID。
- en: Note
  id: totrans-729
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**IANA** is not the only naming authority. Each country may have its own registry.
    For instance, in the United States the **American National Standards Institute
    (ANSI)** also has a registry.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '**IANA** 并不是唯一的命名机构。每个国家可能有自己的注册表。例如，在美国，**美国国家标准协会（ANSI）** 也有一个注册表。'
- en: IANA maintains a registry of OIDs for private enterprises. It allocates numbers
    free of charge and all that is necessary is a one-time registration. However,
    IANA only gives one number to each enterprise so, if your organization has one
    already, you should use the existing one. You can view the registry at [http://www.iana.org/assignments/enterprise-numbers](http://www.iana.org/assignments/enterprise-numbers).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: IANA 维护着一个用于私营企业的 OID 注册表。它免费分配号码，只需进行一次注册。然后，IANA 每个企业只分配一个号码，所以如果你的组织已经有了一个，应该使用现有的那个。你可以在
    [http://www.iana.org/assignments/enterprise-numbers](http://www.iana.org/assignments/enterprise-numbers)
    上查看注册表。
- en: 'To obtain a number go to [http://iana.org/cgi-bin/enterprise.pl](http://iana.org/cgi-bin/enterprise.pl)
    and complete the form there. You will then be assigned an OID looking something
    like this: 1.3.6.1.4.1.?, where the question mark is replaced with an integer.
    This OID serves as the basis for the OIDs we use when creating schemas. By appending
    your own series of digits and dots to this string you can create your own OID
    numbers, and as long as you take care to keep your OIDs unique within your own
    domain, you can assume that these OIDs are also globally unique (for you are the
    only one with the exact base OID).'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得一个号码，请访问 [http://iana.org/cgi-bin/enterprise.pl](http://iana.org/cgi-bin/enterprise.pl)
    并填写那里的表格。然后，你将分配一个类似于这样的 OID：1.3.6.1.4.1.?，其中问号会被一个整数替换。这个 OID 作为我们在创建架构时使用的 OID
    的基础。通过在这个字符串后面附加你自己的数字和点，你可以创建自己的 OID 号码，只要你确保在自己的域内保持 OID 的唯一性，你就可以假设这些 OID 也是全局唯一的（因为你是唯一拥有该基础
    OID 的人）。
- en: Note
  id: totrans-733
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In these examples I am using the OID registered to me. These OIDs may be used
    to replicate the examples herein, but do not use my OID to create your own schemas.
    The practice of using someone else's OID is called **OID hijacking**, and is frowned
    upon because it compromises the assumption that OIDs are globally unique.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些例子中，我使用的是注册给我的 OID。这些 OID 可以用于复制这里的例子，但不要用我的 OID 来创建你自己的架构。使用他人的 OID 的做法称为
    **OID 劫持**，这种做法是不被提倡的，因为它破坏了 OID 唯一性的假设。
- en: 'While this series of digits has some semantic meaning (it means, roughly, that
    the owner is a private enterprise operating within IANA''s namespace), there are
    no constraints on how you decide to structure your OIDs. You could, for example,
    just append a new set of random digits to the base OID each time you needed to
    create a new OID:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一串数字有一定的语义含义（大致上意味着拥有者是一个在 IANA 命名空间内运营的私营企业），但在如何构建 OID 方面没有限制。例如，你可以每次需要创建新
    OID 时，简单地将一组随机数字附加到基础 OID 上：
- en: '[PRE100]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'But it is often more manageable to come up with some semantic scheme for organization.
    A version derived from the OpenLDAP foundation''s scheme is recommended. From
    the base OID, create a segment to be used just for LDAP OIDs:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 但是通常更易于提出一些语义化的组织方案。建议使用基于 OpenLDAP 基金会方案的版本。从基础 OID 开始，创建一个仅用于 LDAP OID 的段：
- en: '[PRE101]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now we have just one portion of the namespace that will be used only for LDAP
    OIDs. From here we will use a simple subcategory identifier. Starting with the
    OID arc 1.3.6.1.4.1.8254.1021, we will create OIDs of the form:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只有一个部分命名空间，它将仅用于 LDAP OID。接下来我们将使用一个简单的子类别标识符。从 OID 区段 1.3.6.1.4.1.8254.1021
    开始，我们将创建如下格式的 OID：
- en: '[PRE102]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Where `x` indicates the type of object and `y` indicates the specific object
    we are identifying. The OpenLDAP Foundation uses the following types:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`x`表示对象的类型，`y`表示我们正在标识的具体对象。OpenLDAP基金会使用以下类型：
- en: LDAP syntaxes (`1`)
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP语法（`1`）
- en: Matching rules (`2`)
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配规则（`2`）
- en: Attribute types (`3`)
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性类型（`3`）
- en: Object classes (`4`)
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类（`4`）
- en: Supported features (`5`)
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的特性（`5`）
- en: Protocol mechanisms (`9`)
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议机制（`9`）
- en: Controls (`10`)
  id: totrans-748
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制（`10`）
- en: Extended operations (`11`)
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展操作（`11`）
- en: We are only going to create object classes and attributes, so the value of `x`
    for our classes will be `3` for OIDs attached to attributes and `4` for OIDs attached
    to object classes.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只创建对象类和属性，因此我们类的`x`值对于附加到属性的OID为`3`，对于附加到对象类的OID为`4`。
- en: 'For the `y` value, we will just start with the digit `1` and increment each
    time we define a new object of that type. For example, our first object class
    will have the OID:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`y`值，我们只需从数字`1`开始，每次定义一个新类型的对象时递增。例如，我们的第一个对象类将具有以下OID：
- en: '[PRE103]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And for our second object class we will just increment the last value from
    `1` to `2`:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个对象类，我们只需将最后一个值从`1`递增到`2`：
- en: '[PRE104]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Again, this is just one convention and different organizations use different
    conventions. While I advocate this convention you are free to choose another if
    you find that it is better for your needs.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这只是一个约定，不同的组织使用不同的约定。虽然我提倡这种约定，但如果你觉得其他约定更适合你的需求，你可以自由选择。
- en: There are two things to keep in mind though. First, you need to ensure that
    the OIDs are unique across your arc. That means you should maintain a registry
    of them in a place accessible to all people in your organization who work with
    the OIDs. Second, adding meaning to the numbers can provide tremendous utility,
    as it can help you recall or derive what an otherwise arbitrary string of numbers
    represents.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两件事需要记住。首先，确保OID在你的命名空间内唯一。这意味着你应该在一个所有与OID相关的组织成员都能访问的地方维护一个OID注册表。其次，为数字添加意义可以提供巨大的实用性，因为它有助于你回忆或推导出一个本来是任意的数字串所代表的内容。
- en: Now we are ready to begin creating our schema.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好开始创建我们的架构了。
- en: Giving Our OID a Name
  id: totrans-758
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给我们的OID命名
- en: Our schema definitions are all going in a file called `blog.schema`, which we
    will later reference in an `include` statement in `slapd.conf`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的架构定义都放在一个名为`blog.schema`的文件中，稍后我们将在`slapd.conf`中的`include`语句中引用它。
- en: Most usually once the base OID for LDAP objects is defined, it is convenient
    to use the `objectidentifier` directive in `slapd.conf` to make the OIDs more
    readable, and make the process of creating schema definitions less error prone.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一旦定义了LDAP对象的基本OID，就可以方便地使用`slapd.conf`中的`objectidentifier`指令来使OID更具可读性，并减少创建架构定义时出错的概率。
- en: 'We can do this in the first few lines of our schema file:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在架构文件的前几行中完成这一操作：
- en: '[PRE105]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The first line maps the name `blogSchema` onto the OID `1.3.6.1.4.1.8254.1021`.
    Now we can refer to that long OID as `blogSchema`, which is much easier to remember.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将名称`blogSchema`映射到OID`1.3.6.1.4.1.8254.1021`。现在我们可以将那个长OID称为`blogSchema`，这样更容易记住。
- en: The second and third `objectidentifier` directives add a few more aliases. The
    second one sets the name `blogAttrs` refer to the OID `blogSchema:3` (which is
    `1.3.6.1.4.1.8254.1021.3`). Thus, when we define attributes we can use the shortcut
    `blogAttrs:1` instead of typing the whole thing out as `1.3.6.1.4.1.8254.1021.3.1`.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第三个`objectidentifier`指令添加了更多的别名。第二个指令将名称`blogAttrs`设置为指代OID `blogSchema:3`（即`1.3.6.1.4.1.8254.1021.3`）。因此，当我们定义属性时，可以使用快捷方式`blogAttrs:1`，而不是输入完整的`1.3.6.1.4.1.8254.1021.3.1`。
- en: Similarly, `blogOCs` alias (short for "blog object classes") can be used to
    refer to the `1.3.6.1.4.1.8254.1021.4` arc.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`blogOCs`别名（即“博客对象类”的缩写）可用于指代`1.3.6.1.4.1.8254.1021.4`命名空间。
- en: With this mechanism in place we have implemented the organizational strategy
    explained in the previous section, and our OID naming from here on should be a
    simple matter of incrementing the last integer of an OID.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个机制，我们实现了上一节中解释的组织策略，从此我们的OID命名应该只是简单地递增OID中的最后一个整数。
- en: Creating Object Classes
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象类
- en: 'We will be starting with our object classes, and then use these defined object
    classes to guide the creation of our attributes. This is typically the way creation
    of schemas is done, but it does have one counter-intuitive result: object classes
    must be defined after the attributes that they contain. In effect then, we are
    jumping to the end of our schema file to add object classes, and will later add
    attribute definitions between the object identifiers and the object classes.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对象类开始，然后使用这些定义的对象类来指导我们属性的创建。这通常是创建模式的方式，但它有一个反直觉的结果：对象类必须在它们包含的属性之后定义。实际上，我们是在跳到模式文件的末尾来添加对象类，并且稍后会在对象标识符和对象类之间添加属性定义。
- en: The first object class to describe is the `blog` class. This object class will
    define the attributes necessary to define a blog. For our purposes we are going
    to create a very simple object class, though there are many more attributes that
    could be attached.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要描述的对象类是`blog`类。该对象类将定义定义博客所需的属性。为了我们的目的，我们将创建一个非常简单的对象类，尽管还可以附加更多的属性。
- en: 'We want the class to have the following attributes:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望该类包含以下属性：
- en: '`blogTitle`: The title of the blog'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogTitle`：博客标题'
- en: '`blogUrl`: The URL (Uniform Resource Locater) of the main page for the blog'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogUrl`：博客主页的URL（统一资源定位符）'
- en: '`blogFeedUrl`: The URL for the RSS or Atom feed of the URL'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogFeedUrl`：该URL指向RSS或Atom订阅源的地址'
- en: '`description`: A brief text description of the blog'
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：博客的简要文本描述'
- en: Of these, the `blogUrl` and `blogTitle` attributes should be required. `blogUrl`
    is an essential component of a blog. Without this, an entry describing a blog
    would be of little value. And the `blogTitle` attribute is necessary to give us
    a naming component to use in DNs.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些属性中，`blogUrl`和`blogTitle`属性应该是必需的。`blogUrl`是博客的重要组成部分，没有它，描述博客的条目将没有多大价值。而`blogTitle`属性是必需的，它可以作为命名组件在DN中使用。
- en: For the sake of clarity of meaning, here we have prepended the `blog` string
    to any new attributes so that they can be immediately distinguished from other
    similar attributes.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们在所有新属性前加上了`blog`字符串，以便能立即区分这些属性与其他类似属性。
- en: Tip
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Naming Object Classes and Attributes**'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名对象类和属性**'
- en: If your object classes or attributes are designed for internal use, or for application-specific
    use, it is advised that the name of the organization or application be prepended
    to the attribute and object class names. That helps to make the purpose of the
    defined items explicit.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的对象类或属性是为内部使用或特定应用程序使用设计的，建议在属性和对象类的名称前加上组织或应用程序的名称。这有助于明确已定义项的目的。
- en: Fortunately for us, `description` is already defined. While we could use the
    `title` attribute, as defined in `core.schema`, this could introduce confusion,
    as that attribute is used to refer to the title of a person in an organization.
    To avoid any confusion then, we will avoid reusing that attribute.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`description`已经被定义。虽然我们可以使用`core.schema`中定义的`title`属性，但这可能会引起混淆，因为该属性用于指代组织中人的职称。为了避免混淆，我们将避免重用该属性。
- en: 'Already we have said that this object class is going to be structural, and
    we have a scheme for determining an OID number. There are no similar object classes
    so we will create a class whose superior is `top`. We now have all the information
    we need to create our schema definition:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过这个对象类将是结构类，并且我们有一个确定OID号的方案。由于没有类似的对象类，我们将创建一个以`top`为父类的类。现在我们已经拥有了创建模式定义所需的所有信息：
- en: '[PRE106]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In the OID field we used the object identifier we assigned in the last section.
    And we started with `1`, our first object class.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在OID字段中，我们使用了上一节中分配的对象标识符。我们从`1`开始，这是我们的第一个对象类。
- en: The `blogOwner` object class is to be marked auxiliary so that we can attach
    it to a variety of different entries, regardless of the structural object class.
    For example, regardless of whether the blog is a corporate blog, or is maintained
    by an organizational unit, or is simply an individual's, we can add this object
    class to the desired entry.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '`blogOwner`对象类应标记为辅助类，以便可以将其附加到不同类型的条目上，无论其结构对象类如何。例如，无论博客是企业博客、由某个组织单元维护，还是单纯个人博客，我们都可以将该对象类添加到所需的条目中。'
- en: 'We want to use the `blogOwner` object class to insert a pointer from an entry
    to the appropriate `blog` entry in the directory information tree. Since that
    is all we need, a single attribute will suffice for these purposes:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用`blogOwner`对象类从一个条目插入指向目录信息树中相应`blog`条目的指针。既然这是我们所需的全部，因此一个属性就足够了。
- en: '`blogDN`: The DN describing the `blog` that this entry is affiliated with.'
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blogDN`：描述与此条目相关联的`blog`的DN。'
- en: 'This object class then, turns out to be even simpler than the previous one:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象类实际上比前一个更简单：
- en: '[PRE107]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This OID number differs from the first only in that the last value has been
    incremented. This follows the scheme we defined in the previous section.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这个OID号与第一个不同，唯一的区别是最后一个值已经递增。这遵循了我们在前一部分定义的方案。
- en: Since this is an auxiliary object class, there is no need for a superior. And
    since we want this class to be used to point to a `blog` entry elsewhere in the
    directory, the `blogDN` attribute is required.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个辅助对象类，因此不需要上级对象。并且由于我们希望这个类用于指向目录中其他地方的`blog`条目，因此需要`blogDN`属性。
- en: Now we have our two object classes. In creating them we have referred to four
    attributes that currently do not exist. It is time to create them.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个对象类。在创建它们时，我们引用了四个目前不存在的属性。现在是时候创建它们了。
- en: Creating Attributes
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建属性
- en: 'As we created the `blog` and `blogOwner` object classes, we tentatively defined
    (in our text) four attributes: `blogTitle`, `blogUrl`, `blogFeedUrl`, and `blogDN`.
    Now we will define each of these, beginning with `blogTitle`.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了`blog`和`blogOwner`对象类之后，我们初步定义了（在文本中）四个属性：`blogTitle`、`blogUrl`、`blogFeedUrl`和`blogDN`。现在我们将定义每个属性，从`blogTitle`开始。
- en: In order to define our attribute we want to decide on the syntax of the attribute
    and also the matching rules that SLAPD will use for this attribute. The `blogTitle`
    will contain values that are strings of text data. So the syntax we want is one
    that supports this. The **Directory String syntax**, defined in RFC 4517, is intended
    for just such a purpose. And it supports internationalization, storing characters
    in UTF-8.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的属性，我们需要决定属性的语法以及SLAPD将用于该属性的匹配规则。`blogTitle`将包含文本数据的字符串值。因此，我们需要的语法是支持这种数据类型的。**目录字符串语法**，在RFC
    4517中定义，正是为此目的而设，且支持国际化，能够以UTF-8存储字符。
- en: When performing searches, we do not want the case of the text (upper or lower)
    to make a difference. In other words, we want "My Blog" and "my blog" to be treated
    as matches. So we need to find the matching rule that will best support this.
    There are over three dozen matching rules supported in OpenLDAP (you can see a
    list by searching the `cn=Subschema` entry). We want to implement string-based
    equality and substring matching on our `blogTitle` attribute, so the pair of matching
    rules we will want to use are `caseIgnoreMatch` and `caseIgnoreSubstringsMatch`.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行搜索时，我们不希望文本的大小写（大写或小写）产生影响。换句话说，我们希望"My Blog"和"my blog"被视为匹配项。因此，我们需要找到最适合支持此功能的匹配规则。OpenLDAP支持三十多种匹配规则（您可以通过搜索`cn=Subschema`条目查看列表）。我们希望在`blogTitle`属性上实现基于字符串的相等性和子字符串匹配，因此我们将使用的匹配规则对是`caseIgnoreMatch`和`caseIgnoreSubstringsMatch`。
- en: 'Now, we have all of the information necessary for creating a new attribute
    type:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了创建新属性类型所需的所有信息：
- en: '[PRE108]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The OID field is `blogAttrs:1`, indicating that this is our first attribute.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: OID字段为`blogAttrs:1`，表示这是我们的第一个属性。
- en: The LDAP syntax OID is the OID for a **Directory String**. At the end of the
    OID, the `{256}` suggests that the maximum length of the title be constrained
    to 256 characters.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP语法OID是**目录字符串**的OID。在OID的末尾，`{256}`表明标题的最大长度应限制为256个字符。
- en: Note
  id: totrans-800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The characters are in UTF-8, so this might take up as much as 512 bytes of space
    if each of the 256 characters is two bytes.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 字符是UTF-8编码的，因此如果每个256个字符占用两个字节，这可能会占用最多512字节的空间。
- en: The next two attributes, `blogUrl` and `blogFeedUrl`, are similar and we can
    take advantage of that as we define them.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个属性，`blogUrl`和`blogFeedUrl`，是类似的，我们可以利用这一点在定义它们时进行简化。
- en: The first thing to examine is the LDAP syntax of these attributes. Unlike `blogTitle`,
    we do not want the values of `blogUrl` and `blogFeedUrl` to be in the Directory
    String syntax, because (according to RFC 3986 and the previous URL standards)
    URLs are to use a subset of the ASCII character set.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要检查的是这些属性的LDAP语法。与`blogTitle`不同，我们不希望`blogUrl`和`blogFeedUrl`的值使用目录字符串语法，因为（根据RFC
    3986和之前的URL标准）URL应使用ASCII字符集的子集。
- en: Note
  id: totrans-804
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more on URLs and internationalization, see the W3C''s *Web* *Naming* *and*
    *Addressing* page: [http://www.w3.org/Addressing/](http://www.w3.org/Addressing/).
    Links to information as well as pertinent RFCs can be found there.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 关于URL和国际化的更多信息，请参见W3C的*Web* *Naming* *and* *Addressing*页面：[http://www.w3.org/Addressing/](http://www.w3.org/Addressing/)。相关信息和相关RFC可以在该页面找到。
- en: Instead of using Directory String syntax, we should use the **IA5 String syntax**
    which describes an extended ASCII character set. The OID for this syntax is `1.3.6.1.4.1.1466.115.121.1.26`.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用**IA5字符串语法**，而不是使用目录字符串语法，它描述了一种扩展的ASCII字符集。该语法的OID是`1.3.6.1.4.1.1466.115.121.1.26`。
- en: Similarly, when we specify matching rules, we want to use the IA5 matching rules.
    And since URLs are case-sensitive, we want exact matches. We do not want the case
    to be ignored. So for matching rules we want `caseExactIA5Match` and `caseExactIA5SubstringsMatch`.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，当我们指定匹配规则时，我们希望使用IA5匹配规则。而且由于URL是区分大小写的，我们希望进行精确匹配。我们不希望忽略大小写。因此，匹配规则我们要使用`caseExactIA5Match`和`caseExactIA5SubstringsMatch`。
- en: 'Now we can define both attributes:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义这两个属性了：
- en: '[PRE109]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Since the `blogUrl` field contains the matching rules and syntax that `blogFeedUrl`
    uses, and since there is an obvious similarity in usage between the two, it makes
    sense to treat `blogUrl` as the supertype of `blogFeedUrl`. So, `blogFeedUrl`
    inherits the LDAP syntax and matching rules from `blogUrl`.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`blogUrl`字段包含了`blogFeedUrl`使用的匹配规则和语法，并且这两者在使用上有明显的相似性，因此将`blogUrl`视为`blogFeedUrl`的超类型是有意义的。所以，`blogFeedUrl`继承了`blogUrl`的LDAP语法和匹配规则。
- en: Finally, we need to define our `blogDN` field, which will hold a DN. There is
    syntax and specific matching rules for DNs, and we will use those. The **Distinguished
    Name syntax**, defined with the OID `1.3.6.1.4.1.1466.115.121.1.12`, is used for
    values that are DNs. And the `distinguishedNameMatch` matching rule is used for
    performing exact matches on DNs. There are no substring or ordering matches for
    DNs.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义我们的`blogDN`字段，它将保存一个DN。DN有语法和特定的匹配规则，我们将使用这些规则。**区分名语法**，用OID `1.3.6.1.4.1.1466.115.121.1.12`定义，用于表示DN的值。而`distinguishedNameMatch`匹配规则则用于对DN进行精确匹配。DN没有子字符串匹配或排序匹配。
- en: 'Our last attribute then, looks like this:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的属性看起来像这样：
- en: '[PRE110]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now we have our entire schema defined. We are ready to test it.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了整个模式。我们准备好进行测试了。
- en: Loading the New Schema
  id: totrans-815
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载新模式
- en: As with all other schemas, in order to load this schema, we must include it
    in `slapd.conf`.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他模式一样，为了加载此模式，我们必须在`slapd.conf`中包含它。
- en: '[PRE111]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: It is assumed here that `blog.schema` is located in the `/etc/ldap/schema` directory
    (which is a good place to put the schema). If you choose to locate the schema
    elsewhere, adjust the path accordingly.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`blog.schema`位于`/etc/ldap/schema`目录中（这是放置模式的好位置）。如果你选择将模式放置在其他地方，请相应地调整路径。
- en: The highlighted line in the code is the only addition necessary (the rest should
    be there already). Note that our schema is only dependent on `core.schema`. The
    other three are not necessary to make our schema work.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中高亮的行是唯一需要添加的部分（其余部分应该已经存在）。请注意，我们的模式只依赖于`core.schema`。其他三个模式对于使我们的模式生效并不是必须的。
- en: Restarting SLAPD will load the schema.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 重启SLAPD将加载该模式。
- en: Troubleshooting Schema Loading
  id: totrans-821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排查模式加载问题
- en: 'If there is an error in the schema SLAPD will not start, failing instead with
    an elaborate error message like this:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式中存在错误，SLAPD将无法启动，而是会显示一个详细的错误信息，例如：
- en: '[PRE112]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This error was triggered when we misspelled `AUXILIARY`—a cause not easily divined
    by this error message. But it illustrates the fact that the process of writing
    a schema definition takes patience and precision.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拼写错误`AUXILIARY`时，触发了这个错误——这个错误信息并不容易直接看出其原因。但它说明了编写模式定义需要耐心和精确。
- en: The best strategy for dealing with such failures is to carefully read the errant
    schema definition over, hunting for errors. Sometimes simplifying a definition
    can help eliminate other possible errors too. Finally, checking the definition
    against the specification in RFC 4512 can help you spot any nondescript syntactical
    errors.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种故障的最佳策略是仔细阅读错误的模式定义，寻找错误。有时简化定义也可以帮助排除其他可能的错误。最后，将定义与RFC 4512中的规范进行对比，帮助你发现任何不明显的语法错误。
- en: A New Record
  id: totrans-826
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新记录
- en: 'Now we can use `ldapadd` to add a new `blog` entry to our directory information
    tree. We will add information about the official corporate blog of Example.Com:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ldapadd`将一个新的`blog`条目添加到我们的目录信息树中。我们将添加关于Example.Com官方公司博客的信息：
- en: '[PRE113]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The highlighted portion above is the new entry we are adding. The last line,
    returned by SLAPD, indicates that the entry has been added successfully.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的高亮部分是我们正在添加的新条目。SLAPD 返回的最后一行表示该条目已成功添加。
- en: 'Our user `uid=barbara` is responsible for maintaining this blog so we can indicate
    this relationship by adding the `blogOwner` object class and `blogDN` attribute
    to her record with `ldapmodify`:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户 `uid=barbara` 负责维护这个博客，因此我们可以通过使用 `ldapmodify` 向她的记录中添加 `blogOwner` 对象类和
    `blogDN` 属性来表示这种关系：
- en: '[PRE114]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The record for `uid=barbara` now looks like this:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid=barbara` 的记录现在如下所示：'
- en: '[PRE115]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We have just successfully created and implemented a new schema including new
    attributes and object classes.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功创建并实现了一个包含新属性和对象类的新模式。
- en: Summary
  id: totrans-835
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The focus of this chapter has been the schema. We began with a theoretical look
    at what makes up a schema and how schemas are defined. Then we looked at the organization
    of schemas in the directory, focusing on the different types of object class and
    how they work together to compose a hierarchical directory. From there we turned
    to more practical material. We looked at the `accesslog` and `ppolicy` overlays,
    each of which requires its own schema. Finally, we ended by creating our own custom
    schema, creating a pair of object classes, and a handful of attributes.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是模式。我们首先从理论角度探讨了模式的构成及其定义方式。接着，我们看了目录中模式的组织方式，重点介绍了不同类型的对象类及它们如何协同工作以构成一个层次结构的目录。随后，我们转向了更实用的内容。我们研究了
    `accesslog` 和 `ppolicy` 覆盖层，每个覆盖层都需要其独立的模式。最后，我们通过创建自定义模式、构建一对对象类和一组属性来结束本章。
- en: In the next chapter we will discuss working with multiple directories, focusing
    particluarly on directory replication, the process of keeping two or more directory
    servers synchronized with the same content.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论如何处理多个目录，特别关注目录复制，即保持两个或更多目录服务器同步并包含相同内容的过程。
