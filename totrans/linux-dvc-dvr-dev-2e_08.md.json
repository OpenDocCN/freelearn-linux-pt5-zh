["```\nstruct device {\n    struct device         *parent;\n    struct kobject        kobj;\n    struct bus_type       *bus;\n    struct device_driver  *driver;\n    void *platform_data;\n    void *driver_data;\n    struct dev_pm_domain  *pm_domain;\n    struct device_node    *of_node; \n    struct fwnode_handle  *fwnode;\n    dev_t       devt;\n    u32         id;\n    [...]\n};\n```", "```\nstruct device_driver {\n    const char        *name;\n    struct bus_type   *bus;\n     struct module    *owner;\n     const struct of_device_id   *of_match_table;\n     const struct acpi_device_id *acpi_match_table;\n     int (*probe) (struct device *dev);\n     int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev,\n                      pm_message_t state);\n    int (*resume) (struct device *dev);\n    const struct dev_pm_ops *pm;\n};\n```", "```\nstatic struct platform_driver mypdrv = {\n    .probe = my_pdrv_probe,\n    .remove = my_pdrv_remove,\n    .driver = {\n        .name = KBUILD_MODNAME,\n        .owner = THIS_MODULE,\n    },\n};\nstatic int __init my_drv_init(void)\n{\n    /* Registering with Kernel */\n    platform_driver_register(&mypdrv);\n    return 0;\n}\nstatic void __exit my_pdrv_remove (void)\n{\n    /* Unregistering from Kernel */\n    platform_driver_unregister(&my_driver);\n}\nmodule_init(my_drv_init);\nmodule_exit(my_pdrv_remove);\n```", "```\nstatic struct platform_driver mypdrv = {\n    .probe = my_pdrv_probe,\n    .remove = my_pdrv_remove,\n    .driver = {\n        .name = KBUILD_MODNAME,\n        .owner = THIS_MODULE,\n    },\n};\nmodule_platform_driver(my_driver);\n```", "```\nstatic const struct spi_device_id mcp23s08_ids[] = {\n    { \"mcp23s08\", MCP_TYPE_S08 },\n    { \"mcp23s17\", MCP_TYPE_S17 },\n    { \"mcp23s18\", MCP_TYPE_S18 },\n    { },\n};\nstatic const struct of_device_id mcp23s08_spi_of_match[] = {\n    {\n        .compatible = \"microchip,mcp23s08\",\n        .data = (void *) MCP_TYPE_S08,\n    },\n    {\n        .compatible = \"microchip,mcp23s17\",\n        .data = (void *) MCP_TYPE_S17,\n    },\n    {\n        .compatible = \"microchip,mcp23s18\",\n        .data = (void *) MCP_TYPE_S18,\n    },\n    { },\n};\nstatic struct spi_driver mcp23s08_driver = {\n    .probe  = mcp23s08_probe, /* don't care about this */\n    .remove = mcp23s08_remove, /* don't care about this */\n    .id_table = mcp23s08_ids,\n    .driver = {\n        .name    = \"mcp23s08\",\n        .of_match_table =\n                of_match_ptr(mcp23s08_spi_of_match),\n    },\n};\n```", "```\nMODULE_DEVICE_TABLE(<bus_type_name>,  <array_of_ids>)\n```", "```\nMODULE_DEVICE_TABLE(spi, mcp23s08_ids);\nMODULE_DEVICE_TABLE(of, mcp23s08_spi_of_match);\n```", "```\nroot:/lib/modules/5.10.10+fslc+g8dc0fcb# cat modules.alias\n# Aliases extracted from modules themselves.\nalias fs-msdos msdos\nalias fs-binfmt_misc binfmt_misc\nalias fs-configfs configfs\nalias iso9660 isofs\nalias fs-iso9660 isofs\nalias fs-udf udf\nalias of:N*T*Cmicrochip,mcp23s17* gpio_mcp23s08\nalias of:N*T*Cmicrochip,mcp23s18* gpio_mcp23s08\nalias of:N*T*Cmicrochip,mcp23s08* gpio_mcp23s08\nalias spi:mcp23s17 gpio_mcp23s08\nalias spi:mcp23s18 gpio_mcp23s08\nalias spi:mcp23s08 gpio_mcp23s08\nalias usb:v0C72p0011d*dc*dsc*dp*ic*isc*ip*in* peak_usb\nalias usb:v0C72p0012d*dc*dsc*dp*ic*isc*ip*in* peak_usb\nalias usb:v0C72p000Dd*dc*dsc*dp*ic*isc*ip*in* peak_usb\nalias usb:v0C72p000Cd*dc*dsc*dp*ic*isc*ip*in* peak_usb\nalias pci:v00008086d000015B8sv*sd*bc*sc*i* e1000e\nalias pci:v00008086d000015B7sv*sd*bc*sc*i* e1000e\n[...]\nalias usb:v0416pA91Ad*dc*dsc*dp*ic0Eisc01ip00in* uvcvideo\nalias of:N*T*Ciio-hwmon* iio_hwmon\nalias i2c:lm73 lm73\nalias spi:ad7606-4 ad7606_spi\nalias spi:ad7606-6 ad7606_spi\nalias spi:ad7606-8 ad7606_spi\n```", "```\nstruct bus_type {\n    const char    *name;\n    struct device    *dev_root;\n    int (*match)(struct device *dev,\n                   struct device_driver *drv);\n    int (*probe)(struct device *dev);\n    int (*remove)(struct device *dev);\n    /* [...] */\n};\n```", "```\nstatic int platform_match(struct device *dev,\n                           struct device_driver *drv)\n{\n    struct platform_device *pdev =\n                         to_platform_device(dev);\n    struct platform_driver *pdrv =\n                         to_platform_driver(drv);\n     /* Only bind to the matching driver when\n     * driver_override is set\n     */\n    if (pdev->driver_override)\n        return !strcmp(pdev->driver_override, drv->name);\n    /* Attempt an OF style match first */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n    /* Then try ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n    return 1;\n    /* Then try to match against the id table */\n    if (pdrv->id_table)\n        return platform_match_id(pdrv->id_table,\n                                       pdev) != NULL;\n    /* fall-back to driver name match */\n    return (strcmp(pdev->name, drv->name) == 0);\n}\n```", "```\nstatic const struct i2c_device_id *i2c_match_id(\n            const struct i2c_device_id *id,\n            const struct i2c_client *client)\n{\n    while (id->name[0]) {\n        if (strcmp(client->name, id->name) == 0)\n            return id;\n        id++;\n    }\n    return NULL;\n}\nstatic int i2c_device_match(struct device *dev, struct\n          device_driver *drv)\n{\n    struct i2c_client *client = i2c_verify_client(dev);\n    struct i2c_driver *driver;\n    if (!client)\n        return 0;\n    /* Attempt an OF style match */\n    if (of_driver_match_device(dev, drv))\n        return 1;\n    /* Then ACPI style match */\n    if (acpi_driver_match_device(dev, drv))\n        return 1;\n    driver = to_i2c_driver(drv);\n    /* match on an id table if there is one */\n    if (driver->id_table)\n        return i2c_match_id(driver->id_table,\n                               client) != NULL;\n    return 0;\n}\n```"]