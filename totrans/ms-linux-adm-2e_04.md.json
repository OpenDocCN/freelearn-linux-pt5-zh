["```\nsudo -v\n```", "```\nSorry, user sudo command usually grants elevated permissions for a limited time. Ubuntu, for example, has a 15-minute sudo elevation span, after which time a sudo user would need to authenticate again. Subsequent invocations of sudo may not prompt for a password if done within the sudo cache credential timeout.\nIf we don’t have a default superuser account, we can always use the root context to create new users (see the next chapter) and elevate them to **sudoer** privileges. We’ll learn more about this in the *Creating a superuser* section, later in this chapter.\nNow, let’s have a look at how to create, modify, and delete users.\nCreating, modifying, and deleting users\nIn this section, we explore a few command-line tools and some common tasks for managing users. The example commands and procedures are shown for Ubuntu and Fedora, but the same principles apply to any other Linux distribution. Some user management `useradd` is not available on Alpine Linux, and `adduser` should be used instead). Please check the documentation of the Linux distribution of your choice for the equivalent commands.\nCreating users\nTo create users, we can use either the `useradd` or the `adduser` command, although on some Linux distributions (for example, Debian or Ubuntu), the recommended way is to use the `adduser` command in favor of the low-level `useradd` utility. We’ll cover both in this section.\n`adduser` is a Perl script using `useradd`—basically, a shim of the `useradd` command—with a user-friendly guided configuration. Both command-line tools are installed by default in Ubuntu and Fedora. Let’s take a brief look at each of these commands.\nCreating users with useradd\nThe syntax for the `useradd` command is shown here:\n\n```", "```\n\n In its simplest invocation, the following command creates a user account (`julian`):\n\n```", "```\n\n The user information is stored in a `/etc/passwd` file. Here’s the related user data for `julian`:\n\n```", "```\n\n In our case, this is the output:\n![Figure 4.1 – The user record created with useradd](img/Figure_04_01_B19682.jpg)\n\nFigure 4.1 – The user record created with useradd\nLet’s analyze the related user record. Each entry is delimited by a colon (`:`) and is listed here:\n\n*   `julian`: Username\n*   `x`: Encrypted password (password hash is stored in `/etc/shadow`)\n*   `1001`: The UID\n*   `1001`: The user **group** **ID** (**GID**)\n*   `::` The **General Electric Comprehensive Operating Supervisor** (**GECOS**) field—for example, display name (in our case, empty), explained later in this section\n*   `/home/julian`: User home folder\n*   `/bin/sh`: Default login shell for the user\n\nImportant note\nThe GECOS field is a string of comma-delimited attributes, reflecting general information about the user account (for example, real name, company, and phone number). In Linux, the GECOS field is the fifth field in a user record. See more information at [https://en.wikipedia.org/wiki/Gecos_field](https://en.wikipedia.org/wiki/Gecos_field).\nWe can also use the `getent` command to retrieve the preceding user information, as follows:\n\n```", "```\n\n To view the UID (`uid`), GID (`gid`), and group membership associated with a user, we can use the `id` command, as follows:\n\n```", "```\n\n This command gives us the following output:\n![Figure 4.2 – The UID information](img/Figure_04_02_B19682.jpg)\n\nFigure 4.2 – The UID information\nWith the simple invocation of `useradd`, the command creates the user (`julian`) with some immediate default values (as enumerated), while other user-related data is empty—for example, we have no full name or password specified for the user yet. Also, while the home directory has a default value (for example, `/home/julian`), the actual filesystem folder will not be created unless the `useradd` command is invoked with the `-m` or the `--create-home` option, as follows:\n\n```", "```\n\n Without a home directory, regular users would not have the ability to save their files in a private location on the system. On the other hand, some system accounts may not need a home directory since they don’t have a login shell. For example, a database server (for example, PostgreSQL) may run with a non-root system account (for example, `postgres`) that only needs access to database resources in specific locations (for example, `/var/lib/pgsql`), controlled via other permission mechanisms (for example, **Security-Enhanced** **Linux** (**SELinux**)).\nFor our regular user, if we also wanted to specify a full name (display name), the command would change to this:\n\n```", "```\n\n The `-c, --comment` option parameter of `useradd` expects a *comment*, also known as the GECOS field (the fifth field in our user record), with multiple comma-separated values. In our case, we specify the full name (for example, `Julian`). For more information, check out the `useradd` manual (`man useradd`) or `useradd --help`.\nThe user still won’t have a password yet, and consequently, there would be no way for them to log in (for example, via a `julian`, we invoke the `passwd` command, like this:\n\n```", "```\n\n You can see the following output:\n![Figure 4.3 – Creating or changing the user password](img/Figure_04_03_B19682.jpg)\n\nFigure 4.3 – Creating or changing the user password\nThe `passwd` command will prompt for the new user’s password. With the password set, there will be a new entry added to the `/etc/shadow` file. This file stores the secure password hashes (not the passwords!) for each user. Only superusers can access the content of this file. Here’s the command to retrieve the related information for the user `julian`:\n\n```", "```\n\n You can also use the following command:\n\n```", "```\n\n The output of both commands is shown in the following screenshot:\n![Figure 4.4 – Information about the user from the shadow file](img/Figure_04_04_B19682.jpg)\n\nFigure 4.4 – Information about the user from the shadow file\nOnce the password has been set, in normal circumstances, the user can log in to the system (via SSH or GUI). If the Linux distribution has a GUI, the new user will show up on the login screen.\nAs noted, with the `useradd` command, we have low-level granular control over how we create user accounts, but sometimes we may prefer a more user-friendly approach. Enter the `adduser` command.\nCreating users with adduser\nThe `adduser` command is a Perl wrapper for `useradd`. The syntax for this command is shown here:\n\n```", "```\n\n `sudo` may prompt for the superuser password. `adduser` will prompt for the new user’s password and other user-related information (as shown in *Figure 4**.5*).\nLet’s create a new user account (`alex`) with `adduser`, as follows:\n\n```", "```\n\n The preceding command yields the following output:\n![Figure 4.5 – The adduser command](img/Figure_04_05_B19682.jpg)\n\nFigure 4.5 – The adduser command\nIn Fedora, the preceding invocation of the `adduser` command will simply run without prompting the user for a password or any other information.\nWe can see the related user entry in `/etc/passwd` with `getent`, as follows:\n\n```", "```\n\n The following is the output:\n![Figure 4.6 – Viewing user information with getent](img/Figure_04_06_B19682.jpg)\n\nFigure 4.6 – Viewing user information with getent\nIn the preceding examples, we created a regular user account. Administrators or superusers can also elevate the privileges of a regular user to a superuser. Let’s see how in the following section.\nCreating a superuser\nWhen a regular user is given the power to run `sudo`, they become a superuser. Let’s assume we have a regular user created via any of the examples shown in the *Creating* *users* section.\nPromoting the user to a superuser (or *sudoer*) requires a `sudo` group membership. In Linux, the `sudo` group is a reserved system group for users with elevated or `root` privileges. To make the user `julian` a sudoer, we simply need to add the user to the `sudo` group, like this (in Ubuntu):\n\n```", "```\n\n The `-aG` options of `usermod` instruct the command to append (`-a, --append`) the user to the specified group (`-G, --group`)—in our case, `sudo`.\nTo verify our user is now a sudoer, first make sure the related user information reflects the `sudo` membership by running the following command:\n\n```", "```\n\n This gives us the following output:\n![Figure 4.7 – Looking for the sudo membership of a user](img/Figure_04_07_B19682.jpg)\n\nFigure 4.7 – Looking for the sudo membership of a user\nThe output shows that the `sudo` group membership (GID) in the `groups` tag is `27(sudo)`.\nTo verify the `sudo` access for the user `julian`, run the following command:\n\n```", "```\n\n The preceding command prompts for the password of the user `julian`. A successful login would usually validate the superuser context. Alternatively, the user (`julian`) can run the `sudo -v` command in their terminal session to validate the `sudo` privileges. For more information on superuser privileges, see the *Understanding sudo* section earlier in the chapter.\nWith multiple users created, a system administrator may want to view or list all the users in the system. In the next section, we provide a few ways to accomplish this task.\nViewing users\nThere are a few ways for a superuser to view all users configured in the system. As previously noted, the user information is stored in the `/etc/passwd` and `/etc/shadow` files. Besides simply viewing these files, we can parse them and extract only the usernames with the following command:\n\n```", "```\n\n Alternatively, we can parse the `/etc/shadow` file, like this:\n\n```", "```\n\n In the preceding commands, we read the content from the related files (with `cat`). Next, we piped the result to a delimiter-based parsing (with `cut`, on the `:` delimiter) and picked the first field `(-f1`). Finally, we chose a paginated display of the results, using the `less` command (to exit the command’s output, press *Q*).\nNote the use of `sudo` for the `shadow` file since access is limited to superusers only, due to the sensitive nature of the password hash data. Alternatively, we can use the `getent` command to retrieve the user information.\nThe following command lists all the users configured in the system:\n\n```", "```\n\n The preceding command reads the `/etc/passwd` file. Alternatively, we can retrieve the same information from `/etc/shadow`, as follows:\n\n```", "```\n\n For both commands, we can further pipe the `getent` output to `| cut -d: -f1` to list only the usernames, like this:\n\n```", "```\n\n The output will be similar to this:\n![Figure 4.8 – Viewing usernames](img/Figure_04_08_B19682.jpg)\n\nFigure 4.8 – Viewing usernames\nWith new users created, administrators or superusers may want to change certain user-related information, such as password, password expiration, full name, or login shell. Next, we take a look at some of the most common ways to accomplish this task.\nModifying users\nA superuser can run the `usermod` command to modify user settings, with the following syntax:\n\n```", "```\n\n The examples in this section apply to a user we previously created (`julian`) with the simplest invocation of the `useradd` command. As noted in the previous section, the related user record in `/etc/passwd` has no full name for the user, and the user has no password either.\nLet’s change the following settings for our user (`julian`):\n\n*   `Julian` (initially empty)\n*   `/local/julian` (from default `/home/julian`)\n*   `/bin/bash` (from default `/bin/sh`)\n\nThe command-line utility for changing all the preceding information is shown here:\n\n```", "```\n\n Here are the command options, briefly explained:\n\n*   `-c, --comment \"Julian\"`: The full username\n*   `-d, --home local/julian`: The user’s new home directory\n*   `-m, --move`: Move the content of the current home directory to the new location\n*   `-s, --shell /bin/sh`: The user login shell\n\nThe related change, retrieved with the `getent` command, is shown here:\n\n```", "```\n\n We get the following output:\n![Figure 4.9 – The user changes reflected with getent](img/Figure_04_09_B19682.jpg)\n\nFigure 4.9 – The user changes reflected with getent\nHere are a few more examples of changing user settings with the `usermod` command-line utility.\nChanging the username\nThe `-l, --login` option parameter of `usermod` specifies a new login username. The following command changes the username from `julian` to `balog` (that is, first name to last name), as illustrated here:\n\n```", "```\n\n In a production environment, we may have to add to the preceding command, as we may also want to change the display name and the home directory of the user (for consistency reasons). In a previous example in the *Creating users with useradd* section, we showcased the `-d, --home` and `-m, --move` option parameters, which would accommodate such changes.\nLocking or unlocking a user\nA superuser or administrator may choose to temporarily or permanently lock a specific user with the `-L, --lock` option parameter of `usermod`, as follows:\n\n```", "```\n\n As a result of the preceding command, the login attempt for the user `julian` would be denied. Should the user try to SSH into the Linux machine, they would get a **Permission denied, please try again** error message. Also, the related username will be removed from the login screen if the Linux platform has a GUI.\nTo unlock the user, we invoke the `-U, --unlock` option parameter, as follows:\n\n```", "```\n\n The preceding command restores system access for the user.\nFor more information on the `usermod` utility, please check out the related documentation (`man usermod`) or the command-line help (`usermod --help`).\nAlthough the recommended way of modifying user settings is via the `usermod` command-line utility, some users may find it easier to manually edit the `/etc/passwd` file. The following section shows you how.\nModifying users via /etc/passwd\nA superuser can also manually edit the `/etc/passwd` file to modify user data by updating the relevant line. Although the editing can be done with a text editor of your choice (for example, `nano`), we recommend the use of the `vipw` command-line utility for a safer approach. `vipw` enables the required locks to prevent possible data corruption—for example, in case a superuser performs a change at the same time regular users change their password.\nThe following command initiates the editing of the `/etc/passwd` file by also prompting for the preferred text editor (for example, `nano` or `vim`):\n\n```", "```\n\n For example, we can change the settings for user `julian` by editing the following line:\n\n```", "```\n\n The meaning of the colon (`:`)-separated fields was previously described in the *Creating users with useradd* section. Each of these fields can be manually altered in the `/etc/passwd` file, resulting in changes equivalent to the corresponding `usermod` invocation.\nFor more information on the `vipw` command-line utility, you can refer to the related system manual (`man vipw`).\nAnother relatively common administrative task for a user account is to change a password or set up a password expiration. Although `usermod` can change a user password via the `-p` or `--password` option, it requires an encrypted hash string (and not a cleartext password). Generating an encrypted password hash would be an extra step. An easier way is to use the `passwd` utility to change the password.\nA superuser (administrator) can change the password of a user (for example, the user `julian`) with the following command:\n\n```", "```\n\n The output will ask for the new password for the respective user. To change the expiration time of a password (the password age), the `chage` command is used. For example, to set a 30-day password age for the user `julian`, we will use the following command:\n\n```", "```\n\n This will force the user `julian` to change their password every month. The password time availability is defined system-wide by the password policy. It is found inside the `/etc/login.defs` file, inside the `julian` as our example again):\n\n```", "```\n\n This command will force the user `julian` to enter their own password the first time they log in to the system.\nSometimes, administrators are required to remove specific users from the system. The next section shows a couple of ways of accomplishing this task.\nDeleting users\nThe most common way to remove users from the system is to use the `userdel` command-line tool. The general syntax of the `userdel` command is shown here:\n\n```", "```\n\n For example, to remove the user `julian`, a superuser would run the following command:\n\n```", "```\n\n Here are the command options used:\n\n*   `-f, --force`: Removes all files in the user’s home directory, even if not owned by the user\n*   `-r, --remove`: Removes the user’s home directory and mail spool\n\nThe `userdel` command removes the related user data from the system, including the user’s home directory (when invoked with the `-f` or `--force` option) and the related entries in the `/etc/passwd` and `/``etc/shadow` files.\nThere is also an alternative way, which could be handy in some odd cleanup scenarios. The next section shows how.\nDeleting users via /etc/passwd and /etc/shadow\nA superuser can edit the `/etc/passwd` and `/etc/shadow` files and manually remove the corresponding lines for the user (for example, `julian`). Please note that both files have to be edited for consistency and complete removal of the related user account.\nEdit the `/etc/passwd` file using the `vipw` command-line utility, as follows:\n\n```", "```\n\n Remove the following line (for the user `julian`):\n\n```", "```\n\n Next, edit the `/etc/shadow` file using the `-s` or `--shadow` option with `vipw`, as follows:\n\n```", "```\n\n Remove the following line (for the user `julian`):\n\n```", "```\n\n After editing the preceding files, a superuser may also need to remove the deleted user’s home directory, as follows:\n\n```", "```\n\n For more information on the `userdel` utility, please check out the related documentation (`man userdel`) or the command-line help (`userdel --help`).\nThe user management concepts and commands learned so far apply exclusively to individual users in the system. When multiple users in the system have a common access level or permission attribute, they are collectively referred to as a group. Groups can be regarded as standalone organizational units we can create, modify, or delete. We can also define and alter user memberships associated with groups. The next section focuses on group management internals.\nManaging groups\nLinux uses groups to organize users. Simply put, a group is a collection of users sharing a common attribute. Examples of such groups could be *employees*, *developers*, *managers*, and so on. In Linux, a group is uniquely identified by a GID. Users within the same group share the same GID.\nFrom a user’s perspective, there are two types of groups, outlined here:\n\n*   **Primary group**: The user’s initial (default) login group\n*   **Supplementary groups**: A list of groups the user is also a member of; also known as **secondary groups**\n\nEvery Linux user is a member of a primary group. A user can belong to multiple supplementary groups or no supplementary groups at all. In other words, there is one mandatory primary group associated with each Linux user, and a user can have multiple or no supplementary group memberships.\nFrom a practical point of view, we can look at groups as a permissive context of collaboration for a select number of users. Imagine a *developers* group having access to developer-specific resources. Each user in this group has access to these resources. Users outside the *developers* group may not have access unless they authenticate with a group password if the group has one.\nIn the following section, we provide detailed examples of how to manage groups and set up group memberships for users. Most related commands require *superuser* or `sudo` privileges.\nCreating, modifying, and deleting groups\nWhile our primary focus remains on group administrative tasks, some related operations still involve user-related commands. Command-line utilities such as `groupadd`, `groupmod`, and `groupdel` are targeted strictly at creating, modifying, and deleting groups, respectively. On the other hand, the `useradd` and `usermod` commands carry group-specific options when associating users with groups. We’ll also introduce you to `gpasswd`, a command-line tool specializing in group administration, combining user- and group-related operations.\nWith this aspect in mind, let’s take a look at how to create, modify, and delete groups and how to manipulate group memberships for users.\nCreating groups\nTo create a new group, a superuser invokes the `groupadd` command-line utility. Here’s the basic syntax of the related command:\n\n```", "```\n\n Let’s create a new group (`developers`), with default settings, as follows:\n\n```", "```\n\n The group information is stored in the `/etc/group` file. Here’s the related data for the `developers` group:\n\n```", "```\n\n The command yields the following output:\n![Figure 4.10 – The group with default attributes](img/Figure_04_10_B19682.jpg)\n\nFigure 4.10 – The group with default attributes\nLet’s analyze the related group record. Each entry is delimited by a colon (`:`) and is listed here:\n\n*   `developers`: Group name\n*   `x`: Encrypted password (password hash is stored in `/etc/gshadow`)\n*   `1003`: GID\n\nWe can also use the `getent` command to retrieve the preceding group information, as follows:\n\n```", "```\n\n A superuser may choose to create a group with a specific GID, using the `-g, --gid` option parameter with `groupadd`. For example, the following command creates the `developers` group (if it doesn’t exist) with a GID of `1200`:\n\n```", "```\n\n For more information on the `groupadd` command-line utility, please refer to the related documentation (`man groupadd`).\nGroup-related data is stored in the `/etc/group` and `/etc/gshadow` files. The `/etc/group` file contains generic group membership information, while the `/etc/gshadow` file stores the encrypted password hashes for each group. Let’s take a brief look at group passwords.\nUnderstanding group passwords\nBy default, a group doesn’t have a password when created with the simplest invocation of the `groupadd` command (for example, `groupadd developers`). Although `groupadd` supports an encrypted password (via the `-p, --password` option parameter), this would require an extra step to generate a secure password hash. There’s a better and simpler way to create a group password: by using the `gpasswd` command-line utility.\nImportant note\n`gpasswd` is a command-line tool that helps with everyday group administration tasks.\nThe following command creates a password for the `developers` group:\n\n```", "```\n\n We get prompted to enter and re-enter a password, as illustrated here:\n![Figure 4.11 – Creating a password for the developers group](img/Figure_04_11_B19682.jpg)\n\nFigure 4.11 – Creating a password for the developers group\nThe purpose of a group password is to protect access to group resources. A group password is inherently insecure when shared among group members, yet a Linux administrator may choose to keep the group password private while group members collaborate unhindered within the group’s security context.\nHere’s a quick explanation of how it works. When a member of a specific group (for example, `developers`) logs in to that group (using the `newgrp` command), the user is not prompted for the group password. When users who don’t belong to the group attempt to log in, they will be prompted for the group password.\nIn general, a group can have administrators, members, and a password. Members of a group who are the group’s administrators may use `gpasswd` without being prompted for a password, as long as they’re logged in to the group. Also, group administrators don’t need superuser privileges to perform group administrative tasks for a group they are the administrator of.\nWe’ll take a closer look at `gpasswd` in the next sections, where we further focus on group management tasks, as well as adding users to a group and removing users from a group. But for now, let’s keep our attention strictly at the group level and see how we can modify a user group.\nModifying groups\nThe most common way to modify the definition of a group is via the `groupmod` command-line utility. Here’s the basic syntax for the command:\n\n```", "```\n\n The most common operations when changing a group’s definition are related to the GID, group name, and group password. Let’s take a look at each of these changes. We assume our previously created group is named `developers`, with a GID of `1003`.\nTo change the GID to `1200`, a superuser invokes the `groupmod` command with the `-g, --gid` option parameter, as follows:\n\n```", "```\nsudo groupmod -n devops group with the following command:\n\n```", "```\n\n The command yields the following output:\n![Figure 4.12 – Verifying the group changes](img/Figure_04_12_B19682.jpg)\n\nFigure 4.12 – Verifying the group changes\nTo change the group password for `devops`, the simplest way is to use `gpasswd`, as follows:\n\n```", "```\n\n We are prompted to enter and re-enter a password.\nTo remove the group password for `devops`, we invoke the `gpasswd` command with the `-r, --remove-password` option, as follows:\n\n```", "```\n\n As the command has no visible outcome or message, we will be prompted back to the shell:\n![Figure 4.13 – Setting a new group password and removing a group password](img/Figure_04_13_B19682.jpg)\n\nFigure 4.13 – Setting a new group password and removing a group password\nFor more information on `groupmod` and `gpasswd`, refer to the system manuals of these utilities (`man groupmod` and `man gpasswd`), or simply invoke the `-h, --help` option for each.\nNext, we look at how to delete groups.\nDeleting groups\nTo delete groups, we use the `groupdel` command-line utility. The related syntax is shown here:\n\n```", "```\n\n By default, Linux enforces referential integrity between a primary group and the users associated with that primary group. We cannot delete a group that has been assigned as a primary group for some users before deleting the users of that primary group. In other words, by default, Linux doesn’t want to leave the users with dangling primary GIDs.\nFor example, when we first added the user `julian`, they were assigned automatically to the `julian` primary group. We then added the user to the `sudoers` group.\nLet’s attempt to add the user `julian` to the `devops` group. A superuser may run the `usermod` command with the `-g, --gid` option parameter to *change* the primary group of a user. The command should be invoked for each user. Here’s an example of removing the user `julian` from the `julian` primary group. First, let’s get the current data for the user, as follows:\n\n```", "```\n\n This is the output:\n![Figure 4.14 – Retrieving the current primary group for the user](img/Figure_04_14_B19682.jpg)\n\nFigure 4.14 – Retrieving the current primary group for the user\nNow, let us add the user `julian` to the `devops` group. The `-g, --gid` option parameter of the `usermod` command accepts both a *GID* and a group *name*. The specified group name must already be present in the system; otherwise, the command will fail. If we want to change the primary group (for example, to `devops`), we simply specify the group name in the `-g, --gid` option parameter, as follows:\n\n```", "```\n\n The output is shown in the following screenshot:\n![Figure 4.15 – Changing the primary group of the user](img/Figure_04_15_B19682.jpg)\n\nFigure 4.15 – Changing the primary group of the user\nThe result is that the user `julian` is now part of the `devops` group.\nNow, let us attempt to delete the `devops` group, which is the primary group for the user `julian`. Attempting to delete the `devops` group results in an error, as can be seen in *Figure 4**.16* (the first command used). Therefore, we cannot delete a group that is not empty.\nA superuser may choose to *force* the deletion of a primary group, invoking `groupdel` with the `-f, --force` option, but this would be ill advised. This is because the command would result in users with orphaned primary GIDs and a possible security hole in the system. The maintenance and removal of such users would also become problematic.\nIn order to be able to delete the `devops` group, we need to assign another group to the user `julian`. What we can do is assign it to the initial primary group called `julian`, and then attempt to delete the `devops` group, now that it is empty. First, let us assign the user `julian` to the `julian` group with the following command:\n\n```", "```\n\n At this point, it’s safe to delete the group (`devops`), as follows:\n\n```", "```\n\n The outcome from the preceding commands is this:\n![Figure 4.16 – Successful attempt to delete the group](img/Figure_04_16_B19682.jpg)\n\nFigure 4.16 – Successful attempt to delete the group\nFor more information on the `groupdel` command-line utility, check out the related system manual (`man groupdel`), or simply invoke `groupdel --help`.\nModifying groups via /etc/group\nAn administrator can also manually edit the `/etc/group` file to modify group data by updating the related line. Although the editing can be done with a text editor of your choice (for example, `nano`), we recommend the use of the `vigr` command-line utility for a safer approach. `vigr` is similar to `vipr` (for modifying `/etc/passwd`) and sets safety locks to prevent possible data corruption during concurrent changes of group data.\nThe following command opens the `/etc/group` file for editing by also prompting for the preferred text editor (for example, `nano` or `vim`):\n\n```", "```\n\n For example, we can change the settings for the `developers` group by editing the following line:\n\n```", "```\n\n When deleting groups using the `vigr` command, we’re also prompted to remove the corresponding entry in the group shadow file `(/etc/gshadow`). The related command invokes the `-s` or `--shadow` option, as illustrated here:\n\n```", "```\n\n For more information on the `vigr` utility, please refer to the related system manual (`man vigr`).\nAs with most Linux tasks, all the preceding tasks could have been accomplished in different ways. The commands chosen are the most common ones, but there might be cases when a different approach may prove more appropriate.\nIn the next section, we’ll take a glance at how to add users to primary and secondary groups and how to remove users from these groups.\nManaging users in groups\nSo far, we’ve only created groups that have no users associated. There is not much use for empty user groups, so let’s add some users to them.\nAdding users to a group\nBefore we start adding users to a group, let’s create a few groups. In the following example, we create the groups by also specifying their GID (via the `-g, --gid` option parameter of the `groupadd` command):\n\n```", "```\n\n We can check the last groups created by using the following command:\n\n```", "```\n\n It will show us the last five lines of the `/etc/group` file. We can see the last five groups created.\nNext, we create a couple of new users (`alex2` and `julian2` as we already have users `alex` and `julian`) and add them to some of the groups we just created. We’ll have the `admin` group set as the *primary group* for both users, while the `developers` and `devops` groups are defined as *secondary* (or *supplementary*) *groups*. The code can be seen here:\n\n```", "```\n\n The `-g, --gid` option parameter of the `useradd` command specifies the (unique) primary group (`admin`). The `-G, --groups` option parameter provides a comma-separated list (without intervening spaces) of the secondary group names (`developers``,``devops`).\nWe can verify the group memberships for both users with the following commands:\n\n```", "```\n\n The output is shown in the following screenshot:\n![Figure 4.17 – Assigning groups to new users](img/Figure_04_17_B19682.jpg)\n\nFigure 4.17 – Assigning groups to new users\nAs we can see, the `gid` attribute shows the primary group membership: `gid=1100(admin)`. The `groups` attribute shows the supplementary (secondary) groups: `groups=1100(admin),1200(developers),1300(devops)`.\nWith users scattered across multiple groups, an administrator is sometimes confronted with the task of moving users between groups. The following section shows how to do this.\nMoving and removing users across groups\nBuilding upon the previous example, let’s assume the administrator wants to move (or add) the user `alex2` to a new secondary group called `managers`. Please note that, according to our previous examples, the user `alex2` has `admin` as the primary group and `developers`/`devops` as secondary groups (see the output of the `id alex2` command in *Figure 4**.18*).\nLet’s create a `managers` group first, with GID `1400`. The code can be seen here:\n\n```", "```\n\n Next, add our existing user, `alex2`, to the `managers` group. We use the `usermod` command with the `-G, --groups` option parameter to specify the secondary groups the user is associated with.\nThe simplest way to *append* a secondary group to a user is by invocation of the `-a, --append` option of the `usermod` command, as illustrated here:\n\n```", "```\n\n The preceding command would preserve the existing secondary groups for the user `alex2` while adding the new `managers` group. Alternatively, we could run the following command:\n\n```", "```\n\n In the preceding command, we specified multiple groups (with no intervening whitespace!).\nImportant note\nWe preserved the existing secondary groups (`developers`/`devops`) and *appended* to the comma-separated list the `managers` additional secondary group. If we only had the `managers` group specified, the user `alex2` would have been *removed* from the `developers` and `devops` secondary groups.\nTo verify whether the user `alex2` is now part of the `managers` group, run the following command:\n\n```", "```\n\n This is the output of the command:\n\n```", "```\nsudo usermod -G managers alex2\n```", "```\nsudo usermod -G '' alex2\n```", "```\nid alex\n```", "```\nsudo usermod -g managers alex2\n```", "```\nid alex2\n```", "```\nsudo groupadd -g 1004 alex2\n```", "```\nsudo usermod -g alex2 alex2\n```", "```\nid alex2\n```", "```\ncat /etc/group | cut -d: -f1 | column | less\n```", "```\ngetent group | cut -d: -f1 | column | less\n```", "```\ngetent group developers\n```", "```\ngroups alex\n```", "```\ngroups\n```", "```\nnewgrp GROUP\n```", "```\nid julian\n```", "```\nsu julian\n```", "```\nwhoami\n```", "```\ngroups\n```", "```\nid\n```", "```\nid -g\n1100\n```", "```\nnewgrp developers\n```", "```\nid -g\n1200\n```", "```\nnewgrp managers\n```", "```\nls [OPTIONS] FILE|DIRECTORY\n```", "```\nls -l /etc/passwd\n```", "```\n-rw-r--r-- 1 root root 2010 Mar  9 08:57 /etc/passwd\n```", "```\n-rw-r--r-- 1 root root 2010 Mar  9 08:57 /etc/passwd\n```", "```\nstat --format '%a' /etc/passwd\n```", "```\n644\n```", "```\nchmod o+w myfile\n```", "```\nchmod u-rw myfile\n```", "```\nchmod u-r,ug-w,o-rwx myfile\n```", "```\nchmod 777 myfile\n```", "```\nchown [OPTIONS] [OWNER][:[GROUP]] FILE\n```", "```\nsudo chown julian:developers myfile\n```", "```\nsudo chown -R julian:julian mydir/\n```", "```\nchgrp [OPTIONS] GROUP FILE\n```", "```\nsudo chgrp developers myfile\n```", "```\ntouch myfile2\nstat --format '%a' myfile2\n```", "```\n664\n```", "```\nmkdir mydir2\nstat --format '%a' mydir2\n```", "```\n775\n```", "```\nchmod u+s myscript.sh\n```", "```\nchmod g+s myscript.shw\n```", "```\nchmod +t mydir\n```", "```\n\n```", "```\n\n```"]