- en: '*Chapter 17*: Leveraging the Linux Kernel Input Subsystem'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input devices are devices that you can use to interact with the system. Such
    devices include buttons, keyboards, touchscreens, mice, and more. They work by
    sending events that are caught and broadcast over the system by the input core.
    This chapter will explain each structure that's used by the input core to handle
    input devices, as well as how to manage events from the user space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Linux kernel input subsystem – its data structures and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and registering an input device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using polled input devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and reporting input events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling input devices from the user space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the Linux kernel input subsystem – its data structures and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main data structures and APIs of this subsystem can be found in the `include`/`linux`/`input.h`
    files. The following line is required in any input device driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever type of input device it is, whatever type of event it sends, an input
    device is represented in the kernel as an instance of the struct `input_dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of readability, some elements in the structure have been omitted.
    Let''s look at these fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` represents the name of the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phys` is the physical path to the device in the system hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evbit` is a bitmap of the types of events that are supported by the device.
    The following are some events:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_KEY` is for devices that support sending key events (for example, keyboards,
    buttons, and so on)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_REL` is for devices that support sending relative positions (for example,
    mice, digitizers, and so on)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_ABS` is for devices that support sending absolute positions (for example,
    joysticks) The list of events is available in the kernel source in the`include/linux/input-event-codes.h`
    file. You can use the `set_bit()` macro to set the appropriate bit, depending
    on your input device''s capabilities. Of course, a device can support more than
    one type of event. For example, a mouse driver will set both `EV_KEY` and `EV_REL`,
    as shown here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`keybit` is for `EV_KEY` enabled devices and consists of a bitmap of keys/buttons
    that this device exposes; for example, `BTN_0`, `KEY_A`, `KEY_B`, and so on. The
    complete list of keys/buttons can be found in the `include/linux/input-event-codes.h`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relbit` is for `EV_REL` enabled devices and consists of a bitmap of relative
    axes for the device; for example, `REL_X`, `REL_Y`, `REL_Z`, and so on. Have a
    look at `include/linux/input-event-codes.h` for the complete list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`absbit` is for `EV_ABS` enabled devices and consists of a bitmap of absolute
    axes for the device; for example, `ABS_Y`, `ABS_X`, and so on. Have a look at
    the same previous file for the complete list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mscbit` is for `EV_MSC` enabled devices and consists of a bitmap of miscellaneous
    events that are supported by the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat_key` stores the key code of the last key pressed; it is used when the
    autorepeat feature is implemented by the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rep` stores the current values for auto repeat parameters, typically the delay
    and rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`absinfo` is an array of `&struct input_absinfo` elements that holds information
    about the absolute axes (the current value, `min`, `max`, `flat`, `fuzz`, and
    the resolution). You should use the `input_set_abs_params()` function to set those
    values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`min` and `max` specify the lower and upper bound values, respectively. `fuzz`
    indicates the expected noise on the specified channel of the specified input device.
    In the following examples, we''re setting each channel''s bound:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`key` reflects the current state of the device''s keys/buttons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` is a method that''s called when the very first user calls `input_open_device()`.
    Use this method to prepare the device, such as to interrupt a request, poll a
    thread start, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close` is called when the very last user calls `input_close_device()`. Here,
    you can stop polling (which consumes a lot of resources).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` stores the number of users (input handlers) that opened this device.
    It is used by `input_open_device()` and `input_close_device()` to ensure that
    `dev->open()` is only called when the first user opens the device and that `dev->close()`
    is only called when the very last user closes the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` is the struct device associated with this device (for device model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_vals` is the number of values that are queued in the current frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_vals` is the maximum number of values that are queued in a frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vals` is the array of values that are queued in the current frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devres_managed` indicates that the devices are managed with the **devres**
    framework and don''t need to be explicitly unregistered or freed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you're familiar with the main input device's data structure, we can
    start registering such devices within the system.
  prefs: []
  type: TYPE_NORMAL
- en: Allocating and registering an input device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the events that are supported by an input device can be seen by the
    system, memory needs to be allocated for this device first using the `devm_input_allocate_device()`
    API. Then, the device needs to be registered with the system using `input_device_register()`.
    The former API will take care of freeing up the memory and unregistering the device
    when it leaves the system. However, non-managed allocation is still available
    but not recommended, `input_allocate_device()`. By using non-managed allocation,
    the driver becomes responsible for making sure that `input_unregister_device()`
    and `input_free_device()` are called to unregister the device and free its memory
    when they''re on the unloading path of the driver, respectively. The following
    are the respective prototypes of these APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Device allocation may sleep, so it must not be called in the atomic context
    or with a spinlock being held. The following is an excerpt of the `probe` function
    of an input device sitting on the I2C bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, in the preceding code, no memory freeing nor device
    unregistering is performed when an error occurs because we have used the managed
    allocation for both the input device and the IRQ. That said, the input device
    has an IRQ line so that we're notified of a state change on the underlying device.
    This is not always the case as the system may lack available IRQ lines, in which
    case the input core will have to poll the device frequently so that it doesn't
    miss events. We discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using polled input devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polled input devices are special input devices that rely on polling to sense
    device state changes; the generic input device type relies on IRQ to sense changes
    and send events to the input core.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polled input device is described in the kernel as an instance of `struct
    input_polled_dev` structure, which is a wrapper around the generic `struct input_dev`
    structure. The following is its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the elements in this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` is the driver''s private data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` is an optional method that prepares the device for polling (enables
    the device and sometimes flushes the device''s state).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close` is an optional method that is called when the device is no longer being
    polled. It is used to put devices into low power mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll` is a mandatory method that''s called whenever the device needs to be
    polled. It is called at the frequency of `poll_inteval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval` is the frequency at which the `poll()` method should be called.
    It defaults to 500 milliseconds unless it''s overridden when you''re registering
    the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval_max` specifies the upper bound for the poll interval. It defaults
    to the initial value of `poll_interval`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval_min` specifies the lower bound for the poll interval. It defaults
    to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input` is the input device that the polled device is built around. It must
    be initialized by the driver (by its ID, name, and bits). The polled input device
    just provides an interface to use polling instead of IRQ, to sense device state
    change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory can be allocated for a polled input device using `devm_input_allocate_polled_device()`.
    This is a managed allocation API that takes care of freeing memory and unregistering
    the device as appropriate. Similarly, the non-managed API can be used for allocation,
    `input_allocate_polled_device()`, in which case you must take care of calling
    `input_free_polled_device()` by yourself. The following code shows the prototypes
    of those APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For resource-managed devices, the `input_dev->devres_managed` field will be
    set to `true` by the input core. Then, you should take care of initializing the
    mandatory fields of the underlying `struct input_dev`, as we saw in the previous
    section. The polling interval must be set too; otherwise, it will default to 500
    ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the fields have been allocated and initialized, the polled input device
    can be registered using `input_register_polled_device()`, which returns `0` on
    success. For managed allocation, unregistering is handled by the system; you need
    to call `input_unregister_polled_device()` by yourself to perform the reverse
    operation. The following are their prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical example of the `probe()` function for such a device may look as follows.
    First, we define the driver data structure, which will gather all the necessary
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the driver data structure has been defined, the `probe()` function can
    be implemented. The following is its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once again, neither unregistering nor freeing are handled by ourselves when
    an error occurs because we have used managed allocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what our `open` callback may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our example, it does nothing. However, the `open` method is used to prepare
    the resources that are needed by the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deciding whether you should implement a polled input device is straightforward.
    The usual way is to use classic input devices if an IRQ line is available; alternatively,
    you can fall back to the polled device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other elements may need to be considered when you're choosing between implementing
    a polled input device or an IRQ-based one; the preceding code is just a suggestion.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with this subset of input devices, we can consider
    registering and unregistering input devices. That said, even though the input
    device has been registered, we can't interact with it yet. In the next section,
    we will learn how the input device can report events to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Generating and reporting input events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device allocation and registration are essential, but they are useless if the
    device is unable to report events to the input core, which is what input devices
    are designed to do. Depending on the type of event our device can support, the
    kernel provides the appropriate APIs to report them to the core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an `EV_XXX` capable device, the corresponding report function would be
    `input_report_xxx()`. The following table shows the mappings between the most
    important event types and their report functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 17.1 – Mapping the input device''s capabilities and the report APIs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_Table_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 17.1 – Mapping the input device's capabilities and the report APIs
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototypes for these report APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of available report functions can be found in `include/linux/input.h`
    in the kernel source file. They all have the same skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` is the input device that''s responsible for the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code` represents the event code; for example, `REL_X` or `KEY_BACKSPACE`.
    The complete list can be found in `include/linux/input-event-codes.h`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the value the event carries. For an `EV_REL` event type, it carries
    the relative change. For an `EV_ABS` (joysticks and so on) event type, it contains
    an absolute new value. For an `EV_KEY` event type, it should be set to `0` for
    key release, `1` for a keypress, and `2` for auto-repeat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once all these changes have been reported, the driver should call `input_sync()`
    on the input device to indicate that this event is complete. The input subsystem
    will collect these events into a single packet and send it through `/dev/input/event<X>`,
    which is the character device that represents our `struct input_dev` on the system.
    Here, `<X>` is the interface number that''s been assigned to the driver by the
    input core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example of this. The following is an excerpt from the `drivers/input/misc/bma150.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding excerpt, `input_sync()` tells the core to consider the three
    reports as the same event. This makes sense since the position has three axes
    (*X*, *Y*, and *Z*) and we do not want *X*, *Y*, or *Z* to be reported separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to report the event is inside the poll function for a polled
    device or the IRQ routine (threaded part or not) for an IRQ-enabled device. If
    you perform some operations that may sleep, you should process your report inside
    the threaded part of the IRQ handler. The following code shows how our initial
    example could implement the `poll` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, our input device reports the `0` key code. In the next
    section, we will discuss how the user space can handle those report events and
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: Handling input devices from the user space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A node will be created in the `/dev/input/` directory for each input device
    (polled or not) that has been successfully registered with the system. In my case,
    the node corresponds to `event0` because it is the first and only input device
    on my target board. You can use the `udevadm` tool to display information about
    the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another tool that you can use, which allows you to print the keys that are
    supported by the device, is `evetest`. It can also catch and print events when
    they are reported by the device. The following code shows its usage on our input
    device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only the input devices we have written drivers for can be managed with
    `evetest`. In the following example, I am using the USB-C headset that''s connected
    to my computer. It has input device capabilities since it provides volume-related
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I pushed the up volume key to see how it is reported.
    `evtest` can even be used with your keyboard, with the only condition being that
    you identify the corresponding input device node in `/dev/input/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, every registered input device is represented by a `/dev/input/event<X>`
    character device, which we can use to read the event from the user space. An application
    that''s reading this file will receive event packets in the `struct input_event`
    format, which has the following declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the meaning of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`time` is a timestamp that corresponds to the time when the event happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` is the event type; for example, `EV_KEY` for a keypress or release,
    `EV_REL` for a relative moment, or `EV_ABS` for an absolute one. More types are
    defined in `include/linux/input-event-codes.h`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code` is the event code; for example, `REL_X` or `KEY_BACKSPACE`. Again, a
    complete list can be found in `include/linux/input-event-codes.h`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the value that the event carries. For an `EV_REL` event type, it
    carries the relative change. For an `EV_ABS` (joysticks and so on) event type,
    it contains the absolute new value. For an `EV_KEY` event type, it is set to `0`
    for a key release, `1` for a keypress, and `2` for auto-repeat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A user space application can use blocking and non-blocking reads, but also
    `poll()` or `select()` system calls, to be notified of events after opening this
    device. The following is an example of the `select()` system call. Let''s start
    by enumerating the headers we need to implement our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must define our input device path as a macro as it will be used often:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we must open the input device and keep its file descriptor for later
    use. Failing to open the input device is considered as an error, so we must exit
    the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a file descriptor representing our opened input device. We can
    use the `select()` system call to sense any key press or release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have done the necessary sanity checks on the return path of
    `select()`. Note that `select()` returns zero if it timed out before any file
    descriptors became ready, hence `else if` in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is effective now, let''s read the data to see what it corresponds
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If the execution flow reaches this mean, it means that everything went well.
    Now, we can walk through the events that are supported by our input device and
    compare them to the event that is reported by the input core before a decision
    is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For further debugging purposes, if your input device is based on GPIOs, you
    can successively push/release the button and check whether the GPIO''s state has
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, if the input device has an IRQ line, it may make sense to check the
    statistic for this IRQ line to make sure it is coherent. For example, here, we
    must check whether the request has succeeded and how many times it has been fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we learned how to deal with the input device from the user
    space and provided some debugging tips for when something goes wrong. We used
    the `select()` system call to sense input events, though we could have used `poll()`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described the input framework and highlighted the difference between
    polled and interrupt-driven input devices. At this point, you should have the
    necessary knowledge to write a driver for any input driver, whatever its type,
    and whatever input event it supports. The user space interface was also discussed,
    and an example was provided.
  prefs: []
  type: TYPE_NORMAL
