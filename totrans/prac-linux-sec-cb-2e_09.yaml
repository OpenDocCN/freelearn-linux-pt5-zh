- en: Bash Vulnerability Patching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash漏洞修复
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Understanding the Bash vulnerability – Shellshock
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Bash漏洞 - Shellshock
- en: Security issues – Shellshock
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全问题 - Shellshock
- en: Patch management system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁管理系统
- en: Integrating patches on the Linux network
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux网络上集成补丁
- en: Other well-known Linux vulnerabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他知名Linux漏洞
- en: Understanding the Bash vulnerability – Shellshock
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Bash漏洞 - Shellshock
- en: '**Shellshock** or **Bashdoor** is a vulnerability that occurs in most versions
    of Linux and Unix operating systems. It was discovered on September 12, 2014,
    and affects all distributions of Linux using Bash shell. Shellshock vulnerability
    makes it possible to execute commands remotely using environment variables.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shellshock**或**Bashdoor**是大多数Linux和Unix操作系统版本中存在的漏洞。它于2014年9月12日被发现，并影响所有使用Bash
    shell的Linux发行版。Shellshock漏洞使得通过环境变量可以远程执行命令。'
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To understand Shellshock, we will need a Linux system using a version of Bash
    prior to 4.3, which is vulnerable to this bug.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Shellshock，我们需要一个使用Bash 4.3之前版本的Linux系统，该版本存在此漏洞。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, we will see how to set up our system to understand the internal
    details of Shellshock vulnerability:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何设置系统以理解Shellshock漏洞的内部细节：
- en: 'The first step to perform will be to check the version of Bash on the Linux
    system so that we can find out if our system is vulnerable to **Shellshock**.
    To check our version of Bash, run the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行的第一步是检查Linux系统中Bash的版本，以便我们可以找出系统是否易受**Shellshock**攻击。检查Bash版本，请运行以下命令：
- en: '![](img/e5fc2b9d-74cc-4060-b673-24920443b892.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5fc2b9d-74cc-4060-b673-24920443b892.png)'
- en: Bash versions through 4.3 have been reported to be vulnerable to Shellshock.
    For our example, we are using Ubuntu 12.04 LTS, desktop version. From the output
    in the preceding screenshot, we can understand that this system is vulnerable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过4.3版本的Bash已被报告存在Shellshock漏洞。在我们的示例中，我们使用的是Ubuntu 12.04 LTS桌面版。从前面的截图输出中，我们可以看出该系统是有漏洞的。
- en: 'Now, let''s check if the vulnerability actually exists or not. To do so, we
    run the following code:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查漏洞是否真的存在。为此，我们运行以下代码：
- en: '![](img/43cdcd58-d070-4c1a-9a61-44d2b848310c.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43cdcd58-d070-4c1a-9a61-44d2b848310c.png)'
- en: Once we run the preceding command, if the output has `shellshock` printed, it
    confirms the vulnerability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了上述命令，如果输出中打印了`shellshock`，则确认该漏洞的存在。
- en: Now, let's understand the insights of the vulnerability. For this, first, we
    need to understand the basics of Bash shell variables.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们理解这个漏洞的内在原理。为此，首先我们需要了解Bash shell变量的基础知识。
- en: 'If we want to create a variable named `testvar` in bash and store a value of
    `''shellshock''` in it, we must run the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想在bash中创建一个名为`testvar`的变量，并将值`'shellshock'`存储其中，我们必须运行以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we wish to print the value of this variable, we can use the `echo`
    command, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们希望打印这个变量的值，可以使用`echo`命令，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will open a child process of bash by running the `bash` command. Then,
    one again, we to try to print the value of the variable `testvar` in the child
    process:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过运行`bash`命令打开一个bash子进程。然后，再次尝试在子进程中打印变量`testvar`的值：
- en: '![](img/2ecf64cc-451d-46f1-8456-6e5e5d3c133a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ecf64cc-451d-46f1-8456-6e5e5d3c133a.png)'
- en: We can see that we are not able to get any output when we try to print the value
    in the child process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当我们尝试在子进程中打印变量值时，没有任何输出。
- en: Now, we will try to do the same thing by using environment variables of bash.
    When we start a new shell session of bash, a few variables are available for use,
    and these are called **environment variables**.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将尝试通过使用bash的环境变量来做同样的事情。当我们启动一个新的bash shell会话时，会有一些变量可供使用，这些变量被称为**环境变量**。
- en: 'To make our `testvar` variable an environment variable, we will export it.
    Once exported, we can use it in the child shell also, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将我们的`testvar`变量变成环境变量，我们将进行导出。一旦导出，我们也可以在子shell中使用它，如下所示：
- en: '![](img/304f4052-44cc-44ae-a6a8-ba01fe3f8ed5.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/304f4052-44cc-44ae-a6a8-ba01fe3f8ed5.png)'
- en: 'As we have defined variables and then exported them, in the same way, we can
    define a function and export it as well, in order to make it available in a child
    shell. The following steps show how to define a function and export it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们已经定义了变量并将其导出一样，类似地，我们也可以定义一个函数并将其导出，以便在子shell中使用。以下步骤展示了如何定义函数并导出它：
- en: '![](img/aa4c6602-48ed-4937-b57a-a3e30cad4a99.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa4c6602-48ed-4937-b57a-a3e30cad4a99.png)'
- en: We can see in the preceding example that the function `x` has been defined and
    it has been exported using the `-f` flag.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的示例中看到，函数`x`已经被定义，并且使用`-f`标志进行了导出。
- en: 'Now, let''s define a new variable, name it `testfunc`, and assign its value,
    as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们定义一个新的变量，将其命名为`testfunc`，并为其赋值，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The previously defined variable can be accessed in the same way as a regular
    variable is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的变量可以像常规变量一样访问：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will export this variable to make to an environment variable and then
    try to access it from the child shell, as shown in the following screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导出这个变量，使其成为一个环境变量，然后尝试从子shell中访问它，如下所示：
- en: '![](img/e3bfc087-e605-45b0-9640-0a15c6d37310.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bfc087-e605-45b0-9640-0a15c6d37310.png)'
- en: We can see something unexpected in the preceding result. In the parent shell,
    the variable is accessed as a normal variable. However, in the child shell, it
    gets interpreted as a function and executes the body of the function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的结果中看到一些意外的情况。在父shell中，变量作为普通变量访问。然而，在子shell中，它被解释为一个函数，并执行函数体。
- en: 'Next, we will terminate the definition of the function and then pass any arbitrary
    command, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将终止函数的定义，并传递任意命令，如下所示：
- en: '![](img/9d16bb04-2380-4cdd-9ac0-5cd72efff415.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d16bb04-2380-4cdd-9ac0-5cd72efff415.png)'
- en: In the preceding example, we can see that as soon as we start a new `bash` shell,
    the code that was defined outside the function is executed during the startup
    of `bash`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到，一旦启动新的`bash` shell，定义在函数外的代码会在`bash`启动时执行。
- en: This is the vulnerability in `bash` shell.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`bash` shell中的漏洞。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first check the version of bash running on our system. Then, we run the well-known
    code to confirm if shellshock vulnerability exists.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查系统上运行的bash版本。然后，运行著名的代码来确认是否存在shellshock漏洞。
- en: To understand how shellshock vulnerability works, we create a variable in bash
    and then try to export it to the child shell and execute it there. Next, we try
    to create another variable and assign its value as `'() { echo 'shellshock';}'`.
    After doing this, when we export this variable to a child shell and execute it
    there, we can see that it gets interpreted as a function and executes the body
    of the function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解shellshock漏洞是如何工作的，我们在bash中创建一个变量，然后尝试将其导出到子shell并在那里执行。接下来，我们尝试创建另一个变量，并将其值赋为`'()
    { echo 'shellshock';}'`。做完这个之后，当我们将该变量导出到子shell并在其中执行时，我们可以看到它被解释为一个函数并执行函数体。
- en: This is what makes bash vulnerable to shellshock, where specially crafted variables
    can be used to run any command in bash when it is launched.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使bash容易受到shellshock攻击的原因，其中精心构造的变量可以在启动bash时执行任何命令。
- en: Security issues – Shellshock
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全问题 – Shellshock
- en: In this era of almost everything being online, online security is a major concern.
    Nowadays, many web servers, web-connected devices, and services use Linux as their
    platform. Most versions of Linux use the Unix bash shell so that the Shellshock
    vulnerability can affect a huge portion of websites and web servers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个几乎所有事物都在线的时代，网络安全是一个主要问题。如今，许多Web服务器、网络连接的设备和服务都使用Linux作为平台。大多数版本的Linux使用Unix
    bash shell，因此Shellshock漏洞可能影响大量网站和Web服务器。
- en: In the previous recipe, we understood the details about Shellshock vulnerability.
    Now, we will understand how this bug can be exploited through SSH.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们了解了关于Shellshock漏洞的详细信息。现在，我们将理解如何通过SSH利用这个漏洞。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To exploit Shellshock vulnerability, we need two systems. The first system will
    be used as the victim's, and should be vulnerable to Shellshock. In our case,
    we are using an Ubuntu system as the vulnerable system. The second system will
    be used as the attacker, and can have any Linux version running on it. For our
    case, we are running Kali on the second system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用Shellshock漏洞，我们需要两台系统。第一台系统将作为受害者系统，并且应当易受Shellshock攻击。在我们的案例中，我们使用Ubuntu系统作为脆弱系统。第二台系统将作为攻击者系统，可以运行任何Linux版本。对于我们的案例，第二台系统上运行的是Kali。
- en: 'The victim system will be running the `openssh-server` package. It can be installed
    using the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 受害系统将运行`openssh-server`包。可以使用以下命令进行安装：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will then configure this system as a vulnerable SSH server to show how it
    can be exploited using the Shellshock bug.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将配置该系统作为一个脆弱的SSH服务器，以展示如何利用Shellshock漏洞进行攻击。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To see how the Shellshock bug can be used to exploit a SSH server, we need
    to first configure our SSH server as a vulnerable system. To do so, we will follow
    these steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何利用 Shellshock 漏洞攻击 SSH 服务器，我们首先需要将 SSH 服务器配置为易受攻击的系统。为此，我们将按照以下步骤操作：
- en: 'The first step is to add a new user account called `user1` on the SSH server
    system. We must also add `/home/user1` as its home directory and `/bin/bash` as
    its shell:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是在 SSH 服务器系统上添加一个名为`user1`的新用户帐户。我们还必须将`/home/user1`设置为其主目录，并将`/bin/bash`作为其
    Shell：
- en: '![](img/d8ffdbb1-f272-45a0-bb5b-4e0ea955681d.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8ffdbb1-f272-45a0-bb5b-4e0ea955681d.png)'
- en: Once the account is added, we cross check it by checking the `/etc/passwd` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦帐户添加完毕，我们通过检查`/etc/passwd`文件来确认。
- en: 'Next, we create a directory for `user1` in `/home` and grant the ownership
    of this directory to the `user1` account:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`/home`下为`user1`创建一个目录，并将该目录的所有权授予`user1`账户：
- en: '![](img/6bdf8939-acfd-4a4c-8890-aa89f7073eea.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bdf8939-acfd-4a4c-8890-aa89f7073eea.png)'
- en: 'Now, we need to authenticate the attacker to login to the SSH server using
    the authorization keys. For doing this, we will first generate the authorization
    keys on the attacker''s system, using the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要通过授权密钥对攻击者进行身份验证，以便登录到 SSH 服务器。为此，我们将首先在攻击者的系统上生成授权密钥，使用以下命令：
- en: '![](img/613941c5-d68d-4da7-8e6d-8845e60685b0.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/613941c5-d68d-4da7-8e6d-8845e60685b0.png)'
- en: We can see that the public/private keys have been generated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到已经生成了公钥/私钥。
- en: 'After generating the authorization keys, we will send the public key to the
    remote SSH server over SFTP. First, we have copied the public key file `id_rsa.pub`
    to the Desktop and then we run the following command to connect to the SSH server
    using SFTP:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成授权密钥后，我们将通过 SFTP 将公钥发送到远程 SSH 服务器。首先，我们将公钥文件`id_rsa.pub`复制到桌面，然后运行以下命令以使用
    SFTP 连接到 SSH 服务器：
- en: '![](img/99639c9e-9619-4137-86a5-cc6ff7cb0da1.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99639c9e-9619-4137-86a5-cc6ff7cb0da1.png)'
- en: When connected, we transfer the file using the `put` command.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，我们使用`put`命令传输文件。
- en: 'Now, on the victim SSH server system, we create a directory called `.ssh` inside
    `/home/user1/` and then we write the content of the `id_rsa.pub` file to `authorized_keys`
    inside the `/home/user1/.ssh/` directory:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在受害者的 SSH 服务器系统上，我们在`/home/user1/`内创建一个名为`.ssh`的目录，然后将`id_rsa.pub`文件的内容写入`/home/user1/.ssh/`目录下的`authorized_keys`文件中：
- en: '![](img/8a68697b-c19a-41f1-8067-adcbe0479359.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a68697b-c19a-41f1-8067-adcbe0479359.png)'
- en: 'After this, we edit the configuration file of SSH, `etc/ssh/sshd_config`, and
    enable the `PublicKeyAuthentication` variable. We also check that `AuthorizedKeysFile`
    is specified correctly:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们编辑 SSH 的配置文件`etc/ssh/sshd_config`，启用`PublicKeyAuthentication`变量。我们还要检查`AuthorizedKeysFile`是否正确指定：
- en: '![](img/c8758e43-2a47-4527-836f-661e04872047.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8758e43-2a47-4527-836f-661e04872047.png)'
- en: 'Once the preceding steps are successfully completed, we can try to log in to
    the SSH server from the attacker system to see if we are prompted for a password
    or not:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦前面的步骤成功完成，我们可以尝试从攻击者系统登录到 SSH 服务器，看看是否会要求输入密码：
- en: '![](img/5fa3f36c-3c7e-49db-8971-a7e8b93a16c0.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5fa3f36c-3c7e-49db-8971-a7e8b93a16c0.png)'
- en: 'Now, we will create a basic script which will display the message `restricted`
    if the user tries to pass the `date` command as an argument. However, if anything
    other than `date` is passed, it will get executed. We will name this script `sample.sh`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个基本的脚本，如果用户尝试传递`date`命令作为参数，它会显示消息`restricted`。然而，如果传递的是其他内容，它将被执行。我们将这个脚本命名为`sample.sh`：
- en: '![](img/b52db8bf-24e6-49cb-a256-eebe1e144f57.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b52db8bf-24e6-49cb-a256-eebe1e144f57.png)'
- en: 'Once the script is created, we can run the given command to give executable
    permissions to it:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦脚本创建完毕，我们可以运行给定的命令来赋予它可执行权限：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After this, we use the `command` option in the `authorized_keys` file to run
    our `sample.sh` script by adding the path of the script:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们使用`authorized_keys`文件中的`command`选项，通过添加脚本的路径来运行我们的`sample.sh`脚本：
- en: '![](img/621a0c58-a97f-4413-880c-d1a20bf7c0e9.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/621a0c58-a97f-4413-880c-d1a20bf7c0e9.png)'
- en: Marking the precedings changes in the `authorized_keys` file, to restrict a
    user from executing a predefined set of commands, will make the public key authentication
    vulnerable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`authorized_keys`文件中标记之前的更改，以限制用户执行一组预定义的命令，这将使得公钥认证变得脆弱。
- en: 'Now, from the attacker''s system, try connecting to the victim''s system over
    SSH, while passing `date` as an argument:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从攻击者的系统尝试通过 SSH 连接到受害者的系统，并传递`date`作为参数：
- en: '![](img/7b14e2ee-368a-4759-bd06-20ecf821ad39.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b14e2ee-368a-4759-bd06-20ecf821ad39.png)'
- en: We can see the message `restricted` is displayed due to the script that we have
    added to the `authorized_keys` file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到由于我们添加到`authorized_keys`文件中的脚本，显示了`restricted`信息。
- en: 'Next, we try to pass our Shellshock exploit as an argument, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们尝试将我们的Shellshock漏洞利用作为参数传递，如下所示：
- en: '![](img/2842e182-0fc1-41e5-a34a-61661b83e3d2.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2842e182-0fc1-41e5-a34a-61661b83e3d2.png)'
- en: We can see that even though we have restricted the `date` command in this script,
    it gets executed this time and we get the output of the `date` command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，尽管我们在这个脚本中限制了`date`命令，但这次它被执行了，并且我们得到了`date`命令的输出。
- en: Now, let's see how we can use Shellshock vulnerability to compromise an Apache
    server that is running any script that can trigger the bash shell with environment
    variables.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何利用Shellshock漏洞来攻陷运行任何脚本的Apache服务器，这些脚本可以触发带有环境变量的bash shell。
- en: 'If Apache is not already installed on the victim''s system, we must install
    it by running the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果受害者系统上尚未安装Apache，我们必须通过运行以下命令来安装它：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once installed, we launch the Apache server using the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们使用以下命令启动Apache服务器：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we move to the `/usr/lib/cgi-bin/` path and create a script called `example.sh`
    with the following code in it, to display some HTML output:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转到`/usr/lib/cgi-bin/`路径，并创建一个名为`example.sh`的脚本，其中包含以下代码，以显示一些HTML输出：
- en: '![](img/bbf585ee-625e-4651-b3c8-4b95bb34ffbc.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbf585ee-625e-4651-b3c8-4b95bb34ffbc.png)'
- en: 'We then make it executable by running the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过运行以下命令使其可执行：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now from the attacker's system, we try to access `example.sh` file remotely
    using command line tool called `curl -`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从攻击者的系统中，我们尝试使用名为`curl -`的命令行工具远程访问`example.sh`文件。
- en: 'We get the output of the script as expected: `Example Page`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按预期获得脚本的输出：`Example Page`。
- en: '![](img/8d58573d-be6f-4aa7-87f2-7295c2d34e32.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d58573d-be6f-4aa7-87f2-7295c2d34e32.png)'
- en: 'Now, let''s send a malicious request to the server, using curl, to print the
    content of the `/etc/passwd` file of the victim''s system:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用curl向服务器发送一个恶意请求，以打印受害者系统中`/etc/passwd`文件的内容：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/286f6f8f-0d86-412b-8f02-2b5c9b1b92f7.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/286f6f8f-0d86-412b-8f02-2b5c9b1b92f7.png)'
- en: 'Here is the output, but truncated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果，但被截断：
- en: '![](img/f03f7090-e5cf-4b3b-9342-e28e6ab23255.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f03f7090-e5cf-4b3b-9342-e28e6ab23255.png)'
- en: We can see the output on the attacker's system, showing us how the victim's
    system can be remotely accessed using Shellshock vulnerability. In the preceding
    command, `() { :;} ;` signifies a variable that looks like a function. In this
    code, the function is a single `:`, which is defined as doing nothing and is only
    a simple command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到攻击者系统上的输出，展示了如何利用Shellshock漏洞远程访问受害者的系统。在前面的命令中，`() { :;} ;`表示一个看起来像函数的变量。在这段代码中，函数是单一的`:`，它被定义为什么都不做，仅仅是一个简单的命令。
- en: 'We will try another command to see the content of the current directory of
    the victim''s system, as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将尝试另一个命令，查看受害者系统当前目录的内容，如下所示：
- en: '![](img/503b15b4-3af1-4bdc-9bf5-6930547ef025.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/503b15b4-3af1-4bdc-9bf5-6930547ef025.png)'
- en: We can see the content of the `root` directory of the victim's system in the
    preceding output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的输出中看到受害者系统中`root`目录的内容。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: On our SSH server system, we create a new user account and assign a bash shell
    to it as its default shell. We also create a directory for this new user account
    in `/home` and assign its ownership to this account.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的SSH服务器系统上，我们创建一个新的用户账户，并将bash shell设置为其默认shell。我们还在`/home`目录下为该新用户账户创建一个目录，并将其所有权分配给该账户。
- en: Next, we configure our SSH server system to authenticate another system connecting
    to it using authorization keys.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置SSH服务器系统以使用授权密钥验证另一个系统的连接。
- en: We then create a bash script to restrict particular commands such as `date`
    and add this script path to `authorized_keys` using the command option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个bash脚本来限制特定命令，如`date`，并使用命令选项将该脚本路径添加到`authorized_keys`中。
- en: After this, when we try to connect to the SSH server from the other system,
    whose authorization keys were configured earlier, if we pass the `date` command
    as an argument when connecting, we can see that the command gets restricted.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们尝试从另一个系统连接到SSH服务器时，如果我们在连接时传递`date`命令作为参数，我们会看到该命令被限制。
- en: However, when the same `date` command is passed with the Shellshock exploit,
    we can see the output of it, thereby showing us how Shellshock can be used to
    exploit the SSH server.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当相同的`date`命令与Shellshock漏洞一起传递时，我们可以看到它的输出，从而展示了如何使用Shellshock来攻击SSH服务器。
- en: Similarly, we exploit the Apache server by creating a sample script and placing
    it in the `/usr/lib/cgi-bin` directory of the Apache system.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们通过创建一个示例脚本并将其放置在 Apache 系统的 `/usr/lib/cgi-bin` 目录中来利用 Apache 服务器。
- en: Then, we try to access this script from the other system using the curl tool.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试从另一个系统使用 curl 工具访问这个脚本。
- en: We can see that if we pass `shellshock exploit` when accessing the script through
    curl, we are able to run our commands on the Apache server remotely.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当通过 curl 访问脚本时，如果传递 `shellshock exploit`，我们就能在远程 Apache 服务器上运行我们的命令。
- en: Linux patch management system
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 补丁管理系统
- en: In present computing scenarios, vulnerability and patch management is a never
    ending cycle. When an attack happens on a computer due to a known vulnerability
    being exploited, we can see that the patch for such a vulnerability already exists,
    but has not been implemented properly on the system, which causes the attack to
    happen.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的计算环境中，漏洞和补丁管理是一个永无止境的循环。当计算机因为已知漏洞被利用而遭受攻击时，我们可以看到该漏洞的补丁已经存在，但在系统中并未正确实施，从而导致了攻击的发生。
- en: As a system administrator, we have to know which patch needs to be installed
    and which one should be ignored.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，我们必须知道哪些补丁需要安装，哪些可以忽略。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Since patch management can be done using the built-in tools of Linux, no specific
    settings need to be configured before performing these steps.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于补丁管理可以使用 Linux 的内置工具进行，因此在执行这些步骤之前无需配置特定的设置。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The easiest and most efficient way to keep our system updated is to the use
    the Update Manager, which is built into the Linux system. In this recipe, we will
    explore how the Update Manager works on the Ubuntu system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 保持系统更新的最简单和最高效的方法是使用内置于 Linux 系统中的 Update Manager。在本教程中，我们将探讨 Update Manager
    如何在 Ubuntu 系统中工作：
- en: 'To open the graphical version of Update Manager in Ubuntu, click the **Superkey**,
    which is on the top in the toolbar on the left-hand side, and then type `update`.
    In the following screenshot, we can see the Update Manager:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 Ubuntu 中打开 Update Manager 的图形版本，点击左侧工具栏顶部的**超级键**，然后输入`update`。在下面的截图中，我们可以看到
    Update Manager：
- en: '![](img/aad20015-ff77-4c65-8783-f87d9ca7c3b2.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aad20015-ff77-4c65-8783-f87d9ca7c3b2.png)'
- en: 'When we open Update Manager, we will see the following pop-up box, showing
    different security updates available for installation:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们打开 Update Manager 时，我们会看到以下弹出框，显示了可供安装的不同安全更新：
- en: '![](img/e411f634-72f5-4265-ae94-34d58ee27db4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e411f634-72f5-4265-ae94-34d58ee27db4.png)'
- en: Select the updates to install and click on Install Updates to proceed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要安装的更新并点击“安装更新”以继续。
- en: On the same window, we have the Settings button on the bottom-left. When we
    click that, we get a new window called Software Sources, which has more options
    for configuring the Update Manager.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一窗口的左下角，我们有一个设置按钮。点击它后，我们会看到一个名为“软件源”的新窗口，里面有更多配置 Update Manager 的选项。
- en: 'The first tab reads Ubuntu Software, and it displays a list of repositories
    for downloading the updates. We choose the options from the list as per our requirements:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个标签为“Ubuntu 软件”，它显示了一个用于下载更新的仓库列表。我们根据需要从列表中选择选项：
- en: '![](img/1d0769f9-7d05-4ea1-a8d1-0a8366e08e1f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d0769f9-7d05-4ea1-a8d1-0a8366e08e1f.png)'
- en: 'If we click on the option Download from, we get the option to change the repository
    server to be used for downloading. This option is useful if we have any problems
    with connecting to the currently selected server or if the server is slow:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们点击“下载源”选项，就可以更改用于下载的仓库服务器。如果我们在连接当前选择的服务器时遇到问题，或服务器速度较慢，这个选项非常有用：
- en: '![](img/59c824e6-78c1-4dbe-a14f-82d143e9a952.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59c824e6-78c1-4dbe-a14f-82d143e9a952.png)'
- en: 'From the dropdown, when we select the Other option, we get a list to select
    the server, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下拉菜单中，当我们选择“其他”选项时，我们可以选择服务器，如下所示：
- en: '![](img/50c39792-90da-4fdc-8ccd-5e7eaa3d15c1.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50c39792-90da-4fdc-8ccd-5e7eaa3d15c1.png)'
- en: 'The next tab, Other Software, is used to add partner repositories of Canonical:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个标签页，“其他软件”，用于添加 Canonical 的合作伙伴仓库：
- en: '![](img/a5b7f2c9-73f5-4394-a887-5dd8e23d08d9.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5b7f2c9-73f5-4394-a887-5dd8e23d08d9.png)'
- en: 'We can choose any option from the list shown in the preceding screenshot and
    click on Edit to make changes to the repository details:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从前面截图中显示的列表中选择任何选项，然后点击“编辑”以更改仓库详细信息：
- en: '![](img/69cc8958-3cde-4ec4-95bd-11c42b96260f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/69cc8958-3cde-4ec4-95bd-11c42b96260f.png)'
- en: 'The Updates tab is used to define how and when the Ubuntu system will receive
    updates:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新标签用于定义 Ubuntu 系统如何以及何时接收更新：
- en: '![](img/27191cc7-4d61-4f80-ba64-ec2d8482587f.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27191cc7-4d61-4f80-ba64-ec2d8482587f.png)'
- en: 'The next tab, Authentication, contains details about the authentication keys
    of the software providers, as obtained from the maintainer of the software repositories:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个标签页，认证，包含来自软件仓库维护者的、有关软件提供商认证密钥的详细信息：
- en: '![](img/ced82557-0fa3-42a7-8b2d-bfe199b157f7.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ced82557-0fa3-42a7-8b2d-bfe199b157f7.png)'
- en: 'The last tab is called Statistics, and is available for users who would like
    to provide data to the Ubuntu developer project anonymously. This information
    helps the developer to increase the performance and experience of the software:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个标签叫做统计信息，供那些希望匿名向 Ubuntu 开发者项目提供数据的用户使用。这些信息帮助开发者提高软件的性能和体验：
- en: '![](img/ffce7bad-4833-415c-b049-4f754809c656.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffce7bad-4833-415c-b049-4f754809c656.png)'
- en: 'After making any changes under any of the tabs, when we click on close, it
    gives us a prompt to confirm if the new updates should be shown in the list or
    not. Click Reload or Close:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何标签页下进行更改后，当我们点击关闭时，会弹出一个提示，确认是否要在列表中显示新的更新。点击重新加载或关闭：
- en: '![](img/5f8c1455-5b53-4ad5-b8c8-42c1fef79ae3.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f8c1455-5b53-4ad5-b8c8-42c1fef79ae3.png)'
- en: 'If we want to check the list of locations from which the Update Manager retrieves
    all the packages, we can check the content of the `/etc/apt/sources.list` file.
    We get the following result:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想检查更新管理器从哪些位置获取所有包，可以查看 `/etc/apt/sources.list` 文件的内容。我们得到以下结果：
- en: '![](img/102d5896-0d73-4ba3-b67f-7b63b351bc12.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/102d5896-0d73-4ba3-b67f-7b63b351bc12.png)'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To update our Linux system, we use the built-in Update Manager as per the Linux
    distribution.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们的 Linux 系统，我们根据 Linux 发行版使用内置的更新管理器。
- en: In the update manager, either we install all the updates that are available,
    or we configure it as per our requirements using the Settings window.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新管理器中，我们可以选择安装所有可用的更新，或者根据我们的需求通过设置窗口进行配置。
- en: In the Settings window, we have the option to display the list of repositories
    from where the updates can be downloaded.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置窗口中，我们可以选择显示可以下载更新的仓库列表。
- en: The second tab in the Settings window lets us add third-party partner repositories
    of Canonical.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 设置窗口中的第二个标签允许我们添加 Canonical 的第三方合作伙伴仓库。
- en: Using the next tab, we can specify when and what kind of updates should be downloaded.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一个标签，我们可以指定何时以及下载什么类型的更新。
- en: We also check the authentication keys of the software providers using the Settings
    window.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过设置窗口检查软件提供商的认证密钥。
- en: The last tab, called Statistics, helps us send data to Ubuntu project developers
    for increasing the performance of the software.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个标签页，名为统计信息，帮助我们将数据发送给 Ubuntu 项目开发者，以提高软件的性能。
- en: Applying patches in Linux
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 中应用补丁
- en: Whenever a security vulnerability is found in any software, a security patch
    is released for the software to fix the bug. Normally, we use the Update Manager
    that's built into Linux to apply the security updates. However, for software that
    we install by compiling the source code, Update Manager may not be helpful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在任何软件中发现安全漏洞时，都会发布一个安全补丁来修复该漏洞。通常，我们使用 Linux 内置的更新管理器来应用安全更新。然而，对于通过编译源代码安装的软件，更新管理器可能无法提供帮助。
- en: For such situations, we can apply the patch file to the original software's
    source code and then recompile the software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们可以将补丁文件应用于原始软件的源代码，然后重新编译软件。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will use the built-in commands of Linux to create and apply a patch,
    nothing needs to be done before starting the following steps. We will be creating
    a sample program in C for understanding the process of creating a patch file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 Linux 的内置命令来创建和应用补丁，因此在开始以下步骤之前不需要做任何准备工作。我们将创建一个 C 语言示例程序来理解创建补丁文件的过程。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, we will see how to create a patch for a program, using the
    `diff` command, and then apply the patch using the `patch` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用 `diff` 命令为程序创建补丁，然后使用 `patch` 命令应用补丁：
- en: 'Our first step will be to create a simple C program called `example.c` to print
    `This is an example`, as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步将是创建一个简单的 C 程序，名为 `example.c`，用于打印 `This is an example`，如下所示：
- en: '![](img/cbdb0c9c-f48b-4055-b39e-68209f3e6760.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbdb0c9c-f48b-4055-b39e-68209f3e6760.png)'
- en: Now, we will create a copy of `example.c` and name it `example_new.c`
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建 `example.c` 的副本，并将其命名为 `example_new.c`
- en: 'Next, we will edit the new file `example_new.c` and add a few extra lines of
    code in it, as follows:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑新的文件`example_new.c`并在其中添加几行额外的代码，具体如下：
- en: '![](img/77494098-5bbb-417f-bc9b-31214330bd7d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77494098-5bbb-417f-bc9b-31214330bd7d.png)'
- en: Now, `example_new.c` can be considered as the updated version of `example.c`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`example_new.c`可以视为`example.c`的更新版本。
- en: 'We will now create a patch file and name it `example.patch` by using the `diff`
    command, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将使用`diff`命令创建一个补丁文件，并命名为`example.patch`，具体如下：
- en: '![](img/88c29b27-0f0a-407b-86e2-b6fba615bc3a.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88c29b27-0f0a-407b-86e2-b6fba615bc3a.png)'
- en: 'If we check the content of the patch file, we get the following output:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们查看补丁文件的内容，将得到如下输出：
- en: '![](img/23493436-1fb7-4a5b-9a80-6cf9e2f17f53.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23493436-1fb7-4a5b-9a80-6cf9e2f17f53.png)'
- en: 'Now, before applying the patch, we can take a backup of the original file by
    using the `-b` option, as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在应用补丁之前，我们可以通过使用`-b`选项备份原始文件，具体如下：
- en: '![](img/2f3ffbc6-636a-4df2-b7f0-e3ec747b3286.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f3ffbc6-636a-4df2-b7f0-e3ec747b3286.png)'
- en: We can see that a new file called `example.c.orig` has been created, which is
    the backup file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一个名为`example.c.orig`的新文件已经被创建，这是备份文件。
- en: 'Before doing the actual patching, we can dry run the patch file to check whether
    we are getting any errors or not. To do this, we run the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际应用补丁之前，我们可以先进行试运行，检查是否会出现任何错误。为此，我们运行以下命令：
- en: '![](img/5a60562f-ab8a-4457-adaa-b044f59a6a86.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a60562f-ab8a-4457-adaa-b044f59a6a86.png)'
- en: If we get no error message, it means that the patch file can be now run on the
    original file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误消息，意味着补丁文件现在可以应用到原始文件上。
- en: 'Now, we run the following command to apply the patch to the original file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行以下命令将补丁应用到原始文件：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After applying the patch, if we now check the content of the `example.c` program,
    we will see that it has been updated with the extra lines of code, as written
    in `example_new.c`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用补丁后，如果我们检查`example.c`程序的内容，将看到它已更新，包含了在`example_new.c`中写入的额外代码行：
- en: '![](img/0bc098fc-dbac-45d2-982c-c3984f5705a4.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bc098fc-dbac-45d2-982c-c3984f5705a4.png)'
- en: 'Once the patch has been applied on the original file, if we wish to reverse
    the patch, we can use the `-R` option, as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦补丁应用到原始文件上，如果我们希望撤销该补丁，可以使用`-R`选项，具体如下：
- en: '![](img/e9695a65-d798-4038-99a3-b53213cca9e7.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9695a65-d798-4038-99a3-b53213cca9e7.png)'
- en: We can see the difference in the size of the file after patching and then after
    reversing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在应用补丁后，再撤销补丁后的文件大小变化。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first create a sample C program. Then, we create a copy of it and add few
    more lines of code to make it an updated version. After this, we create a patch
    file using the `diff` command. Before applying the patch, we check it for any
    errors by doing a dry run.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个示例 C 程序。然后，我们创建它的副本并添加更多的代码行，使其成为一个更新版本。之后，我们使用`diff`命令创建补丁文件。在应用补丁之前，我们通过试运行检查它是否存在任何错误。
- en: If we get no errors, we apply the patch using the `patch` command. Now, the
    original file has the same content as the updated version file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，我们使用`patch`命令应用补丁。现在，原始文件的内容与更新后的版本文件相同。
- en: We can also reverse the patch using the `-R` option.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-R`选项撤销补丁。
- en: Other well-known Linux vulnerabilities
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他著名的 Linux 漏洞
- en: With time, Linux has gained a lot of popularity due to its open source nature.
    However, it has also resulted into increased security concerns. Linux systems
    tend to be as vulnerable as other operating systems, such as Windows. These vulnerabilities
    may be due to faults in the OS, or due to oversight by the Linux administrators.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Linux 因其开源特性而获得了广泛的关注。然而，这也带来了日益严重的安全问题。Linux 系统的漏洞问题与其他操作系统（如 Windows）一样普遍，这些漏洞可能源于操作系统本身的缺陷，或由于
    Linux 管理员的疏忽。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this section, we will see discuss about few of the most common Linux vulnerabilities,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些最常见的 Linux 漏洞，具体如下：
- en: '**Linux Kernel netfilter: xt_TCPMSS**: Even though it''s an old vulnerability,
    affecting Linux kernels before 4.11, and 4.9.x before 4.9.36, it still exists
    in many systems of organizations that have failed to attend to this vulnerability
    and are still using older versions of the Linux kernel. It has CVE ID: CVE-2017-18017
    and a critical vulnerability score of 9.8.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux内核 netfilter: xt_TCPMSS**：尽管这是一个较老的漏洞，影响的是 4.11 之前的 Linux 内核版本，以及 4.9.x
    版本的 4.9.36 之前的版本，但它仍然存在于许多没有解决该漏洞并且仍在使用较老版本 Linux 内核的组织系统中。此漏洞的 CVE ID 为：CVE-2017-18017，且具有
    9.8 的严重漏洞评分。'
- en: If exploited successfully, the aforementioned vulnerability can help hackers
    send through a flood of communications and cause a **denial-of-service** (**DoS**)
    attack.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该漏洞成功被利用，黑客可以借此发起**拒绝服务**（**DoS**）攻击，向目标发送大量通信。
- en: '**Dirty Cow Bug**: CVE-2016-5195 is the official reference to this bug. It
    was discovered that a race condition existed in the memory manager of the Linux
    kernel when handling copy-on-write breakage of private, read-only memory mappings.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Dirty Cow 漏洞**：CVE-2016-5195 是该漏洞的官方参考。发现 Linux 内核的内存管理器在处理私有只读内存映射的写时复制（copy-on-write）中存在竞态条件。'
- en: 'The flaw is located in a section of the Linux kernel that''s a part of virtually
    every distribution of the open source OS that has been around for almost a decade:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该漏洞位于 Linux 内核的一个部分，几乎所有开源操作系统的发行版中都有，且这个漏洞已经存在了近十年：
- en: '![](img/8e46120c-c0ed-44d3-a488-81589e25a33c.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e46120c-c0ed-44d3-a488-81589e25a33c.png)'
- en: Exploitation of this bug does not leave any traces of anything abnormal happening
    to the logs. Any local users can write to any file they can read, and has been
    present since at least Linux kernel version 2.6.22.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用此漏洞不会在日志中留下任何异常的痕迹。任何本地用户都可以写入他们能够读取的任何文件，该漏洞至少自 Linux 内核版本 2.6.22 起就存在。
- en: 'If you want more information about the exploit available for this bug, you
    can check: [https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/).'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于此漏洞的可利用信息，可以查看：[https://www.exploit-db.com/exploits/40839/](https://www.exploit-db.com/exploits/40839/)。
- en: 'The Metasploit framework, the most popular framework for penetration testing,
    also includes an exploit module for the Dirty Cow bug. More information regarding
    the same can be found here: [https://github.com/rapid7/metasploit-framework/pull/7476](https://github.com/rapid7/metasploit-framework/pull/7476).'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Metasploit 框架，作为最流行的渗透测试框架，也包括了一个针对 Dirty Cow 漏洞的利用模块。更多相关信息可以在这里找到：[https://github.com/rapid7/metasploit-framework/pull/7476](https://github.com/rapid7/metasploit-framework/pull/7476)。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Time and again, many vulnerabilities have been detected in Linux, whether it's
    related to the kernel or the OS-level code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统中不断发现许多漏洞，无论是与内核相关，还是与操作系统级别的代码有关。
- en: A few vulnerabilities, such as Dirty Cow, have existed for a long time, allowing
    attackers to exploit them easily.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一些漏洞，如 Dirty Cow，已经存在很长时间，攻击者可以轻松利用它们。
- en: Most of these vulnerabilities have the exploits available, hence it's necessary
    to keep our system patched and updated in order to remain secure.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些漏洞中的大多数都有现成的利用方法，因此，保持系统的修补和更新是必要的，以确保安全。
