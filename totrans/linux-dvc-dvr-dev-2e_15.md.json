["```\n#include <linux/regmap.h>\n```", "```\nstruct regmap_config {\n    const char *name;\n    int reg_bits;\n    int reg_stride;\n    int pad_bits;\n    int val_bits;\n    bool (*writeable_reg)(struct device *dev, \n                          unsigned int reg);\n    bool (*readable_reg)(struct device *dev, \n                         unsigned int reg);\n    bool (*volatile_reg)(struct device *dev, \n                         unsigned int reg);\n    bool (*precious_reg)(struct device *dev, \n                         unsigned int reg);\n    bool disable_locking;\n    regmap_lock lock;\n    regmap_unlock unlock;\n    void *lock_arg;\n    int (*reg_read)(void *context, unsigned int reg,\n                    unsigned int *val);\n    int (*reg_write)(void *context, unsigned int reg,\n                    unsigned int val);\n    bool fast_io;\n    unsigned int max_register;\n    const struct regmap_access_table *wr_table;\n    const struct regmap_access_table *rd_table;\n    const struct regmap_access_table *volatile_table;\n    const struct regmap_access_table *precious_table;\n[...]\n    const struct reg_default *reg_defaults;\n    unsigned int num_reg_defaults;\n    enum regcache_type cache_type;\n    const void *reg_defaults_raw;\n    unsigned int num_reg_defaults_raw;\n    unsigned long read_flag_mask;\n    unsigned long write_flag_mask;\n    bool use_single_rw;\n    bool can_multi_write;\n    enum regmap_endian reg_format_endian;\n    enum regmap_endian val_format_endian;\n    const struct regmap_range_cfg *ranges;\n    unsigned int num_ranges;\n}\n```", "```\n    static bool foo_writeable_register(struct device *dev,\n                                        unsigned int reg)\n    {\n        switch (reg) {\n        case 0x30 ... 0x38:\n        case 0x40 ... 0x45:\n        case 0x50 ... 0x57:\n        case 0x60 ... 0x6e:\n        case 0x70 ... 0x75:\n        case 0x80 ... 0x85:\n        case 0x90 ... 0x95:\n        case 0xa0 ... 0xa5:\n        case 0xb0 ... 0xb2:\n            return true;\n        default:\n            return false;\n        }\n    }\n    ```", "```\n    static bool foo_volatile_register(struct device *dev,\n                                        unsigned int reg)\n    {\n        switch (reg) {\n        case 0x24 ... 0x29:\n        case 0xb6 ... 0xb8:\n            return true;\n        default:\n            return false;\n        }\n    }\n    ```", "```\nstatic const struct regmap_config regmap_config = {\n    .reg_bits       = 8,\n    .val_bits       = 8,\n    .max_register   = LM3533_REG_MAX,\n    .readable_reg   = lm3533_readable_register,\n    .volatile_reg   = lm3533_volatile_register,\n    .precious_reg   = lm3533_precious_register,\n};\n```", "```\nstruct regmap *devm_regmap_init_spi(struct spi_device *spi,\n                            const struct regmap_config);\nstruct regmap *devm_regmap_init_i2c(struct i2c_client *i2c,\n                            const struct regmap_config);\nstruct regmap * devm_regmap_init_mmio(\n                        struct device *dev,\n                        void __iomem *regs,\n                        const struct regmap_config *config)\n```", "```\nvoid regmap_exit(struct regmap *map)\n```", "```\nint regmap_read(struct regmap *map, unsigned int reg,\n                 unsigned int *val);\nint regmap_write(struct regmap *map, unsigned int reg,\n                 unsigned int val);\nint regmap_update_bits(struct regmap *map,\n                 unsigned int reg, unsigned int mask,\n                 unsigned int val);\n```", "```\nstatic int _regmap_update_bits(struct regmap *map,\n             unsigned int reg, unsigned int mask,\n             unsigned int val, bool *change,\n             bool force_write)\n{\n    int ret;\n    unsigned int tmp, orig;\n    if (change)\n        *change = false;\n    if (regmap_volatile(map, reg) &&\n                   map->reg_update_bits) {\n        ret = map->reg_update_bits(map->bus_context,\n                                   reg, mask, val);\n        if (ret == 0 && change)\n            *change = true;\n    } else {\n        ret = _regmap_read(map, reg, &orig);\n        if (ret != 0)\n            return ret;\n        tmp = orig & ~mask;\n        tmp |= val & mask;\n        if (force_write || (tmp != orig)) {\n            ret = _regmap_write(map, reg, tmp);\n            if (ret == 0 && change)\n                *change = true;\n        }\n    }\n    return ret;\n}\n```", "```\nint regmap_multi_reg_write(struct regmap *map,\n                    const struct reg_sequence *regs,\n                    int num_regs)\n```", "```\nstruct reg_sequence {\n    unsigned int reg;\n    unsigned int def;\n    unsigned int delay_us;\n};\n```", "```\nstatic const struct reg_sequence foo_default_regs[] = {\n    { FOO_REG1,       0xB8 },\n    { BAR_REG1,       0x00 },\n    { FOO_BAR_REG1,   0x10 },\n    { REG_INIT,       0x00 },\n    { REG_POWER,      0x00 },\n    { REG_BLABLA,     0x00 },\n};\nstatic int probe ( ...)\n{\n    [...]\n    ret = regmap_multi_reg_write(my_regmap,\n                          foo_default_regs,\n                          ARRAY_SIZE(foo_default_regs));\n    [...]\n}\n```", "```\nint regmap_bulk_read(struct regmap *map,\n                     unsigned int reg, void *val,\n                     size_tval_count);\nint regmap_bulk_write(struct regmap *map,\n                      unsigned int reg,\n                      const void *val, size_t val_count);\n```", "```\n/* An enum of all the supported cache types */\nenum regcache_type {\n   REGCACHE_NONE,\n   REGCACHE_RBTREE,\n   REGCACHE_COMPRESSED,\n   REGCACHE_FLAT,\n};\n```", "```\nstruct reg_default {\n    unsigned int reg;\n    unsigned int def;\n};\n```", "```\nstatic const struct reg_default ltc3589_reg_defaults[] = {\n{ LTC3589_SCR1,   0x00 },\n{ LTC3589_OVEN,   0x00 },\n{ LTC3589_SCR2,   0x00 },\n{ LTC3589_VCCR,   0x00 },\n{ LTC3589_B1DTV1, 0x19 },\n{ LTC3589_B1DTV2, 0x19 },\n{ LTC3589_VRRCR,  0xff },\n{ LTC3589_B2DTV1, 0x19 },\n{ LTC3589_B2DTV2, 0x19 },\n{ LTC3589_B3DTV1, 0x19 },\n{ LTC3589_B3DTV2, 0x19 },\n{ LTC3589_L2DTV1, 0x19 },\n{ LTC3589_L2DTV2, 0x19 },\n};\nstatic const struct regmap_config ltc3589_regmap_config = {\n        .reg_bits = 8,\n        .val_bits = 8,\n        .writeable_reg = ltc3589_writeable_reg,\n        .readable_reg = ltc3589_readable_reg,\n        .volatile_reg = ltc3589_volatile_reg,\n        .max_register = LTC3589_L2DTV2,\n        .reg_defaults = ltc3589_reg_defaults,\n        .num_reg_defaults = ARRAY_SIZE(ltc3589_reg_defaults),\n        .use_single_rw = true,\n        .cache_type = REGCACHE_RBTREE,\n};\n```", "```\n#include <linux/regmap.h>\n```", "```\nstruct private_struct\n{\n    /* Feel free to add whatever you want here */\n    struct regmap *map;\n    int foo;\n};\n```", "```\nstatic const struct regmap_range wr_rd_range[] =\n{\n    {\n            .range_min = 0x20,\n            .range_max = 0x4F,\n    },{\n            .range_min = 0x60,\n            .range_max = 0x7F\n    },\n}; \nstruct regmap_access_table drv_wr_table =\n{\n    .yes_ranges =   wr_rd_range,\n    .n_yes_ranges = ARRAY_SIZE(wr_rd_range),\n};\nstruct regmap_access_table drv_rd_table =\n{\n    .yes_ranges =   wr_rd_range,\n    .n_yes_ranges = ARRAY_SIZE(wr_rd_range),\n};\n```", "```\nstatic bool writeable_reg(struct device *dev,\n                          unsigned int reg)\n{\n    if (reg>= 0x20 &&reg<= 0x4F)\n        return true;\n    if (reg>= 0x60 &&reg<= 0x7F)\n        return true;\n    return false;\n}\nstatic bool readable_reg(struct device *dev,\n                         unsigned int reg)\n{\n    if (reg>= 0x20 &&reg<= 0x4F)\n        return true;\n    if (reg>= 0x60 &&reg<= 0x7F)\n        return true;\n    return false;\n}\n```", "```\nstatic int my_spi_drv_probe(struct spi_device *dev)\n{\n    struct regmap_config config;\n    struct private_struct *priv;\n    unsigned char data;\n    /* setup the regmap configuration */\n    memset(&config, 0, sizeof(config));\n    config.reg_bits = 8;\n    config.val_bits = 8;\n    config.write_flag_mask = 0x80;\n    config.max_register = 0x80;\n    config.fast_io = true;\n    config.writeable_reg = drv_writeable_reg;\n    config.readable_reg = drv_readable_reg;\n    /* \n     * If writeable_reg and readable_reg are set,\n     * there is no need to provide wr_table nor rd_table.\n     * Uncomment below code only if you do not want to use\n     * writeable_reg nor readable_reg.\n     */\n    //config.wr_table = drv_wr_table;\n    //config.rd_table = drv_rd_table;\n    /* allocate the private data structures */\n    /* priv = kzalloc */\n    /* Init the regmap spi configuration */\n    priv->map = devm_regmap_init_spi(dev, &config);\n    /* Use devm_regmap_init_i2c in case of i2c bus */\n    /* \n     * Let us write into some register\n     * Keep in mind that, below operation will remain same\n     * whether you use SPI, I2C, or memory mapped Regmap.\n     * It is and advantage when you use regmap.\n     */ \n    regmap_read(priv->map, 0x30, &data);\n    [...] /* Process data */\n    data = 0x24;\n    regmap_write(priv->map, 0x23, data); /* write new value */\n    /* set bit 2 (starting from 0) and bit 6\n     * of register 0x44 */\n    regmap_update_bits(priv->map, 0x44,\n                       0b00100010, 0xFF);\n    [...] /* Lot of stuff */     \n    return 0;\n}\n```", "```\nmount -t debugfs none /sys/kernel/debug\n```", "```\nroot@jetson-nano-devkit:~# ls -l /sys/kernel/debug/regmap/\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 4-003c-power-slave\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 4-0068\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 700e3000.mipical\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 702d3000.amx\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 702d3100.amx\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 hdaudioC0D3-hdaudio\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 tegra210-admaif\ndrwxr-xr-x   2 root  root   0 Jan  1  1970 tegra210-adx.0\n[...]\nroot@jetson-nano-devkit:~#\n```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/access \n    00: y y y n\n    01: y y y n\n    02: y y y n\n    03: y y y n\n    04: y y y n\n    05: y y y n\n    06: y y y n\n    07: y y y n\n    08: y y y n\n    [...]\n    5c: y y y n\n    5d: y y y n\n    5e: y y y n\n    ```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/702d3000.amx/name \n    tegra210-amx\n    ```", "```\nroot@raspberrypi4-64:~# ls -l /sys/kernel/debug/regmap/\ndrwxr-xr-x  2 root root 0 Jan 1 1970 dummy-avs-monitor@fd5d2000\nroot@raspberrypi4-64:~#\n```", "```\nroot@raspberrypi4-64:~# cat /sys/kernel/debug/regmap/dummy-avs-monitor\\@fd5d2000/name \nnodev\nroot@raspberrypi4-64:~#\n```", "```\navs_monitor: avs-monitor@7d5d2000 {\n    compatible = \"brcm,bcm2711-avs-monitor\",\n                 \"syscon\", \"simple-mfd\";\n    reg = <0x7d5d2000 0xf00>;\n[...]\n};\n```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/702d3000.amx/cache_bypass \n    N\n    ```", "```\nroot@jetson-nano-devkit:~# echo Y > /sys/kernel/debug/regmap/702d30[579449.571475] tegra210-amx tegra210-amx.0: debugfs cache_bypass=Y forced\n00.amx/cache_bypass \nroot@jetson-nano-devkit:~#\n```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/range \n    0-5e\n    ```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/rbtree \n    0-5e (95)\n    1 nodes, 95 registers, average 95 registers, used 175 bytes\n    ```", "```\n    root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/registers \n    00: d2\n    01: 1f\n    02: 00\n    03: dc\n    04: 0f\n    05: 00\n    06: 00\n    07: 00\n    08: 02\n    [...]\n    5c: 35\n    5d: 81\n    5e: 00\n    #\n    ```"]