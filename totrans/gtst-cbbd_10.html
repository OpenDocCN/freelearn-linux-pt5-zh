<html><head></head><body><div><div><div><div><h1 class="title"><a id="appB"/>Appendix B. Basic Linux Commands Cheatsheet</h1></div></div></div><p>A Linux-based system contains many commands. Each installed application is, in fact, a command. This appendix will give an overview of the most basic commands that should, in theory, be available in every basic Linux installation. Most of these commands will be used throughout this book, some of which are considered as the bare basics. This appendix is by no means an authoritative reference, but it should get you well on your way.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Requesting the manual</h1></div></div></div><p>Linux <a id="id418" class="indexterm"/>features an interesting command called <code class="literal">man</code>. It is special because, if installed, it opens a manual page about any command. Try it by requesting the manual page of <code class="literal">man</code>, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ man man</strong>
</pre></div><p>Running <code class="literal">man</code> with the <code class="literal">man</code> parameter will open the manual page of <code class="literal">man</code>. With the <em>q</em> key, you can exit <code class="literal">man</code>, and with the arrow keys, you can navigate around. The <em>h</em> key opens a help screen where more keys are explained.</p><p>If <code class="literal">man</code> or manual pages are not installed, the Internet can be used instead. There are many sites that have the most common manual pages available. The website <a class="ulink" href="http://www.die.net">http://www.die.net</a> is very popular and can be used to query various manual pages.</p><p>Something to<a id="id419" class="indexterm"/> note is that there are several sections of manual pages available—nine to be exact. The man-manual page will explain each of them briefly. The first section relates to commands and these pages are queried by default.</p><p>Finally, a lot of commands often have a short help screen, which can be activated by appending <code class="literal">-h</code> or <code class="literal">--help</code> to a command.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Listing a directory</h1></div></div></div><p>The <code class="literal">ls</code> command, which <a id="id420" class="indexterm"/>stands for list, is the command used to list the contents of a directory. Without a parameter, it will list the current active directory, and if supplied with a parameter, it will try to list that file or directory, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ ls /home/</strong>
<strong>packt</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Changing through directories</h1></div></div></div><p>To change<a id="id421" class="indexterm"/> to a different directory, the <code class="literal">cd</code> command can be used. Without a parameter, <code class="literal">cd</code> will always change to the current user's home directory; otherwise, the directory that is supplied via the first parameter is used, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ cd /home</strong>
<strong>packt@PacktPublishing:/home$</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Getting the current working directory</h1></div></div></div><p>The <a id="id422" class="indexterm"/>current active directory or current working directory can be printed using the <code class="literal">pwd</code> command. This can be useful when one wants to know where one is located in the current filesystem and can be done using the following command:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ pwd</strong>
<strong>/home/packt</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Getting the current user</h1></div></div></div><p>Finding <a id="id423" class="indexterm"/>out which user is currently logged in can be useful, especially when swapping between several users. The <code class="literal">whoami</code> command will print the current active logged-in user, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ whoami</strong>
<strong>packt</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Running commands as root</h1></div></div></div><p>Very often, when <a id="id424" class="indexterm"/>administering or setting up a system, certain commands need to be executed as root. The <code class="literal">sudo</code> command, when set up properly, can be used to allow certain users to execute certain commands as root. The <em>who</em> and <em>what</em> queries are controlled via the <code class="literal">sudoers</code> file at <code class="literal">/etc/sudoers</code> and should be edited with the <code class="literal">visudo</code> command. The <a id="id425" class="indexterm"/>
<code class="literal">sudo</code> command is used as a prefix to the command to be executed as root, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ sudo whoami</strong>
<strong>[sudo] password for packt:</strong>
<strong>root</strong>
</pre></div><p>It should be noted that while <code class="literal">sudo</code> is very often used to execute commands as root, it can also be used to have any user execute any command as any user.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Changing the current user without logging out</h1></div></div></div><p>To actually <a id="id426" class="indexterm"/>change to a different user as if one would log in with that user, the <code class="literal">su</code> command is used. With <code class="literal">su</code> followed by a different username, it is possible to change the identity of the said user. Unlike <code class="literal">sudo</code>, which requires the current user's password, here, the user to whom access is being requested is required, as shown in the following command:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ su root</strong>
<strong>Password:</strong>
</pre></div><p>Logging out of a shell or from a different user, the following <code class="literal">exit</code> command is used. It takes no parameters. Alternatively, <em>Ctrl</em> + <em>d</em> can also be used to log out on nearly all shells.</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ exit</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Creating files or changing their dates</h1></div></div></div><p>To create a <a id="id427" class="indexterm"/>new empty file, the <code class="literal">touch</code> command can be used. Additionally, to<a id="id428" class="indexterm"/> modify an existing file's access and modification date can be changed to reflect a new date and time, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ touch /tmp/testfile</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Creating directories</h1></div></div></div><p>To create a <a id="id429" class="indexterm"/>new empty directory, the following <code class="literal">mkdir</code> command can be used:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ mkdir /tmp/testdir</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Removing files</h1></div></div></div><p>To remove<a id="id430" class="indexterm"/> a file, the <code class="literal">rm</code> command can be used. The <code class="literal">rm</code> command removes the file that is passed along as a parameter. By default, <code class="literal">rm</code> will refuse to remove a directory; it only operates on files.</p><p>The two options that are very often passed to <code class="literal">rm</code> are <code class="literal">-r</code> and <code class="literal">-f</code>. First, a word of caution on the <code class="literal">-f</code> option, which stands for force; while the <code class="literal">rm</code> command should be used with extreme care, the <code class="literal">-f</code> option requires even more thought and attention. The <code class="literal">-f</code> option forces the removal of anything <code class="literal">rm</code> can delete, regardless of any permission.</p><p>The <code class="literal">-r</code> option also needs to be used with care, as it stands for recursively delete. Ironically, the <code class="literal">-r</code> option takes a directory as a parameter, so it can recursively delete every file and directory under the passed location. Recursively deleting a file does not seem to make sense anyway. The following <code class="literal">rm</code> command shows an example to remove a file:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ rm /tmp/testfile</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Removing a directory</h1></div></div></div><p>Removing a<a id="id431" class="indexterm"/> directory is done via the <code class="literal">rmdir</code> command; it, however, will only operate on an empty directory, as shown in the following command:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ rmdir /tmp/testdir</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Copying files and directories</h1></div></div></div><p>To copy a<a id="id432" class="indexterm"/> file, the <code class="literal">cp</code> command <a id="id433" class="indexterm"/>can be used. Copying a file, you need to supply the source file and the destination file as parameters to <code class="literal">cp</code> in that order. Optionally, a directory can be supplied instead of a file to copy a directory. While <code class="literal">copy</code> takes many options, which <a id="id434" class="indexterm"/>the manual page explains in <a id="id435" class="indexterm"/>detail, the <code class="literal">-r</code> option can be important when dealing with directories, as it tells <code class="literal">copy</code> to recursively copy a directory and everything underneath it. The following command shows the use of the copy command:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ cp /tmp/testfile /tmp/testdir/copy_of_testfile</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Moving files and directories</h1></div></div></div><p>To move<a id="id436" class="indexterm"/> a file, the <code class="literal">mv</code> command can be used. Supply the source file and <a id="id437" class="indexterm"/>destination file as parameters to <code class="literal">mv</code> in that order. Optionally, a directory can be supplied for the source and the destination or just the destination.</p><p>Renaming a file is actually nothing more than moving a file from one name to another. The following command is used to move a file:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ mv /tmp/testfile /tmp/testdir/moved_testfile</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Changing file and directory access permissions</h1></div></div></div><p>To grant or <a id="id438" class="indexterm"/>restrict access to certain files and directories, the <code class="literal">chmod</code> command can be used. This command stands for <em>change mode</em> and requires at least two <a id="id439" class="indexterm"/>parameters: the mode that needs to be applied and the file or directory on which this needs to be applied.</p><p>Managing permissions properly can be quite complex, though the manual page does help quite a bit. The basics are as follows. Under Linux, there are three standard access levels: user, group, and others. A fourth virtual-access level exists to cover the three others, all. Let us take a look at each of these in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>User</strong>: This <a id="id440" class="indexterm"/>access level relates to the user who owns a file or directory; usually, it refers to the user who created the file or directory</li><li class="listitem" style="list-style-type: disc"><strong>Group</strong>: This <a id="id441" class="indexterm"/>access level grants all the users who are also members of this group access to this level</li><li class="listitem" style="list-style-type: disc"><strong>Others</strong>: This <a id="id442" class="indexterm"/>access level gives access to everybody else</li><li class="listitem" style="list-style-type: disc"><strong>All</strong>: This<a id="id443" class="indexterm"/> is the fourth virtual-access level that incorporates the preceding three levels</li></ul></div><p>The four access levels are often abbreviated with their first letters, <code class="literal">ugoa</code>. Next to the access levels, there are the access rights, and here, we will look at the three common ones. Technically, there are four, but more on that in a minute! The two primary access rights are read and write access to a file or directory, which are abbreviated with <code class="literal">r</code> and <code class="literal">w</code>. The third access right is execute, abbreviated with <code class="literal">x</code>, which grants execution permission on a file to a user, group, or <a id="id444" class="indexterm"/>anybody else. So, for example, <code class="literal">chmod</code> itself would require the execute access right to be set for anybody to actually execute that file. The <a id="id445" class="indexterm"/>fourth access right is <code class="literal">x</code> again, but this time it is applied to a directory. Since directories cannot be executed, the access right has a different meaning here and hence has four access rights. For directories, it allows users, groups, or anybody else to actually change into the directory and read the list of files in it.</p><p>Constructing a mode is done as follows. Firstly, the shorthand letter is used to designate the user, group, or others followed by <code class="literal">+</code> or <code class="literal">–</code> to grant or revoke access rights supplied immediately after. Users, groups, and other designators can be combined if separated by a comma. Refer to the following example to see the constructing mode:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ chmod g+r-w,o+r-w-x /tmp/testfile</strong>
</pre></div><p>Very often, access permissions are applied by their numerical value, rather than through their letters. This has its roots mostly in history, where the actual mode bits were used. For more details on the numerical values, you can refer to the manual page.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Changing file and directory ownership</h1></div></div></div><p>To change <a id="id446" class="indexterm"/>the owner of a file or directory, the <code class="literal">chown</code> command <a id="id447" class="indexterm"/>can be used, which stands for change owner. For this, two parameters are required: the new owner and the file or directory that requires new ownership, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ chown packt /tmp/testdir</strong>
</pre></div><p>To change the group membership of a file, a similar command to <code class="literal">chown</code>, called <code class="literal">chgroup</code>, which stands for change group, exists and works identically.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec84"/>Changing passwords</h1></div></div></div><p>To change <a id="id448" class="indexterm"/>passwords, the <code class="literal">passwd</code> command can be used. When executed without a parameter, the current user's password can be changed by supplying both the old and the new password. The root user can change any user's password by supplying that as the first parameter to <code class="literal">passwd</code>, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ passwd</strong>
<strong>Changing password for packt.</strong>
<strong>(current) UNIX password:</strong>
<strong>Enter new UNIX password:</strong>
<strong>Retype new UNIX password:</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec85"/>Displaying the content of a text file</h1></div></div></div><p>There are <a id="id449" class="indexterm"/>many tools to output the content of a file; <code class="literal">less</code>, <code class="literal">more</code>, or <code class="literal">cat</code>, to name just a few. They all work similarly, pass a filename as their parameter, and they will start displaying the content. Both <code class="literal">less</code> and <code class="literal">more</code> allow search or scrolling through the file, with <code class="literal">less</code> being more advanced than <code class="literal">more</code>. The <code class="literal">cat</code> utility, which stands for concatenate, will just output whatever it finds in the file, be it text or not, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ cat /tmp/testfile</strong>
</pre></div><p>One common operation used with <code class="literal">cat</code> is redirecting the output content of a file to somewhere else, be it a new file where its functions mimic the copying of a file or appending to another file.</p><p>There are a few programs that function in a manner that is very similar to <code class="literal">cat</code>, but operate on compressed files, decompressing them on the fly. Such commands are <code class="literal">zcat</code>, for <strong>gzip</strong> cat<a id="id450" class="indexterm"/> or <a id="id451" class="indexterm"/>
<code class="literal">xzcat</code>, for the <strong>xz</strong> compression. A useful purpose lies herein that when redirecting the output, a file could be decompressed and the output can be written elsewhere. <a class="link" href="ch03.html" title="Chapter 3. Installing an Operating System">Chapter 3</a>, <em>Installing an Operating System</em>, makes use of this by taking a compressed binary file and redirecting the output directly onto a flash disk, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ xzcat /tmp/archive.xz &gt; /dev/sdb</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec86"/>Modifying the partitions on a disk</h1></div></div></div><p>The <a id="id452" class="indexterm"/>
<code class="literal">fdisk</code> command, which<a id="id453" class="indexterm"/> stands for fixed disk, is a command that can create and modify partitions on a hard or flash disk. It requires a disk device node to be supplied as a parameter. While it is quite menu-driven, <code class="literal">fdisk</code> has a lot of commands. The most important ones are briefly summarized, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">m</code>: This<a id="id454" class="indexterm"/> command shows a help menu</li><li class="listitem" style="list-style-type: disc"><code class="literal">p</code>: This <a id="id455" class="indexterm"/>command prints the current partition table</li><li class="listitem" style="list-style-type: disc"><code class="literal">o</code>: This <a id="id456" class="indexterm"/>command wipes out the entire partition table and creates a new empty partition table</li><li class="listitem" style="list-style-type: disc"><code class="literal">n</code>: This <a id="id457" class="indexterm"/>command creates a new partition by answering a few questions that <code class="literal">fdisk</code> asks</li><li class="listitem" style="list-style-type: disc"><code class="literal">d</code>: This <a id="id458" class="indexterm"/>command deletes a partition</li><li class="listitem" style="list-style-type: disc"><code class="literal">w</code>: This <a id="id459" class="indexterm"/>command writes the created partition table to the disk and exits</li></ul></div><p>Always take great care when working with partitions.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>The <code class="literal">fdisk</code> command does not actually write the changes to the disk unless explicitly requested. If there are errors, the <em>Ctrl</em> + <em>c</em> key can be used to quit <code class="literal">fdisk</code> without writing changes to the disk.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Formatting partitions</h1></div></div></div><p>To <a id="id460" class="indexterm"/>format a partition, the various <code class="literal">mkfs</code> commands can be used. It depends on whether the supporting utilities are installed. When creating an <code class="literal">ext4</code> partition, <code class="literal">mkfs.ext4</code> is used. Likewise, to create a <code class="literal">fat</code> or <code class="literal">vfat</code> partition, <code class="literal">mkfs.vfat</code> is used. Each filesystem partitioning tool has different options and parameters, so the manual page for these commands should be checked for details. Generally speaking, when using the default settings, supplying the device-specific partition node, such as <code class="literal">/dev/sdb1</code>, for the first partition <code class="literal">(1)</code> on the second hard or flash disk <code class="literal">(b)</code> is passed as a parameter to the <code class="literal">mkfs</code> commands. Creating filesystems is a destructive operation. Use it with care!</p><p>In the following example, an <code class="literal">ext4</code> filesystem is created on a previously partitioned USB flash stick. Note that <code class="literal">sudo</code> was used here to obtain permission to write directly to the flash drive.</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ sudo mkfs.ext4 /dev/sdb1</strong>
</pre></div><p>A special variant of <code class="literal">mkfs</code> is <code class="literal">mkswap</code>, which creates a filesystem specifically geared to swap space.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec88"/>Mounting partitions</h1></div></div></div><p>Attaching <a id="id461" class="indexterm"/>storage to a system is called mounting. While many graphical desktop environments seem to just work, behind the scenes, they still mount and unmount disks and partitions. The <a id="id462" class="indexterm"/>
<code class="literal">mount</code> command, which makes this happen, requires two parameters: the device node and the mount location.</p><p>Either of the two parameters might be omitted if either of them has been defined in the <code class="literal">fstab</code> file at <code class="literal">/etc/fstab</code>. The <code class="literal">fstab</code> file is parsed by <code class="literal">mount</code> to see what needs to be mounted, where, and how. Usage of the <code class="literal">mount</code> command is shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ mount /dev/sdb1 /tmp/testdir</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Unmounting partitions</h1></div></div></div><p>To remove<a id="id463" class="indexterm"/> a partition from a running system, the <code class="literal">umount</code> command is used and stands for <em>unmount</em>. The <em>n</em> seems to be thought about as being redundant so the term has been abbreviated to <code class="literal">umount</code>. It is very important to know that <code class="literal">umount</code> requires no files or directories that are being accessed or in use when detaching a partition from the <a id="id464" class="indexterm"/>system. Either the device node or the mount point can be used to unmount a partition, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ umount /dev/sdb1</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec90"/>Writing data</h1></div></div></div><p>A <a id="id465" class="indexterm"/>somewhat unusual name is used for the program described in this section, <code class="literal">dd</code>. It is unknown what <code class="literal">dd</code> stands for, but its purpose is to copy data. There are many possible arguments to <code class="literal">dd</code>, but the most important ones used in this book will be covered here. The <code class="literal">if</code> parameter<a id="id466" class="indexterm"/> specifies the input file where data is to be read from. The <code class="literal">of</code> parameter<a id="id467" class="indexterm"/> is the output file parameter where the data is to be written. With these two parameters, it is already possible to copy data from the source to the destination. What makes <code class="literal">dd</code> so versatile is the plethora of other parameters. The <code class="literal">seek</code> parameter<a id="id468" class="indexterm"/> allows you to change the start position where to start writing. The <code class="literal">skip</code> parameter allows you to change the start position from where data is read. The <a id="id469" class="indexterm"/>
<code class="literal">bs</code> parameter, which stands for block-size, determines the size of the data blocks involved in the transaction, and in combination with the<a id="id470" class="indexterm"/> <code class="literal">count</code> parameter, determines how much data is to be copied. As <a id="id471" class="indexterm"/>
<code class="literal">dd</code> allows you to very specifically control a copy operation, it is often used to write full images, bootloaders at specific locations, and much more, as shown in the following command. See the manual page for more information.</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ dd if=inputfile of=outputfile seek=8 bs=1024</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec91"/>Changing to a special root directory</h1></div></div></div><p>Normally, the<a id="id472" class="indexterm"/> root directory is the main system directory and everything branches from there. Sometimes, we want to restrict access to only certain parts of the system or temporarily pretend a certain directory is this root. The <code class="literal">chroot</code> command, which stands for change root, ensures that the supplied directory is considered the new root until exited. As a second parameter, <code class="literal">chroot</code> can be told what command to run from within this restricted root. In the following example, the root directory is changed to <code class="literal">/tmp/testdir</code> and the requested command to be executed, <code class="literal">bash</code>, will reside at <code class="literal">/tmp/testdir/bin/bash</code>, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ chroot /tmp/testdir /bin/bash</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec92"/>Forcing the system to write all content to disks</h1></div></div></div><p>Modern systems <a id="id473" class="indexterm"/>buffer everything in memory and occasionally write that content to disk. The obvious reason for this is that the disks are very slow and the memory is fast. This does have a bad side effect, that is, sometimes the data that we expect to be on a disk is not actually written. The <code class="literal">sync</code> command causes all the data that is not yet written to disk to be synchronized to the disk, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ sync</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec93"/>Adding new users</h1></div></div></div><p>To add <a id="id474" class="indexterm"/>a new user to the system, the <code class="literal">useradd</code> command can be used. While there are many options and parameters that can be supplied, as seen in <a class="link" href="ch04.html" title="Chapter 4. Manually Installing an Alternative Operating System">Chapter 4</a>, <em>Manually Installing an Alternative Operating System</em>, the manual page does a great job of explaining all the options. However, just applying a new username is sufficient to create a bare user, as shown in the following command. Note that a new user does not have a password yet and needs one created via the previously mentioned <code class="literal">passwd</code> command.</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ useradd superpackt</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec94"/>Additional commands</h1></div></div></div><p>This chapter contained<a id="id475" class="indexterm"/> a short list of the most basic commands. There are many more commands and even more guides on the Internet that go over a lot of commands. The website <a class="ulink" href="http://www.reallylinux.com/">http://www.reallylinux.com/</a> has a nice section called <em>Essential Commands</em> where these and more are briefly covered, but any site that covers the basic Linux commands can be used to learn more about commands.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec95"/>Summary</h1></div></div></div><p>This appendix covered the most basic Linux commands as well as the ones used throughout this book. The next appendix will give you an overview of the FEX configuration file.</p></div></body></html>