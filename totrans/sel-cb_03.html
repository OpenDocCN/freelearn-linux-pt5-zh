<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Confining Web Applications</h1></div></div></div><p>In this chapter, we will cover the default confinement of the web server domain and practice how to enhance this policy to suit our needs. We will also look into <code class="literal">mod_selinux</code> and how it can be used to confine web applications even further. All this will be handled through the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Listing conditional policy support</li><li class="listitem" style="list-style-type: disc">Enabling user directory support</li><li class="listitem" style="list-style-type: disc">Assigning web content types</li><li class="listitem" style="list-style-type: disc">Using different web server ports</li><li class="listitem" style="list-style-type: disc">Using custom content types</li><li class="listitem" style="list-style-type: disc">Creating a custom CGI domain</li><li class="listitem" style="list-style-type: disc">Setting up mod_selinux</li><li class="listitem" style="list-style-type: disc">Starting Apache with limited clearance</li><li class="listitem" style="list-style-type: disc">Mapping HTTP users to contexts</li><li class="listitem" style="list-style-type: disc">Using source address mapping to decide on contexts</li><li class="listitem" style="list-style-type: disc">Separating virtual hosts with mod_selinux</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Introduction</h1></div></div></div><p>Web applications are <a id="id211" class="indexterm"/>a prime example of where SELinux can prove its effectiveness. They are often facing the (untrusted) Internet and are a popular target to exploit. Securing the web server and web applications is just one of the basic mitigating strategies though—by confining the web server, we are reducing the results of a successful exploit even further.</p><p>A well-confined web server will only allow operations towards the operating system that are acceptable behavior for the service. But considering the wide area of services that can be provided through a web server, we must be careful not to open up too many privileges.</p><p>Policy developers have foreseen the situation that the web server domain might be too broad in its privileges and have made the web server domain (<code class="literal">httpd_t</code>) not only very versatile, but also very configurable. In this chapter, we will look into the domain in more detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Listing conditional policy support</h1></div></div></div><p>The first <a id="id212" class="indexterm"/>configurable aspect of the SELinux web server domain policy is its wide use of SELinux Booleans. Through these Booleans, additional policy rules can be selectively enabled or disabled. In this recipe, we'll look at the Booleans and see how these can be toggled.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>How to do it…</h2></div></div></div><p>In order to list the conditional policy support, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Request the list of all SELinux Booleans and selectively show those starting with <code class="literal">httpd_</code>:<div><pre class="programlisting">
<strong>~# getsebool –a | grep httpd_</strong>
</pre></div></li><li class="listitem">To get a short description together with the Booleans, we can use <code class="literal">semanage</code>:<div><pre class="programlisting">
<strong>~# semanage boolean –l | grep httpd_</strong>
</pre></div></li><li class="listitem">If the description of a Boolean isn't sufficient, we can ask the SELinux utilities to display the SELinux rules that will be enabled (or disabled) if the Boolean is set:<div><pre class="programlisting">
<strong>~# sesearch –b httpd_enable_ftp_server –AC</strong>
<strong>Found 3 semantic av rules:</strong>
<strong>DT allow httpd_t httpd_t : capability net_bind_service ; [ httpd_enable_ftp_server ]</strong>
<strong>DT allow httpd_t ftp_port_t : tcp_socket { recv_msg send_msg name_bind } ; [ httpd_enable_ftp_server ]</strong>
<strong>DT allow httpd_t ftp_server_packet_t : packet { send recv } ; [ httpd_enable_ftp_server ]</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>How it works...</h2></div></div></div><p>Conditional SELinux policy support is provided through SELinux Booleans. These are configurable parameters (with a <code class="literal">true</code>/<code class="literal">false</code> value), which an administrator can enable or disable<a id="id213" class="indexterm"/> using <a id="id214" class="indexterm"/>the <code class="literal">setsebool</code> or <code class="literal">semanage boolean</code> command.</p><p>With <a id="id215" class="indexterm"/>the <code class="literal">getsebool</code> command, we request an overview of all SELinux Booleans. Recent policies have a few hundred Booleans assigned, but luckily most Booleans follow one of the two following naming conventions that make filtering easier:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Boolean starts with <code class="literal">allow_</code> or <code class="literal">use_</code></li><li class="listitem" style="list-style-type: disc">A Boolean starts with the SELinux policy module prefix</li></ul></div><p>Booleans<a id="id216" class="indexterm"/> that start with <code class="literal">allow_</code> or <code class="literal">use_</code> are considered global Booleans and will usually affect multiple SELinux policy modules. A good example for such a Boolean is <code class="literal">allow_execmem</code>, which enables several domains to execute <a id="id217" class="indexterm"/>code stored in writable memory rather than read-only memory (this is a harmful, but sometimes unavoidable memory permission setting).</p><p>Most, if not all other Booleans start with the SELinux policy module prefix that they are applied to. For the web server, this is <code class="literal">httpd_</code> (even though the policy is called apache, the <code class="literal">httpd_</code> prefix is chosen because the policy can apply directly on various web servers, not only on the Apache HTTPd).</p><p>When we <a id="id218" class="indexterm"/>use the <code class="literal">semanage boolean</code> command, a short description is provided for the Booleans. This description is obtained from an XML file called <code class="literal">policy.xml</code>, which can be found at <code class="literal">/usr/share/selinux/devel/</code>. The XML file is generated during the build of the base SELinux policy.</p><p>The most accurate description of a Boolean, however, is the set of rules that it would trigger when enabled or disabled. This is where the <code class="literal">sesearch</code> command comes into play.</p><p>As can be seen from the example, Booleans will trigger one or more allow rules. The prefix to the <code class="literal">sesearch</code> output tells us whether a shown rule is active if the Boolean is true (<code class="literal">T</code>) or false (<code class="literal">F</code>), and if the rule is currently enabled (<code class="literal">E</code>) in the policy or disabled (<code class="literal">D</code>).</p><p>A nice trick when querying the SELinux policy using <code class="literal">sesearch</code> is to ask for Boolean-managed rules as well (regardless of whether they are currently enabled or disabled). This can be accomplished<a id="id219" class="indexterm"/> by adding the <code class="literal">–C</code> option (which is the short option for <code class="literal">--show_cond</code>). For instance, to find the transitions of the <code class="literal">newrole_t</code> domain, the following command can be used:</p><div><pre class="programlisting">
<strong>~# sesearch –s newrole_t –c process –p transition –AC</strong>
<strong>Found 5 semantic av rules:</strong>
<strong>   allow newrole_t newrole_t : process { … };</strong>
<strong>   allow newrole_t chkpwd_t : process transition;</strong>
<strong>   allow newrole_t updpwd_t : process transition;</strong>
<strong>EF allow newrole_t userdomain : process transition ; [ secure_mode ]</strong>
<strong>DT allow newrole_t unpriv_userdomain : process transition ; [ secure_mode ]</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">httpd_selinux</code> manual <a id="id220" class="indexterm"/>page lists all SELinux Booleans that are applicable to the Apache SELinux module and explains their purpose in more detail:<div><pre class="programlisting">
<strong>~$ man httpd_selinux</strong>
</pre></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Enabling user directory support</h1></div></div></div><p>Let's look<a id="id221" class="indexterm"/> at an example of how to use SELinux Booleans applicable to web server installations. In this recipe, we'll enable Apache UserDir support (allowing the web server to serve local user account web pages at <code class="literal">http://sitename/~username</code>).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Getting ready</h2></div></div></div><p>Configure the Apache web server to serve user content. An entire Apache configuration tutorial would be in place here, but this is not in the scope of this book. Basically, this is done by editing the <code class="literal">httpd.conf</code> file and setting the <code class="literal">UserDir</code> directive.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>How to do it…</h2></div></div></div><p>To enable user directory support, follow the next set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure that the user's home directory is accessible for the Apache runtime account with the following commands. If Linux DAC denies access, SELinux will not even handle the request.<div><pre class="programlisting">
<strong>~$ chmod 755 ${HOME}/</strong>
<strong>~$ chmod 755 ${HOME}/public_html</strong>
</pre></div></li><li class="listitem">Check that access isn't already allowed by surfing to a user page. If all permissions are okay but SELinux denies access, then the page should be served with a 403 (forbidden) error and a denial should be registered in the audit logs. The Apache error logs would yield a permission denied against the resource.</li><li class="listitem">The audit logs will probably tell that <code class="literal">httpd_t</code> isn't allowed to act on <code class="literal">home_root_t</code> or <code class="literal">user_home_dir_t</code>. From a look through the SELinux Booleans, we find at least two interesting Booleans (<code class="literal">httpd_enable_homedirs</code> and <code class="literal">httpd_read_user_content</code>):<div><pre class="programlisting">
<strong>~# sesearch -s httpd_t -t home_root_t -c dir -p open -AC</strong>
<strong>Found 2 semantic av rules:</strong>
<strong>DT allow httpd_t home_root_t : dir { getattr search open } ; [ httpd_enable_homedirs ]</strong>
<strong>DT allow httpd_t home_root_t : dir { getattr search open } ; [ httpd_read_user_content ]</strong>
</pre></div></li><li class="listitem">Let's first toggle <code class="literal">httpd_read_user_content</code>. This allows the web server to access all user files, which is functionally okay, but this also immediately grants it access to all files:<div><pre class="programlisting">
<strong>~# setsebool httpd_read_user_content on</strong>
</pre></div></li><li class="listitem">Another <a id="id222" class="indexterm"/>approach (but this approach requires user intervention) is to have <code class="literal">~/public_html/</code> labeled as <code class="literal">httpd_user_content_t</code>. When this is done, <code class="literal">httpd_read_user_content</code> can be turned off and <code class="literal">httpd_enable_homedirs</code> can be enabled:<div><pre class="programlisting">
<strong>~$ chcon –R –t httpd_user_content_t public_html</strong>
<strong>~# setsebool httpd_read_user_content off</strong>
<strong>~# setsebool httpd_enable_homedirs on</strong>
</pre></div></li><li class="listitem">When the changes are working nicely, we can persist the changes so that they survive a reboot:<div><pre class="programlisting">
<strong>~# setsebool –P httpd_enable_homedirs on</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>How it works...</h2></div></div></div><p>The default web server policy in SELinux does not allow the web server to access user home content. If a vulnerability in a web application or the Apache web server itself would allow an attacker to read user content, SELinux will prevent this from happening. But, sometimes, user content access is needed.</p><p>By enabling the <code class="literal">httpd_read_user_content</code> Boolean, the web server domain (and all related domains) will have full read access to all user files. If users are not able (or do not know how) to set the proper context on their files, then this is the only suitable option.</p><p>A better approach, however, is to enable the <code class="literal">httpd_enable_homedirs</code> Boolean. This allows the web server search access through the home directory (<code class="literal">/home/user/</code>, which is labeled <code class="literal">user_home_dir_t</code>) but does not provide read access to user content (which is labeled <code class="literal">user_home_t</code>). Instead, the resources needed for the web server are labeled <code class="literal">httpd_user_content_t</code>—a type that regular users can relabel resources to (or relabel resources from). Next to <code class="literal">httpd_user_content_t</code>, one can also define the following content types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">httpd_user_htaccess_t</code> for the <code class="literal">.htaccess</code> files</li><li class="listitem" style="list-style-type: disc"><code class="literal">httpd_user_script_exec_t</code> for user-provided CGI scripts</li><li class="listitem" style="list-style-type: disc"><code class="literal">httpd_user_ra_content_t</code> for appendable resources (for the web server)</li><li class="listitem" style="list-style-type: disc"><code class="literal">httpd_user_rw_content_t</code> for read/write resources (for the web server)</li></ul></div><p>These resources can be set by the end user and give a finer control over how each resource within the <code class="literal">~/public_html/</code> location can be handled by the web server (and the web applications).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>There's more...</h2></div></div></div><p>Some SELinux <a id="id223" class="indexterm"/>supporting distributions have a daemon called <code class="literal">restorecond</code>, which <a id="id224" class="indexterm"/>can be used to automatically set the context of files the moment they are created/detected, without needing file transitions in policy. This can be used to automatically have <code class="literal">~/public_html/</code> labeled as <code class="literal">httpd_user_content_t</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">More information <a id="id225" class="indexterm"/>about per-user web directories can be found at <a class="ulink" href="https://httpd.apache.org/docs/2.4/howto/public_html.html">https://httpd.apache.org/docs/2.4/howto/public_html.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Assigning web content types</h1></div></div></div><p>For <a id="id226" class="indexterm"/>standard web server configurations (without SELinux), access rights on resources for a web server are purely based on the ownership of the files (and the access mask applied to it). With SELinux, the resources can be labeled more specifically towards their functional meaning.</p><p>Web applications have content that should be read-only and content that should be read-write, but there are also specific types for resources such as <code class="literal">.htaccess</code> files. In this recipe, we'll look at the various web server content types and apply them to the right resources.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>How to do it…</h2></div></div></div><p>Execute the following steps to assign specific web content types to the right resources:</p><div><ol class="orderedlist arabic"><li class="listitem">Take a look at the available content types for web servers by asking SELinux to show us all types that have the <code class="literal">httpdcontent</code> attribute set:<div><pre class="programlisting">
<strong>~$ seinfo –ahttpdcontent –x</strong>
<strong>  httpdcontent</strong>
<strong>    httpd_sys_content_t</strong>
<strong>    httpd_user_ra_content_t</strong>
<strong>    httpd_user_rw_content_t</strong>
<strong>    httpd_nagios_content_t</strong>
<strong>…</strong>
</pre></div></li><li class="listitem">Query the existing policy for known context assignations (as those can give us pointers to what is still lacking):<div><pre class="programlisting">
<strong>~$ semanage fcontext –l | grep httpd_nagios</strong>
</pre></div></li><li class="listitem">Now, assign the right context to those resources that aren't labeled correctly yet. The paths used here are an example for a Nagios installation:<div><pre class="programlisting">
<strong>~# semanage fcontext –a –t httpd_nagios_content_t /var/www/html/nagios(/.*)?</strong>
<strong>~# semanage fcontext –a –t httpd_nagios_script_exec_t /usr/local/lib/nagios/cgi-bin/.*</strong>
<strong>~# restorecon –R /var/www/html/nagios /usr/local/lib/nagios</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How it works</h2></div></div></div><p>The web <a id="id227" class="indexterm"/>server policy supports functional content types for web applications. These types are used for the following content types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Read-only content of the web application</li><li class="listitem" style="list-style-type: disc">Writable content of the web application (for which a distinction is made between full writable content and content that can only be appended to, such as logfiles)</li><li class="listitem" style="list-style-type: disc">Executable scripts (for CGI scripts and similar content)</li></ul></div><p>The advantage is not so much that there is the distinction of read-only versus read-write, but that this is supported on a per-application basis, with types that are specific to one application. In the example, we looked at the content for the Nagios monitoring application.</p><p>This allows administrators to provide access to these resources towards specific applications or users. Even though all content in <code class="literal">/var/www/html/</code> might be owned by the Apache Linux user, we can still grant users (and applications) access to application-specific resources without needing to grant those users or applications full privileges on all Apache resources.</p><p>For the read-only content, there is the regular web application content (<code class="literal">httpd_nagios_content_t</code>) and the special <code class="literal">.htaccess</code> content (<code class="literal">httpd_nagios_htaccess_t</code>). The distinction is made primarily because access to the regular content is given more broadly (and depending on some SELinux Booleans, this can also become writable content), whereas the <code class="literal">.htaccess</code> content remains read-only.</p><p>To query the available web server content, we used the <code class="literal">httpdcontent</code> attribute. This attribute is assigned to all content, allowing administrators to create policies that govern all web content. The <a id="id228" class="indexterm"/>
<code class="literal">httpdcontent</code> attribute is given to all these types, but there are also attributes called <code class="literal">httpd_rw_content</code>, <code class="literal">httpd_ra_content</code>, <code class="literal">httpd_htaccess_type</code>, and <code class="literal">httpd_script_exec_type</code> to allow for manipulation of those specific resources.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>There's more...</h2></div></div></div><p>We covered Nagios as an example web application, which has a set of web application related resources. Many other web applications or applications with web content have already been identified policy-wise.</p><p>On Linux <a id="id229" class="indexterm"/>distributions that have all known policies loaded by default, this overview will already be visible through the <code class="literal">seinfo</code> command as per our preceding example. If that isn't the case, we can always search through the SELinux policies to find out which modules call the <code class="literal">apache_content_template</code>—the interface that automatically generates the right web application content types:</p><div><pre class="programlisting">
<strong>~$ grep apache_content_template ${POLICY_LOCATION}/policy/modules/*/*.te</strong>
</pre></div><p>When different types become more troublesome than helpful, it is possible to ask the SELinux policy to see all those different types as just one common web content type and be done with it. This is supported through the <code class="literal">httpd_unified</code> Boolean. When this Boolean is enabled, the web server policy will treat all various web server resource types as one, unifying all the types. And, if the Booleans, <code class="literal">httpd_enable_cgi</code> and <code class="literal">httpd_builtin_scripting</code>, are enabled as well, then the web server domain has the privilege to execute that content as well.</p><p>Needless to say, unifying the web server resource contexts might make management simpler; it also increases the privileges of the web server domain towards various web resources, making it potentially less secure.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Using different web server ports</h1></div></div></div><p>By default, web <a id="id230" class="indexterm"/>servers listen on the known web server ports (such as ports <code class="literal">80</code> and <code class="literal">443</code>). Often, administrators might want to have the web server listen on a nondefault port. The SELinux policy might reject this, as it is not standard behavior for a web server to listen on other unrelated ports.</p><p>In this recipe, we will tell SELinux that a nondefault port should still be seen as a web server port.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>How to do it…</h2></div></div></div><p>In order to assign a label to a different port, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">To see all the ports that match <code class="literal">http_port_t</code>, use <code class="literal">semanage port -l</code>:<div><pre class="programlisting">
<strong>~# semanage port -l | grep -w http_port_t</strong>
<strong>http_port_t  tcp  80, 81, 443, 488, 8008, 8009, 8443, 9000</strong>
</pre></div></li><li class="listitem">Query the SELinux policy to see which port type is assigned to a particular port. For instance, for port <code class="literal">8881</code>, the following command is used:<div><pre class="programlisting">
<strong>~$ seinfo --portcon=8881</strong>
</pre></div></li><li class="listitem">If the<a id="id231" class="indexterm"/> port is identified as <code class="literal">unreserved_port_t</code>, then we can mark it as <code class="literal">http_port_t</code>:<div><pre class="programlisting">
<strong>~# semanage port -a -t http_port_t -p tcp 8881</strong>
</pre></div></li><li class="listitem">If, however, the port has been already assigned a particular type, then we need to update the SELinux policy for the web server to allow it to listen on ports of this particular type. For instance, for port <code class="literal">9090</code> (<code class="literal">websm_port_t</code>), perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">First find the interface that allows binding on <code class="literal">websm_port_t</code>:<div><pre class="programlisting">
<strong>~$ sefindif websm_port_t.*bind</strong>
</pre></div></li><li class="listitem">Create a custom SELinux policy (<code class="literal">myhttpd</code>) with the following content:<div><pre class="programlisting">corenet_sendrecv_websm_server_packets(httpd_t)
corenet_tcp_bind_websm_port(httpd_t)</pre></div></li><li class="listitem">Load the policy to allow the web server to bind on the identified port type.</li></ol></div></li><li class="listitem">Finally, edit the web server configuration file to listen to the right port:<div><pre class="programlisting">Listen *:8881</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>How it works...</h2></div></div></div><p>SELinux works with labels for all resources, including ports. In this example, we are looking at TCP port types to allow the web server to bind to.</p><p>With <code class="literal">seinfo</code>, we can see whether a port matches a known declaration. Ports with a value of <code class="literal">1024</code> or higher are, by default, labeled as <code class="literal">unreserved_port_t</code>, whereas, ports <code class="literal">511</code> or lower are labeled as <code class="literal">reserved_port_t</code> and those in between are labeled as <code class="literal">hi_reserved_port_t</code>. These are, however, defaults and more specific port types might be declared for a specific port.</p><p>If a port is not assigned a specific type yet, then we can assign one ourselves using <code class="literal">semanage port</code>. This is sufficient to allow the web server to bind to this port (there is no need for relabeling operations on ports, unlike files or directories, as this is done by the SELinux subsystem immediately).</p><p>If a port is already assigned a specific type, then it cannot be overridden by additional policies or the administrator. When this occurs, the SELinux policy will need to be enhanced to allow the web server to bind to this specific type.</p><p>In the example, we searched for the interface that would allow the web server to bind to the port, revealing <code class="literal">corenet_tcp_bind_websm_port</code> as the interface to use. However, we also added another interface—this is due to the way network controls are configured in SELinux, and may or may not be necessary on a system. The additional interface is <code class="literal">corenet_sendrecv_websm_server_packets</code>. This interface is used to allow the web server to <a id="id232" class="indexterm"/>send or receive packets labeled as <code class="literal">websm_server_packet_t</code>. Packet labeling allows for application-specific communication flow governance and extends the regular firewall capabilities of the Linux operating system (which focus primarily on network flow management) with SELinux domain awareness.</p><p>If packet labeling is <a id="id233" class="indexterm"/>needed, then packets are labeled through <code class="literal">iptables</code> on a local system, as shown in the following command:</p><div><pre class="programlisting">
<strong>~# iptables –t mangle –A INPUT –p tcp --dport 9090 -j SECMARK --selctx system_u:object_r:websm_server_packet_t</strong>
</pre></div><p>If a system does not have such iptables-based labeling (known as SECMARK labeling), then the interface is not needed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>There's more...</h2></div></div></div><p>Recent SELinux user space utilities have another command available to query the SELinux <a id="id234" class="indexterm"/>policy, called <code class="literal">sepolicy</code>. Searching for port declarations with <code class="literal">sepolicy</code> is done as follows:</p><div><pre class="programlisting">
<strong>~$ sepolicy network --port 8080</strong>
<strong>8080: tcp unreserved_port_t 1024-65535</strong>
<strong>8080: udp unreserved_port_t 1024-65535</strong>
<strong>8080: tcp http_cache_port_t 8080</strong>
</pre></div><p>Also, in the SELinux policy rules, we will notice that there is a third interface often enabled for network communication. In our example, the third interface would be called <code class="literal">corenet_tcp_sendrecv_websm_port</code>. This access vector would enable the domain to send and receive messages on the <code class="literal">websm_port_t</code> TCP socket. However, the support for this access vector has been disabled in recent policies in favor of SECMARK labeling.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SECMARK labeling is explored in <a class="link" href="ch09.html" title="Chapter 9. Aligning SELinux with DAC">Chapter 9</a>, <em>Aligning SELinux with DAC</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Using custom content types</h1></div></div></div><p>Next up is<a id="id235" class="indexterm"/> to create our own set of content types for a web application<a id="id236" class="indexterm"/> that does not have a policy associated with it yet. We will use <strong>DokuWiki</strong> (available at <a class="ulink" href="https://www.dokuwiki.org">https://www.dokuwiki.org</a>) as an example.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Getting ready</h2></div></div></div><p>Install DokuWiki either through the Linux distributions' package manager or manually through a downloaded release from the main site. In this example, we assume that DokuWiki is installed at <code class="literal">/srv/web/dokuwiki/</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>How to do it…</h2></div></div></div><p>To use custom web content types, follow the next set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a policy called <code class="literal">mydokuwiki.te</code> with the following content:<div><pre class="programlisting">apache_content_template(dokuwiki)</pre></div></li><li class="listitem">Add a file context definition file called <code class="literal">mydokuwiki.fc</code>, which contains the following code:<div><pre class="programlisting">/srv/web/dokuwiki/lib/plugins(/.*)?  gen_context(system_u:object_r:httpd_dokuwiki_rw_content_t,s0)
/srv/web/dokuwiki/conf(/.*)?  gen_context(system_u:object_r:httpd_dokuwiki_rw_content_t,s0)
/srv/web/dokuwiki/data(/.*)?  gen_context(system_u:object_r:httpd_dokuwiki_rw_content_t,s0)
/srv/web/dokuwiki/data/\.htaccess  --  gen_context(system_u:object_r:httpd_dokuwiki_htaccess_t,s0)
/srv/web/dokuwiki(/.*)?  gen_context(system_u:object_r:httpd_dokuwiki_content_t,s0)</pre></div></li><li class="listitem">Build and load the policy and then relabel all DokuWiki files using the following commands:<div><pre class="programlisting">
<strong>~# semodule -i mydokuwiki.pp</strong>
<strong>~# restorecon -RvF /srv/web/dokuwiki</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>How it works...</h2></div></div></div><p>All the magic associated with creating web application content in SELinux is handled by the <code class="literal">apache_content_template</code> interface. With <code class="literal">seshowif</code>, one can show all underlying SELinux policy rules as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Various<a id="id237" class="indexterm"/> SELinux types are created, such as <code class="literal">httpd_dokuwiki_content_t</code> and the like, and the proper attributes are assigned to it (such as the <code class="literal">httpdcontent</code> attribute).</li><li class="listitem" style="list-style-type: disc">An SELinux Boolean is created, which allows the administrator to enable or disable the web application to write to public files (labeled as <code class="literal">public_content_rw_t</code>). This is an SELinux type used for resources that are shared across multiple services (such as FTP servers, web servers, and many more).</li><li class="listitem" style="list-style-type: disc">The necessary privileges are granted to the web server domain to access and handle the newly defined types, as well as enabling CGI domains for the web application. For our DokuWiki example, this is not needed as everything is handled by the PHP code parsed and executed by the web server itself (usually).</li></ul></div><p>We then labeled all DokuWiki files accordingly, based on the DokuWiki best practices for file access. Some administrators might want to have the <code class="literal">conf/</code> subdirectory labeled as a nonwritable resource, and only (temporarily) enable this during the configuration. Although this is a valid approach, it might be sufficient to use Linux DAC file access controls to accomplish the same results.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>There's more...</h2></div></div></div><p>Using the <code class="literal">apache_content_template</code> interface is a simple way to create web content types, but it has the downside that it is an all-or-nothing approach, and the module now heavily depends on the web server module (<code class="literal">apache</code>).</p><p>Experienced users might want to selectively create content and assign the right attributes to it, allowing the web server domain to interact with the resources while still keeping granular control over the types and resources.</p><p>We'll leave this as an exercise that you can do to see how this can be accomplished.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Creating a custom CGI domain</h1></div></div></div><p>Sometimes, it <a id="id238" class="indexterm"/>might not be necessary to create a full set of types. Consider a CGI script that is triggered but without the need for a specific set of content types. Sure, one can mark the script as <code class="literal">httpd_sys_script_exec_t</code> (if it is a system's CGI script) or <code class="literal">httpd_user_script_exec_t</code> (if it is a user's custom CGI script) so that the resulting script runs in the <code class="literal">httpd_sys_script_t</code> or <code class="literal">httpd_user_script_t</code> domain.</p><p>But, if those domains do not hold enough privileges (or too many privileges), it might be wise to create a custom CGI domain instead.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>How to do it…</h2></div></div></div><p>To create<a id="id239" class="indexterm"/> a custom CGI domain, the following approach can be used:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a custom SELinux policy module (<code class="literal">mycgiscript.te</code>) with the following content:<div><pre class="programlisting">policy_module(mycgiscript, 0.1)
type cgiscript_t;
type cgiscript_exec_t;
domain_type(cgiscript_t)
domain_entry_file(cgiscript_t, cgiscript_exec_t)
apache_cgi_domain(cgiscript_t, cgiscript_exec_t)</pre></div></li><li class="listitem">Create the proper file context file (<code class="literal">mycgiscript.fc</code>), marking the executable as <code class="literal">cgiscript_exec_t</code>:<div><pre class="programlisting">/path/to/script  --gen_context(system_u:object_r:cgiscript_exec_t,s0)</pre></div></li><li class="listitem">Build and load the module.</li><li class="listitem">Relabel the executable and test it out:<div><pre class="programlisting">
<strong>~# restorecon /path/to/script</strong>
</pre></div></li><li class="listitem">As the <code class="literal">cgiscript_t</code> domain is primitive in its rights, the script will most likely not work—however, do not turn SELinux in permissive mode. The audit logs will show the access attempts that were denied. Instead of using <code class="literal">audit2allow</code> to automatically grant everything, use the <code class="literal">sefindif</code> function to find a proper interface. Add the right interfaces to the module and retry until the script works properly.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec72"/>How it works...</h2></div></div></div><p>The policy module defines a domain type (<code class="literal">cgiscript_t</code>) and an executable type (<code class="literal">cgiscript_exec_t</code>). With the <code class="literal">domain_type</code> interface, <code class="literal">cgiscript_t</code> is marked as a domain (and the proper SELinux rules to deal with this new domain are created as well). With <code class="literal">domain_entry_type</code>, the SELinux policy is updated to mark <code class="literal">cgiscript_exec_t</code> as the type that can be used to transition towards the <code class="literal">cgiscript_t</code> domain.</p><p>Then, we call <code class="literal">apache_cgi_domain</code>, which allows the web server domain (<code class="literal">httpd_t</code>) to execute the <code class="literal">cgiscript_exec_t</code> labeled resources and have the resulting process run in the <code class="literal">cgiscript_t</code> domain.</p><p>The initial<a id="id240" class="indexterm"/> policy module, however, is very primitive and will not hold enough privileges. It is a matter of trial and error to update the policy. For instance, consider that the script calls a binary; the audit logs might show the following content:</p><div><pre class="programlisting">type=AVC msg=audit(1363205612.277:476924): avc: denied { execute } for pid=6855 comm="cgiscript.pl" name="perl" dev=sda3 ino=4325828 scontext=system_u:system_r:cgiscript_t:s0 tcontext=system_u:object_r:bin_t:s0 tclass=file</pre></div><p>To find out which policy interface would allow this, we can use <code class="literal">sefindif</code> again:</p><div><pre class="programlisting">
<strong>~$ sefindif exec.*bin_t'</strong>
<strong>interface(`corecmd_exec_bin',`</strong>
<strong>  can_exec($1, bin_t)</strong>
</pre></div><p>Developing custom policies remains a trial-and-error approach, but this is the only method available, which ensures that only necessary privileges are granted to a domain. Some policy developers would suggest to turn on the permissive mode and look through all denials in the audit logs. The problem with that approach is that these denials might not lead to the right SELinux policy rules.</p><p>For instance, the script might need to call another executable (and transition to a domain). In permissive mode, the transition will not occur, and it would look like the main domain (<code class="literal">cgiscript_t</code>) needs all privileges that the target command needs—even though all that is needed is a proper domain transition.</p><p>By focusing on the enforcing mode, we can gradually increase the policy while keeping the <em>least privilege</em> principle in place, only allowing those privileges that are actually needed.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Setting up mod_selinux</h1></div></div></div><p>In the <a id="id241" class="indexterm"/>next set of recipes, we use an Apache module called <code class="literal">mod_selinux</code> to make Apache SELinux-aware and to support configurable transitions. In other words, the context in which Apache is running is no longer a statically defined context, but can be changed according to the administrators' needs.</p><p>In this recipe, we will install <code class="literal">mod_selinux</code> from its source as many Linux distributions do not offer it by default, even though it is a very powerful addition to the web server (which is also why support for <code class="literal">mod_selinux</code> is often called Apache/SELinux Plus).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How to do it…</h2></div></div></div><p>You can set up <code class="literal">mod_selinux</code> through the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Download <a id="id242" class="indexterm"/>the sources from <a class="ulink" href="https://github.com/kaigai/mod_selinux">https://github.com/kaigai/mod_selinux</a>.</li><li class="listitem">Make <a id="id243" class="indexterm"/>sure that the Apache development headers (<code class="literal">httpd-devel</code> on Red Hat or Fedora systems) are installed.</li><li class="listitem">Build and install the <code class="literal">mod_selinux</code> shared library for Apache using <code class="literal">apxs</code>:<div><pre class="programlisting">
<strong>~# apxs -c -i mod_selinux.c</strong>
</pre></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>It may be possible that the build fails with an error about <code class="literal">client_ip</code>. If that is the case, edit <code class="literal">mod_selinux.c</code> at the line number shown in the error and use <code class="literal">remote_ip</code> instead of <code class="literal">client_ip</code>, after which the <code class="literal">apxs</code> command can be run again.</p></div></div></li><li class="listitem">Build and install the <code class="literal">mod_selinux</code> SELinux policy module, whose files are also part of the downloaded sources:<div><pre class="programlisting">
<strong>~$ cp mod_selinux.te ${DEVROOT}/local</strong>
<strong>~$ cp mod_selinux.if ${DEVROOT}/local</strong>
<strong>~$ cd ${DEVROOT}/local &amp;&amp; make mod_selinux.pp</strong>
<strong>~# semodule -i mod_selinux.pp</strong>
</pre></div></li><li class="listitem">Edit the web server configuration (<code class="literal">httpd.conf</code>) and add in the proper <code class="literal">LoadModule</code> line:<div><pre class="programlisting">LoadModule selinux_module modules/mod_selinux.so</pre></div></li><li class="listitem">Restart the web server. Its logfiles should tell you that the SELinux policy support is loaded:<div><pre class="programlisting">[Fri Apr 18 13:11:23 2014] [notice] SELinux policy enabled; httpd running as context unconfined_u:system_r:httpd_t:s0-s0:c0.c1023</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec74"/>How it works...</h2></div></div></div><p>The <code class="literal">mod_selinux.c</code> file contains<a id="id244" class="indexterm"/> the Apache module code and can be built using <code class="literal">apxs</code>—the Apache eXtenSion tool. This tool will perform the following <a id="id245" class="indexterm"/>tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the compiler with the proper arguments to build a dynamic shared object that can be loaded at runtime by the Apache web server</li><li class="listitem" style="list-style-type: disc">Install the resulting module in the proper Apache <code class="literal">modules/</code> directory</li></ul></div><p>The build failure mentioned in the recipe can come up depending on the Apache version in use, where a variable has a different name (<code class="literal">client_ip</code> instead of <code class="literal">remote_ip</code>).</p><p>Next, we copied and deployed the <code class="literal">mod_selinux</code> SELinux policy just like we did with other SELinux policy modules.</p><p>Finally, the <a id="id246" class="indexterm"/>web server is updated to enable the <code class="literal">mod_selinux</code> Apache module. With the <code class="literal">mod_selinux</code> shared library in place, Apache is now ready to make SELinux-related decisions.</p><p>If the <code class="literal">mod_selinux</code> support has to be distributed to multiple systems, then only the <code class="literal">mod_selinux.so</code> (now installed in the web server <code class="literal">modules/</code> directory, such as <code class="literal">/usr/lib64/httpd/modules/</code>) and <code class="literal">mod_selinux.pp</code> files (the SELinux policy module) need to be distributed.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec75"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A good<a id="id247" class="indexterm"/> write-up on <code class="literal">mod_selinux</code> can be found at <a class="ulink" href="http://code.google.com/p/sepgsql/wiki/Apache_SELinux_plus">http://code.google.com/p/sepgsql/wiki/Apache_SELinux_plus</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Starting Apache with limited clearance</h1></div></div></div><p>In the <a id="id248" class="indexterm"/>previous chapter, we manipulated the <code class="literal">/etc/rc.d/init.d/httpd init</code> script to use <code class="literal">runcon</code> in order for the web server to run with a limited clearance. But with the help of <code class="literal">mod_selinux</code>, this can be made configurable.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>How to do it…</h2></div></div></div><p>In order to start Apache with limited security clearance, follow the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the Apache web server configuration file (<code class="literal">httpd.conf</code>) and add in the following code:<div><pre class="programlisting">&lt;IfModule mod_selinux.c&gt;
  selinuxServerDomain *:s0-s0:c0.c10
&lt;/IfModule&gt;</pre></div></li><li class="listitem">Undo the changes made to the service script in the previous chapter.</li><li class="listitem">Restart the web server and confirm that it is running with the <code class="literal">s0-s0:c0.c10</code> clearance by issuing the following commands:<div><pre class="programlisting">
<strong>~# /etc/rc.d/init.d/httpd restart</strong>
<strong>~# ps -efZ | grep httpd</strong>
<strong>system_u:system_r:httpd_t:s0-s0:c0.c10 root 2838 1  0 13:14 ?      00:00:00 /usr/sbin/httpd</strong>
<strong>system_u:system_r:httpd_t:s0-s0:c0.c10 apache 2840 2838  0 13:14 ? 00:00:00 /usr/sbin/httpd</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How it works...</h2></div></div></div><p>As mentioned before, with <code class="literal">mod_selinux</code>, the Apache web server becomes SELinux-aware, meaning it can alter its own behavior and interact with the SELinux subsystem based on configuration settings as well as SELinux policy rules.</p><p>With<a id="id249" class="indexterm"/> the <code class="literal">selinuxServerDomain</code> configuration directive, <code class="literal">mod_selinux</code> performs a dynamic change of the current context to a new context, which is called a dynamic domain transition or dynamic range transition (it is called domain if the type changes, range if the sensitivity level or security clearance changes). This is only possible if an application is SELinux-aware.</p><p>Now, such a transition is still governed through SELinux policies. For instance, the range to which the Apache web server can transition must be dominated by the range the Apache web server originally has (which was <code class="literal">s0-s0:c0.c1024</code> in our example).</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The <code class="literal">mod_selinux</code> module does not support lookups on the context, making it impossible to use human-readable sensitivities (governed through <code class="literal">mcstransd</code> as we've seen previously).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>There's more...</h2></div></div></div><p>It is possible to define different types, allowing the entire web server to run in a custom domain. For this to happen, the <code class="literal">httpd_t</code> domain must have the rights to dynamically transition to the target type (the <code class="literal">dyntransition</code> permission in the <code class="literal">process</code> class). Then, the <code class="literal">selinuxServerDomain</code> call could look like the following code:</p><div><pre class="programlisting">selinuxServerDomain myhttpd_t:s0-s0:c0.c10</pre></div><p>Of course, many more privileges are needed as well in order to access resources already accessible by the <code class="literal">httpd_t</code> domain at startup, but the <code class="literal">dyntransition</code> permission is specific to the SELinux-aware applications that want to support dynamic domain transitions instead of transitioning upon process execution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Mapping HTTP users to contexts</h1></div></div></div><p>Applications<a id="id250" class="indexterm"/> generally run with a static context, which <a id="id251" class="indexterm"/>inhibits all privileges that are needed for the application. Even services (daemons) generally stay within their own context during the entire life cycle of the service. But, with <code class="literal">mod_selinux</code>, it is possible to transition the context of the web server handler (the process or thread responsible for handling a specific request) to another context based on the authenticated user. This allows the administrator to grant certain privileges to the application based on the user. When a lower-privileged user abuses a vulnerability in the web application, then the reduced privileges on the web application itself might prevent a successful exploit.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec79"/>How to do it…</h2></div></div></div><p>Through<a id="id252" class="indexterm"/> the following set of steps, we will map a web <a id="id253" class="indexterm"/>user to a specific SELinux context:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a mapping file in which the users are listed together with their target context. For instance, to have user John's requests handled with the sensitivity <code class="literal">s0:c0,c2</code>, user Cindy's requests with the sensitivity <code class="literal">s0:c0.c5,c7</code>, all unauthenticated users as <code class="literal">anon_webapp_t:s0</code>, and the other authenticated users as <code class="literal">user_webapp_t:s0:c0</code>:<div><pre class="programlisting">john    *:s0:c0,c2
cindy    *:s0:c0.c5,c7
__anonymous__  anon_webapp_t:s0
*      user_webapp_t:s0:c0</pre></div></li><li class="listitem">Save this file on a web server-readable location, such as <code class="literal">/etc/httpd/conf/mod_selinux.map</code>.</li><li class="listitem">Edit the web server configuration file and add in the following line:<div><pre class="programlisting">selinuxDomainMap  /etc/httpd/conf/mod_selinux.map</pre></div></li><li class="listitem">Restart the web server.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec80"/>How it works...</h2></div></div></div><p>The <code class="literal">mod_selinux</code> module is aware of the authenticated user value and, based on the settings in the mappings file, it can transition the request handler to a smaller sensitivity range (as is the case in the first two examples) or to different domains altogether.</p><p>There is an important constraint to this though. The target context to which the handler can transition must be bound by the main type (<code class="literal">httpd_t</code>). This means that the permissions granted to the target context must be a subset of the permissions granted to <code class="literal">httpd_t</code>. This is performed through the <code class="literal">typebounds</code> statement, as follows:</p><div><pre class="programlisting">typebounds httpd_t anon_webapp_t;</pre></div><p>This is because web server handlers are usually threads (or lightweight processes) instead of processes. Threads share a lot of resources, often in ways that SELinux cannot manage. As a result, if one thread gains more rights than the web server, then the secure state of the web server (as a whole) might be in jeopardy. Also, the information flow between different contexts would be difficult, if not impossible to govern.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Using source address mapping to decide on contexts</h1></div></div></div><p>The <code class="literal">mod_selinux</code> Apache module has access to other information than just the username (in case of authenticated users). It can access environment variables (which are used in the Apache<a id="id254" class="indexterm"/> web configuration <a id="id255" class="indexterm"/>through the <code class="literal">SetEnvIf</code> directives), allowing a very flexible approach on SELinux context handling within the application.</p><p>In this recipe, we will use this to change the context of request handlers based on the remote IP address of the client.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec81"/>How to do it…</h2></div></div></div><p>Alongside web users, we can also use source address information to decide on the context. This is done by completing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we define the <code class="literal">TARGETDOMAIN</code> environment variable based on the remote IP address in the web server configuration (<code class="literal">httpd.conf</code>):<div><pre class="programlisting">SetEnvIf Remote_Addr "10\.0\.[0-9]+\.[0-9]+$" TARGETDOMAIN=user_webapp_t:s0
SetEnvIf Remote_Addr "10\.1\.[0-9]+\.[0-9]+$" TARGETDOMAIN=anon_webapp_t:s0
SetEnvIf TARGETDOMAIN ^$ TARGETDOMAIN=*:s0</pre></div></li><li class="listitem">Then, in the same web server configuration, we invoke the <code class="literal">selinuxDomainEnv</code> directive, which will have the handler context transitioned to the value inside <code class="literal">TARGETDOMAIN</code>:<div><pre class="programlisting">selinuxDomainEnv TARGETDOMAIN</pre></div></li><li class="listitem">Restart the web server for the changes to take effect.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec82"/>How it works...</h2></div></div></div><p>In the first step, we used Apache's <code class="literal">SetEnvIf</code> directive (provided through <code class="literal">mod_setenvif</code>) to check the remote IP address of the client (<code class="literal">Remote_Addr</code>). If it matches the expression given, then we set the <code class="literal">TARGETDOMAIN</code> variable to the given context. In our example, we used a different type for each match, but it is also possible to just change the security clearance. We finished with a check that verified if the <code class="literal">TARGETDOMAIN</code> variable has been set. If not, then a default value (<code class="literal">*:s0</code>) is assigned.</p><p>Next, we called the <code class="literal">selinuxDomainEnv</code> directive, which makes a transition to the domain provided in the <code class="literal">TARGETDOMAIN</code> variable.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec83"/>There's more...</h2></div></div></div><p>The example uses <code class="literal">Remote_Addr</code>, but many other request-related aspects can be used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">With <code class="literal">Remote_Host</code>, the <a id="id256" class="indexterm"/>hostname of the client can be queried and used to make decisions.</li><li class="listitem" style="list-style-type: disc">With <code class="literal">Server_Addr</code>, the address of the web server itself (on which the request <a id="id257" class="indexterm"/>was received) can be used. This is<a id="id258" class="indexterm"/> useful in a multihomed system, where the web server binds to <a id="id259" class="indexterm"/>all available IP addresses.</li><li class="listitem" style="list-style-type: disc">With <code class="literal">Request_Method</code>, the <a id="id260" class="indexterm"/>type of request (such as <code class="literal">GET</code> or <code class="literal">POST</code>) can be used.</li><li class="listitem" style="list-style-type: disc">With <code class="literal">Request_Protocol</code>, the<a id="id261" class="indexterm"/> name and version of the HTTP protocol (such as <code class="literal">HTTP/1.0</code> or <code class="literal">HTTP/1.1</code>) can be used.</li><li class="listitem" style="list-style-type: disc">With <code class="literal">Request_URI</code>, the<a id="id262" class="indexterm"/> request URL can be used to tune the context or clearance.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec84"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For <a id="id263" class="indexterm"/>more information about Apache's <code class="literal">mod_setenvif</code> support, consult the module documentation at <a class="ulink" href="http://httpd.apache.org/docs/2.4/mod/mod_setenvif.html">http://httpd.apache.org/docs/2.4/mod/mod_setenvif.html</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Separating virtual hosts with mod_selinux</h1></div></div></div><p>One <a id="id264" class="indexterm"/>of Apache's strengths is that it can differentiate <a id="id265" class="indexterm"/>sites based on the name used to connect to the server, rather than just the IP address, port, and URL. This is called virtual host support and is a very popular approach to multitenant website and web application hosting.</p><p>For instance, a web server running on a single IP address can still host the sites of multiple customers, say <code class="literal">www.companyX.com</code> and <code class="literal">www.companyY.com</code>. With <code class="literal">mod_selinux</code>, we can change the context or security clearance of the web server request handlers based on the associated virtual host.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec85"/>How to do it…</h2></div></div></div><p>The following approach distinguishes virtual host confinement through <code class="literal">mod_selinux</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Decide on the contexts for the individual tenants. In the previous chapter, we used <code class="literal">s0:c100</code> for company X and <code class="literal">s0:c101</code> for company Y.</li><li class="listitem">In each virtual host, set the right clearance. For instance, for company X set the clearance as follows:<div><pre class="programlisting">&lt;VirtualHost *:443&gt;
  ServerName www.companyX.com
<strong>  selinuxDomainVal *:s0-s0:c100</strong>
&lt;/VirtualHost&gt;</pre></div></li><li class="listitem">Restart the web server for the changes to take effect.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec86"/>How it works...</h2></div></div></div><p>Unlike<a id="id266" class="indexterm"/> the <code class="literal">selinuxServerDomain</code> directive, which is for the entire web server, the <code class="literal">selinuxDomainVal</code> directive sets the context<a id="id267" class="indexterm"/> of the handlers (virtual hosts) individually. As we covered in the previous chapter, using multiple categories for a multitenant system is a flexible way of dealing with information isolation between tenants.</p><p>An important difference with the previous chapter, however, is that the <code class="literal">mod_selinux</code> module does not use <code class="literal">mcstransd</code>. The following setting will fail:</p><div><pre class="programlisting">selinuxDomainVal *:<strong>CompanyXClearance</strong>
</pre></div><p>Such a setting would result in the following error message by Apache:</p><div><pre class="programlisting">[error] (22)Invalid argument: SELinux: setcon_raw("unconfined_u:system_r:httpd_t:CompanyXClearance") failed</pre></div><p>As such, we need to use the standard sensitivity notation.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec87"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You <a id="id268" class="indexterm"/>can find more information about Apache virtual host support at <a class="ulink" href="http://httpd.apache.org/docs/2.4/vhosts/">http://httpd.apache.org/docs/2.4/vhosts/</a></li></ul></div></div></div></body></html>