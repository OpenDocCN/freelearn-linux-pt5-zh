["```\n$ cat file1 file2 file3 ...\n\n```", "```\n        $ cat file.txt\n This is a line inside file.txt\n This is the second line inside file.txt\n\n```", "```\n        $ cat one.txt two.txt \n This line is from one.txt\n This line is from two.txt\n\n```", "```\nOUTPUT_FROM_SOME COMMANDS | cat\n\n```", "```\n$ echo 'Text through stdin' | cat - file.txt\n\n```", "```\n$ cat -s file\n\n```", "```\n$ cat multi_blanks.txt\nline 1\n\nline 2\n\nline 3\n\nline 4\n\n$ cat -s multi_blanks.txt # Squeeze adjacent blank lines\nline 1\n\nline 2\n\nline 3\n\nline 4\n\n```", "```\n$ cat file.py \ndef function(): \n    var = 5 \n        next = 6 \n    third = 7 \n\n$ cat -T file.py \ndef function():\n^Ivar = 5\n^I^Inext = 6\n^Ithird = 7^I\n\n```", "```\n$ cat lines.txt\nline \nline\nline\n\n$ cat -n lines.txt\n 1 line\n 2 line\n 3 line\n\n```", "```\n$> echo \"This will vanish\" > myfile\n$> cat -n myfile >myfile\ncat: myfile: input file is output file\n$> cat myfile | cat -n >myfile\n$> ls -l myfile\n-rw-rw-rw-. 1 user user 0 Aug 24 00:14 myfile   ;# myfile has 0\nbytes\n\n```", "```\n$ script -t 2> timing.log -a output.session\n\n```", "```\n$ script -t 2> timing.log -a output.session\n\n# This is a demonstration of tclsh\n$ tclsh\n% puts [expr 2 + 2]\n4\n% exit\n$ exit\n\n```", "```\n$ scriptreplay timing.log output.session\n# Plays the sequence of commands and output\n\n```", "```\n$ find base_path\n\n```", "```\n$ find . -print\n.history\nDownloads\nDownloads/tcl.fossil\nDownloads/chapter2.doc\nâ€¦\n\n```", "```\n$> echo \"test\" > \"file name\"\n$> find . -type f -print | xargs ls -l\nls: cannot access ./file: No such file or directory\nls: cannot access name: No such file or directory\n$> find . -type f -print0 | xargs -0 ls -l\n-rw-rw-rw-. 1 user group 5  Aug 24 15:00 ./file name\n\n```", "```\n$ find /home/slynux -name '*.txt' -print\n\n```", "```\n$ ls\nexample.txt  EXAMPLE.txt  file.txt\n$ find . -iname \"example*\" -print\n./example.txt\n./EXAMPLE.txt\n\n```", "```\n$ ls\nnew.txt  some.jpg  text.pdf   stuff.png\n$ find . \\( -name '*.txt' -o -name '*.pdf' \\) -print\n./text.pdf\n./new.txt\n\n```", "```\n$ find . \\( -name '*e*' -and -name 's*' \\) \n./some.jpg\n\n```", "```\n$ ls\nnew.PY  next.jpg  test.py script.sh $ find . -regex '.*\\.(py\\|sh\\)$'\n./test.py\nscript.sh\n\n```", "```\n$ find . -iregex '.*\\(\\.py\\|\\.sh\\)$'\n./test.py\n./new.PY\n./script.sh\n\n```", "```\n$ find . ! -name \"*.txt\" -print\n\n```", "```\n$ ls\nlist.txt  new.PY  new.txt  next.jpg  test.py\n\n$ find . ! -name \"*.txt\" -print\n.\n./next.jpg\n./test.py\n./new.PY\n\n```", "```\n$ find -L /proc -maxdepth 3 -name 'bundlemaker.def' 2>/dev/null\n\n```", "```\n$ find . -mindepth 2 -name \"f*\" -print\n./dir1/dir2/file1\n./dir3/dir4/f2\n\n```", "```\n$ find . -type d -print\n\n```", "```\n$ find . -type f -print\n\n```", "```\n$ find . -type l -print\n\n```", "```\n        $ find . -type f -atime -7 -print\n\n```", "```\n        $ find . -type f -atime 7 -print\n\n```", "```\n        $ find . -type f -atime +7 -print\n\n```", "```\n$ find . -type f -amin +7 -print\n\n```", "```\n$ find . -type f -newer file.txt -print\n\n```", "```\n# Files having size greater than 2 kilobytes\n$ find . -type f -size +2k\n\n# Files having size less than 2 kilobytes\n$ find . -type f -size -2k\n\n# Files having size 2 kilobytes\n$ find . -type f -size 2k\n\n```", "```\n$ find . -type f -perm 644 -print\n# Print files having permission 644\n\n```", "```\n$ find . -type f -name \"*.php\" ! -perm 644 -print\nPHP/custom.php\n$ ls -l PHP/custom.php\n-rw-rw-rw-.  root   root   513 Mar 13  2016  PHP/custom.php\n\n```", "```\n$ find . -type f -user slynux -print\n\n```", "```\n$ find . -type f -name \"*.swp\" -delete\n\n```", "```\n# find . -type f -user root -exec chown slynux {} \\;\n\n```", "```\n$ find . -type f -name '*.c' -exec cat {} \\;>all_c_files.txt\n$ find . -type f -name '*.c' -exec cat {} > all_c_files.txt \\;\n$ fine . -type f -name '*.c' -exec cat {} >all_c_files.txt +\n\n```", "```\n$ find . -type f -mtime +10 -name \"*.txt\" -exec cp {} OLD  \\;\n\n```", "```\n-exec ./commands.sh {} \\;\n\n```", "```\n$ find . -type f -name \"*.txt\" -exec printf \"Text file: %s\\n\" {} \\;\nConfig file: /etc/openvpn/easy-rsa/openssl-1.0.0.cnf\nConfig file: /etc/my.cnf\n\n```", "```\n$ find devel/source_path  -name '.git' -prune -o -type f -print\n\n```", "```\n$ gcc `find '*.c'`\n\n```", "```\nls *.c | xargs grep main\n\n```", "```\n          $ cat example.txt # Example file\n 1 2 3 4 5 6 \n 7 8 9 10 \n 11 12\n\n $ cat example.txt | xargs\n 1 2 3 4 5 6 7 8 9 10 11 12\n\n```", "```\n          $ cat example.txt | xargs -n 3\n 1 2 3 \n 4 5 6 \n 7 8 9 \n 10 11 12\n\n```", "```\n$ echo \"split1Xsplit2Xsplit3Xsplit4\" | xargs -d X\nsplit1 split2 split3 split4\n\n```", "```\n$ echo \"splitXsplitXsplitXsplit\" | xargs -d X -n 2\nsplit split\nsplit split\n\n```", "```\n$ find /smbMount -iname '*.docx' -print0 | xargs -0 grep -L image\n\n```", "```\n#!/bin/bash \n#Filename: cecho.sh \n\necho $*'#'  \n\n```", "```\n    $ ./cecho.sh arg1 arg2\n arg1 arg2 #\n\n```", "```\n ./cecho.sh arg1 \n ./cecho.sh arg2 \n ./cecho.sh arg3 \n\n```", "```\n ./cecho.sh arg1 arg2 \n ./cecho.sh arg3 \n\n```", "```\n ./cecho.sh arg1 arg2 arg3 \n\n```", "```\n$ cat args.txt\narg1\narg2\narg3\n\n```", "```\n$ cat args.txt | xargs -n 1 ./cecho.sh\narg1 #\narg2 #\narg3 #\n\n```", "```\n$ cat args.txt | xargs -n 2 ./cecho.sh \narg1 arg2 #\narg3 #\n\n```", "```\n$ cat args.txt | xargs ./cecho.sh\narg1 arg2 arg3 #\n\n```", "```\n./cecho.sh -p arg1 -l\n\n```", "```\n./cecho.sh -p arg1 -l\n./cecho.sh -p arg2 -l\n./cecho.sh -p arg3 -l\n\n```", "```\n$ cat args.txt | xargs -I {} ./cecho.sh -p {} -l\n-p arg1 -l #\n-p arg2 -l #\n-p arg3 -l #\n\n```", "```\n$ find . -type f -name \"*.txt\"  -print | xargs rm -f \n\n```", "```\n$ find . -type f -name \"*.txt\" -print0 | xargs -0 rm -f\n\n```", "```\n$ find source_code_dir_path -type f -name \"*.c\" -print0 | xargs -0 wc -l \n\n```", "```\n$ cat files.txt  | ( while read arg; do cat $arg; done )\n# Equivalent to cat files.txt | xargs -I {} cat {}\n\n```", "```\n$ cmd0 | ( cmd1;cmd2;cmd3) | cmd4\n\n```", "```\nfind . -name '*.c' | xargs -I ^ sh -c \"echo -ne '\\n ^: '; grep main ^\"\n\n```", "```\ntr [options] set1 set2\n\n```", "```\n$ echo \"HELLO WHO IS THIS\" | tr 'A-Z' 'a-z'\nhello who is this\n\n```", "```\n$ echo 12345 | tr '0-9' '9876543210'\n87654 #Encrypted\n\n$ echo 87654 | tr '9876543210' '0-9'\n12345 #Decrypted\n\n```", "```\n$ echo \"tr came, tr saw, tr conquered.\" | tr 'a-zA-Z' 'n-za-mN-ZA-M'\n\n```", "```\nge pnzr, ge fnj, ge pbadhrerq.\n\n```", "```\n$ echo ge pnzr, ge fnj, ge pbadhrerq. | tr 'a-zA-Z' 'n-za-mN-ZA-M'\n\n```", "```\ntr came, tr saw, tr conquered.\n\n```", "```\n$ tr '\\t' ' ' < file.txt\n\n```", "```\n$ cat file.txt | tr -d  '[set1]'\n#Only set1 is used, not set2\n\n```", "```\n$ echo \"Hello 123 world 456\" | tr -d '0-9'\nHello world\n# Removes the numbers from stdin and print\n\n```", "```\ntr -c [set1] [set2]\n\n```", "```\n$ echo hello 1 char 2 next 4 | tr -d -c '0-9 \\n'\n124\n\n```", "```\n$ echo hello 1 char 2 next 4 | tr -c '0-9' ' '\n 1      2     4\n\n```", "```\ntr -s '[set of characters to be squeezed]' \n\n```", "```\n$ echo \"GNU is       not     UNIX.  Recursive   right ?\" | tr -s ' '\nGNU is not UNIX. Recursive right ?\n\n```", "```\n$ cat multi_blanks.txt | tr -s '\\n'\nline 1\nline 2\nline 3\nline 4\n\n```", "```\n$ cat sum.txt\n1\n2\n3\n4\n5\n\n$ cat sum.txt | echo $[ $(tr '\\n' '+' ) 0 ]\n15\n\n```", "```\necho $[ 1+2+3+4+5+0 ]\n\n```", "```\n$ cat test.txt\nfirst 1\nsecond 2\nthird 3\n\n```", "```\n$ cat test.txt | tr -d [a-z] | echo \"total: $[$(tr ' ' '+')]\"\ntotal: 6\n\n```", "```\ntr [:class:] [:class:]\n\n```", "```\ntr '[:lower:]' '[:upper:]'\n\n```", "```\n$ md5sum filename\n68b329da9893e34099c7d8ad5cb9c940 filename\n\n```", "```\n$ md5sum filename > file_sum.md5\n\n```", "```\n$ md5sum file1 file2 file3 ..\n\n```", "```\n[checksum1]   file1\n[checksum1]   file2\n[checksum1]   file3\n\n```", "```\n$ md5sum -c file_sum.md5\n# It will output a message whether checksum matches or not\n\n```", "```\n$ md5sum -c *.md5\n\n```", "```\n3f50877c05121f7fd8544bef2d722824 *ubuntu-16.10-desktop-amd64.iso\ne9e9a6c6b3c8c265788f4e726af25994 *ubuntu-16.10-desktop-i386.iso\n7d6de832aee348bacc894f0a2ab1170d *ubuntu-16.10-server-amd64.iso\ne532cfbc738876b353c7c9943d872606 *ubuntu-16.10-server-i386.iso\n\n```", "```\n$ md5deep -rl directory_path > directory.md5\n\n```", "```\n# `-r` to enable recursive traversal\n# `-l` to use relative path. By default it writes absolute file\npath in output\n\n```", "```\n$ find directory_path -type f -print0 | xargs -0 md5sum >> directory.md5\n\n```", "```\n$ md5sum -c directory.md5\n\n```", "```\n        $ md5sum file\n 8503063d5488c3080d4800ff50850dc9  file\n $ sha1sum file\n 1ba02b66e2e557fede8f61b7df282cd0a27b816b  file\n\n```", "```\n test:$6$fG4eWdUi$ohTKOlEUzNk77.4S8MrYe07NTRV4M3LrJnZP9p.qc1bR5c.\nEcOruzPXfEu1uloBFUa18ENRH7F70zhodas3cR.:14790:0:99999:7::: \n\n```", "```\n$ opensslpasswd -1 -salt SALT_STRING PASSWORD\n$1$SALT_STRING$323VkWkSLHuhbt1zkSsUG.\n\n```", "```\n        $ crypt <input_file >output_file\n Enter passphrase:\n\n```", "```\n        $ crypt PASSPHRASE <input_file >encrypted_file\n\n```", "```\n        $ crypt PASSPHRASE -d <encrypted_file >output_file\n\n```", "```\n          $ gpg -c filename\n\n```", "```\n          $ gpg filename.gpg\n\n```", "```\n        $ base64 filename > outputfile\n\n```", "```\n        $ cat file | base64 > outputfile\n\n```", "```\n        $ base64 -d file > outputfile\n\n```", "```\n        $ cat base64_file | base64 -d > outputfile\n\n```", "```\n        $ sort file1.txt file2.txt > sorted.txt\n\n```", "```\n        $ sort file1.txt file2.txt -o sorted.txt\n\n```", "```\n        $ sort -n file.txt\n\n```", "```\n        $ sort -r file.txt\n\n```", "```\n        $ sort -M months.txt\n\n```", "```\n        $ sort -m sorted1 sorted2\n\n```", "```\n        $ sort file1.txt file2.txt | uniq\n\n```", "```\n        #!/bin/bash \n        #Desc: Sort \n        sort -C filename ; \n        if [ $? -eq 0 ]; then \n           echo Sorted; \n        else \n           echo Unsorted; \n        fi \n\n```", "```\nif sort -c fileToCheck ; then echo sorted ; else echo unsorted ; fi\n\n```", "```\n$ cat data.txt\n1  mac    2000\n2  winxp    4000\n3  bsd    1000\n4  linux    1000\n\n```", "```\n# Sort reverse by column1\n$ sort -nrk 1  data.txt\n4  linux    1000 \n3  bsd    1000 \n2  winxp    4000 \n1  mac    2000 \n# -nr means numeric and reverse\n\n# Sort by column 2\n$ sort -k 2  data.txt\n3  bsd    1000 \n4  linux    1000 \n1  mac    2000 \n2  winxp    4000\n\n```", "```\n$ cat data.txt\n\n1 alpha 300\n2 beta 200\n3 gamma 100\n$ sort -bk 2.3,2.4 data.txt   ;# Sort m, p, t\n3 gamma 100\n1 alpha 300\n2 beta 200\n\n```", "```\n$ sort -nk 1,1 data.txt\n\n```", "```\n$ sort -z data.txt | xargs -0\n# Use zero terminator to make safe use with xargs\n\n```", "```\n$ sort -bd unsorted.txt\n\n```", "```\n$ cat sorted.txt\nbash \nfoss \nhack \nhack\n\n$ uniq sorted.txt\nbash \nfoss \nhack \n\n```", "```\n$ sort unsorted.txt | uniq\n\n```", "```\n$ uniq -u sorted.txt\nbash\nfoss\n\n```", "```\n$ sort unsorted.txt | uniq -u\n\n```", "```\n$ sort unsorted.txt | uniq -c\n 1 bash\n 1 foss\n 2 hack\n\n```", "```\n$ sort unsorted.txt  | uniq -d\nhack\n\n```", "```\n$ cat data.txt\nu:01:gnu \nd:04:linux \nu:01:bash \nu:01:hack\n\n```", "```\n$ sort data.txt | uniq -s 2 -w 2\nd:04:linux \nu:01:bash \n\n```", "```\n$ uniq -z file.txt\n\n```", "```\n$ uniq -z file.txt | xargs -0 rm\n\n```", "```\n        $ filename=`mktemp`\n $ echo $filename\n /tmp/tmp.8xvhkjF5fH\n\n```", "```\n        $ dirname=`mktemp -d`\n $ echo $dirname\n tmp.NI8xzW7VRX\n\n```", "```\n                $ tmpfile=`mktemp -u`\n $ echo $tmpfile\n /tmp/tmp.RsGmilRpcT\n\n```", "```\n                $mktemp test.XXX\n test.2tc\n\n```", "```\n$ split -b 10k data.file\n$ ls\ndata.file  xaa  xab  xac  xad  xae  xaf  xag  xah  xai  xaj\n\n```", "```\n$ split -b 10k data.file -d -a 4\n\n$ ls\ndata.file x0009  x0019  x0029  x0039  x0049  x0059  x0069  x0079\n\n```", "```\n$ split -b 10k data.file -d -a 4 split_file\n$ ls\ndata.file       split_file0002  split_file0005  split_file0008\nstrtok.c\nsplit_file0000  split_file0003  split_file0006  split_file0009\nsplit_file0001  split_file0004  split_file0007\n\n```", "```\n-l no_of_lines:\n # Split into files of 10 lines each.\n $ split -l 10 data.file \n\n```", "```\n$ cat server.log\nSERVER-1 \n[connection] 192.168.0.1 success \n[connection] 192.168.0.2 failed \n[disconnect] 192.168.0.3 pending \n[connection] 192.168.0.4 success \nSERVER-2 \n[connection] 192.168.0.1 failed \n[connection] 192.168.0.2 failed \n[disconnect] 192.168.0.3 success \n[connection] 192.168.0.4 failed \nSERVER-3 \n[connection] 192.168.0.1 pending \n[connection] 192.168.0.2 pending \n[disconnect] 192.168.0.3 pending \n[connection] 192.168.0.4 failed\n\n```", "```\n$ csplit server.log /SERVER/ -n 2 -s {*}  -f server -b \"%02d.log\"       $ rm server00.log \n$ ls\nserver01.log  server02.log  server03.log  server.log\n\n```", "```\nfile_jpg=\"sample.jpg\" \nname=${file_jpg%.*} \necho File name is: $name \n\n```", "```\nFile name is: sample\n\n```", "```\nextension=${file_jpg#*.} \necho Extension is: jpg \n\n```", "```\nExtension is: jpg\n\n```", "```\nVAR=hack.fun.book.txt\n\n```", "```\n$ echo ${VAR%.*}\n\n```", "```\n$ echo ${VAR%%.*}\n\n```", "```\nVAR=hack.fun.book.txt\n\n```", "```\n$ echo ${VAR#*.} \n\n```", "```\n$ echo ${VAR##*.}\n\n```", "```\n\n$ echo ${URL%.*} # Remove rightmost .*\nwww.google\n\n$ echo ${URL%%.*} # Remove right to leftmost  .* (Greedy operator)\nwww\n\n$ echo ${URL#*.} # Remove leftmost  part before *.\ngoogle.com\n\n$ echo ${URL##*.} # Remove left to rightmost  part before *.\n(Greedy operator) com\n\n```", "```\n#!/bin/bash \n#Filename: rename.sh \n#Desc: Rename jpg and png files \n\ncount=1; \nfor img in `find . -iname '*.png' -o -iname '*.jpg' -type f -maxdepth 1` \ndo \n  new=image-$count.${img##*.} \n\n  echo \"Renaming $img to $new\" \n  mv \"$img\" \"$new\" \n  let count++ \n\ndone  \n\n```", "```\n$ ./rename.sh\nRenaming hack.jpg to image-1.jpg\nRenaming new.jpg to image-2.jpg\nRenaming next.png to image-3.png\n\n```", "```\n        $ rename *.JPG *.jpg\n\n```", "```\n        $ rename 's/ /_/g' *\n\n```", "```\n        $ rename 'y/A-Z/a-z/' *\n $ rename 'y/a-z/A-Z/' *\n\n```", "```\n        $ find path -type f -name \"*.mp3\" -exec mv {} target_dir \\;\n\n```", "```\n        $ find path -type f -exec rename 's/ /_/g' {} \\;\n\n```", "```\n$ ls /usr/share/dict/ \namerican-english  british-english\n\n```", "```\n#!/bin/bash \n#Filename: checkword.sh \nword=$1 \ngrep \"^$1$\" /usr/share/dict/british-english -q  \nif [ $? -eq 0 ]; then \n  echo $word is a dictionary word; \nelse \n  echo $word is not a dictionary word; \nfi \n\n```", "```\n$ ./checkword.sh ful \nful is not a dictionary word \n\n$ ./checkword.sh fool \nfool is a dictionary word\n\n```", "```\n#!/bin/bash  \n#Filename: aspellcheck.sh \nword=$1  \n\noutput=`echo \\\"$word\\\" | aspell list`  \n\nif [ -z $output ]; then  \n        echo $word is a dictionary word;  \nelse  \n        echo $word is not a dictionary word;  \nfi  \n\n```", "```\n$ look word\n\n```", "```\n$ grep \"^word\" filepath\n\n```", "```\n$ look android\nandroid\nandroid's\nandroids\n\n```", "```\n$look 'Aug 30' /var/log/syslog\n\n```", "```\n$ backupWork.sh\n\n```", "```\nnotes[Return]docx[Return] \n\n```", "```\n    \"notes\\ndocx\\n\"\n\n```", "```\n#!/bin/bash \n# backup.sh \n# Backup files with suffix. Do not backup temp files that start with ~ \nread -p \" What folder should be backed up: \" folder \nread -p \" What type of files should be backed up: \" suffix \nfind $folder -name \"*.$suffix\" -a ! -name '~*' -exec cp {} \\   \n    $BACKUP/$LOGNAME/$folder \necho \"Backed up files from $folder to $BACKUP/$LOGNAME/$folder\" \n\n```", "```\n$ echo -e \"notes\\ndocx\\n\" | ./backup.sh \nBacked up files from notes to /BackupDrive/MyName/notes\n\n```", "```\n$ echo -e \"notes\\ndocx\\n\"  > input.data\n$ cat input.data\nnotes\ndocx\n\n```", "```\n$ ./interactive.sh < input.data\n\n```", "```\necho -e \\xeb\\x1a\\x5e\\x31\\xc0\\x88\\x46\"\n\n```", "```\n#!/usr/bin/expect  \n#Filename: automate_expect.tcl \nspawn ./backup .sh  \nexpect { \n  \"*folder*\" { \n     send \"notes\\n\" \n     exp_continue \n   } \n  \"*type*\" { \n     send \"docx\\n\" \n     exp_continue \n  } \n} \n\n```", "```\n$ ./automate_expect.tcl \n\n```", "```\n#/bin/bash \n#filename: generate_checksums.sh \nPIDARRAY=() \nfor file in File1.iso File2.iso \ndo \n  md5sum $file & \n  PIDARRAY+=(\"$!\") \ndone \nwait ${PIDARRAY[@]} \n\n```", "```\n$ ./generate_checksums.sh \n330dcb53f253acdf76431cecca0fefe7  File1.iso\nbd1694a6fe6df12c3b8141dcffaf06e6  File2.iso\n\n```", "```\nmd5sum File1.iso File2.iso\n\n```", "```\nls *jpg | parallel convert {} -geometry 50x50 {.}Small.jpg\n\n```", "```\n$ cd /var/log\n$ find . -exec sh -c 'echo -n {} | tr -d \"[:alnum:]_.\\-\" | \\\n    tr \"/\" \" \"; basename {}' \\;\n\n```", "```\nmail\n statistics\ngdm\n ::0.log\n ::0.log.1\ncups\n error_log\n access_log\n ... access_l\n\n```", "```\nfor d in `find . -type d`;  \n  do  \n  echo `find $d -type f | wc -l` files in $d;  \ndone \n\n```", "```\n103 files in .\n17 files in ./cups\n0 files in ./hp\n0 files in ./hp/tmp\n\n```"]