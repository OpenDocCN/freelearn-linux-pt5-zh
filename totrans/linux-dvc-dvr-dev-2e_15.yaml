- en: '*Chapter 12*: Abstracting Memory Access – Introduction to the Regmap API: a
    Register Map Abstraction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 12 章*：抽象内存访问 – Regmap API 简介：寄存器映射抽象'
- en: Before the Regmap API was developed, there was redundant code for the device
    drivers dealing with SPI, I2C, or memory-mapped devices. Many of these drivers
    contained some very similar code for accessing hardware device registers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Regmap API 之前，处理 SPI、I2C 或内存映射设备的设备驱动程序存在冗余代码。这些驱动程序中有很多非常相似的代码用于访问硬件设备寄存器。
- en: 'The following figure shows how SPI, I2C, and memory-mapped related APIs were
    used standalone before Regmap was introduced:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了在引入 Regmap 之前，SPI、I2C 和内存映射相关的 API 如何单独使用：
- en: '![Figure 12.1 – I2C, SPI, and memory-mapped access before Regmap'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.1 – Regmap 引入前的 I2C、SPI 和内存映射访问'
- en: '](img/B17934_12_001.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_12_001.jpg)'
- en: Figure 12.1 – I2C, SPI, and memory-mapped access before Regmap
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – Regmap 引入前的 I2C、SPI 和内存映射访问
- en: The Regmap API was introduced in version v3.1 of the Linux kernel and proposes
    a solution that factors out and unifies these similar register access codes, saving
    code and making it much easier to share infrastructure. It is then just a matter
    of how to initialize and to configure a `regmap` structure, and process any read/write/modify
    operations fluently, whether it is SPI, I2C, or memory-mapped.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap API 于 Linux 内核的 v3.1 版本中引入，提出了一个解决方案，将这些相似的寄存器访问代码进行抽象并统一，节省了代码量，并使基础设施共享变得更加容易。接下来，便是如何初始化和配置
    `regmap` 结构，并流畅地处理任何读写/修改操作，无论是 SPI、I2C 还是内存映射。
- en: 'The following diagram depicts this API unification:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示描述了此 API 的统一化：
- en: '![Figure 12.2 - I2C, SPI, and memory-mapped access after Regmap'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.2 – Regmap 引入后的 I2C、SPI 和内存映射访问'
- en: '](img/B17934_12_002.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_12_002.jpg)'
- en: Figure 12.2 - I2C, SPI, and memory-mapped access after Regmap
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Regmap 引入后的 I2C、SPI 和内存映射访问
- en: The previous figure shows how Regmap unified transactions between devices and
    their respective bus frameworks. In this chapter, we will cover as much as possible
    of the whole aspect of the APIs this framework offers, from initialization to
    complex use cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了 Regmap 如何统一设备与各自总线框架之间的事务。在本章中，我们将尽可能涵盖该框架提供的 API 的各个方面，从初始化到复杂的使用场景。
- en: 'This chapter will walk through the Regmap framework via the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过以下主题详细讲解 Regmap 框架：
- en: Introduction to the Regmap data structures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regmap 数据结构简介
- en: Handling Regmap initialization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Regmap 初始化
- en: Using Regmap register access functions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Regmap 寄存器访问函数
- en: Regmap-based SPI driver example – putting it all together
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 Regmap 的 SPI 驱动示例 – 整合所有内容
- en: Leveraging Regmap from the userspace
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户空间利用 Regmap
- en: Introduction to the Regmap data structures
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Regmap 数据结构简介
- en: 'The Regmap framework, which is enabled via the `CONFIG_REGMAP` kernel configuration
    option, is made of a few data structures, among which the most important are `struct
    regmap_config`, which represents the Regmap configuration, and `struct regmap`,
    which is the Regmap instance itself. That said, all of the Regmap data structures
    are defined in `include/linux/regmap.h`. It then goes without saying that this
    header must be included in all Regmap-based drivers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap 框架通过 `CONFIG_REGMAP` 内核配置选项启用，由几个数据结构组成，其中最重要的是 `struct regmap_config`，它表示
    Regmap 配置，和 `struct regmap`，它是 Regmap 实例本身。也就是说，所有 Regmap 数据结构都定义在 `include/linux/regmap.h`
    中。因此，这个头文件必须在所有基于 Regmap 的驱动程序中包含：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Including the preceding header is sufficient to make the most out of the Regmap
    framework. With this header, a lot of data structures will be made available,
    among which, `struct regmap_config` is the most important, which we will describe
    in the next section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 包含前述头文件足以充分利用 Regmap 框架。通过此头文件，许多数据结构将变得可用，其中 `struct regmap_config` 是最重要的，我们将在下一节中详细描述。
- en: Understanding the struct regmap_config structure
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `struct regmap_config` 结构体
- en: '`struct regmap_config` stores the configuration of the register map during
    the driver''s lifetime. What you set there affects the memory read/write operations.
    This is the most important structure, which is defined as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct regmap_config` 存储驱动生命周期内寄存器映射的配置。你在此设置的内容会影响内存的读写操作。这是最重要的结构，定义如下：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don''t be afraid of how big this structure is. All the elements are self-explanatory.
    However, for more clarity, let''s expand on their meanings here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心这个结构有多复杂，所有元素都是自解释的。然而，为了更清晰，下面将详细说明它们的含义：
- en: '`reg_bits` is a mandatory field, which is the number of valid bits in a register''s
    address. This is the size in bits of register addresses.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_bits` 是一个必填字段，它是寄存器地址中有效位的数量。这是寄存器地址的位大小。'
- en: '`reg_stride` represents a value that valid register addresses must be a multiple
    of. If set to `0`, a value of `1` will be used. If set to `4`, for example, an
    address will be considered valid only if this address is a multiple of `4`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_stride` 表示有效寄存器地址必须是该值的倍数。如果设置为 `0`，则使用 `1` 作为默认值。如果设置为 `4`，例如，只有当地址是
    `4` 的倍数时，该地址才被认为是有效的。'
- en: '`pad_bits` is the number of bits of padding between the register and value.
    This is the number of bits to (left) shift the register value when formatting.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pad_bits` 是寄存器和数值之间的填充位数。这是格式化时需要（左）移位寄存器值的位数。'
- en: '`val_bits` represents the number of bits used to store a register''s value.
    It is a mandatory field.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val_bits` 表示用于存储寄存器值的位数。它是一个必填字段。'
- en: '`writeable_reg` is an optional callback function. If provided, it is used by
    the Regmap subsystem when a register needs to be written. Before writing into
    a register, this function is automatically called to check whether the register
    can be written to or not. The following is an example of using such a function:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeable_reg` 是一个可选的回调函数。如果提供，它将在需要写寄存器时由 Regmap 子系统使用。在写入寄存器之前，系统会自动调用此函数检查该寄存器是否可以写入。以下是使用该函数的示例：'
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`readable_reg` is the same as `writeable_reg` but for all register read operations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readable_reg` 与 `writeable_reg` 相同，但用于所有寄存器读操作。'
- en: '`volatile_reg` is an optional callback function called every time a register
    needs to be read or written through the Regmap cache. If the register is volatile,
    the function should return true. A direct read/write is then performed on the
    register. If false is returned, it means the register is cacheable. In this case,
    the cache will be used for a read operation, and the cache will be written in
    the case of a write operation:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile_reg` 是一个可选的回调函数，每次需要通过 Regmap 缓存读写寄存器时都会调用。如果寄存器是易失性的，该函数应返回 true。然后将直接对寄存器进行读写。如果返回
    false，则表示寄存器是可缓存的。在这种情况下，读取操作将使用缓存，写入操作时缓存将被写入：'
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`precious_reg`: Some devices are sensitive to reads on some of their registers,
    especially for things such as clear on read interrupt status registers. With this
    set, this optional callback must return true if the specified register falls in
    this case, which will present the core (`debugfs`, for example) from internally
    generating any reads of it. This way, only explicit reads by the driver will be
    allowed.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precious_reg`: 一些设备对其某些寄存器的读取很敏感，特别是像清除读中断状态寄存器这样的寄存器。设置此项后，如果指定寄存器属于此类，必须返回
    true，防止核心（例如 `debugfs`）内部生成任何读取操作。这样，只有驱动程序显式读取时才允许操作。'
- en: '`disable_locking` tells whether the following lock/unlock callbacks should
    be used or not. If false, it means not to use any locking mechanisms. It means
    this `regmap` object is either protected by external means or is guaranteed not
    to be accessed from multiple threads.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable_locking` 表示是否应使用以下锁定/解锁回调。如果为 false，则表示不使用任何锁定机制。意味着该 `regmap` 对象要么由外部方式保护，要么保证不会被多个线程访问。'
- en: '`lock`/`unlock` are optional lock/unlock callbacks, overriding default lock/unlock
    functions of `regmap`, based on spinlock or mutex, depending on whether accessing
    the underlying device may put the caller to sleep or not.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`/`unlock` 是可选的锁定/解锁回调函数，覆盖 `regmap` 的默认锁定/解锁函数，基于自旋锁或互斥锁，具体取决于访问底层设备是否会使调用者进入休眠状态。'
- en: '`lock_arg` will be used as the only argument of lock/unlock functions (ignored
    if regular lock/unlock functions are not overridden).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock_arg` 将作为锁定/解锁函数的唯一参数（如果未重写常规锁定/解锁函数，则忽略）。'
- en: '`reg_read`: Your device may not support simple I2C/SPI read operations. You''ll
    then have no choice but to write your own customized read function. `reg_read`
    should then point to that function. That said, most devices do not need that.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_read`: 您的设备可能不支持简单的 I2C/SPI 读操作。您将不得不编写自己的定制读函数。`reg_read` 应指向该函数。也就是说，大多数设备并不需要这样做。'
- en: '`reg_write` is the same as `reg_read` but for write operations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_write` 与 `reg_read` 相同，但用于写操作。'
- en: '`fast_io` indicates that the register IO is fast. If set, the `regmap` will
    use a spinlock instead of a mutex to perform locking. This field is ignored if
    custom lock/unlock (not discussed here) functions are used (see the fields `lock`/`unlock`
    of `struct regmap_config` in the kernel sources). It should be used only for "nobus"
    cases (MMIO devices), since accessing I2C, SPI, or similar buses may put the caller
    to sleep.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fast_io`表示寄存器IO是快速的。如果设置该项，`regmap`将使用自旋锁而不是互斥锁来执行锁定操作。如果使用了自定义的锁/解锁函数（此处不讨论），则该字段将被忽略（请参阅内核源码中`struct
    regmap_config`的`lock`/`unlock`字段）。它应该仅用于“无总线”情况（MMIO设备），因为访问I2C、SPI或类似总线可能会导致调用者被挂起。'
- en: '`max_register`: This optional element specifies the maximum valid register
    address above which no operation is permitted.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_register`：这个可选元素指定了最大有效寄存器地址，超过该地址将不允许进行任何操作。'
- en: '`wr_table`: Instead of providing a `writeable_reg` callback, you could provide
    a `regmap_access_table` object, which is a structure holding a `yes_ranges` and
    a `no_range` field, both pointers to `struct regmap_range`. Any register that
    belongs to a `yes_range` entry is considered as writeable and is considered as
    not writeable if belonging to `no_range`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wr_table`：你可以提供一个`regmap_access_table`对象，代替`writeable_reg`回调。该对象是一个结构体，包含`yes_ranges`和`no_range`字段，均为指向`struct
    regmap_range`的指针。任何属于`yes_range`条目的寄存器都被视为可写，而属于`no_range`条目的寄存器则被视为不可写。'
- en: '`rd_table` is the same as `wr_table`, but for any read operation.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rd_table`与`wr_table`相同，但适用于任何读取操作。'
- en: '`volatile_table`: Instead of `volatile_reg`, you could provide `volatile_table`.
    The principle is then the same as `wr_table` or `rd_table`, but for caching mechanisms.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile_table`：你可以提供`volatile_table`代替`volatile_reg`。其原理与`wr_table`或`rd_table`相同，但适用于缓存机制。'
- en: '`precious_table`: As above, for precious registers.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`precious_table`：与上述类似，适用于珍贵寄存器。'
- en: '`reg_defaults` is an array of elements of type `reg_default`, where each `reg_default`
    element is a `{reg, value}` structure that represents power-on reset values for
    a register. This is used with the cache so that a read of an address that exists
    in this array, and that has not been written since power-on reset, will return
    the default register value in this array without performing any read transactions
    on the device. An example of this is the IIO device driver, whose link is the
    following: [https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c](https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_defaults`是`reg_default`类型元素的数组，每个`reg_default`元素是一个`{reg, value}`结构，表示寄存器的上电复位值。与缓存一起使用，以便对该数组中存在的地址进行读取，并且自上电复位后未进行写操作时，将返回该数组中的默认寄存器值，而无需执行任何设备读取事务。一个例子是IIO设备驱动程序，链接如下：[https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c](https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c)。'
- en: '`num_reg_defaults` is the number of elements in `reg_defaults`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_reg_defaults`是`reg_defaults`中元素的数量。'
- en: '`cache_type`: The actual cache type, which can be either `REGCACHE_NONE`, `REGCACHE_RBTREE`,
    `REGCACHE_COMPRESSED`, or `REGCACHE_FLAT`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_type`：实际的缓存类型，可以是`REGCACHE_NONE`、`REGCACHE_RBTREE`、`REGCACHE_COMPRESSED`或`REGCACHE_FLAT`。'
- en: '`read_flag_mask`: This is the mask to be applied in the top bytes of the register
    when doing a read. Normally, the highest bit in the top byte of a write or read
    operation in SPI or I2C is set to differentiate write and read operations.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_flag_mask`：这是读取操作时需要应用于寄存器高字节中的掩码。通常，SPI或I2C中的写或读操作的高字节中的最高位被设置，以区分写操作和读操作。'
- en: '`write_flag_mask`: The mask to be set in the top bytes of the register when
    doing a write.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_flag_mask`：写操作时需要在寄存器的高字节中设置的掩码。'
- en: '`use_single_rw` is a Boolean that, if set, will instruct the register map to
    convert any bulk write or read operation on the device into a series of single
    write or read operations. This is useful for devices that do not support bulk
    read or write, or either.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_single_rw`是一个布尔值，如果设置该项，将指示寄存器映射将设备上的任何批量写入或读取操作转换为一系列单次写入或读取操作。这对于不支持批量读写的设备非常有用。'
- en: '`can_multi_write` only targets write operations. If set, it indicates that
    this device supports the multi-write mode of bulk write operations. If clear,
    multi-write requests will be split into individual write operations.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`can_multi_write`仅针对写操作。如果设置该项，表示该设备支持批量写操作的多重写模式。如果未设置，则多重写请求将被拆分为单独的写操作。'
- en: 'You should look at `include/linux/regmap.h` for more details on each element.
    The following is an example of the initialization of `regmap_config`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看`include/linux/regmap.h`获取每个元素的更多详细信息。以下是`regmap_config`初始化的示例：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding example shows how to build a basic register map configuration.
    Though only a few elements are set in the configuration data structure, enhanced
    configuration can be set up by learning about each element that we have described.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何构建一个基本的寄存器映射配置。尽管配置数据结构中只设置了少数几个元素，但通过学习我们描述的每个元素，可以设置更高级的配置。
- en: Now that we have learned about Regmap configuration, let's see how to use this
    configuration with the initialization API that corresponds to our needs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Regmap 配置，接下来我们来看看如何使用这个配置与初始化 API 进行配合，满足我们的需求。
- en: Handling Regmap initialization
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Regmap 初始化
- en: As we said earlier, the Regmap API supports SPI, I2C, and memory-mapped register
    access. Their respective support can be enabled in the kernel thanks to the `CONFIG_REGMAP_SPI`,
    `CONFIG_REGMAP_I2C`, and `CONFIG_REGMAP_MMIO` kernel configuration options. It
    can go far beyond that and managing IRQs as well, but this is out of the scope
    of this book. Depending on the memory access method you need to support in the
    driver, you will have to call either `devm_regmap_init_i2c()`, `devm_regmap_init_spi()`,
    or `devm_ regmap_init_mmio()` in the probe function. To write generic drivers,
    Regmap is the best choice you can make.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Regmap API 支持 SPI、I2C 和内存映射寄存器访问。通过`CONFIG_REGMAP_SPI`、`CONFIG_REGMAP_I2C`和`CONFIG_REGMAP_MMIO`内核配置选项，可以在内核中启用它们各自的支持。它的功能远不止于此，还可以管理
    IRQ，但这超出了本书的范围。根据驱动程序需要支持的内存访问方式，你需要在探测函数中调用`devm_regmap_init_i2c()`、`devm_regmap_init_spi()`或`devm_regmap_init_mmio()`之一。要编写通用驱动程序，Regmap
    是你可以做出的最佳选择。
- en: 'The Regmap API is generic and homogenous, and initialization only changes between
    bus types. Other functions are the same. It is a good practice to always initialize
    the register map in the probe function, and you must always fill the `regmap_config`
    elements prior to initializing the register map using one of the following APIs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap API 是通用且一致的，初始化只在总线类型之间有所不同。其他函数是相同的。一个好的实践是总是在探测函数中初始化寄存器映射，并且在使用以下
    API 初始化寄存器映射之前，必须始终填写`regmap_config`元素：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These are resource-managed APIs whose allocated resources are automatically
    freed when the device leaves the system or when the driver is unloaded. In the
    preceding prototypes, the return value will be a pointer to a valid `struct regmap`
    object or an `ERR_PTR()` error on failure. `regs` is a pointer to a memory-mapped
    IO region (returned by `devm_ioremap_resource()` or any `ioremap*` family function).
    `dev` is the device (`struct device`) to interact with in the case of a memory-mapped
    `regmap`, and `spi` and `i2c` are respectively SPI or I2C devices to interact
    with in the case of SPI- or I2C-based `regmap`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是资源管理的 API，其分配的资源会在设备离开系统或驱动程序卸载时自动释放。在前面的原型中，返回值将是指向有效的`struct regmap`对象的指针，或者在失败时返回`ERR_PTR()`错误。`regs`是指向内存映射
    IO 区域的指针（由`devm_ioremap_resource()`或任何`ioremap*`系列函数返回）。`dev`是要与之交互的设备（`struct
    device`），在内存映射的`regmap`的情况下，`spi`和`i2c`分别是要与之交互的 SPI 或 I2C 设备，在 SPI 或 I2C 类型的`regmap`中。
- en: 'Calling one of these functions is sufficient to start interacting with the
    underlying device. Whether the Regmap is an I2C, SPI, or a memory-mapped register
    map, if it has not been initialized with a resource managed API variant, it must
    be freed with the `regmap_exit()` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用其中一个函数即可开始与底层设备交互。无论 Regmap 是 I2C、SPI 还是内存映射寄存器映射，如果它没有通过资源管理的 API 变体进行初始化，则必须使用`regmap_exit()`函数来释放它：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This function simply releases a previously allocated register map.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数简单地释放先前分配的寄存器映射。
- en: Now that the register access method has been defined, we can jump to the device
    access functions, which allow reading from or writing into device registers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在寄存器访问方法已经定义，我们可以跳转到设备访问函数，这些函数允许从设备寄存器中读取或写入数据。
- en: Using Regmap register access functions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Regmap 寄存器访问函数
- en: 'Remap register access methods handle data parsing, formatting, and transmission.
    In most cases, device accesses are performed with `regmap_read()`, `regmap_write()`,
    and `regmap_update_bits()`, which are the three important APIs when it comes to
    writing/reading data into/from the device. Their respective prototypes are the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重映射寄存器访问方法处理数据解析、格式化和传输。在大多数情况下，设备访问是通过`regmap_read()`、`regmap_write()`和`regmap_update_bits()`来执行的，这三个函数是进行设备数据读写时的重要
    API。它们各自的原型如下：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`regmap_write()` writes data to the device. If set in `regmap_config`, `max_register`
    will be used to check whether the register address that needs to be accessed is
    greater or lower. If the register address passed is lower or equal to `max_register`,
    then the next operation will be performed; otherwise, the Regmap core will return
    an invalid I/O error (`-EIO`). Right after, the `writeable_reg` callback is called.
    The callback must return true before going to the next step. If it returns false,
    then `-EIO` is returned, and the write operation is stopped. If `wr_table` is
    set instead of `writeable_reg`, then the following happens:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`regmap_write()` 向设备写入数据。如果在 `regmap_config` 中设置了 `max_register`，则会使用它来检查需要访问的寄存器地址是否超出范围。如果传递的寄存器地址小于或等于
    `max_register`，则执行下一步操作；否则，Regmap 核心会返回无效的 I/O 错误（`-EIO`）。紧接着，调用 `writeable_reg`
    回调函数。回调函数必须返回 true 才能进入下一步。如果返回 false，则返回 `-EIO`，并停止写操作。如果设置了 `wr_table` 而不是 `writeable_reg`，则会发生以下情况：'
- en: If the register address lies in `no_ranges`, then `-EIO` is returned.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寄存器地址位于 `no_ranges` 中，则返回 `-EIO`。
- en: If the register address lies in `yes_ranges`, the next step is performed.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寄存器地址位于 `yes_ranges` 中，则执行下一步操作。
- en: If the register address is not present in `yes_range` or `no_range`, then `-EIO`
    is returned, and the operation is terminated.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寄存器地址不在 `yes_range` 或 `no_range` 中，则返回 `-EIO`，并终止操作。
- en: If `cache_type != REGCACHE_NONE`, then caching is enabled. In this case, the
    cache entry is first updated with the new value, and then a write to the hardware
    is performed. Otherwise, no caching action is performed. If the `reg_write` callback
    is provided, it is used to perform the write operation. Otherwise, the generic
    Regmap's write function will be executed to write the data into the specified
    register address.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cache_type != REGCACHE_NONE`，则启用缓存。在这种情况下，首先会使用新值更新缓存项，然后再执行硬件写入。否则，不执行缓存操作。如果提供了
    `reg_write` 回调函数，则使用它来执行写操作。否则，将执行通用的 Regmap 写入功能，将数据写入指定的寄存器地址。
- en: '`regmap_read()` reads data from the device. It works exactly like `regmap_write()`
    with appropriate data structures (`readable_reg` and `rd_table`). Therefore, if
    provided, `reg_read` is used to perform the read operation; otherwise, the generic
    register map read function will be performed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`regmap_read()` 从设备中读取数据。它与 `regmap_write()` 的工作方式完全相同，使用了适当的数据结构（`readable_reg`
    和 `rd_table`）。因此，如果提供了 `reg_read`，则使用它来执行读取操作；否则，将执行通用的寄存器映射读取功能。'
- en: '`regmap_update_bits()` is a three-in-one function. It performs a read/modify/write
    cycle on the specified register address. It is a wrapper on `_regmap_update_bits`,
    which looks like the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`regmap_update_bits()` 是一个三合一函数。它执行指定寄存器地址的读/修改/写周期。它是 `_regmap_update_bits`
    的包装器，代码如下：'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This way, the bits you need to update must be set to `1` in `mask`, and corresponding
    bits should be set to the value you need to give to them in `val`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你需要更新的位必须在 `mask` 中设置为 `1`，并且相应的位应设置为你需要赋予它们的值 `val`。
- en: As an example, to set the first and third bits to `1`, `mask` should be `0b00000101`,
    and the value should be `0bxxxxx1x1`. To clear the seventh bit, `mask` must be
    `0b01000000` and the value should be `0bx0xxxxxx`, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，若要将第一位和第三位设置为 `1`，则 `mask` 应该是 `0b00000101`，值应为 `0bxxxxx1x1`。若要清除第七位，`mask`
    必须是 `0b01000000`，值应为 `0bx0xxxxxx`，依此类推。
- en: Bulk and multiple registers reading/writing APIs
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量和多个寄存器读/写的 API
- en: '`regmap_multi_reg_write()` is one of the APIs that allows you to write multiple
    registers to the device. Its prototype looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`regmap_multi_reg_write()` 是允许你向设备写入多个寄存器的 API 之一。它的原型如下：'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this prototype, `regs` is an array of elements of type `reg_sequence`, which
    represents register/value pairs for sequences of writes with an optional delay
    in microseconds to be applied after each write. The following is the definition
    of this data structure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个原型中，`regs` 是一个 `reg_sequence` 类型元素的数组，表示带有可选延迟（单位为微秒）的寄存器/值对的写入序列，延迟应用于每次写入之后。以下是该数据结构的定义：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding data structure, `reg` is the register address, `def` is the
    register value, and `delay_us` is the delay to be applied after the register write
    in microseconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，`reg` 是寄存器地址，`def` 是寄存器值，`delay_us` 是在寄存器写入后应用的延迟，单位为微秒。
- en: 'The following is a usage of such a sequence:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此类序列的一个用法：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding, we have learned how to use our first multi-register write
    API, which takes a set of registers along with their values.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内容中，我们学习了如何使用第一个多寄存器写入API，该API接收一组寄存器及其对应的值。
- en: 'There are also `regmap_bulk_read()` and `regmap_bulk_write()`, which can be
    used to read/write multiple registers from/to the device. Their usage fits for
    large blocks of data and they are defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`regmap_bulk_read()`和`regmap_bulk_write()`，可以用于从设备读取/写入多个寄存器。它们适用于大块数据，并定义如下：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the parameters in the preceding functions, `map` is the register map to operate
    on and `reg` is the register address from where the read/write operation must
    start. In the case of the read, `val` will contain the read value; it must be
    allocated to store at least the `count` value in the native register size for
    the device. In the case of the write operation, `val` must point to the data array
    to write to the device. Finally, `count` is the number of elements in `val`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面函数的参数中，`map`是要操作的寄存器映射，`reg`是读取/写入操作开始的寄存器地址。在读取的情况下，`val`将包含读取的值；它必须被分配足够的空间来存储至少与设备本地寄存器大小相等的`count`值。在写入操作的情况下，`val`必须指向要写入设备的数据数组。最后，`count`是`val`中的元素数量。
- en: Understanding the Regmap caching system
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Regmap缓存系统
- en: 'Obviously, Regmap supports data caching. Whether the cache system is used or
    not depends on the value of the `cache_type` field in `regmap_config`. Looking
    at `include/linux/regmap.h`, accepted values are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Regmap支持数据缓存。是否使用缓存系统取决于`regmap_config`中`cache_type`字段的值。在查看`include/linux/regmap.h`时，接受的值如下：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The cache type is set to `REGCACHE_NONE` by default, meaning that the cache
    is disabled. Other values simply define how the cache should be stored.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存类型默认为`REGCACHE_NONE`，意味着缓存被禁用。其他值仅定义了缓存应该如何存储。
- en: 'Your device may have a predefined power-on reset value in certain registers.
    Those values can be stored in an array so that any read operation returns the
    value contained in the array. However, any write operation affects the real register
    in the device and updates the content in the array. It is a kind of a cache that
    we can use to speed up access to the device. That array is `reg_defaults`. Looking
    at the source, its structure looks like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你的设备可能在某些寄存器中有预定义的上电复位值。这些值可以存储在数组中，以便任何读取操作都返回数组中包含的值。然而，任何写入操作都会影响设备中的实际寄存器，并更新数组中的内容。这是一种我们可以用来加速设备访问的缓存。这个数组就是`reg_defaults`。查看源代码，其结构如下：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding data structure, `reg` is the register address and `def` is
    the register default value. `reg_defaults` is ignored if `cache_type` is set to
    none. If the `default_reg` element is not set but you still enable the cache,
    the corresponding cache structure will be created for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，`reg`是寄存器地址，`def`是寄存器的默认值。如果`cache_type`设置为none，则会忽略`reg_defaults`。如果没有设置`default_reg`元素，但仍启用了缓存，相应的缓存结构将为你创建。
- en: 'It is quite simple to use. Just declare it and pass it as a parameter to the
    `regmap_config` structure. Let''s have a look at the LTC3589 regulator driver
    in `drivers/regulator/ltc3589.c`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用起来非常简单。只需声明它，并将其作为参数传递给`regmap_config`结构体。让我们看一下`drivers/regulator/ltc3589.c`中的LTC3589调节器驱动程序：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Any read operation on any one of the registers present in the array will immediately
    return the value in the array. However, a write operation will be performed on
    the device itself and will update the affected register in the array. This way,
    reading the `LTC3589_VRRCR` register will return `0xff` and write any value in
    that register, and it will update its entry in the array so that any new read
    operation will return the last written value directly from the cache.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组中任何一个寄存器进行读取操作时，将立即返回数组中的值。然而，写入操作会在设备本身上执行，并更新数组中受影响的寄存器。这样，读取`LTC3589_VRRCR`寄存器将返回`0xff`，并且向该寄存器写入任何值时，它会更新该寄存器在数组中的条目，以便任何新的读取操作都能直接从缓存中返回上次写入的值。
- en: Now that we are able to use the Regmap APIs to access the device registers whatever
    the underlying bus is these devices sit on, the time has come for us to summarize
    the knowledge we have learned so far in a practical example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够使用Regmap API来访问设备寄存器，无论这些设备依赖于哪种底层总线，接下来是总结我们到目前为止所学到的知识，并通过一个实际的示例来展示。
- en: Regmap-based SPI driver example – putting it all together
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Regmap的SPI驱动示例——将其整合在一起
- en: 'All the steps involved in setting up Regmap, from configuration to device register
    access, can be enumerated as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Regmap 所涉及的所有步骤，从配置到设备寄存器访问，可以列举如下：
- en: Setting up a `struct regmap_config` object according to the device characteristics.
    Defining the register range if needed, default values if any, `cache_type` if
    needed, and so on. If custom read/write functions are needed, pass them to the
    `reg_read`/`reg_write` fields.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据设备的特性设置 `struct regmap_config` 对象。如果需要，可以定义寄存器范围、默认值、`cache_type` 等。如果需要自定义读/写函数，将其传递给
    `reg_read`/`reg_write` 字段。
- en: In the `probe` function, allocating a register map using `devm_regmap_init_i2c()`,
    `devm_regmap_init_spi()`, or `devm_regmap_init_mmio()` depending on the connection
    with the underlying device – I2C, SPI, or memory-mapped.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `probe` 函数中，根据与底层设备的连接类型（I2C、SPI 或内存映射）使用 `devm_regmap_init_i2c()`、`devm_regmap_init_spi()`
    或 `devm_regmap_init_mmio()` 分配寄存器映射。
- en: Whenever you need to read/write from/into registers, calling `remap_[read|write]`
    functions.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当需要读/写寄存器时，调用 `remap_[read|write]` 函数。
- en: When done with the register map, assuming you used resource-managed APIs, you
    have nothing else to do as devres core will take care of releasing the Regmap
    resources; otherwise, you'll have to call `regmap_exit()` to free the register
    map allocated in the probe.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当寄存器映射完成后，假设你使用了资源管理 API，devres 核心会负责释放 Regmap 资源，无需其他操作；否则，你必须调用 `regmap_exit()`
    来释放在 probe 中分配的寄存器映射。
- en: Let's now materialize these steps in a real driver example that takes advantage
    of the Regmap framework.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个实际的驱动示例中实现这些步骤，利用 Regmap 框架的优势。
- en: A Regmap example
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 Regmap 示例
- en: 'To achieve our goal, let''s first describe a fake SPI device for which we can
    write a driver using the Regmap framework. For understandability, let''s use the
    following characteristics:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，首先让我们描述一个假设的 SPI 设备，以便我们可以使用 Regmap 框架编写驱动。为了便于理解，假设该设备具有以下特性：
- en: The device supports 8-bit register addressing and 8-bit register values.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备支持 8 位寄存器寻址和 8 位寄存器值。
- en: The maximum address that can be accessed in this device is `0x80` (it does not
    necessarily mean that this device has `0x80` registers).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备中可访问的最大地址是 `0x80`（这并不一定意味着该设备有 `0x80` 个寄存器）。
- en: 'The write mask is `0x80`, and the valid address ranges are as follows:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写掩码是 `0x80`，有效地址范围如下：
- en: '`0x20` to `0x4F`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x20` 到 `0x4F`'
- en: '`0x60` to `0x7F`'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0x60` 到 `0x7F`'
- en: Since the device supports simple SPI read/write operations, there is no need
    to provide a custom read/write function.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于该设备支持简单的 SPI 读/写操作，因此无需提供自定义的读/写函数。
- en: Now that we are done with the device and the Regmap specifications, we can start
    writing the code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了设备和 Regmap 规范的定义，可以开始编写代码了。
- en: 'The following includes the required header to deal with Regmap:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理 Regmap 所需的头文件：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Depending on the APIs needed in the driver, other headers might be included.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据驱动中所需的 API，可能还需要包括其他头文件。
- en: 'Then, we define our private data structure as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们按如下方式定义私有数据结构：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we define a read/write register range, that is, registers that are allowed
    to be accessed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个读/写寄存器范围，即允许访问的寄存器：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, it must be noted that if `writeable_reg` and/or `readable_reg` are
    set, there is no need to provide `wr_table` and/or `rd_table`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，必须注意，如果设置了 `writeable_reg` 和/或 `readable_reg`，则无需提供 `wr_table` 和/或 `rd_table`。
- en: 'After that, we define the callback that will be called any time a register
    is accessed for a write or a read operation. Each callback must return true if
    it is allowed to perform the specified operation on the register:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义回调函数，该函数将在每次进行写或读操作时调用。每个回调必须返回 `true`，如果允许对寄存器执行指定的操作：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that all Regmap-related operations have been defined, we can implement
    the driver''s `probe` method as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 既然所有与 Regmap 相关的操作都已定义，我们可以按如下方式实现驱动的 `probe` 方法：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding `probe` method, there are even more commands than code. We
    simply needed to demonstrate how the device specification could be translated
    into a register map configuration and used as main access functions to the device
    registers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `probe` 方法中，命令比代码还要多。我们仅仅需要展示如何将设备规格转换为寄存器映射配置，并将其用作访问设备寄存器的主要方法。
- en: Now that we are done with Regmap from within the kernel, let's see how user
    space can make the most out of this framework in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了内核中的 Regmap 部分，接下来我们将在下一节中展示用户空间如何充分利用该框架。
- en: Leveraging Regmap from the user space
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户空间使用Regmap
- en: 'Register maps can be monitored from the user space via the debugfs file system.
    First, debugfs needs to be enabled via the `CONFIG_DEBUG_FS` kernel configuration
    option. Then, debugfs can be mounted using the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过debugfs文件系统从用户空间监控寄存器映射。首先，需要通过`CONFIG_DEBUG_FS`内核配置选项启用debugfs。然后，可以使用以下命令挂载debugfs：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After that, the debugfs register map implementation can be found under `/sys/kernel/debug/regmap/`.
    This debugfs view implemented by `drivers/base/regmap/regmap-debugfs.c` in kernel
    sources contains a register cache (mirror) for drivers/peripherals based on the
    Regmap API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，debugfs寄存器映射实现可以在`/sys/kernel/debug/regmap/`下找到。这个由`drivers/base/regmap/regmap-debugfs.c`实现的debugfs视图包含基于Regmap
    API的驱动程序/外设的寄存器缓存（镜像）。
- en: 'From the Regmap main debugfs directory, we can get the list of devices whose
    drivers are based on the Regmap API using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从Regmap主调试文件系统（debugfs）目录中，我们可以使用以下命令获取基于Regmap API的驱动程序的设备列表：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In each directory, there can be one or more of the following files:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个目录中，可能包含以下一个或多个文件：
- en: '`access`: An encoding of the various access permissions to each register in
    respect of the pattern `readable writable volatile precious`:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access`：对每个寄存器的各种访问权限进行编码，模式为`readable writable volatile precious`：'
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For example, the line `5e: y y y n` means that the register at address `5e`
    is readable, writeable, volatile, but not precious.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`5e: y y y n`这一行表示地址为`5e`的寄存器是可读的、可写的、易失的，但不是珍贵的。'
- en: '`name`: The driver name associated with the register map. Check for the corresponding
    driver. For example, the `702d3000.amx` register map entry:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：与寄存器映射相关联的驱动程序名称。检查相应的驱动程序。例如，`702d3000.amx`寄存器映射条目：'
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are, however, Regmap entries starting with `dummy-` as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些Regmap条目以`dummy-`开头，如下所示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This kind of entry is set when there are no associated `/dev` entries (`devtmpfs`).
    You can check this by printing the underlying device name, which will be `nodev`
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有关联的`/dev`条目（`devtmpfs`）时，设置这种条目。您可以通过打印底层设备名称来检查这一点，名称将为`nodev`，如下所示：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can look for the suffix name after `dummy-` to find the relevant node in
    the device tree, for example, `dummy-avs-monitor@fd5d2000`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查找`dummy-`后缀名称，以便在设备树中找到相关节点，例如，`dummy-avs-monitor@fd5d2000`：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`cache_bypass`: Puts the register map into cache-only mode. If enabled, writes
    to the register map will only update the hardware and not the cache directly:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_bypass`：将寄存器映射置于仅缓存模式。如果启用，写入寄存器映射将仅更新硬件，而不会直接更新缓存：'
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To enable cache bypassing, you should echo `Y` in this file as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用缓存绕过，您应该在此文件中回显`Y`，如下所示：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will additionally print a message in the kernel log buffer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将额外在内核日志缓冲区中打印一条消息。
- en: '`cache_dirty`: Indicates that HW registers were reset to default values and
    that hardware registers do not match the cache state. The read value can be either
    `Y` or `N`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_dirty`：表示硬件寄存器已重置为默认值，并且硬件寄存器与缓存状态不匹配。读取的值可以是`Y`或`N`。'
- en: '`cache_only`: Echoing `N` in this file will disable caching for this register
    map and in the meantime, will trigger cache syncing, while writing `Y` will force
    registers in this register map to be cached only. Reading this file value will
    return `Y` or `N` according to the current caching enabled state. Any write happening
    while this value is true will be cached (only the register cache will be updated,
    no hardware changes will occur).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_only`：在此文件中回显`N`将禁用此寄存器映射的缓存，同时触发缓存同步，而写入`Y`将强制此寄存器映射仅缓存。当读取此文件的值时，将根据当前启用的缓存状态返回`Y`或`N`。在此值为`true`时发生的任何写入都会被缓存（只会更新寄存器缓存，不会发生硬件更改）。'
- en: '`range`: The valid register ranges of the register map:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range`：寄存器映射的有效寄存器范围：'
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`rbtree`: Provides how much memory overhead the `rbtree` cache adds:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rbtree`：提供`rbtree`缓存增加的内存开销：'
- en: '[PRE31]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`registers`: The file used to read and write the actual registers associated
    with the register map:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registers`：用于读取和写入与寄存器映射关联的实际寄存器的文件：'
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding output, the register address is shown first, then its content
    after.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，首先显示寄存器地址，然后显示其内容。
- en: This section is quite short but is a concise description of Regmap monitoring
    from the user space. It allows reading and writing register content, and in some
    circumstances, changing the behavior of the underlying Regmap.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本节非常简短，但简明扼要地描述了来自用户空间的Regmap监控。它允许读取和写入寄存器内容，并在某些情况下更改底层Regmap的行为。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter is all about register access related Regmap APIs. Its simplicity
    should give you an idea of how useful and widely used it is. This chapter has
    shown everything you need to know about the Regmap API. Now you should be able
    to convert any standard SPI/I2C/memory-mapped driver into Regmap.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于与寄存器访问相关的 Regmap API。它的简单性应该能让你了解它有多么有用和广泛应用。本章展示了你需要了解的所有关于 Regmap API
    的内容。现在你应该能够将任何标准的 SPI/I2C/内存映射驱动程序转换为 Regmap 驱动程序。
- en: The next chapter will cover IRQ management under Linux, however, two chapters
    after, we will cover IIO devices, a framework for analog-to-digital converters.
    Those kinds of devices always sit on top of SPI/I2C buses. It could be a challenge
    for us, at the end of that chapter, to write an IIO driver using the Regmap API.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍 Linux 下的 IRQ 管理，然而在接下来的两章中，我们将讲解 IIO 设备，这是一种用于模拟到数字转换器的框架。这类设备通常位于 SPI/I2C
    总线之上。对于我们来说，可能会面临一个挑战，那就是在本章结束时，使用 Regmap API 编写一个 IIO 驱动程序。
