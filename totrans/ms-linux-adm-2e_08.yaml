- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Linux Shell Scripting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux Shell 脚本编写
- en: Knowing how to use the basics of Linux shell programming and the **command-line
    interface** (**CLI**) is essential for a modern-day Linux professional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用 Linux Shell 编程基础和**命令行界面**（**CLI**）对现代 Linux 专业人员至关重要。
- en: In this chapter, you will learn how to use the Linux shell’s programming capabilities
    to automate different tasks in Linux. You will learn about the structure of a
    basic Linux shell script and how it is organized and executed. We’ll explore most
    of the commands already available to you from the previous chapters, especially
    the ones for working with files and directories and input and output redirection.
    Along the way, we’ll introduce you to writing scripts, the structure and complexity
    of shell programming, and how to use specialized tools such as `sed` and `gawk`.
    We hope that by the end of this chapter, you’ll be comfortable using scripts in
    your day-to-day workflow and be ready for future, more advanced explorations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何利用 Linux Shell 的编程功能来自动化 Linux 中的不同任务。你将了解基本 Linux Shell 脚本的结构，以及它是如何组织和执行的。我们将探索之前章节中已经介绍的大多数命令，特别是那些用于操作文件和目录以及输入输出重定向的命令。过程中，我们将引导你学习编写脚本、Shell
    编程的结构和复杂性，以及如何使用 `sed` 和 `gawk` 等专用工具。我们希望到本章结束时，你能熟练地在日常工作流中使用脚本，并为未来更高级的探索做好准备。
- en: 'We’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Introducing shell features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Shell 特性
- en: The structure of a shell script
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 脚本的结构
- en: Decisions, loops, variables, arrays, and functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决策、循环、变量、数组和函数
- en: Using `sed` and (`g`)`awk`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sed` 和 (`g`)`awk`
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a working installation of a standard Linux distribution,
    on either server, desktop, PC, or **virtual machine** (**VM**). Our examples and
    case studies will use mainly Ubuntu/Debian and RHEL/Fedora platforms, but the
    commands and examples that will be explored are equally suitable for other Linux
    distributions, such as openSUSE/SLE.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要在标准的 Linux 发行版上进行安装并正常运行，无论是服务器、桌面、PC 还是**虚拟机**（**VM**）。我们的示例和案例研究主要使用 Ubuntu/Debian
    和 RHEL/Fedora 平台，但我们将探讨的命令和示例同样适用于其他 Linux 发行版，如 openSUSE/SLE。
- en: Exploring the Linux shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Linux Shell
- en: Back in [*Chapter 2*](B19682_02.xhtml#_idTextAnchor053), *The Linux Shell and
    Filesystem*, we introduced you to the shell by exploring the available virtual
    consoles, command types, and the filesystem. This gave you a fair foundation for
    what we are about to explore in this chapter. By now, with everything we have
    been showing you in this book, you are already well versed in using the command
    line; you know some of the most common and useful commands available in Linux
    as we explored file operations, package, user, and disk management, all the way
    up to network administration. All this knowledge will eventually be put to use
    in this chapter, where we will explore advanced shell features, shell variables,
    regular expressions, and how to take advantage of the powerful programming and
    automation features of the Bash shell.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第 2 章*](B19682_02.xhtml#_idTextAnchor053)，*Linux Shell 和文件系统*，我们通过探索可用的虚拟控制台、命令类型和文件系统介绍了
    Shell。这为我们在本章要探索的内容提供了一个良好的基础。到目前为止，通过本书所展示的内容，你已经熟练掌握了命令行的使用；你了解了一些在 Linux 中最常用和最有用的命令，我们探讨了文件操作、软件包、用户和磁盘管理，直到网络管理。所有这些知识将在本章中得到应用，我们将探讨高级
    Shell 特性、Shell 变量、正则表达式，以及如何利用 Bash Shell 强大的编程和自动化功能。
- en: In the next section, we will begin discovering the advanced features of the
    shell.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将开始探索 Shell 的高级特性。
- en: Bash shell features
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash Shell 特性
- en: The shell not only runs commands but also has many more features that make a
    system administrator’s life more comfortable while at the command line. Some of
    these features include the use of `PATH` and aliases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 不仅执行命令，还有许多其他特性，使得系统管理员在命令行中的工作更加轻松。这些特性包括使用 `PATH` 和别名。
- en: Before we proceed, let’s dig into a little history about the standards the shell
    is based on. Back in the day, when UNIX emerged as an operating system, the need
    for a standard to oversee different variants appeared. Thus, the **Institute of
    Electrical and Electronics Engineers** (**IEEE**) created the **Portable Operating
    System Interface** (**POSIX**) as a family of different standards that were meant
    to assure compatibility between operating systems. Therefore, UNIX and Linux,
    as well as macOS (based on Darwin, the kernel of macOS derived from UNIX), AIX,
    HP-UX, and Oracle Solaris, are POSIX compliant. POSIX has different standards
    for the C language API, file format definitions, directory structures, environment
    variables definitions, locale specifications, character sets, and regular expressions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们了解一下 shell 所基于的标准的历史。早在 UNIX 作为操作系统出现时，便出现了对标准化需求的呼声，用以监督不同版本的系统。因此，**电气与电子工程师协会**（**IEEE**）创建了**可移植操作系统接口**（**POSIX**），它是一个包含多种标准的体系，旨在确保不同操作系统之间的兼容性。因此，UNIX
    和 Linux 以及 macOS（基于 Darwin，macOS 的内核来源于 UNIX）、AIX、HP-UX 和 Oracle Solaris 都是符合
    POSIX 标准的。POSIX 为 C 语言 API、文件格式定义、目录结构、环境变量定义、区域设置、字符集和正则表达式等提供了不同的标准。
- en: With this short history lesson under our belts, let’s proceed. In the next section,
    we will show you how to use shell wildcards and metacharacters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这些历史背景后，我们继续。在下一节中，我们将向你展示如何使用 shell 通配符和元字符。
- en: Wildcards and metacharacters
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通配符和元字符
- en: 'In Linux, **wildcards** are used to match filenames. There are three main types
    of wildcards:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，**通配符**用于匹配文件名。主要有三种类型的通配符：
- en: '`*`): This is used to match any string of none or more characters'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`): 这个符号用于匹配零个或多个字符'
- en: '`?`): This is used to match a single character'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`): 这个符号用于匹配一个单独的字符'
- en: '`[ ]`): This is used to match any of the characters inside brackets'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]`): 这个符号用于匹配方括号内的任意字符'
- en: '**Metacharacters** are special characters that are used in Linux and any Unix-based
    system. These metacharacters are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**元字符**是用于 Linux 和任何基于 UNIX 的系统中的特殊字符。以下是这些元字符：'
- en: '![Figure 8.1 – Metacharacter list](img/B19682_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 元字符列表](img/B19682_08_01.jpg)'
- en: Figure 8.1 – Metacharacter list
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 元字符列表
- en: 'Let’s look at two examples that use metacharacters for command substitution.
    We use the output of one command inside another command. This can be done in two
    ways, as shown in the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看两个使用元字符进行命令替换的示例。我们将一个命令的输出作为另一个命令的输入。这个过程可以通过两种方式实现，如下图所示：
- en: '![Figure 8.2 – Example of command execution and substitution](img/B19682_08_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 命令执行与替换示例](img/B19682_08_02.jpg)'
- en: Figure 8.2 – Example of command execution and substitution
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 命令执行与替换示例
- en: 'The purpose of the preceding example is to show you how command substitution
    works in the shell, but perhaps we should explain further what the commands used
    do. We used two commands: `echo` and `date`. We used the output of the `date`
    command inside the output of the `echo` command. The `echo` command is one of
    the simplest commands in Linux as it prints the message between the quotes to
    the standard output. In our case, the message also consists of the `date` command,
    which outputs the current date of the system, in the format shown.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例的目的是向你展示如何在 shell 中使用命令替换，但我们也许应该进一步解释所用命令的作用。我们使用了两个命令：`echo` 和 `date`。我们将
    `date` 命令的输出嵌入到 `echo` 命令的输出中。`echo` 命令是 Linux 中最简单的命令之一，它将引号中的消息输出到标准输出。在我们的例子中，这个消息还包括了
    `date` 命令的输出，显示系统当前日期，格式如图所示。
- en: You can also combine two or more commands, and to do this in Linux, we use the
    pipe. The pipe sends the output of the first command that was used as the input
    for the second command, and so forth, depending on how many pipes you use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将两个或多个命令组合起来，在 Linux 中我们使用管道符来实现这一点。管道符将第一个命令的输出作为第二个命令的输入，依此类推，具体取决于你使用了多少个管道符。
- en: 'In the following example, we’re using the `ls -l /etc` command to do a long
    listing of the contents of the `/etc` directory; we will pipe this to the `less`
    command. Use it as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用 `ls -l /etc` 命令对 `/etc` 目录的内容进行长格式列出；然后将其通过管道传递给 `less` 命令。请按照以下代码使用：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `less` command will show one display at a time, allowing you to see all
    the contents. You can use the arrow keys or the page up and page down keys to
    navigate through the output and see all the contents of the `/``etc` directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 命令一次显示一页内容，允许你查看所有内容。你可以使用箭头键或翻页键（Page Up 和 Page Down）在输出中导航，查看 `/etc`
    目录的所有内容。'
- en: The pipe and command substitution will be very useful, especially when you’re
    working with complex commands or when scripting, as you will see later in this
    chapter when you learn how to create and use scripts.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 管道和命令替换将非常有用，特别是当你处理复杂命令或编写脚本时，正如你在本章后面学习如何创建和使用脚本时会看到的那样。
- en: 'Now, let’s execute some commands in a sequence. After that, we will use metacharacters
    to group commands and redirect the output to a file. All this is shown in the
    following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行一些命令序列。然后，我们将使用元字符来分组命令并将输出重定向到一个文件。所有这些内容将在以下截图中显示：
- en: '![Figure 8.3 – Example of command sequence execution](img/B19682_08_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 命令序列执行示例](img/B19682_08_03.jpg)'
- en: Figure 8.3 – Example of command sequence execution
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 命令序列执行示例
- en: As you can see in the preceding output, the two commands that were executed
    on the first line can easily be grouped using brackets, and their output can be
    redirected to a file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的输出中所看到的，第一行执行的两个命令可以很容易地通过大括号进行分组，并且它们的输出可以重定向到一个文件中。
- en: We used three types of metacharacters – the *command execution sequence* (`;`),
    the brackets for *grouping commands* in the execution sequence, and the *output
    redirection* (`>`) to redirect the output to a file. The file did not exist initially
    as it was created only when the command was executed. The last command we used
    was the `cat` command, which *concatenates* the contents of the newly created
    file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了三种元字符——*命令执行顺序* (`;`)、用于*分组命令*的括号，以及*输出重定向* (`>`) 将输出重定向到文件。该文件最初并不存在，只有在命令执行时才会创建。我们使用的最后一个命令是
    `cat` 命令，它*连接*了新创建文件的内容。
- en: The first two commands that were used were `who`, which prints information about
    the currently logged-in users to the standard output, and `pwd`, which prints
    the present working directory as the location we are in inside the filesystem.
    In the following section, we will show you how to use brace expansion with the
    shell.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的前两个命令是 `who`，它将当前登录的用户信息打印到标准输出，和 `pwd`，它打印出我们所在的当前工作目录的位置。接下来的部分，我们将展示如何在
    Shell 中使用大括号扩展。
- en: Brace expansion
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大括号扩展
- en: Curly brackets can also be used to expand the arguments of a command. **Braces**
    are not just limited to filenames, unlike a wildcard. They work with any type
    of string. Inside these braces, you can use a single string, a sequence, or several
    strings separated by commas.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号也可以用来扩展命令的参数。**大括号**不仅限于文件名，不像通配符那样，它们可以与任何类型的字符串一起使用。在这些大括号中，你可以使用单个字符串、一个序列或由逗号分隔的多个字符串。
- en: 'In this section, we will show you some examples of using this type of expansion.
    First, we will use `report` and `new-report` inside our present working directory
    and we want to delete them both at once. We can use the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将展示一些使用这种扩展类型的示例。首先，我们将在当前工作目录中使用 `report` 和 `new-report`，并希望一次性删除它们。我们可以使用以下命令：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To create multiple files (five of them, for example) that share parts of their
    name, as in `file1`, `file2`, … `filen`, we can use the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多个文件（例如五个文件），它们共享部分名称，如 `file1`、`file2`、… `filen`，我们可以使用以下命令：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the output of both these commands:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这两个命令的输出：
- en: '![Figure 8.4 – Examples of using brace expansion](img/B19682_08_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 使用大括号扩展的示例](img/B19682_08_04.jpg)'
- en: Figure 8.4 – Examples of using brace expansion
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 使用大括号扩展的示例
- en: Important note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Brace expansion is a powerful tool that adds flexibility and power to any system
    administrator’s workflow. They will prove very useful when learning how to script,
    for example.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展是一个强大的工具，它为任何系统管理员的工作流增添了灵活性和强大功能。比如在学习如何编写脚本时，它将非常有用。
- en: 'Now that we’ve created those files, it should be really easy for you to figure
    out how to use brace expansion to delete multiple files at once. Type the following
    command into your console and see what happens:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了这些文件，你应该能很容易地弄明白如何使用大括号扩展一次删除多个文件。将以下命令输入到你的控制台中，看看会发生什么：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It will delete all five files we created previously. Use the `ls` command to
    see the contents of the present working directory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它将删除我们之前创建的所有五个文件。使用 `ls` 命令查看当前工作目录的内容。
- en: In the next section, we will talk about shell command aliases, what they are,
    and how to use them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 shell 命令别名，它们是什么以及如何使用它们。
- en: The shell’s aliases
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shell 的别名
- en: 'The Linux shell supports `ll` that is shorthand for `ls -alF`. You can define
    your own aliases too. You can make them temporary or permanent, similar to variables.
    In the following example, we changed the alias for the `ll` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Linux shell 支持 `ll`，这是 `ls -alF` 的缩写。你也可以定义自己的别名，可以将它们设置为临时的或永久的，类似于变量。在以下示例中，我们更改了
    `ll` 命令的别名：
- en: '![Figure 8.5 – Changing the alias of a command](img/B19682_08_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 更改命令的别名](img/B19682_08_05.jpg)'
- en: Figure 8.5 – Changing the alias of a command
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 更改命令的别名
- en: This modification is only temporary, and it will revert to the default version
    after reboot or shell restart. If you want to make it permanent, you should edit
    the `~/.bashrc` file and add the aliases you created previously inside the file.
    To do this, open the file with your preferred text editor and add the lines you
    used in the Terminal to the file. Save the file and execute it. Also, a better
    practice would be to add those lines to a new file called `.bash_aliases`. You
    can view the default contents of `.bashrc` for more information on how to use
    aliases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改只是临时的，重新启动或 shell 重启后将恢复为默认版本。如果你想使其永久生效，应该编辑 `~/.bashrc` 文件，并将之前创建的别名添加到该文件中。为此，使用你喜欢的文本编辑器打开该文件，并将你在终端中使用的行添加到文件中。保存文件并执行它。同时，最佳实践是将这些行添加到一个名为
    `.bash_aliases` 的新文件中。你可以查看 `.bashrc` 文件的默认内容，了解如何使用别名。
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The `.bashrc` file is a hidden script file that consists of different Terminal
    session configurations. Also, the file can contain different functions that can
    help the user overcome repetitive tasks. It is automatically executed when the
    user logs in, but it can also be manually executed by using the `source .``bashrc`
    command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`.bashrc` 文件是一个隐藏的脚本文件，包含不同的终端会话配置。此外，该文件还可以包含不同的函数，帮助用户完成重复任务。它会在用户登录时自动执行，也可以通过使用
    `source .bashrc` 命令手动执行。'
- en: In the next section, we will show you what shell variables are and how to use
    them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示什么是 shell 变量以及如何使用它们。
- en: Bash shell variables
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash shell 变量
- en: The Bash shell uses different types of variables, in the same way you would
    use them in any programming language. The Bash shell has some built-in variables
    and indirect variables and offers the possibility to define your own variables
    as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell 使用不同类型的变量，和你在任何编程语言中使用它们的方式相同。Bash shell 有一些内置变量和间接变量，并且还允许你定义自己的变量。
- en: 'Linux has two major types of shell variables: **global** and **local variables**.
    They are generally identical for every Linux distribution out there, with some
    exceptions. You will need to consult your distribution’s documentation for any
    specific modifications to the environment variables.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有两种主要的 shell 变量类型：**全局变量**和**局部变量**。它们对于所有的 Linux 发行版通常是相同的，但也有一些例外。你需要查阅你发行版的文档，以了解任何特定的环境变量修改。
- en: We will walk you through the most widely used variables in Linux, starting with
    the built-in ones.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将带你了解 Linux 中最常用的变量，从内置变量开始。
- en: Built-in shell variables
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置 shell 变量
- en: 'Here is a short list of some of the standard built-in variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些标准内置变量的简短列表：
- en: '`HOME`: The user’s home directory (for example, `/home/packt`)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOME`: 用户的主目录（例如，`/home/packt`）'
- en: '`LOGNAME`: The user’s login name (for example, `packt`)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOGNAME`: 用户的登录名（例如，`packt`）'
- en: '`PWD`: The shell’s current working directory'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWD`: 当前的工作目录'
- en: '`OLDPWD`: The shell’s previous working directory'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OLDPWD`: shell 的上一个工作目录'
- en: '`PATH`: The shell’s search path (list of directories separated by colons)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`: shell 的搜索路径（由冒号分隔的目录列表）'
- en: '`SHELL`: The path to the shell'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHELL`: shell 的路径'
- en: '`USER`: The user’s login name'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`: 用户的登录名'
- en: '`TERM`: The type of the Terminal'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERM`: 终端的类型'
- en: 'To call a variable while in the shell, all you have to do is place a dollar
    sign, `$`, in front of the variable’s name. Here is a short example that shows
    how to use the variables that we just listed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中调用变量时，只需在变量名的前面加上美元符号 `$`。以下是一个简短的示例，展示了如何使用我们刚才列出的变量：
- en: '![Figure 8.6 – Variable calling from the shell](img/B19682_08_06.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 从 shell 调用变量](img/B19682_08_06.jpg)'
- en: Figure 8.6 – Variable calling from the shell
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 从 shell 调用变量
- en: 'You can also assign your own shell variables, as in the following example.
    Here, we’re assigning the `sysadmin` string to a new variable called `MYVAR` and
    then printing it to standard output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以像下面的例子一样赋值自己的 shell 变量。在这里，我们将 `sysadmin` 字符串赋值给一个名为 `MYVAR` 的新变量，然后将其打印到标准输出：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The variables listed at the beginning of this section are just a part of all
    the variables available by default inside the shell. To see all the shell variables,
    use the `printenv` command. If the list is too long, you can redirect it to a
    file. In the following example, your variables list is inside the `shell_variables`
    file, and you can see it by concatenating or by editing inside a text editor such
    as Vim:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节开头列出的变量只是 shell 中默认提供的所有变量的一部分。要查看所有 shell 变量，可以使用 `printenv` 命令。如果列表太长，可以将其重定向到文件中。在下面的例子中，你的变量列表存储在
    `shell_variables` 文件中，你可以通过串联或在文本编辑器（如 Vim）中编辑来查看它：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we use the tilde symbol (`~`) to specify the logged-in user’s home directory.
    The shell’s variables are only available inside the shell. If you want some variables
    to be known to other programs that are run by the shell, you must export them
    by using the `export` command. Once a variable is exported from the shell, it
    is known as an **environment variable**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用波浪号符号（`~`）来指定已登录用户的主目录。Shell 变量仅在 shell 内部可用。如果你希望某些变量能被 shell 运行的其他程序所知道，必须通过使用
    `export` 命令将其导出。一旦变量从 shell 导出，它就成为 **环境变量**。
- en: The shell’s search path
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell 的搜索路径
- en: 'The `PATH` variable is an essential one in Linux. It helps the shell know where
    all the programs are located. When you enter a command into your Bash shell, it
    first has to search for that command through the Linux filesystem. Some directories
    are already listed inside the `PATH` variable, but you can also add new ones.
    Your addition can be temporary or permanent, depending on how you do it. To make
    a directory’s path available temporarily, simply add it to the `PATH` variable.
    In the following example, we’re adding the `/home/packt` directory to `PATH`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 变量是 Linux 中一个重要的变量。它帮助 shell 知道所有程序的位置。当你在 Bash shell 中输入命令时，它首先必须通过
    Linux 文件系统搜索该命令。有些目录已经列在 `PATH` 变量中，但你也可以添加新的目录。根据你的操作方式，添加的内容可以是临时的或永久的。要使一个目录的路径临时可用，只需将其添加到
    `PATH` 变量中。在下面的例子中，我们将 `/home/packt` 目录添加到 `PATH` 中：'
- en: '![Figure 8.7 – Adding a new location to PATH](img/B19682_08_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 添加新位置到 PATH](img/B19682_08_07.jpg)'
- en: Figure 8.7 – Adding a new location to PATH
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 添加新位置到 PATH
- en: To make any changes permanent, we must modify the `PATH` variable inside a file
    called `~/.bash_profile` or `~/.bashrc`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使任何更改永久生效，我们必须在名为 `~/.bash_profile` 或 `~/.bashrc` 的文件中修改 `PATH` 变量。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some distributions, such as openSUSE, add an extra `bin` directory inside the
    user’s home directory. This is a place where you can put files that you want the
    shell to execute – for example, script files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些发行版，如 openSUSE，会在用户的主目录中添加一个额外的 `bin` 目录。这是你可以放置希望 shell 执行的文件的地方，例如脚本文件。
- en: The shell’s `$PATH` variable is important, especially when using scripts, as
    you will preferably have to create scripts inside a directory that is known by
    the shell. In the next section, we will show you how to create your first Bash
    scripts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 的 `$PATH` 变量很重要，特别是在使用脚本时，因为你通常需要在一个 shell 已知的目录中创建脚本。在下一节中，我们将向你展示如何创建你的第一个
    Bash 脚本。
- en: Basics of shell scripting
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 脚本基础
- en: We have already covered important aspects of the Linux command line, shell variables,
    wildcards, and metacharacters. Now, we will start exploring what scripts are,
    how to create them, and how to use them in a Linux CLI. We will not use the graphical
    user interface, only the CLI, which we primarily used in our previous chapters.
    Let’s start with some basic, but important, concepts about shell scripting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 Linux 命令行、shell 变量、通配符和元字符的关键内容。现在，我们将开始探索什么是脚本，如何创建它们以及如何在 Linux CLI
    中使用它们。我们将不使用图形用户界面，仅使用 CLI，这是我们在前面章节中主要使用的。让我们从一些关于 shell 脚本的基本但重要的概念开始。
- en: First, let’s learn what a **script** is. If we were to check the meaning of
    the term in a dictionary, the answer would be that a script is a series of instructions
    that are executed by a computer, mainly to automate a specific task. Instructions
    can easily be assimilated as commands too. Thus, a series of commands executed
    together by the shell can be considered a script. This is a very basic script,
    but it is a script. Let’s look at how we can create a script file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解什么是 **脚本**。如果我们在字典中查找这个术语的意思，答案是脚本是一系列由计算机执行的指令，主要用于自动化特定任务。指令也可以很容易地看作是命令。因此，一系列由
    shell 执行的命令可以被视为一个脚本。这是一个非常基础的脚本，但它仍然是一个脚本。让我们看看如何创建一个脚本文件。
- en: Creating a shell script file
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 shell 脚本文件
- en: 'The most appropriate way to write scripts is to create them in the form of
    a file, called a `.sh` extension for clarity. However, this is not obligatory,
    because in Linux, files don’t use extensions, unlike in Windows. The distinctive
    characteristic that makes a file considered a script is the *very first line*
    of text inside that file. In the case of a Bash shell script, this line is in
    the following format:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 编写脚本最合适的方法是将它们创建为一个文件，为了清晰起见，我们使用 `.sh` 扩展名。然而，这并不是强制性的，因为在 Linux 中，文件不像 Windows
    那样使用扩展名。使文件被认为是脚本的独特特征是该文件中的 *第一行* 文本。对于 Bash shell 脚本，这一行的格式如下：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the file is opened and executed, the first line tells the shell’s interpreter
    that it is dealing with a script file that, in our case, will be run by the Bash
    shell. If you are using a different shell, this first line will point to it. The
    use of the hashtag (`#`) inside a shell script file denotes a commented line,
    except for this very first line, where it is used, combined with the exclamation
    mark (`!`), to point to the shell’s interpreter. The `#!` combination is also
    called the **shebang**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件被打开并执行时，第一行告诉 shell 解释器它正在处理一个脚本文件，在我们的例子中，这个脚本将由 Bash shell 执行。如果你使用的是不同的
    shell，这第一行会指向它。在 shell 脚本文件中，井号（`#`）表示注释行，除了这一行，它与感叹号（`!`）结合使用，指向 shell 的解释器。`#!`
    的组合也被称为 **shebang**。
- en: 'Let’s create a basic script file. We will use the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的脚本文件。我们将使用以下代码：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we used four different commands in our first, basic script. We used a
    separate line for each command, but there is another way to write it: by putting
    all commands on the same line and using semicolons to separate them. However,
    for clarity, it is useful to use different lines.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在第一个基本脚本中使用了四个不同的命令。我们为每个命令使用了单独的一行，但也可以用另一种方式来编写：将所有命令写在同一行并使用分号分隔它们。然而，为了清晰起见，使用不同的行会更有用。
- en: 'Now that we have our first script, let’s run it. We created the script file
    inside our home directory under the name `basic-script.sh`. Let’s try and run
    it by simply invoking its name at the command line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了第一个脚本，让我们运行它。我们在主目录下创建了名为 `basic-script.sh` 的脚本文件。让我们尝试通过在命令行中简单地调用它的名称来运行它：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be prompted with an error, as shown in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个错误提示，如下图所示：
- en: '![Figure 8.8 – Error upon running the new script](img/B19682_08_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 运行新脚本时出现的错误](img/B19682_08_08.jpg)'
- en: Figure 8.8 – Error upon running the new script
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 运行新脚本时出现的错误
- en: 'You might be wondering why we get this error. It is because the shell does
    not know about your script. It cannot find it inside its `PATH` variable. As you
    might remember from the previous section, `PATH` is a variable that the shell
    uses to find the location of specific files to run. To overcome this error, we
    have two options:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么会出现这个错误。是因为 shell 不知道你的脚本，它在 `PATH` 变量中找不到它。正如你从前一节中记得的那样，`PATH` 是
    shell 用来查找特定文件位置并执行的变量。为了克服这个错误，我们有两个选择：
- en: We can add the directory in which our script resides to the shell’s path
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将脚本所在目录添加到 shell 的路径中
- en: We can use a relative or absolute path when we invoke the script at the command
    line
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行调用脚本时，我们可以使用相对路径或绝对路径
- en: 'We will use the second method as it is more convenient. However, you can use
    the first method as a good practice exercise and try to add your directory’s location
    to the shell’s `PATH` variable. Let’s invoke the script file with its location:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第二种方法，因为它更方便。然而，你可以使用第一种方法作为一个很好的练习，尝试将你的目录位置添加到 shell 的 `PATH` 变量中。让我们通过指定位置来调用脚本文件：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will get another error, this time a different one, saying `Permission denied`.
    This is because we do not have permission to execute the file. When we created
    the file inside our Ubuntu machine, it only got read and write permissions for
    the file’s owner and its group because of the default `umask` value. To change
    that, we will need to make the file executable by using the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会遇到另一个错误，这次是不同的错误，显示 `Permission denied`。这是因为我们没有权限执行该文件。当我们在 Ubuntu 机器内创建文件时，由于默认的
    `umask` 值，该文件只为文件所有者和其组提供了读写权限。为了改变这一点，我们需要使用以下命令使文件可执行：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we’ve set the executable permissions on the file, we can run it again,
    and this time, the script will be executed. The output will show that every command
    inside our script was executed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了文件的可执行权限之后，我们可以再次运行它，这次脚本将被执行。输出将显示脚本内的每个命令都被执行了：
- en: '![Figure 8.9 – Running an executable script file](img/B19682_08_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 运行可执行脚本文件](img/B19682_08_09.jpg)'
- en: Figure 8.9 – Running an executable script file
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 运行可执行脚本文件
- en: As shown in the previous screenshot, the script was executed, and the output
    showed the result of each command inside. On the first line, we have the username
    (the output of the `whoami` command), on the second line, we have information
    about the logged-in users (the output of the `who` command), on the third line,
    we have information about the current date (the output of the `date` command),
    and on the last line, we have information about the current session (the output
    of the `uptime` command).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，脚本已被执行，输出显示了每个命令的结果。第一行显示用户名（`whoami` 命令的输出），第二行显示已登录用户的信息（`who` 命令的输出），第三行显示当前日期的信息（`date`
    命令的输出），最后一行显示当前会话的信息（`uptime` 命令的输出）。
- en: Important note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: As a general rule, when writing scripts, we advise you to *use as many comments*
    as possible to detail each variable and parameter you choose. This is considered
    a good programming practice, which will make your code writing more enjoyable
    and relevant. Documenting your coding steps will make your scripts easier to read
    at a later time, both by yourself and by anyone else who might come across your
    code. We don’t use many comments in the examples used in this book, but this is
    due to constraints regarding page count. Nevertheless, we encourage you to use
    them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当编写脚本时，我们建议*尽可能使用注释*来详细说明您选择的每个变量和参数。这被认为是一种良好的编程实践，可以使您的代码编写更加愉快和相关。记录您的编码步骤将使您的脚本在以后更容易阅读，无论是您自己还是其他任何可能遇到您代码的人。在本书中使用的示例中，我们并未使用太多注释，这是由于页面数量的限制。尽管如此，我们鼓励您使用它们。
- en: With that, you know how to create a shell script file and how to execute it.
    Let’s proceed to more advanced topics now. In the next section, we will show you
    how to use variables in your scripts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，您就知道如何创建一个 shell 脚本文件以及如何执行它。现在让我们继续更高级的话题。在接下来的部分，我们将向您展示如何在您的脚本中使用变量。
- en: Variables in shell scripts
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shell 脚本中的变量
- en: We introduced you to variables at the beginning of this chapter. Now, it is
    time to learn how to use them inside a script. To recap, let’s see what kind of
    variables are used in Linux. We have `printenv` and/or `set` commands. We listed
    some of the most commonly used variables in the *Built-in shell variables* section
    earlier in this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们向您介绍了变量。现在是时候学习如何在脚本内使用它们了。回顾一下，让我们看看 Linux 中使用哪些类型的变量。我们可以使用 `printenv`
    和/或 `set` 命令。我们在本章的*内置 shell 变量*部分列出了一些最常用的变量。
- en: Understanding naming conventions
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解命名规范
- en: Inside the Linux shell, the system’s environment variables use only uppercase
    letters. Thus, the relevant naming considerations should be applied when creating
    user-specified variables. In this regard, there is not one single naming convention
    that applies. But you should take into consideration that the names of variables
    are *case-sensitive* and should be up to *20 characters* in length. The way to
    assign a value to a variable is by using the equals (`=`) sign.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux shell 内，系统的环境变量仅使用大写字母。因此，在创建用户指定的变量时，应遵循相关的命名考虑因素。在这方面，没有一个适用于所有情况的命名约定。但您应考虑变量名*区分大小写*且应最多*20个字符*的长度。赋值给变量的方法是使用等号（`=`）符号。
- en: 'If you plan on using only uppercase letters in the names of your variables,
    you should consider the disastrous effects this might have, considering that the
    environment variables only use uppercase letters. We would advise you to consider
    one of the following rules when creating variable names inside your shell:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在变量名称中只使用大写字母，你应该考虑到这可能带来的灾难性后果，因为环境变量只使用大写字母。我们建议你在创建 shell 中的变量名称时，遵循以下规则之一：
- en: Use only lowercase letters, underscores, and numbers
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用小写字母、下划线和数字
- en: Capitalize the first letter of a word in the variable name
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量名中的单词首字母大写
- en: Important note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When considering name length, try not to use very long names; instead, use succinct
    and relevant names or abbreviations. This will make your script easier to read
    and understand.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑变量名长度时，尽量避免使用过长的名称；可以使用简洁且相关的名称或缩写。这样会让你的脚本更易于阅读和理解。
- en: Now, let’s learn how to define and use our first variables inside a shell. We
    will explore this in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 shell 中定义和使用第一个变量。我们将在下一节中探讨这个内容。
- en: Defining and using variables
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和使用变量
- en: 'Let’s create a new file called `user-script.sh` that will show relevant user
    information by using environment variables. After we create the file and enter
    the relevant code, we will make it executable and then we will run it. The following
    are the relevant commands:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`user-script.sh`的新文件，通过使用环境变量来显示相关的用户信息。创建文件并输入相关代码后，我们将使其可执行，然后运行它。以下是相关命令：
- en: '![Figure 8.10 – Using environment variables in a script](img/B19682_08_10.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 在脚本中使用环境变量](img/B19682_08_10.jpg)'
- en: Figure 8.10 – Using environment variables in a script
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 在脚本中使用环境变量
- en: In the preceding figure, we used two different ways to show information with
    the `echo` command. When we used double quotes to show information, the environment
    variable was used inside the quoted string, and its value was displayed in the
    output. Keep in mind that when using single quotes, the value of the variable
    will not be passed through to the shell’s interpreter. We used four different
    environment variables to show information about the user. Those variables were
    `UID`, `USER`, `HOME`, and `BASH`. This is a very basic and straightforward way
    to use shell variables inside scripts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们使用了两种不同的方式来显示信息。使用双引号时，环境变量会被插入到引号字符串中，并且它的值会显示在输出中。请记住，使用单引号时，变量的值不会传递给
    shell 解释器。我们使用了四个不同的环境变量来显示用户信息。它们分别是`UID`、`USER`、`HOME`和`BASH`。这是一种非常基本且直接的在脚本中使用
    shell 变量的方式。
- en: 'You can also use your own variables, not just the ones that are provided by
    the shell. A very useful feature of the shell’s interpreter is that it can automatically
    determine the data type a variable is using. You should also know that the values
    of variables defined inside a shell script are only active so long as the shell
    is running, and they will be lost afterward. Let’s create a new shell script and
    use our own variables this time. The following is the output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用自己的变量，而不仅仅是 shell 提供的那些。Shell 解释器的一个非常有用的功能是它能够自动确定变量所使用的数据类型。你还应该知道，脚本中定义的变量值仅在
    shell 运行时有效，之后会丢失。让我们创建一个新的 shell 脚本，并这次使用我们自己的变量。以下是输出：
- en: '![Figure 8.11 – A basic script using user-defined variables](img/B19682_08_11.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 一个使用用户定义变量的基本脚本](img/B19682_08_11.jpg)'
- en: Figure 8.11 – A basic script using user-defined variables
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 一个使用用户定义变量的基本脚本
- en: Here, we created a file called `user-variables.sh` and defined two variables,
    one called `value`, which we gave a value of `25`, and another variable called
    `product`, with a value of `Shirt`. When we called the variables inside the `echo`
    command, we used the same callout sign as for environment variables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`user-variables.sh`的文件，并定义了两个变量，一个叫`value`，其值为`25`，另一个叫`product`，其值为`Shirt`。当我们在`echo`命令中调用这些变量时，我们使用了与环境变量相同的调用符号。
- en: Now that you know how to name, define, and use a variable, let’s continue to
    more advanced topics. In the next section, we will show you how to use mathematical
    expressions inside your shell scripts.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何命名、定义和使用变量，让我们继续深入学习更高级的主题。在下一节中，我们将展示如何在 shell 脚本中使用数学表达式。
- en: Using mathematical expressions in shell scripts
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 shell 脚本中使用数学表达式
- en: 'The shell is a programming language, so it has built-in features to work with
    numbers. The Bash shell provides the `expr` command, which is used for different
    mathematical operations. To learn about all the operations that are supported,
    please visit the internal manual page for the `expr` command, as we will not provide
    them fully here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Shell是一种编程语言，因此它具有用于处理数字的内建功能。Bash Shell提供了`expr`命令，用于执行各种数学运算。要了解所有受支持的运算，请访问`expr`命令的内部手册页面，我们在这里不会完全列出：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, we will show you how to use some of the operations that the `expr`
    command provides. Keep in mind that, as the manual says, you will need to escape
    (by using the backslash character, `\`) some of the characters used by the `expr`
    command, as they will be misinterpreted by the shell. Let’s create a new script
    file and do some basic mathematical operations. Our new file is called `math.sh`
    and can be created using the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将展示如何使用`expr`命令提供的某些操作。请记住，正如手册中所述，你需要使用反斜杠字符(`\`)来转义一些`expr`命令使用的字符，否则它们会被Shell误解。让我们创建一个新的脚本文件并进行一些基本的数学运算。我们的新文件名为`math.sh`，可以使用以下代码创建：
- en: '![Figure 8.12 – Using the expr command inside scripts](img/B19682_08_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 在脚本中使用expr命令](img/B19682_08_12.jpg)'
- en: Figure 8.12 – Using the expr command inside scripts
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 在脚本中使用expr命令
- en: 'Besides the `expr` command, we can also use square brackets as a much simpler
    variant for mathematical operations. Let’s modify the preceding script and replace
    the `expr` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`expr`命令外，我们还可以使用方括号作为一种更简单的数学运算方式。让我们修改前面的脚本，替换掉`expr`命令：
- en: '![Figure 8.13 – Using square brackets for math operations](img/B19682_08_13.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 使用方括号进行数学运算](img/B19682_08_13.jpg)'
- en: Figure 8.13 – Using square brackets for math operations
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 使用方括号进行数学运算
- en: As shown in the previous example, we use integer values. You can try and use
    a floating-point value for the `vat` variable, for example, and you will see that
    an error will be displayed when running the script. This is because the shell
    only supports integer arithmetic operations. There are workarounds to overcome
    this limitation, and the most feasible is by using the Bash calculator, or the
    `bc` command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们使用了整数值。你可以尝试为`vat`变量使用浮动点值，例如，你会看到运行脚本时会显示错误。这是因为Shell只支持整数运算。为了克服这个限制，有一些解决方法，其中最可行的是使用Bash计算器，或者`bc`命令。
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to have full support for floating-point operations inside your shell,
    you might want to consider using the **Z shell** (**Zsh**). It is installed by
    default in some Linux distributions (Manjaro and Kali Linux) and on macOS. You
    can also install it in your distribution if you like.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在Shell中完全支持浮动点运算，可能需要考虑使用**Z shell**（**Zsh**）。它在一些Linux发行版（如Manjaro和Kali
    Linux）以及macOS中默认安装。你也可以在你的发行版中安装它。
- en: 'Let’s see how we can use the `bc` command inside our `math.sh` script. We will
    change the code as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在我们的`math.sh`脚本中使用`bc`命令。我们将按照以下方式修改代码：
- en: '![Figure 8.14 – Using the bc command for floating-point operations](img/B19682_08_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 使用bc命令进行浮动点运算](img/B19682_08_14.jpg)'
- en: Figure 8.14 – Using the bc command for floating-point operations
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 使用bc命令进行浮动点运算
- en: 'In the preceding example, we assigned a floating-point value to the `vat` variable
    and used the `bc` command to calculate a floating-point total. We can use the
    `bc` command inside a variable like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将一个浮动点值赋给了`vat`变量，并使用`bc`命令来计算浮动点总数。我们可以像这样在变量中使用`bc`命令：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `option` value provides options for `bc` to use. In our case, we used a
    variable called `decs` (an arbitrary name we chose) to specify the number of decimals
    we would like to provide. The `expression` parameter specifies the operation we
    used, which in our case was addition. We piped the output of the `echo` command
    to the `bc` command and the result was assigned to the `var` variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`option`值为`bc`提供了选项。在我们的例子中，我们使用了一个名为`decs`（这是我们选择的一个任意名称）的变量来指定我们想要提供的小数位数。`expression`参数指定了我们使用的操作，在我们的例子中是加法。我们将`echo`命令的输出通过管道传递给`bc`命令，结果被赋值给了`var`变量。'
- en: Creating Bash shell scripts is more than doing math operations or giving a sequence
    of consecutive shell commands. Sometimes, decisions need to be made inside the
    shell, depending on the input provided and the output expected. This is where
    specific programming structures intervene. We will walk you through all of them
    in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Bash Shell脚本不仅仅是进行数学运算或执行一系列连续的Shell命令。有时候，脚本内部需要根据输入和期望的输出做出决策。这就是特定编程结构介入的地方。我们将在下一节中详细讲解这些结构。
- en: Using programming structures
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编程结构
- en: In this section, we will show you how to use **conditional** and **looping statements**.
    They can prove invaluable when creating advanced shell scripts. We will also show
    you how to use arrays, how input reading is used inside scripts, and how to format
    and print data for the output.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你展示如何使用**条件语句**和**循环语句**。在编写高级Shell脚本时，它们非常有用。我们还将展示如何使用数组，如何在脚本中读取输入，以及如何格式化和打印输出数据。
- en: Using arrays in Bash
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Bash中使用数组
- en: We showed you how to use variables in previous sections. Now, it is time to
    step up our game and show you how to make use of `filename1`, `filename2`, `filename3`
    … `filenameN`, we can create an array that will hold all the filenames. If you
    know other programming languages, arrays may already be familiar to you. But if
    you don’t know any other programming languages, fear not, as Bash has a facile
    way of using arrays.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中展示了如何使用变量。现在，是时候提升我们的技能，展示如何利用`filename1`、`filename2`、`filename3` ……
    `filenameN`，我们可以创建一个数组来存储所有的文件名。如果你熟悉其他编程语言，数组对你来说可能已经很熟悉。但如果你不了解其他编程语言，不用担心，因为Bash提供了一种简单的数组使用方法。
- en: 'Let’s start with an easy example. Let’s say we have to work with different
    usernames. Instead of using different variables for each username, we can use
    an **indexed array**:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始。假设我们需要处理不同的用户名。为了避免为每个用户名使用不同的变量，我们可以使用**索引数组**：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The elements inside an array start from index number `0` (zero). This is important
    to remember when we need to access the contents of the array. If we would like
    to access the third element from the usernames array (the `"mike"` string), we
    must use the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素从索引号`0`（零）开始。这一点很重要，尤其是在需要访问数组内容时。如果我们想访问用户名数组中的第三个元素（即`"mike"`字符串），我们必须使用以下代码：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output will be `mike` (without quotes). To print out the entire array,
    use the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是`mike`（没有引号）。要打印整个数组，可以使用以下代码：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To print out the size of the array, as in the number of elements, use the following
    code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印数组的大小，也就是元素的数量，可以使用以下代码：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, we have six elements inside, and the output will be `6`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，数组中有六个元素，输出将是`6`。
- en: 'Let’s say we need to add a new username (`"alex"`) to the array. There are
    different ways to add it. If we just want to add it with no specified position
    from the beginning, we can use the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将一个新的用户名（`"alex"`）添加到数组中。有不同的方法来添加它。如果我们只想将其添加到数组末尾，而不指定位置，我们可以使用以下代码：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The new username will be appended at the end of the array. At this point, the
    array contains unordered names, and we will need to arrange them in alphabetical
    order. We will cover this in the *Using looping statements* section, after which
    we will teach you about output formatting and different conditional and looping
    statements.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 新的用户名将被附加到数组的末尾。此时，数组中的名字是无序的，我们需要将它们按字母顺序排列。我们将在*使用循环语句*部分介绍这一点，之后我们将教你如何进行输出格式化以及使用不同的条件语句和循环语句。
- en: 'Alternatively, we can add a new element (`"zack"`, for example) at a specific
    position inside the array (let’s say position 2) by using the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以通过使用以下代码，在数组中的特定位置（比如位置2）添加一个新元素（例如`"zack"`）：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So far, we’ve only used strings inside arrays as an example. You can also use
    integers for indexed arrays. The built-in command to create an array is `declare`.
    To create an indexed array, you can use the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在数组中使用了字符串作为示例。你也可以在索引数组中使用整数。创建数组的内置命令是`declare`。要创建一个索引数组，可以使用以下命令：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also create associative arrays using the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令创建关联数组：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Associative arrays** are based on key-value pairs of elements. The following
    is an example of an associative array declaration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联数组**是基于键值对的元素。以下是一个关联数组声明的示例：'
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Presented inside square brackets are the keys that are used to map the values.
    Inside double quotes, we have the values. To print the values, you can use the
    same command you used for indexed arrays:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号内展示的是用于映射值的键。双引号内的是值。要打印这些值，可以使用与索引数组相同的命令：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To print the keys, use the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印键，请使用以下命令：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main difference between indexed and associative arrays is that indexed arrays
    are based on index value, where each element has a specific index position inside
    the array, whereas associative arrays use specific keys to map the values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组与关联数组之间的主要区别在于，索引数组是基于索引值的，每个元素在数组中都有一个特定的索引位置，而关联数组则使用特定的键来映射值。
- en: Arrays are important data structures inside Bash and we will make use of them
    later in this chapter when we discuss looping statements. But first, let’s learn
    how to read input data inside a script, and how to format output data. In the
    next section, we will show you how to read data from standard input.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 Bash 中重要的数据结构，稍后我们将在本章讨论循环语句时使用它们。但首先，让我们学习如何在脚本中读取输入数据，以及如何格式化输出数据。在下一节中，我们将展示如何从标准输入读取数据。
- en: Reading input data
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取输入数据
- en: By default, the shell reads the input data from the standard input, which is
    the keyboard. To read from the standard input, you can use the `read` command.
    This command reads all input data provided until a new line is provided. This
    happens when you press the *Enter* key on your keyboard.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Shell 从标准输入（即键盘）读取输入数据。要从标准输入读取数据，可以使用 `read` 命令。此命令会读取所有输入数据，直到提供新的行。每当你按下键盘上的
    *Enter* 键时，就会发生这种情况。
- en: 'With the `read` command, you can provide one or more variables. If you use
    more variables, each word provided through standard input will be assigned to
    a variable. The following is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `read` 命令时，可以提供一个或多个变量。如果使用更多的变量，通过标准输入提供的每个单词将被分配给一个变量。以下是一个示例：
- en: '![Figure 8.15 – Using the read command for standard input](img/B19682_08_15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.15 – 使用 `read` 命令进行标准输入](img/B19682_08_15.jpg)'
- en: Figure 8.15 – Using the read command for standard input
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 – 使用 `read` 命令进行标准输入
- en: 'In the preceding screenshot, we used the `read` command with four variables
    called `a`, `b`, `c`, and `d`. When we first introduced the data, we only provided
    a value for the first variable, meaning that we hit *Enter* after entering the
    first word from the keyboard. Thus, we had only one value for `a` and no value
    for the others. When we used the `read` command for the second time, we provided
    values for every variable, thus hitting *Enter* after the word `Thursday`. This
    way, each variable received a relevant value. The `read` command has several options
    available, but you will have to read the manual to learn about them in detail.
    Similar to providing values from the standard input, the `read` command can receive
    input from a file by using redirection. For example, if we have a file called
    `week-days`, we can redirect its content to the `read` command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们使用了 `read` 命令，并为四个变量 `a`、`b`、`c` 和 `d` 提供了值。当我们首次输入数据时，只为第一个变量提供了值，这意味着在输入第一个单词后，我们按下了
    *Enter* 键。因此，`a` 只有一个值，而其他变量没有值。当我们第二次使用 `read` 命令时，为每个变量提供了值，在输入完单词 `Thursday`
    后按下 *Enter* 键。这样，每个变量都接收了相应的值。`read` 命令有多个选项可用，但你需要阅读手册来了解它们的详细信息。与从标准输入提供值类似，`read`
    命令还可以通过重定向从文件接收输入。例如，如果我们有一个名为 `week-days` 的文件，可以将其内容重定向到 `read` 命令：
- en: '![Figure 8.16 – Using read with file redirection](img/B19682_08_16.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 使用 `read` 命令与文件重定向](img/B19682_08_16.jpg)'
- en: Figure 8.16 – Using read with file redirection
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 使用 `read` 命令与文件重定向
- en: The `read` command is used for input reading when creating scripts. We showed
    you how to use the command on the command line, but we will come back to it later
    in this chapter when we talk about more advanced scripts. In the following section,
    we will introduce you to output data formats.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`read` 命令用于在创建脚本时读取输入。我们已经向你展示了如何在命令行中使用该命令，但在本章稍后我们将回到这一部分，讨论更高级的脚本。在接下来的章节中，我们将介绍输出数据格式。'
- en: Formatting output data
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化输出数据
- en: In Linux, the standard output is directed by default to the monitor. For this
    task, you will have two commands you can use. One of them is the `echo` command,
    which we’ve used quite extensively in this book. The other command is called `printf`,
    and we will cover its use in this section.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，标准输出默认会定向到显示器。对于这个任务，你将有两个可以使用的命令。其中一个是我们在本书中广泛使用的 `echo` 命令。另一个命令是
    `printf`，我们将在本节中讲解它的使用。
- en: 'The `printf` command is similar to the one used in the C programming language.
    A quick manual search for the `printf` command will show us the form in which
    it should be used:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 命令类似于 C 编程语言中使用的命令。快速查阅 `printf` 命令的手册会向我们展示它应该使用的形式：'
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the arguments of the command are printed according to the format string
    provided. The format controls can have normal characters or **escape sequences**,
    containing backslash and letters. These escape sequences are clearly presented
    in the available manual. Briefly, some widely used sequences are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的所有参数会根据提供的格式字符串进行打印。格式控制符可以包含常规字符或**转义序列**，这些序列由反斜杠和字母组成。转义序列在可用的手册中有清晰的说明。简而言之，一些常用的序列如下：
- en: '`\``b`: Backspace'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``b`：退格符'
- en: '`\``e`: Escape'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``e`：转义'
- en: '`\f`: Form feed'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\f`：换页符'
- en: '`\n`: New line'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`：新行'
- en: '`\r`: Carriage return'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`：回车符'
- en: '`\t`: Horizontal tab'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`：水平制表符'
- en: '`\v`: Vertical tab'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\v`：垂直制表符'
- en: When using a backslash with `printf`, it should be escaped from the shell by
    using double quotes or another backslash. For more details on this, please refer
    to the manual.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反斜杠与`printf`时，应该通过使用双引号或另一个反斜杠从 shell 中进行转义。有关更多详细信息，请参考手册。
- en: 'Besides escape sequences, the `printf` command has format specifiers. Here
    are some details about what some of these format specifiers represent:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转义序列，`printf` 命令还具有格式化符。以下是一些常见格式化符所代表的含义：
- en: '`%s`: This is a string specifier and it’s used for basic string output'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%s`：这是一个字符串格式化符，用于基本的字符串输出'
- en: '`%b`: This is a string specifier that allows escape sequence interpretation'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%b`：这是一个字符串格式化符，它允许解释转义序列'
- en: '`%d`: This is an integer specifier that’s used for integral values'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d`：这是一个整数格式化符，用于整数值'
- en: '`%f`: This is similar to the integer specifier, but it’s used for floating-point
    values'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%f`：这与整数格式化符类似，但用于浮点值'
- en: '`%x`: This is used for the hexadecimal values of integers and output padding'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%x`：用于整数的十六进制值和输出填充'
- en: Now that you know the basics of the `printf` command, let’s look at some examples
    of how to use it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `printf` 命令的基础知识，让我们看一些如何使用它的示例。
- en: 'In the following figure, we’re using `printf` format specifiers to show you
    the difference between using them and not using them:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们使用 `printf` 格式化符来展示使用与不使用格式化符之间的区别：
- en: '![Figure 8.17 – Basic usage of the printf command](img/B19682_08_17.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – printf 命令的基本用法](img/B19682_08_17.jpg)'
- en: Figure 8.17 – Basic usage of the printf command
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – printf 命令的基本用法
- en: As shown here, when using the default setting, `printf` prints the string inside
    the double quotes but without a new line at the end. When using the `%s` format
    specifier, the command prints the strings provided as arguments and interprets
    them as characters – in our case, the strings between double quotes. Using `\n`
    will create a new line after each string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，使用默认设置时，`printf` 会打印双引号内的字符串，但行尾不会换行。使用 `%s` 格式化符时，命令打印作为参数提供的字符串，并将其解释为字符——在我们的例子中，就是双引号之间的字符串。使用
    `\n` 会在每个字符串后创建一个新行。
- en: 'Let’s use the `printf` command inside a script now. The following is an example
    of `printf` using the `%s` format specifier. Notice that we use the command using
    single quotes since the output is similar to when using double quotes:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在脚本中使用 `printf` 命令。以下是一个使用 `%s` 格式化符的 `printf` 示例。请注意，由于输出类似于使用双引号，因此我们使用单引号来调用该命令：
- en: '![Figure 8.18 – Using printf inside a script](img/B19682_08_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – 在脚本中使用 printf](img/B19682_08_18.jpg)'
- en: Figure 8.18 – Using printf inside a script
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – 在脚本中使用 printf
- en: 'The preceding figure shows a script that reads two variables from the standard
    input device and then shows both variables to the standard output (the monitor).
    We used the string specifier (`%s`) and the new line escape sequence (`\n`). Now,
    let’s dig deeper into formatting output. In the following examples, we’re using
    the new tab escape sequence (`\t`) together with the newline escape sequence (`\n`)
    and the string specifier. Take a look at the following figure and see how formatting
    works:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了一个脚本，它从标准输入设备读取两个变量，并将这两个变量显示到标准输出（显示器）上。我们使用了字符串格式符（`%s`）和换行符转义序列（`\n`）。现在，让我们深入探讨输出格式化。在接下来的示例中，我们将使用新的制表符转义序列（`\t`）以及换行符转义序列（`\n`）和字符串格式符。请看以下图示，看看格式化是如何工作的：
- en: '![Figure 8.19 – Using tab and newline escape sequences](img/B19682_08_19.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.19 – 使用制表符和换行符转义序列](img/B19682_08_19.jpg)'
- en: Figure 8.19 – Using tab and newline escape sequences
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 使用制表符和换行符转义序列
- en: 'The example we just showed you is using escape sequences to mimic table formatting
    for the output. We can do this by using a script with more complex specifiers
    than the ones already used. In the following example, we’re using the string (`%s`),
    integer (`%d`), and floating (`%f`) specifiers to format a table output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示的示例使用了转义序列来模拟输出的表格格式化。我们可以通过使用一个包含比之前更复杂格式符的脚本来实现这一点。在以下示例中，我们使用了字符串（`%s`）、整数（`%d`）和浮点数（`%f`）格式符来格式化表格输出：
- en: '![Figure 8.20 – Using complex specifiers and escape sequences for table formatting](img/B19682_08_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 使用复杂格式符和转义序列进行表格格式化](img/B19682_08_20.jpg)'
- en: Figure 8.20 – Using complex specifiers and escape sequences for table formatting
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 使用复杂格式符和转义序列进行表格格式化
- en: Let’s detail our `format-output.sh` script. We have a variable called `separator`
    that’s used to print out the graphical border between the header and the contents.
    Then, we have the `header` and `format` variables, each using specifiers and sequences
    for formatting specifics. `header` starts with a new line (`\n`), followed by
    a string specifier with a length of 10 characters wide aligned to the left (`%-10s`),
    followed by eight characters wide aligned to the right (`%8s`), 10 characters
    wide aligned to the right (`%10s`), and 11 characters wide aligned to the right
    (`%11s`) with a new line at the end (`\n`). The format variable is used to format
    the contents of the table by using two string columns (using the `%s` specifier),
    one integer (`%d`), and one floating-point (`%f`) specifier. The integer value
    is used for the product ID and the floating-point value is used for the price.
    We use the `%08d` format specifier to print the ID, which means that the output
    will be 8 characters wide. The `0` character in front indicates that any empty
    spaces will be filled with zeros. This ensures that even when the ID number has
    less than eight digits, the remaining width will be padded with zeros to maintain
    the desired width of eight characters. The result is shown in the lower part of
    the preceding screenshot, where we have a table with products, their IDs, placement,
    and prices.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释一下我们的 `format-output.sh` 脚本。我们有一个名为 `separator` 的变量，用于在标题和内容之间打印出图形边框。接下来，我们有
    `header` 和 `format` 变量，每个都使用格式符和序列来进行格式化。`header` 以换行符（`\n`）开始，后跟一个宽度为 10 字符、左对齐的字符串格式符（`%-10s`），接着是一个宽度为
    8 字符、右对齐的格式符（`%8s`），一个宽度为 10 字符、右对齐的格式符（`%10s`），以及一个宽度为 11 字符、右对齐的格式符（`%11s`），最后以换行符结束（`\n`）。`format`
    变量用于通过两个字符串列（使用 `%s` 格式符）、一个整数（`%d`）和一个浮点数（`%f`）格式符来格式化表格的内容。整数值用于产品 ID，浮点值用于价格。我们使用
    `%08d` 格式符来打印 ID，这意味着输出将是宽度为 8 字符。前面的 `0` 表示任何空格都会被零填充。这确保了即使 ID 号码少于八位数，剩余的宽度也会用零填充，以保持所需的
    8 字符宽度。结果显示在前面截图的下方，我们有一个包含产品、ID、位置和价格的表格。
- en: Thus, `printf` is a very versatile and powerful tool that can be used with great
    results insider your scripts. Now that you know the basic tools for input and
    output data formatting for Bash scripting, let’s proceed to other useful and important
    structures that can be used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`printf` 是一个非常多功能且强大的工具，可以在你的脚本中带来很好的效果。现在你已经掌握了 Bash 脚本中输入和输出数据格式化的基本工具，我们可以继续探讨其他有用和重要的结构。
- en: In the next section, we will cover exit statuses.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论退出状态。
- en: Understanding exit statuses and testing structures
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解退出状态和测试结构
- en: To use conditional and looping statements, we need to understand the `$?`. The
    question mark is the place of an integer that will give the status of the command.
    For example, if the command’s execution was successful, then the value of the
    question mark will be `0` (zero) and the parameter will show `$0`. If the command’s
    execution was not successful, the question mark can have any value starting from
    1 to 255\. Most regularly, the error number is `1`, so the parameter will be `$1`.
    These are also called **exit codes**.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用条件和循环语句，我们需要理解 `$?`。问号的位置是一个整数，表示命令的状态。例如，如果命令执行成功，问号的值将是 `0`（零），参数将显示为
    `$0`。如果命令执行不成功，问号的值可能是从 1 到 255 之间的任何值。通常，错误代码是 `1`，因此参数将是 `$1`。这些也被称为**退出代码**。
- en: 'Alongside exit codes, **testing structures** are also important for conditional
    and looping statements in Bash. These testing structures are usually the building
    blocks for the aforementioned statements. They are considered shell’s keywords
    and are represented like so:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了退出代码，**测试结构**在Bash的条件和循环语句中也很重要。这些测试结构通常是前述语句的构建模块。它们被视为Shell的关键字，表示方式如下：
- en: '`[[ ]]`: Double square brackets are used to test the true or false status of
    a command; it can perform operations on regular expressions too'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ ]]`：双方括号用于测试命令的真假状态；它也可以对正则表达式执行操作'
- en: '`(( ))`: Double brackets are used for arithmetic operations'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(( ))`：双括号用于算术运算'
- en: '`test`: This keyword is used to evaluate expressions such as strings, integers,
    and file properties'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：该关键字用于评估表达式，如字符串、整数和文件属性'
- en: Important note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The syntax of Bash requires spaces to be used before and after brackets – for
    example, `[` `operation ]`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Bash的语法要求在括号前后使用空格——例如，`[` `operation ]`。
- en: 'In conditional statements, some other types of operators are used for testing.
    Let’s take a look at some of the most commonly used conditional operators for
    **integer tests**:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在条件语句中，还会使用一些其他类型的操作符进行测试。我们来看一些常用的条件操作符，用于**整数测试**：
- en: '`-eg`: The equality check operator'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eg`：等于检查操作符'
- en: '`-ne`: The inequality check operator'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ne`：不等于操作符'
- en: '`-lt`: The less than operator'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`：小于操作符'
- en: '`-le`: The less than or equal to operator'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`：小于或等于操作符'
- en: '`-gt`: The greater than operator'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`：大于操作符'
- en: '`-ge`: The greater than or equal operator'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`：大于或等于操作符'
- en: In addition, there are argument operators in Linux shell scripting. The `$0`
    variable represents the command used to run the script, while `$1` through `$n`
    represents the first through *n*th arguments passed to the command. For example,
    `$1` refers to the first argument, `$2` refers to the second argument, and so
    on, where `$n` represents the *n*th argument of the command.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Linux shell脚本中还有参数操作符。`$0` 变量代表用于运行脚本的命令，而 `$1` 到 `$n` 代表传递给命令的第一个到第 *n*
    个参数。例如，`$1` 代表第一个参数，`$2` 代表第二个参数，依此类推，`$n` 代表命令的第 *n* 个参数。
- en: Besides the operators shown in this section, basic mathematical operators are
    also currently used in conditional statements.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本节展示的操作符，基本的数学运算符在条件语句中也会被使用。
- en: 'There are also testing structures for **strings**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 也有用于**字符串**的测试结构：
- en: '`=`: Tests if strings are identical (`==` is also accepted)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`：测试字符串是否相同（`==` 也可以接受）'
- en: '`!=`: Tests if strings are *NOT* identical'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`：测试字符串是否*不*相同'
- en: '`\<` and `\>`: Less than and greater are accepted for string comparison, but
    they must be escaped (we already used the backslash character)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\<` 和 `\>`：小于和大于符号用于字符串比较，但必须进行转义（我们已经使用了反斜杠字符）'
- en: 'There are also testing operators for **file types**, which are in the form
    of options:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 也有用于**文件类型**的测试操作符，它们以选项的形式出现：
- en: '`-f`: Tests for a regular file'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：测试是否为常规文件'
- en: '`-d`: Tests for a directory'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：测试是否为目录'
- en: '`-h` or `-L`: Tests for a symbolic link'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h` 或 `-L`：测试是否为符号链接'
- en: '`-e`: Testing for a file’s existence'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：测试文件是否存在'
- en: 'Here are some other operators that are used for testing:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些用于测试的其他操作符：
- en: '`-a`: The logical AND'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：逻辑“与”操作符'
- en: '`-o`: The logical OR'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`：逻辑“或”操作符'
- en: '`-z`: To check if an input string was entered'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z`：检查是否输入了字符串'
- en: Testing operators are complex and useful, so it’s very important to learn them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 测试操作符既复杂又实用，因此学习它们非常重要。
- en: In the next section, we will cover Bash conditional statements.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Bash的条件语句。
- en: Using conditional if statements
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用条件if语句
- en: Just like in any other programming language, Bash has conditional execution
    statements, such as `if-then-fi`, `if-then-else-fi`, and *nested* `if`, and conditional
    operators such as `&&` (*AND*) and `||` (*OR*). We will show you how to use them
    in this section.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他编程语言一样，Bash也有条件执行语句，如`if-then-fi`、`if-then-else-fi`和*嵌套*`if`，以及条件操作符，如`&&`（*与*）和`||`（*或*）。我们将在本节中展示如何使用它们。
- en: 'We will present the `if` statement in all its appearances (`if-then`, `if-then-else`,
    and nested `if`) in this section:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中展示所有形式的`if`语句（`if-then`、`if-then-else`和嵌套`if`）：
- en: 'In its most common form, the `if-then-fi` statement has the following syntax:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-then-fi`语句在最常见的形式中具有以下语法：'
- en: '[PRE25]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This Bash `if` statement is running `condition` after the `if` keyword. If the
    command is completed successfully, meaning it has an exit status of zero, then
    it will run the commands that are listed after the `then` keyword.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个Bash `if`语句在`if`关键字后运行`condition`。如果命令成功完成，即其退出状态为零，那么它将执行`then`关键字后列出的命令。
- en: 'The `if-then-else-fi` statement is similar to `if-then` and has the following
    syntax:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if-then-else-fi`语句与`if-then`语句类似，具有以下语法：'
- en: '[PRE26]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Similar to the simpler `if-then` statement, `condition` is run, and depending
    on its exit status, the results are different. If it completes successfully, the
    commands after the `then` keyword are executed, but if there is another exit status
    (non-zero), the commands after the `else` keyword are executed. This gives more
    options and alternatives, based on the result of the condition. There are situations
    when you would need to check for more conditions inside a single `if-then` command,
    so you can use nested if statements for this.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与更简单的`if-then`语句类似，`condition`会被执行，并且根据其退出状态，结果会有所不同。如果它成功完成，`then`关键字后的命令将被执行；但是如果有其他退出状态（非零），则`else`关键字后的命令将被执行。这为你提供了更多的选择和替代方案，具体取决于条件的结果。有些情况需要在单个`if-then`命令内部检查更多条件，因此可以使用嵌套的`if`语句来实现。
- en: 'Now, let’s discuss some basic conditional arguments that are used in `if` statements,
    together with some examples:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一些在`if`语句中使用的基本条件参数，并附上一些示例：
- en: 'In this example, we will check if the number a user is typing is even or odd.
    The script will take the input from the user by using the `read` command; then,
    it will check if what remains from its division by two is zero or not. This way,
    it determines if the number is odd or even. We will use the `if-then-else` statement
    for this example, together with the `read` and `printf` commands. The following
    screenshot shows the code and the execution’s output:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将检查用户输入的数字是偶数还是奇数。脚本将使用`read`命令获取用户输入；然后，它将检查该数字除以二的余数是否为零。通过这种方式，它确定数字是奇数还是偶数。我们将在这个例子中使用`if-then-else`语句，并结合`read`和`printf`命令。以下截图展示了代码和执行输出：
- en: '![Figure 8.21 – Script to determine an even or odd number](img/B19682_08_21.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 确定偶数或奇数的脚本](img/B19682_08_21.jpg)'
- en: Figure 8.21 – Script to determine an even or odd number
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 确定偶数或奇数的脚本
- en: 'The following script checks if a filename introduced by the user is indeed
    a file or not by using the `test -f` operator. We will introduce the absolute
    path of the file we want to run a check on. The script is called `testing_file.sh`
    and its code is shown in the following screenshot:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下脚本通过使用`test -f`操作符检查用户输入的文件名是否确实是一个文件。我们将输入要检查的文件的绝对路径。该脚本名为`testing_file.sh`，其代码如下所示：
- en: '![Figure 8.22 – Checking if a filename that’s been introduced is a file](img/B19682_08_22.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.22 – 检查输入的文件名是否为文件](img/B19682_08_22.jpg)'
- en: Figure 8.22 – Checking if a filename that’s been introduced is a file
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22 – 检查输入的文件名是否为文件
- en: 'By running this script, you will be prompted to provide the filename and full
    path of an existing (or not) file. Let’s do some tests. You will see the output
    shown in the following figure. We tested if the script is working correctly in
    three different scenarios: when we do not provide a filename, when we enter a
    correct filename, and when we enter the wrong filename:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本时，系统会提示你提供现有（或不存在）文件的文件名和完整路径。让我们进行一些测试。你将看到下图所示的输出。我们测试了在三种不同情况下脚本是否正常工作：当我们不提供文件名时，当我们输入正确的文件名时，以及当我们输入错误的文件名时：
- en: '![Figure 8.23 – Running the file-checking script](img/B19682_08_23.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.23 – 运行文件检查脚本](img/B19682_08_23.jpg)'
- en: Figure 8.23 – Running the file-checking script
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23 – 运行文件检查脚本
- en: Now that we’ve covered the basics of `if` conditional statement usage, let’s
    proceed to other types of statements, such as looping statements.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经涵盖了`if`条件语句的基本用法，让我们继续学习其他类型的语句，如循环语句。
- en: Using looping statements
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用循环语句
- en: In Bash, `for`, `while`, and `until` commands, and we will show you how to use
    them in this section. Looping statements are used when repeating processes are
    needed, such as looping through several commands until a condition is met.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，`for`、`while` 和 `until` 命令，我们将在本节中向您展示如何使用它们。循环语句用于需要重复处理的情况，例如循环执行多个命令，直到满足某个条件。
- en: Using the for statement
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 for 语句
- en: 'As in any other programming language, the need for iterating appears when repetitive
    tasks have to be done. This means that some commands need to be repeated until
    condition(s) are met. This is similar in Bash as in any other programming language,
    and one of the commands to use is the `for` command. It has the following structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何其他编程语言一样，当需要执行重复任务时，就会出现迭代的需求。这意味着一些命令需要重复执行，直到满足条件。这在Bash中与其他编程语言类似，其中一个可以使用的命令就是`for`命令。它的结构如下：
- en: '[PRE27]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you did not have any interaction with such a statement before, we will help
    you understand what it means. The variables provided through the `var` parameter
    are assigned with a series of values provided through the `list` parameter, in
    a series of iterations. At the start of the iteration, the variable is set with
    the current (or starting) value in the list. Each iteration will use another value
    from the list, until the last item in the list. The number of items in the list
    will set the number of iterations. For each iteration, the commands inside the
    `commands` block will be executed. This is a basic loop we described.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有接触过这样的语句，我们将帮助你理解它的含义。通过`var`参数提供的变量会在每次迭代中被赋予`list`参数中提供的一系列值。在迭代开始时，变量会被设置为列表中的当前（或起始）值。每次迭代将使用列表中的另一个值，直到列表中的最后一项。列表中的项数将决定迭代的次数。在每次迭代中，`commands`块中的命令将被执行。这是我们描述的基本循环。
- en: 'Let’s see some basic uses of the `for` command. We will loop through a statically
    declared array. This means that we will not use the input from our user; instead,
    we will specify the array directly inside the script. We will use a temporary
    variable (or counter) called `i` to iterate through the entire length of the array.
    We use `${array[@]}` to specify the array’s length. The loop will stop when the
    counter (`i`) reaches this length. The following figure shows the script’s code,
    the commands used to run it, and the output. Keep in mind that we provided an
    array that had values already ordered. This is not a sorting algorithm:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`for`命令的一些基本用法。我们将遍历一个静态声明的数组。这意味着我们不会使用用户的输入；相反，我们将在脚本中直接指定数组。我们将使用一个临时变量（或计数器）`i`来遍历数组的整个长度。我们使用`${array[@]}`来指定数组的长度。当计数器（`i`）达到该长度时，循环将停止。下图展示了脚本的代码、运行该脚本的命令以及输出。请记住，我们提供了一个已经排序的数组。这不是排序算法：
- en: '![Figure 8.24 – Iterating through an array using the for statement](img/B19682_08_24.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.24 – 使用 for 语句遍历数组](img/B19682_08_24.jpg)'
- en: Figure 8.24 – Iterating through an array using the for statement
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – 使用 for 语句遍历数组
- en: In the following example, we will bring back the discussion on arrays and use
    some of them inside a `for` statement. This time, we will show you how to sort
    an array. We will use most of the structures we’ve already learned about, such
    as input reading, output formatting, arrays, and `for` statements.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将重新讨论数组，并在`for`语句中使用其中的一些。这次，我们将展示如何对数组进行排序。我们将使用我们已经学习过的大部分结构，例如输入读取、输出格式化、数组和`for`语句。
- en: Important note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Sorting algorithms are outside the scope of this book. We will only use one
    type of sort (bubble) to show you how to use arrays and `for` statements and how
    powerful Bash can be. However, if you plan on doing any serious programming while
    using the shell, we advise you to use another programming language that is more
    suited for this type of action, such as Python. Python is incredibly versatile
    and can successfully be used for many administrative tasks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法超出了本书的范围。我们只使用一种排序方法（冒泡排序）来展示如何使用数组和`for`语句，以及Bash的强大功能。然而，如果你计划在使用Shell时进行任何严肃的编程，我们建议你使用其他更适合这类操作的编程语言，例如Python。Python非常灵活，可以成功用于许多管理任务。
- en: 'Let’s get back to our sorting issue. Let’s say we have a random array that
    we would like to sort. We will use an array that has integer elements only. To
    make things more interesting, we will prompt the user to introduce the array elements
    from the standard input. The following figure shows the code of the script:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到排序问题上。假设我们有一个随机数组，我们希望对其进行排序。我们将使用一个只包含整数元素的数组。为了让事情更有趣，我们将提示用户从标准输入中输入数组元素。下图展示了脚本的代码：
- en: '![Figure 8.25 – Using the bubble sort algorithm to sort an array](img/B19682_08_25.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图8.25 – 使用冒泡排序算法对数组进行排序](img/B19682_08_25.jpg)'
- en: Figure 8.25 – Using the bubble sort algorithm to sort an array
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 使用冒泡排序算法对数组进行排序
- en: Let’s explain the code. We used a variable, `n`, to specify the length of the
    array. Then, we used this variable to iterate through all the numbers provided
    by the user. In the first `for` statement, we iterate through all the numbers
    and carefully increase the counter (with the `I` variable) by each step (the `i++`
    structure). The numbers provided by the user are then stored inside an array called
    `num`. When the sorting starts, we use two nested `for` statements and one `if`
    statement. We make use of a new counter called `j`, which is used to store the
    value of a new consecutive number inside the array. The `if` statement compares
    which of two consecutive numbers inside the array is greater, thus performing
    the switch between the first two elements inside the array. To perform the switch,
    we use a temporary counter called `k` to keep the value of the greater number
    to make the switch between the two numbers that are being compared. The loop is
    finished when all the numbers have been cycled through. The final `for` statement
    prints the contents of the new, sorted array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下代码。我们使用了一个变量`n`来指定数组的长度。然后，我们用这个变量遍历用户提供的所有数字。在第一个`for`语句中，我们遍历所有数字，并小心地通过每一步增加计数器（使用`I`变量）（`i++`结构）。用户提供的数字随后存储在一个名为`num`的数组中。当排序开始时，我们使用两个嵌套的`for`语句和一个`if`语句。我们使用了一个新的计数器`j`，用于存储数组中新的连续数字的值。`if`语句比较数组中连续两个数字哪个更大，从而在数组的前两个元素之间进行交换。为了进行交换，我们使用一个临时计数器`k`来保持较大数字的值，以便交换这两个正在比较的数字。循环在所有数字都被遍历后结束。最终的`for`语句打印出新排序后的数组内容。
- en: 'The user input and the output of the command are shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入和命令输出如下所示：
- en: '![Figure 8.26 – Showing the input and output for our sorting script](img/B19682_08_26.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图8.26 – 显示我们的排序脚本的输入和输出](img/B19682_08_26.jpg)'
- en: Figure 8.26 – Showing the input and output for our sorting script
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 – 显示我们的排序脚本的输入和输出
- en: 'In the preceding example, bubble sort is working as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，冒泡排序的工作原理如下：
- en: The first step is to compare the first two elements in the array, which are
    `45` and `24`, and see which is greater; `45` is greater than `24`, so the new
    array will be `24 45` `56` (the algorithm swaps between `45` and `24`).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是比较数组中的前两个元素，即`45`和`24`，看看哪个更大；`45`大于`24`，所以新的数组将是`24 45` `56`（该算法在`45`和`24`之间进行交换）。
- en: The second step is to compare the next two elements, which are now `45` and
    `56` (because `45` was greater than `24` and is now in the second position; as
    `45` is not greater than `56`, their position will remain unchanged).
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是比较下两个元素，它们现在是`45`和`56`（因为`45`大于`24`，现在排在第二位；由于`45`不大于`56`，它们的位置将保持不变）。
- en: The third step is to do one more pass through all the elements and still do
    the comparison.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三步是再对所有元素进行一次遍历，并继续进行比较。
- en: Important note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Bubble sort is not an efficient sorting algorithm, but it was a good example
    of how to use arrays, `for` and `if` statements, input from the user, and output
    formatting. For more information on the bubble sort algorithm or any other type
    of sorting algorithm, we would advise a thorough online search or that you read
    the titles we have provided in the *Further reading* section at the end of this
    chapter.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序并不是一种高效的排序算法，但它是一个很好的示例，展示了如何使用数组、`for`和`if`语句、用户输入和输出格式化。有关冒泡排序算法或其他任何类型排序算法的更多信息，建议您进行深入的在线搜索，或者阅读本章结尾的*进一步阅读*部分中提供的书目。
- en: Now that you know how to use the `for` statement, let’s proceed to the `while`
    statement.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用`for`语句了，接下来我们来看看`while`语句。
- en: Using the while statement
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`while`语句
- en: 'The `while` loop is similar to the `for` loop, with the difference that it
    is somehow also a combination of the `if` statement. So long as a condition is
    true, the loop is executing the commands. The syntax is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环与 `for` 循环类似，不同之处在于它某种程度上也结合了 `if` 语句。只要条件为真，循环就会执行命令。其语法如下：'
- en: '[PRE28]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The condition is tested every time an iteration is started. If the condition
    remains true, the exit status is zero, and the commands are executed until the
    condition changes its status. Let’s see some examples.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 每次开始一次迭代时，都会测试条件。如果条件保持为真，退出状态为零，命令将继续执行直到条件状态发生变化。我们来看一些例子。
- en: 'In the following script, we’re using a `while` statement to go through a list
    of numbers in descending order:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下脚本中，我们使用 `while` 语句以降序遍历数字列表：
- en: '![Figure 8.27 – Using a while statement](img/B19682_08_27.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.27 – 使用 `while` 语句](img/B19682_08_27.jpg)'
- en: Figure 8.27 – Using a while statement
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27 – 使用 `while` 语句
- en: The `while` statement will evaluate the `[ $max -gt 0 ]` condition and iterate
    until the condition is false. This means that so long as the number you provide
    is greater than (`-gt`) zero, the commands will be executed. The commands inside
    the `while` loop are simply decreasing the number with every iteration. Otherwise,
    you will end up in an infinite loop. Thus, the value of the max variable will
    be lower by one point every time the `while` loop executes. We tested with two
    values, once with 10 and again with 30; you can see the output in *Figure 8**.27*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句会评估 `[ $max -gt 0 ]` 条件，并在条件为假时停止迭代。这意味着，只要你提供的数字大于 (`-gt`) 零，命令就会执行。`while`
    循环内部的命令只是通过每次迭代减少数字。否则，你将陷入无限循环。因此，`while` 循环每执行一次，`max` 变量的值就会减少 1。我们用两个值进行了测试，分别是
    10 和 30；你可以在*图 8.27*中看到输出结果。'
- en: The `while` statement is very useful and straightforward, being a great addition
    to the `for` statement. Now, let’s see the `until` statement.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 语句非常有用且直观，它是对 `for` 语句的一个重要补充。现在，让我们来看一下 `until` 语句。'
- en: Using the until statement
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `until` 语句
- en: 'This looping structure is the opposite of `while`. It uses a condition that
    is false from the start, and while the condition remains false, the commands inside
    the structure will be executed. The syntax is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环结构与 `while` 相反。它使用一个从一开始就是假的条件，只有当条件保持为假时，结构内的命令才会被执行。其语法如下：
- en: '[PRE29]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For a very quick example, let’s redo the `while` loop from the previous example
    by using the `until` statement this time. Here’s the code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 快速示例，让我们将之前的 `while` 循环用 `until` 语句重新做一次。以下是代码：
- en: '![Figure 8.28 – An example of an until statement](img/B19682_08_28.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.28 – 一个 `until` 语句的示例](img/B19682_08_28.jpg)'
- en: Figure 8.28 – An example of an until statement
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 – 一个 `until` 语句的示例
- en: Can you spot the differences between the `until` and `while` loops? In the case
    of `until`, the iteration continues until the value of the variable is equal to
    zero, `[ $max -eq 0 ]`. The commands inside the `until` loop are the same as the
    ones used inside the `while` loop. The condition is different. The output, as
    you might expect, is the same as when using a `while` loop.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找出 `until` 循环和 `while` 循环之间的区别吗？在 `until` 循环中，迭代会继续直到变量的值等于零，`[ $max -eq 0
    ]`。`until` 循环内部的命令与 `while` 循环中的命令相同，唯一不同的是条件。输出结果，正如你预期的那样，和使用 `while` 循环时是一样的。
- en: Before we move on and learn about more advanced programming structures, we’ll
    provide some basic information about controlling the execution of a loop by using
    specific keywords.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续学习更高级的编程结构之前，我们将提供一些关于使用特定关键字控制循环执行的基本信息。
- en: Exiting loop statements
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出循环语句
- en: 'The two commands that are used in Bash to exit loops are `break` and `continue`.
    They are relatively straightforward. Whenever you want to exit a loop, you can
    use one of them. Let’s use a simple script that iterates through a series of integer
    numbers until a specified value is reached and it exits the iteration. Here is
    the code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 中用于退出循环的两个命令是 `break` 和 `continue`。它们非常简单直观。每当你想退出一个循环时，可以使用其中一个。让我们使用一个简单的脚本，遍历一系列整数，直到达到指定值并退出迭代。以下是代码：
- en: '![Figure 8.29 – Exiting a loop using the break command](img/B19682_08_29.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.29 – 使用 `break` 命令退出循环](img/B19682_08_29.jpg)'
- en: Figure 8.29 – Exiting a loop using the break command
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 – 使用 `break` 命令退出循环
- en: 'When executing, the user is asked to introduce the maximum value for the sequence
    and the value of `break`. The `for` loop goes through the sequence until the value
    of break is reached, and it exits the loop. We used the `break` command to exit
    the loop and started the iteration from zero. You can test the outcome with different
    values. The following is the output when using a value of `10` for the maximum
    sequence and a value of `5` for `break`:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 – Output of using the break script example](img/B19682_08_30.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 8.30 – Output of using the break script example
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the loop exits after 5 is reached. However, it shows the value
    of 5, it does not skip it. This can be fixed (it is not necessarily an issue,
    more of an algorithm design decision). Let’s look at the following code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 – Breaking loop optimized](img/B19682_08_31.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Figure 8.31 – Breaking loop optimized
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: For the breaking value to not be shown, we moved the `echo $i` command after
    the conditional if-then statement. This will prevent the script from showing the
    breaking value provided by the user. Both use cases are valid and they provide
    the same output, so the position of the output printing command is only relevant
    to your needs.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will show you how to use the `continue` command
    to exit a loop. The algorithm is similar to the one used in the `break` example,
    except this time, the value provided by the user will not be shown in the output.
    The `break` command will exit the loop when a condition is met, whereas the `continue`
    command will skip the rest of the command execution that is present after the
    condition, when a certain condition is met, and will continue to the next iteration
    of the loop sequence. This difference is sufficient for you to understand the
    differences between `break` and `continue`. Let’s see the code for the same script,
    using the `continue` command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.32 – Using the continue command inside a loop](img/B19682_08_32.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
- en: Figure 8.32 – Using the continue command inside a loop
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the code is similar to what was used in the previous example.
    The only difference is the use of the `continue` command instead of `break`. Now,
    let’s see the output that’s obtained:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.33 – The output when using the continue command](img/B19682_08_33.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: Figure 8.33 – The output when using the continue command
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, the number 5 is not shown, meaning that the
    loop skipped it when the `continue` command is used.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: You now know quite a bit about scripting in Linux. You know how to use variables,
    arrays, if and looping statements, and even exiting loops. In the next section,
    we will show you how to use more advanced programming structures, such as functions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Working with functions
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in most programming languages, `function` keyword, followed by the function’s
    name, as shown in the following syntax:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Alternatively, you can use parentheses after the function’s name, as shown
    in the following syntax:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The name from the syntax is a unique name that the function will use throughout
    the script. The commands are represented by one or more shell commands that are
    executed by the function in their order of appearance. Simplified, you can look
    at functions as scripts inside scripts. Let’s see some examples.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: With the risk of being redundant, we will use one of the scripts we already
    created and use it as a function, just to show you how functions work, for starters.
    We will use the script that sorts numbers in descending order and make it a function.
    But before that, let’s give you a word of caution regarding functions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Functions must be created before they are called. Calling a function is the
    process of running it inside a script. If you create the function after you call
    it, the script will give you an error because Bash is a single-pass interpreter.
    A good practice is to create the functions at the beginning of a script. This
    way, they will be available whenever they’re needed throughout the script.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here it is – our first function is shown in the following screenshot. As
    you can see, first, we created the `sorting` function, and then we called it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34 – Running our first function](img/B19682_08_34.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: Figure 8.34 – Running our first function
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to create and call a function inside a shell script,
    but there is much more to this matter than just that. We will try and give you
    all the necessary information about functions so that you will be able to use
    them in your scripts, but if you want to learn more, please consider the titles
    provided in the *Further* *reading* section.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will walk you through different function capabilities,
    such as output, variables, and array handling.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Advanced function capabilities
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every function inside the Bash shell, as stated before, works like a script
    by itself. This means that it can manage variables, arrays, and output in the
    same way as a script. In this section, we will show you how to use variables,
    arrays, and output inside functions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Using variables inside functions
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Both types of variables (global and local) can be used inside functions. Let’s
    provide an overview of the differences between these two types of variables. The
    global ones are visible and available throughout the system, while the local ones
    are only available inside the function where they were declared. By default, all
    variables in Bash are defined as global variables, including the ones defined
    inside functions. To declare local variables inside functions, we can use the
    `local` keyword. Let’s see a basic example to understand how this works:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.35 – Showing how local and global variables work in functions](img/B19682_08_35.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Figure 8.35 – Showing how local and global variables work in functions
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how the variables were declared. For example, first,
    we declared the `var1='1'` and `var2='2'` variables. By default, they are set
    as global variables. Then, inside the `var_function` function, we modified the
    values of the two variables, but for one of them, we used the `local` keyword
    to define it local to the function. For the other one, we did not use the same
    keyword – we defined it as we did before the function. Thus, when printing the
    variables to the standard output after the function is run, only `var2` will keep
    the value given to it inside the variable, compared to `var1`, which was declared
    locally and had a different value only inside the function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图展示了变量是如何声明的。例如，首先我们声明了 `var1='1'` 和 `var2='2'` 变量。默认情况下，它们被设置为全局变量。然后，在 `var_function`
    函数内，我们修改了这两个变量的值，但其中一个变量我们使用了 `local` 关键字来定义它为函数内局部变量。对于另一个变量，我们没有使用相同的关键字——我们按函数外的定义方式进行定义。因此，当函数运行后打印变量到标准输出时，只有
    `var2` 会保留函数内给定的值，而 `var1` 由于在函数内部是局部定义的，因此其值只在函数内有效。
- en: Using arrays inside functions
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在函数中使用数组
- en: 'Unlike variables, arrays inside functions are somewhat problematic. There are
    two scenarios to consider: one when you need to pass arrays from the script to
    the function, and one when you would need to pass an array from the function back
    to the script. In the first case, you can’t use the array as a function parameter
    because only the first value of the array will be used by the function. Thus,
    the convenient way is to break the array and then rebuild it inside the function,
    even though it sounds and proves unpractical. In the second case, the practice
    of handling arrays is similar to the first scenario as the function will output
    the values in the correct order and the script will reassemble the value into
    an array. Let’s see an example:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量不同，函数中的数组有些问题。需要考虑两种情况：一种是当你需要将数组从脚本传递到函数时，另一种是当你需要将数组从函数返回到脚本时。在第一种情况下，你不能将数组作为函数参数传递，因为函数只会使用数组的第一个值。因此，便捷的做法是将数组拆开，然后在函数内部重新构建它，尽管这听起来不实际，且经验证明确实不太实用。在第二种情况下，处理数组的方式与第一种情况类似，因为函数会按照正确的顺序输出值，而脚本则会将这些值重新组合成数组。来看一个例子：
- en: '![Figure 8.36 – Using arrays inside functions](img/B19682_08_36.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.36 – 在函数中使用数组](img/B19682_08_36.jpg)'
- en: Figure 8.36 – Using arrays inside functions
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.36 – 在函数中使用数组
- en: 'In the preceding example, we used two functions, one for each of the scenarios
    described at the beginning of this subsection. The `test_function_1` function
    inside the script shows the way we can pass array elements to the function. The
    `test_function_2` function shows how arrays are being returned from functions.
    Here’s the output:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了两个函数，每个函数分别处理了前面小节开头描述的两种情况。脚本中的 `test_function_1` 函数展示了我们如何将数组元素传递给函数。`test_function_2`
    函数展示了如何从函数中返回数组。下面是输出结果：
- en: '![Figure 8.37 – Output of using arrays in functions](img/B19682_08_37.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.37 – 在函数中使用数组的输出](img/B19682_08_37.jpg)'
- en: Figure 8.37 – Output of using arrays in functions
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.37 – 在函数中使用数组的输出
- en: At this point, you’ve learned how to create scripts and how to use arrays, variables,
    programming structures, and functions. Now, it’s time to learn how to use `sed`
    and (`g`)`awk` both at the command line and in scripts.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经学习了如何创建脚本，以及如何使用数组、变量、编程结构和函数。现在，是时候学习如何在命令行和脚本中同时使用 `sed` 和 (`g`)`awk`
    了。
- en: Using sed and (g)awk commands
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `sed` 和 (`g`)`awk` 命令
- en: Both `sed` and (`g`)`awk` are advanced tools that are used for manipulating
    text files. `sed` is a stream editor and `awk` is a programming language. We also
    use the `gawk` reference (thus the letter `g` used inside parentheses) as it is
    the GNU implementation of `awk`, offering more features and extensions. Let’s
    learn how to use both of them at the command line.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 和 (`g`)`awk` 都是用于处理文本文件的高级工具。`sed` 是流编辑器，而 `awk` 是一种编程语言。我们还使用 `gawk`
    这个术语（因此括号内的 `g` 字母）是因为它是 `awk` 的 GNU 实现，提供了更多的功能和扩展。让我们学习如何在命令行中使用这两者。'
- en: Using sed at the command line
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在命令行中使用 `sed`
- en: '`sed` is more than a simple command. It is a data stream editor that edits
    files based on a strict set of rules supplied beforehand. Based on these rules,
    the command reads the file line by line and the data inside the file is then manipulated.
    `sed` is a non-interactive stream editor that makes changes based on a script,
    and in this respect, it is well suited for editing more files at once or for doing
    mundane repetitive tasks. The `sed` command’s general syntax is as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 不仅仅是一个简单的命令。它是一个数据流编辑器，基于预先提供的一组严格规则编辑文件。根据这些规则，命令逐行读取文件，然后对文件中的数据进行操作。`sed`
    是一个非交互式流编辑器，它基于脚本进行更改，因此非常适合一次编辑多个文件或执行繁琐的重复任务。`sed` 命令的一般语法如下：'
- en: '[PRE32]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `sed` command uses different script subcommands, and one of the common
    subcommands that’s used is for text substitution. There are many other use cases
    that we will not discuss here, but if you feel the need to learn more about the
    `sed` tool, there are plenty of great materials online and in print. For example,
    the following link could be useful: [https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command](https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command).'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed` 命令使用不同的脚本子命令，其中一个常用的子命令用于文本替换。这里有许多其他用法，我们不会在此讨论，但如果你想了解更多关于 `sed` 工具的信息，网上和书籍中有很多很好的资料。例如，以下链接可能会有所帮助：[https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command](https://www.ibm.com/docs/en/aix/7.2?topic=s-sed-command)。'
- en: 'The common syntax that’s used for text substitution is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 文本替换常用的语法如下：
- en: '[PRE33]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here are some examples of the most common use cases of `sed`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 `sed` 最常见用法的示例：
- en: 'Replace one name with another inside a text file. For this example, we will
    use a new file called `poem` in our home directory. Inside it, we generated a
    random poem. The task is to replace the name `Jane` with `Elane` from within the
    file. The letter `g`, as a flag of the command, specifies that the operation should
    be global – that is, it should be applied to the entire text document. Here is
    the result:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本文件中将一个名称替换为另一个名称。以此示例，我们将在家目录中使用一个名为 `poem` 的新文件。在该文件中，我们生成了一首随机诗歌。任务是将文件中的
    `Jane` 替换为 `Elane`。字母 `g` 作为命令的标志，指定操作应为全局操作——即应应用于整个文本文件。结果如下：
- en: '![Figure 8.38 – Using the sed command to replace a string in a text file](img/B19682_08_38.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.38 – 使用 sed 命令替换文本文件中的字符串](img/B19682_08_38.jpg)'
- en: Figure 8.38 – Using the sed command to replace a string in a text file
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.38 – 使用 sed 命令替换文本文件中的字符串
- en: If you check the original file using the `cat` command, you will see that `sed`
    only delivered the changed name result to the standard output and did not make
    any changes to the original file. To make the changes to the file permanent, you
    will have to use the `-``i` attribute.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `cat` 命令检查原始文件，你会发现 `sed` 只将更改后的名称结果输出到标准输出，并没有对原始文件进行任何更改。要使更改永久生效，你必须使用
    `-i` 属性。
- en: 'In the following example, we’re adding new spaces at the beginning of each
    line and redirecting the output to a new file. We’re using the same `poem` file
    as before. The beginning of a file is represented by the `^` character:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将在每行的开头添加新空格，并将输出重定向到一个新文件。我们使用的是之前的 `poem` 文件。文件的开头由 `^` 字符表示：
- en: '![Figure 8.39 – Using sed to add spaces](img/B19682_08_39.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.39 – 使用 sed 添加空格](img/B19682_08_39.jpg)'
- en: Figure 8.39 – Using sed to add spaces
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.39 – 使用 sed 添加空格
- en: 'We will use `sed` to show only the second line from the `poem` file and to
    show all the lines except for *line 2*:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `sed` 仅显示 `poem` 文件中的第二行，并显示除了*第 2 行*之外的所有行：
- en: '![Figure 8.40 – Using sed to show specific lines in a file](img/B19682_08_40.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.40 – 使用 sed 显示文件中的特定行](img/B19682_08_40.jpg)'
- en: Figure 8.40 – Using sed to show specific lines in a file
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.40 – 使用 sed 显示文件中的特定行
- en: 'Let’s show only *lines 4 to 6* from a file – in our case, the `/``etc/passwd`
    file:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们仅显示文件中的*第 4 行到第 6 行*——在我们的例子中，是 `/etc/passwd` 文件：
- en: '![Figure 8.41 – Using sed to show a specific number of lines in a text file](img/B19682_08_41.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.41 – 使用 sed 显示文本文件中的特定行数](img/B19682_08_41.jpg)'
- en: Figure 8.41 – Using sed to show a specific number of lines in a text file
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.41 – 使用 sed 显示文本文件中的特定行数
- en: 'Here is a more practical exercise. We will show the contents of `/etc/apt/sources.list`
    from Ubuntu without the commented lines. To do this, use the following command:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个更实际的练习。我们将显示 Ubuntu 中 `/etc/apt/sources.list` 的内容，排除注释行。为此，请使用以下命令：
- en: '[PRE34]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 8.42 – Use of sed to show only lines with no comments](img/B19682_08_42.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: Figure 8.42 – Use of sed to show only lines with no comments
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsection, we will explore the `awk` command at the command
    line.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Using awk from the command line
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`awk` is much more than a simple command – it is a pattern-matching language.
    It is a full-fledged programming language that was the base for PERL. It is used
    for data extraction from text files, with a syntax similar to C. It sees a file
    as being composed of fields and records. The general structure of the `awk` command
    is as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The true power of `awk` is beyond the scope of this chapter, so we will show
    no more than one simple example of its use that could prove practical for a future
    system administrator.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will generate a list containing the names of all the packages
    installed by Ubuntu. We only want to print the name of each package, not all the
    other details. For this, we will use the following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This command is only showing the names of the packages that have been installed.
    Here is the output:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.43 – Using awk to generate a list of package names](img/B19682_08_43.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: Figure 8.43 – Using awk to generate a list of package names
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Generally, to see the installed packages in Ubuntu, we would run the `dpkg -l`
    command. In the preceding example, we piped the output of that command to the
    `awk` command, which printed the second column (field) from the `dpkg -l` output
    (`'{print $2}'`). Then, we redirected everything to a new file called `package-list`
    and used the `tail` command to see the last 10 lines of the newly created file.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Both `sed` and `awk` are very powerful tools, and we have merely scratched the
    surface of what they can do. Please feel free to dig deeper into these two awesome
    tools.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Using scripts to showcase interprocess communication
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`producer.sh` and `consumer.sh`), thus mimicking the producer and consumer
    processes. We hope that the use of such simple models will still provide a reasonable
    analogy for real-world applications.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at shared storage, named and unnamed pipes, and sockets IPC
    mechanisms, all of which we introduced in [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104)
    but did not cover in detail.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Shared storage
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its simplest form, the `storage` file.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: In this simple use case, the obvious challenge is the integrity of the read/write
    operations due to possible race conditions between the underlying operations.
    To avoid race conditions, the file must be locked during write operations to prevent
    overlapping I/O with another read or write action. To keep things simple, we’re
    not going to resolve this problem in our naive examples, but we thought it’s worth
    calling it out.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the producer writes a new set of data (`10` random UUID strings)
    every `5` seconds to the `storage` file. The following screenshot shows the producer’s
    script:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.44 – The producer script (using shared storage)](img/B19682_08_44.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.44 – 生产者脚本（使用共享存储）](img/B19682_08_44.jpg)'
- en: Figure 8.44 – The producer script (using shared storage)
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.44 – 生产者脚本（使用共享存储）
- en: 'The consumer reads the content of the `storage` file every second. The following
    screenshot shows the consumer’s script:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者每秒钟读取一次 `storage` 文件的内容。下图显示了消费者的脚本：
- en: '![Figure 8.45 – The consumer script (using shared storage)](img/B19682_08_45.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.45 – 消费者脚本（使用共享存储）](img/B19682_08_45.jpg)'
- en: Figure 8.45 – The consumer script (using shared storage)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.45 – 消费者脚本（使用共享存储）
- en: 'When running both scripts, the producer creates random strings and writes them
    to the `storage` file, and the consumer reads the producer’s output from the same
    file. The output is shown in the following screenshot:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 运行两个脚本时，生产者生成随机字符串并将其写入 `storage` 文件，而消费者从同一个文件中读取生产者的输出。输出如下截图所示：
- en: '![Figure 8.46 – The producer (left) and consumer (right) communicating through
    shared storage](img/B19682_08_46.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.46 – 生产者（左）和消费者（右）通过共享存储进行通信](img/B19682_08_46.jpg)'
- en: Figure 8.46 – The producer (left) and consumer (right) communicating through
    shared storage
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.46 – 生产者（左）和消费者（右）通过共享存储进行通信
- en: Next, we will show you how unnamed pipes work.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向您展示无名管道是如何工作的。
- en: Unnamed pipes
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无名管道
- en: '**Unnamed** or **anonymous** pipes, also known as **regular** pipes, feed the
    output of a process to the input of another one. Using our producer-consumer model,
    the simplest way to illustrate an unnamed pipe as an IPC mechanism between the
    two processes would be to do the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**无名**管道或**匿名**管道，也称为**常规**管道，将一个进程的输出传递到另一个进程的输入。以我们的生产者-消费者模型为例，最简单的方式来说明无名管道作为进程间通信机制的使用方式是：'
- en: '[PRE37]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The key element of the preceding illustration is the pipe (`|`) symbol. The
    left-hand side of the pipe produces an output that’s fed directly to the right-hand
    side of the pipe for consumption. To accommodate the anonymous pipe IPC layer,
    we’ll make two new scripts called `producer2.sh` and `consumer2.sh`. The code
    is shown in the following screenshot:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 前述示意图中的关键元素是管道符号 (`|`)。管道的左侧产生一个输出，并直接传递给管道右侧进行消费。为了适应匿名管道 IPC 层，我们将创建两个新的脚本，分别叫做
    `producer2.sh` 和 `consumer2.sh`。代码如下截图所示：
- en: '![Figure 8.47 – The producer2 (left) and consumer2 (right) scripts (using an
    unnamed pipe)](img/B19682_08_47.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.47 – 生产者2（左）和消费者2（右）脚本（使用无名管道）](img/B19682_08_47.jpg)'
- en: Figure 8.47 – The producer2 (left) and consumer2 (right) scripts (using an unnamed
    pipe)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.47 – 生产者2（左）和消费者2（右）脚本（使用无名管道）
- en: 'In our modified implementation, `producer2.sh` prints some data to the console
    (`10` random UUID strings). `consumer2.sh` reads and displays either the data
    coming through the `/dev/stdin` pipe or the input arguments if the pipe is empty.
    *Line 6* in the `consumer2.sh` script checks the presence of piped data in `/dev/stdin`
    (`0` for `fd0`):'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改后的实现中，`producer2.sh` 向控制台打印一些数据（`10` 个随机的 UUID 字符串）。`consumer2.sh` 读取并显示通过
    `/dev/stdin` 管道传来的数据，或者在管道为空时显示输入的参数。`consumer2.sh` 脚本中的 *第 6 行* 检查 `/dev/stdin`
    中是否有管道数据（`fd0` 对应的值为 `0`）：
- en: '[PRE38]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the producer-consumer communication is shown in the following
    screenshot:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者-消费者通信的输出如下截图所示：
- en: '![Figure 8.48 – The producer feeding data into a consumer through an unnamed
    pipe](img/B19682_08_48.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.48 – 生产者通过无名管道将数据传递给消费者](img/B19682_08_48.jpg)'
- en: Figure 8.48 – The producer feeding data into a consumer through an unnamed pipe
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.48 – 生产者通过无名管道将数据传递给消费者
- en: The output clearly shows the data being printed out by the consumer process.
    (Note the `"Consumer data:"` header preceding the UUID strings.)
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清晰地显示了消费者进程打印的数据。（请注意 `"Consumer data:"` 标题前面的 UUID 字符串。）
- en: One of the problems with IPC anonymous pipes is that the data that’s fed between
    the producer and consumer is not persisted through any kind of storage layer.
    If the producer or consumer processes are terminated, the pipe is gone, and the
    underlying data is lost. Named pipes solve this problem, as we will show you in
    the next section.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 匿名管道的一个问题是，生产者和消费者之间传输的数据并没有通过任何存储层持久化。如果生产者或消费者进程被终止，管道会消失，底层数据也会丢失。命名管道解决了这个问题，接下来我们将在下一节中展示。
- en: Named pipes
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名管道
- en: '**Named pipes**, also known as **First In, First Outs** (**FIFOs**), are similar
    to traditional (unnamed) pipes but substantially different in terms of their semantics.
    An unnamed pipe only persists for as long as the related process is running. However,
    a named pipe has backing storage and will last so long as the system is up, regardless
    of the running status of the processes attached to the related IPC channel.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a named pipe acts as a file, and it can be deleted when it’s no
    longer being used. Let’s modify our producer and consumer scripts so that we can
    use a named pipe as their IPC channel:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.49 – The producer3 (left) and consumer3 (right) scripts (using named
    pipe)](img/B19682_08_49.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
- en: Figure 8.49 – The producer3 (left) and consumer3 (right) scripts (using named
    pipe)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The named pipe is `pipe.fifo` (*line 3* in both scripts). The pipe file is created
    (if it’s not already present) by either the producer or consumer when they start
    (*line 6*). The related command is `mkfifo` (see `man mkfifo` for more information).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'The producer writes a random UUID to the named pipe every second (*line 14*
    in `producer3.sh`), where the consumer immediately reads it (*lines 10* to *12*
    in `consumer3.sh`):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.50 – producer3 (left) and consumer3 (right) communicating through
    a named pipe](img/B19682_08_50.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: Figure 8.50 – producer3 (left) and consumer3 (right) communicating through a
    named pipe
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: We started both scripts – the producer and the consumer – in an arbitrary order.
    After a while, we stopped (interrupted) the consumer (*step 1*). The producer
    continued to run but automatically stopped sending data to the pipe. Then, we
    started the consumer again. The producer immediately resumed sending data to the
    pipe. After a while, we stopped the producer (*step 2*). This time, the consumer
    became idle. After starting the producer again, both resumed normal operation,
    and data began flowing through the named pipe. This workflow has shown the persistence
    and resilience of the named pipe, regardless of the running status of the producer
    or consumer processes.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Named pipes are essentially queues, where data is queued and dequeued on a first-come-first-served
    basis. When more than two processes communicate on the IPC named pipe channel,
    the FIFO approach may not fit the bill, especially when specific processes demand
    a higher priority for data processing. Next, we will show you how sockets work.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of IPC **socket-based facilities**:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '**IPC sockets**: Also known as Unix domain sockets'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network sockets**: **Transport Control Protocol** (**TCP**) and **User Datagram
    Protocol** (**UDP**) sockets'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPC sockets use a local file as a **socket address** and enable bidirectional
    communication between processes on the same host. On the other hand, **network
    sockets** extend the IPC data connectivity layer beyond the local machine via
    TCP/UDP networking. Apart from the obvious implementation differences, the IPC
    socket’s and network socket’s data communication channels behave the same.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Both sockets are configured as streams, support bidirectional communication,
    and emulate a client/server pattern. The socket’s communication channel is active
    until it’s closed on either end, thereby breaking the IPC connection.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Let’s adapt our producer-consumer model to simulate an IPC socket (Unix domain
    socket) data connectivity layer. We’ll use `netcat` to handle the underlying client/server
    IPC socket’s connectivity. `netcat` is a powerful networking tool for reading
    and writing data using TCP, UDP, and ICP socket connections. If `netcat` is not
    installed by default on your Linux distribution of choice, you may look to install
    it as follows.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian, use the following command:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On Fedora/RHEL, use the following command:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: For more information about `netcat`, please refer to the related system reference
    manual (`man netcat`).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will use a `producer4.sh` file and a `consumer4.sh`
    file. The code for each file is shown in the following screenshot:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.51 – The producer4 (left) and consumer4 (right) scripts (using IPC
    sockets)](img/B19682_08_51.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: Figure 8.51 – The producer4 (left) and consumer4 (right) scripts (using IPC
    sockets)
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'The producer acts as the server by initiating a `netcat` listener endpoint
    using an IPC socket (the last line in `producer4.sh`):'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `-l` option indicates the listener (server) mode, while the `-U "${SOCKET}"`
    option parameter specifies the IPC socket type (Unix domain socket). The consumer
    connects to the `netcat` server endpoint as a client with a similar command (the
    last line in `consumer4.sh`). The producer and consumer both use the same (shared)
    IPC socket file descriptor (`/var/tmp/ipc.sock`) for communication.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The producer sends random UUID strings every second to the consumer (the `while`-`do`-`done`
    structure in `producer4.sh`). The related output is captured in `stdout` with
    the `tee` command before being piped to `netcat`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.52 – producer4 (left) and consumer4 (right) communicating through
    an IPC socket](img/B19682_08_52.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: Figure 8.52 – producer4 (left) and consumer4 (right) communicating through an
    IPC socket
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: The consumer gets all the messages (UUIDs) that have been generated by the producer.
    To show you that the consumer listens, we first started the consumer script, which
    generated two errors, so long as the producer was not sending data through the
    socket. Once we started the producer script, the consumer started to receive data.
    When we interrupted the producer, the consumer stopped immediately.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: In our producer-consumer model, we used `netcat` for the IPC socket communication
    layer. Alternatively, we could use `socat`, a similar networking tool. In the
    next section, we will show you a quick example of using a script for a specific
    Linux administrative task. As a bonus, we will also show you how to build applications
    from source.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Scripting for administrative tasks
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scripting in a Linux operating system is mainly useful when it can help with
    mundane administrative tasks. This way, you can automate your workflow in ways
    that will make your job easier and more enjoyable. There are many use cases of
    shell scripts, and we will only provide you with a quick and easy example, hoping
    that it will suffice for understanding how a script can be used for a sysadmin
    task.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will show you how to build a distribution-specific
    package from a source. This is something that should have been presented to you
    in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), but at that time, you did
    not know how to create a script. In this chapter, we only used Ubuntu 22.04.2
    LTS for our examples. In the following sections, we will use Fedora 37 Server
    Edition for our examples.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Creating scripts for system administrative tasks
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will show you a couple of scripts for administrative tasks.
    As we stated at the beginning of this chapter, a shell script is a sequence of
    Bash commands that are executed when the file is running. In the following subsections,
    we will create two scripts that will do two different administrative tasks.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: An updating script example
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This script will use the `dnf update` command to update the system at a specified
    time. It is a very basic script that runs just a simple command and shows some
    messages to standard output. Remember that we will be using a Fedora Server distribution
    this time. The simplest way would be to run the following command inside the script:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The issue is that it requires the `sudo` password. This defies the purpose
    of automation because the user must provide the password manually. Let’s learn
    how to overcome this issue. First, let’s see the code of the script:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.53 – A simple update script](img/B19682_08_53.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: Figure 8.53 – A simple update script
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you want the command to be run without the `sudo` password, you will
    have to edit the `/etc/sudoers` file and modify/add some things.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Please take into consideration that this method will have system-wide effects,
    not only on the script you want to run. It is not considered a safe measure and
    we advise you to use it with extreme care and consideration on any production
    system.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the comment before `%wheel` in the following line:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will provide a password-less action for every user that is in the wheel
    group. This should include the user you are using. If it wasn’t inside the `wheel`
    group, you wouldn’t be able to use `sudo` with it. In our case, the `packt` user
    is inside the `wheel` group. To test if it works, you can run the script as a
    regular user and see if the prompt for the `sudo` password will appear.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will have to schedule the script to run at a certain time. Don’t forget
    to make your script file executable to be able to run it. As we are using a server
    distribution, we assume that this machine is running 24/7 without interruptions,
    so running at startup would make no sense. Furthermore, we want to ensure that
    the system is always up to date. To schedule the script, we will use `cron` and
    `crontab`. We will show you how they work in the next section.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling scripts in Linux with cron
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `crontab` might look scary at first, but once you get to know it, you
    will find it very useful. Perhaps the most intimidating aspect of using `cron`
    jobs is the definition process, especially the `cron` date is provided inside
    the `/``etc/crontab` file:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.54 – Example of a cron job definition in /etc/crontab](img/B19682_08_54.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
- en: Figure 8.54 – Example of a cron job definition in /etc/crontab
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'We believe that the preceding screenshot is self-explanatory. Now, let’s set
    up a new `cron` job for our updating script. We will use the `crontab -e` command.
    This command will use the default shell text editor, which in our case (in Fedora)
    is Vim. Running the `crontab -e` command will start a new Vim instance where the
    job should be written. Here is our code:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let’s explain this. In the preceding example, we set the new update script file
    to run at 23:00 every Sunday. The user that is running it is `packt`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the line of code is created, you can check if the `cron` job was created
    by using the `crontab -l` command. If you want to see the `cron` jobs of certain
    users, you can use the following command:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, `packt` is our user. The following snippet shows the code, which can
    be enhanced inside `crontab` with an output and error message redirection to `/dev/null`.
    This could be useful when we don’t want to see the command’s output or if any
    errors occur and we don’t need to see them. The line would be modified as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`crontab` is a powerful tool that will prove of great help whenever you need
    to schedule tasks in Linux. However, it is not the only tool available for the
    job. Feel free to explore other tools available, such as the `at` command. Next,
    we will go through another short script for backing up files.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: A backup script example
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another common use for scripting is for **backing up** files. We will create
    a new script for this task and we will schedule it according to our needs. The
    script’s code is shown in the following screenshot:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.55 – A short backup script](img/B19682_08_55.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: Figure 8.55 – A short backup script
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: The code is backing up the `/home/packt` directory to the `/mnt/backup` directory.
    The contents of `/home/packt` will be archived using the `tar` command and saved
    as `.tgz` files using the current date and hostname for the filename.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Using the date format can be daunting and intimidating at first, but knowing
    how to use it in your scripts will prove invaluable. Use the `date --help` command
    for more information.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will show you how to create a small random password
    generator in Bash.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: A random password generator script
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keeping your online or local accounts secure is extremely important, so secure
    passwords should be used as a general rule. We will provide you with an example
    of a script that generates random passwords.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many password generators available to use in Linux, but we thought
    that it would be fun if you created such a small script by yourself. One default
    password-generating app available in Bash is `pwmake`, for example. However, we
    will create our own password-generating script. We will use `openssl` and an encoding
    mechanism called `base64`. For more information, go to [https://developer.mozilla.org/en-US/docs/Glossary/Base64](https://developer.mozilla.org/en-US/docs/Glossary/Base64).
    Keep in mind that there are many other ways to generate random characters in Linux,
    one highly used being the `/dev/urandom` pseudo-random number generator. Feel
    free to explore as many ways as you like. In the meantime, here is our code for
    the password-generating script:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.56 – Password-generating script](img/B19682_08_56.jpg)'
  id: totrans-522
  prefs: []
  type: TYPE_IMG
- en: Figure 8.56 – Password-generating script
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the script, you will be prompted to provide the number of characters
    you want to use and the number of passwords to be generated:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.57 – The output of running the password-generating script](img/B19682_08_57.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
- en: Figure 8.57 – The output of running the password-generating script
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Scripting is an invaluable task you should master. We barely scratched the surface
    of shell scripting, but the information in this chapter should give you a good
    start so that you can start developing sysadmin scripts.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: In the next subsection, we will show you how to package your scripts into full-fledged
    apps that can be installed on the Linux command line. This is an addition to [*Chapter
    3*](B19682_03.xhtml#_idTextAnchor075), where you learned about Linux package management.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Packaging scripts
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash scripts are pieces of software like any other, so they can be deployed
    with Linux distributions as platform-specific packages. Just like you would package
    any other piece of software code, you can package a piece of shell scripting code.
    In this section, as an add-on to the knowledge you gathered in [*Chapter 3*](B19682_03.xhtml#_idTextAnchor075),
    we will show you how to package a Bash script. As stated before, the information
    provided here can easily be used for other software sources (usually, in Linux,
    there is C/C++, Python, Rust, Java, or Go). In the next subsection, we will show
    you how to create an RPM package for RHEL-based distributions. We will use Fedora
    Linux 37 in our example.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Creating RPM packages from source
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create an RPM package, we will use the password generator script we developed
    in the previous section. Before going into more details, we’ll provide a short
    word on programming language types and where Bash fits in.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, software programs are developed using human-readable source code.
    This code needs to be translated into machine code so that the computer will understand
    it. There are several large generic types of programming languages: **interpreted**
    (such as Python or Bash – which is a CLI language but still considered an interpreted
    language) and **compiled** (such as C/C++, Java, and Go) are the widely known
    ones. The Bash source code is executed line by line, without prior compilation
    into specific machine code. For more information, check out [https://en.wikipedia.org/wiki/List_of_programming_languages_by_type](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type).'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Often, the software source code is distributed in the form of compressed archives
    (`.tar.gz` files or tarballs) that are then packaged into RPM packages. The archive
    usually consists of the source code file and a license file. This license file
    offers information about the type of license the software is distributed with.
    In the case of **free and open source software** (**FOSS**), the license is usually
    GPLv3 or GLPLv3, but other types such as the MIT license or Apache and BSD licenses
    are also used.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information on FOSS license types, check out [https://en.wikipedia.org/wiki/Comparison_of_free_and_open-source_software_licenses](https://en.wikipedia.org/wiki/Comparison_of_free_and_open-source_software_licenses).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the necessary steps for creating an RPM package from a Bash
    script:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '`passgen-0.1`.'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LICENSE.txt` and placed inside the newly created directory. We will use the
    GPLv3 open source license. The text to be added to your file can be found under
    the *How to Apply These Terms to Your New Programs* section at [https://www.gnu.org/licenses](https://www.gnu.org/licenses).'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`passgen_script.sh` file inside the new directory and change its name to `passgen-0.1.sh`.'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`passgen-0.1.sh` script to the Filesystem Hierarchy Standard `$PATH` using
    the `install` command. We use the `install` command because our simple Bash script
    does not need any dependencies:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`tar.gz` archive with the following command:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: sudo dnf install rpmdevtools
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Set up the workspace**: To set up the workspace, we will run the following
    application:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 8.58 – The rpmbuild’s directory structure](img/B19682_08_58.jpg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
- en: Figure 8.58 – The rpmbuild’s directory structure
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: The `BUILD` directory contains information about the build process; the `RPMS`
    directory contains binary RPMs; the `SOURCES` directory contains the tarball of
    the compressed source code; the `SPECS` directory contains the SPEC file; and
    the `SRPMS` directory contains source RPMs.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '`~/rpmbuild/SOURCES` directory with the following command (from within the
    `passgen-0.1` directory):'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '~/rpmbuild/SPECS/ directory, after which you will see that a new file called
    passgen.spec was created.The new `SPEC` file contains automatically generated
    lines with specific RPM macros defined. We will not get into much detail about
    macros, but you can find more information at [https://rpm-software-management.github.io/rpm/manual/macros.html](https://rpm-software-management.github.io/rpm/manual/macros.html).
    As Bash is an interpreted language, some default specifications from the `SPEC`
    file are not needed, such as `BuildRequires`, which was deleted. For the `%build`
    section, we did not provide any information as Bash does not need anything specific.
    The `SPEC` file is shown in the following screenshot:'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Figure 8.59 – The SPEC file’s entries](img/B19682_08_59.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
- en: Figure 8.59 – The SPEC file’s entries
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '`SPEC` file, but there are other use cases, such as building an RPM from a
    `rpmbuild`, but the options are different. When building source RPMs, we will
    use the `-bs` option, when rebuilding RPMs from source, we will use the `--rebuild`
    option, and when building binary RPMs from source, we will use the `-bb` option.
    In our case, we will create a binary from source and use the following command:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Figure 8.60 – The new RPM binary package](img/B19682_08_60.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
- en: Figure 8.60 – The new RPM binary package
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Here you are, building your very first RPM binary package from a Bash script
    file! You can do this for any type of source file you might develop. Building
    binary packages is not a very difficult task, and with good documentation about
    the specifics of macros used in the `SPEC` file, you are good to go. More information
    about the available documentation on this matter can be found in the *Further*
    *reading* section.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create Bash scripts in Linux. You now know
    about shell variables and script variables, as well as how to use programming
    structures such as loops, conditionals, and arrays inside scripts. You now further
    understand how interprocess communication works. The skills you have learned will
    help you create scripts in any Linux distribution. When you are creating scripts,
    you will put your text editor knowledge into action too. You will use the skills
    that you’ve learned regarding Bash scripting in many aspects of your everyday
    job as a system administrator too.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to manage security in Linux, the access
    control mechanisms, AppArmor and SELinux, and firewalls. This skill is important
    for any administrator and must be part of any advanced training.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered Linux Bash scripting. Here are some questions for
    you to test your knowledge and for further practice:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: What are arrays and how are they used in Bash scripts? Can there be hybrid types?
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Think of their types, how they are defined, and how they are used.'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is an infinite loop?
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: This is something you would not like to use but should know how to
    escape if needed.'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How many types of loops can be used in a Bash script?
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Not that many, but more than conditional loops.'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find out how to build a DEB binary package.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Use the examples from Debian, which can be found at [https://www.debian.org/doc/manuals/maint-guide/build.en.html](https://www.debian.org/doc/manuals/maint-guide/build.en.html)
    and [https://wiki.debian.org/HowToPackageForDebian](https://wiki.debian.org/HowToPackageForDebian).'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-577
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, please refer to
    the following resources:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Administration Best Practices*, by Scott Alan Miller, published by Packt'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Command Line and Shell Scripting Techniques*, by Vedran Dakic and Jasmin
    Redzepagic, published by Packt'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation from [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/packaging_and_distributing_software/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/packaging_and_distributing_software/index),
    [https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/](https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/)
    (RPM macros), and [rpm.org](http://rpm.org)
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
