<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Managing Configuration</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Grouping configuration files in directories</li><li class="listitem" style="list-style-type: disc">Keeping configuration under version control</li><li class="listitem" style="list-style-type: disc">Configuring host roles using groups</li><li class="listitem" style="list-style-type: disc">Building groups using regular expressions</li><li class="listitem" style="list-style-type: disc">Using inheritance to simplify configuration</li><li class="listitem" style="list-style-type: disc">Defining macros in a resource file</li><li class="listitem" style="list-style-type: disc">Dynamically building host definitions</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Introduction</h1></div></div></div><p>A major downside of Nagios Core's configuration being so flexible is that without proper management, a configuration can easily balloon out into hundreds of files with thousands of objects, all having unclear dependencies. This can be frustrating when attempting to make significant changes to a configuration, or even for something as simple as removing a host, sifting through dependencies to find what's causing errors in the configuration and prevents you from restarting Nagios Core.</p><p>It's therefore important to build your configuration carefully using as much abstraction as possible, to allow adding, changing, and removing hosts and service definitions from the configuration painlessly, and to avoid duplication of configuration. Nagios Core provides a few ways of dealing with this, most notably in the judicious use of groups and templates for the fundamental objects. Duplication of network-specific and volatile data, such as passwords, is also to be avoided; it's best done with the use of custom macros defined in a resource file.</p><p>This chapter's recipes will run through some examples of good practice for the configuration of a large network. The most important recipes are the first two, <em>Grouping configuration files in directories</em> and <em>Configuring host roles using groups</em>. If you're looking to untangle and revamp a messy configuration, then these two recipes would be the best place to start.</p><p>At the end of the chapter, the final recipe, <em>Dynamically building host definitions</em>, will show one of the primary advantages of a tidy configuration in being able to easily generate configuration according to a list of hosts and services kept in some other external information source, such as a <strong>Configuration Management Database</strong> (<strong>CMDB</strong>).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Grouping configuration files in directories</h1></div></div></div><p>In this recipe, we'll learn to group <a id="id530" class="indexterm"/>
<a id="id531" class="indexterm"/>configuration files in directories to greatly ease the management of configuration. We'll do this by configuring Nagios Core to load every file it can find ending with a <code class="literal">.cfg</code> extension in a given directory, including recursing through subdirectories. The end result will be that to have Nagios Core load a file, we only need to include it somewhere in that directory with an appropriate extension; we don't need to define exactly which files are being loaded in <code class="literal">nagios.cfg</code>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec305"/>Getting ready</h2></div></div></div><p>You will need to have a server running Nagios Core 3.0 or later, and have access to the command line to change its configuration. You should be familiar with the loading of individual configuration files using the <code class="literal">cfg_file</code> directive<a id="id532" class="indexterm"/> in <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>.</p><p>In particular, you should have a directory prepared that contains all of the configuration files you would like to be loaded by Nagios Core. In this example, we'll prepare a new directory called <code class="literal">/usr/local/nagios/etc/naginet</code>, which will contain three configuration files, each defining information for one host:</p><div><pre class="programlisting">
<strong># ls -1 /usr/local/nagios/etc/naginet</strong>
<strong>athens.cfg</strong>
<strong>ithaca.cfg</strong>
<strong>sparta.cfg</strong>
</pre></div><p>You will need to ensure that the directory, files, and subdirectories within it are all readable (though not necessarily owned) by the <code class="literal">nagios</code> user.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec306"/>How to do it...</h2></div></div></div><p>We can arrange for Nagios Core to include all the files in a directory as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the <code class="literal">nagios.cfg</code> file. In the default installation, it is located at <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>. <div><pre class="programlisting">
<strong># vi nagios.cfg</strong>
</pre></div></li><li class="listitem">Edit the file, and below any other <code class="literal">cfg_file</code> or <code class="literal">cfg_dir</code> directive<a id="id533" class="indexterm"/>s, add the following line referring to the absolute path of the directory containing your <code class="literal">.cfg</code> files:<div><pre class="programlisting">cfg_dir=/usr/local/nagios/etc/naginet</pre></div><p>Note that this directive is <code class="literal">cfg_dir</code>, rather than <code class="literal">cfg_file</code>.</p></li><li class="listitem">Remove any <code class="literal">cfg_file</code> definitions pointing to <code class="literal">.cfg</code> files in the new directory. This is to prevent loading the same objects twice. In our example, we would need to comment out our previous rules loading these files individually:<div><pre class="programlisting">
<strong>#cfg_file=/usr/local/nagios/etc/naginet/sparta.cfg</strong>
<strong>#cfg_file=/usr/local/nagios/etc/naginet/athens.cfg</strong>
<strong>#cfg_file=/usr/local/nagios/etc/naginet/ithaca.cfg</strong>
</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, Nagios Core should have loaded all of the files with the extension <code class="literal">.cfg</code> found in the <code class="literal">naginet</code> directory or any of its subdirectories, saving us the burden of specifying them individually.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec307"/>How it works...</h2></div></div></div><p>At load time, Nagios Core interprets the <code class="literal">cfg_dir</code> directive to mean that it should identify all of the <code class="literal">.cfg</code> files in a particular directory, including <a id="id534" class="indexterm"/>
<a id="id535" class="indexterm"/>recursing through its subdirectories. It ignores the files that do not have that extension, allowing us to include metadata or other file types (such as version control information directories) without causing problems.</p><p>As a result, defining a new host or service becomes as simple as adding the file in an appropriate included directory, without needing to edit <code class="literal">nagios.cfg</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec308"/>There's more...</h2></div></div></div><p>It's important to note that this directive will include all the <code class="literal">.cfg</code> files in subdirectories as well. This might allow us to meaningfully group the configuration files:</p><div><pre class="programlisting">
<strong>$ find /usr/local/nagios/etc/naginet</strong>
<strong>/usr/local/nagios/etc/naginet</strong>
<strong>/usr/local/nagios/etc/naginet/hosts</strong>
<strong>/usr/local/nagios/etc/naginet/hosts/athens.cfg</strong>
<strong>/usr/local/nagios/etc/naginet/hosts/sparta.cfg</strong>
<strong>/usr/local/nagios/etc/naginet/hosts/ithaca.cfg</strong>
<strong>/usr/local/nagios/etc/naginet/commands</strong>
<strong>/usr/local/nagios/etc/naginet/commands/webserver-checks.cfg</strong>
<strong>/usr/local/nagios/etc/naginet/services</strong>
<strong>/usr/local/nagios/etc/naginet/services/webservers.cfg</strong>
</pre></div><p>For large networks, it's worth deciding on some suitable organizing principle for directories. One common approach is having a separate directory for hosts, services, and command definitions, relevant to a particular <strong>Domain Name System</strong> (<strong>DNS</strong>) zone<a id="id536" class="indexterm"/> or larger subnet.</p><p>If you want to prevent a file from being included at <a id="id537" class="indexterm"/>
<a id="id538" class="indexterm"/>any point, all you need to do is either move it out of the directory, or rename it so that it no longer has a <code class="literal">.cfg</code> extension. One possibility is adding the suffix <code class="literal">.exclude</code>:</p><div><pre class="programlisting">
<strong># mv unwanted-file.cfg unwanted-file.cfg.exclude</strong>
</pre></div><p>This will prevent Nagios Core from picking it up as part of its <code class="literal">cfg_dir</code> searching algorithm.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec309"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using inheritance to simplify configuration</em> and <em>Keeping configuration under version control</em> recipes in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Keeping configuration under version control</h1></div></div></div><p>In this recipe, we'll place a Nagios Core configuration <a id="id539" class="indexterm"/>
<a id="id540" class="indexterm"/>directory under version control, in an attempt to keep track of changes made to it, and to enable us to reverse changes if there are problems.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec310"/>Getting ready</h2></div></div></div><p>You should choose an appropriate version control system. The recipe will vary considerably depending on which system you use; there are too many options to demonstrate here, so we'll use the popular open source content tracker <strong>Git</strong>, the basics of which are very easy to use for this kind of version control and do not require an external server. However, there's no reason you can't use <strong>Subversion</strong> or <strong>Mercurial</strong>, if you'd prefer. You should have the client for your chosen system (<code class="literal">git</code>, <code class="literal">hg</code>, <code class="literal">svn</code>, and so on) installed on your server.</p><p>This will all work with any version of Nagios Core. It does not involve directly changing any part of the Nagios Core configuration, only keeping track of the files in it.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec311"/>How to do it...</h2></div></div></div><p>We can place our configuration directory under version control as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the root of the configuration directory. In the default installation, this is <code class="literal">/usr/local/nagios/etc</code>:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc</strong>
</pre></div></li><li class="listitem">Run <code class="literal">git init</code> to start a repository in the current directory:<div><pre class="programlisting">
<strong># git init</strong>
<strong>Initialized empty Git repository in /usr/local/nagios/etc/.git/.</strong>
</pre></div></li><li class="listitem">Add all the files in the configuration directory with <code class="literal">git add</code>:<div><pre class="programlisting">
<strong># git add .</strong>
</pre></div></li><li class="listitem">Commit the files with <code class="literal">git commit</code>:<div><pre class="programlisting">
<strong># git commit -m "First commit of configuration"</strong>
<strong>[master (root-commit) 6a2c605] First commit of configuration.</strong>
<strong> 39 files changed, 3339 insertions(+), 0 deletions(-)</strong>
<strong> create mode 100644 naginet/athens.naginet.cfg</strong>
<strong> create mode 100644 naginet/ithaca.naginet.cfg</strong>
<strong> create mode 100644 naginet/sparta.naginet.cfg</strong>
<strong> ...</strong>
</pre></div></li></ol></div><p>With this done, we should now have a <code class="literal">.git</code> repository in <code class="literal">/usr/local/nagios/etc</code>, tracking all the changes made to the configuration files.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec312"/>How it works...</h2></div></div></div><p>Changes to the configuration files in this directory can now be <a id="id541" class="indexterm"/>
<a id="id542" class="indexterm"/>reviewed for commit with <code class="literal">git status</code>. For example, if we changed the IP addresses of one of our hosts, we might check the changes by typing the following:</p><div><pre class="programlisting">
<strong># git status -s</strong>
<strong>M naginet/hosts/sparta.cfg</strong>
</pre></div><p>We could then commit this change with an explanatory message:</p><div><pre class="programlisting">
<strong># git commit -am "Changed IP address of host"</strong>
<strong>[master d5116a6] Changed IP address of host</strong>
<strong>1 files changed, 1 insertions(+), 1 deletions(-)</strong>
</pre></div><p>We can review the change with <code class="literal">git log</code>:</p><div><pre class="programlisting">
<strong># git log --oneline</strong>
<strong>d5116a6 Changed IP address of host</strong>
<strong>6a2c605 First commit of configuration</strong>
</pre></div><p>If we want to inspect exactly what was changed later on, we can use <code class="literal">git diff</code> followed by the short commit ID given in the first column of the preceding output:</p><div><pre class="programlisting">
<strong># git diff 6a2c605</strong>
<strong>diff --git a/naginet/hosts/sparta.cfg b/naginet/hosts/sparta.cfg</strong>
<strong>index 0bb3b0b..fb7c2a9 100644</strong>
<strong>--- a/naginet/hosts/sparta.cfg</strong>
<strong>+++ b/naginet/hosts/sparta.cfg</strong>
<strong>@@ -2,7 +2,7 @@ define host {</strong>
<strong>     use                 linux-server</strong>
<strong>     host_name           sparta.naginet</strong>
<strong>     alias               sparta</strong>
<strong>-    address             10.128.0.101</strong>
<strong>+    address             10.128.0.102</strong>
<strong>}</strong>
</pre></div><p>The full functionality of Git for managing these changes, <a id="id543" class="indexterm"/>
<a id="id544" class="indexterm"/>including reverting to older revisions, is out of scope here. You can read more about how to use Git in general in Scott Chacon's excellent book entitled <em>Pro Git</em>, free to read online at <a class="ulink" href="http://git-scm.com/book">http://git-scm.com/book</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec313"/>There's more...</h2></div></div></div><p>Version control is particularly useful in this way when more than one person is editing a configuration, because it allows us to determine who made a change and when. It also allows us to see the exact changeset to review why it was changed, and to undo or edit it if it is causing problems.</p><p>If you're going to use this method, it's a good idea to keep your configuration reasonably granular, using at least several files rather than just one or two. It will still work if you have two big files such as <code class="literal">hosts.cfg</code> and <code class="literal">services.cfg</code> for your network, but the differences between each commit will not be as clear. This is therefore a very good recipe to combine with the <em>Grouping configuration files in directories</em> recipe, also in this chapter.</p><p>Rather than merely the configuration directory, you may prefer to keep the entire Nagios Core directory under version control, including the plugins and other scripts and binaries. This could be particularly handy if you upgrade your installation with new releases and want to see what's changed in your files, in case it breaks anything. In this case, be careful to use your chosen version control system's "ignore" functionality to prevent tracking temporary files or log files. For Git, take a look at the output of <code class="literal">git help ignore</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec314"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Grouping configuration files in directories</em> recipe in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Configuring host roles using groups</h1></div></div></div><p>In this recipe, we'll learn how to use the abstraction of <a id="id545" class="indexterm"/>
<a id="id546" class="indexterm"/>host and service groups to our advantage in order to build a configuration where hosts and services can be added or removed more easily. We'll do this by defining roles for hosts by using a hostgroup structure, and then assigning relevant services to the hostgroup, rather than to the hosts individually.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec315"/>Getting ready</h2></div></div></div><p>You will need to have a server running Nagios Core 3.0 or later, have access to the command line to change its directories, and understand the basics of how host and service groups work. These are covered in the <em>Creating a new hostgroup</em> and <em>Creating a new servicegroup</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>.</p><p>In this example, we'll create two simple hostgroups; one called <code class="literal">servers</code>, for which a <code class="literal">PING</code> check should be made for its member hosts, and another called <code class="literal">webservers</code>, which should include <code class="literal">HTTP</code> checks for its member hosts. Once this is set up, we'll then add an example host <code class="literal">sparta.naginet</code> to both groups, thereby easily assigning all the appropriate services to the host in one definition, which we can cleanly remove simply by deleting the host.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec316"/>How to do it...</h2></div></div></div><p>We can create our group-based roles for hosts as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory. In the default installation, this is <code class="literal">/usr/local/nagios/etc/objects</code>. If you have already followed the <em>Grouping configuration files in directories</em> recipe in this chapter, then your own directory may differ.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
</pre></div></li><li class="listitem">In an appropriate file, perhaps <code class="literal">hostgroups.cfg</code>, define new hostgroups with names corresponding to the roles for the hosts. Do not assign them any members just yet.<div><pre class="programlisting">define hostgroup {
    hostgroup_name  servers
    alias           Servers
}
define hostgroup {
    hostgroup_name  web-servers
    alias           Web Servers
}</pre></div></li><li class="listitem">In a second appropriate file, perhaps <code class="literal">services.cfg</code>, define new services and assign them <code class="literal">hostgroup_name</code> values, corresponding to the hostgroups added in the previous step:<div><pre class="programlisting">define service {
    use                  generic-service
<strong>    hostgroup_name       servers</strong>
    service_description  PING
    check_command        check_ping!100,10%!200,20%
}
define service {
    use                  generic-service
<strong>    hostgroup_name       web-servers</strong>
    service_description  HTTP
    check_command        check_http
}</pre></div><p>Note that the use of the <code class="literal">generic-service</code> template is an example only; you will probably want to inherit from your own particular service template.</p></li><li class="listitem">Add or edit your existing hosts to make them a <a id="id547" class="indexterm"/><a id="id548" class="indexterm"/>part of the appropriate hostgroups, using the <a id="id549" class="indexterm"/><code class="literal">hostgroups</code> directive:<div><pre class="programlisting">define host {
    use         linux-server
    host_name   sparta.naginet
    alias       sparta
    address     10.128.0.21
<strong>    hostgroups  servers,web-servers</strong>
}
define host {
    use         linux-server
    host_name   athens.naginet
    alias       athens
    address     10.128.0.22
<strong>    hostgroups  servers,web-servers</strong>
}</pre></div></li><li class="listitem">If you already had services with the same value for their <code class="literal">service_description</code> directives <a id="id550" class="indexterm"/>as the ones you're adding in this recipe, you will need to remove them, as this may cause a conflict with the services added in the previous step.</li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, you should now find that all of the <a id="id551" class="indexterm"/>
<a id="id552" class="indexterm"/>services you defined for the hostgroups you created have been attached to the appropriate hosts:</p><div><img src="img/5566_09_01.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec317"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section avoids assigning services directly to hosts, instead assigning them to hostgroups, thereby creating roles for services that hosts can adopt or discard simply by becoming part of or leaving the group.</p><p>Apart from making the configuration shorter, another advantage to this approach is that if services are added this way, adding or deleting a host from the Nagios Core configuration requires nothing but the adding or removing of the host definition. Similarly, if a host takes on another role (for example, a web server adding some database functionality), then we can modify the services being checked on it simply by modifying its hostgroups. This ends up being much easier than adding dependencies in other files.</p><p>Another advantage is that having hostgroups organized by host function is helpful for applying batch operations such as scheduled downtime in one easy action, or for checking all the services for one particular type of host. Once a hostgroup is defined, we can run operations on all the hosts within it by clicking on its name in the brackets, in any of the hostgroup views:</p><div><img src="img/5566_09_02.jpg" alt="How it works..."/></div><p>If we had twenty web servers that we knew were going to be down, for example, this would be much easier than scheduling downtime for each of them individually!</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec318"/>There's more...</h2></div></div></div><p>It's worth noting that hostgroups can have subgroups, <a id="id553" class="indexterm"/>
<a id="id554" class="indexterm"/>meaning that all of the hosts added to any of their subgroups are implicitly added to the parent group.</p><p>For example, we could define the hostgroup web servers as a subgroup of the <code class="literal">servers</code> hostgroup, using the <a id="id555" class="indexterm"/>
<code class="literal">hostgroup_members</code> directive:</p><div><pre class="programlisting">define hostgroup {
    hostgroup_name     servers
    alias              Servers
<strong>    hostgroup_members  web-servers</strong>
}</pre></div><p>This would allow us to implicitly add hosts to both groups, without needing to refer to the parent group, and with all the services assigned to both groups assigned to the host:</p><div><pre class="programlisting">define host {
    use         linux-server
    host_name   athens.naginet
    alias       athens
    address     10.128.0.22
<strong>    hostgroups  web-servers</strong>
}</pre></div><p>This can be very useful for sorting "subcategories" of services. Other examples might include a <code class="literal">dns-servers</code> group with subgroups <code class="literal">dns-authoritative-servers</code> and <code class="literal">dns-recursive-servers</code>, or a <code class="literal">database-servers</code> group with subgroups <code class="literal">oracle-servers</code> and <code class="literal">mysql-servers</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec319"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Building groups using regular expressions</em> and <em>Using inheritance to simplify configuration</em> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Creating a new hostgroup</em>, <em>Creating a new servicegroup</em>, and <em>Running a service on all hosts in a hostgroup</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <em>Understanding Hosts, Services, and Contacts</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Building groups using regular expressions</h1></div></div></div><p>In this recipe, we'll learn a shortcut for building <a id="id556" class="indexterm"/>
<a id="id557" class="indexterm"/>groups of hosts using regular expressions tested against their hostnames.</p><p>This recipe is likely only of use to you if you use a naming convention for your hosts that allows them to be reasonably grouped by location, function, or some other useful metric by a common string in their hostnames.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec320"/>Getting ready</h2></div></div></div><p>You will need to have a server running Nagios Core 3.0 or later, have access to the command line to change its configuration, and understand the basics of how hostgroups and servicegroups work. These are covered in the <em>Creating a new hostgroup</em> and <em>Creating a new servicegroup</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>.</p><p>In this example, we'll group three existing hosts named <code class="literal">web-server-01</code>, <code class="literal">web-server-02</code>, and <code class="literal">web-server-03</code> into a new hostgroup, <code class="literal">web-servers</code>, based only on their hostnames.</p><p>It would help to have some familiarity with regular expressions, but the recipe includes a simple example, which should meet many use cases for this trick. An excellent site about regular expressions including tutorials can be found at <a class="ulink" href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec321"/>How to do it...</h2></div></div></div><p>We can build a hostgroup by matching regular expressions to hostnames as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the Nagios configuration directory. In the default installation, this is <code class="literal">/usr/local/nagios/etc</code>. Edit the <code class="literal">nagios.cfg</code> file in this directory.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc</strong>
<strong># vi nagios.cfg</strong>
</pre></div></li><li class="listitem">Search for the <code class="literal">use_regexp_matching</code> directive. Uncomment it if necessary and set it to <code class="literal">1</code>.<div><pre class="programlisting">use_regexp_matching=1</pre></div></li><li class="listitem">Search for the <code class="literal">use_true_regexp_matching</code> directive. Uncomment it if necessary, and ensure it's set to <code class="literal">0</code>, which it should be by default.<div><pre class="programlisting">use_true_regexp_matching=0</pre></div></li><li class="listitem">Change to the <code class="literal">objects</code> configuration directory. In the default installation, this is <code class="literal">/usr/local/nagios/etc/objects</code>. If you have already followed the <em>Grouping configuration files in directories</em> recipe in this chapter, then your own directory may differ.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
</pre></div></li><li class="listitem">In an appropriate file, perhaps <code class="literal">hostgroups.cfg</code>, add a definition similar to the following. In this case, <code class="literal">.+</code> means "any string at least one character in length"; you will probably want a pattern of your <a id="id558" class="indexterm"/><a id="id559" class="indexterm"/>own, devising appropriate to your own host names.<div><pre class="programlisting">define hostgroup {
    hostgroup_name  web-servers
<strong>    members         web-server-.+</strong>
    alias           Web Servers
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, if your regular expression was correctly formed to match all the appropriate hostnames, then you should find that the hosts become part of the group:</p><div><img src="img/5566_09_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec322"/>How it works...</h2></div></div></div><p>With the <a id="id560" class="indexterm"/>
<code class="literal">use_regexp_matching</code> directive set to <code class="literal">1</code>, Nagios Core will attempt to use hostname strings containing the strings <code class="literal">*</code>, <code class="literal">?</code>, <code class="literal">+</code>, or <code class="literal">\.</code> as regular expressions to match against hostnames. Because <code class="literal">web-server-01</code>, <code class="literal">web-server-02</code>, and <code class="literal">web-server-03</code> all match the regular expression <code class="literal">web-server-.+</code> given in the <code class="literal">members</code> directive for the <code class="literal">web-servers</code> hostgroup, all three hosts are added to the group.</p><p>We keep <code class="literal">use_true_regexp_matching</code> off. If it were on, it would use every hostname pattern as a regular expression, whether or not it had any special regular expression characters. This is probably not what you want for most <a id="id561" class="indexterm"/>
<a id="id562" class="indexterm"/>configurations.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec323"/>There's more...</h2></div></div></div><p>This matching works in other places aside from hostgroup definitions; for example, you can also use it in the <code class="literal">host_name</code> definitions for services:</p><div><pre class="programlisting">define service {
    use                  generic-service
<strong>    host_name            web-server-.+</strong>
    service_description  HTTP
    check_command        check_http
}</pre></div><p>This is one of a number of very good suggestions for simplifying object definitions suggested in the Nagios Core manual: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/objecttricks.html">http://nagios.sourceforge.net/docs/3_0/objecttricks.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec324"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Building groups using regular expressions</em> and <em>Using inheritance to simplify configuration</em> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Creating a new hostgroup</em> and <em>Creating a new servicegroup</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <em>Understanding Hosts, Services, and Contacts</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Using inheritance to simplify configuration</h1></div></div></div><p>In this recipe, we'll learn how to use inheritance to handle the situation where hosts and services share a lot of values in common, amounting to a large amount of undesirable redundancy in configuration.</p><p>Some Nagios Core objects, particularly hosts and <a id="id563" class="indexterm"/>
<a id="id564" class="indexterm"/>services, have a rather long list of possible directives, and the default values for these are not always suitable. It's therefore worthwhile to be able to declare the values you want for these directives once, and then spend only a few lines on the actual host definition by copying those values from a template, making the configuration shorter and easier to read.</p><p>Previous examples in this book have already demonstrated the use of this in suggesting you inherit from the <code class="literal">linux-server</code> host template or the <code class="literal">generic-service</code> service template, for the sake of brevity; in this example, we'll define our own templates, and show how these can be used to streamline a configuration.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec325"/>Getting ready</h2></div></div></div><p>You will need to have a server running Nagios Core 3.0 or later, have access to the command line to change its configuration, and be familiar with how to define hosts and services. These are covered in the <em>Creating a new host</em> and <em>Creating a new service</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>.</p><p>In this example, we'll define a template, <code class="literal">critical-host</code>, which we'll use as the basis for any host that needs to be checked and notified around the clock, with a very stringent value for its <code class="literal">check_command</code> directive, and with all notification types enabled. We'll also define two hosts named <code class="literal">phobos.naginet</code> and <code class="literal">deimos.naginet</code> that inherit from this template.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec326"/>How to do it...</h2></div></div></div><p>We can define a host template and then define hosts to inherit from it as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory. In the default installation, this <code class="literal">is /usr/local/nagios/etc/objects</code>. If you have already followed the <em>Grouping configuration files in directories </em>recipe in this chapter, then your own directory may differ.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
</pre></div></li><li class="listitem">In an appropriate file, perhaps <code class="literal">templates.cfg</code>, add the following definition. Note the use of the special directives <code class="literal">name</code> and <code class="literal">register</code>:<div><pre class="programlisting">define host {
<strong>    name                   critical-host</strong>
<strong>    register               0</strong>
    check_command          check_ping!25,10%!50,20%
    max_check_attempts     3
    check_interval         1
    notification_interval  1
    notification_period    24x7
    notification_options   d,u,r,f,s
    check_period           24x7
    contact_groups         admins
}</pre></div></li><li class="listitem">In another file, or separate files if you prefer to keep your hosts to one per file, define hosts to inherit from this template. <a id="id565" class="indexterm"/><a id="id566" class="indexterm"/>Add in the remaining required directives for hosts, and include a <code class="literal">use</code> directive referring to the established template:<div><pre class="programlisting">define host {
<strong>    use        critical-host</strong>
    host_name  phobos.naginet
    alias      phobos
    address    10.128.0.151
}
define host {
<strong>    use        critical-host</strong>
    host_name  deimos.naginet
    alias      deimos
    address    10.128.0.152
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div><p>You might receive warnings about no services being defined for the hosts, but you can ignore those for now.</p></li></ol></div><p>With this done, two new hosts should be registered in your configuration, <strong>phobos.naginet</strong> and <strong>deimos.naginet</strong>:</p><div><img src="img/5566_09_04.jpg" alt="How to do it..."/></div><p>No other new hosts should be added, as the template itself was explicitly not registered as an object with the <code class="literal">register</code> directive.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec327"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section defines a new template with the <code class="literal">name</code> directive of <code class="literal">critical-host</code>. Because the value for the host's register directive is <code class="literal">0</code>, where it normally defaults to <code class="literal">1</code>, the host is not registered as an object with Nagios Core. Instead, it becomes a snippet of configuration that can be <a id="id567" class="indexterm"/>
<a id="id568" class="indexterm"/>referenced by real objects of the same type, by referring to its name.</p><p>Note that in the template, the normally required values of <code class="literal">host_name</code>, <code class="literal">alias</code>, and <code class="literal">address</code> are missing; this means that the host is not complete and wouldn't work if we tried to register it as an actual host anyway.</p><p>Instead, we use its values as the basis for other hosts, <code class="literal">phobos.naginet</code> and <code class="literal">deimos.naginet</code>. Both of these hosts inherit from <code class="literal">critical-host</code>, and fill in the rest of the missing values in their own definitions. This frees us from having to repeat the same directives in two different hosts.</p><p>If an object inherits a value for a directive from its parent, it's possible to override that directive by redefining it in the inheriting object definition. For example, if we wanted <code class="literal">phobos.naginet</code> to have a different value for <code class="literal">max_check_attempts</code>, we can add that to its definition:</p><div><pre class="programlisting">define host {
    use                 critical-host
    host_name           deimos.naginet
    alias               deimos
    address             10.128.0.152
<strong>    max_check_attempts  5</strong>
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec328"/>There's more...</h2></div></div></div><p>The most important thing to note about templates is that they work for a variety of Nagios Core objects, most importantly including hosts, services, and contacts. You can therefore set up and inherit from a service template in the same way:</p><div><pre class="programlisting">define service {
    name      critical-service
    register  0
    ...etc...
}
define service {
    use       critical-service
    ...etc...
}</pre></div><p>Or a contact template:</p><div><pre class="programlisting">define contact {
    name      critical-contact
    register  0
    ...etc...
}
define contact {
    use       critical-contact
    ...etc...
}</pre></div><p>Note that inheritance can stack. For example, <code class="literal">critical-host</code> could itself inherit from a template, perhaps <code class="literal">generic-host</code>, by adding its own <code class="literal">use</code> directive:</p><div><pre class="programlisting">define host {
<strong>    use       generic-host</strong>
    name      critical-host
    register  0
    ...etc...
}</pre></div><p>This allows the setting up of an inheritance structure of arbitrary complexity, but you should avoid too much depth to prevent confusing yourself or anyone else trying to read your configuration. Two levels is probably a sensible limit.</p><p>The rules around how inheritance is handled are discussed in more depth in the Nagios Core manual, including a treatment of multiple inheritance. It's useful to know about this, but in the interests of keeping configuration clear, it's best used sparingly: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/objectinheritance.html">http://nagios.sourceforge.net/docs/3_0/objectinheritance.html</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec329"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Configuring host roles using groups</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Creating a new host</em>, <em>Creating a new service</em>, and <em>Creating a new contact</em> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <em>Understanding Hosts, Services, and Contacts</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Defining macros in a resource file</h1></div></div></div><p>In this recipe, we'll learn how to define <a id="id569" class="indexterm"/>
<a id="id570" class="indexterm"/>custom user macros in resource files. This is good practice for strings used in <code class="literal">check_command</code> definitions or other directives that are shared by more than one host or service. For example, <a id="id571" class="indexterm"/>in lieu of writing the full path in a <code class="literal">command_name</code> directive as follows:</p><div><pre class="programlisting">command_name=/usr/local/nagios/libexec/check_ssh $HOSTADDRESS$</pre></div><p>We could instead write:</p><div><pre class="programlisting">command_name=$USER1$/check_ssh $HOSTADDRESS$</pre></div><p>As a result, if the location of the <code class="literal">check_ssh</code> script<a id="id572" class="indexterm"/> changes, we only need to change the value of <code class="literal">$USER1$</code> in the appropriate resource file to update all of its uses throughout the configuration.</p><p>Most of the macros in Nagios Core are defined automatically by the monitoring server, but up to 32 user-defined macros can be used as well, in the form <code class="literal">$USERn$</code>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec330"/>Getting ready</h2></div></div></div><p>You will need to have a server running Nagios Core 3.0 or later, and have access to the command line to change its configuration, in particular the <code class="literal">resource.cfg</code> file.</p><p>In this example, we'll add a new macro, <code class="literal">$USER2$</code>, to contain the SNMP community name <code class="literal">snagmp</code>, as used for various <code class="literal">check_snmp</code> requests.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec331"/>How to do it...</h2></div></div></div><p>We can define our user macro as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the Nagios configuration directory. In the default installation, this is <code class="literal">/usr/local/nagios/etc</code>. Edit the <code class="literal">resource.cfg</code> file in this directory.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc</strong>
<strong># vi resource.cfg</strong>
</pre></div></li><li class="listitem">Ensure that the <code class="literal">$USER2$</code> macro is not already defined in the file. If it is, we could define <code class="literal">$USER3$</code> instead, and so on.</li><li class="listitem">Add the following definition to the end of the file:<div><pre class="programlisting">$USER2$=snagmp</pre></div></li><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. In the default installation, this is <code class="literal">/usr/local/nagios/etc/objects</code>.<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
</pre></div></li><li class="listitem">Edit any of the <code class="literal">object</code> configuration files in which you wish to use the value of the macro, and replace the inline values with <code class="literal">$USER2$</code>. In our example, we might find various uses of the literal <code class="literal">checksnmp</code> community string:<div><pre class="programlisting">define command {
    ...
    command_line  $USER1$/check_snmp -H $HOSTADDRESS$ -C snagmp -o .1.3.6.1.2.1.1.5.0 -r $ARG1$
}
define service {
    ...
    check_command  check_snmp!snagmp
}</pre></div><p>We could swap these out to use the macro instead:</p><div><pre class="programlisting">define command {
    ...
<strong>    command_line  $USER1$/check_snmp -H $HOSTADDRESS$ -C $USER2$ -o .1.3.6.1.2.1.1.5.0 -r $ARG1$</strong>
}
define service {
    ...
<strong>    check_command  check_snmp!$USER2$</strong>
}</pre></div></li><li class="listitem">Validate the configuration and <a id="id573" class="indexterm"/><a id="id574" class="indexterm"/>restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, all the monitoring should be working the same as it was before, but we're now using macro expansion to centralize configuration.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec332"/>How it works...</h2></div></div></div><p>Before Nagios Core processes directives such as <code class="literal">command_line</code> and <code class="literal">check_command</code>, it will first expand all the macros referenced, including the user-defined macros we added in the <code class="literal">resource.cfg</code> resource file.</p><p>One common use for the <code class="literal">$USERn$</code> macros is for defining the full path of directories where Nagios Core resources such as plugins or event handler scripts are located— in fact, the sample configuration included in Nagios Core defines <code class="literal">$USER1$</code> in <code class="literal">resource.cfg</code> as <code class="literal">/usr/local/nagios/libexec</code>, the default location for plugin scripts and binaries.</p><p>It's worth noting that you can load more than one resource file by adding more <code class="literal">resource_file</code> directives  in <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>. For example, to load another file called <code class="literal">resource-extra.cfg</code>, we could add a second line as follows:</p><div><pre class="programlisting">resource_file=/usr/local/nagios/etc/resource.cfg
<strong>resource_file=/usr/local/nagios/etc/resource-extra.cfg</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec333"/>There's more...</h2></div></div></div><p>There's also a security benefit to using resource files—for sensitive information, we can prevent users other than <code class="literal">nagios</code> from reading them <a id="id575" class="indexterm"/>
<a id="id576" class="indexterm"/>by making them readable only to the <code class="literal">nagios</code> user:</p><div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc</strong>
<strong># chown nagios.nagios resource.cfg</strong>
<strong># chmod 0600 resource.cfg</strong>
</pre></div><p>This makes it a decent way to store credentials, such as usernames and passwords, for example to be used in <code class="literal">check_command</code> for MySQL:</p><div><pre class="programlisting">define command {
    command_name  check_mysql_secure
<strong>    command_line  check_mysql -H $HOSTADDRESS$ -u naguser -d nagdb -p $USER3$</strong>
}</pre></div><p>You can also define per-host macros, by using custom directives preceded with an underscore in the host definition:</p><div><pre class="programlisting">define host {
    use                 critical-host
    host_name           sparta.naginet
    alias               sparta
    address             10.128.0.21
<strong>    _mac_address        08:00:27:7e:7c:d2</strong>
}</pre></div><p>In the preceding example, we're able to include the host's MAC address in a custom directive; this can be referenced in services as <code class="literal">$_HOSTMAC_ADDRESS$</code>:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  ARP
    check_command        check_arp!$_HOSTMAC_ADDRESS$
}</pre></div><p>The same trick can also apply for contacts and services. This special use of custom macros is discussed in the <em>Custom Object Variables</em> chapter of the Nagios documentation at <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/customobjectvars.html">http://nagios.sourceforge.net/docs/3_0/cu</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec334"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring the output of an SNMP query</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li><li class="listitem" style="list-style-type: disc">The <em>Monitoring individual nodes in a cluster</em> recipe in <a class="link" href="ch08.html" title="Chapter 8. Managing Network Layout">Chapter 8</a>, <em>Understanding the Network Layout</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Dynamically building host definitions</h1></div></div></div><p>In this recipe, we'll learn one possible method of building Nagios configuration dynamically, to avoid having to compose or copy-paste a lot of directives for new hosts or services. In other words, this recipe is about generating configuration using templates.</p><p>To demonstrate how this is useful, we'll use the <code class="literal">m4</code> macro <a id="id577" class="indexterm"/>language utility, which should be available on virtually any UNIX-like system, including GNU/Linux and BSD. As a tool designed for macro expansion, <code class="literal">m4</code> is particularly well-suited to creating verbose plain text configuration files such as the ones used by Nagios Core.</p><p>The principles here should apply just as easily to your favored programming or templating language, perhaps Python or Perl, or shell scripts.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec335"/>Getting ready</h2></div></div></div><p>You will need to have the <code class="literal">m4</code> macro language tool available to you, preferably but not necessarily on the same system as the one running Nagios Core. It is a very standard tool and should be already installed, or available as part of a package. The version used in this example is <a id="id578" class="indexterm"/>
<strong>GNU m4</strong>, documented at <a class="ulink" href="http://www.gnu.org/software/m4/manual/m4.html">http://www.gnu.org/software/m4/manual/m4.html</a>. This recipe does not assume any familiarity with <code class="literal">m4</code>, and will show you the basics.</p><p>You may like to work in a new subdirectory in your home directory:</p><div><pre class="programlisting">
<strong>$ mkdir $HOME/nagios-dynamic-hosts</strong>
<strong>$ cd $HOME/nagios-dynamic-hosts</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec336"/>How to do it...</h2></div></div></div><p>We can create and apply an example Nagios Core <a id="id579" class="indexterm"/>configuration template as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new file <code class="literal">host-service-template.m4</code> with the following contents:<div><pre class="programlisting">define(`NAGHOST', `
    define host {
        host_name              $1
        alias                  $2
        address                $3
        contact_groups         ifelse(`$#', `4', `$4', `admins')
        check_command          check-host-alive
        check_interval         5
        check_period           24x7
        max_check_attempts     3
        notification_interval  30
        notification_options   d,r
        notification_period    24x7
    }
    define service {
        host_name              $1
        contact_groups         ifelse(`$#', `4', `$4', `admins')
        check_command          check_ping!100,10%!200,20%
        check_interval         5
        check_period           24x7
        max_check_attempts     3
        notification_interval  30
        notification_period    24x7
        retry_interval         1
        service_description    PING
    }
')</pre></div></li><li class="listitem">Create a second file in the same directory called <code class="literal">sparta.host.m4</code> with the following contents:<div><pre class="programlisting">include(`host-service-template.m4')
NAGHOST(`sparta', `Sparta Webserver', `10.0.128.21')</pre></div></li><li class="listitem">Create a third file in the same directory called <code class="literal">athens.host.m4</code> with the following contents:<div><pre class="programlisting">include(`host-service-template.m4')
NAGHOST(`athens', `Athens Webserver', `10.0.128.22', `ops')</pre></div></li><li class="listitem">Run the following commands and note the output:<div><pre class="programlisting">
<strong>$ m4 sparta.host.m4</strong>
<strong>define host {</strong>
<strong>    host_name              sparta</strong>
<strong>    alias                  Sparta Webserver</strong>
<strong>    address                10.0.128.21</strong>
<strong>    contact_groups         admins</strong>
<strong>    check_command          check-host-alive</strong>
<strong>    check_interval         5</strong>
<strong>    check_period           24x7</strong>
<strong>    max_check_attempts     3</strong>
<strong>    notification_interval  30</strong>
<strong>    notification_options   d,r</strong>
<strong>    notification_period    24x7</strong>
<strong>}</strong>
<strong>define service {</strong>
<strong>    host_name              sparta</strong>
<strong>    contact_groups         admins</strong>
<strong>    check_command          check_ping!100,10%!200,20%</strong>
<strong>    check_interval         5</strong>
<strong>    check_period           24x7</strong>
<strong>    max_check_attempts     3</strong>
<strong>    notification_interval  30</strong>
<strong>    notification_period    24x7</strong>
<strong>    retry_interval         1</strong>
<strong>    service_description    PING</strong>
<strong>}</strong>
<strong>$ m4 athens.host.m4</strong>
<strong>define host {</strong>
<strong>    host_name              athens</strong>
<strong>    alias                  Athens Webserver</strong>
<strong>    address                10.0.128.22</strong>
<strong>    contact_groups         ops</strong>
<strong>    check_command          check-host-alive</strong>
<strong>    check_interval         5</strong>
<strong>    check_period           24x7</strong>
<strong>    max_check_attempts     3</strong>
<strong>    notification_interval  30</strong>
<strong>    notification_options   d,r</strong>
<strong>    notification_period    24x7</strong>
<strong>}</strong>
<strong>define service {</strong>
<strong>    host_name              athens</strong>
<strong>    contact_groups         ops</strong>
<strong>    check_command          check_ping!100,10%!200,20%</strong>
<strong>    check_interval         5</strong>
<strong>    check_period           24x7</strong>
<strong>    max_check_attempts     3</strong>
<strong>    notification_interval  30</strong>
<strong>    notification_period    24x7</strong>
<strong>    retry_interval         1</strong>
<strong>    service_description    PING</strong>
<strong>}</strong>
</pre></div></li></ol></div><p>As seen in the preceding output, we can now generate a basic host and service configuration with a two-line <code class="literal">m4</code> script referring to a <a id="id580" class="indexterm"/>template, simply by writing the output to a <code class="literal">.cfg</code> file:</p><div><pre class="programlisting">
<strong>$ m4 sparta.host.m4 &gt; sparta.cfg</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec337"/>How it works...</h2></div></div></div><p>The files <code class="literal">sparta.host.m4</code> and <code class="literal">athens.host.m4</code> both called an <code class="literal">m4</code> macro with arguments, after including the template for the host and service in the <code class="literal">host-service-template.m4</code> file. This was expanded into the full definition, and the arguments given were substituted as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$1</code> was replaced with the first argument, <code class="literal">host_name</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$2</code> was replaced with the second argument, <code class="literal">alias</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$3</code> was replaced with the third argument, <code class="literal">address</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$4</code> was replaced with the fourth argument, <code class="literal">contact_group</code></li></ul></div><p>Note that two of these values, <code class="literal">$1</code> and <code class="literal">$4</code>, were used in both the host and the <code class="literal">PING</code> service definitions.</p><p>Also note that the argument <code class="literal">$4</code> is optional; the <code class="literal">if-else</code> construct tests the number of arguments, and if it finds there are four, it uses the value of the fourth argument; for <code class="literal">athens.naginet</code>, this is the contact group <code class="literal">ops</code>. If there is no fourth argument, it defaults instead to the value <code class="literal">admins</code>. This allows us to set default values for arguments if we so choose.</p><p>The rest of the directives are all written directly into the template. <a id="id581" class="indexterm"/>The configuration made by this process is valid for Nagios Core, assuming that the <code class="literal">check_command</code> and <code class="literal">contact_groups</code> used are defined.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec338"/>There's more...</h2></div></div></div><p>To automate things even further, we could use <code class="literal">make</code> to automatically generate <code class="literal">.cfg</code> files from anything with the extension <code class="literal">.host.m4</code> with the following <code class="literal">Makefile</code>:</p><div><pre class="programlisting">%.cfg : %.host.m4
    m4 $&lt; &gt; $*.cfg</pre></div><p>Note that correct <a id="id582" class="indexterm"/>
<code class="literal">Makefile</code> syntax usually requires a literal <em>Tab</em> character to indent the second line, not four spaces.</p><p>With this in the same directory as all the preceding files, in order to build the configuration for the <code class="literal">sparta.naginet</code> host, we would only need to use a <code class="literal">make</code> call to generate the file:</p><div><pre class="programlisting">
<strong>$ make sparta.cfg</strong>
<strong>m4 sparta.host.m4 &gt; sparta.cfg</strong>
<strong>$ make athens.cfg</strong>
<strong>m4 athens.host.m4 &gt; athens.cfg</strong>
</pre></div><p>Note that it's better practice to avoid repeating directives, and instead to use hostgroups and host and service templates to define "roles" for new hosts. This makes adding and removing the hosts much easier, and both processes are explained in this chapter, in the <em>Configuring host roles using groups</em> and <em>Using inheritance to simplify configuration</em> recipes.</p><p>David Douthitt goes into considerably more depth about the possibilities of using <code class="literal">m4</code> for Nagios configuration at <a class="ulink" href="http://administratosphere.wordpress.com/2009/02/19/configuring-nagios-with-m4/">http://administratosphere.wordpress.com/2009/02/19/configuring-nagios-with-m4/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec339"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Configuring host roles using groups</em> and <em>Using inheritance to simplify configuration</em> recipes in this chapter</li></ul></div></div></div></body></html>