- en: The Old-Boy Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us ping!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing IP routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all available machines on a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running commands on a remote host with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running graphical commands on a remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files through the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a wireless network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-less auto-login with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port forwarding using SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a remote drive at a local mount point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network traffic and port analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring network bandwidth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating arbitrary sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing an Internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic firewall using `iptables`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Virtual Private Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is the act of connecting computers to allow them to exchange information.
    The most widely used networking stack is TCP/IP, where each node is assigned a
    unique IP address for identification. If you are already familiar with networking,
    you can skip this introduction.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP networks work by passing data packets from node to node. Each data packet
    contains the IP address of its destination and the port number of the application
    that can process this data.
  prefs: []
  type: TYPE_NORMAL
- en: When a node receives a packet, it checks to see if it is this packet's destination.
    If so, the node checks the port number and invokes the appropriate application
    to process the data. If this node is not the destination, it evaluates what it
    knows about the network and passes the packet to a node that is closer to the
    final destination.
  prefs: []
  type: TYPE_NORMAL
- en: Shell scripts can be used to configure the nodes in a network, test the availability
    of machines, automate execution of commands at remote hosts, and more. This chapter
    provides recipes that introduce tools and commands related to networking, and
    shows how to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before digging through recipes based on networking, it is essential to have
    a basic understanding of setting up a network, terminologies, and commands for
    assigning IP address, adding routes, and so on. This recipe provides an overview
    of commands used in GNU/Linux networks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A network interface physically connects a machine to a network, either with
    a wire or a Wi-Fi link. Linux denotes network interfaces using names such as `eth0`,
    `eth1`, or `enp0s25` (referring to Ethernet interfaces). Other interfaces, namely
    `usb0`, `wlan0`, and `tun0`, are available for USB network interfaces, wireless
    LAN, and tunnels, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will use these commands: `ifconfig`, `route`, `nslookup`,
    and `host`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ifconfig` command is used to configure and display details about network
    interfaces, subnet mask, and so on. It should be available at `/sbin/ifconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List the current network interface configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The leftmost column in the ifconfig output lists the names of network interfaces,
    and the right-hand columns show the details related to the corresponding network
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the IP address for a network interface, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will need to run the preceding command as root
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.80` is defined as the address for the wireless device, wlan0'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the subnet mask along with the IP address, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Many networks use **Dynamic Host Configuration Protocol** (**DHCP**) to assign
    IP addresses automatically when a computer connects to the network. The `dhclient`
    command assigns the IP address when your machine is connected to a network that
    assigns IP addresses automatically. If addresses are assigned via DHCP, use `dhclient`
    instead of manually choosing an address that might conflict with another machine
    on the network. Many Linux distributions invoke `dhclient` automatically when
    they sense a network cable connection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ifconfig` command can be combined with other shell tools to produce specific
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the list of network interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one-line command sequence displays network interfaces available on a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first ten characters of each line in `ifconfig` output is reserved for writing
    names of network interfaces. Hence, we use `cut` to extract the first ten characters
    of each line. `tr -d ' '` deletes every space character in each line. Now, the
    `n` newline character is squeezed using `tr -s 'n'` to produce a list of interface
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying IP addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ifconfig` command displays details of every active network interface available
    on the system. However, we can restrict it to a specific interface using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To control a device, we need the IP address, broadcast address, hardware address,
    and subnet mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HWaddr 00:1c:bf:87:25:d2`: This is the hardware address (MAC address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inet addr:192.168.0.82`: This is the IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bcast:192.168.3.255`: This is the broadcast address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mask:255.255.252.0`: This is the subnet mask'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract the IP address from the `ifconfig` output, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `egrep -o "inetaddr:[^ ]*"` command returns `inet addr:192.168.0.82`. The
    pattern starts with `inetaddr:` and ends with any non-space character sequence
    (specified by `[^ ]*`). The next command, `grep -o "[0-9.]*"` reduces its input
    to only numbers and periods, and prints out an IP4 address.
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing the hardware address (MAC address)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When authentication or filtering is based on the hardware address, we can use
    hardware address spoofing. The hardware address appears in the `ifconfig` output
    as `HWaddr 00:1c:bf:87:25:d2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hw` subcommand of `ifconfig` will define a devices class and the MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `00:1c:bf:87:25:d5` is the new MAC address to be assigned.
    This is useful when we need to access the Internet through MAC-authenticated service
    providers that provide access to the Internet for a single machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: this definition only lasts until a machine restarts.'
  prefs: []
  type: TYPE_NORMAL
- en: Name server and DNS (Domain Name Service)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The underlying addressing scheme for the Internet is the dotted decimal form
    (like `83.166.169.231`). Humans prefer to use words instead of numbers, so resources
    on the Internet are identified with strings of words called **URLs** or **domain
    names**. For example, [www.packtpub.com](http://www.packtpub.com) is a domain
    name and it corresponds to an IP address. The site can be identified by the numeric
    or the string name.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of mapping IP addresses to symbolic names is called **Domain
    Name Service** (**DNS**). When we enter [www.google.com](http://www.google.com),
    our computer uses the DNS servers to resolve the domain name into the corresponding
    IP address. While on a local network, we set up the local DNS to name local machines
    with symbolic names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name servers are defined in `/etc/resolv.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add name servers manually by editing that file or with a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest method to obtain an IP address is to use the `ping` command to
    access the domain name. The reply includes the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The number `64.233.181.106` is the IP address of a google.com server.
  prefs: []
  type: TYPE_NORMAL
- en: A domain name may map to multiple IP addresses. In that case, `ping` shows one
    address from the list of IP addresses. To obtain all the addresses assigned to
    the domain name, we should use a DNS lookup utility.
  prefs: []
  type: TYPE_NORMAL
- en: DNS lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several DNS lookup utilities provide name and IP address resolution from the
    command line. The `host` and `nslookup` commands are two commonly installed utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `host` command lists all of the IP addresses attached to a domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nslookup` command maps names to IP addresses and will also map IP addresses
    to names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The last line in the preceding command-line snippet corresponds to the default
    name server used for resolution.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to add a symbolic name to the IP address resolution by adding
    entries into the `/etc/hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entries in `/etc/hosts follow this format`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can update `/etc/hosts` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: After adding this entry, whenever resolution to `backupserver` occurs, it will
    resolve to `192.168.0.9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `backupserver` has multiple names, you can include them on the same line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Showing routing table information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common to have interconnected networks. For example, different departments
    at work or school may be on separate networks. When a device on one network wants
    to communicate with a device on the other network, it needs to send packets through
    a device which is common to both networks. This device is called a `gateway` and
    its function is to route packets to and from different networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operating system maintains a table called the `routing table`, which contains
    the information on how packets are to be forwarded through machines on the network.
    The `route` command displays the routing table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using `-n` specifies to display the numeric addresses. By default, route will
    map the numeric address to a name.
  prefs: []
  type: TYPE_NORMAL
- en: When your system does not know the route to a destination, it sends the packet
    to a default gateway. The default gateway may be the link to the Internet or an
    inter-departmental router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `route add` command can add a default gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using variables and environment variables *recipe of [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains the `PATH` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Searching and mining text inside a file with grep* recipe of [Chapter 4](22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml),
    *Texting and Driving*, explains the `grep` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us ping!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ping` command is a basic network command, supported on all major operating
    systems. Ping is used to verify connectivity between hosts on a network and identify
    accessible machines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ping command uses **Internet Control Message Protocol** (**ICMP**) packets
    to check the connectivity of two hosts on a network. When these echo packets are
    sent to a target, the target responds with a reply if the connection is complete.
    A ping request can fail if there is no route to the target or if there is no known
    route from the target back to the requester.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pinging an address will check whether a host is reachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ADDRESS` can be a hostname, domain name, or an IP address itself.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `ping` will continuously send packets and the reply information
    is printed on the terminal. Stop the pinging process by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a host is reachable, the output will be similar to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When a host is unreachable, the output will resemble this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the target is not reachable, the ping returns with the `Destination Host
    Unreachable` error message.
  prefs: []
  type: TYPE_NORMAL
- en: Network administrators generally configure devices such as routers not to respond
    to `ping`. This is done to lower security risks, as `ping` can be used by attackers
    (using brute-force) to find out IP addresses of machines.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to checking the connectivity between two points in a network, the
    `ping` command returns other information. The round trip time and lost packet
    reports can be used to determine whether a network is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Round Trip Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ping` command displays **Round Trip Time** (**RTT**) for each packet sent
    and returned. RTT is reported in milliseconds. On an internal network, a RTT of
    under 1ms is common. When pinging a site on the Internet, RTT are commonly 10-400
    ms, and may exceed 1000 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the minimum RTT is `118.012 ms`, the average RTT is `206.630` ms, and
    the maximum RTT is `347.186ms`. The `mdev` (`77.713ms`) parameter in the ping
    output stands for mean deviation.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each packet that ping sends is assigned a number, sequentially from 1 until
    ping stops. If a network is near saturation, packets may be returned out of order
    because of collisions and retries, or may be completely dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the second packet was dropped and then retried after a timeout,
    causing it to be returned out of order and with a longer Round Trip Time.
  prefs: []
  type: TYPE_NORMAL
- en: Time to live
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each ping packet has a predefined number of hops it can take before it is dropped.
    Each router decrements that value by one. This value shows how many routers are
    between your system and the site you are pinging. The initial **Time To Live**
    (**TTL**) value can vary depending on your platform or ping revision. You can
    determine the initial value by pinging the loopback connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we ping the loopback address to determine what the TTL is with
    no hops (in this case, 64). Then we ping a remote site and subtract that TTL value
    from our No-Hop value to determine how many hops are between the two sites. In
    this case, 64-45 is 19 hops.
  prefs: []
  type: TYPE_NORMAL
- en: The TTL value is usually constant between two sites, but can change when conditions
    require alternative paths.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of packets to be sent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ping` command sends echo packets and waits for the reply of echo indefinitely
    until it is stopped by pressing *Ctrl* + *C*. The `-c` flag will limit the count
    of echo packets to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, the `ping` command sends two echo packets and stops.
    This is useful when we need to ping multiple machines from a list of IP addresses
    through a script and check their statuses.
  prefs: []
  type: TYPE_NORMAL
- en: Return status of the ping command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ping` command returns the exit status `0` when it succeeds and returns
    non-zero when it fails. `Successful` means the destination host is reachable,
    whereas `Failure` is when the destination host is unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return status can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tracing IP routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application requests a service through the Internet, the server may
    be at a distant location and connected via many of gateways or routers. The `traceroute`
    command displays the address of all intermediate gateways a packet visits before
    reaching its destination. `traceroute` information helps us to understand how
    many hops each packet takes to reach a destination. The number of intermediate
    gateways represents the effective distance between two nodes in a network, which
    may not be related to the physical distance. Travel time increases with each hop.
    It takes time for a router to receive, decipher, and transmit a packet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format for the `traceroute` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`destinationIP` may be numeric or a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Modern Linux distributions also ship with an `mtr` command, which is similar
    to traceroute but shows real-time data that keeps refreshing. It is useful for
    checking your network carrier quality.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all available machines on a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we monitor a large network, we need to check the availability of all machines.
    A machine may not be available for two reasons: it is not powered on, or because
    of a problem in the network. We can write a shell script to determine and report
    which machines are available on the network.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we demonstrate two methods. The first method uses ping and the
    second method uses `fping`. The `fping` command is easier for scripts and has
    more features than the ping command. It may not be part of your Linux distribution,
    but can be installed with your package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next example script will find the visible machines on the network using
    the ping command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output resembles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script uses the `ping` command to find out the available machines on the
    network. It uses a `for` loop to iterate through a list of IP addresses generated
    by the expression `192.168.0.{1..255}`. The `{start..end}` notation generates
    values between start and end. In this case, it creates IP addresses from `192.168.0.1`
    to `192.168.0.255`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ping $ip -c 2 &> /dev/null` runs a `ping` command to the corresponding IP
    address. The `-c` option causes ping to send only two packets. The `&> /dev/null`
    redirects both `stderr` and `stdout to /dev/null`, so nothing is printed on the
    terminal. The script uses `$?` to evaluate the exit status. If it is successful,
    the exit status is `0`, and the IP address which replied to our ping is printed.'
  prefs: []
  type: TYPE_NORMAL
- en: In this script, a separate `ping` command is executed for each address, one
    after the other. This causes the script to run slowly when an IP address does
    not reply, since each ping must wait to time out before the next ping begins.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipes show enhancements to the ping script and how to use `fping`.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel pings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous script tests each address sequentially. The delay for each test
    is accumulated and becomes large. Running the ping commands in parallel will make
    this faster. Enclosing the body of the loop in `{}&` will make the `ping` commands
    run in parallel. `( )` encloses a block of commands to run as a subshell, and
    `&` sends it to the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the `for` loop, we execute many background processes and come out of the
    loop, terminating the script. The `wait` command prevents the script from terminating
    until all its child processes have exited.
  prefs: []
  type: TYPE_NORMAL
- en: The output will be in the order that pings reply. This will not be the numeric
    order in which they were sent if some machines or network segments are slower
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: Using fping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second method uses a different command called `fping`. The `fping` command
    generates ICMP messages to multiple IP addresses and then waits to see which reply.
    It runs much faster than the first script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available with `fping` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-a` option with `fping` specifies to display the IP addresses for available
    machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-u` option with `fping` specifies to display unreachable machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-g` option specifies generating a range of IP addresses from the slash-subnet
    mask notation specified as IP/mask or start and end IP addresses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`2>/dev/null` is used to dump error messages printed due to an unreachable
    host to a null device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to manually specify a list of IP addresses as command-line
    arguments or as a list through `stdin`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Playing with file descriptors and redirection* recipe in [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains the data redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Comparisons and tests* recipe in [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains numeric comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running commands on a remote host with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSH** stands for **Secure Shell**. It connects two computers across an encrypted
    tunnel. SSH gives you access to a shell on a remote computer where you can interactively
    run a single command and receive the results or start an interactive session.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH doesn't come preinstalled with all GNU/Linux distributions. You may have
    to install the `openssh-server` and `openssh-client` packages using a package
    manager. By default, SSH runs on port number `22`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To connect to a remote host with the SSH server running, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The options in this command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`username` is the user that exists at the remote host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote_host` can be the domain name or IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: SSH will ask for a password, and upon successful authentication it will connect
    to the login shell on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: SSH performs a fingerprint verification to make sure we are actually connecting
    to the remote computer we want. This is to avoid what is called a **man-in-the-middle
    attack**, where an attacker tries to impersonate another computer. SSH will, by
    default, store the fingerprint the first time we connect to a server and verify
    that it does not change for future connections.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the SSH server runs at port `22`. However, certain servers run SSH
    service at different ports. In that case, use `-p port_num` with the `ssh` command
    to specify the port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to an SSH server running at port `422`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When using `ssh` in shell scripts, we do not want an interactive shell, we simply
    want to execute commands on the remote system and process the command's output.
  prefs: []
  type: TYPE_NORMAL
- en: Issuing a password every time is not practical for an automated script, so password-less
    login using SSH keys should be configured. The *P*a*ssword-less auto-login with
    SSH* recipe in this chapter explains the SSH commands to set this up.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a command at the remote host and display its output on the local shell,
    use the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can submit multiple commands by separating the commands with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the commands executed at the remote host are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can pass a more complex subshell in the command sequence using the `( )`
    subshell operator.
  prefs: []
  type: TYPE_NORMAL
- en: The next example is an SSH-based shell script to collect the uptime of a list
    of remote hosts. Uptime is the length of time since the last power-on. It's returned
    by the `uptime` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is assumed that all systems in `IP_LIST` have a common user `test`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ssh` command can be executed with several additional options.
  prefs: []
  type: TYPE_NORMAL
- en: SSH with compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SSH protocol supports compressing the data transfer. This feature comes
    in handy when bandwidth is an issue. Use the `-C` option with the `ssh` command
    to enable compression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting data into stdin of remote host shell commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH allows you to use output from a task on your local system as input on the
    remote system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '`echo` on the remote host prints the data received through `stdin`, which in
    turn is passed to `stdin` from localhost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This facility can be used to transfer tar archives from a local host to the
    remote host. This is described in detail in [Chapter 7](3fc45121-c541-4c47-90ec-4db14dc7a60e.xhtml),
    *The Backup plan*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Running graphical commands on a remote machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you attempt to run a command on a remote machine that uses a graphical window,
    you will see an error similar to `cannot open display`. This is because the `ssh`
    shell is attempting (and failing) to connect to the X server on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run an graphical application on a remote server, you need to set the `$DISPLAY`
    variable to force the application to connect to the X server on your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the graphical output on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to show the graphical output on your local machine, use SSH''s
    X11 forwarding option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This will run the commands on the remote machine, but it will display graphics
    on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Password-less auto-login with SSH* recipe in this chapter explains how
    to configure auto-login to execute commands without prompting for a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring files through the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major use for networking computers is resource sharing. Files are a common
    shared resource. There are different methods for transferring files between systems,
    ranging from a USB stick and `sneakernet` to network links such as NFS and Samba.
    These recipes describe how to transfer files using the common protocols FTP, SFTP,
    RSYNC, and SCP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The commands for performing file transfer over the network are mostly available
    by default with Linux installation. Files can be transferred via FTP using the
    traditional `ftp` command or the newer `lftp`, or via an SSH connection using
    `scp` or `sftp`. Files can be synchronized across systems with the `rsync` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**) is old and is used in many public websites
    to share files. The service usually runs on port `21`. FTP requires that an FTP
    server be installed and running on the remote machine. We can use the traditional
    `ftp` command or the newer `lftp` command to access an FTP-enabled server. The
    following commands are supported by both `ftp` and `lftp`. FTP is used in many
    public websites to share files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to an FTP server and transfer files to and from it, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It will prompt for a password and then display a logged in prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You can type commands in this prompt, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd directory`: This will change directory on the remote system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lcd:` This will change the directory on the local machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir`: This will create a directory on the remote machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls`: This will list files in the current directory on the remote machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get FILENAME`: This will download a file to the current directory on the local
    machine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`put filename`: This will upload a file from the current directory on the remote
    machine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `quit` command will terminate an `lftp` session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocompletion is supported in the `lftp` prompt
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through additional techniques and commands used for file transfer through
    a network.
  prefs: []
  type: TYPE_NORMAL
- en: Automated FTP transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lftp` and the `ftp` commands open an interactive session with the user.
    We can automate FTP file transfers with a shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding script has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is used to send data through `stdin` to the `lftp` command. The *Playing
    with file descriptors and redirection* recipe of [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains various methods for redirection to *stdin*.
  prefs: []
  type: TYPE_NORMAL
- en: The `-u` option logs in to the remote site with our defined `USER` and `PASSWD`.
    The `binary` command sets the file mode to binary.
  prefs: []
  type: TYPE_NORMAL
- en: SFTP (Secure FTP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SFTP is a file transfer system that runs on the top of an SSH connection and
    emulates an FTP interface. It requires an SSH server on the remote system instead
    of an FTP server. It provides an interactive session with an `sftp` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Sftp supports the same commands as `ftp` and `lftp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start an `sftp` session, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `lftp`, an `sftp` session can be terminated by typing the `quit`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the SSH server will not be running at the default port `22`. If
    it is running at a different port, we can specify the port along with `sftp` as
    `-oPort=PORTNO`. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`-oPort` should be the first argument of the `sftp` command.'
  prefs: []
  type: TYPE_NORMAL
- en: The rsync command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rsync` command is widely used for copying files over networks and for taking
    backup snapshots. This is described in detail in the *Backing up snapshots with
    rsync*
  prefs: []
  type: TYPE_NORMAL
- en: recipe of [Chapter 7](3fc45121-c541-4c47-90ec-4db14dc7a60e.xhtml), *The Backup
    Plan*.
  prefs: []
  type: TYPE_NORMAL
- en: SCP (secure copy program)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SCP is a secure file copy command similar to the older, insecure remote copy
    tool called `rcp`. The files are transferred through an encrypted channel using
    SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will prompt for a password. Like `ssh`, the transfer can be made password-less
    with the auto-login SSH technique. The *Password-less auto-login with SSH* recipe
    in this chapter explains SSH auto-login. Once SSH login is automated, the scp
    command can be executed without an interactive password prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remotehost` can be an IP address or domain name. The format of the `scp`
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`SOURCE` or `DESTINATION` can be in the format `username@host:/path`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command copies a file from the remote host to the current directory
    with the given filename.
  prefs: []
  type: TYPE_NORMAL
- en: If SSH is running at a different port than `22`, use `-oPort` with the same
    syntax, `sftp`.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive copying with scp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-r` parameter tells `scp` to recursively copy a directory between two
    machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` parameter will cause `scp` to retain permissions and modes when copying
    files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Playing with file descriptors and redirection* recipe in [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains the standard input using EOF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a wireless network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ethernet connection is simple to configure, since it is connected through
    wired cables with no special requirements like authentication. However, wireless
    LAN requires an **Extended Service Set IDentification** network identifier (**ESSID**)
    and may also require a pass-phrase.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect to a wired network, we simply assign an IP address and subnet mask
    with the `ifconfig` utility. A wireless network connection requires the `iwconfig`
    and `iwlist` utilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script will connect to a wireless LAN with **WEP** (**Wired Equivalent
    Privacy**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ifconfig`, `iwconfig`, and `route` commands must be run as root. Hence,
    a check for the root user is performed before performing any actions in the scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless LAN requires parameters such as `essid`, `key`, and `frequency` to
    connect to the network. `essid` is the name of the wireless network to connect
    to. Some networks use a WEP key for authentication, which is usually a five- or
    ten-letter hex passphrase. The frequency assigned to the network is required by
    the `iwconfig` command to attach the wireless card with the proper wireless network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `iwlist` utility will scan and list the available wireless networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `Frequency` parameter can be extracted from the scan result, from the `Frequency:2.462
    GHz (Channel 11)` line.
  prefs: []
  type: TYPE_NORMAL
- en: WEP is used in this example for simplicity. Note that WEP is insecure. If you
    are administering the wireless network, use a variant of **Wi-Fi Protected Access2**
    (**WPA2**).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Comparisons and tests* recipe of [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains string comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-less auto-login with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH is widely used with automation scripting, as it makes it possible to remotely
    execute commands at remote hosts and read their outputs. Usually, SSH is authenticated
    with username and password, which are prompted during the execution of SSH commands.
    Providing passwords in automated scripts is impractical, so we need to automate
    logins. SSH has a feature which SSH allows a session to auto-login. This recipe
    describes how to create SSH keys for auto-login.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH uses an encryption technique called asymmetric keys consisting of two keys–a
    public key and a private key for automatic authentication. The `ssh-keygen` application
    creates an authentication key pair. To automate the authentication, the public
    key must be placed on the server (by appending the public key to the `~/.ssh/authorized_keys`
    file) and the private key file of the pair should be present at the `~/.ssh` directory
    of the user at the client machine. SSH configuration options (for example, path
    and name of the `authorized_keys` file) can be modified by altering the `/etc/ssh/sshd_config`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two steps to implement automatic authentication with SSH. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SSH key on the local machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring the public key to the remote host and appending it to `~/.ssh/authorized_keys`
    (which requires access to the remote machine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create an SSH key, run the `ssh-keygen` command with the encryption algorithm
    type specified as RSA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You need to enter a passphrase to generate the public-private key pair. It is
    possible to generate the key pair without entering a passphrase, but it is insecure.
  prefs: []
  type: TYPE_NORMAL
- en: If you intend to write scripts that use automated login to several machines,
    you should leave the passphrase empty to prevent the script from asking for a
    passphrase while running.
  prefs: []
  type: TYPE_NORMAL
- en: The `ssh-keygen` program creates two files. `~/.ssh/id_rsa.pub` and `~/.ssh/id_rsa:id_rsa.pub`
    is the generated public key and `id_rsa` is the private key. The public key has
    to be appended to the `~/.ssh/authorized_keys` file on remote servers where we
    need to auto-login from the current host.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will append a key file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Provide the login password in the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The auto-login has been set up from now onwards, so SSH will not prompt for
    passwords during execution. Test this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You will not be prompted for a password. Most Linux distros include `ssh-copy-id`,
    which will append your private key to the appropriate `authorized_keys` file on
    the remote server. This is shorter than the `ssh` technique described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Port forwarding using SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Port forwarding is a technique which redirects an IP connection from one host
    to another. For example, if you are using a Linux/Unix system as a firewall you
    can redirect connections to port `1234` to an internal address such as `192.168.1.10:22`
    to provide an `ssh` tunnel from the outside world to an internal machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can forward a port on your local machine to another machine and it's also
    possible to forward a port on a remote machine to another machine. In the following
    examples, you will get a shell prompt once the forwarding is complete. Keep this
    shell open to use the port forward and exit it whenever you want to stop the port
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will forward port `8000` on your local machine to port `80` on
    [www.kernel.org](http://www.kernel.org):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Replace user with the username on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will forward port 8000 on a remote machine to port `80` of [www.kernel.org](http://www.kernel.org):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, replace `REMOTE_MACHINE` with the hostname or IP address of the remote
    machine and `user` with the username you have SSH access to.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Port forwarding is more useful when using non-interactive mode or reverse port
    forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: Non-interactive port forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to just set port forwarding instead of having a shell kept open
    while port forwarding is effective, use the following form of `ssh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `-f` option instructs `ssh` to fork to background before executing the command.
    `-N` tells `ssh` that there is no command to run; we only want to forward ports.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse port forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reverse port forwarding is one of the most powerful features of SSH. This is
    most useful in situations where you have a machine which isn't publicly accessible
    from the Internet, but you want others to be able to access a service on this
    machine. In this case, if you have SSH access to a remote machine which is publicly
    accessible on the Internet, you can set up a reverse port forward on that remote
    machine to the local machine which is running the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This command will forward port `8000` on the remote machine to port `80` on
    the local machine. Don't forget to replace `REMOTE_MACHINE` with the hostname
    of the IP address of the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, if you browse to `http://localhost:8000` on the remote machine,
    you will connect to a web server running on port `80` of the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a remote drive at a local mount point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a local mount point to access the remote host filesystem facilitates
    read and write data transfer operations. SSH is the common transfer protocol.
    The `sshfs` application uses SSH to enable you to mount a remote filesystem on
    a local mount point.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sshfs` doesn''t come by default with GNU/Linux distributions. Install `sshfs`
    with a package manager. `sshfs` is an extension to the FUSE filesystem package
    that allows users to mount a wide variety of data as if it were a local filesystem.
    Variants of FUSE are supported on Linux, Unix, Mac OS/X, Windows, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on FUSE, visit its website at [http://fuse.sourceforge.net/](http://fuse.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To mount a filesystem location at a remote host to a local mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Issue the password when prompted. After the password is accepted, the data at
    `/home/path` on the remote host can be accessed via a local mount point, `/mnt/mountpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unmount, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running commands on a remote host with SSH* recipe in this chapter explains
    the `ssh` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network traffic and port analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application that accesses the network does it via a port. Listing the
    open ports, the application using a port and the user running the application
    is a way to track the expected and unexpected uses of your system. This information
    can be used to allocate resources as well as checking for rootkits or other malware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Various commands are available for listing ports and services running on a network
    node. The `lsof` and `netstat` commands are available on most GNU/Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `lsof` (list open files) command will list open files. The `-i` option
    limits it to open network connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Each entry in the output of `lsof` corresponds to a service with an active
    network port. The last column of output consists of lines similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this output, `laptop.local:41197` corresponds to the `localhost` and `192.168.0.2:3128`
    corresponds to the remote host. `41197` is the port used on the current machine,
    and `3128` is the port to which the service connects at the remote host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the opened ports from the current machine, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `:[0-9a-z]+->` regex for grep extracts the host port portion `(:34395->
    or :ssh->)` from the `lsof` output. The next `grep` removes the leading colon
    and trailing arrow leaving the port number (which is alphanumeric). Multiple connections
    may occur through the same port and hence, multiple entries of the same port may
    occur. The output is sorted and passed through `uniq` to display each port only
    once.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more utilities that report open port and network traffic related information.
  prefs: []
  type: TYPE_NORMAL
- en: Opened port and services using netstat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`netstat` also returns network service statistics. It has many features beyond
    what is covered in this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `netstat -tnp` to list opened port and services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Measuring network bandwidth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous discussion of `ping` and `traceroute` was on measuring the latency
    of a network and the number of hops between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The `iperf` application provides more metrics for a networks' performance. The
    `iperf` application is not installed by default, but it is provided by most distributions'
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `iperf` application must be installed on both ends of a link (a host and
    a client). Once `iperf` is installed, start the server end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the client side to generate throughput statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-m` option instructs `iperf` to also find the **Maximum Transfer Size**
    (**MTU**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Creating arbitrary sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For operations such as file transfer and secure shell, there are prebuilt tools
    such as ftp and `ssh`. We can also write custom scripts as network services. The
    next recipe demonstrates how to create simple network sockets and use them for
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `netcat` or `nc` command will create network sockets to transfer data over
    a TCP/IP network. We need two sockets: one listens for connections and the other
    connects to the listener.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Set up the listening socket using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This will create a listening socket on port `1234` on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect to the socket using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: If you are running this on the same machine as the listening socket, replace
    `HOST` with localhost, otherwise replace it with the IP address or hostname of
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Type something and press *Enter* on the terminal where you performed step 2\.
    The message will appear on the terminal where you performed step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network sockets can be used for more than just text communication, as shown
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Quickly copying files over the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can exploit `netcat` and shell redirection to copy files over the network.
    This command will send a file to the listening machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the listening machine, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'On the sender machine, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Creating a broadcasting server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use `netcan` to create a custom server. The next recipe demonstrates
    a server that will send the time every 10 seconds. The time can be received by
    connecting to the port with a client `nc` session of telnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copying files with `nc` works because ns echoes the input from the input of
    one socket to the output at the other.
  prefs: []
  type: TYPE_NORMAL
- en: The broadcasting server is a bit more complicated. The `while [ 1 ]` loop will
    run forever. Within the loop, the script sleeps for 10 seconds, then invokes the
    date command and pipes the output to the `nc` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `nc` to create a client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Building a bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have two separate networks, you may need a way to pass data from one
    network to the other. This is commonly done by connecting the two subnets with
    a router, hub, or switch.
  prefs: []
  type: TYPE_NORMAL
- en: A Linux system can be used for a network bridge.
  prefs: []
  type: TYPE_NORMAL
- en: A bridge is a low-level connection that passes packets based on their MAC address
    instead of being identified by the IP address. As such it requires fewer machine
    resources and is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a bridge to link virtual machines on private, non-routed networks,
    or to link separate subnets in a company, for instance, to link a manufacturing
    subnet to the shipping sub-net so production information can be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel has supported network bridges since the 2.2 kernel. The current
    tool to define a bridge, is the iproute2 (`ip`) command. This is standard in most
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ip command performs several actions using the command/subcommand model.
    To create a bridge, we use the `ip link` commands.
  prefs: []
  type: TYPE_NORMAL
- en: The Ethernet adapter being attached to the bridge should not be configured with
    an IP address when it is added to the bridge. The bridge is configured with an
    address, not the NIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, there are two NIC cards: `eth0` is configured and connected
    to the `192.168.1.0` subnet, while eth1 is not configured but will be connected
    to the `10.0.0.0` subnet via the bridge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This creates the bridge allowing packets to be sent from `eth0` to `eth1` and
    back. Before the bridge can be useful, we need to add this bridge to the routing
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'On machines in the `10.0.0.0/24` network, we add a route to the `192.168.1.0/16`
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Machines on the `192.168.1.0/16` subnet need to know how to find the `10.0.0.0/24`
    subnet. If the `eth0` card is configured for IP address `192.168.1.2`, the route
    command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Sharing an Internet connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most firewall/routers have the ability to share an Internet connection with
    the devices in your home or office. This is called **Network Address Translation**
    (**NAT**). A Linux computer with two **Network Interface Cards** (**NIC**) can
    act as a router, providing firewall protection and connection sharing.
  prefs: []
  type: TYPE_NORMAL
- en: Firewalling and NAT support are provided by the support for iptables built into
    the kernel. This recipe introduces `iptables` with a recipe that shares a computer's
    Ethernet link to the Internet through the wireless interface to give other wireless
    devices access to the Internet via the host's Ethernet NIC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe uses `iptables` to define a **Network Address Translation** (**NAT**),
    which lets a networking device share a connection with other devices. You will
    need the name of your wireless interface, which is reported by the `iwconfig`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connect to the Internet. In this recipe, we are assuming that the primary wired
    network connection, `eth0`, is connected to the Internet. Change it according
    to your setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using your distro''s network management tool, create a new ad hoc wireless
    connection with the following settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IP address: 10.99.66.55'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet mask: 255.255.0.0 (16)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the following shell script to share the Internet connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here `eth0` is the interface that is connected to the Internet and `wlan0` is
    the wireless interface that is supposed to share the Internet with other devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect your devices to the wireless network you just created with the following
    settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'IP address: 10.99.66.56 (and so on)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subnet mask: 255.255.0.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this more convenient, you might want to install a DHCP and DNS server
    on your machine, so it's not necessary to configure IPs on devices manually. A
    handy tool for this is `dnsmasq`, which performs both DHCP and DNS operations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three sets of IP addresses set aside for non-routing use. That means
    that no network interface visible to the Internet can use them. They are only
    used by machines on a local, internal network. The addresses are `10.x.x.x`, `192.168.x.x`,
    and `172.16.x.x-> 172.32.x.x`. In this recipe, we use a portion of the `10.x.x.x`
    address space for our internal network.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Linux systems will accept or generate packets, but will not echo
    them. This is controlled by the value `in/proc/sys/net/ipv4/ip_forward`.
  prefs: []
  type: TYPE_NORMAL
- en: Echoing a `1` to that location tells the Linux kernel to forward any packet
    it doesn't recognize. This allows the wireless devices on the `10.99.66.x` subnet
    to use `10.99.66.55` as their gateway. They will send a packet destined for an
    Internet site to `10.99.66.55`, which will then forward it out its gateway on
    `eth0` to the Internet to be routed to the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The `iptables` command is how we interact with the Linux kernel's iptables subsystem.
    These commands add rules to forward all packets from the internal network to the
    outside world and to forward expected packets from the outside world to our internal
    network.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe will discuss more ways to use iptables.
  prefs: []
  type: TYPE_NORMAL
- en: Basic firewall using iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A firewall is a network service that is used to filter network traffic for unwanted
    traffic, block it, and allow the desired traffic to pass. The standard firewall
    tool for Linux is `iptables`, which is integrated into the kernel in recent versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`iptables` is present by default on all modern Linux distributions. It''s easy
    to configure for common scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If don''t want to contact a given site (for example, a known malware site),
    you can block traffic to that IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `PING 8.8.8.8` in another terminal, then by running the `iptables`
    command, you will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Here, the ping fails the third time because we used the `iptables` command to
    drop all traffic to `8.8.8.8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also block traffic to a specific port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find messages like this in your `/var/log/secure` or `var/log/messages`
    file, you have a small problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: These messages mean a robot is probing your system for weak passwords. You can
    prevent the robot from accessing your site with an INPUT rule that will drop all
    traffic from that site.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`iptables` is the command used to configure the firewall on Linux. The first
    argument in `iptables` is -A, which instructs `iptables` to append a new rule
    to the chain, or -I, which places the new rule at the start of the ruleset. The
    next parameter defines the chain. A chain is a collection of rules, and in earlier
    recipes we used the `OUTPUT` chain, which is evaluated for outgoing traffic, whereas
    the last recipes used the `INPUT` chain, which is evaluated for incoming traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: The `-d` parameter specifies the destination to match with the packet being
    sent, and  `-s` specifies the source of a packet. Finally, the `-j` parameter
    instructs `iptables` to jump to a particular action. In these examples, we used
    the DROP action to drop the packet. Other actions include `ACCEPT` and `REJECT`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we use the `-p` parameter to specify that this rule matches
    only TCP on the port specified with `-dport`. This blocks only the outbound `FTP`
    traffic.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can clear the changes made to the `iptables` chains with the `-flush` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Virtual Private Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Virtual Private Network** (**VPN**) is an encrypted channel that operates
    across public networks. The encryption keeps your information private. VPNs are
    used to connect remote offices, distributed manufacturing sites, and remote workers.
  prefs: []
  type: TYPE_NORMAL
- en: We've discussed copying files with `nc`, or `scp`, or `ssh`. With a VPN network,
    you can mount remote drives via NFS and access resources on the remote network
    as if they were local.
  prefs: []
  type: TYPE_NORMAL
- en: Linux has clients for several VPN systems, as well as client and server support
    for OpenVPN.
  prefs: []
  type: TYPE_NORMAL
- en: This section's recipes will describe setting up an OpenVPN server and client.
    This recipe is to configure a single server to service multiple clients in a hub
    and spoke model. OpenVPN supports more topologies that are beyond the scope of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenVPN is not part of most Linux distributions. You can install it using your
    package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this command can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note that you'll need to do this on the server and each client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm that the tunnel device (`/dev/net/tun`) exists. Test this on server
    and client systems. On modern Linux systems, the tunnel should already exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in setting up an OpenVPN network is to create the certificates
    for the server and at least one client. The simplest way to handle this is to
    make self-signed certificates with the `easy-rsa` package included with pre-version
    2.3 releases of OpenVPN. If you have a later version of OpenVPN, `easy-rsa` should
    be available via the package manager.
  prefs: []
  type: TYPE_NORMAL
- en: This package is probably installed in `/usr/share/easy-rsa`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, make sure you''ve got a clean slate with nothing left over from previous
    installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'NOTE: If you run `./clean-all`, I will be doing a `rm -rf` on `/usr/share/easy-rsa/keys`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the **Certificate Authority** key with the `build-ca` command.
    This command will prompt you for information about your site. You''ll have to
    enter this information several times. Substitute your name, e-mail, site name,
    and so on for the values in this recipe. The required information varies slightly
    between commands. Only the unique sections will be repeated in these recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a certificate for at least one client. You''ll need a separate client
    certificate for each machine that you wish to connect to this OpenVPN server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, generate the **Diffie-Hellman** with the `build-dh` command. This
    will take several seconds and will generate a few screens filled with dots and
    plusses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: These steps will create several files in the keys folder. The next step is to
    copy them to the folders where they'll be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy server keys to `/etc/openvpn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the client keys to the client system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Configuring OpenVPN on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenVPN includes sample configuration files that are almost ready to use. You
    only need to customize a few lines for your environment. The files are commonly
    found in `/usr/share/doc/openvpn/examples/sample-config-files`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the local IP address to listen on. This is the IP address of the NIC attached
    to the network you intend to allow VPN connections through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Finally, check that the `diffie-hellman` parameter file is correct. The OpenVPN
    sample `config` file may specify a 1024-bit length key, while the `easy-rsa` creates
    a 2048-bit (more secure) key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Configuring OpenVPN on the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a similar set of configurations to do on each client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the client configuration file to `/etc/openvpn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `client.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the paths for the certificates to the point to correct folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the remote site for your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Starting the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server can be started now. If everything is configured correctly, you''ll
    see it output several lines of output. The important line to look for is the `Initialization
    Sequence Completed` line. If that is missing, look for an error message earlier
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `ifconfig`, you can confirm that the server is running. You should see
    the tunnel device (tun) listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Starting and testing a client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the server is running, you can start a client. Like the server, the client
    side of OpenVPN is created with the `openvpn` command. Again, the important part
    of this output is the `Initialization Sequence Completed` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `ifconfig` command, you can confirm that the tunnel has been initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `netstat` command to confirm that the new network is routed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the tunnel device connected to the `10.8.0.x` network, and
    the gateway is `10.8.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can test connectivity with the `ping` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
