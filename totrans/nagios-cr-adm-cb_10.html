<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Security and Performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Security and Performance</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Requiring authentication for the web interface</li><li class="listitem" style="list-style-type: disc">Using authenticated contacts</li><li class="listitem" style="list-style-type: disc">Writing debugging information to the Nagios log file</li><li class="listitem" style="list-style-type: disc">Monitoring Nagios performance with Nagiostats</li><li class="listitem" style="list-style-type: disc">Improving startup times with pre-cached object files</li><li class="listitem" style="list-style-type: disc">Setting up a redundant monitoring host</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec84"/>Introduction</h1></div></div></div><p>Most administrators of even mid-size networks will choose to dedicate an entire server to monitoring software, and sometimes a whole server just for Nagios Core. This is because of two main factors common to most comprehensive Nagios Core setups:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They have a lot of privileges, because in order to inspect the running state of so many different hosts and services, they need to be conferred appropriate network access. This often means that their IP addresses are whitelisted all over the network. A user who is able to assume that privilege could potentially do a lot of damage.</li><li class="listitem" style="list-style-type: disc">They have a lot of work to do, and hence ideally have dedicated software and hardware resources to run what can be thousands of host and service checks smoothly and to promptly notice problems and recoveries. If a Nagios Core server is not able to keep up with its check schedule, it could cause delays in notifications about very important services.</li></ul></div><p>It's therefore very important to take into account the security and performance of your Nagios Core server when building your configuration.</p><p>General best network security practices apply to Nagios Core management and will not be discussed in depth here. The following general guidelines are just as relevant to securing a Nagios Core server as they are any other <a id="id583" class="indexterm"/>kind of server:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Don't run the server as root</strong></span>: This is probably not a concern unless you've changed it yourself, as if you've installed using the <a id="id584" class="indexterm"/>Quick Start Guides the server should be set up to run as the unprivileged <code class="literal">nagios</code> user. Nagios Core should not need <code class="literal">root</code> privileges under most circumstances.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use a firewall</strong></span>: The protections offered by Nagios Core, NSCA, and NRPE's host checking are very basic and are not a replacement for a software or hardware firewall policy. Even a simple <code class="literal">iptables</code> or <code class="literal">pf</code> software firewall would be a very good idea to protect a monitoring server.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Use the principle of least privilege</strong></span>: Don't confer Nagios Core or any of its plugins or processes more privileges than they need, and lock down writable files, such as <code class="literal">logs</code>, and state information only to appropriate users. Similarly, only allow Nagios Core access through firewalls for what it needs to check, and nothing else.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Encrypt sensitive information</strong></span>: Don't put credentials in plain text in any of the configuration files if you can avoid it, and if you can't avoid it, define them in resource files that are only readable by the <code class="literal">nagios</code> user.</li></ul></div><p>You should therefore not consider this chapter a complete guide to securing and optimizing your Nagios Core server. For a more comprehensive treatment of security and optimization procedures, be sure to take a look at these pages in the Nagios Core documentation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Security Considerations</strong></span>: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/security.html">http://nagios.sourceforge.net/docs/3_0/security.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Enhanced CGI Security and </strong></span><a id="id585" class="indexterm"/><span class="strong"><strong>Authentication</strong></span>: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/cgisecurity.html">http://nagios.sourceforge.net/docs/3_0/cgisecurity.html</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Tuning Nagios for Maximum </strong></span><a id="id586" class="indexterm"/><span class="strong"><strong>Performance</strong></span>: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/tuning.html">http://nagios.sourceforge.net/docs/3_0/tuning.html</a></li></ul></div><p>In particular, this chapter will focus on securing the CGIs, as the web interface is readily exposing Nagios Core's information to the world, and is particularly vulnerable to abuse if misconfigured. It will also include methods to assess how Nagios Core is performing.</p></div></div>
<div class="section" title="Requiring authentication for the web interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec85"/>Requiring authentication for the web interface</h1></div></div></div><p>In this recipe, we'll explore the use of basic authentication for the Nagios Core web interface, probably the single most important <a id="id587" class="indexterm"/>
<a id="id588" class="indexterm"/>configuration step in preventing abuse of the software by malicious users.</p><p>By default, the Nagios Core installation process takes the sensible step of locking down the authentication by default in its recommended Apache configuration file, with standard HTTP authentication for a default user named <code class="literal">nagiosadmin</code>, with full privileges.</p><p>Unfortunately, some administrators take the step of removing this authentication or never installing it, in spite of the recommendations in the installation guide. It's a good idea to install it and keep it in place even on private networks, and especially if the server running Nagios Core is open to the Internet in any way (generally not advised).</p><p>This is not just because of the security benefits, but also because it allows you to set up basic access control, allowing certain users the permission to read state or run commands on certain resources, but not on others. It also has other more subtle benefits, such as recording the names of users that carry out actions for logging purposes.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec340"/>Getting ready</h2></div></div></div><p>You'll need access to the backend of a Nagios Core server with version 3.0 or greater, to change its configuration and restart it. You'll also need a functioning web interface. Much of this recipe will assume the web interface is running on the recommended <span class="strong"><strong>Apache HTTPD server</strong></span>; <a id="id589" class="indexterm"/>you may also need to be able to edit this configuration. Some familiarity with Apache HTTPD is assumed here; the documentation available online is excellent if you need to consult it:</p><p>
<a class="ulink" href="https://httpd.apache.org/docs/">https://httpd.apache.org/docs/</a>
</p><p>This recipe will be in two parts: we'll first ensure that all the recommended settings are in place to properly require authentication, and we'll then demonstrate adding a user named <code class="literal">helpdesk</code> with read-only permissions for the server's web interface. This user will be able to read the states of all the hosts and services, but will not be able to (for example) issue commands, or submit passive check results.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec341"/>How to do it...</h2></div></div></div><p>We can ensure proper authentication is in place for the Nagios Core web interface as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Clear your browser of all cookies and saved authentication data, and try to visit the web interface. If your browser does not challenge you for a username or password as follows, then it's likely that your authentication is disabled or not working correctly:<div class="mediaobject"><img src="graphics/5566_10_01.jpg" alt="How to do it..."/></div></li><li class="listitem">On the server, move to the Nagios Core configuration directory and open the <code class="literal">cgi.cfg</code> file. In the default installation, this is saved in <code class="literal">/usr/local/nagios/etc/cgi.cfg</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc</strong></span>
<span class="strong"><strong># vi cgi.cfg</strong></span>
</pre></div></li><li class="listitem">Ensure that the value for <code class="literal">use_authentication</code> is uncommented and set to <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting">use_authentication=1</pre></div></li><li class="listitem">Ensure that the <code class="literal">default_user_name</code> directive is <a id="id590" class="indexterm"/>commented out:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#default_user_name=guest</strong></span>
</pre></div></li><li class="listitem">In the <code class="literal">nagios.conf</code> file in your Apache configuration, check that the following lines are included to refer to the <code class="literal">htpasswd.users</code> file:<div class="informalexample"><pre class="programlisting">AuthName "Nagios Access"
AuthType Basic
AuthUserFile /usr/local/nagios/etc/htpasswd.users
Require valid-user</pre></div><p>This file should be somewhere in the configuration directory for Apache, for example <code class="literal">/etc/apache/conf.d/nagios.conf</code>. If you need to make changes to Apache's configuration to fix this, you will need to restart Apache to have the changes take effect.</p></li></ol></div><p>We can add a read-only user named <code class="literal">helpdesk</code> as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the user to the <code class="literal">htpasswd.users</code> file using <code class="literal">htpasswd</code>, the Apache HTTPD password manager. Its location will vary depending on your system; common locations are <code class="literal">/usr/bin</code> and <code class="literal">/usr/local/apache/bin</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># htpasswd /usr/local/nagios/etc/htpasswd.users helpdesk</strong></span>
<span class="strong"><strong>New password:</strong></span>
<span class="strong"><strong>Re-type new password:</strong></span>
<span class="strong"><strong>Adding password for user helpdesk</strong></span>
</pre></div><p>You may like to make the <code class="literal">htpasswd.users</code> file only readable by the web server user if you are concerned about the <a id="id591" class="indexterm"/>hashes being stolen by users on the system.</p></li><li class="listitem">In <code class="literal">cgi.cfg</code>, uncomment the <code class="literal">authorized_for_read_only</code> directive and add the new <code class="literal">helpdesk</code> user to its value:<div class="informalexample"><pre class="programlisting">authorized_for_read_only=helpdesk</pre></div></li><li class="listitem">Add the user to the values for the <a id="id592" class="indexterm"/><code class="literal">authorized_for_all_services</code> and <code class="literal">authorized_for_all_hosts</code> <a id="id593" class="indexterm"/>directives:<div class="informalexample"><pre class="programlisting">authorized_for_all_services=nagiosadmin,helpdesk
authorized_for_all_hosts=nagiosadmin,helpdesk</pre></div><p>Be careful not to confuse these with the <code class="literal">authorized_for_all_service_commands</code> and <code class="literal">authorized_for_all_host_commands</code> directives.</p></li></ol></div><p>You should not need to restart the Nagios Core server for these changes to take effect as you normally would with other <code class="literal">.cfg</code> files.</p><p>With this done, you should only be able to access the Nagios Core web interface with a valid username and password. The default <code class="literal">nagiosadmin</code> user created on installation should have full privileges, and the <code class="literal">helpdesk</code> user added in this recipe should be able to view host and service states, but will be unable to issue any commands such as rescheduling checks or submitting passive check results.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec342"/>How it works...</h2></div></div></div><p>It's important to note that it isn't actually Nagios Core itself prompting for the username and password and running the authentication check; this is a function performed by the web server, as specified in the <code class="literal">nagios.conf</code> file recommended for installation with Apache HTTPD.</p><p>After login, however, Nagios Core uses the permissions <a id="id594" class="indexterm"/>defined in the <code class="literal">cgi.cfg</code> file each time one of the CGI scripts in the web interface is accessed, to ensure that the user as authenticated with the web server has permissions to view the requested page, or execute the requested action.</p><p>We disable the <a id="id595" class="indexterm"/>
<code class="literal">default_user_name</code> directive by commenting it out, because this specifies a user that Nagios Core will "assume" for users who access the CGIs without authenticating. This is a potentially dangerous setting and is best avoided in most circumstances, particularly with a server with publicly <a id="id596" class="indexterm"/>accessible addresses.</p><p>The following directives in <code class="literal">cgi.cfg</code> allow refining permissions for using the CGIs, to form a simple kind of access control list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_configuration_information</code>: The <a id="id597" class="indexterm"/>specified users are allowed to view configuration information for hosts in the web interface</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_system_information</code>: <a id="id598" class="indexterm"/>The specified users are allowed to view Nagios Core process and performance information</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_system_commands</code>: The <a id="id599" class="indexterm"/>specified users are allowed to run commands affecting the Nagios Core process, such as shutdowns and restarts</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_all_services</code>: The <a id="id600" class="indexterm"/>specified users are allowed to view status information and history for all services</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_all_hosts</code>: The specified <a id="id601" class="indexterm"/>users are allowed to view status information and history for all hosts</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_all_service_commands</code><a id="id602" class="indexterm"/>: The specified users are allowed to run commands on all services, such as rescheduling checks or submitting passive check results</li><li class="listitem" style="list-style-type: disc"><code class="literal">authorized_for_all_host_commands</code>: The <a id="id603" class="indexterm"/>specified users are allowed to run commands on all hosts, such as rescheduling checks or submitting passive check results</li></ul></div><p>Further refining access per-service and per-host is done with authenticated contacts, demonstrated in the <span class="emphasis"><em>Using authenticated contacts</em></span> recipe in this chapter. This is highly recommended for teams with mixed responsibilities that all require <a id="id604" class="indexterm"/>access to the same Nagios Core web interface.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec343"/>There's more...</h2></div></div></div><p>Besides authentication via Apache HTTPD, it's also often sensible to limit the IP addresses allowed access to the Nagios Core instance, using <code class="literal">Order</code> and <code class="literal">Allow</code> Apache directives. We could extend the <code class="literal">nagios.conf</code> file loaded by Apache as follows:</p><div class="informalexample"><pre class="programlisting">&lt;Directory "/usr/local/nagios/sbin"&gt;
    Options ExecCGI
    AllowOverride None
    AuthName "Nagios Access"
    AuthType Basic
    AuthUserFile /usr/local/nagios/etc/htpasswd.users
    Require valid-user
<span class="strong"><strong>    Order Allow,Deny</strong></span>
<span class="strong"><strong>    Deny from all</strong></span>
<span class="strong"><strong>    Allow from 127.0.0.0/16</strong></span>
<span class="strong"><strong>    Allow from 10.128.0.1</strong></span>
&lt;/Directory&gt;</pre></div><p>This would only allow local addresses and <code class="literal">10.128.0.1</code> to access the CGIs, denying access with <code class="literal">403 Forbidden</code> to anyone else. Similarly, we could arrange to only allow connections over HTTPS, perhaps with an <code class="literal">SSLRequireSSL</code> directive; in general, we can configure Apache to carefully control even accessing the CGIs, let alone abusing them.</p><p>Note that none of this should take the place of an appropriate firewall solution and policy. A monitoring server should be protected as carefully as any other mission-critical server.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec344"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using authenticated contacts</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Viewing configuration in the web interface</em></span> and <span class="emphasis"><em>Scheduling checks from the web interface</em></span> recipes in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>, <span class="emphasis"><em>Working With the Web Interface</em></span></li></ul></div></div></div>
<div class="section" title="Using authenticated contacts"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec86"/>Using authenticated contacts</h1></div></div></div><p>In this recipe, we'll learn how to use authenticated contacts to refine our control of access to information in the Nagios Core web interface. This recipe is <a id="id605" class="indexterm"/>
<a id="id606" class="indexterm"/>useful in situations where a particular user requires information on the status of certain hosts and services but should not be allowed to view others, a setup which can't be managed with the directives in <code class="literal">cgi.cfg</code>.</p><p>As a simple example, on a given monitoring server, we might have two hosts configured thus:</p><div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  sparta.naginet
    alias      sparta
    address    10.128.0.21
    contacts   nagiosadmin
}
define host {
    use        linux-server
    host_name  athens.naginet
    alias      athens
    address    10.128.0.22
    contacts   nagiosadmin
}</pre></div><p>We might like to add a new user <code class="literal">athensadmin</code> with permissions to view the status of and run commands on the <code class="literal">athens.naginet</code> host and its services, but not the <code class="literal">sparta.naginet</code> host or its services.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec345"/>Getting ready</h2></div></div></div><p>You'll need access to the backend of a Nagios Core server with version 3.0 or greater, to change its configuration and restart it. You'll also need a <a id="id607" class="indexterm"/>functioning web interface with authentication running, and be familiar with how it works; the <span class="emphasis"><em>Requiring authentication for the web interface</em></span> recipe in this chapter explains how to do this.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec346"/>How to do it...</h2></div></div></div><p>We can add an authenticated contact as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new user in the <code class="literal">htpasswd.users</code> file named <code class="literal">athensadmin</code>, using the <code class="literal">htpasswd</code> tool:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># htpasswd /usr/local/nagios/etc/htpasswd.users athensadmin</strong></span>
<span class="strong"><strong>New password:</strong></span>
<span class="strong"><strong>Re-type new password:</strong></span>
<span class="strong"><strong>Adding password for user athensadmin</strong></span>
</pre></div></li><li class="listitem">Log in to the Nagios Core web interface with the credentials you just added, and click on <span class="strong"><strong>Hosts</strong></span> in the left menu to verify that you are not able to view any information yet:<div class="mediaobject"><img src="graphics/5566_10_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Back on the command line, change to the Nagios Core objects configuration directory. In the quick start guide <a id="id608" class="indexterm"/>installation, this is <code class="literal">/usr/local/nagios/etc/objects</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the <code class="literal">contacts.cfg</code> file to include a definition for a new contact object, <code class="literal">athensadmin</code>. Here, we've used the <code class="literal">generic-contact</code> template. You can use your own template or values <a id="id609" class="indexterm"/>if you prefer; the value for <code class="literal">contact_name</code> is the important part:<div class="informalexample"><pre class="programlisting">define contact {
    use           generic-contact
<span class="strong"><strong>    contact_name  athensadmin</strong></span>
    alias         Athens Administrator
    email         athens@example.com
}</pre></div></li><li class="listitem">Edit the hosts or services to which you want to allow the <code class="literal">athensadmin</code> user access, and add <code class="literal">athensadmin</code> to its list of contacts. <a id="id610" class="indexterm"/>For our example, this means the definition for <code class="literal">athens.naginet</code> looks similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  athens.naginet
    alias      athens
    address    10.128.0.22
<span class="strong"><strong>    contacts   nagiosadmin,athensadmin</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, logging in as the <code class="literal">athensadmin</code> user should allow you to view the details of the <code class="literal">athens.naginet</code> host, but nothing else:</p><div class="mediaobject"><img src="graphics/5566_10_03.jpg" alt="How to do it..."/></div><p>You should also be able to issue commands related to that host, such as rescheduling checks and acknowledging issues.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec347"/>How it works...</h2></div></div></div><p>When logging in as an authenticated user with Apache HTTPD, Nagios Core checks the username to see if it matches the <a id="id611" class="indexterm"/>
<code class="literal">contact_name</code> directive of any configured contacts. If it does, then privileges to inspect the state of that contact's associated hosts and services are granted, along with the ability to run commands on only those hosts and services. The web interface otherwise works in just the same way. <a id="id612" class="indexterm"/>
<a id="id613" class="indexterm"/>To the authenticated contact, it appears as if no other hosts or services are being monitored.</p><p>If your network includes co-located equipment or teams with mixed monitoring responsibilities, this will allow you to restrict the Nagios Core interface to certain hosts for certain users. This can be very useful for confidentiality, transparency, and delegation purposes.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec348"/>There's more...</h2></div></div></div><p>If you want to allow an authenticated user read-only access to the details for their associated hosts or services, you can arrange that by adding their username to the values of the <a id="id614" class="indexterm"/>
<code class="literal">authorized_for_read_only</code> directive in <code class="literal">cgi.cfg</code>:</p><div class="informalexample"><pre class="programlisting">authorized_for_read_only=athensadmin</pre></div><p>The <code class="literal">athensadmin</code> user will then still be able to view the same host and service information, but will not be able to issue any commands:</p><div class="mediaobject"><img src="graphics/5566_10_04.jpg" alt="There's more..."/></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec349"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Requiring authentication for the web interface</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new contact</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li></ul></div></div></div>
<div class="section" title="Writing debugging information to a Nagios log file"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Writing debugging information to a Nagios log file</h1></div></div></div><p>In this recipe, we'll learn how to use the debugging log file in Nagios Core to get various kinds of process information from the running program, <a id="id615" class="indexterm"/>considerably more than available in the file specified by the standard <code class="literal">log_file</code> directive. <a id="id616" class="indexterm"/>This is useful not just for debugging purposes when Nagios Core is doing something unexpected at runtime, but also to get a better idea of how the server is working in general and with your particular configuration.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec350"/>Getting ready</h2></div></div></div><p>You will need a Nagios Core server with version 3.0 or greater. More debugging options are available in versions after 3.0, but these will be noted in the recipe. You will need access to change the <code class="literal">nagios.cfg</code> file and to restart the server.</p><p>In this example, we'll simply log everything we possibly can, and then explain how to refine the logging behavior if necessary in the <span class="emphasis"><em>How it works…</em></span> section.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec351"/>How to do it...</h2></div></div></div><p>We can enable very verbose debugging for our monitoring server as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the configuration directory for Nagios Core. In the default installation, this is <code class="literal">/usr/local/nagios/etc</code>. Edit the file <code class="literal">nagios.cfg</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc</strong></span>
<span class="strong"><strong># vi nagios.cfg</strong></span>
</pre></div></li><li class="listitem">Look for the <code class="literal">debug_level</code>, <code class="literal">debug_verbosity</code>, and <code class="literal">debug_file</code> directives. Ensure they are uncommented or add them to the end of the file if they don't exist, and define them as follows:<div class="informalexample"><pre class="programlisting">debug_level=-1
debug_verbosity=2
debug_file=/usr/local/nagios/var/nagios.debug</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, the <code class="literal">/usr/local/nagios/var/nagios.debug</code> file should start filling with information about the running process quite quickly. You may find it instructive to watch it for a while with <code class="literal">tail -f</code>, which will show you the <a id="id617" class="indexterm"/>contents of the file as it updates:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># tail -f /usr/local/nagios/var/nagios.debug</strong></span>
<span class="strong"><strong>[1347529967.839794] [008.2] [pid=14621] No events to execute at the moment. Idling for a bit...</strong></span>
<span class="strong"><strong>[1347529967.839799] [001.0] [pid=14621] check_for_external_commands()</strong></span>
<span class="strong"><strong>[1347529967.839805] [064.1] [pid=14621] Making callbacks (type 8)...</strong></span>
<span class="strong"><strong>[1347529968.089971] [008.1] [pid=14621] ** Event Check Loop</strong></span>
<span class="strong"><strong>[1347529968.090027] [008.1] [pid=14621] Next High Priority Event Time: Thu Sep 13 21:52:52 2012</strong></span>
<span class="strong"><strong>[1347529968.090038] [008.1] [pid=14621] Next Low Priority Event Time:  Thu Sep 13 21:53:00 2012</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec352"/>How it works...</h2></div></div></div><p>The <code class="literal">debug_level</code> directive <a id="id618" class="indexterm"/>specifies how much information (and of what kind) should be written to the debugging log. Here we've used the value <code class="literal">-1</code>, which is a shortcut for specifying that all debugging information should be written to the debugging log file.</p><p>In practice, however, we often only want to get information about particular kinds of Nagios Core tasks. In this case, we can use <code class="literal">OR</code> values for <code class="literal">debug_level</code> to specify which ones.</p><p>The different kinds of debugging information can be specified with the following numbers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">1</code>: Function enter and exit debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">2</code>: Configuration debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">4</code>: Process debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">8</code>: Scheduled event debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">16</code>: Host and service check debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">32</code>: Notification debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">64</code>: Event broker debugging</li></ul></div><p>In version 3.3 and later of Nagios Core, the following can also be specified. There may be even more added in subsequent versions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">128</code>: External commands debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">256</code>: Commands debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">512</code>: Scheduled downtime debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">1024</code>: Comments debugging</li><li class="listitem" style="list-style-type: disc"><code class="literal">2048</code>: Macros debugging</li></ul></div><p>Rather than comma-separating these values to specify more than one, they are added together. For example, if we wanted to save process and scheduled event debugging information and nothing else, we would use <code class="literal">4 + 8 = 12</code>:</p><div class="informalexample"><pre class="programlisting">debug_level=12</pre></div><p>We can turn the debugging off completely by changing <code class="literal">debug_level</code> back to <code class="literal">0</code>, its default value.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec353"/>There's more...</h2></div></div></div><p>Nagios Core generates a great deal of information at the highest level of debugging, with over 30 lines per second even on minimal configurations, so be careful not to leave this running permanently if you don't always need it, as it can slowly fill a disk. You can avoid this situation by using the <a id="id619" class="indexterm"/>
<code class="literal">max_debug_file_size</code> directive to specify a maximum size in bytes for the file. For example, to restrict the file to one megabyte, we could define the following:</p><div class="informalexample"><pre class="programlisting">max_debug_file_size=1000000</pre></div><p>Nagios Core will "roll" an existing debugging log by adding the extension <code class="literal">.old</code> when it exceeds this size, and will start a new one. It will also automatically delete any previous logs with the <code class="literal">.old</code> extension when it does this.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec354"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring Nagios performance with Nagiostats </em></span>recipe in this chapter </li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Viewing and interpreting notification history</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>, <span class="emphasis"><em>Working With the Web Interface</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring Nagios performance with Nagiostats"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Monitoring Nagios performance with Nagiostats</h1></div></div></div><p>In this recipe, we'll learn how to use the <a id="id620" class="indexterm"/>
<a id="id621" class="indexterm"/>
<code class="literal">nagiostats</code> utility to get some statistics about the performance of a Nagios Core process, and the states of the hosts and services that it monitors.</p><p>Optionally, we'll also show how to use the <code class="literal">mrtg.cfg</code> file built in the Nagios Core source distribution at <code class="literal">./configure</code> time to set up graphs built by <a id="id622" class="indexterm"/>
<code class="literal">mrtg</code> (<span class="strong"><strong>Multi-Router Traffic Grapher</strong></span>), and link to the graphs in the menu of the web interface. The Nagios Core source distribution includes some files to assist with this, which we'll use here.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec355"/>Getting ready</h2></div></div></div><p>You will need a Nagios Core 3.0 or newer server installed and running to invoke <code class="literal">nagiostats</code>. Older versions do include the utility, but there is not quite as much information returned.</p><p>If you would like to run the <code class="literal">mrtg</code> graphing as well, which is highly recommended, you should have <code class="literal">mrtg</code> and its helper program, <code class="literal">indexmaker</code>, installed on your system. If you are already graphing other things with <code class="literal">mrtg</code>, don't worry, this recipe should not interfere with that.</p><p>The recipe does not assume any familiarity with <code class="literal">mrtg</code>, but if you have any problems with it, you may like to consult its documentation online at <a class="ulink" href="http://oss.oetiker.ch/mrtg/doc/index.en.html">http://oss.oetiker.ch/mrtg/doc/index.en.html</a>.</p><p>You should also have access to the sources from which your installation of Nagios Core was compiled. If you need to retrieve the sources again, you can download them from the Nagios Core website (<a class="ulink" href="http://www.nagios.org/">http://www.nagios.org/</a>).</p><p>In this case, you will need to run <code class="literal">./configure</code> again to generate the file required, <code class="literal">sample-config/mrtg.cfg</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec356"/>How to do it...</h2></div></div></div><p>We can invoke <code class="literal">nagiostats</code> itself in one step whenever we <a id="id623" class="indexterm"/>
<a id="id624" class="indexterm"/>want to get some statistics about the server's performance:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagiostats -c /usr/local/nagios/etc/nagios.cfg</strong></span>
</pre></div><p>This should give you output beginning with the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Nagios Stats 3.4.1</strong></span>
<span class="strong"><strong>Copyright (c) 2003-2008 Ethan Galstad (www.nagios.org)</strong></span>
<span class="strong"><strong>Last Modified: 05-11-2012</strong></span>
<span class="strong"><strong>License: GPL</strong></span>
<span class="strong"><strong>CURRENT STATUS DATA</strong></span>
<span class="strong"><strong>------------------------------------------------------</strong></span>
<span class="strong"><strong>Status File:                            /usr/local/nagios/var/status.dat</strong></span>
<span class="strong"><strong>Status File Age:                        0d 0h 0m 2s</strong></span>
<span class="strong"><strong>Status File Version:                    3.4.1</strong></span>
<span class="strong"><strong>Program Running Time:                   2d 2h 25m 23s</strong></span>
<span class="strong"><strong>Nagios PID:                             2487</strong></span>
<span class="strong"><strong>Used/High/Total Command Buffers:        0 / 0 / 4096</strong></span>
<span class="strong"><strong>Total Services:                         60</strong></span>
<span class="strong"><strong>Services Checked:                       60</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div></li><li class="listitem">Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagiostats -c /usr/local/nagios/etc/nagios.cfg --help</strong></span>
</pre></div><p>This should give you a complete list of the names and meanings of all the fields returned by the output of <code class="literal">nagiostats</code>.</p></li></ol></div><p>If you would like to include <code class="literal">mrtg</code> graphs of this data, a good starting point is using the sample configuration included in the Nagios Core source distribution, in <code class="literal">sample-config/mrtg.cfg</code>.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy <code class="literal">sample-config/mrtg.cfg</code> into <code class="literal">/usr/local/nagios/etc</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cp nagios-3.4.1/sample-config/mrtg.cfg /usr/local/nagios/etc</strong></span>
</pre></div></li><li class="listitem">Create a directory to store the <code class="literal">mrtg</code> pages and graphs, so that they can be viewed in the Nagios Core web interface:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mkdir /usr/local/nagios/share/stats</strong></span>
</pre></div></li><li class="listitem">Edit <code class="literal">/usr/local/nagios/etc/mrtg.cfg</code> to include a <code class="literal">WorkDir</code> declaration at the top of the file:<div class="informalexample"><pre class="programlisting">WorkDir: /usr/local/nagios/share/stats</pre></div></li><li class="listitem">Run <code class="literal">mrtg</code> to create the graphs:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mrtg /usr/local/nagios/etc/mrtg.cfg</strong></span>
</pre></div><p>For this first run, we can safely ignore any <a id="id625" class="indexterm"/>
<a id="id626" class="indexterm"/>errors about missing prior data, or backup log files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>2012-09-16 17:01:04, Rateup WARNING: /usr/bin/rateup could not read the primary log file for nagios-n</strong></span>
<span class="strong"><strong>2012-09-16 17:01:04, Rateup WARNING: /usr/bin/rateup The backup log file for nagios-n was invalid as well</strong></span>
<span class="strong"><strong>2012-09-16 17:01:04, Rateup WARNING: /usr/bin/rateup Can't remove nagios-n.old updating log file</strong></span>
<span class="strong"><strong>2012-09-16 17:01:04, Rateup WARNING: /usr/bin/rateup Can't rename nagios-n.log to nagios-n.old updating log file</strong></span>
</pre></div><p>If you are using a UTF-8 locale in your shell, <code class="literal">mrtg</code> may fail to run. You can run it in a standard C locale with an <code class="literal">env</code> prefix:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># env LANG=C mrtg /usr/local/nagios/etc/mrtg.cfg</strong></span>
</pre></div></li><li class="listitem">Run the <code class="literal">indexmaker</code> helper installed with <code class="literal">mrtg</code> to create an index to the graphs:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># indexmaker /usr/local/nagios/etc/mrtg.cfg --output=/usr/local/nagios/share/stats/index.html</strong></span>
</pre></div><p>You should only need to do this once, unless you add or remove graph definitions from <code class="literal">mrtg.cfg</code> later on.</p></li><li class="listitem">Visit <code class="literal">http://olympus.naginet/nagios/stats</code>, substituting your own Nagios Core server's hostname for <code class="literal">olympus.naginet</code>. After authenticating (if necessary), we should be able to see <a id="id627" class="indexterm"/><a id="id628" class="indexterm"/>some empty <code class="literal">mrtg</code> graphs:<div class="mediaobject"><img src="graphics/5566_10_05_full.jpg" alt="How to do it..."/></div><p>Don't worry that they're empty; we expect that, as we only have one data point for each graph at the moment.</p></li><li class="listitem">If everything has worked up to this point, we can probably add a <code class="literal">cron</code> task to run every five minutes to add new data points to the graph. Here, we are assuming the <code class="literal">mrtg</code> program is saved in <code class="literal">/usr/bin</code>:<div class="informalexample"><pre class="programlisting">*/5 * * * *  root  /usr/bin/mrtg /usr/local/nagios/etc/mrtg.cfg</pre></div><p>The best way to do this will vary between systems. You could put this in <code class="literal">/etc/crontab</code>, or in its own file in <code class="literal">/etc/cron.d/nagiostats</code> if you want to be a little tidier.</p><p>It is probably safe to leave it running as <code class="literal">root</code>, but if you are concerned about this, you should also be able to run it as the <code class="literal">nagios</code> user by including a <code class="literal">--lock-file</code> option:</p><div class="informalexample"><pre class="programlisting">*/5 * * * *  nagios  /usr/bin/mrtg --lock-file=/usr/local/nagios/var/mrtg.cfg.lock /usr/local/nagios/etc/mrtg.cfg</pre></div><p>That might require correcting permissions on the graphs already generated:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chown -R nagios.nagios /usr/local/nagios/share/stats</strong></span>
</pre></div></li></ol></div><p>With this done, if the <code class="literal">cron</code> task is installed correctly, we should start seeing data being plotted over the next few hours:</p><div class="mediaobject"><img src="graphics/5566_10_06_full.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec357"/>How it works...</h2></div></div></div><p>The statistics provided by <code class="literal">nagiostats</code> provide both <a id="id629" class="indexterm"/>
<a id="id630" class="indexterm"/>performance data about Nagios Core itself, how long it's taking to complete its round of checks of all objects and the average time it's taking per check, as well as data such as the number of hosts in various states. By default, running it will return the data in a terse but human-readable format; you can get a good idea of the meaning of each of the fields by running it with <code class="literal">--help</code> as suggested in the recipe.</p><p>The <code class="literal">mrtg.cfg</code> file included in the Nagios source distribution, which is tailored to your particular system at <code class="literal">./configure</code> time, contains example definitions of <code class="literal">mrtg</code> graphs that parse the data retrieved from <code class="literal">nagiostats</code>. These are not the only possible graphs using the information provided by <code class="literal">nagiostats</code>, but they are useful examples.</p><p>The data used is the same as the data you read if you invoked <code class="literal">nagiostats</code> from the shell, but the format is slightly different. If you want to see the data being passed to <code class="literal">mrtg</code> by <code class="literal">nagiostats</code>, you can run it with the <code class="literal">--mrtg</code> option<a id="id631" class="indexterm"/> and <a id="id632" class="indexterm"/>
<a id="id633" class="indexterm"/>nominate fields to be included in the output with <code class="literal">--data</code>; for example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagiostats -c /usr/local/nagios/etc/nagios.cfg --mrtg --data=AVGACTSVCPSC,AVGPSVSVCPSC,PROGRUNTIME,NAGIOSVERPID</strong></span>
<span class="strong"><strong>0</strong></span>
<span class="strong"><strong>0</strong></span>
<span class="strong"><strong>1d 2h 43m 43s</strong></span>
<span class="strong"><strong>Nagios 3.4.1 (pid=1080)</strong></span>
</pre></div><p>The recipe's call to <code class="literal">indexmaker</code> is a separate program that builds an <code class="literal">index.html</code> file with links to all the graphs, just for convenience. Like the <code class="literal">mrtg</code> call, it refers to the configuration file <code class="literal">/usr/local/nagios/etc/mrtg.cfg</code> to figure out what it needs to do.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec358"/>There's more...</h2></div></div></div><p>Once you're happy with the way your graph's web pages are being displayed, you might like to consider including them in your Nagios Core sidebar. This can be done by editing <code class="literal">/usr/local/nagios/share/side.php</code>, and adding a new link to the <span class="strong"><strong>System</strong></span> section, perhaps named <span class="strong"><strong>Performance Reports</strong></span>, below the <span class="strong"><strong>Performance Info</strong></span> link. The new line might look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">&lt;li&gt;&lt;a href="/nagios/stats/" target="&lt;?php echo $link_target;?&gt;"&gt;Performance Reports&lt;/a&gt;&lt;/li&gt;</pre></div><p>This would make a link to the graphs show up in the web interface as follows:</p><div class="mediaobject"><img src="graphics/5566_10_07.jpg" alt="There's more..."/></div><p>Note that customizations to the menu like this will be overwritten if you reinstall Nagios Core.</p><p>If you like what <code class="literal">mrtg</code> does with this data, you might like to look at <span class="strong"><strong>Cacti</strong></span>, a very helpful frontend to <code class="literal">rrdtool</code>, which is similar to <code class="literal">mrtg</code>. It will allow you a lot of flexibility in defining graphs, although it takes a while to learn (<a class="ulink" href="http://www.cacti.net/">http://www.cacti.net/</a>).</p><p>If you're interested in more graphing for Nagios Core performance and state data you may like the Nagiosgraph extension, which is discussed in the <span class="emphasis"><em>Tracking host and service states with NagiosGraph</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Automating and Extending Nagios Core">Chapter 11</a>,<span class="emphasis"><em> Automating and Extending Nagios</em></span>.</p><p>Finally, note that Nagios Core includes some built-in graphing of hosts and states in its reports, so be sure to check those out as well before you try to build a graph for a report that already exists! These are all also discussed in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>,<span class="emphasis"><em> Working With the Web Interface</em></span>. Check out the references in the <span class="emphasis"><em>See also</em></span> section for this recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec359"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using the tactical overview</em></span>, <span class="emphasis"><em>Viewing and interpreting availability reports</em></span>, <span class="emphasis"><em>Viewing and interpreting trends</em></span>, and <span class="emphasis"><em>Viewing and interpreting notification history</em></span> recipes in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>, <span class="emphasis"><em>Working With the Web Interface</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Tracking host and service states with Nagiosgraph</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Automating and Extending Nagios Core">Chapter 11</a>, <span class="emphasis"><em>Automating and Extending Nagios</em></span></li></ul></div></div></div>
<div class="section" title="Improving startup times with pre-cached object files"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Improving startup times with pre-cached object files</h1></div></div></div><p>In this recipe, we'll learn how to shorten startup times for large and/or complex Nagios Core configurations. This is done by pre-caching the Nagios <a id="id634" class="indexterm"/>
<a id="id635" class="indexterm"/>Core objects from the configuration, applying all appropriate template and group expansions into a single file that Nagios Core can read much more quickly than a more modular and human-readable configuration.</p><p>This will likely only be of interest to you if you are monitoring more than a hundred hosts or services with a reasonably complex template and grouping layout, as suggested by some of the recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a> and <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>. It will still work on smaller installations, but the gains in startup speed are likely to be minimal.</p><p>If you are only running a small setup, then this recipe might be of interest if you want to better understand how Nagios Core expands a configuration that uses a lot of templates and other configuration tricks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec360"/>Getting ready</h2></div></div></div><p>You should be running a Nagios Core 3.0 or newer server, and have access to the server to change its configuration.</p><p>You should check that the <code class="literal">precached_object_file</code> directive in <code class="literal">/usr/local/nagios/etc/nagios.cfg</code> is uncommented and defined to an accessible file. The setting in the Quick Start configuration is sensible:</p><div class="informalexample"><pre class="programlisting">precached_object_file=/usr/local/nagios/var/objects.precache</pre></div><p>Having this directive uncommented doesn't actually generate or use the pre-cached objects file; that needs to be done explicitly, as will be explained in the recipe.</p><p>Don't confuse this with the <code class="literal">object_cache_file</code> directive in the same file, which should be left untouched at its current setting.</p><p>For this example, we'll use a fairly large configuration with some 20,000 objects defined on a rather slow machine.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec361"/>How to do it...</h2></div></div></div><p>We can get some idea of possible performance improvement from using pre-cached object files as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run <code class="literal">nagios</code> with the <code class="literal">-s</code> option, and inspect the output. This will print a profile of the processes normally involved in building complete object definitions from the configuration files.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -s /usr/local/nagios/etc/nagios.cfg</strong></span>
</pre></div><p>In this case, we're particularly interested in the sections of output marked with asterisks, in the section titled <code class="literal">OBJECT CONFIG PROCESSING TIMES</code>, which denote times that <a id="id636" class="indexterm"/>could be improved by pre-cached object files, including an estimate of the saved time at the end of the <code class="literal">TOTAL</code> field:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>OBJECT CONFIG PROCESSING TIMES      (* = Potential for precache savings with -u option)</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>Read:                 8.285613 sec</strong></span>
<span class="strong"><strong>Resolve:              0.001696 sec  *</strong></span>
<span class="strong"><strong>Recomb Contactgroups: 0.000124 sec  *</strong></span>
<span class="strong"><strong>Recomb Hostgroups:    1.972412 sec  *</strong></span>
<span class="strong"><strong>Dup Services:         0.309333 sec  *</strong></span>
<span class="strong"><strong>Recomb Servicegroups: 0.000029 sec  *</strong></span>
<span class="strong"><strong>Duplicate:            0.000168 sec  *</strong></span>
<span class="strong"><strong>Inherit:              0.102685 sec  *</strong></span>
<span class="strong"><strong>Recomb Contacts:      0.000001 sec  *</strong></span>
<span class="strong"><strong>Sort:                 0.000000 sec  *</strong></span>
<span class="strong"><strong>Register:             0.826046 sec</strong></span>
<span class="strong"><strong>Free:                 0.102805 sec</strong></span>
<span class="strong"><strong>                      ============</strong></span>
<span class="strong"><strong>TOTAL:                11.600912 sec  * = 2.386448 sec (20.57%) estimated savings</strong></span>
</pre></div><p>We might decide that <code class="literal">2.3</code> seconds is a worthwhile saving from our restart time. Perhaps we really don't <a id="id637" class="indexterm"/>
<a id="id638" class="indexterm"/>want to miss any important checks!</p></li><li class="listitem">Run <code class="literal">nagios</code> with the <code class="literal">-p</code> and <code class="literal">-v</code> options, to verify the configuration and also write a pre-cached object file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -pv /usr/local/nagios/etc/nagios.cfg</strong></span>
</pre></div></li><li class="listitem">Run <code class="literal">nagios</code> with the <code class="literal">-u</code> and <code class="literal">-s</code> options to see how long the startup and scheduling test takes when instructed to use the pre-cached object file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -us /usr/local/nagios/etc/nagios.cfg</strong></span>
</pre></div></li><li class="listitem">We may note that the <code class="literal">TOTAL</code> time taken is now significantly less (even more of an improvement than estimated), and that many of the times are now zero seconds, as Nagios Core did not have to do that step at all:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>OBJECT CONFIG PROCESSING TIMES      (* = Potential for precache savings with -u option)</strong></span>
<span class="strong"><strong>----------------------------------</strong></span>
<span class="strong"><strong>Read:                 4.975257 sec</strong></span>
<span class="strong"><strong>Resolve:              0.000000 sec  *</strong></span>
<span class="strong"><strong>Recomb Contactgroups: 0.000000 sec  *</strong></span>
<span class="strong"><strong>Recomb Hostgroups:    0.000000 sec  *</strong></span>
<span class="strong"><strong>Dup Services:         0.000000 sec  *</strong></span>
<span class="strong"><strong>Recomb Servicegroups: 0.000000 sec  *</strong></span>
<span class="strong"><strong>Duplicate:            0.000000 sec  *</strong></span>
<span class="strong"><strong>Inherit:              0.000000 sec  *</strong></span>
<span class="strong"><strong>Recomb Contacts:      0.000000 sec  *</strong></span>
<span class="strong"><strong>Sort:                 0.000000 sec  *</strong></span>
<span class="strong"><strong>Register:             0.828953 sec</strong></span>
<span class="strong"><strong>Free:                 0.000758 sec</strong></span>
<span class="strong"><strong>                    ============</strong></span>
<span class="strong"><strong>TOTAL:                5.804968 sec</strong></span>
</pre></div></li></ol></div><p>With this done, we should find that restarting Nagios Core with both the <code class="literal">-d</code> and the <code class="literal">-u</code> flags should be faster than before. This can be incorporated into any startup scripts (for example, <code class="literal">/etc/init.d/nagios</code>). It also means that if we make <a id="id639" class="indexterm"/>
<a id="id640" class="indexterm"/>changes to the configuration, we must remember to run <code class="literal">nagios -pv</code> again to validate and regenerate the pre-cached object file.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec362"/>How it works...</h2></div></div></div><p>When run with the <code class="literal">-p</code> option, Nagios Core parses the configuration as normal into objects with which it can work, expanding out the <code class="literal">hostgroups</code>, <code class="literal">templates</code>, and other configuration shortcuts. It writes this information into a single file as specified by the <code class="literal">precached_object_file</code> <a id="id641" class="indexterm"/>directive.</p><p>The configuration file is human-readable; if you view it in a text editor, you'll see the expanded definitions that have been built from your configuration, with all of the object inheritance, regular expression hostgroups, and multi-host service definitions expanded.</p><p>When next restarted, Nagios Core can be instructed to use this file instead of re-parsing the configuration all over again by including the <code class="literal">-u</code> option. You may need to incorporate this in any <code class="literal">init.d</code> scripts you are using.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec363"/>There's more...</h2></div></div></div><p>If you don't really have speed problems on Nagios Core restarting, it's best to avoid making this permanent, as it adds another layer of complexity to building configuration; if you forget to rebuild the pre-cached object file after making configuration changes and before restarting Nagios Core, it will continue <a id="id642" class="indexterm"/>using the previous configuration, not realizing the difference. Use this with caution!</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec364"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Running a service on all hosts in a group</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Configuring host roles using groups</em></span> and the <span class="emphasis"><em>Using inheritance to simplify configuration</em></span> recipes in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <span class="emphasis"><em>Configuration Management</em></span></li></ul></div></div></div>
<div class="section" title="Setting up a redundant monitoring host"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Setting up a redundant monitoring host</h1></div></div></div><p>In this recipe, we'll learn how to implement a simple kind of redundancy for Nagios Core, by running a second Nagios Core instance with a near-identical <a id="id643" class="indexterm"/>configuration on another machine.</p><p>This may seem like it would not need a recipe to implement. It should be reasonably straightforward to simply copy over the configuration for a Nagios Core system and run it concurrently. There are two main problems with this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Every problem detected on the network will fire notifications events twice. The administrator charged with looking after the pager might well find this unbearable!</li><li class="listitem" style="list-style-type: disc">Everything will be checked twice. On smaller networks with simple checks, this may not be too much of a concern, but it could be an issue on larger, busier networks.</li></ul></div><p>This recipe will solve the first problem by configuring the slave monitoring server to suppress notifications until it detects an issue with the master server. In the <span class="emphasis"><em>There's more…</em></span> section, we'll discuss extending this solution to solve the second problem as well, by preventing the slave server from making checks as well as sending notifications while the master server is active.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec365"/>Getting ready</h2></div></div></div><p>This is the most complex recipe in this book, and one of the longest, tying in concepts from many other recipes and chapters. To follow it, you will likely need to have a good working knowledge of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The building blocks of Nagios Core ­hosts, services, contacts, commands, plugins, and notifications ­explained in all recipes in Chapters 1 through 4.</li><li class="listitem" style="list-style-type: disc">Remote execution via <code class="literal">check_nrpe</code> ­explained in all recipes in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span>. The recipe will at one point tell you to install NRPE on the master server to run a specific plugin, so you should learn how to do this first.</li><li class="listitem" style="list-style-type: disc">Event handlers and writing to the command file with them, ­explained in the <span class="emphasis"><em>Setting up an event handler script</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Automating and Extending Nagios Core">Chapter 11</a>.</li></ul></div><p>The event handler scripts, the most complex part of this setup, are fortunately already written for us; we'll show how to implement them by copying them out of the Nagios Core source package. You'll therefore need to have the sources available for your particular version of Nagios Core. If you need to retrieve the sources again, you can download them again from Nagios Core's website at <a class="ulink" href="http://www.nagios.org/">http://www.nagios.org/</a>.</p><p>The recipe will start by assuming we have two monitoring servers: <code class="literal">olympus.naginet</code> (<code class="literal">10.128.0.11</code>), which will be the master monitoring server, and <code class="literal">everest.naginet</code> (<code class="literal">10.128.0.12</code>), which will be the slave. The two servers <a id="id644" class="indexterm"/>are configured to monitor the same three hosts, with PING service checks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">sparta.naginet</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">athens.naginet</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ithaca.naginet</code></li></ul></div><p>The Nagios Core configuration of the two servers is completely identical to start with, and both are sending notifications to an appropriate contact group. However, note that the servers are not yet monitoring one another; this will be an important part of the recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec366"/>How to do it...</h2></div></div></div><p>We can arrange a simple redundancy setup for our two <a id="id645" class="indexterm"/>
<a id="id646" class="indexterm"/>Nagios Core servers as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Confirm that the <code class="literal">check_nagios</code> plugin is available on the <code class="literal">master</code> server, and try running it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
<span class="strong"><strong># ./check_nagios -e 5 -F /usr/local/nagios/var/status.dat -C /usr/local/nagios/bin/nagios</strong></span>
<span class="strong"><strong>NAGIOS OK: 1 process, status log updated 3 seconds ago</strong></span>
</pre></div></li><li class="listitem">Install the NRPE daemon on the master server, and define a command <code class="literal">check_nagios</code> in <code class="literal">nrpe.cfg</code> (see <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>).<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>command[check_nagios]=/usr/local/nagios/libexec/check_nagios -e 5 -F /usr/local/nagios/var/status.dat -C /usr/local/nagios/bin/nagios</strong></span>
</pre></div></li><li class="listitem">Include the slave server's address in the <code class="literal">allowed_hosts</code> directive for <code class="literal">nrpe</code>, in the file <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>:<div class="informalexample"><pre class="programlisting">allowed_hosts=127.0.0.1,10.128.0.12</pre></div><p>Don't forget to restart NRPE to include this change to the configuration.</p></li><li class="listitem">On the slave server, verify that a call to <code class="literal">check_nrpe</code> can retrieve the results of <code class="literal">check_nagios</code> on the master server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
<span class="strong"><strong># ./check_nrpe -H olympus.naginet</strong></span>
<span class="strong"><strong>NRPE v2.13</strong></span>
<span class="strong"><strong># ./check_nrpe -H olympus.naginet -c check_nagios</strong></span>
<span class="strong"><strong>NAGIOS OK: 1 process, status log updated 2 seconds ago</strong></span>
</pre></div><p>You will have to install the <code class="literal">check_nrpe</code> plugin on the slave server to do this. This is explained in the <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>.</p></li><li class="listitem">On the slave server, copy four files (two event <a id="id647" class="indexterm"/><a id="id648" class="indexterm"/>handlers and two helper scripts) from the source distribution into the <code class="literal">/usr/local/nagios/libexec/eventhandlers</code> directory (which you may need to create first):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># EHD=/usr/local/nagios/libexec/eventhandlers</strong></span>
<span class="strong"><strong># mkdir -p $EHD</strong></span>
<span class="strong"><strong># cd /usr/local/src/nagios</strong></span>
<span class="strong"><strong># cp contrib/eventhandlers/enable_notifications $EHD</strong></span>
<span class="strong"><strong># cp contrib/eventhandlers/disable_notifications $EHD</strong></span>
<span class="strong"><strong># cp contrib/eventhandlers/redundancy-scenario1/handle-master-host-event $EHD</strong></span>
<span class="strong"><strong># cp contrib/eventhandlers/redundancy-scenario1/handle-master-proc-event $EHD</strong></span>
</pre></div><p>The preceding command assumes you are keeping the sources for your Nagios Core distribution in <code class="literal">/usr/local/src</code>. We define and use the shell variable <code class="literal">$EHD</code> to refer to the event handlers directory for convenience.</p></li><li class="listitem">In the installed <code class="literal">handle-master-proc-event</code> script, find and replace <code class="literal">active_service_checks</code> with <code class="literal">notifications</code>. The command line tool <code class="literal">sed</code> works well for this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sed -i 's/active_service_checks/notifications/g' $EHD/handle-master-proc-event</strong></span>
</pre></div><p>This is because the script as provided issues a command to toggle active checks, rather than notifications. At the time of writing, in Nagios 3.3.1 there is also a bug in <code class="literal">handle-master-proc-event</code> that may need to be corrected, on line 49:</p><div class="informalexample"><pre class="programlisting">`eventhandlerdir/disable_active_service_checks`</pre></div><p>It should have a dollar sign added after the first backtick:</p><div class="informalexample"><pre class="programlisting">`$eventhandlerdir/disable_active_service_checks`</pre></div></li><li class="listitem">Ensure the event handlers are owned and <a id="id649" class="indexterm"/><a id="id650" class="indexterm"/>executable by the <code class="literal">nagios</code> user:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chown nagios.nagios $EHD/*</strong></span>
<span class="strong"><strong># chmod 0755 $EHD/*</strong></span>
</pre></div></li><li class="listitem">In <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code>, define two new event handler commands:<div class="informalexample"><pre class="programlisting">define command {
    command_name  handle-master-host-event
    command_line  $USER1$/eventhandlers/handle-master-host-event $HOSTSTATE$ $HOSTSTATETYPE$ $HOSTATTEMPT$
}
define command {
    command_name  handle-master-proc-event
    command_line  $USER1$/eventhandlers/handle-master-proc-event $SERVICESTATE$ $SERVICESTATETYPE$ $SERVICEATTEMPT$
}</pre></div></li><li class="listitem">Make a host and service definition on the slave server to monitor the master server. It might look something similar to the following code snippet; change your <code class="literal">host_name</code>, <code class="literal">alias</code>, and <code class="literal">address</code> values as appropriate. The templates used are only examples; you will probably want to choose templates that are defined to run checks often, and during a 24x7 interval.<div class="informalexample"><pre class="programlisting">define host {
    use            critical-host-template
    host_name      olympus.naginet
    alias          olympus
    address        10.128.0.11
    event_handler  handle-master-host-event
}
    define service {
        use                  critical-service-template
        host_name            olympus.naginet
        service_description  NAGIOS
        check_command        check_nrpe!check_nagios
        event_handler        handle-master-proc-event
    }</pre></div><p>You can make the master server <a id="id651" class="indexterm"/>
<a id="id652" class="indexterm"/>monitor the slave server as well if you wish.</p></li><li class="listitem">Note that you will need to have the <code class="literal">check_nrpe</code> command defined, which the <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a> explains. If you have followed that recipe then you have probably already done this. If not, the following definition works:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_nrpe
    command_line  $USER1$/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
}</pre></div></li><li class="listitem">Finally, in <code class="literal">nagios.cfg</code> on the slave server, change <code class="literal">enable_notifications</code> to <code class="literal">0</code>:<div class="informalexample"><pre class="programlisting">enable_notifications=0</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, the two Nagios Core servers should both be running, but importantly, notifications on the slave server start out as disabled, as visible in the <span class="strong"><strong>Tactical Overview</strong></span>:</p><div class="mediaobject"><img src="graphics/5566_10_10.jpg" alt="How to do it..."/></div><p>However, all the systems are still being monitored, as <a id="id653" class="indexterm"/>
<a id="id654" class="indexterm"/>visible in the <span class="strong"><strong>Services</strong></span> screen, including the <span class="strong"><strong>NAGIOS</strong></span> service on the host machine:</p><div class="mediaobject"><img src="graphics/5566_10_11.jpg" alt="How to do it..."/></div><p>This means that notifications will only be sent by the master server, since it still has its notifications enabled. However, if the master server goes down or its Nagios process stops working, the event handlers should be called, and notifications on the slave server will be automatically enabled. When the master server or its <code class="literal">NAGIOS</code> service comes back up, the notifications will be disabled again, with checks and state changes having continued uninterrupted throughout. We have therefore established a simple kind of redundancy. If you use this setup, you should test it thoroughly to make sure that the slave Nagios Core server will enable and disable its notifications for each contingency (host goes down, service goes down, service comes back, and so on.)</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec367"/>How it works...</h2></div></div></div><p>The event handlers included in the Nagios Core distribution, which we copied into the <code class="literal">eventhandlers</code> directory, are designed to <a id="id655" class="indexterm"/>handle toggling notifications and active checks based on the status of a given service or host. They are included for the purposes of demonstrating event handlers and redundancy situations like this one.</p><p>We start by setting up the slave server to monitor not just the host on which the master Nagios Core server is running, but also the Nagios Core service itself, using the <code class="literal">check_nagios</code> plugin. This <a id="id656" class="indexterm"/>plugin checks the age of the log file and the system's process tables to ensure that a Nagios Core service is actually running on the system. Because it's a local plugin that doesn't work for remote checks, we check it from the slave server via NRPE.</p><p>The slave server checks the status of the master server and its <code class="literal">NAGIOS</code> service as part of its normal routine of active checks. When the master <a id="id657" class="indexterm"/>
<a id="id658" class="indexterm"/>server's host or its <code class="literal">NAGIOS</code> service change state, both call their respective event handlers, the two shell scripts <code class="literal">handle-master-host-event</code> and <code class="literal">handle-master-proc-event</code>, defined in the commands of the same name.</p><p>Each time the event handlers are called, they are passed three arguments, in macro form. For <code class="literal">handle-master-host-event</code>, these are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTSTATE$</code>: This is the new state of the master server</li><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTSTATETYPE$</code>: This specifies whether the state is <code class="literal">SOFT</code> or <code class="literal">HARD</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTATTEMPT$</code>: This is the number of host checks attempted, up to the value of <code class="literal">max_check_attempts</code> for the host</li></ul></div><p>
<code class="literal">handle-master-proc-event</code> is passed three analogous arguments, the only difference being they refer to service states rather than host states:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$SERVICESTATE$</code>: This is the new state of the <a id="id659" class="indexterm"/><code class="literal">NAGIOS</code> service on the master server</li><li class="listitem" style="list-style-type: disc"><code class="literal">$SERVICESTATETYPE$</code>: This specifies <a id="id660" class="indexterm"/>whether the service state is <code class="literal">SOFT</code> or <code class="literal">HARD</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$SERVICEATTEMPT$</code>: This is the number of host <a id="id661" class="indexterm"/>checks attempted, up to the value of <code class="literal">max_check_attempts</code> for the host</li></ul></div><p>The event handlers are written in such a way that they only do anything if the new state is <code class="literal">HARD</code>; that is, if the number of<code class="literal"> max_check_attempts</code> has been reached. It ignores <code class="literal">SOFT</code> state changes until enough consecutive checks have failed that it can be reasonably confident in concluding that the monitored host or service is suffering a problem.</p><p>If the host or service enters a <code class="literal">HARD CRITICAL</code> state<a id="id662" class="indexterm"/>, the event handlers call the helper script <code class="literal">enable-notifications</code> to write a command to the <code class="literal">commands</code> file at <code class="literal">/usr/local/nagios/var/rw/nagios.cmd</code> for the server to process. This command takes the following form, including the UNIX timestamp for when the command was written:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[1348129155] ENABLE_NOTIFICATIONS;1348129155</strong></span>
</pre></div><p>When Nagios Core processes this command, the effect is that the previously disabled notifications are enabled, and all subsequent notifications generated as a result of checks will be sent.</p><p>Similarly, when the host or service recovers from the <code class="literal">HARD CRITICAL</code> state, entering a <code class="literal">HARD UP</code> or <code class="literal">HARD OK</code> state, the <code class="literal">disable-notifications</code> helper script is called, writing a command in the same manner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[1348129231] DISABLE_NOTIFICATIONS;1348129231</strong></span>
</pre></div><p>The effect is that when the master server is noted to be <a id="id663" class="indexterm"/>
<a id="id664" class="indexterm"/>down, the slave server notices and assumes its notification behavior, and when it recovers, it stops its own notifications again, allowing the master server to resume its role.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec368"/>There's more...</h2></div></div></div><p>If network bandwidth is a concern, we can arrange to leave the slave server more or less idle when not in use, by keeping not only notifications but also service checks off by default. Helper scripts for this are also included in the Nagios Core distribution, in the <code class="literal">disable_active_service_checks</code> and <code class="literal">enable_active_service_checks</code> scripts.</p><p>The primary issue with this change is the loss of state information as the slave server makes its initial round of checks; this can also be worked around, as explained in the Nagios Core documentation on redundancy at <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/redundancy.html">http://nagios.sourceforge.net/docs/3_0/redundancy.html</a>.</p><p>Once these steps are implemented, the main annoyance with this setup is having to keep the two configuration directories in sync. It's undesirable and error-prone to have to make changes on two servers each time the configuration needs to change, so you may like to consider using a snapshot tool such as <code class="literal">rsync</code> to keep the two directories the same. More information about <code class="literal">rsync</code> can be found at <a class="ulink" href="http://en.wikipedia.org/wiki/Rsync">http://en.wikipedia.org/wiki/Rsync</a>.</p><p>A configuration managed with version control is also help here, as recommended in the <span class="emphasis"><em>Keeping configuration under version control</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>. That way you can use <code class="literal">git clone</code> or <code class="literal">svn checkout</code> to quickly copy and update configuration files on multiple machines.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec369"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Writing debugging information to Nagios log file</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Keeping configuration under version control</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <span class="emphasis"><em>Configuration Management</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Setting up an event handler script</em></span> recipe in <a class="link" href="ch11.html" title="Chapter 11. Automating and Extending Nagios Core">Chapter 11</a>, <span class="emphasis"><em>Automating and Extending Nagios</em></span></li></ul></div></div></div></body></html>