<html><head></head><body><div class="appendix" title="Appendix&#xA0;D.&#xA0;Troubleshooting the Common Pitfalls"><div class="titlepage"><div><div><h1 class="title"><a id="appD"/>Appendix D. Troubleshooting the Common Pitfalls</h1></div></div></div><p>When experimenting with new things, a lot can go wrong. In this appendix, a few of these common pitfalls are covered briefly. Anticipating everything that can go wrong is plainly impossible, but an overview of the most common problems is what this appendix is for.</p><p>Some general things that do tend to happen more often than one can imagine is the reading and entering of commands. A typo is easily made, or something is easily overlooked and read wrong. These things naturally happen and are all part of working with something exciting and new. So the first general tip is to always double-check your input. Despite the many eyes that went over all the pages in this book, there is always the possibility that a mistake has crawled into this book, so if something still goes wrong, even when following the book to the letter, check the errata.</p><div class="section" title="Stability issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec102"/>Stability issues</h1></div></div></div><p>Quite often, users <a id="id490" class="indexterm"/>find the many communities surrounding these devices<a id="id491" class="indexterm"/> and complain about strange crashes, unstable systems or random reboots. While it is, of course, always possible that the actual device might be damaged, very often a flaky power supply is to blame, which either provides unstable power or is not powerful enough.</p><p>Testing the <a id="id492" class="indexterm"/>strength or stability of a power supply is very difficult without additional equipment. What tends to happen if the power supply cannot deliver enough current is that the voltage starts to drop. This can be measured with a standard multimeter.</p><p>If the voltage drops <a id="id493" class="indexterm"/>below 4.8 volt, things are likely to go wrong. A very noisy power supply is even harder to test and requires an oscilloscope. It is probably best to get a well-known and good power supply. Phone chargers, for example, come in different strengths. There are cheap phone power supplies that barely deliver 500 milliampere, which, when the device is heavily stressed, is not enough. Obviously, there are also decent chargers that come with high-end smartphones that can easily supply 2000 milliampere, but even here, in combination with the hard disk or solid-state disk, the power requirement can be too high. It is thus advised to disconnect as many devices as possible. No USB device and no SATA storage as they get their power from the board. No other components that might receive power directly from the board. Ideally, only a power connection and a serial connection should be made, and a multimeter or another power measuring device should be used to see that the voltage does not drop too low.</p><p>Should the board still remain unstable even after all that, where other people with the same board using the same bootloader and ideally the same root filesystem have no problem, then the board might be defective. It is probably best to ask for an exchange where the board was purchased. But please, always try to verify everything else, as a board exchange is no fun for all the parties involved.</p></div></div>
<div class="section" title="Boot failures when booting from SD cards"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec103"/>Boot failures when booting from SD cards</h1></div></div></div><p>There is nothing <a id="id494" class="indexterm"/>more frustrating than spending hours on compiling and preparing an SD card to boot the board with, only to have it not work. While it is critical to <a id="id495" class="indexterm"/>have a serial console to see a debugging output during this stage, sometimes no output is generated at all due to an incorrect SD card or binary. The most important thing when experimenting with the bootloader is to always have a known working copy at hand. This is to make sure that modifications to u-boot are not the cause.</p><p>The nightlies from linux-sunxi are an alternative, as those should always work. See <a class="ulink" href="http://dl.linux-sunxi.org/nightly/u-boot-sunxi/u-boot-sunxi/u-boot-sunxi-latest/">http://dl.linux-sunxi.org/nightly/u-boot-sunxi/u-boot-sunxi/u-boot-sunxi-latest/</a> for a list of available bootloaders.</p><p>Sometimes, the microSD card might simply not be compatible or might even be broken. A different microSD card should be used to make sure the microSD card is not the cause. It is not unheard of that the first few bytes on the card are broken beyond repair. This is not generally a problem if the card is used as a simple storage medium. Because the bootloader gets written and read from the start of the SD card, this can thus result in a system that is unable to boot.</p><p>Now, going with either one of the nightlies or a self-compiled bootloader, quite often, users tend to choose the wrong file. This is not a big surprise, as there are many files and various instructions <a id="id496" class="indexterm"/>on the Internet that, sometimes, become outdated and are no longer accurate. A common example is that many older guides suggest writing <code class="literal">u-boot.bin</code> or <code class="literal">sunxi-spl.bin</code> using various <code class="literal">seek</code> offsets. Using the correct files and parameters, this can still work, whereas using the wrong parameters or wrong settings will cause failure. The recommended way, as described in <a class="link" href="ch04.html" title="Chapter 4. Manually Installing an Alternative Operating System">Chapter 4</a>, <span class="emphasis"><em>Manually Installing an Alternative Operating System</em></span>, onto the board is to use <code class="literal">u-boot-sunxi-with-spl.bin</code> using a <code class="literal">blocksize (bs)</code> of <code class="literal">1024</code> and <code class="literal">seek</code> of <code class="literal">8</code>. Applying this to, for example, <code class="literal">sdb</code>, the following command should be used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@packt:~# dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</strong></span>
</pre></div><p>This is because <a id="id497" class="indexterm"/>both the previous mentioned files are combined in one big file, so fewer things can go wrong. Finally, after writing the bootloader, the intention is to format the first partition to store the kernel. The partition number gets omitted and not <code class="literal">/dev/sdb1</code>, but <code class="literal">/dev/sdb</code> gets formatted. This is completely legal to do; having partitions on a storage medium is optional, though often useful. Formatting the entire disk, rather than the partition, however, has a side effect that the earlier written bootloader is now overwritten and gone. When the board boots, the bootloader is no more to be found and hence no output is generated.</p></div>
<div class="section" title="No display output via a connected monitor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec104"/>No display output via a connected monitor</h1></div></div></div><p>Quite often, when <a id="id498" class="indexterm"/>a monitor is connected via HDMI or VGA, there is no display output. This can be, understandably, very frustrating. Even more so, it probably worked fine with the preinstalled Android was working fine, but now when booting Linux from the SD card, nothing happens anymore. There are of course many possible reasons for not getting an image on the monitor, such as the cable might not be connected properly, the monitor might be set to the wrong input, and so on. Even though all these things seem very obvious and common, they do happen, and there are a few cases that are not so easily checked.</p><p>The Allwinner SoC is actually not very smart when it comes to displaying outputs. It needs to be told what is connected and what to use as an output. For this purpose, monitors and TVs, which really are just fancy monitors, have a communication channel in the cable called <span class="strong"><strong>Display Data Channel</strong></span> (<span class="strong"><strong>DDC</strong></span>). The <a id="id499" class="indexterm"/>purpose of the DDC is for the monitor to tell whoever asks what its capabilities and resolutions are. And this is where things get ugly.</p><p>For VGA, it was once agreed upon that there were two colors for the plugs: black if the port does not care about <a id="id500" class="indexterm"/>DDC and ignores it, and blue if it does read the DDC information and can respond accordingly. Unfortunately, many creators of development boards simply use a blue<a id="id501" class="indexterm"/> connector, thinking that is the standard VGA connector, but do not implement DDC. Without DDC, the board has no idea what is connected and how to send signals to it. And because of the ignorant usage of blue and black VGA plugs, there is no simple rule to follow anymore, which says that if your connector is black, you have to set up your VGA port manually.</p><p>For HDMI, the problem is very similar. The Allwinner HDMI display controller was created with television in mind for the most part. Thus, there are some quirks when connecting it to an HDMI monitor or when using a DVI to HDMI adapter. Android might, for example, have a purple hue over the image when being connected to a DVI monitor, which is a quirk caused by the driver in combination with the design of the display controller; running a linux-sunxi kernel usually fixes this.</p><p>The first thing that can be checked and changed is the <code class="literal">uEnv.txt</code> file that resides on the bootloader partition, possibly <code class="literal">/dev/sdb1</code>, when we use a microSD card in a USB adapter. Here, there should be a setting called <code class="literal">disp.screen0_output_mode=EDID:1280x720p60</code> or something similar for the bottom <code class="literal">extraargs</code> parameter.</p><p>This means that for the output, first try to probe the monitor via EDID, which is an extended form of DDC, and if that fails, fall back to the 1280 by 720 progressive resolution running at a refresh rate of 60 Hz. Some monitors might not properly announce their EDID information, so the first thing to try is removing the EDID bit from <code class="literal">output_mode</code> and thus forcing the output to <code class="literal">1280x720p60</code>. Additionally, it is possible that after EDID fails, the fixed resolution supplied is simply something the monitor does not accept. For valid resolutions and settings, check the second column in the table used in the following section. It should be noted that when we use a VGA monitor, EDID must be removed, as the driver will ignore the entire <code class="literal">output_mode</code> in that case. Additionally, the desired video output type needs to be appended to <code class="literal">extraargs</code> as <code class="literal">disp.screen0_output_type=4</code> for VGA or <code class="literal">3</code> for HDMI.</p><p>Overriding the kernel parameters via the <code class="literal">uEnv.txt</code> file might not be enough and cause things to not work. The same settings can and should also be supplied via the FEX file. The driver should, in theory, check both the kernel command line and the FEX file, but one might overrule the other, and thus, in case of trouble, both possibilities should be covered.</p><p>To force a video output mode, the FEX file needs to modified. The section that controls the display controller in the FEX file is the <code class="literal">[disp_init]</code> section. All the parameters for the display controller on the <a id="id502" class="indexterm"/>linux-sunxi wiki, <a class="ulink" href="http://linux-sunxi.org/Fex_Guide">http://linux-sunxi.org/Fex_Guide</a>, there are a few things that need to be looked at. When getting things going for the first time, <code class="literal">disp_mode</code> is probably best set to <code class="literal">0</code> , indicating one frame buffer on <code class="literal">screen0</code>. Depending how the monitor is connected, <code class="literal">screen0_output_type</code> should <a id="id503" class="indexterm"/>be set to either <code class="literal">3</code> or <code class="literal">4</code>, where <code class="literal">3</code> is an HDMI display and <code class="literal">4</code> is a VGA display. The <code class="literal">screen1_output_type</code> object is best disabled by setting it to <code class="literal">0</code>. For <code class="literal">screen0_output_mode</code>, the following table should be used, and any setting applied to <code class="literal">screen1_output_mode</code> will be ignored:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>
<code class="literal">output_mode</code>
</p>
</th><th style="text-align: left" valign="bottom">
<p>Used for the TV/HDMI output</p>
</th><th style="text-align: left" valign="bottom">
<p>Used for the VGA output</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>480i</p>
</td><td style="text-align: left" valign="top">
<p>1680 * 1050</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>576i</p>
</td><td style="text-align: left" valign="top">
<p>1440 * 900</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>480p</p>
</td><td style="text-align: left" valign="top">
<p>1360 * 768</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>576p</p>
</td><td style="text-align: left" valign="top">
<p>1280 * 1024</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>720p50</p>
</td><td style="text-align: left" valign="top">
<p>1024 * 768</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>720p60</p>
</td><td style="text-align: left" valign="top">
<p>800 * 600</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top">
<p>1080i50</p>
</td><td style="text-align: left" valign="top">
<p>640 * 480</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>7</p>
</td><td style="text-align: left" valign="top">
<p>1080i60</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>8</p>
</td><td style="text-align: left" valign="top">
<p>1080p24</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>9</p>
</td><td style="text-align: left" valign="top">
<p>1080p50</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>10</p>
</td><td style="text-align: left" valign="top">
<p>1080p60</p>
</td><td style="text-align: left" valign="top">
<p>1920 * 1080</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>11</p>
</td><td style="text-align: left" valign="top">
<p>pal</p>
</td><td style="text-align: left" valign="top">
<p>1280 * 720</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>14</p>
</td><td style="text-align: left" valign="top">
<p>ntsc</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>The other settings should not be significant for the display output. The display should be able to output data now when booting, for example, the Fedora installation image, as was used in <a class="link" href="ch03.html" title="Chapter 3. Installing an Operating System">Chapter 3</a>, <span class="emphasis"><em>Installing an Operating System</em></span>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec105"/>Summary</h1></div></div></div><p>This appendix went over the three most common issues, which most often happen when starting to work with the various development boards. The things covered in this appendix by no means cover every possibly scenario but should give you a decent strategy on tackling these early problems.</p></div></body></html>