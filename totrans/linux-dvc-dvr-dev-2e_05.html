<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-60"><em class="italic"><a id="_idTextAnchor060"/>Chapter 4</em>: Writing Character Device Drivers</h1>
			<p>Unix-based systems expose hardware to user space by means of special files, all created in the <strong class="source-inline">/dev</strong> directory upon device registration with the system. Programs willing to access a given device must locate its corresponding device file in <strong class="source-inline">/dev</strong> and perform the appropriate system call on it, which will be redirected to the driver of the underlying device associated with that special file. Though system calls redirection is done by an operating system, what system calls are supported depends on the type of device and the driver implementation.</p>
			<p>On the topic of types of devices, there are many of them from a hardware point of view, which are, however, grouped into two families of special device files in <strong class="source-inline">/dev</strong> – these are <strong class="bold">block devices</strong> and <strong class="bold">character devices</strong>. They are differentiated by the way they are <a id="_idIndexMarker317"/>accessed, their speed, and the way data is transferred between them and the system. Typically, character devices are slow and transfer data to or from user applications sequentially <a id="_idIndexMarker318"/>byte by byte (one character after another – hence their name). Such devices include serial ports and input devices (keyboards, mouses, touchpads, video devices, and so on). On the other hand, block devices are fast, since they are accessed quite frequently and transfer data in blocks. Such devices are essentially storage devices (hard drives, CD-ROMs, solid-state drives, and so on). </p>
			<p>In this chapter, we will focus on character devices and their drivers, their APIs, and their common data structures. We will introduce most of their concepts and write our first character device driver. </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>The concept of major and minor</li>
				<li>Character device data structure introduction </li>
				<li>Creating a device node</li>
				<li>Implementing file operations</li>
			</ul>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>The concept of major and minor</h1>
			<p>Linux has always enforced device file identification by a unique identifier, composed of two parts, a <strong class="bold">major</strong> and<a id="_idIndexMarker319"/> a <strong class="bold">minor</strong>. While <a id="_idIndexMarker320"/>other file types (links, directories, and sockets) may exist in <strong class="source-inline">/dev</strong>, character or block device files are recognizable by their types, which can be seen using the <strong class="source-inline">ls -l</strong> command:</p>
			<p class="source-code">$ ls -la /dev</p>
			<p class="source-code">crw-------  1 root root    254,     0 août  22 20:28 gpiochip0</p>
			<p class="source-code">crw-------  1 root root    240,     0 août  22 20:28 hidraw0</p>
			<p class="source-code">[...]</p>
			<p class="source-code">brw-rw----  1 root disk    259,     0 août  22 20:28 nvme0n1</p>
			<p class="source-code">brw-rw----  1 root disk    259,     1 août  22 20:28 nvme0n1p1</p>
			<p class="source-code">brw-rw----  1 root disk    259,     2 août  22 20:28 nvme0n1p2</p>
			<p class="source-code">[...]</p>
			<p class="source-code">crw-rw----+ 1 root video    81,     0 août  22 20:28 video0</p>
			<p class="source-code">crw-rw----+ 1 root video    81,     1 août  22 20:28 video1</p>
			<p>From the preceding excerpt, in the first column, <strong class="source-inline">c</strong> identifies character device files and <strong class="source-inline">b</strong> identifies block device files. In the fifth and sixth columns, we can see, respectively, major and minor numbers. The major number either identifies the type of device or can be bound to a driver. The minor number either identifies a device locally to the driver or devices of the same type. This explains the fact that some device files have the same major number in the preceding output.</p>
			<p>Now that we are done with the basic concepts of character devices in a Linux system, we can start exploring the kernel code, starting from introducing the main data structures. </p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Character device data structure introduction</h1>
			<p>A character device driver<a id="_idIndexMarker321"/> represents the most basic device driver in the kernel sources. Character devices are represented in the kernel as instances of <strong class="source-inline">struct cdev</strong>, declared in <strong class="source-inline">include/linux/cdev.h</strong>:</p>
			<p class="source-code">struct cdev {</p>
			<p class="source-code">    struct kobject kobj;</p>
			<p class="source-code">    struct module *owner;</p>
			<p class="source-code">    const struct file_operations *ops;</p>
			<p class="source-code">    dev_t dev;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>The preceding excerpt has listed elements of our interest only. The following shows the meaning of these elements in this data structure:</p>
			<ul>
				<li><strong class="source-inline">kobj</strong>: This is the underlying kernel object for this character device object, used to enforce the Linux device model. We will discuss this in <a href="B17934_14_Epub.xhtml#_idTextAnchor203"><em class="italic">Chapter 14</em></a>, <em class="italic">Introduction to the Linux Device Model</em>.</li>
				<li><strong class="source-inline">owner</strong>: This should be set with the <strong class="source-inline">THIS_MODULE</strong> macro.</li>
				<li><strong class="source-inline">ops</strong>: This is the set of file operations associated with this character device.</li>
				<li><strong class="source-inline">dev</strong>: This is the character device identifier.</li>
			</ul>
			<p>With this data structure introduced, the next logical one for discussion is the one exposing file operations that system calls will rely on. Let's then introduce the data structure that allows interaction between user space and kernel space through the character de<a id="_idTextAnchor063"/>vice.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/>An introduction to device file operations</h2>
			<p>The <strong class="source-inline">cdev-&gt;ops</strong> element<a id="_idIndexMarker322"/> points to the file operations supported by a given device. Each of these operations is the target of a particular system call, in a manner that, when the system call is invoked by a program in user space on the character device, this system call is redirected in the kernel to its file operation counterpart in <strong class="source-inline">cdev-&gt;ops</strong>. <strong class="source-inline">struct file_operations</strong> is the data structure that holds these operations. It looks like the following:</p>
			<p class="source-code">struct file_operations {</p>
			<p class="source-code">   struct module *owner;</p>
			<p class="source-code">   loff_t (*llseek) (struct file *, loff_t, int);</p>
			<p class="source-code">   ssize_t (*read) (struct file *, char __user *,</p>
			<p class="source-code">                     size_t, loff_t *);</p>
			<p class="source-code">   ssize_t (*write) (struct file *, const char __user *,</p>
			<p class="source-code">                     size_t, loff_t *);</p>
			<p class="source-code">   unsigned int (*poll) (struct file *,</p>
			<p class="source-code">                         struct poll_table_struct *);</p>
			<p class="source-code">   int (*mmap) (struct file *, struct vm_area_struct *);</p>
			<p class="source-code">   int (*open) (struct inode *, struct file *);</p>
			<p class="source-code">   int (*flush) (struct file *, fl_owner_t id);</p>
			<p class="source-code">   long (*unlocked_ioctl) (struct file *, unsigned int,</p>
			<p class="source-code">                           unsigned long);</p>
			<p class="source-code">   int (*release) (struct inode *, struct file *);</p>
			<p class="source-code">   int (*fsync) (struct file *, loff_t, loff_t,</p>
			<p class="source-code">                 int datasync);</p>
			<p class="source-code">   int (*flock) (struct file *, int, struct file_lock *);</p>
			<p class="source-code">   [...]</p>
			<p class="source-code">};</p>
			<p>The preceding excerpt <a id="_idIndexMarker323"/>lists only the important methods of the structure, especially the ones that are relevant to the needs of this book. The full code is in <strong class="source-inline">include/linux/fs.h</strong> in kernel sources. Each of these callbacks is the backend of a system call, and none of them are mandatory. The following explains the meanings of<a id="_idIndexMarker324"/> elements in the structure: </p>
			<ul>
				<li><strong class="source-inline">struct module *owner</strong>: This is a mandatory field that should point to the module owning this structure. It is used for proper reference counting. Most of the time, it is set to <strong class="source-inline">THIS_MODULE</strong>, a macro defined in <strong class="source-inline">&lt;linux/module.h&gt;</strong>.</li>
				<li><strong class="source-inline">loff_t (*llseek) (struct file *, loff_t, int);</strong>: This method is used to move the current cursor position in the file given as the first parameter. On a successful move, the function must return the new position, or else a negative value must be returned. If this method is not implemented, then every seek performed on this file will succeed by modifying the position counter in the <strong class="source-inline">file</strong> structure (<strong class="source-inline">file-&gt;f_pos</strong>), except the seek relative to end-of-file, which will fail. </li>
				<li><strong class="source-inline">ssize_t (*read) (struct file *, char *, size_t, loff_t *);</strong>: The role of this function is to retrieve data from the device. Since the return value is a "signed size" type, this function must return either the number (positive) of bytes successfully read, or else return an appropriate negative code on error. If this function is not implemented, then any <strong class="source-inline">read()</strong> system call on the device file will fail, returning with <strong class="source-inline">-EINVAL</strong> (an "invalid argument"). </li>
				<li><strong class="source-inline">ssize_t (*write) (struct file *, const char *, size_t, loff_t *);</strong>: The role of this function is to send data to the device. Like the <strong class="source-inline">read()</strong> function, it must return a positive number, which, in this case, represents the number of bytes that have been written successfully, or else return an appropriately negative code on error. In the same way, if it is not implemented in the driver, then the <strong class="source-inline">write()</strong> system call attempt will fail with <strong class="source-inline">-EINVAL</strong>.</li>
				<li><strong class="source-inline">int (*flush) (struct file *, fl_owner_t id);</strong>: This operation is invoked when the file structure is being released. Like <strong class="source-inline">open</strong>, <strong class="source-inline">release</strong> can be <strong class="source-inline">NULL</strong>.</li>
				<li><strong class="source-inline">unsigned int (*poll) (struct file *, struct poll_table_struct *);</strong>: This file operation must return a bitmask describing the status of the device. It is the kernel backend for both <strong class="source-inline">poll()</strong> and <strong class="source-inline">select()</strong> system calls, both used to query whether the device is writable, readable, or in some special state. Any caller of this method will block until the device enters the requested state. If this file operation is not implemented, then the device is always assumed to be readable, writable, and in no special state.</li>
				<li><strong class="source-inline">int (*mmap) (struct file *, struct vm_area_struct *);</strong>: This is used to request part or all of the device memory to be mapped to a process address space. If this file operation is not implemented, then any attempt to invoke the <strong class="source-inline">mmap()</strong> system call on the device file will fail, returning <strong class="source-inline">-ENODEV</strong>.</li>
				<li><strong class="source-inline">int (*open) (struct inode *, struct file *);</strong> This file operation is the backend of the <strong class="source-inline">open()</strong> system call, which, if not implemented (if <strong class="source-inline">NULL</strong>), will result in the success<a id="_idIndexMarker325"/> of any attempt to open the device and the driver won't be notified of the operation.</li>
				<li><strong class="source-inline">int (*release) (struct inode *, struct file *);</strong>: This is invoked when the file is being released, in response to the <strong class="source-inline">close()</strong> system call. Like <strong class="source-inline">open</strong>, <strong class="source-inline">release</strong> is not mandatory and can be <strong class="source-inline">NULL</strong>. </li>
				<li><strong class="source-inline">int (*fsync) (struct file *, loff_t, loff_t, int datasync);</strong>: This operation is the backend of the <strong class="source-inline">fsync()</strong> system call, whose purpose is to flush any pending data. If it is not implemented, any call to <strong class="source-inline">fsync()</strong> on the device file will fail, returning <strong class="source-inline">-EINVAL</strong>.</li>
				<li><strong class="source-inline">long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</strong>: This is the backend of the <strong class="source-inline">ioctl</strong> system call, whose purpose is to extend the commands that can be sent to the device (such as formatting a track of a floppy disk, which is neither reading nor writing). The commands defined by this function will extend a set of predefined commands that are already recognized by the kernel without referring to this file operation. Thus, for any command that is not defined (either because this function is not implemented or because it does not support the specified command), the system call will return <strong class="source-inline">-ENOTTY</strong>, to say <em class="italic">"No such ioctl for device"</em>. Any non-negative value returned by this function is passed back to the calling program to indicate successful <a id="_idIndexMarker326"/>completion.</li>
			</ul>
			<p>Now that we are familiar with the file operation callbacks, let's delve into the kernel insights and learn how files are handled for a better understanding of the mechanisms behind characte<a id="_idTextAnchor065"/>r devices.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>File representation in the kernel</h2>
			<p>Looking at the file <a id="_idIndexMarker327"/>operation table, at least one of the parameters of each operation is either the <strong class="source-inline">struct inode</strong> or <strong class="source-inline">struct file</strong> type. <strong class="source-inline">struct inode</strong> refers to a file on the disk. However, to refer an open file (associated with a file descriptor within a process), the <strong class="source-inline">struct file</strong> structure is used.</p>
			<p>The following is the declaration of an <strong class="source-inline">inode</strong> structure:</p>
			<p class="source-code">struct inode {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    union {</p>
			<p class="source-code">        struct pipe_inode_info  *i_pipe;</p>
			<p class="source-code">        struct cdev    *i_cdev;</p>
			<p class="source-code">        char           *i_link;</p>
			<p class="source-code">        unsigned       i_dir_seq;</p>
			<p class="source-code">    };</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>The most important field in the structure is the <strong class="source-inline">union</strong>, especially the <strong class="source-inline">i_cdev</strong> element, which is set when the underlying file is a character device. This makes it possible to switch back and forth between <strong class="source-inline">struct inode</strong> and <strong class="source-inline">struct cdev</strong>.</p>
			<p>On the other hand, <strong class="source-inline">struct file</strong> is a filesystem data structure holding information about a file (its type, character, block, pipe, and so on), most of which is only relevant to the OS. The <strong class="source-inline">struct file</strong> structure (defined in <strong class="source-inline">include/linux/fs.h</strong>) has the following definition: </p>
			<p class="source-code">struct file {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">   struct path f_path;</p>
			<p class="source-code">   struct inode *f_inode;</p>
			<p class="source-code">   const struct file_operations *f_op;</p>
			<p class="source-code">   loff_t f_pos;</p>
			<p class="source-code">   void *private_data;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">}</p>
			<p>In the preceding <a id="_idIndexMarker328"/>data structure, <strong class="source-inline">f_path</strong> represents the actual path of the file in the filesystem, and <strong class="source-inline">f_inode</strong> is the underlying <strong class="source-inline">inode</strong> that points to this opened file. This makes it possible to switch back and forth between <strong class="source-inline">struct file</strong> and the underlying <strong class="source-inline">cdev</strong>, through the <strong class="source-inline">f_inode</strong> element. <strong class="source-inline">f_op</strong> represents the file operation table. Because <strong class="source-inline">struct file</strong> represents an open file descriptor, it tracks the current read/write position within its opened instance. This is done through the <strong class="source-inline">f_pos</strong> element, and <strong class="source-inline">f_pos</strong> is the current read/write position.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor067"/>Creating a device node</h1>
			<p>The creation of a device <a id="_idIndexMarker329"/>node makes it visible to users and allows users to interact with the underlying device. Linux requires intermediate steps before the device node is created and the following section discusses these steps.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor068"/>Device identification</h2>
			<p>To precisely identify <a id="_idIndexMarker330"/>devices, their identifiers must be unique. Although identifiers can be dynamically allocated, most drivers still use static identifiers for compatibility reasons. Whatever the allocation method, the Linux kernel stores file device numbers in elements of <strong class="source-inline">dev_t</strong> type, which is a 32-bit unsigned integer in which the major is represented by the first <strong class="source-inline">12</strong> bits, and the minor is coded on the <strong class="source-inline">20</strong> remaining bits.</p>
			<p>All of this is stated in <strong class="source-inline">include/linux/kdev_t.h</strong>, which contains several macros, including those that, given a <strong class="source-inline">dev_t</strong> type variable, can return either a minor or a major number:</p>
			<p class="source-code">#define MINORBITS    20</p>
			<p class="source-code">#define MINORMASK    ((1U &lt;&lt; MINORBITS) - 1)</p>
			<p class="source-code">#define MAJOR(dev)    ((unsigned int) ((dev) &gt;&gt; MINORBITS))</p>
			<p class="source-code">#define MINOR(dev)    ((unsigned int) ((dev) &amp; MINORMASK))</p>
			<p class="source-code">#define MKDEV(ma,mi)  (((ma) &lt;&lt; MINORBITS) | (mi))</p>
			<p>The last macro <a id="_idIndexMarker331"/>accepts a minor and a major number and returns a <strong class="source-inline">dev_t</strong> type identifier, which the kernel uses to keep identifiers. The preceding excerpt also describes how the <strong class="source-inline">character device</strong> identifier is built using a bit shift. At this point, we can get deep into the code, using the APIs that the kernel provides for code allocation.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>Registration and deregistration of character device numbers</h2>
			<p>There are<a id="_idIndexMarker332"/> two ways to deal with device numbers – <strong class="bold">registration</strong> (the static method) and <strong class="bold">allocation</strong> (the dynamic method). Registration, also called <strong class="bold">static allocation</strong>, is only useful if you <a id="_idIndexMarker333"/>know in advance which major number you want to start with, after making sure it does not clash with <a id="_idIndexMarker334"/>another driver using the same major (though this is not always predictable). Registration is a brute-force method in which you let the kernel know what device numbers you want by providing the starting major/minor pair and the number of minors, and it either grants them to you or not (depending on availability). The function to use for device number registration is the following:</p>
			<p class="source-code">int register_chrdev_region(dev_t first, unsigned int count,</p>
			<p class="source-code">                           char *name);</p>
			<p>This method returns <strong class="source-inline">0</strong> on success, or a negative error code when it fails. The <strong class="source-inline">first</strong> parameter is the identifier you must have built using the major number and the first minor of the desired range. You can use the <strong class="source-inline">MKDEV(maj, min)</strong> macro to achieve that. <strong class="source-inline">count</strong> is the number of consecutive device minors required, and <strong class="source-inline">name</strong> should be the name of the associated device or driver.</p>
			<p>However, note that <strong class="source-inline">register_chrdev_region()</strong> works well if you know exactly which device numbers you want, and of course, those numbers must be available on your running system. Because this can be a source of conflict with other device drivers, it is considered preferable to use dynamic allocation, with which the kernel happily allocates a major number for you on the fly. <strong class="source-inline">alloc_chrdev_region()</strong> is the API you must use for dynamic allocation. The following is its prototype: </p>
			<p class="source-code">int alloc_chrdev_region(</p>
			<p class="source-code">                      dev_t *dev, unsigned int firstminor,</p>
			<p class="source-code">                      unsigned int count, char *name);</p>
			<p>This method returns <strong class="source-inline">0</strong> on <a id="_idIndexMarker335"/>success, or a negative error code on failure. <strong class="source-inline">dev</strong> is the only output parameter. It represents the first number (built using the allocated major and the first minor requested) that the kernel assigned. <strong class="source-inline">firstminor</strong> is the first of the requested range of minor numbers, <strong class="source-inline">count</strong> is the number of consecutive minors you need, and <strong class="source-inline">name</strong> should be the name of the associated device or driver.</p>
			<p>The difference between static allocation and dynamic allocation is that, with the former, you should know in advance which device number is needed. When it comes to loading the driver on another machine, there is no guarantee that the chosen number is free on that machine, and this can lead to conflict and trouble. New drivers are encouraged to use dynamic allocation to obtain a major device number, rather than choosing a number randomly from the ones that are currently free, which will probably lead to a clash. In other words, your drivers are better using <strong class="source-inline">alloc_chrdev_region()</strong> rather than <strong class="source-inline">register_chrdev_region()</strong>.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>Initializing and registering a character device on the system</h2>
			<p>The registration of a<a id="_idIndexMarker336"/> character device is made by specifying a device identifier (of <strong class="source-inline">dev_t</strong> type). In this chapter, we will be using dynamic allocation, using <strong class="source-inline">alloc_chrdev_region()</strong>. After the identifier has been allocated, you must initialize <a id="_idIndexMarker337"/>the character device and add it to the system using <strong class="source-inline">cdev_init()</strong> and <strong class="source-inline">cdev_add(),</strong> respectively. The following are their prototypes:</p>
			<p class="source-code">void cdev_init(struct cdev *cdev,</p>
			<p class="source-code">               const struct file_operations *fops);</p>
			<p class="source-code">int cdev_add (struct cdev * p, dev_t dev, unsigned count);</p>
			<p>In <strong class="source-inline">cdev_init()</strong>, <strong class="source-inline">cdev</strong> is the structure to initialize, and <strong class="source-inline">fops</strong> the <strong class="source-inline">file_operations</strong> instance for this device, making it ready to add to the system. In <strong class="source-inline">cdev_add()</strong>, <strong class="source-inline">p</strong> is the <strong class="source-inline">cdev</strong> structure for the device, <strong class="source-inline">dev</strong> is the first device number for which this device is responsible (obtained dynamically), and <strong class="source-inline">count</strong> is the number of consecutive minor numbers corresponding to this device. When it succeeds, <strong class="source-inline">cdev_add()</strong> returns <strong class="source-inline">0</strong>, or else it returns a negative error code.</p>
			<p>The respective reverse operation of <strong class="source-inline">cdev_add()</strong> is <strong class="source-inline">cdev_del()</strong>, which removes the character device from the system and has the following prototype:</p>
			<p class="source-code">void cdev_del(struct cdev *);</p>
			<p>At this step, the device is part <a id="_idIndexMarker338"/>of the system but not physically present. In other words, it is not visible in <strong class="source-inline">/dev</strong> yet. For the node to be created, you must use <strong class="source-inline">device_create()</strong>, which has the following prototype:</p>
			<p class="source-code">struct device * device_create(struct class *class,</p>
			<p class="source-code">                              struct device *parent,</p>
			<p class="source-code">                              dev_t devt,</p>
			<p class="source-code">                              void *drvdata, </p>
			<p class="source-code">                              const char *fmt, ...)</p>
			<p>This method creates a device and registers it with Sysfs. In its argument, <strong class="source-inline">class</strong> is a pointer to <strong class="source-inline">struct class</strong> that this device should be registered to, <strong class="source-inline">parent</strong> is a pointer to the <strong class="source-inline">struct device</strong> parent of this new device if there is any, <strong class="source-inline">devt</strong> is the device number for the char device to be added, and <strong class="source-inline">drvdata</strong> is the data to be added to the device for callbacks.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">In case of multiple minors, the <strong class="source-inline">device_create()</strong> and <strong class="source-inline">device_destroy()</strong> APIs can be put in a <strong class="source-inline">for</strong> loop, and the <strong class="source-inline">&lt;device name format&gt;</strong> string can be appended with the loop counter, as follows: </p>
			<p class="callout"><strong class="source-inline">device_create(class, NULL, MKDEV(MAJOR(first_devt), MINOR(first_devt) + i), NULL, "mynull%d", i);</strong></p>
			<p>Because a device needs an existing class before being created, you must either create a class or use an existing one. For now, we will create a class, and to do that, we need to use the <strong class="source-inline">class_create()</strong> function, declared as the following:</p>
			<p class="source-code">struct class * class_create(struct module * owner,</p>
			<p class="source-code">                            const char * name);</p>
			<p>After then, the<a id="_idIndexMarker339"/> class will be visible in <strong class="source-inline">/sys/class</strong>, and we can create the device using that class. The<a id="_idIndexMarker340"/> following is a rough example: </p>
			<p class="source-code">#define EEP_NBANK 8</p>
			<p class="source-code">#define EEP_DEVICE_NAME "eep-mem"</p>
			<p class="source-code">#define EEP_CLASS "eep-class"</p>
			<p class="source-code">static struct class *eep_class;</p>
			<p class="source-code">static struct cdev eep_cdev[EEP_NBANK];</p>
			<p class="source-code">static dev_t dev_num;</p>
			<p class="source-code">static int __init my_init(void)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int i;</p>
			<p class="source-code">    dev_t curr_dev;</p>
			<p class="source-code">    /* Request for a major and EEP_NBANK minors */</p>
			<p class="source-code">    alloc_chrdev_region(&amp;dev_num, 0, EEP_NBANK, </p>
			<p class="source-code">                        EEP_DEVICE_NAME);</p>
			<p class="source-code">    /* create our device class, visible in /sys/class */</p>
			<p class="source-code">    eep_class = class_create(THIS_MODULE, EEP_CLASS);</p>
			<p class="source-code">    /* Each bank is represented as a character device (cdev) */</p>
			<p class="source-code">    for (i = 0; i &lt; EEP_NBANK; i++) {</p>
			<p class="source-code">        /* bind file_operations to the cdev */</p>
			<p class="source-code">        cdev_init(&amp;my_cdev[i], &amp;eep_fops);</p>
			<p class="source-code">        eep_cdev[i].owner = THIS_MODULE;</p>
			<p class="source-code">        /* Device number to use to add cdev to the core */</p>
			<p class="source-code">        curr_dev = MKDEV(MAJOR(dev_num),</p>
			<p class="source-code">                          MINOR(dev_num) + i);</p>
			<p class="source-code">        /* Make the device live for the users to access */</p>
			<p class="source-code">        cdev_add(&amp;eep_cdev[i], curr_dev, 1);</p>
			<p class="source-code">        /* create a node for each device */</p>
			<p class="source-code">        device_create(eep_class,</p>
			<p class="source-code">              NULL,     /* no parent device */</p>
			<p class="source-code">              curr_dev,</p>
			<p class="source-code">              NULL,     /* no additional data */</p>
			<p class="source-code">              EEP_DEVICE_NAME "%d", i); /* eep-mem[0-7] */</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, <strong class="source-inline">device_create()</strong> will create a node for each device, – <strong class="source-inline">/dev/eep-mem0</strong>, <strong class="source-inline">dev/eep-mem1</strong>, and so on, with our class represented by <strong class="source-inline">eep_class</strong>. Additionally, devices can also be viewed under <strong class="source-inline">/sys/class/eep-class</strong>. In the meantime, the <a id="_idIndexMarker341"/>reverse operation is the following:</p>
			<p class="source-code">for (i = 0; i &lt; EEP_NBANK; i++) {</p>
			<p class="source-code">    device_destroy(eep_class,</p>
			<p class="source-code">              MKDEV(MAJOR(dev_num), (MINOR(dev_num) +i)));</p>
			<p class="source-code">    cdev_del(&amp;eep_cdev[i]);</p>
			<p class="source-code">}</p>
			<p class="source-code">class_unregister(eep_class);</p>
			<p class="source-code">class_destroy(eep_class);</p>
			<p class="source-code">unregister_chrdev_region(chardev_devt, EEP_NBANK);</p>
			<p>In the preceding code, <strong class="source-inline">device_destroy()</strong> will remove a device node from <strong class="source-inline">/dev</strong>, <strong class="source-inline">cdev_del()</strong> will make the system forget about this character device, <strong class="source-inline">class_unregister()</strong> and <strong class="source-inline">class_destroy()</strong> will deregister and remove the class from the system, and finally, <strong class="source-inline">unregister_chrdev_region()</strong> will release our device number.</p>
			<p>Now that we are familiar with all the prerequisites about character devices, we can start implementing a file operation, which allows users to interact with the underlying device.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor071"/>Implementing file operations</h1>
			<p>After introducing file operations in the<a id="_idIndexMarker342"/> previous section, it is time to implement those to enhance the driver capabilities and expose the device's methods to user space (by means of system calls, of course). Each of these methods has its particularities, which we will highlight in this section.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>Exchanging data between the kernel space and user space</h2>
			<p>As we have seen while introducing the file operation table, the <strong class="source-inline">read</strong> and <strong class="source-inline">write</strong> methods are used to exchange data with the underlying device. Both being system calls means that data will originate from or be in destination to user space. While looking at the <strong class="source-inline">read</strong> and <strong class="source-inline">write</strong> method prototypes, the first point that catches our attention is the use of <strong class="source-inline">__user</strong>. This is a cookie<a id="_idIndexMarker343"/> used by <strong class="bold">Sparse</strong> (a semantic checker used by the kernel to find possible coding faults) to let the developer know they are about to use an untrusted pointer (or a pointer that may be invalid in the current virtual address mapping) improperly, which they should not dereference but, instead, use dedicated kernel functions to access the memory to which this pointer points.</p>
			<p>This leads us to two principal functions that allow us to exchange data between a kernel and user space, <strong class="source-inline">copy_from_user()</strong> and <strong class="source-inline">copy_to_user()</strong>, which copy a buffer from user space<a id="_idIndexMarker344"/> to kernel space<a id="_idIndexMarker345"/> and vice versa, respectively:</p>
			<p class="source-code">unsigned long copy_from_user(void *to,</p>
			<p class="source-code">               const void __user *from, unsigned long n)</p>
			<p class="source-code">unsigned long copy_to_user(void __user *to,</p>
			<p class="source-code">               const void *from, unsigned long n)</p>
			<p>In both cases, pointers prefixed with <strong class="source-inline">__user</strong> point to the user space (untrusted) memory. <strong class="source-inline">n</strong> represents the number of bytes to copy, either to or from user space. <strong class="source-inline">from</strong> represents the source address, and <strong class="source-inline">to</strong> is the destination address. Each of these returns the number of bytes that could not be copied, if any, while they return <strong class="source-inline">0</strong> on success. Note that these routines may sleep as they run in a user context and do not need to be invoked in an atomic context. </p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>Implementing the open file operation</h2>
			<p>The <strong class="source-inline">open</strong> file operation <a id="_idIndexMarker346"/>is the backend of the open system call. One usually uses this method to perform device and data structure initializations, after which it should return <strong class="source-inline">0</strong> on success, or a negative error code if something went wrong. The prototype of the <strong class="source-inline">open</strong> file operation is defined as follows:</p>
			<p class="source-code">int (*open) (struct inode *inode, struct file *filp);</p>
			<p>If it is not implemented, device <a id="_idIndexMarker347"/>opening will always succeed, but the driver won't be aware, which is not necessarily a problem if the device needs no special initialization. </p>
			<h3>Per-device data</h3>
			<p>As we have seen in file operation prototypes, there is almost always a <strong class="source-inline">struct file</strong> argument. <strong class="source-inline">struct file</strong> has an element free of use, that is <strong class="source-inline">private_data</strong>. <strong class="source-inline">file-&gt;private_data</strong>, if set, will be available to other system calls invoked on the same file descriptor. You can use this<a id="_idIndexMarker348"/> field during the lifetime of the file descriptor. It is good practice to set this field in the <strong class="source-inline">open</strong> method as it is always the first system call on any file.</p>
			<p>The following is our data structure:</p>
			<p class="source-code">struct pcf2127 {</p>
			<p class="source-code">    struct cdev cdev;</p>
			<p class="source-code">    unsigned char *sram_data;</p>
			<p class="source-code">    struct i2c_client *client;</p>
			<p class="source-code">    int sram_size;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">};</p>
			<p>Given this data structure, the <strong class="source-inline">open</strong> method would look like the following:</p>
			<p class="source-code">static unsigned int sram_major = 0;</p>
			<p class="source-code">static struct class *sram_class = NULL;</p>
			<p class="source-code">static int sram_open(struct inode *inode,</p>
			<p class="source-code">                     struct file *filp)</p>
			<p class="source-code">{</p>
			<p class="source-code">    unsigned int maj = imajor(inode);</p>
			<p class="source-code">    unsigned int min = iminor(inode);</p>
			<p class="source-code">    struct pcf2127 *pcf = NULL;</p>
			<p class="source-code">    pcf = container_of(inode-&gt;i_cdev,</p>
			<p class="source-code">                        struct pcf2127, cdev);</p>
			<p class="source-code">    pcf-&gt;sram_size = SRAM_SIZE;</p>
			<p class="source-code">    if (maj != sram_major || min &lt; 0 ){</p>
			<p class="source-code">        pr_err ("device not found\n");</p>
			<p class="source-code">        return -ENODEV; /* No such device */</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /* prepare the buffer if the device is</p>
			<p class="source-code">     * opened for the first time</p>
			<p class="source-code">       */</p>
			<p class="source-code">    if (pcf-&gt;sram_data == NULL) {</p>
			<p class="source-code">        pcf-&gt;sram_data =</p>
			<p class="source-code">                  kzalloc(pcf-&gt;sram_size, GFP_KERNEL);</p>
			<p class="source-code">        if (pcf-&gt;sram_data == NULL) {</p>
			<p class="source-code">            pr_err("memory allocation failed\n");</p>
			<p class="source-code">            return -ENOMEM;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    filp-&gt;private_data = pcf;</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Most of the time, the <strong class="source-inline">open</strong> operation does some initialization and requests resources that will be used while a user keeps an open instance of the device node. Everything that has to be done in this operation must be undone and released when the device is closed, as we'll see in the next operation.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor074"/>Implementing the release file operation</h2>
			<p>The <strong class="source-inline">release</strong> method <a id="_idIndexMarker349"/>is called when the device gets closed, the reverse of the <strong class="source-inline">open</strong> method. You must then undo everything you have done in the <strong class="source-inline">open</strong> operation. It could be literally, freeing any private memory allocated and shutting down the device (if supported), and discarding every buffer on the last closing (if the device supports multi-opening, or if the driver can handle more than one device at a time).</p>
			<p>The following is an excerpt of a <strong class="source-inline">release</strong> function:</p>
			<p class="source-code">static int sram_release(struct inode *inode,</p>
			<p class="source-code">                        struct file *filp)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct pcf2127 *pcf = NULL;</p>
			<p class="source-code">    pcf = container_of(inode-&gt;i_cdev,</p>
			<p class="source-code">                        struct pcf2127, cdev);</p>
			<p class="source-code">    mutex_lock(&amp;device_list_lock);</p>
			<p class="source-code">    filp-&gt;private_data = NULL;</p>
			<p class="source-code">    /* last close? */</p>
			<p class="source-code">    pcf2127-&gt;users--;</p>
			<p class="source-code">    if (!pcf2127-&gt;users) {</p>
			<p class="source-code">        kfree(tx_buffer);</p>
			<p class="source-code">        kfree(rx_buffer);</p>
			<p class="source-code">        tx_buffer = NULL;</p>
			<p class="source-code">        rx_buffer = NULL;</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">        if (any_other_dynamic_struct)</p>
			<p class="source-code">            kfree(any_other_dynamic_struct);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    mutex_unlock(&amp;device_list_lock);</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>The preceding code releases all the resources acquired when the device node has been open. This is literally all that needs to be done in this file operation. If the device node is backed by a<a id="_idIndexMarker350"/> hardware device, this operation can also put this device in the appropriate state.</p>
			<p>At this point, we are able to implement the entry (<strong class="source-inline">open</strong>) and exit (<strong class="source-inline">release)</strong> points for the character device. All that remains now is to implement each possible operation that can be done in between.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Implementing the write file operation</h2>
			<p>The <strong class="source-inline">write</strong> method is used to send <a id="_idIndexMarker351"/>data to the device; whenever a user calls the <strong class="source-inline">write()</strong> system call on the device's file, the kernel implementation that is called ends up being invoked. Its prototype is as follows:</p>
			<p class="source-code">ssize_t(*write)(struct file *filp, const char __user *buf,</p>
			<p class="source-code">                size_t count, loff_t *pos);</p>
			<p>This file operation must return the number of bytes (size) written, and the following are the definitions of its arguments:</p>
			<ul>
				<li><strong class="source-inline">*buf</strong> represents the data buffer coming from the user space.</li>
				<li><strong class="source-inline">count</strong> is the size of the requested transfer.</li>
				<li><strong class="source-inline">*pos</strong> indicates the start position from which data should be written in the file (or in the corresponding memory region if the character device file is memory-backed).</li>
			</ul>
			<p>Generally, in this file operation, the first thing to do is to check for bad or invalid requests coming from the user space (for example, check for size limitations in case of a memory-backed device and size overflow). The following is an example:</p>
			<p class="source-code">/* if trying to Write beyond the end of the file,</p>
			<p class="source-code"> * return error. "filesize" here corresponds to the size</p>
			<p class="source-code"> * of the device memory (if any)</p>
			<p class="source-code"> */</p>
			<p class="source-code">if (*pos &gt;= filesize) return –EINVAL;</p>
			<p>After the checks, it is<a id="_idIndexMarker352"/> common to make some adjustments, especially with <strong class="source-inline">count,</strong> to not go beyond the file size. This step is not mandatory either:</p>
			<p class="source-code">/* filesize corresponds to the size of device memory */</p>
			<p class="source-code">if (*pos + count &gt; filesize) </p>
			<p class="source-code">    count = filesize - *pos;</p>
			<p>The next step is to find the location from which you will start to write. This step is relevant only if the device is backed by physical memory in which the <strong class="source-inline">write()</strong> method is supposed to store given data:</p>
			<p class="source-code">/* convert pos into valid address */</p>
			<p class="source-code">void *from = pos_to_address(*pos); </p>
			<p>Finally, you can copy data from user space into kernel memory, after which you can perform the <strong class="source-inline">write</strong> operation on the backing device and adjust <strong class="source-inline">*pos</strong>, as in the following excerpt:</p>
			<p class="source-code">if (copy_from_user(dev-&gt;buffer, buf, count) != 0){</p>
			<p class="source-code">    retval = -EFAULT;</p>
			<p class="source-code">    goto out;</p>
			<p class="source-code">}</p>
			<p class="source-code">/* now move data from dev-&gt;buffer to physical device */</p>
			<p class="source-code">write_error = device_write(dev-&gt;buffer, count);</p>
			<p class="source-code">if (write_error)</p>
			<p class="source-code">    return –EFAULT;</p>
			<p class="source-code">/* Increase the current position of the cursor in the file,</p>
			<p class="source-code"> * according to the number of bytes written and finally,</p>
			<p class="source-code"> * return the number of bytes copied</p>
			<p class="source-code"> */</p>
			<p class="source-code">*pos += count;</p>
			<p class="source-code">return count;</p>
			<p>The following is an <a id="_idIndexMarker353"/>example of the <strong class="source-inline">write</strong> method, which summarizes the steps described so far:</p>
			<p class="source-code">ssize_t </p>
			<p class="source-code">eeprom_write(struct file *filp, const char __user *buf,</p>
			<p class="source-code">             size_t count, loff_t *f_pos)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct eeprom_dev *eep = filp-&gt;private_data;</p>
			<p class="source-code">    int part_origin = PART_SIZE * eep-&gt;part_index;</p>
			<p class="source-code">    int register_address;</p>
			<p class="source-code">    ssize_t retval = 0;</p>
			<p class="source-code">    /* step (1) */</p>
			<p class="source-code">    if (*f_pos &gt;= eep-&gt;part_size) </p>
			<p class="source-code">        /* Can't write beyond the end of a partition. */</p>
			<p class="source-code">        return -EINVAL;</p>
			<p class="source-code">    /* step (2) */</p>
			<p class="source-code">    if (*pos + count &gt; eep-&gt;part_size)</p>
			<p class="source-code">        count = eep-&gt;part_size - *pos;</p>
			<p class="source-code">    /* step (3) */</p>
			<p class="source-code">    register_address = part_origin + *pos;</p>
			<p class="source-code">    /* step(4) */</p>
			<p class="source-code">    /* Copy data from user space to kernel space */</p>
			<p class="source-code">    if (copy_from_user(eep-&gt;data, buf, count) != 0)</p>
			<p class="source-code">        return -EFAULT;</p>
			<p class="source-code">    /* step (5) */</p>
			<p class="source-code">    /* perform the write to the device */</p>
			<p class="source-code">    if (write_to_device(register_address, buff, count)</p>
			<p class="source-code">        &lt; 0){</p>
			<p class="source-code">        pr_err("i2c_transfer failed\n");  </p>
			<p class="source-code">        return –EFAULT;</p>
			<p class="source-code">     }</p>
			<p class="source-code">    /* step (6) */</p>
			<p class="source-code">    *f_pos += count;</p>
			<p class="source-code">    return count;</p>
			<p class="source-code">}</p>
			<p>After the data has<a id="_idIndexMarker354"/> been read and processed, it might be necessary to write the processing output back. Since we have started with writing, the next operation we may think of is <strong class="source-inline">read</strong>, as we will see in the next section.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>Implementing the read file operation</h2>
			<p>The <strong class="source-inline">read</strong> method<a id="_idIndexMarker355"/> has the following prototype:</p>
			<p class="source-code">ssize_t (*read) (struct file *filp, char __user *buf,</p>
			<p class="source-code">                 size_t count, loff_t *pos);</p>
			<p>This operation is the backend of the <strong class="source-inline">read()</strong> system call. Its arguments are described as follows:</p>
			<ul>
				<li><strong class="source-inline">*buf</strong> is the buffer we receive from user space.</li>
				<li><strong class="source-inline">count</strong> is the size of the requested transfer (the size of the user buffer).</li>
				<li><strong class="source-inline">*pos</strong> indicates the start position from which data should be read in the file.</li>
			</ul>
			<p>It must return the size of the data that has been successfully read. This size can be less than <strong class="source-inline">count</strong> though (for example, when reaching the end of the file before reaching the <strong class="source-inline">count</strong> requested by the user).</p>
			<p>Implementing the read operation looks like the write one, since some sanity checks need to be performed. First, you can prevent reading beyond the file size and return an end-of-file response:</p>
			<p class="source-code">if (*pos &gt;= filesize)</p>
			<p class="source-code">    return 0; /* 0 means EOF */</p>
			<p>Then, you should make sure the number of bytes read can't go beyond the file size and you can adjust <strong class="source-inline">count</strong> appropriately:</p>
			<p class="source-code">if (*pos + count &gt; filesize)</p>
			<p class="source-code">    count = filesize – (*pos);</p>
			<p>Next, you can find the location from which you will start the read, after which you can copy the data into the user space buffer and return an error on failure, and then advance the file's current position according to the number of bytes read and return the number of bytes copied:</p>
			<p class="source-code">/* convert pos into valid address */</p>
			<p class="source-code">void *from = pos_to_address (*pos); </p>
			<p class="source-code">sent = copy_to_user(buf, from, count);</p>
			<p class="source-code">if (sent)</p>
			<p class="source-code">    return –EFAULT;</p>
			<p class="source-code">*pos += count;</p>
			<p class="source-code">return count;</p>
			<p>The following is an <a id="_idIndexMarker356"/>example of a driver <strong class="source-inline">read()</strong> file operation, intended to give an overview of what can be done here:</p>
			<p class="source-code">ssize_t  eep_read(struct file *filp, char __user *buf,</p>
			<p class="source-code">                  size_t count, loff_t *f_pos)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct eeprom_dev *eep = filp-&gt;private_data;</p>
			<p class="source-code">    if (*f_pos &gt;= EEP_SIZE) /* EOF */</p>
			<p class="source-code">        return 0;</p>
			<p class="source-code">    if (*f_pos + count &gt; EEP_SIZE)</p>
			<p class="source-code">        count = EEP_SIZE - *f_pos;</p>
			<p class="source-code">    /* Find location of next data bytes */</p>
			<p class="source-code">    int part_origin  =  PART_SIZE * eep-&gt;part_index;</p>
			<p class="source-code">    int eep_reg_addr_start  =  part_origin + *pos;</p>
			<p class="source-code">    /* perform the read from the device */</p>
			<p class="source-code">    if (read_from_device(eep_reg_addr_start, buff, count)</p>
			<p class="source-code">        &lt; 0){</p>
			<p class="source-code">        pr_err("i2c_transfer failed\n");  </p>
			<p class="source-code">        return –EFAULT;</p>
			<p class="source-code">    } </p>
			<p class="source-code">    /* copy from kernel to user space */</p>
			<p class="source-code">    if(copy_to_user(buf, dev-&gt;data, count) != 0)</p>
			<p class="source-code">        return -EIO;</p>
			<p class="source-code">    *f_pos += count;</p>
			<p class="source-code">    return count;</p>
			<p class="source-code">}</p>
			<p>Though reading and <a id="_idIndexMarker357"/>writing data moves the cursor position, there is an operation whose main purpose is to move the cursor position without touching data at all. Such an operation helps to start writing or reading data from anywhere by moving the cursor to the desired position.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor077"/>Implementing the llseek file operation</h2>
			<p>The <strong class="source-inline">llseek</strong> file operation<a id="_idIndexMarker358"/> is the kernel backend for the <strong class="source-inline">lseek()</strong> system call, used to move the cursor position within a file. Its prototype looks as follows:</p>
			<p class="source-code">loff_t(*llseek) (struct file *filp, loff_t offset,</p>
			<p class="source-code">                 int whence);</p>
			<p>This callback must return the new position in the file. The following are the definitions of its parameters:</p>
			<ul>
				<li><strong class="source-inline">loff_t</strong> is an offset, relative to the current file position, which defines how much of it will be changed.</li>
				<li><strong class="source-inline">whence</strong> defines where to seek from. The possible values are as follows:<ul><li><strong class="source-inline">SEEK_SET</strong>: To put the cursor to a position relative from the beginning of the file</li><li><strong class="source-inline">SEEK_CUR</strong>: To put the cursor to a position relative to the current file position</li><li><strong class="source-inline">SEEK_END</strong>: To adjust the cursor to a position relative to the end of the file</li></ul></li>
			</ul>
			<p>When implementing this operation, it is a good practice to use the <strong class="source-inline">switch</strong> statement to check every<a id="_idIndexMarker359"/> possible <strong class="source-inline">whence</strong> case, since they are limited, and adjust the new position accordingly:</p>
			<p class="source-code">switch( whence ){</p>
			<p class="source-code">    case SEEK_SET:/* relative from the beginning of file */</p>
			<p class="source-code">        newpos = offset; /* offset become the new position */</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case SEEK_CUR: /* relative to current file position */</p>
			<p class="source-code">        /* just add offset to the current position */</p>
			<p class="source-code">        newpos = file-&gt;f_pos + offset;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    case SEEK_END: /* relative to end of file */</p>
			<p class="source-code">        newpos = filesize + offset;</p>
			<p class="source-code">        break;</p>
			<p class="source-code">    default:</p>
			<p class="source-code">        return -EINVAL;</p>
			<p class="source-code">}</p>
			<p class="source-code">/* Check whether newpos is valid **/</p>
			<p class="source-code">if ( newpos &lt; 0 )</p>
			<p class="source-code">    return –EINVAL;</p>
			<p class="source-code">/* Update f_pos with the new position */</p>
			<p class="source-code">filp-&gt;f_pos = newpos;</p>
			<p class="source-code">/* Return the new file-pointer position */</p>
			<p class="source-code">return newpos;</p>
			<p>After the preceding <a id="_idIndexMarker360"/>kernel backend excerpt, the following is an example of a user program that will successively read and seek into a file. The underlying driver will then execute the <strong class="source-inline">llseek()</strong> file operation entry:</p>
			<p class="source-code">#include &lt;unistd.h&gt;</p>
			<p class="source-code">#include &lt;fcntl.h&gt;</p>
			<p class="source-code">#include &lt;sys/types.h&gt;</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#define CHAR_DEVICE "foo"</p>
			<p class="source-code">int main(int argc, char **argv)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int fd = 0;</p>
			<p class="source-code">    char buf[20];</p>
			<p class="source-code">    if ((fd = open(CHAR_DEVICE, O_RDONLY)) &lt; -1)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    /* Read 20 bytes */</p>
			<p class="source-code">    if (read(fd, buf, 20) != 20)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    printf("%s\n", buf);</p>
			<p class="source-code">    /* Move the cursor to ten time relative to</p>
			<p class="source-code">     * its actual position</p>
			<p class="source-code">     */</p>
			<p class="source-code">    if (lseek(fd, 10, SEEK_CUR) &lt; 0)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    if (read(fd, buf, 20) != 20) </p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    printf("%s\n",buf);</p>
			<p class="source-code">    /* Move the cursor seven time, relative from</p>
			<p class="source-code">     * the beginning of the file</p>
			<p class="source-code">     */</p>
			<p class="source-code">    if (lseek(fd, 7, SEEK_SET) &lt; 0)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    if (read(fd, buf, 20) != 20)</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    printf("%s\n",buf);</p>
			<p class="source-code">    close(fd);</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>The code<a id="_idIndexMarker361"/> produces the following output:</p>
			<p class="source-code">jma@jma:~/work/tutos/sources$ cat toto </p>
			<p class="source-code">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
			<p class="source-code">jma@jma:~/work/tutos/sources$ ./seek </p>
			<p class="source-code">Lorem ipsum dolor si</p>
			<p class="source-code">nsectetur adipiscing</p>
			<p class="source-code">psum dolor sit amet,</p>
			<p class="source-code">jma@jma:~/work/tutos/sources$</p>
			<p>In this section, we have explained the concept of seeking with an example, showing how relative and absolute seeking works. Now that we are done with operations moving data around, we can switch to the next operation, sensing the readability or writability of data in a character device.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor078"/>The poll method</h2>
			<p>The <strong class="source-inline">poll</strong> method is<a id="_idIndexMarker362"/> the backend of both the <strong class="source-inline">poll()</strong> and <strong class="source-inline">select()</strong> system calls. These system calls are used to passively (by sleeping, without wasting CPU cycles) sense the readability/writability in a file. To support these system calls, the driver must implement <strong class="source-inline">poll</strong>, which has the following prototype:</p>
			<p class="source-code">unsigned int (*poll) (struct file *, struct poll_table_struct *);</p>
			<p>The kernel function at the heart of this method implementation is <strong class="source-inline">poll_wait()</strong>, defined in <strong class="source-inline">&lt;linux/poll.h&gt;</strong>, which is the header you must include in the driver code. It has the following declaration:</p>
			<p class="source-code">void poll_wait(struct file * filp,</p>
			<p class="source-code">               wait_queue_head_t * wait_address, poll_table *p)</p>
			<p><strong class="source-inline">poll_wait()</strong> adds the device associated with a <strong class="source-inline">struct file</strong> structure (given as the first parameter) to a list of those that can wake up processes (put to sleep in the <strong class="source-inline">struct wait_queue_head_t</strong> structure given as the second parameter), according to events registered in the <strong class="source-inline">struct poll_table</strong> structure given as the third parameter. A user process can call the <strong class="source-inline">poll()</strong>, <strong class="source-inline">select()</strong>, or <strong class="source-inline">epoll()</strong> system calls to add a set of files to a list on which it needs to wait, in order to be aware of the associated (if any) device's readiness. The kernel will then call the <strong class="source-inline">poll</strong> entry of the driver associated with each device file. The <strong class="source-inline">poll</strong> method of each driver should then call <strong class="source-inline">poll_wait()</strong> in order to register events for which the process needs to be notified with the kernel, put that process to sleep until one of these events occurs, and register the driver as one of those that can wake the process up. The usual way is to use a wait queue per event type (one for readability, another one for writability, and eventually one for an exception if needed), according to events supported by the <strong class="source-inline">select()</strong> (or <strong class="source-inline">poll()</strong>) system call.</p>
			<p>The return<a id="_idIndexMarker363"/> value of the (<strong class="source-inline">*poll</strong>) file operation must have <strong class="source-inline">POLLIN | POLLRDNORM</strong> set if there is data to read, <strong class="source-inline">POLLOUT | POLLWRNORM</strong> if the device is writable, and <strong class="source-inline">0</strong> if there is no new data and the device is not yet writable. In the following example, we assume the device supports both blocking read and write. Of course, you can implement only one of these. If the driver does not define this method, the device will be considered as always readable and writable, and <strong class="source-inline">poll()</strong> or <strong class="source-inline">select()</strong> system calls return immediately.</p>
			<p>Implementing the poll operation may require adapting the read or write file operations in a way that, on write, readers are notified of the readability, and on read, writers are notified of the writability:</p>
			<p class="source-code">#include &lt;linux/poll.h&gt;</p>
			<p class="source-code">/* declare a wait queue for each event type (read, write ...) */</p>
			<p class="source-code">static DECLARE_WAIT_QUEUE_HEAD(my_wq);</p>
			<p class="source-code">static DECLARE_WAIT_QUEUE_HEAD(my_rq);</p>
			<p class="source-code">static unsigned int eep_poll(struct file *file,</p>
			<p class="source-code">                             poll_table *wait)</p>
			<p class="source-code">{</p>
			<p class="source-code">    unsigned int reval_mask = 0;</p>
			<p class="source-code">    poll_wait(file, &amp;my_wq, wait);</p>
			<p class="source-code">    poll_wait(file, &amp;my_rq, wait);</p>
			<p class="source-code">    if (new_data_is_ready)</p>
			<p class="source-code">        reval_mask |= (POLLIN | POLLRDNORM);</p>
			<p class="source-code">    if (ready_to_be_written)</p>
			<p class="source-code">       reval_mask |= (POLLOUT | POLLWRNORM);</p>
			<p class="source-code">    return reval_mask;</p>
			<p class="source-code">}</p>
			<p>In the preceding <a id="_idIndexMarker364"/>snippet, we have implemented the <strong class="source-inline">poll</strong> operation, which can put processes to sleep if a device is not writable or readable. However, there is no notification mechanism when any of those states change. Therefore, a <strong class="source-inline">write</strong> operation (or any operation making data available, such as an IRQ) must notify processes sleeping in the readability wait queue; the same applies to the <strong class="source-inline">read</strong> operation (or any operation making the device ready to be writable), which must notify processes sleeping in the writability wait queue. The following is an example:</p>
			<p class="source-code">wake_up_interruptible(&amp;my_rq); /* Ready to read */</p>
			<p class="source-code">/* set flag accordingly in case poll is called */</p>
			<p class="source-code">new_data_is_ready = true;</p>
			<p class="source-code">wake_up_interruptible(&amp;my_wq); /* Ready to be written to */</p>
			<p class="source-code">ready_to_be_written = true;</p>
			<p>More precisely, you can notify a readable event either from within the driver's <strong class="source-inline">write()</strong> method, meaning that the written data can be read back, or from within an IRQ handler, meaning that an external device sent some data that can be read back. On the other hand, you can notify a writable event either from within the driver's <strong class="source-inline">read()</strong> method, meaning that the buffer is empty and can be filled again, or from within an IRQ handler, meaning that the device has completed a data-send operation and is ready to accept data again. Do not forget to set flags back to <strong class="source-inline">false</strong> when the state changes.</p>
			<p>The following is an <a id="_idIndexMarker365"/>excerpt of code that uses <strong class="source-inline">select()</strong> on a given character device in order to sense data availability:</p>
			<p class="source-code">#include &lt;unistd.h&gt;</p>
			<p class="source-code">#include &lt;fcntl.h&gt;</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;sys/select.h&gt;</p>
			<p class="source-code">#define NUMBER_OF_BYTE 100</p>
			<p class="source-code">#define CHAR_DEVICE "/dev/packt_char"</p>
			<p class="source-code">char data[NUMBER_OF_BYTE];</p>
			<p class="source-code">int main(int argc, char **argv)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int fd, retval;</p>
			<p class="source-code">    ssize_t read_count;</p>
			<p class="source-code">    fd_set readfds;</p>
			<p class="source-code">    fd = open(CHAR_DEVICE, O_RDONLY);</p>
			<p class="source-code">    if(fd &lt; 0)</p>
			<p class="source-code">        /* Print a message and exit*/</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">    while(1){ </p>
			<p class="source-code">        FD_ZERO(&amp;readfds);</p>
			<p class="source-code">        FD_SET(fd, &amp;readfds);</p>
			<p class="source-code">       ret = select(fd + 1, &amp;readfds, NULL, NULL, NULL);</p>
			<p class="source-code">        /* From here, the process is already notified */</p>
			<p class="source-code">        if (ret == -1) {</p>
			<p class="source-code">            fprintf(stderr, "select: an error ocurred");</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    </p>
			<p class="source-code">        /* we are interested in one file only */</p>
			<p class="source-code">        if (FD_ISSET(fd, &amp;readfds)) {</p>
			<p class="source-code">            read_count = read(fd, data, NUMBER_OF_BYTE);</p>
			<p class="source-code">            if (read_count &lt; 0)</p>
			<p class="source-code">                /* An error occurred. Handle this */</p>
			<p class="source-code">                [...]</p>
			<p class="source-code">            if (read_count != NUMBER_OF_BYTE)</p>
			<p class="source-code">                /* We have read less than needed bytes */</p>
			<p class="source-code">                [...] /* handle this */</p>
			<p class="source-code">            else</p>
			<p class="source-code">            /* Now we can process the data we have read */</p>
			<p class="source-code">            [...]</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }    </p>
			<p class="source-code">    close(fd);</p>
			<p class="source-code">    return EXIT_SUCCESS;</p>
			<p class="source-code">}</p>
			<p>In the preceding code sample, we used <strong class="source-inline">select()</strong> without timeout, in a way that means we will be notified of "read" events only. From that line, the process is put to sleep until it is notified of the event for which it registered itself.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor079"/>The ioctl method</h2>
			<p>A typical Linux system contains <a id="_idIndexMarker366"/>around 350 <strong class="bold">system calls</strong> (<strong class="bold">syscalls</strong>), but only a few of them are linked to file operations. Sometimes, devices may need to implement specific commands that are not provided by system calls, and especially the ones associated with files. In this case, the solution is to use <strong class="bold">input/output control</strong> (<strong class="bold">ioctl</strong>), which <a id="_idIndexMarker367"/>is a method by which you extend a list of commands associated with a device. You can use it to send special commands to devices (reset, shutdown, configure, and so on). If the driver does not define<a id="_idIndexMarker368"/> this method, the kernel will return an <strong class="source-inline">-ENOTTY</strong> error to any <strong class="source-inline">ioctl()</strong> system call. The following is its prototype:</p>
			<p class="source-code">long ioctl(struct file *f, unsigned int cmd,</p>
			<p class="source-code">           unsigned long arg);</p>
			<p>In the preceding prototype, <strong class="source-inline">f</strong> is the pointer to the file descriptor representing an opened instance of the device, <strong class="source-inline">cmd</strong> is the ioctl command, and <strong class="source-inline">arg</strong> is a user parameter, which can be the address of any user memory on which the driver can call <strong class="source-inline">copy_to_user()</strong> or <strong class="source-inline">copy_from_user()</strong>. To be concise, and for obvious reasons, an IOCTL command needs to be identified by a number, which should be unique to the system. The unicity of IOCTL numbers across the system will prevent us from sending the right command to the wrong device, or passing the wrong argument to the right command (with a duplicated IOCTL number). Linux provides four helper macros to create an IOCTL identifier, depending on whether there is data transfer or not and the direction of the transfer. Their respective prototypes are as follows:</p>
			<p class="source-code">_IO(MAGIC, SEQ_NO)</p>
			<p class="source-code">_IOR(MAGIC, SEQ_NO, TYPE)</p>
			<p class="source-code">_IOW(MAGIC, SEQ_NO, TYPE)</p>
			<p class="source-code">_IORW(MAGIC, SEQ_NO, TYPE)</p>
			<p>Their descriptions are as follows:</p>
			<ul>
				<li><strong class="source-inline">_IO</strong>: The IOCTL command does not need data transfer.</li>
				<li><strong class="source-inline">_IOR</strong>: This means that we're creating an IOCTL command number for passing information from the kernel to user space (which is reading data). The driver will be allowed to return the <strong class="source-inline">sizeof(TYPE)</strong> bytes to the user without this return value being considered as an error.</li>
				<li><strong class="source-inline">_IOW</strong>: This is the same as <strong class="source-inline">_IOR</strong>, but the user sends data to the driver this time.</li>
				<li><strong class="source-inline">_IOWR</strong>: The IOCTL command needs both write and read parameters.</li>
			</ul>
			<p>What their <a id="_idIndexMarker369"/>parameters mean (in the order they are passed) is described here:</p>
			<ul>
				<li>A number coded on 8 bits (<strong class="source-inline">0</strong> to <strong class="source-inline">255</strong>), called the <strong class="bold">magic number</strong>.</li>
				<li>A sequence number or command ID, also on 8 bits.</li>
				<li>A data type, if any, that will inform the kernel about the size to be copied. This could be the name of a structure or a data type.</li>
			</ul>
			<p>This is well documented in <strong class="source-inline">Documentation/ioctl/ioctl-decoding.txt</strong> in the kernel sources, and existing IOCTL commands are listed in <strong class="source-inline">Documentation/ioctl/ioctl-number.txt</strong>, a good place to start when you need to create your own IOCTL commands.</p>
			<h3>Generating an IOCTL number (a command)</h3>
			<p>It is recommended to generate <a id="_idIndexMarker370"/>your own IOCTL numbers in a dedicated header file, since this header should be available in user space as well. In other words, you should handle the duplication (by means of symbolic links, for example) of the IOCTL header file so that there is one in the kernel and one in user space, which can be included in user apps. Let's now generate some IOCTL numbers in a real example, and<a id="_idIndexMarker371"/> let's call this header <strong class="source-inline">eep_ioctl.h</strong>:</p>
			<p class="source-code">#ifndef PACKT_IOCTL_H</p>
			<p class="source-code">#define PACKT_IOCTL_H</p>
			<p class="source-code">/* We need to choose a magic number for our driver,</p>
			<p class="source-code"> * and sequential numbers for each command:</p>
			<p class="source-code"> */</p>
			<p class="source-code">#define EEP_MAGIC 'E'</p>
			<p class="source-code">#define ERASE_SEQ_NO 0x01</p>
			<p class="source-code">#define RENAME_SEQ_NO 0x02</p>
			<p class="source-code">#define GET_FOO 0x03</p>
			<p class="source-code">#define GET_SIZE 0x04</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * Partition name must be 32 byte max</p>
			<p class="source-code"> */</p>
			<p class="source-code">#define MAX_PART_NAME 32</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * Now let's define our ioctl numbers:</p>
			<p class="source-code"> */</p>
			<p class="source-code">#define EEP_ERASE _IO(EEP_MAGIC, ERASE_SEQ_NO)</p>
			<p class="source-code">#define EEP_RENAME_PART _IOW(EEP_MAGIC, RENAME_SEQ_NO, \</p>
			<p class="source-code">                             unsigned long)</p>
			<p class="source-code">#define EEP_GET_FOO  _IOR(EEP_MAGIC, GET_FOO, \</p>
			<p class="source-code">                          struct my_struct *)</p>
			<p class="source-code">#define EEP_GET_SIZE _IOR(EEP_MAGIC, GET_SIZE, int *)</p>
			<p class="source-code">#endif</p>
			<p>After the commands <a id="_idIndexMarker372"/>have been defined, the header needs to be included in the final code. Moreover, because they are all unique and limited, it is a good practice to use a <strong class="source-inline">switch ... case</strong> statement to handle each command and return a <strong class="source-inline">-ENOTTY</strong> error code when an undefined <strong class="source-inline">ioctl</strong> command is called. The following is an example:</p>
			<p class="source-code">#include "eep_ioctl.h"</p>
			<p class="source-code">static long eep_ioctl(struct file *f, unsigned int cmd,</p>
			<p class="source-code">                      unsigned long arg)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int part;</p>
			<p class="source-code">    char *buf = NULL;</p>
			<p class="source-code">    int size = 2048;</p>
			<p class="source-code">    switch(cmd){</p>
			<p class="source-code">        case EEP_ERASE:</p>
			<p class="source-code">            erase_eepreom();</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        case EEP_RENAME_PART:</p>
			<p class="source-code">            buf = kmalloc(MAX_PART_NAME, GFP_KERNEL);</p>
			<p class="source-code">            copy_from_user(buf, (char *)arg,</p>
			<p class="source-code">                            MAX_PART_NAME);</p>
			<p class="source-code">            rename_part(buf);</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        case EEP_GET_SIZE:</p>
			<p class="source-code">            if (copy_to_user((int*)arg,</p>
			<p class="source-code">                           &amp;size, sizeof(int)))</p>
			<p class="source-code">                return -EFAULT;</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        default:</p>
			<p class="source-code">            return –ENOTTY;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Both the kernel and user <a id="_idIndexMarker373"/>space must include the header files that contain the IOCTL commands. Therefore, in the first line of the preceding excerpt, we have included <strong class="source-inline">eep_ioctl.h</strong>, which is the header file where our IOCTL commands are defined.</p>
			<p>If you think your IOCTL command will need more than one argument, you should gather those arguments in a structure and just pass a pointer to the structure to <strong class="source-inline">ioctl</strong>.</p>
			<p>Now, from the user space, you must use the same <strong class="source-inline">ioctl</strong> header as in the driver's code:</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;fcntl.h&gt;</p>
			<p class="source-code">#include &lt;unistd.h&gt;</p>
			<p class="source-code">#include "eep_ioctl.h" /* our ioctl header file */</p>
			<p class="source-code">int main()</p>
			<p class="source-code">{</p>
			<p class="source-code">    int size = 0;</p>
			<p class="source-code">    int fd;</p>
			<p class="source-code">    char *new_name = "lorem_ipsum";</p>
			<p class="source-code">    fd = open("/dev/eep-mem1", O_RDWR);</p>
			<p class="source-code">    if (fd &lt; 0){</p>
			<p class="source-code">        printf("Error while opening the eeprom\n");</p>
			<p class="source-code">        return 1;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    /* ioctl to erase partition */</p>
			<p class="source-code">    ioctl(fd, EEP_ERASE);</p>
			<p class="source-code">    /* call to get partition size */</p>
			<p class="source-code">    ioctl(fd, EEP_GET_SIZE, &amp;size);</p>
			<p class="source-code">    /* rename partition */</p>
			<p class="source-code">    ioctl(fd, EEP_RENAME_PART, new_name);  </p>
			<p class="source-code">    close(fd);</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, we<a id="_idIndexMarker374"/> have demonstrated the use of kernel IOCTL commands from user space. That said, all throughout this section, we have learned how to implement the character device's <strong class="source-inline">ioctl</strong> callback and how to exchange data between the kernel and user space.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor080"/>Summary</h1>
			<p>In this chapter, we have demystified character devices, and we have seen how to let users interact with our driver through device files. We learned how to expose file operations to user space and control their behavior from within the kernel. We went so far that you are even able to implement multi-device support.</p>
			<p>The next chapter is a bit more hardware-oriented, as it deals with the device tree, a mechanism that allows hardware devices present on the system to be declared to the kernel. See you in the next chapter.</p>
		</div>
	</body></html>