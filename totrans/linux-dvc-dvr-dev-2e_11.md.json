["```\nCPU <--platform bus--> SPI master <---SPI bus---> SPI slave\n```", "```\nstruct spi_controller {\n    struct device     dev;\n    u16               num_chipselect;\n    u32               min_speed_hz;\n    u32               max_speed_hz;\n    int               (*setup)(struct spi_device *spi);\n    int (*set_cs_timing)(struct spi_device *spi,\n                          struct spi_delay *setup,\n                          struct spi_delay *hold,\n                          struct spi_delay *inactive);\n    int    (*transfer)(struct spi_device *spi,\n                         struct spi_message *mesg);\n    bool    (*can_dma)(struct spi_controller *ctlr,\n                        struct spi_device *spi,\n                        struct spi_transfer *xfer);\n    struct kthread_worker  *kworker;\n    struct kthread_work    pump_messages;\n    spinlock_t             queue_lock;\n    struct list_head       queue;\n    struct spi_message     *cur_msg;\n    bool                   busy;\n    bool                   running;\n    bool                   rt;\n    int (*transfer_one_message)(\n                      struct spi_controller *ctlr,\n                      struct spi_message *mesg);\n[...]\n    int (*transfer_one_message)(\n            struct spi_controller *ctlr,\n            struct spi_message *mesg);\n    void (*set_cs)(struct spi_device *spi, bool enable);\n    int (*transfer_one)(struct spi_controller *ctlr,\n                    struct spi_device *spi,\n                    struct spi_transfer *transfer);\n[...]\n    /* DMA channels for use with core dmaengine helpers */\n    struct dma_chan    *dma_tx;\n    struct dma_chan    *dma_rx;\n    /* dummy data for full duplex devices */\n    Void              *dummy_rx;\n    Void              *dummy_tx;\n};\n```", "```\ndev_set_name(&ctlr->dev, \"spi%u\", ctlr->bus_num);\n```", "```\nctlr->kworker = kthread_create_worker(0, dev_name(&ctlr->dev));\n```", "```\nroot@yocto-imx6:~# ps | grep spi\n65 root         0 SW   [spi1]\n```", "```\nstruct spi_device {\n    struct device dev;\n    struct spi_controller  *controller;\n    struct spi_master *master;\n    u32         max_speed_hz;\n    u8          chip_select;\n    u8          bits_per_word;\n    bool        rt;\n    u16         mode;\n    int          irq;\n    [...]\n    int cs_gpio; /* LEGACY: chip select gpio */\n    struct gpio_desc *cs_gpiod; /* chip select gpio desc */\n    struct spi_delay word_delay; /* inter-word delay */\n    /* the statistics */\n    struct spi_statistics statistics;\n};\n```", "```\n#define    SPI_CPHA    0x01\n#define    SPI_CPOL    0x02\n```", "```\nstruct spi_driver {\n   const struct spi_device_id *id_table;\n   int         (*probe)(struct spi_device *spi);\n   int         (*remove)(struct spi_device *spi);\n   void        (*shutdown)(struct spi_device *spi);\n   struct device_driver    driver;\n};\n```", "```\nstruct spi_transfer {\n    const void    *tx_buf;\n    void          *rx_buf;\n    unsigned    len;\n    dma_addr_t    tx_dma;\n    dma_addr_t    rx_dma;\n    struct sg_table tx_sg;\n    struct sg_table rx_sg;\n    unsigned    cs_change:1;\n    unsigned    tx_nbits:3;\n    unsigned    rx_nbits:3;\n#define    SPI_NBITS_SINGLE 0x01 /* 1bit transfer */\n#define    SPI_NBITS_DUAL        0x02 /* 2bits transfer */\n#define    SPI_NBITS_QUAD        0x04 /* 4bits transfer */\n    u8        bits_per_word;\n    u16       delay_usecs;\n    struct    spi_delay    delay;\n    struct spi_delay  cs_change_delay;\n    struct spi_delay  word_delay;\n    u32        speed_hz;\n    u32        effective_speed_hz;\n[...]\n    struct list_head transfer_list;\n#define SPI_TRANS_FAIL_NO_START  BIT(0)\n    u16        error;\n};\n```", "```\nstruct spi_message {\n       struct list_head     transfers;\n       struct spi_device    *spi;\n       unsigned       is_dma_mapped:1;\n       /* completion is reported through a callback */\n       void                 (*complete)(void *context);\n       void                 *context;\n       unsigned       frame_length;\n       unsigned       actual_length;\n       int                  status;\n    };\n```", "```\nvoid spi_message_init(struct spi_message *message)\n```", "```\nspi_message_add_tail(struct spi_transfer *t, struct spi_message *m)\n```", "```\nStatic int regmap_spi_gather_write(\n                    void *context, const void *reg,\n                    size_t reg_len, const void *val,\n                    size_t val_len)\n{\n    struct device *dev = context;\n    struct spi_device *spi = to_spi_device(dev);\n    struct spi_message m;\n    u32 addr;\n    struct spi_transfer t[2] = {\n      { .tx_buf = &addr, .len = reg_len, .cs_change = 0,},\n      { .tx_buf = val, .len = val_len, },\n    };\n    addr = TCAN4X5X_WRITE_CMD  |\n             (*((u16 *)reg) << 8) | val_len >> 2;\n    spi_message_init(&m);\n    spi_message_add_tail(&t[0], &m);\n    spi_message_add_tail(&t[1], &m);\n    return spi_sync(spi, &m);\n}\n```", "```\nstruct spi_message *spi_message_alloc(unsigned ntrans,\n                                      gfp_t flags)\nvoid spi_message_free(struct spi_message *m)\n```", "```\n/* Completion handler for async SPI transfers */\nstatic void my_complete(void *context)\n{\n    struct spi_message *msg = context;\n    /* doing some other stuffs */\n    […]\n    spi_message_free(m);\n}\nstatic int example_spi_async(struct spi_device *spi,\n              struct my_fake_spi_reg *cmds, unsigned len)\n{\n    struct spi_transfer *xfer;\n    struct spi_message *msg;\n    msg = spi_message_alloc(len, GFP_KERNEL);\n    if (!msg)\n         return -ENOMEM;\n    msg->complete = my_complete;\n    msg->context = msg;\n    list_for_each_entry(xfer, &msg->transfers,\n               transfer_list) {\n        xfer->tx_buf = (u8 *)cmds;\n        /* feel free to handle .rx_buf, and so on */\n        [...]\n        xfer->len = 2;\n        xfer->cs_change = true;\n         cmds++;\n    }\n    return spi_async(spi, msg);\n}\n```", "```\nint probe(struct spi_device *spi)\n```", "```\nint spi_setup(struct spi_device * spi)\n```", "```\n#define FAMILY_ID 0x57\nstatic int fake_probe(struct spi_device *spi)\n{\n    int err;\n    u8 id;\n    spi->max_speed_hz =\n               min(spi->max_speed_hz, DEFAULT_FREQ);\n    spi->bits_per_word = 8;\n    spi->mode = SPI_MODE_0;\n    spi->rt = true;\n    err = spi_setup(spi);\n    if (err)\n        return err;\n    /* read family id */\n    err = get_chip_version(spi, &id);\n    if (err)\n         return -EIO;\n    /* verify family id */\n    if (id != FAMILY_ID) {\n        dev_err(&spi->dev\"\n    \"chip family: expected 0x%02x but 0x%02x rea\"\\n\",\n               FAMILY_ID, id);\n          return -ENODEV;\n    }\n    /* register with other frameworks */\n    [...]\n    return 0;\n}\n```", "```\n#define REG_FAMILY_ID 0x2445\n#define DEFAULT_FREQ 10000000\nstatic int get_chip_version(spi_device *spi, u8 *id)\n{\n    struct spi_transfer t[2];\n    struct spi_message m;\n    u16 cmd;\n    int err;\n    cmd = REG_FAMILY_ID;\n    spi_message_init(&m);\n    memset(&t, 0, sizeof(t));\n    t[0].tx_buf = &cmd;\n    t[0].len = sizeof(cmd);\n    spi_message_add_tail(&t[0], &m);\n    t[1].rx_buf = id;\n    t[1].len = 1;\n    spi_message_add_tail(&t[1], &m);\n    return spi_sync(spi, &m);\n}\n```", "```\nstruct spi_device_id {\n   char name[SPI_NAME_SIZE];\n   kernel_ulong_t driver_data;\n};\n```", "```\n#define ID_FOR_FOO_DEVICE   0\n#define ID_FOR_BAR_DEVICE   1 \nstatic struct spi_device_id foo_idtable[] = {\n  \"{ \"\"oo\", ID_FOR_FOO_DEVICE },\n  \"{ \"\"ar\", ID_FOR_BAR_DEVICE },\n   { },\n};\nMODULE_DEVICE_TABLE(spi, foo_idtable);\n```", "```\nstatic const struct of_device_id foobar_of_match[] = {\n        { .compatible\"= \"packtpub,foobar-dev\"ce\" },\n        { .compatible\"= \"packtpub,barfoo-dev\"ce\" },\n        {},\n};\nMODULE_DEVICE_TABLE(of, foobar_of_match);\n```", "```\nstatic struct spi_driver foo_driver = {\n    .driver         = {\n        .name  \"= \"\"oo\",\n        /* The below line adds Device Tree support */\n        .of_match_table = of_match_ptr(foobar_of_match),\n    },\n    .probe          = my_spi_probe,\n    .id_table       = foo_idtable,\n};\n```", "```\nstatic int remove(struct spi_device *spi)\n```", "```\nstatic int mc33880_remove(struct spi_device *spi)\n{\n    struct mc33880 *mc;\n    mc = spi_get_drvdata(spi); /* Get our data back */\n    if (!mc)\n        return -ENODEV;\n    /*\n     * unregister from frameworks with which we\n     * registered in the probe function\n     */\n    gpiochip_remove(&mc->chip);\n    [...]\n    /* releasing any resource */\n    mutex_destroy(&mc->lock);\n    return 0;\n}\n```", "```\nint spi_register_driver(struct spi_driver *sdrv);\nvoid spi_unregister_driver(struct spi_driver *sdrv);\n```", "```\nstatic int __init foo_init(void)\n{\n   [...] /*My init code */\n   return spi_register_driver(&foo_driver);\n}\nmodule_init(foo_init);\nstatic void __exit foo_cleanup(void)\n{\n   [...] /* My clean up code */\n   spi_unregister_driver(&foo_driver);\n}\nmodule_exit(foo_cleanup);\n```", "```\nmodule_spi_driver(foo_driver);\n```", "```\necspi1 {\n    fsl,spi-num-CSs = <3>;\n    cs-gpios = <&gpio5 17 0>, <&gpio5 17 0>, <&gpio5 17 0>;\n    pinctrl-0 = <&pinctrl_ecspi1 &pinctrl_ecspi1_cs>;\n    #address-cells = <1>;\n    #size-cells = <0>;\n    compatible\"= \"fsl,imx6q-ec\"pi\", \"fsl,imx51-ec\"pi\";\n    reg = <0x02008000 0x4000>;\n    status\"= \"o\"ay\";\n    ad7606r8_0: ad7606r8@0 {\n        compatible\"= \"ad760\"-8\";\n        reg = <0>;\n        spi-max-frequency = <1000000>;\n        interrupt-parent = <&gpio4>;\n        interrupts = <30 0x0>;\n   };\n   label: fake_spi_device@1 {\n        compatible\"= \"packtpub,foobar-dev\"ce\";\n        reg = <1>;\n        a-string-param\"= \"stringva\"ue\";\n        spi-cs-high;\n   };\n   mcp2515can: can@2 {\n        compatible\"= \"microchip,mcp2\"15\";\n        reg = <2>;\n        spi-max-frequency = <1000000>;\n        clocks = <&clk8m>;\n        interrupt-parent = <&gpio4>;\n        interrupts = <29 IRQ_TYPE_LEVEL_LOW>;\n    };\n};\n```", "```\n&ecspi2 {\n    pinctrl-names\"= \"defa\"lt\";\n    pinctrl-0 = <&pinctrl_teoulora_ecspi2>;\n    cs-gpios = <&gpio2 26 1\n                &gpio2 27 1>;\n    num-cs = <2>;\n    status\"= \"o\"ay\";\n    spidev@0 {\n        reg = <0>;\n        compatib\"e=\"semtech,sx1\"01\";\n        spi-max-frequency = <20000000>;\n    };\n};\n```", "```\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\nint main(int argc, char **argv) \n{\n   int i,fd;\n   char *device = \"/dev/spidev0.0\";\n   char wr_buf[]={0xff,0x00,0x1f,0x0f};\n   char rd_buf[10]; \n\n   fd = open(device, O_RDWR);\n   if (fd <= 0) { \n         printf(\"Failed to open SPI device %s\\n\", device);\n         exit(1);\n   }\n\n   if (write(fd, wr_buf, sizeof(wr_buf)) != sizeof(wr_buf))\n         perror(\"Write Error\");\n   if (read(fd, rd_buf, sizeof(rd_buf)) != sizeof(rd_buf))\n         perror(\"Read Error\");\n   else\n         for (i = 0; i < sizeof(rd_buf); i++)\n             printf(\"0x%02X \", rd_buf[i]);\n   close(fd);\n   return 0;\n}\n```", "```\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/* include required headers, listed early in the section */\n[...]\nstatic int pabort(const char *s)\n{\n    perror(s);\n    return -1;\n}\nstatic int spi_device_setup(int fd)\n{\n    int mode, speed, a, b, i;\n    int bits = 8;\n    /* spi mode: mode 0 */\n    mode = SPI_MODE_0;\n    a = ioctl(fd, SPI_IOC_WR_MODE, &mode); /* set mode */\n    b = ioctl(fd, SPI_IOC_RD_MODE, &mode); /* get mode */\n    if ((a < 0) || (b < 0)) {\n        return pabort(\"can't set spi mode\");\n    }\n    /* Clock max speed in Hz */\n    speed = 8000000; /* 8 MHz */\n    a = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed); /* set */\n    b = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed); /* get */\n    if ((a < 0) || (b < 0))\n        return pabort(\"fail to set max speed hz\");\n    /*\n     * Set SPI to MSB first.\n     * Here, 0 means \"not to use LSB first\".\n     * To use LSB first, argument should be > 0\n     */\n    i = 0;\n    a = ioctl(dev, SPI_IOC_WR_LSB_FIRST, &i);\n    b = ioctl(dev, SPI_IOC_RD_LSB_FIRST, &i);\n    if ((a < 0) || (b < 0))\n        pabort(\"Fail to set MSB first\\n\");\n\n    /* setting SPI to 8 bits per word */\n    bits = 8;\n    a = ioctl(dev, SPI_IOC_WR_BITS_PER_WORD, &bits); /* set */\n    b = ioctl(dev, SPI_IOC_RD_BITS_PER_WORD, &bits); /* get */\n    if ((a < 0) || (b < 0))\n        pabort(\"Fail to set bits per word\\n\");\n\n    return 0;\n}\n```", "```\nstatic void do_transfer(int fd)\n{\n    int ret;\n    char txbuf[] = {0x0B, 0x02, 0xB5};\n    char rxbuf[3] = {0, };\n    char cmd_buff = 0x9f;\n    struct spi_ioc_transfer tr[2] = {\n        0 = {\n          .tx_buf = (unsigned long)&cmd_buff,\n          .len = 1,\n          .cs_change = 1;    /* We need CS to change */\n          .delay_usecs = 50, /* wait after this transfer */\n          .bits_per_word = 8,\n        },\n        [1] = {\n          .tx_buf = (unsigned long)tx,\n          .rx_buf = (unsigned long)rx,\n          .len = txbuf(tx),\n          .bits_per_word = 8,\n        },\n    };\n    ret = ioctl(fd, SPI_IOC_MESSAGE(2), &tr);\n    if (ret == 1){\n        perror(\"can't send spi message\");\n        exit(1);\n    }\n    for (ret = 0; ret < sizeof(tx); ret++)\n        printf(\"%.2X \", rx[ret]);\n    printf(\"\\n\");\n}\n```", "```\nint main(int argc, char **argv)\n{\n    char *device = \"/dev/spidev0.0\";\n    int fd;\n    int error;\n    fd = open(device, O_RDWR);\n    if (fd < 0)\n        return pabort(\"Can't open device \");\n    error = spi_device_setup(fd);\n    if (error)\n        exit (1);\n\n    do_transfer(fd);\n\n    close(fd);\n    return 0;\n}\n```"]