- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Virtual Machines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about **virtual machines** (**VMs**) on Linux.
    For starters, you will learn how virtualization works and how to create and use
    VMs. You will learn about one of the most widely used virtualization and hypervisor
    technologies on Linux, called **Kernel-based Virtual Machine** (**KVM**). The
    topics in this chapter will prepare you for the future of Linux, as it is the
    foundation of every modern cloud technology. If you wish to remain up to date
    in a constantly changing landscape, this chapter will be an essential starting
    point for your journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to virtualization on Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Linux KVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with basic KVM commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced KVM management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning VMs using cloud-init
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public key authentication with SSH
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No special technical requirements are needed, just a working installation of
    Linux on your system. We will mainly use Debian GNU/Linux 12 for our examples,
    but we will also show you how to install KVM in Fedora and openSUSE.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to virtualization on Linux
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Virtualization** is a way to make more efficient use of computer hardware.
    It is basically an abstraction layer that takes advantage of the computer’s resources.
    In this section, you will learn about the types of VMs, how they work on Linux,
    and how to deploy and manage them.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency in resource usage
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstraction layer that virtualization uses is a software layer that allows
    more efficient use of all the computer’s components. This in turn allows better
    use of all the physical machine’s capabilities and resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further into virtualization, let’s give you an example. In
    our testing laboratory, we have several physical machines, in the form of laptops
    and small form factor desktop computers (Intel NUCs) that we use as servers. Each
    of the systems has significant resources available, more than enough to run the
    services we need. For instance, our least performant systems are a 5th-generation
    Intel NUC with an Intel i3 CPU with four processing cores and 16 GB of RAM and
    a 7th-generation Intel NUC with a four-core Intel Pentium and 12 GB of RAM. Those
    two systems have plenty of resources that could be more efficiently used by using
    VMs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: For running a local web service or any kind of server on our local network,
    those resources can be split between various VMs with ease. For example, each
    physical system could host four different VMs, each using a single CPU core, and
    at least 2 GB of memory and all the necessary storage capacities. This way, one
    single machine will work as if there were four different ones. This is way more
    efficient than using individual machines for separate tasks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we are comparing the load on a single computer versus
    the same load divided between several VMs. This way of using the same hardware
    resources is more efficient:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Comparison between single computer use and using multiple VMs](img/B19682_11_1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Comparison between single computer use and using multiple VMs
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, as we will use the hypervisor on top of a host OS, we will have
    to keep some resources for the OS’s use, so the number of VMs will be smaller.
    Here is a diagram of how the VMs work on a host OS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – How virtualization works on a host OS](img/B19682_11_2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – How virtualization works on a host OS
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the scheme of how virtualization works when used
    on a host OS. As we will see in the following sections, it is not the only type
    of virtualization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that efficiency is not related solely to the hardware
    resources used. A significant aspect of the efficient use of hardware in data
    centers is related to increased energy efficiency and a reduction of the carbon
    footprint. In this respect, virtualization has played a major role for many decades
    in changing the usage patterns of servers inside data centers. Overall, virtualization
    and containerization are significant players in the fight against climate change.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will give you a short introduction to hypervisors
    and VMs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to hypervisors
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The software layer that virtualization is based on is called a **hypervisor**.
    The physical resources are divided and used as virtual computers, better known
    as VMs. By using VMs, the limits of physical hardware are overcome by the process
    of **emulation**. This has a lot of advantages, enabling the hardware to be used
    more effectively.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The process of emulation is basically an imitation process through which a piece
    of software replicates (or imitates) the functions of another system. In our case,
    the hypervisor (the virtualization software layer) is simulating the use of hardware
    as if it were a different system altogether. This allows the hardware resources
    a computer has to be used more effectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Hypervisors can be used either on top of an existing OS (*type 2*) or directly
    on bare metal (hardware) (*type 1*). For each of these types, there are various
    solutions that can be used, particularly on Linux. For a Linux OS, examples of
    each type are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Examples of hypervisors that run on top of a host OS (type 2) are Oracle VirtualBox
    and VMware Workstation/Fusion
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of hypervisors that run directly on bare metal (type 1) are Citrix
    Xen Server and VMware ESXi
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KVM is mostly classified as a bare-metal hypervisor (type 1), while its underlying
    system is a full OS, thus it is classified as a host hypervisor at the same time
    (type 2)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will exclusively use KVM as the hypervisor of choice.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux KVMs
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A VM is similar to a standalone computer. It is a software-based emulator that
    has access to the host computer’s resources. It uses the host’s CPU, RAM, storage,
    networking interface(s), and ports. Not only that, but it is a virtual environment
    that has the same functions as a physical computer; it is also seen as a virtual
    computer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机类似于一台独立的计算机。它是一种基于软件的模拟器，可以访问宿主计算机的资源。它使用宿主计算机的 CPU、内存、存储、网络接口和端口。不仅如此，它还是一个具有与物理计算机相同功能的虚拟环境；也被视为一台虚拟计算机。
- en: The resources for each VM are managed by the hypervisor. It can relocate resources
    between existing VMs or create new VMs. The VMs are isolated from each other and
    from the host computer. As multiple VMs can exist on a single computer, each VM
    can use different guest OSes. For example, if you use a Windows machine and want
    to try out Linux, a popular solution would be to create a VM with the Linux distribution
    that you want to try. The same goes for Mac users, too. An OS installed inside
    a VM runs similarly to an OS installed on bare metal. The user experience could
    vary from one hypervisor to the other, and so could the resource efficiency and
    response times. From our experience, we prefer running VMs from KVM rather than
    running from any other hypervisor, mainly because of the comprehensive **command-line
    interface** (**CLI**). However, use cases could be different from one user to
    another.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟机的资源由虚拟化技术管理。它可以在现有虚拟机之间重新分配资源或创建新的虚拟机。虚拟机之间相互隔离，并与宿主计算机隔离。由于多个虚拟机可以存在于一台计算机上，每个虚拟机可以使用不同的客户操作系统。例如，如果你使用的是
    Windows 计算机并想尝试 Linux，一个流行的解决方案是创建一个虚拟机来运行你想尝试的 Linux 发行版。Mac 用户也是一样。安装在虚拟机中的操作系统与直接安装在硬件上的操作系统运行方式相似。用户体验可能因虚拟化技术的不同而有所不同，资源效率和响应时间也可能不同。根据我们的经验，我们更倾向于使用
    KVM 来运行虚拟机，而不是使用其他虚拟化技术，主要因为其全面的**命令行界面**（**CLI**）。不过，使用场景因用户不同而有所不同。
- en: Choosing the hypervisor
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择虚拟化技术
- en: In this chapter, we chose the KVM hypervisor. As an optional solution, if you
    use the GNOME desktop environment, you will have access to GNOME Boxes. As both
    KVM and GNOME Boxes are directly available from Linux repositories, we consider
    them to be the better solutions for newcomers to Linux. Both KVM and GNOME Boxes
    share parts of `libvirt` and `qemu` code (to be detailed in the next section),
    and in this respect, we consider them to both be the same hypervisor, which is
    KVM.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们选择了 KVM 虚拟化技术。作为一个可选方案，如果你使用 GNOME 桌面环境，你可以使用 GNOME Boxes。由于 KVM 和 GNOME
    Boxes 都可以直接从 Linux 仓库获取，我们认为它们是 Linux 新手的较好选择。KVM 和 GNOME Boxes 共享部分 `libvirt`
    和 `qemu` 代码（将在下一节详细介绍），在这方面，我们认为它们都是相同的虚拟化技术，即 KVM。
- en: In [*Chapter 1*](B19682_01.xhtml#_idTextAnchor030), *Installing Linux*, you
    first encountered the use of a hypervisor to set up a Linux VM. We showed you
    how to use VMware solutions and VirtualBox to set up a Linux VM. The details used
    then should be sufficient for any user, whether they are experienced or a newbie.
    VirtualBox has several features that make it a fair candidate for your hypervisor
    solution, but in our opinion, it still lacks the finesse of KVM. In the next section,
    we will walk you through KVM.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B19682_01.xhtml#_idTextAnchor030)，*安装 Linux* 中，你第一次接触了使用虚拟化技术来设置
    Linux 虚拟机的方式。我们展示了如何使用 VMware 解决方案和 VirtualBox 来设置 Linux 虚拟机。那时提供的细节对于任何用户来说都应该足够，无论他们是经验丰富的用户还是新手。VirtualBox
    具有一些功能，使其成为虚拟化技术的一个不错的选择，但在我们看来，它仍然缺乏 KVM 的精细度。在下一节中，我们将带你深入了解 KVM。
- en: Using the KVM hypervisor
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 KVM 虚拟化技术
- en: The KVM hypervisor is an open source virtualization project available on all
    major Linux distributions. It is a modern hypervisor that uses specific kernel
    modules to take advantage of all the benefits that the Linux kernel has to offer,
    including memory support, scheduler, nested virtualization, GPU pass-through,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: KVM 是一个开源虚拟化项目，适用于所有主要的 Linux 发行版。它是一种现代虚拟化技术，使用特定的内核模块来充分利用 Linux 内核所提供的所有优势，包括内存支持、调度器、嵌套虚拟化、GPU
    直通等。
- en: KVM in detail – QEMU and libvirt
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: KVM 详细介绍 – QEMU 和 libvirt
- en: KVM uses `libvirt`. The KVM’s interface with `libvirt`, specifically in GNOME,
    is `virt-manager`. The CLI for `libvirt` is called `virsh`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: KVM 使用 `libvirt`。KVM 与 `libvirt` 的接口，特别是在 GNOME 中，是 `virt-manager`。`libvirt`
    的命令行界面（CLI）叫做 `virsh`。
- en: The `libvirt` API provides a common library for managing VMs. It is the management
    layer for VM creation, modification, and provision. It is running in the background
    as a daemon called `libvirtd` that manages the connections with the hypervisor
    at the client’s request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: QEMU is both an emulator and a virtualizer. When used as an emulator, QEMU uses
    **dynamic binary translation** methods to operate. This means that it can use
    different types of OS on the host machine, even if they are designed for different
    architectures. Dynamic binary translations are used in **software-based virtualization**,
    where hardware is emulated to execute instructions in virtualized environments.
    This way, QEMU emulates the machine’s CPU, using a specific binary translator
    method called **Tiny Code Generator** (**TCG**), which transforms the binary code
    for different types of architectures.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'When used as a virtualizer, QEMU uses what is known as a **hardware-based virtualization**,
    where the binary translation is not used, because the instructions are executed
    directly on the host CPU. The differences between software- and hardware-assisted
    virtualization are shown in the following diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Comparison between software- and hardware-assisted virtualization](img/B19682_11_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Comparison between software- and hardware-assisted virtualization
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the diagram, instructions have different paths when using
    software- and hardware-assisted virtualization. In software-assisted virtualization,
    when dynamic binary translations are used, the user’s unprivileged instructions
    are sent directly to the hardware, while the guest OS privileged instructions
    are first sent to the hypervisor before getting to the hardware. In hardware-assisted
    virtualization, the user’s unprivileged instructions are sent to the hypervisor
    first, and then sent to the hardware, while the privileged instructions from the
    guest OS have the same path as in software-assisted virtualization. This ensures
    a certain level of isolation for the guest OS, thereby achieving better performance
    and less complexity.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will show you how to install and configure QEMU
    on a Debian 12 machine. We consider Debian to be a sufficiently lightweight distribution,
    offering the necessary stability for a virtualization host OS. Some commands can
    be replicated on Ubuntu as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Installing the hypervisor on major Linux distributions
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installing QEMU is a straightforward task. All you need to do is to run the
    package installer utility of your distribution, with some specified package names.
    In our case, we will show you how to install it on major Linux distributions such
    as Debian/Ubuntu, Fedora, and openSUSE:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing on** **Debian/Ubuntu Linux**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Installing on** **Fedora Linux**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Installing on** **openSUSE Linux**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following commands:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once all the necessary packages are installed, you can enable and start the
    `libvirtd` daemon with the following commands (valid for all Linux distributions
    showcased in this section):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the packages are installed and the daemon is started and enabled, a safe
    action to take is to check whether your machine is compatible with KVM requirements.
    To do this, use the `virt-host-validate` command as a root user or by using `sudo`.
    We are running the command on a Debian GNU/Linux 12 host, but it can be used on
    other Linux distributions as well:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once the command is running, you may receive a couple of errors or warnings
    regarding QEMU or **Linux Containers** (**LXC**) – which is a technology used
    to run isolated systems, similar to how KVM works – depending on your system (there’s
    more on LXC in [*Chapter 12*](B19682_12.xhtml#_idTextAnchor257)). In our case,
    the output shows one error regarding LXC compatibility, as shown in the following
    screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Running the host validation program](img/B19682_11_4.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Running the host validation program
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: However, this error will not limit our use of `libvirt` and QEMU, so we do not
    intend to resolve it here.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: After seeing that there are no compatibility issues regarding QEMU, we can proceed
    to creating our first VM using the CLI. Thus, we will start using KVM-specific
    commands.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Working with basic KVM commands
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first commands that you will use when working with KVM is the one
    used for creating a VM. Other commands, as shown in the following sections, are
    the ones used to start, stop, delete, or pause an already existing VM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Creating a VM using the command line
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before creating our first VM using `libvirt`, we must check and see whether
    our default bridge network configuration was created. We can verify this by using
    the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command shows if the default bridge configuration was created and if it
    is running. In our case, the bridge connection is not running, thus we will need
    to set it up ourselves. The command used to start the default bridge network is
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once it has been started, the network bridge is not set up for automatic start,
    thus we will use the following command to set it for automatic start:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, the output is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Enabling the default bridge connection](img/B19682_11_5.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Enabling the default bridge connection
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the default bridge connection has been enabled and set for `autostart`,
    we can create our first VM. In order to create a VM, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to download the image file of the OS to use inside the
    VM. For our example, we will create a new VM with Ubuntu 22.04.2 LTS server edition.
    We can download the ISO image with the following command:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the Ubuntu image is downloaded, we will use the `virt-install` command
    to create the first VM on our host system. We will create one VM that will use
    a single `virt-install` command used is the following (run as root):'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`--name`: The name of the new VM'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--memory`: The amount of RAM used by the VM'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--vcpus`: The number of virtual CPUs used by the new VM'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--disk size`: The amount of storage used'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--os-variant`: The type of guest OS'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--network`: The bridge network used'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--cdrom`: The location of the guest OS ISO file'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command will start a new `virt-viewer` window, which will start the OS installation
    process. Similarly, by using the command with the `–graphics=vnc` argument, `virt-install`
    will start `virt-viewer`, which is the default tool for displaying the graphical
    console using the VNC protocol.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Simply knowing how to create a VM is not sufficient for a system administrator.
    This is why, in the next section, we will show you some basic VM management tools
    to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Basic VM management
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic VM tasks can be done using the `virsh` command when using the CLI,
    or Virtual Machine Manager when using a graphical user interface. In the following,
    we will show you the basic commands to use while inside a CLI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the existing VM guests, use the `virsh` `list` command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Be aware that listing the VMs cannot be done by just anyone. This is why the
    following note needs to be considered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: When trying to list the existing guest VMs, you will not get a valid output
    when using a regular user. You will need to be logged in as `root` or use `sudo`
    to see the list of VMs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows some basic commands used to manage VMs, together
    with their output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Commands for VM management](img/B19682_11_6.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Commands for VM management
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a short explanation of the commands you see in the preceding figure.
    To change the state of a VM, such as starting, stopping, and pausing, use the
    following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo virsh` `destroy ubuntu-vm1`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo virsh` `reboot ubuntu-vm1`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo virsh` `suspend ubuntu-vm1`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo virsh` `start ubuntu-vm1`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo virsh` `resume ubuntu-vm1`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo virsh` `undefine ubuntu-vm1`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all the options available for `virsh`, please refer to the manual pages
    using the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The command-line tools for managing VMs are powerful and offer various options.
    If we consider the fact that, most of the time, a system administrator will be
    using the CLI rather than the GUI, the ability to use command-line tools is of
    the utmost importance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will show you some advanced KVM management practices.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Advanced KVM management
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using KVM is so much more than just creating VMs and starting or stopping them.
    VM management can be much more complex, starting with VM automated installation,
    storage and resources management, and up to VM orchestration. Some of these topics
    are out of the scope of this book, but we will still show you how to master your
    VMs on your Linux-powered systems.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, we only have one VM. For the purpose of the exercises in this section,
    we will create two more VMs, all running the same Ubuntu OS that we used for the
    first VM. We will create `ubuntu-vm2` and `ubuntu-vm3` VMs using the following
    commands:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'For `ubuntu-vm2`:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: sudo virt-install --virt-type=kvm --name ubuntu-vm3 --vcpus=2 --memory=2048
    --os-variant=ubuntufocal --cdrom=/var/lib/libvirt/images/ubuntu-22.04.2-live-server-amd64.iso
    --network=default --disk size=20 --noautoconsole
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we have three VMs running on our system and we can begin managing them.
    In the next section, we will show you how to find out the IP of a VM and how to
    connect to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a VM
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, we would like to connect to a running VM from a terminal and
    not use the integrated console provided by the VM manager. In order to be able
    to do this, we will need to know the VM’s IP address. A simple run of the `ip
    neighbor` command will show us all the IP addresses on our local network, but
    this will not provide the relevant information we need, such as the VM’s name.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'On our system, when running the `ip neighbor` command, the output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Viewing the IP addresses on the local network](img/B19682_11_7.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Viewing the IP addresses on the local network
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output, we can see that three of the IP addresses are from the default
    virtual network that is set up by KVM (`virbr0`). This is the first information
    that tells us the IP addresses used by our VMs. But which IP is which VM? To find
    out more information, we will use the following commands:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command is used to list all the existing VMs. The output (as
    seen in *Figure 11**.8*) shows the names of the VMs. In order to see the IP addresses
    associated with each one, we will use the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `[vm name]` represents one of the VM names from the `virsh list` command’s
    output. In the following screenshot, you can see the output of the previous commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Showing the IP addresses for VMs](img/B19682_11_8.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Showing the IP addresses for VMs
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the IP addresses of every VM we created, we can connect to
    any of the VMs using SSH (more on installing and configuring SSH in [*Chapter
    13*](B19682_13.xhtml#_idTextAnchor276)). Considering that we already have openSSH
    installed on both our host system and the target VM, the simplest way to connect
    using SSH is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the previous command, we used the `ssh` command, we specified the user (in
    our case `packt`) and the IP address of the VM (in our case, `192.168.122.129`,
    which is `ubuntu-vm1` that we created earlier). The prompt (as shown in the following
    figure) asks you for confirmation, saves the key to the list of known hosts, and
    then connects you to the machine:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Connect to a VM through SSH](img/B19682_11_9.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Connect to a VM through SSH
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to connect to a VM is by using the `virt-viewer` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This command will open a new console window using the `virt-viewer` utility
    and connect to the VM you specify (in our case, `ubuntu-vm1` again) without using
    the SSH protocol:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用`virt-viewer`工具打开一个新的控制台窗口，并连接到您指定的虚拟机（在我们的案例中，仍然是`ubuntu-vm1`），而无需使用SSH协议：
- en: '![Figure 11.10 – Connecting to VM using virt-viewer](img/B19682_11_10.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – 使用virt-viewer连接虚拟机](img/B19682_11_10.jpg)'
- en: Figure 11.10 – Connecting to VM using virt-viewer
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 使用virt-viewer连接虚拟机
- en: Important note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The connection remains active inside the terminal where you initiated the command.
    Thus, if you press *Ctrl* + *C*, the connection will be terminated and the new
    console window will close. Take into consideration that only the connection will
    be terminated and the VM will still be running.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 连接在您发起命令的终端内保持活动状态。因此，如果您按*Ctrl* + *C*，连接将被终止，新的控制台窗口将关闭。请注意，只有连接会被终止，而虚拟机仍然会继续运行。
- en: 'We have shown you how to use the command line to create VMs, for basic management,
    and to connect to a virtual machine. However, you can also use GUI tools. All
    modern Linux distributions that use GNOME as the desktop environment will offer
    at least two useful tools: the Virtual Machine Manager and GNOME Boxes. The former
    is simply the GUI for `libvirt`, and the latter is a new and simple way to provision
    VMs for immediate use inside GNOME based on QEMU/KVM technology. We will let you
    discover these GUI tools as they are pretty straightforward and not difficult
    to use. You could start creating new VMs using the Virtual Machine Manager. In
    the next section, we will show you how to clone VMs.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用命令行创建虚拟机、进行基本管理以及连接虚拟机。然而，您也可以使用GUI工具。所有现代Linux发行版，如果使用GNOME作为桌面环境，都至少会提供两个有用的工具：虚拟机管理器和GNOME
    Boxes。前者只是`libvirt`的GUI，而后者是基于QEMU/KVM技术，在GNOME环境中即时创建虚拟机的简易方式。我们将让您自己探索这些GUI工具，因为它们非常直观，不难使用。您可以开始使用虚拟机管理器创建新的虚拟机。在下一节中，我们将展示如何克隆虚拟机。
- en: Cloning VMs
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆虚拟机
- en: We have already created three different VMs on our host system. However, there
    are times when you might want to clone an existing VM instead of creating a new
    one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在主机系统上创建了三个不同的虚拟机。然而，有时您可能希望克隆现有的虚拟机，而不是创建新的虚拟机。
- en: 'Before starting to clone a VM, we need to stop or suspend it. We will do this
    using the `suspend` or the `shutdown` commands. We will stop one of our VMs, as
    shown:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始克隆虚拟机之前，我们需要停止或挂起它。我们将使用`suspend`或`shutdown`命令来执行此操作。我们将停止其中一台虚拟机，如下所示：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This command will shut down the `ubuntu-vm1` VM. In order to clone it, we will
    use the `virt-clone` command. Let’s say that we want to name the clone `ubuntu-vm1-clone1`.
    We will use the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将关闭`ubuntu-vm1`虚拟机。为了克隆它，我们将使用`virt-clone`命令。假设我们想将克隆命名为`ubuntu-vm1-clone1`。我们将使用以下命令：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the command is shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![Figure 11.11 – Cloning virtual machines using virt-clone](img/B19682_11_11.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – 使用virt-clone克隆虚拟机](img/B19682_11_11.jpg)'
- en: Figure 11.11 – Cloning virtual machines using virt-clone
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 使用virt-clone克隆虚拟机
- en: Now that the clone has been created, we can start it using the `virsh start`
    command. Cloning a VM will also *transfer* all the original VM’s configuration
    regarding the number of vCPUs, RAM, bridge networking configuration, the same
    MAC address, and even the same IP address. This can become a real headache and
    needs to be solved.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在克隆已经创建，我们可以使用`virsh start`命令启动它。克隆虚拟机还会*传输*所有原虚拟机的配置，包括vCPU数量、内存、桥接网络配置、相同的MAC地址，甚至相同的IP地址。这可能会成为一个真正的麻烦，需要解决。
- en: One way to solve this is to directly connect to the VM’s console (not through
    SSH) and run the `ip addr show` command. This will enable the DHCP client to automatically
    assign an IP address to the host. In the next section, we will show you another
    useful way to manage cloning with VM templates.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种方法是直接连接到虚拟机的控制台（不是通过SSH）并运行`ip addr show`命令。这将使DHCP客户端自动为主机分配IP地址。在下一节中，我们将展示另一种使用虚拟机模板管理克隆的有效方法。
- en: Creating VM templates
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虚拟机模板
- en: Another useful way to overcome the issue described in the previous section is
    to first create a VM template before cloning. By creating a template, you make
    sure that all the configuration files will not persist, including MAC and IP configuration,
    user settings, or SSH host keys.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 解决上一节中描述的问题的另一种有效方法是在克隆之前先创建虚拟机模板。通过创建模板，您可以确保所有配置文件不会持久化，包括MAC和IP配置、用户设置或SSH主机密钥。
- en: 'To create a template, follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `virt-sysprep` utility. In Debian 12, we will install the `libguestfs-tools`
    utility, which contains the `virt-sysprep`, using the following command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that the utility is installed, we will use it to create a template. But
    first, we will create a new VM running Ubuntu and use it as a template. We will
    use the following command to create the new VM:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After finishing the OS installation, make sure that it is up to date with all
    the available packages.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Proceed only after ensuring that the VM is turned off. As a precautionary method,
    you could first copy the file with a different name:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'virt-sysprep command is preparing the VM by resetting all the configuration
    files that might have been created. The following is an excerpt from the output:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 11.12 – Creating a template with virt-sysprep](img/B19682_11_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Creating a template with virt-sysprep
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the template is prepared, you can do either of the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Undefine the domain by using the `virsh undefine` command. This command removes
    the configuration of the VM but leaves the `qcow2` file that it created so that
    you could use it when creating a new VM.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the VM (in our case, the one named `ubuntu-template`) and use it as a clone
    template, as intended.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice is yours, but we are inclined towards the second option, as it is
    already configured and thus is much easier to use. When using only the `qcow2`
    file, you still have to configure (setting CPUs, RAM, networking, etc.) the VM
    prior to using it.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you know how to clone a VM and how to create templates, let’s see other
    ways to manage VMs. In the next section, we will show you how to obtain information
    about the VMs you work with, from the command line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining VM and host resource information
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re working at the command line, some information is not as visible
    as when working with the GUI tools. To see if we still have the necessary sources
    for creating new VMs, we will need to use the `virsh nodeinfo` command to obtain
    information about the host machine:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Finding host information with the nodeinfo command](img/B19682_11_13.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Finding host information with the nodeinfo command
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, as seen in the preceding image, the host has 16 vCPUs available
    and 48 GB of RAM, meaning that we still have resources available for some new
    VMs. We know that when we created the VMs we allocated 2 vCPUs and 2 GB of RAM
    for each one. As we now have five VMs (as shown in the following image), it means
    that we use 10 out of 16 vCPUs and 10 GB out of 48 GB RAM:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Listing the existing VMs](img/B19682_11_14.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Listing the existing VMs
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we do not know how many resources the existing VMs use? There is
    a command that can help us with that. It is called `virsh dominfo`. Let’s see
    the resources that one of our VMs is using, for example, `ubuntu-vm1`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Showing the VMs’ resource usage](img/B19682_11_15.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Showing the VMs’ resource usage
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding image, you can see that our VM is using 2 vCPUs and 2 GB of
    RAM. You can check the resource usage for every VM that you manage. Besides vCPUs
    and RAM, you can also manage virtual disks for existing VMs. To see the disk usage
    for a VM you can use the `virt-df` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Showing disk usage for a VM](img/B19682_11_16.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Showing disk usage for a VM
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `-d` option for showing `libvirt` domain guests and the `-h`
    option to show the results in a human-readable format. The `virt-df` command is
    similar to the `df` command (see [*Chapter 6*](B19682_06.xhtml#_idTextAnchor124)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the resource usage is the first step in managing the resources that
    you have. In the following section, we will show you how to change the amount
    of resources a VM is using.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Managing VM resource usage
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As shown earlier, knowing how many resources a VM is using can prove of great
    value. You would need to be able to modify the resources already in use if you
    run out of resources. You have tools available to modify the amount of vCPUs and
    RAM an existing VM is using. For example, let’s change the resources for our `ubuntu-vm1-clone1`
    VM from 2 vCPUs to 1 vCPU and from 2 GB of RAM to 1 GB of RAM. The command we
    will use is `virsh setvcpus`, and we will use it as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Changing the vCPU count for a VM](img/B19682_11_17.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Changing the vCPU count for a VM
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change the amount of RAM used with the `virsh setmem` and `virsh`
    `setmaxmem` commands:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Changing the memory used by a VM](img/B19682_11_18.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Changing the memory used by a VM
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now check the resources used by the `ubuntu-vm1-clone1` VM using the
    `virsh dominfo` command, as shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Checking the resources for a VM](img/B19682_11_19.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Checking the resources for a VM
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the resources used by the VM have been changed according to
    your new settings. Now that you know how to manage KVMs, which is a required asset
    for a Linux system administrator. In the next section, we will show you how to
    automate KVM VM provisioning using **cloud-init**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning VMs using cloud-init
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re dealing with only one VM, things can be relatively simple. But when
    we have to create hundreds of VMs, manual creation can be daunting. One useful
    tool you can use for such a task is **cloud-init**. Another tool that is suitable
    for this kind of task is **Ansible** (there’s more on Ansible in [*Chapter 17*](B19682_17.xhtml#_idTextAnchor359)).
    In this section, we will cover only cloud-init. It was developed by Canonical
    to be used as a tool for configuring VM instances on cloud platforms, and it is
    written in Python. Currently, it is considered an industry standard for provisioning
    cloud images. In the next subsection, we will briefly explain to you how cloud-init
    works.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how cloud-init works
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the official cloud-init documentation, it is based on several configuration
    sources, specific boot stages, user data formats, vendor data, and instance metadata.
    The concept of boot stages is specific to cloud-init architecture, as it configures
    the entire instance during specific stages of the boot process. It provides a
    way for managing completely working instances that have networking, boot sequence,
    and local configuration files configured.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-init is available on most widely used Linux distributions, such as Ubuntu,
    Debian, Red Hat Enterprise Linux, Fedora, SUSE, and openSUSE. We will use one
    of our Debian 12 systems as a host and install and configure cloud-init on it.
    We will show you how in the following subsection.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring cloud-init
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if its main purpose is to be used for cloud deployments, cloud-init can
    also be used locally. We will use it to deploy VMs on our local system. As a prerequisite
    for using cloud-init, a hypervisor should already be installed on your system,
    such as KVM. For the guest image, cloud-init uses specific cloud images that are
    already available from almost every Linux distribution provider. For example,
    we are planning on deploying Ubuntu VMs, thus we will need Ubuntu-optimized cloud
    images, which are available at [https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/).
    Let’s look at the steps required to prepare the image for deployment:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install the `cloud-image-utils` additional package and then
    the `cloud-init` package:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to create a new directory for the new cloud images:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next step is to download the cloud image:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we get details for the cloud image file:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we resize the image:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'libvirt directory:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: meta-data file will not be populated just yet. We will edit the user-data file
    first.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Important note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we will need a pair of SSH keys to use to connect with the new
    VM we plan to create. As we have not shown you yet how to work with SSH keys,
    we will provide you with the needed information in the next subsection. Go ahead
    and read the *Public key authentication with SSH* section, then get back to this
    point, where we will continue configuring our cloud-init files.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `user-data` file and add the following information:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – The user-data file contents](img/B19682_11_20.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – The user-data file contents
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `user-data` file editing is finished, we can continue and create
    a disk image that will contain the configuration files. We will use the `cloud-localds`
    command from the `cloud-image-utils` package we installed earlier:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: sudo virt-install --name vm01 --virt-type kvm --vcpus 1 --memory 2048 --disk
    path=/var/lib/libvirt/images/ubuntu.qcow2,device=disk --disk path=/var/lib/libvirt/images/cloud-init/ubuntu-provisioning.qcow2,device=cdrom
    --os-type linux --os-variant generic --import --network network=default --noautoconsole
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you get any errors regarding the network activation, you might have to use
    the following commands to activate the default network:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 11.21 – Creating a new VM](img/B19682_11_21.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – Creating a new VM
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have deployed a new VM using cloud-init. We can verify that it is running
    by using the `sudo virsh list` command or by using the Virtual Manager GUI. We
    will verify if the VM is running, we will find out the IP address and connect
    to it using SSH. We will use the following commands: `sudo virsh list` to check
    the state of the VM, `sudo virsh domifaddr vm01` to find its IP, and `ssh packt@192.168.122.32`
    to connect to it. The output is shown in the following screenshot:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Connecting to the new VM using SSH](img/B19682_11_22.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Connecting to the new VM using SSH
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created and connected to a new VM using cloud-init. After
    finishing this section, you now possess the ability to deploy VMs using cloud-init.
    However, we have only scratched the surface of what cloud-init can do, so if you
    feel like you would like to learn more about it, please use the official documentation
    or any of the titles provided in the *Further reading* section at the end of the
    chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show you how to use public key authentication with
    SSH.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Public key authentication with SSH
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`.ssh` directory in your user’s home directory. To generate a new pair of keys,
    you will have to use the `ssh-keygen` command.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used with options, the most relevant ones being: `-t` to specify
    the type of encryption algorithm used, `-b` to specify the number of bits. Used
    with no option, the `ssh-keygen` command will use the RSA encryption algorithm
    and a 3,072-bit key. The following is the output for using the command as is:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Using the ssh-keygen to create a pair of SSH keys](img/B19682_11_23.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Using the ssh-keygen to create a pair of SSH keys
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the two keys are stored inside the `.ssh` directory.
    One will be called `id_rsa` and the other `id_rsa.pub`. For our use case, configuring
    cloud-init, we will need to use the public key. Thus, we will need to concatenate
    the contents of the `id_rsa.pub` file and copy the key. In our case, the contents
    are as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – The SSH public key](img/B19682_11_24.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – The SSH public key
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we need to use those keys to connect to a cloud instance of a virtual
    private server or a VM, the public key needs to be safely copied to that machine
    or instance. For this, we will use the `ssh-copy-id` command. When using the command,
    we will need to provide a username and an IP address or hostname for the destination
    machine. For example, if we were to copy the SSH public key to a VM that has the
    IP `192.168.122.48` and a user `packt`, we would use the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: More details on how to install and configure an SSH server will be provided
    in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276). The information shown here
    is sufficient for our cloud-init task.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization is an important part of computing, providing the technology needed
    to take advantage of the tremendous computing power that modern systems provide.
    It gives you the ability to get the most out of your investment in hardware technology.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we emphasized the importance of virtualization on a Linux system.
    We showed you how to create and manage VMs using KVM. You know how to clone, template,
    and manage resources for VMs; and you know how virtualization works and how to
    install the QEMU/KVM hypervisor on Linux. With those assets, you are prepared
    to start your path into virtualization with no fears.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce you to Docker container technologies.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s a brief quiz about some of the essential concepts that were covered
    in this chapter:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate and describe the types of hypervisors.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice by installing a hypervisor on many Linux hosts.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify whether your hypervisor is working correctly.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`virt-host-validate`.'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Can you think of significant differences between major hypervisors?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Test KVM and VirtualBox for example, and make a comparison.'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How can you find the IP addresses of VMs?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`virsh` `domifaddr` command.'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following Packt books:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering KVM Virtualization – Second Edition*, Vedran Dakic, Humble Devassy
    Chirammal, Prasad Mukhedkar, Anil Vettathu'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*KVM Virtualization Cookbook*, Konstantin Ivanov'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed information about the inner workings of cloud-init, visit the official
    documentation website at [https://cloudinit.readthedocs.io/en/latest/explanation/index.html](https://cloudinit.readthedocs.io/en/latest/explanation/index.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
