<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Understanding Hosts, Services, and Contacts</h1></div></div></div><p>In this chapter we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new network host</li><li class="listitem" style="list-style-type: disc">Creating a new HTTP service</li><li class="listitem" style="list-style-type: disc">Creating a new e-mail contact</li><li class="listitem" style="list-style-type: disc">Verifying configuration</li><li class="listitem" style="list-style-type: disc">Creating a new hostgroup</li><li class="listitem" style="list-style-type: disc">Creating a new servicegroup</li><li class="listitem" style="list-style-type: disc">Creating a new contactgroup</li><li class="listitem" style="list-style-type: disc">Creating a new time period</li><li class="listitem" style="list-style-type: disc">Running a service on all hosts in a group</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>
<strong>Nagios Core</strong> is appropriate for monitoring services and states on all sorts of hosts, and one of its primary advantages is that the configuration can be as simple or as complex as required. Many Nagios Core users will only ever use the software as a way to send PING requests to a few hosts on their local network or <a id="id0" class="indexterm"/>possibly the Internet, and to send e-mail or pager messages to the administrator if they don't get any replies. Nagios Core is capable of monitoring vastly more complex systems than this, scaling from simple LAN configurations to being the cornerstone for monitoring an entire network.</p><p>However, for both simple and complex configurations of Nagios Core, the most basic building blocks of configuration are <strong>hosts</strong>, <strong>services</strong>, and <strong>contacts</strong>. These are the three things that administrators of even very simple networking setups will end up editing and probably creating. If you're a beginner to Nagios Core, then you might have changed a hostname here and there or copied a stanza in a configuration to get it to do what you want. In this chapter, we're going to look at what these configurations do in a bit more depth than that.</p><p>In a Nagios Core configuration:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hosts usually correspond to some sort of computer. This could be a physical or virtual machine accessible over the network, or the monitoring server itself. Conceptually, however, <a id="id1" class="indexterm"/>a host can monitor any kind of network entity, such as the endpoint of a VPN. </li><li class="listitem" style="list-style-type: disc">Services usually correspond to an arrangement for Nagios Core to check something about a host, whether that's something as simple as getting PING replies from it, or something more complicated such as checking that the value of an SNMP OID is within acceptable bounds.</li><li class="listitem" style="list-style-type: disc">Contacts define a means to notify someone when events happen to our services on our hosts, such as not being able to get a PING response, or being unable to send a test e-mail message.</li></ul></div><p>In this chapter, we'll add all three of these, and we'll learn how to group their definitions together to make the configuration more readable, and to work with hosts in groups rather than having to edit each one individually. We'll also set up a custom time period for notifications, so that hardworking system administrators like us don't end up getting paged at midnight unnecessarily!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating a new network host</h1></div></div></div><p>In this recipe, we'll start with the default Nagios Core configuration, and set up a host definition for a server that responds to PING<a id="id2" class="indexterm"/> on our local network. The end result will be that Nagios Core will add our new host to its internal tables <a id="id3" class="indexterm"/>when it starts up, and will automatically check it (probably using PING) on a regular basis. In this example, I'll use my Nagios Core monitoring server with a <strong>Domain Name System</strong> (<strong>DNS</strong>) <a id="id4" class="indexterm"/>name of <code class="literal">olympus.naginet</code>, and add a host definition for a webserver with a DNS name of <code class="literal">sparta.naginet</code>. This is all on my local network – <code class="literal">10.128.0.0/24</code>.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Getting ready</h2></div></div></div><p>You'll need a working Nagios Core 3.0 or greater installation with a web interface, with all the Nagios Core Plugins installed. If you have not yet installed Nagios Core, then you should start with the QuickStart guide<a id="id5" class="indexterm"/>: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/quickstart.html">http://nagios.sourceforge.net/docs/3_0/quickstart.html</a>.</p><p>We'll assume that the configuration file that Nagios Core reads on startup is located at <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>, as is the case with the default install. It shouldn't matter where you include this new host definition in the configuration, as long as Nagios Core is going to read the file at some point, but it might be a good idea to give each host its own file in a separate objects directory, which we'll do here. You should have access to a shell on the server, and be able to write text files using an editor of your choice; I'll use <code class="literal">vi</code>. You will need root privileges on the server via <code class="literal">su</code> or <code class="literal">sudo</code>.</p><p>You should know how to restart Nagios Core on the server, so that the configuration you're going to add gets applied. It shouldn't be necessary to restart the whole server to do this! A common location for the startup/shutdown script on Unix-like hosts is <code class="literal">/etc/init.d/nagios</code>, which I'll use here.</p><p>You should also get the hostname or IP address of the <a id="id6" class="indexterm"/>server you'd like to monitor ready. It's good practice to use the IP address if you can, which will mean your checks keep working even if DNS is unavailable. You shouldn't need the subnet mask or anything like that; Nagios Core will only need whatever information the PING tool would need for its own <code class="literal">check_ping</code> command.<a id="id7" class="indexterm"/>
</p><p>Finally, you should test things first; confirm that you're able to reach the host from the Nagios Core server via PING by checking directly from the shell, to make sure your network stack, routes, firewalls, and netmasks are all correct:</p><div><pre class="programlisting">
<strong>tom@olympus:~$ ping 10.128.0.21</strong>
<strong>PING sparta.naginet (10.128.0.21) 56(84) bytes of data.</strong>
<strong>64 bytes from sparta.naginet (10.128.0.21): icmp_req=1 ttl=64 time=0.149 ms</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How to do it...</h2></div></div></div><p>We can create the new host definition for <code class="literal">sparta.naginet</code> as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change directory to <code class="literal">/usr/local/nagios/etc/objects</code>, and create a new file called <code class="literal">sparta.naginet.cfg</code>:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi sparta.naginet.cfg</strong>
</pre></div></li><li class="listitem">Write the following into the file, changing the values in bold as appropriate for your own setup:<div><pre class="programlisting">define host {
<strong>    host_name              sparta.naginet</strong>
<strong>    alias                  sparta</strong>
<strong>    address                10.128.0.21</strong>
<strong>    max_check_attempts     3</strong>
    check_period           24x7
    check_command          check-host-alive
    contacts               nagiosadmin
    notification_interval  60
    notification_period    24x7
}</pre></div></li><li class="listitem">Change directory to <code class="literal">/usr/local/nagios/etc</code>, and edit the <code class="literal">nagios.cfg</code> file:<div><pre class="programlisting">
<strong># cd ..</strong>
<strong># vi nagios.cfg</strong>
</pre></div></li><li class="listitem">At the end of the file add the following line:<div><pre class="programlisting">
<strong>cfg_file=/usr/local/nagios/etc/objects/sparta.naginet.cfg</strong>
</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>If the server restarted successfully, the web interface <a id="id8" class="indexterm"/>should show a brand new host in the <strong>Hosts</strong> list, in <strong>PENDING</strong> state as it waits to run a check that the host is alive:</p><div><img src="img/5566_01_01.jpg" alt="How to do it..."/></div><p>In the next few minutes, it should change to green to show that the check passed and the host is <strong>UP</strong>, assuming that the check succeeded:</p><div><img src="img/5566_01_02.jpg" alt="How to do it..."/></div><p>If the test failed and Nagios Core was not able to get a PING <a id="id9" class="indexterm"/>response from the target machine after three tries, for whatever reason, then it would probably look similar to the following screenshot:</p><div><img src="img/5566_01_03.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>How it works...</h2></div></div></div><p>The configuration we included in this section adds a host to Nagios Core's list of hosts. It will periodically check the host by sending a PING request, checking to see if it receives a reply, and updating the host's status as shown in the Nagios Core web interface accordingly. We haven't defined any other services to check for this host yet, nor have we specified what action it should take if the host is down. However, the host itself will be automatically checked at regular intervals by Nagios Core, and we can view its state in the web interface at any time.</p><p>The directives we defined in the preceding configuration <a id="id10" class="indexterm"/>are explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">host_name</code>: This defines the <a id="id11" class="indexterm"/>hostname of the machine, used internally by Nagios Core to refer to its host. It will end up being used in other parts of the configuration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">alias</code>: This defines a more recognizable <a id="id12" class="indexterm"/>human-readable name for the host; it appears in the web interface. It could also be used for a full-text description of the host.</li><li class="listitem" style="list-style-type: disc"><code class="literal">address</code>: This defines the IP address of the <a id="id13" class="indexterm"/>machine. This is the actual value that Nagios Core will use for contacting the server; using an IP address rather than a DNS name is generally best practice, so that the checks continue to work even if DNS is not functioning.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max_check_attempts</code>: This defines the number of times Nagios Core should try to repeat the check if checks fail. <a id="id14" class="indexterm"/>Here, we've defined a value of <code class="literal">3</code>, meaning that Nagios Core will try two more times to PING the target host after first finding it down.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_period</code><a id="id15" class="indexterm"/>: This references the time period that the host should be checked. <code class="literal">24x7</code> is a time period defined in the default configuration for Nagios Core. This is a sensible value for hosts, as it means the host will always be checked. This defines how often Nagios Core will check the host, and not how often it will notify anyone.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_command</code>: This references the command that will be used to check whether the host is <code class="literal">UP</code>, <code class="literal">DOWN</code>, or <code class="literal">UNREACHABLE</code>. In this case, a QuickStart Nagios Core configuration defines <code class="literal">check-host-alive</code> as a PING check, which is a good test of basic <a id="id16" class="indexterm"/>network connectivity, and a sensible default for most hosts. This directive is actually not required to make a valid host, but you will want to include it under most circumstances; without it, no checks will be run.</li><li class="listitem" style="list-style-type: disc"><code class="literal">contacts</code><a id="id17" class="indexterm"/>: This references the contact or contacts that will be notified about state changes in the host. In this instance, we've used <code class="literal">nagiosadmin</code>, which is defined in the QuickStart Nagios Core configuration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">notification_interval</code>: This defines how <a id="id18" class="indexterm"/>regularly the host should repeat its notifications if it is having problems. Here, we've used a value of <code class="literal">60</code>, which corresponds to 60 minutes or one hour.</li><li class="listitem" style="list-style-type: disc"><code class="literal">notification_period</code>: This references the <a id="id19" class="indexterm"/>time period during which Nagios Core should send out notifications, if there are problems. Here, we're again using the <code class="literal">24x7</code> time period; for other hosts, another time period such as <code class="literal">workhours</code> might be more appropriate.</li></ul></div><p>Note that we added the definition in its own file called <code class="literal">sparta.naginet.cfg</code>
<a id="id20" class="indexterm"/>, and then referred to it in the main <code class="literal">nagios.cfg</code> configuration file. <a id="id21" class="indexterm"/>This is simply a conventional way of laying out hosts, and it happens to be quite a tidy way to manage things to keep definitions in their own files.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>There's more...</h2></div></div></div><p>There are a lot of other useful parameters for hosts, but the ones we've used include everything that's required.</p><p>While this is a perfectly valid way of specifying a host, it's more typical to define a host based on some template, with definitions of how often the host should be checked, who should be contacted when its state changes and on what basis, and similar properties. Nagios Core's QuickStart sample configuration defines a simple template host called <code class="literal">generic-host</code>, which could be used by extending the host definition with the <code class="literal">use</code> directive:</p><div><pre class="programlisting">define host {
<strong>    use                 generic-host</strong>
    name                sparta
    host_name           sparta.naginet
    address             10.128.0.21
    max_check_attempts  3
    contacts            nagiosadmin
}</pre></div><p>This uses all the parameters defined for <code class="literal">generic-host</code>, and then adds on the details of the specific host that needs to be checked. Note that if you use <code class="literal">generic-host</code>, then you will need to define <a id="id22" class="indexterm"/>
<code class="literal">check_command</code> in your host definition. If you're curious to see what's defined in <code class="literal">generic-host</code>, then you can find its definition in <code class="literal">/usr/local/nagios/etc/objects/templates.cfg</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using an alternative check command for hosts</em> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <em>Working with Commands and Plugins</em></li><li class="listitem" style="list-style-type: disc">The <em>Specifying how frequently to check a host</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. Working with Checks and States">Chapter 3</a>, <em>Working with Checks and States</em></li><li class="listitem" style="list-style-type: disc">The <em>Grouping configuration files in directories</em> and <em>Using inheritance to simplify configuration</em> recipes in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <em>Managing Configuration</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Creating a new HTTP service</h1></div></div></div><p>In this recipe, we'll create a new service to check on an existing host. Specifically, we'll check our <code class="literal">sparta.naginet</code> server to see if it's responding to <a id="id23" class="indexterm"/>HTTP requests on the usual HTTP TCP port 80. To do this, we'll be using a predefined command called <code class="literal">check_http</code>
<a id="id24" class="indexterm"/>, which in turn uses one of the standard set of Nagios Core plugins, also called <code class="literal">check_http</code>. If you don't yet have a web server defined as a host in Nagios Core, then you may like to try the <em>Creating a new network host</em> recipe in this chapter.</p><p>After we've done this, not only will our host be checked for a PING response by <code class="literal">check_command</code>, but Nagios Core will also run a periodic check to ensure that an HTTP service on that machine is responding to requests on the same host.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Getting ready</h2></div></div></div><p>You'll need a working Nagios Core 3.0 or greater installation with a web interface, all the Nagios Plugins installed, and at least one host defined. <a id="id25" class="indexterm"/>If you need to set up a host definition for your web server first, then you might like to read the <em>Creating a new network host</em> recipe in this chapter, for which the requirements are the same.</p><p>It would be a good idea to test that the Nagios Core server is actually able to contact the web server first, to ensure that the check we're about to set up should succeed. The standard <strong>telnet</strong> tool<a id="id26" class="indexterm"/> is a fine way to test that a response comes back from TCP port 80 as we would expect from a web server:</p><div><pre class="programlisting">
<strong>tom@olympus:~$ telnet sparta.naginet 80</strong>
<strong>Trying 10.128.0.21...</strong>
<strong>Connected to sparta.naginet.</strong>
<strong>Escape character is '^]'.</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How to do it...</h2></div></div></div><p>We can create the service definition for <code class="literal">sparta.naginet</code> as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the file in which the <code class="literal">sparta.naginet</code> host is defined, and edit it as follows:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi sparta.naginet.cfg</strong>
</pre></div></li><li class="listitem">Add the following code snippet to the end of the file, substituting in the value of the host's <code class="literal">host_name</code> directive:<div><pre class="programlisting">define service {
<strong>    host_name              sparta.naginet</strong>
    service_description    HTTP
    check_command          check_http
    max_check_attempts     3
    check_interval         5
    retry_interval         1
    check_period           24x7
    notification_interval  60
    notification_period    24x7
    contacts               nagiosadmin
}</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting"># /etc/init.d/nagios restart</pre></div></li></ol></div><p>If the server restarted successfully, the web interface should show a new service under the <strong>Services</strong> section, in <strong>PENDING</strong> state as the service awaits its first check:</p><div><img src="img/5566_01_04.jpg" alt="How to do it..."/></div><p>Within a few minutes, the service's state should change to <a id="id27" class="indexterm"/>
<strong>OK</strong> once the check has run and succeeded with an <strong>HTTP/1.1 200 OK</strong> response, or similar:</p><div><img src="img/5566_01_05.jpg" alt="How to do it..."/></div><p>If the check had problems, perhaps because the HTTP daemon isn't running on the target server, then the check may show <strong>CRITICAL</strong> instead. This probably doesn't mean the configuration is broken; it more likely means the network or web server isn't working:</p><div><img src="img/5566_01_06.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How it works...</h2></div></div></div><p>The configuration we've added adds a simple service check definition for an existing host, to check up to three times whether the HTTP daemon on that host is responding to a simple <strong>HTTP/1.1</strong> request. If Nagios Core can't get a response to its check, then it will flag the state of the service as <strong>CRITICAL</strong>, and will try again up to two more times before sending a notification. The service will be visible in the Nagios Core web interface and we can check its state at any time. Nagios Core will continue testing the server on a regular basis and flagging whether the checks were successful or not.</p><p>It's important to note that the service is like a property of a <a id="id28" class="indexterm"/>particular host; we define a service to check for a specific host, in this case, the <code class="literal">sparta.naginet</code> web server. That's why it's important to get the definition for <code class="literal">host_name</code> right.</p><p>The directives we defined in the preceding configuration are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">host_name</code><a id="id29" class="indexterm"/>: This references the host definition for which this service should apply. This will be the same as the <code class="literal">host_name</code> directive for the appropriate host.</li><li class="listitem" style="list-style-type: disc"><code class="literal">service_description</code><a id="id30" class="indexterm"/>: This is a name for the service itself, something human-recognizable that will appear in alerts and in the web interface for the service. In this case, we've used <code class="literal">HTTP</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_command</code><a id="id31" class="indexterm"/>: This references the command that should be used to check the service's state. Here, we're referring to a command defined in Nagios Core's default configuration called <code class="literal">check_http</code>, which refers to a plugin of the same name in the Nagios Core Plugins set.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max_check_attempts</code><a id="id32" class="indexterm"/>: This defines the number of times Nagios Core should attempt to re-check the service after finding it in a state other than <code class="literal">OK</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_interval</code><a id="id33" class="indexterm"/>: This defines how long Nagios Core should wait between checks when the service is <code class="literal">OK</code>, or after the number of checks given in <code class="literal">max_check_attempts</code> has been exceeded.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retry_interval</code><a id="id34" class="indexterm"/>: This defines how long Nagios Core should wait between retrying checks after first finding them in a state other than <code class="literal">OK</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">check_period</code><a id="id35" class="indexterm"/>: This references the time period during which Nagios Core should run checks of the service. Here we've used the sensible <code class="literal">24x7</code> time period, as defined in Nagios Core's default configuration. Note that this can be different from <code class="literal">notification_period</code>; we can check the service's status without necessarily notifying a contact.</li><li class="listitem" style="list-style-type: disc"><code class="literal">notification_interval</code><a id="id36" class="indexterm"/>: This defines how long Nagios Core should wait between re-sending notifications when a service is in a state other than <code class="literal">OK</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">notification_period</code><a id="id37" class="indexterm"/>: This references the time period during which Nagios Core should send notifications if it finds a host in a problem state. Here we've again used <code class="literal">24x7</code>, but for some less critical services it might be appropriate to use a time period such as <code class="literal">workhours</code>.</li></ul></div><p>Note that we added the service definition in the same <a id="id38" class="indexterm"/>file as defining the host, and directly after it. We can actually place the definition anywhere we like, but this happens to be a good way of keeping things organized.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec15"/>There's more...</h2></div></div></div><p>The service we've set up to monitor on <code class="literal">sparta.naginet</code> is an HTTP service, but that's just one of many possible services we could monitor on our network. Nagios Core defines many different commands for its core plugin set, such as <code class="literal">check_smtp</code>, <code class="literal">check_dns</code>, and so on. These commands, in turn, all point to programs that actually perform a check and return the results to the Nagios Core server to be dealt with. The important thing to take away from this is that a service can monitor pretty much anything, and there are hundreds of plugins available for common network monitoring checks available on the Nagios Exchange<a id="id39" class="indexterm"/> website: <a class="ulink" href="http://exchange.nagios.org/">http://exchange.nagios.org/</a>.</p><p>There are a great deal more possible directives for services, and in practice it's more likely for even simple setups that we'll want to extend a service template for our service. This allows us to define values that we might want for a number of services, such as how long they should be in a <code class="literal">CRITICAL</code> state<a id="id40" class="indexterm"/> before a notification event takes place and someone gets contacted to deal with the problem.</p><p>One such template that Nagios Core's default configuration defines is called <code class="literal">generic-service</code>, and we can use it as a basis for our new service by referring to it with the <code class="literal">use</code> keyword:</p><div><pre class="programlisting">define service {
<strong>    use                    generic-service</strong>
    host_name              sparta.naginet
    service_description    HTTP
    check_command          check_http
}</pre></div><p>This may work well for you, as there are a lot of very sensible default values set by the <code class="literal">generic-service</code> template, which makes things a lot easier. We can inspect these values by looking at the template's definition in <code class="literal">/usr/local/nagios/etc/objects/templates.cfg</code>. This is the same file that includes the <code class="literal">generic-host</code> definition that we may have used earlier.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec16"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new servicegroup</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Specifying how frequently to check a service</em> and <em>Scheduling downtime for a host or service</em> recipes in <a class="link" href="ch03.html" title="Chapter 3. Working with Checks and States">Chapter 3</a>, <em>Working with Checks and States</em></li><li class="listitem" style="list-style-type: disc">The <em>Monitoring web services</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Creating a new e-mail contact</h1></div></div></div><p>In this recipe, we'll create a new contact with which hosts and services can interact, chiefly to inform them of hosts or services changing states. We'll use the simplest example of setting up an e-mail contact, and configuring an existing host so that this person receives an e-mail message when Nagios Core's <a id="id41" class="indexterm"/>host checks fail and the host is apparently unreachable. In this instance, I'll make it e-mail me at <code class="literal">nagios@sanctum.geek.nz</code> whenever my host, <code class="literal">sparta.naginet</code>, goes from <code class="literal">DOWN</code> to <code class="literal">UP</code> state, or vice-versa.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or greater server running, with a web interface and at least one host to check. If you need to do this first, see the <em>Creating a new network host</em> recipe in this chapter.</p><p>For this particular kind of contact, you'll also need to have a working SMTP daemon running on the monitoring server, such as <strong>Exim</strong> or <strong>Postfix</strong>. You should verify that you're able to send messages to the target address, and that they're successfully delivered to the mailserver you expect.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec18"/>How to do it...</h2></div></div></div><p>We can add a simple new contact to the Nagios Core configuration as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to Nagios Core's object configuration directory; ideally it should contain a file that's devoted to contacts, such as <code class="literal">contacts.cfg</code> here, and edit that file:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi contacts.cfg</strong>
</pre></div></li><li class="listitem">Add the following contact definition to the end of the file, substituting your own values for the properties in bold as you need them:<div><pre class="programlisting">define contact {
<strong>    contact_name                   spartaadmin</strong>
<strong>    alias                          Administrator of sparta.naginet</strong>
<strong>    email                          nagios@sanctum.geek.nz</strong>
    host_notification_commands     notify-host-by-email
    host_notification_options      d,u,r
    host_notification_period       24x7
    service_notification_commands  notify-service-by-email
    service_notification_options   w,u,c,r
    service_notification_period    24x7
}</pre></div></li><li class="listitem">Edit the definition for the <code class="literal">sparta.naginet</code> host, and add or replace the definition for <code class="literal">contacts</code> for the appropriate <a id="id42" class="indexterm"/>host to our new <code class="literal">spartaadmin</code> contact:<div><pre class="programlisting">define host {
    host_name              sparta.naginet
    alias                  sparta
    address                10.128.0.21
    max_check_attempts     3
    check_period           24x7
    check_command          check-host-alive
<strong>    contacts               spartaadmin</strong>
    notification_interval  60
    notification_period    24x7
}</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, the next time our host changes its state, we should receive messages similar to the following:</p><div><img src="img/5566_01_07.jpg" alt="How to do it..."/></div><p>When the host becomes available again, we should receive a <a id="id43" class="indexterm"/>recovery message similar to the following:</p><div><img src="img/5566_01_08.jpg" alt="How to do it..."/></div><p>If possible, it's worth testing this setup with a test host that we can safely bring down and then up again, to check that we receive the appropriate notifications.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How it works...</h2></div></div></div><p>This configuration adds a new contact to the Nagios Core configuration, and references it in one of the hosts as the appropriate contact to use when the host has problems.</p><p>We've defined the required directives for the contact, and a couple of others as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">contact_name</code><a id="id44" class="indexterm"/>: This defines a unique name for the contact, so that we can refer to it in host and service definitions, or anywhere else in the Nagios Core configuration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">alias</code><a id="id45" class="indexterm"/>: This defines a human-friendly name for the contact, perhaps a brief explanation of who the person or group is and/or for what they're responsible.</li><li class="listitem" style="list-style-type: disc"><code class="literal">email</code><a id="id46" class="indexterm"/>: This defines the e-mail address of the contact, since we're going to be sending messages by e-mail.</li><li class="listitem" style="list-style-type: disc"><code class="literal">host_notification_commands</code><a id="id47" class="indexterm"/>: This defines the command or commands to be run when a state change on a host prompts a notification for the contact. In this case, we're going to e-mail the contact the results with a predefined command called <code class="literal">notify-host-by-email</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">host_notification_options</code><a id="id48" class="indexterm"/>: This specifies the different kinds of host events for which this contact should be notified. Here, we're using <code class="literal">d,u,r</code>, which means that this contact will receive notifications for a host going <code class="literal">DOWN</code>, becoming <code class="literal">UNREACHABLE</code>, or coming back <code class="literal">UP</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">host_notification_period</code><a id="id49" class="indexterm"/>: This defines the time period during which this contact can be notified of any host events. If a host notification is generated and defined to be sent to this contact, but it falls outside this time period, then the notification will not be sent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">service_notification_commands</code><a id="id50" class="indexterm"/>: This defines the command or commands to be run when a state change on a service prompts a notification for this contact. In this case, we're going to e-mail the contact the results with a predefined command called <code class="literal">notify-service-by-email</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">service_notification_options</code><a id="id51" class="indexterm"/>: This specifies the different kinds of service events for which this contact should be notified. Here, we're using <code class="literal">w,u,c,r</code>, which means we want to receive notifications about the services entering the <code class="literal">WARNING</code>, <code class="literal">UNKNOWN</code>, or <code class="literal">CRITICAL</code> states, and also when they recover and go back to being in the <code class="literal">OK</code> state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">service_notification_period</code><a id="id52" class="indexterm"/>: This is the same as <code class="literal">host_notification_period</code>, except that this directive refers to notifications about services, and not hosts.</li></ul></div><p>Note that we placed the definition for the contact in <code class="literal">contacts.cfg</code>, which is a reasonably sensible place. However, we can place the contact <a id="id53" class="indexterm"/>definition in any file that Nagios Core will read as part of its configuration; we can organize our hosts, services, and contacts any way we like. It helps to choose some sort of system, so we can easily identify where definitions are likely to be when we need to add, change, or remove them.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec20"/>There's more...</h2></div></div></div><p>If we define a lot of contacts with similar options, it may be appropriate to have individual contacts extend contact templates, so that they can inherit those common settings. The QuickStart Nagios Core configuration includes such a template, called <code class="literal">generic-contact</code>. We can define our new contact as an extension of this template, as follows:</p><div><pre class="programlisting">define contact {
<strong>    use    generic-contact</strong>
    alias  Administrator of sparta.naginet
    email  nagios@sanctum.geek.nz
}</pre></div><p>To see the directives defined for <code class="literal">generic-contact</code>, you can inspect its definition in the <code class="literal">/usr/local/nagios/etc/objects/templates.cfg</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec21"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new contact group</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Automating contact rotation</em> and <em>Defining an escalation for repeated notifications</em> recipes in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Verifying configuration</h1></div></div></div><p>In this recipe, we'll learn about the most basic step in debugging a Nagios Core configuration, which is to verify it. This is a very useful step to take before restarting the Nagios Core server to load an altered configuration, because it will warn us about possible problems. This is a good recipe to follow if you're not able to start the Nagios Core server at any point because of configuration problems, and instead get output similar to the following:</p><div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
<strong>Running configuration check... CONFIG ERROR!  Restart aborted.  Check your Nagios configuration.</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it...</h2></div></div></div><p>We can verify the Nagios Core configuration <a id="id54" class="indexterm"/>as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Run the following command, substituting the path to the Nagios binary file and our primary <code class="literal">nagios.cfg</code> configuration file, if necessary:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
</pre></div></li><li class="listitem">If the output is very long, then it might be a good idea to pipe it through a pager program, such as <code class="literal">less</code>:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg | less</strong>
</pre></div></li><li class="listitem">Inspect the output and look for warnings and problems. Here's an example of part of the output we can expect, if our configuration is correct:<div><img src="img/5566_01_09.jpg" alt="How to do it..."/></div><p>If there's a problem of some sort, then we might see an output similar to the following, which is just an example of a possible error; my configuration is wrong because I tried to <a id="id55" class="indexterm"/>add a service for a host called <code class="literal">athens.naginet</code>, when I hadn't actually configured that host yet. So Nagios Core is quite right to yell at me:</p><div><img src="img/5566_01_10.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works...</h2></div></div></div><p>The configuration is parsed as though Nagios Core were about to start up, to check that the configuration all makes sense. It will run basic checks such as looking for syntax errors, and will also check things like having at least one host and service to monitor. Some of the things it reports are warnings, meaning that they're not necessarily problems; examples include hosts not having any services monitored, or not having any contacts defined.</p><p>This is the quickest way to get an idea of whether the Nagios Core configuration is sane and will work correctly. Whenever there's trouble restarting the <a id="id56" class="indexterm"/>Nagios Core server, it's a good idea to check the output of this command first. In fact, it's a good habit to check the configuration before restarting, particularly if we're unsure about the configuration changes, or if the monitoring server is checking something very important! This means if it turns out that our configuration is broken, then the Nagios Core daemon will keep running with the configuration from the point before we changed it, and we can fix things before we restart.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec25"/>There's more...</h2></div></div></div><p>The program at <code class="literal">/usr/local/nagios/bin/nagios</code> is actually the same program that runs the Nagios Core server, but the <code class="literal">-v</code> part of the command is a switch for the program that verifies the configuration instead, and shows any problems with it. The second path is to the configuration file with which Nagios Core starts, which in turn imports the configuration files for objects, such as contact, host, and service definitions.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec26"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Writing debugging information to Nagios Core log file</em> recipe in <a class="link" href="ch10.html" title="Chapter 10. Security and Performance">Chapter 10</a>, <em>Security and Performance</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Creating a new hostgroup</h1></div></div></div><p>In this recipe, we'll learn how to create a new hostgroup; in this case, we'll do this to group together two webservers. This is useful for having distinct groups of hosts that might have different properties, such as being monitored by different teams, or running different types of monitored services. It also <a id="id57" class="indexterm"/>allows us to view a group breakdown in the Nagios Core web interface, and to apply a single service to a whole group of hosts, rather than doing so individually. This means we can set up services for a new host simply by adding it to a group, rather than having to specify the configuration manually.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec27"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running, with a web interface.</p><p>You should also have at least two hosts that form a meaningful group; perhaps they're similar kinds of servers, such as webservers, or are monitored by the same team, or all at a physical location.</p><p>In this example, we have two webservers, <code class="literal">sparta.naginet</code> and <code class="literal">athens.naginet</code>, and we're going to add them to a group called <code class="literal">webservers</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How to do it...</h2></div></div></div><p>We can add our new hostgroup <code class="literal">webservers</code> <a id="id58" class="indexterm"/>to the Nagios Core configuration as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">/usr/local/nagios/etc/objects/hostgroups.cfg</code>, if it doesn't already exist:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi hostgroups.cfg</strong>
</pre></div></li><li class="listitem">Add the following code into the new file, substituting the names in bold to suit your own layout:<div><pre class="programlisting">define hostgroup {
<strong>     hostgroup_name  webservers</strong>
<strong>     alias           Webservers with Greek names</strong>
}</pre></div></li><li class="listitem">Move a directory up, and then edit the <code class="literal">nagios.cfg</code> file:<div><pre class="programlisting">
<strong># cd ..</strong>
<strong># vi nagios.cfg</strong>
</pre></div></li><li class="listitem">Add the following line to the end of the file:<div><pre class="programlisting">cfg_file=/usr/local/nagios/etc/objects/hostgroups.cfg</pre></div></li><li class="listitem">For each of the hosts we want to add to the group, find their definitions, and add a <code class="literal">hostgroups</code> directive to put them into the new hostgroup. In this case, our definitions for <code class="literal">sparta.naginet</code> and <code class="literal">athens.naginet</code> end up looking as follows:<div><pre class="programlisting">define host {
    use         linux-server
    host_name   sparta.naginet
    alias       sparta
    address     10.128.0.21
    hostgroups  webservers
}
define host {
    use         linux-server
    host_name   athens.naginet
    alias       athens
    address     10.128.0.22
    hostgroups  webservers
}</pre></div></li><li class="listitem">Restart Nagios:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>We should now be able to visit the <strong>Host Groups</strong> <a id="id59" class="indexterm"/>section of the web interface, and see a new hostgroup with two members:</p><div><img src="img/5566_01_11.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec29"/>How it works...</h2></div></div></div><p>The configuration we added includes a new file with a new hostgroup into the Nagios Core configuration, and inserts the appropriate hosts into the group. At the moment, all this is doing is creating a separate section in the web interface for us to get a quick overview of only the hosts in that particular group.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec30"/>There's more...</h2></div></div></div><p>The way we've added hosts to groups is actually not the only way to do it. If we prefer, we can name the hosts for the group inside the group definition, using the <code class="literal">members</code> directive, so that we could have a code snippet similar to the following:</p><div><pre class="programlisting">define hostgroup {
    hostgroup_name  webservers
    alias           Webservers with Greek names
    members         athens.naginet,sparta.naginet
}</pre></div><p>This extends to allowing us to make a hostgroup that always includes every single host, if we find that useful:</p><div><pre class="programlisting">define hostgroup {
    hostgroup_name  all
    alias           All hosts
<strong>    members         *</strong>
}</pre></div><p>If we're going to use hostgroups extensively in our Nagios Core configuration, then we should use whichever method is going to be easiest for our configuration. We can use both, if necessary.</p><p>It's worth noting that a host can be in more than one <a id="id60" class="indexterm"/>group, and there is no limit on the number of groups we can declare, so we can afford to be quite liberal with how we group our hosts into useful categories. Examples could be organizing servers by function, manufacturer, or colocation customer, or routers by BGP or OSPF usage; it all depends on what kind of network we're monitoring.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec31"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new host</em> and <em>Running a service on all hosts in a group</em> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Using inheritance to simplify configuration</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <em>Managing Configuration</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Creating a new servicegroup</h1></div></div></div><p>In this recipe, we'll create a new servicegroup. This allows us to make meaningful groups out of a set of arbitrary services, so that we can view the status of all those services in a separate part of the web administration area.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec32"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running, with web interface.</p><p>You should also have at least two services defined that form a meaningful group; perhaps they're similar kinds of services, such as mail services, or are monitored by the same team, or all on the same set of servers at a physical location.</p><p>In this example, we have three servers performing <a id="id61" class="indexterm"/>mail functions: <code class="literal">smtp.naginet</code>, <code class="literal">pop3.naginet</code>, and <code class="literal">imap.naginet</code>, running an SMTP, POP3, and IMAP daemon, respectively. All three of the hosts are set up in Nagios Core, and so are their services. We're going to add them into a new servicegroup called <code class="literal">mailservices</code>.</p><p>Here are the definitions of the hosts and services used in this example, so you can see how everything fits together:</p><div><pre class="programlisting">define host {
    use                 linux-server
    host_name           smtp.naginet
    alias               smtp
    address             10.128.0.31
    hostgroups          webservers
}
    define service {
        use                  generic-service
        host_name            smtp.naginet
        service_description  SMTP
        check_command        check_smtp
    }
define host {
    use                 linux-server
    host_name           pop3.naginet
    alias               pop3
    address             10.128.0.32
    hostgroups          webservers
}
    define service {
        use                  generic-service
        host_name            pop3.naginet
        service_description  POP3
        check_command        check_pop
    }
define host {
    use                 linux-server
    host_name           imap.naginet
    alias               imap
    address             10.128.0.33
    hostgroups          webservers
}
    define service {
        use                  generic-service
        host_name            imap.naginet
        service_description  IMAP
        check_command        check_imap
    }</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec33"/>How to do it...</h2></div></div></div><p>We can add our new servicegroup with the <a id="id62" class="indexterm"/>following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to our Nagios Core configuration objects directory, and edit a new file called <code class="literal">servicegroups.cfg</code>:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi servicegroups.cfg</strong>
</pre></div></li><li class="listitem">Add the following definition to the new file, substituting the values in bold with your own values:<div><pre class="programlisting">define servicegroup {
<strong>    servicegroup_name  mailservices</strong>
<strong>    alias              Mail services</strong>
}</pre></div></li><li class="listitem">Move a directory up, and then edit the <code class="literal">nagios.cfg</code> file:<div><pre class="programlisting">
<strong># cd ..</strong>
<strong># vi nagios.cfg</strong>
</pre></div></li><li class="listitem">Add the following line to the end of the file:<div><pre class="programlisting">cfg_file=/usr/local/nagios/etc/objects/servicegroups.cfg</pre></div></li><li class="listitem">For each of the services we want to add to the group, find their definitions and add a <code class="literal">servicegroups</code> directive to put them into the new servicegroup. The definitions may end up <a id="id63" class="indexterm"/>looking similar to the following code snippet:<div><pre class="programlisting">define service {
    use                  generic-service
    host_name            smtp.naginet
    service_description  SMTP
    check_command        check_smtp
<strong>    servicegroups        mailservices</strong>
}
define service {
    use                  generic-service
    host_name            pop3.naginet
    service_description  POP3
    check_command        check_pop
<strong>    servicegroups        mailservices</strong>
}
define service {
    use                  generic-service
    host_name            imap.naginet
    service_description  IMAP
    check_command        check_imap
<strong>    servicegroups        mailservices</strong>
}</pre></div></li><li class="listitem">Restart Nagios with the following command:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>We should now be able to visit the <strong>Service Groups</strong> section of the <a id="id64" class="indexterm"/>web interface, and see a new servicegroup with three members:</p><div><img src="img/5566_01_12.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec34"/>How it works...</h2></div></div></div><p>The configuration we added includes a new file with a new servicegroup into the Nagios Core configuration, and inserts the appropriate services into the group. This creates a separate section in the web interface for us to get a quick <a id="id65" class="indexterm"/>overview of only the services in that particular group.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec35"/>There's more...</h2></div></div></div><p>The way we've added services to the groups is actually not the only way to do it. If we prefer, we can name the services (and their applicable hosts) for the group inside the group definition, using the <code class="literal">members</code> directive, so that we could have a code snippet similar to the following:</p><div><pre class="programlisting">define servicegroup {
    servicegroup_name  mailservices
    alias              Mail services
<strong>    members            smtp.naginet,SMTP,pop3.naginet,POP3</strong>
}</pre></div><p>Note that we need to specify both the host that the service is on, and then the services to monitor on it, comma-separated. The hostname comes first, and then the service.</p><p>This extends to allowing us to make a servicegroup that always includes every single service, if we find that useful:</p><div><pre class="programlisting">define servicegroup {
    servicegroup_name  all
    alias              All services
<strong>    members            *</strong>
}</pre></div><p>If we're going to be using servicegroup definitions extensively in our Nagios Core configuration, we should use whichever of the two methods to add services to groups that we think is going to be easiest for us to maintain.</p><p>It's worth noting that a service can be in more than one group, and there is no limit on the number of groups we can declare, so we can afford to be quite liberal with how we group our services into categories. Examples could be organising services by the appropriate contact for their notifications, for internal functions, <a id="id66" class="indexterm"/>or customer facing functions.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec36"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new service</em> and <em>Running a service on all hosts in a group</em> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Using inheritance to simplify configuration</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <em>Managing Configuration</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Creating a new contactgroup</h1></div></div></div><p>In this recipe, we'll create a new contactgroup into which we can add our contacts. Like hostgroups and servicegroups, contactgroups mostly amount to convenient shortcuts. In this case, it allows us to define a contactgroup as the recipient of <a id="id67" class="indexterm"/>notifications for a host or service definition. This means that we could define a group <code class="literal">ops</code>, for example, and then even if people joined or left the group, we wouldn't need to change any definitions for the hosts or services.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec37"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running.</p><p>You should also have at least two contacts that form a meaningful group. In this case, we have two staff members, John Smith and Jane Doe, who are both a part of our network operations team. We want both of them to be notified for all the appropriate hosts and services, so we'll add them to a group called <code class="literal">ops</code>. Here are the definitions with which we're working:</p><div><pre class="programlisting">define contact {
    use           generic-contact
    contact_name  john
    alias         John Smith
    email         john@naginet
}
define contact {
    use           generic-contact
    contact_name  jane
    alias         Jane Doe
    email         jane@naginet
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec38"/>How to do it...</h2></div></div></div><p>We can create our new <code class="literal">ops</code> <a id="id68" class="indexterm"/>contactgroup as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to our Nagios Core object configuration directory, and edit the <code class="literal">contacts.cfg</code> file:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc</strong>
<strong># vi contacts.cfg</strong>
</pre></div></li><li class="listitem">Add the following definition to the file, substituting your own values in bold as appropriate:<div><pre class="programlisting">define contactgroup {
<strong>    contactgroup_name  ops</strong>
<strong>    alias              Network operators</strong>
}</pre></div></li><li class="listitem">For each of the contacts that we want to add to the group, find their definitions and add the <code class="literal">contactgroups</code> directive to them. The definitions will end up looking similar to the following code snippet:<div><pre class="programlisting">define contact {
    use            generic-contact
    contact_name   john
    alias          John Smith
    email          john@naginet
<strong>    contactgroups  ops</strong>
}
define contact {
    use            generic-contact
    contact_name   jane
    alias          Jane Doe
    email          jane@naginet
<strong>    contactgroups  ops</strong>
}</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec39"/>How it works...</h2></div></div></div><p>With this group set up, we are now able to use it in the <code class="literal">contactgroups</code> directive for hosts and services, to define the contacts to which <a id="id69" class="indexterm"/>notifications should be sent. Notifications are sent to all the addresses in the group. This can replace the <code class="literal">contacts</code> directive<a id="id70" class="indexterm"/> where we individually name the contacts.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec40"/>There's more...</h2></div></div></div><p>This means, for example, that instead of having a service definition similar to the following:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP
    check_command        check_http
<strong>    contacts             john,jane</strong>
}</pre></div><p>We could use the following code snippet:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP
    check_command        check_http
<strong>    contact_groups       ops</strong>
}</pre></div><p>If John Smith were to leave the operations team, then we could simply remove his contact definition, and nothing else would require changing; from then on, only Jane Doe would receive the service notifications. This method provides a layer of abstraction between contacts and the hosts and services for which they receive notifications.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec41"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new contact</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Automating contact rotation</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Configuring Notifications">Chapter 4</a>, <em>Configuring Notifications</em></li><li class="listitem" style="list-style-type: disc">The <em>Using inheritance to simplify configuration</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <em>Managing Configuration</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Creating a new time period</h1></div></div></div><p>In this recipe, we'll add a new time period definition to the Nagios Core configuration to allow us to set up monitoring for hosts and services only during weekdays. There's a default configuration defined as <code class="literal">workhours</code> that <a id="id71" class="indexterm"/>would almost suit us, except that it doesn't include the evenings. We'll make a new one from scratch, and we'll make another one to cover the weekends too.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec42"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec43"/>How to do it...</h2></div></div></div><p>We can set up our new time period, <a id="id72" class="indexterm"/>which we'll call <code class="literal">weekdays</code>, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to our Nagios Core configuration objects directory, and edit the file called <code class="literal">timeperiods.cfg</code>:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi timeperiods.cfg</strong>
</pre></div></li><li class="listitem">Add the following definitions to the end of the file:<div><pre class="programlisting">define timeperiod {
    timeperiod_name  weekdays
    alias            Weekdays
    monday           00:00-24:00
    tuesday          00:00-24:00
    wednesday        00:00-24:00
    thursday         00:00-24:00
    friday           00:00-24:00
}
define timeperiod {
    timeperiod_name  weekends
    alias            Weekends
    saturday         00:00-24:00
    sunday           00:00-24:00
}</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec44"/>How it works...</h2></div></div></div><p>In our host and service definitions, there are two directives, <code class="literal">check_period</code> and <code class="literal">notification_period</code>. These directives are used to define the times during which a host or service should be checked, and the times when <a id="id73" class="indexterm"/>notifications about them should be sent. The <code class="literal">24x7</code> and <code class="literal">workhours</code> periods are defined in the <code class="literal">timeperiods.cfg</code> file that we just edited, and are used in several of the examples and templates.</p><p>We've just added two more of these time periods, which we can now use in our definitions for hosts and services. The first is called <code class="literal">weekdays</code>, and corresponds to any time during a weekday; the second is called <code class="literal">weekends</code>, and corresponds to any time that's not a weekday. Note that in both cases, we specified the dates and times by naming each individual day, and the times to which they corresponded.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec45"/>There's more...</h2></div></div></div><p>The definitions for dates are quite clever, and can be defined in a variety of ways. The following are all valid definitions for days and time periods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">june 1 - july 15 00:00-24:00</code>: Any time from June 1st to July 15th, inclusive</li><li class="listitem" style="list-style-type: disc"><code class="literal">thursday -1 00:00-24:00</code>: Any time on the last Thursday of every month</li><li class="listitem" style="list-style-type: disc"><code class="literal">day 1 - 10 13:00-21:00</code>: From 1 PM to 9 PM on any day from the 1st of any month to the 10th of any month, inclusive</li></ul></div><p>It's likely that the standard <code class="literal">24x7</code> and <code class="literal">workhours</code> definitions will be fine for day-to-day monitoring, maybe with a <code class="literal">weekdays</code> and <code class="literal">weekends</code> definition added. However, there may well come a time when we need a specific host or service monitored on an unusual schedule, particularly if we're debugging a specific problem that only manifests around a certain time, or have a lot of contacts to manage, or a complex on-call roster.</p><p>Note that Nagios Core can behave in unusual ways, particularly with uptime reporting, if the time periods for our monitoring of hosts and services don't add up to 24 hours. Ideally, we should check and notify all our hosts and services in at least some way around the clock, but dealing with the notifications in different <a id="id74" class="indexterm"/>ways depending on schedule; for example, we could page the systems administrators about a non-critical system during work hours, but just e-mail them when they're asleep!</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec46"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Automating contact rotation</em>, <em>Configuring notification periods</em>, and <em>Configuring notification groups</em> recipes in <a class="link" href="ch04.html" title="Chapter 4. Configuring Notifications">Chapter 4</a>, <em>Configuring Notifications</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Running a service on all hosts in a group</h1></div></div></div><p>In this recipe, we'll create a new service, but instead of applying it to an existing host, we'll apply it to an existing hostgroup. In this case, we'll <a id="id75" class="indexterm"/>create a group called <code class="literal">webservers</code>. The steps for this are very similar to adding a service for just one host; only one directive is different.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec47"/>Getting ready</h2></div></div></div><p>You should have a working Nagios Core 3.0 or better server running, with a web interface. You should be familiar with adding services to individual hosts.</p><p>You should also have at least one hostgroup defined, with at least one host in it; we'll use a group called <code class="literal">webservers</code>, with the hosts <code class="literal">sparta.naginet</code> and <code class="literal">athens.naginet</code> defined in it.</p><p>For reference, here is the hostgroup definition and the definitions for the two hosts in it:</p><div><pre class="programlisting">define hostgroup {
    hostgroup_name  webservers
    alias           Webservers
}
define host {
    use         linux-server
    host_name   athens.naginet
    alias       athens
    address     10.128.0.22
    hostgroups  webservers
}
define host {
    use         linux-server
    host_name   sparta.naginet
    alias       sparta
    address     10.128.0.21
    hostgroups  webservers
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec48"/>How to do it...</h2></div></div></div><p>We can create the service definition for the webservers group as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the file in which the webservers hostgroup is defined, and edit it:<div><pre class="programlisting">
<strong># cd /usr/local/nagios/etc/objects</strong>
<strong># vi hostgroups.cfg</strong>
</pre></div></li><li class="listitem">Add the following code snippet just after the <a id="id76" class="indexterm"/>hostgroup definition. Change the lines in bold to suit your own template and hostgroup names:<div><pre class="programlisting">define service {
<strong>    use                    generic-service</strong>
<strong>    hostgroup_name         webservers</strong>
    service_description    HTTP
    check_command          check_http
}</pre></div></li><li class="listitem">Restart the Nagios Core server:<div><pre class="programlisting">
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>It's important to note that if we are already monitoring those hosts with a per-host service of the same name, then we will need to remove those definitions as well; Nagios Core may not start if a service of the same description is already defined on the same host.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec49"/>How it works...</h2></div></div></div><p>Adding a service to a hostgroup works in exactly the same way as adding it to an individual host, except that it only requires one definition, which is then individually applied to all the hosts in the group. This means it's a very good way to keep a Nagios Core configuration tidier. If we have a group of 50 different web servers in it and we need to monitor their HTTP services on the same basis for each one of them, then we don't need to create 50 service definitions; we can just create one for their hostgroup, which amounts to a smaller and more easily updated configuration.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec50"/>There's more...</h2></div></div></div><p>Like the <code class="literal">host_name</code> directive for services, the <code class="literal">hostgroup_name</code> directive<a id="id77" class="indexterm"/> can actually have several hostgroups defined, separated by commas. <a id="id78" class="indexterm"/>This means that we can apply the same service to not just one group, but several. For services that we would want to run on several different groups (for example, basic PING monitoring) this can amount to a much more flexible configuration.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec51"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Creating a new service and Creating a new hostgroup</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Using inheritance to simplify configuration</em> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <em>Managing Configuration</em></li></ul></div></div></div></body></html>