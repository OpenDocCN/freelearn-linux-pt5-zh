<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Completion</h1></div></div></div><p>This is what most users switch to zsh for: completion. In this chapter, we'll meet one of the best features of zsh: <code class="literal">compsys</code>. Known as "the new" completion mechanism<a class="indexterm" id="id196"/>, this chapter focuses on its various functions and configuration. We will learn to<a class="indexterm" id="id197"/> tweak the completion behavior so that it's no longer restricted to filenames and bump it up using styles and our own functions. When we're done, you should be able to read most zsh scripts as well as tweak many of the existing functions.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Getting started with completion</h1></div></div></div><p>Nobody really likes to type boring filenames, and that's what got completion started back in the day—type a few letters of a filename, press <em>Tab</em>, and the shell will do the rest for you. Zsh goes the extra mile though and actually allows you to complete almost anything. By default, the <em>Tab</em> key is bound to a completion command in zsh.</p><p>Like Bash, zsh defaults to <a class="indexterm" id="id198"/>filename completion. Unlike anything else, however, zsh can enable the completion for practically everything that dares to rear its head in the command line—paths, external and built-in commands, aliases, functions, and options; you name it. And even if you can't name it, you can program it, as we will learn shortly.</p><p>Originally, zsh used a built-in module with a special syntax in order to provide completion. Luckily for us, this was eventually replaced by an even simpler mechanism. We'll focus on the new completion system that is entirely based on shell functions.</p><p>Go ahead and pop open that <code class="literal">.zshrc</code> file of yours, and add the following in order to activate shell completion:</p><div><pre class="programlisting">autoload -U compinit
compinit</pre></div><p>This addition will make the shell load the completion system and start it automatically. The <code class="literal">-U</code> flag tells the shell to avoid expanding any aliases. This will make double tapping <em>Tab</em> trigger the completion mode.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>
<code class="literal">compinit</code> is an essential part of the completion system. As such, you won't be able to test anything from here on until you have updated and sourced your <code class="literal">.zshrc</code> file or at least run <code class="literal">autoload -U compinit &amp;&amp; compinit</code> in your terminal.</p></div></div><p>Remember to <a class="indexterm" id="id199"/>source your files, and then let's go ahead and try our newly enabled completion. Type <code class="literal">ec</code> and press <em>Tab</em>:</p><div><pre class="programlisting">
<strong>% ec &lt;Tab&gt;</strong>
<strong>% echo </strong>
</pre></div><p>The shell automatically completes the external command as <code class="literal">echo</code>. How nice of zsh, isn't it?</p><div><div><h3 class="title"><a id="tip39"/>Tip</h3><p>As we have previously noted, zsh has two ways of performing completions in the command line. You can learn more about "the old way" of doing things by typing <code class="literal">man zshcompctl</code>, for academic purposes, of course.</p></div></div><p>Completion can also be applied to environment variables, for example:</p><div><pre class="programlisting">
<strong>% echo $HOM &lt;Tab&gt;</strong>
<strong>% echo $HOME</strong>
</pre></div><p>By default, zsh enables the <code class="literal">AUTO_LIST</code> option that handles the resolution of ambiguous matches, providing you with all the possible completions. To see this in action, let's go back to the previous example; only this time, we will make the completion less obvious by typing only <code class="literal">HO</code> as follows:</p><div><pre class="programlisting">
<strong>% echo $HO&lt;Tab&gt;</strong>
<strong>Completing parameter</strong>
<strong>HOME  HOST</strong>
</pre></div><p>The shell doesn't know for sure what we mean, so it presents us with a list of possible matches below the prompt instead. This list will be updated if the criteria changes, so we need to only worry about hitting the <em>Tab</em> key.</p><p>Now, let's try option completion with <code class="literal">ls</code>, as follows:</p><div><pre class="programlisting">
<strong>% ls -&lt;Tab&gt;</strong>
</pre></div><p>The following screenshot shows you how completion is triggered for the <code class="literal">ls</code> command:</p><div><img alt="Getting started with completion" src="img/2937OS_05_01.jpg"/><div><p>Menu selection in action</p></div></div><p>Seeing that there are actually a couple of viable options to pick from, zsh presents you with a menu <a class="indexterm" id="id200"/>that you can cycle through by repeatedly hitting the <em>Tab</em> key or using the arrow keys.</p><p>Finally, you can also use completion for expanding commands as follows:</p><div><pre class="programlisting">
<strong>% echo `which zsh`&lt;Tab&gt;</strong>
<strong>% echo /usr/local/bin/zsh</strong>
</pre></div><p>You can see where this is going—completion is awesome enough for us to want it to be applied everywhere, and not just in the word that's being typed. Before we start writing our own functions however, we will take a look at zsh styles, the options by which we can configure the behavior of the <code class="literal">zstyle</code> built-in.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Getting assertive with zstyle</h2></div></div></div><p>Unlike the <a class="indexterm" id="id201"/>shell options that we have been setting—and unsetting—throughout this book, zstyles demand<a class="indexterm" id="id202"/> a bit more complex syntax as a trade-off for enabling a context-sensitive completion.</p><p>Zstyles are defined<a class="indexterm" id="id203"/> via the <code class="literal">zstyle</code> keyword, followed by a colon-delimited list of arguments:</p><div><pre class="programlisting">:completion:function:completer:command:argument:tag</pre></div><p>The first argument, <code class="literal">completion</code>, is used for defining a context, as any given style could behave differently in different contexts. Nothing to write home about though, as we'll get to see in no time.</p><p>The second argument is the name of the style by which it will be referenced by the built-in. The remainder of the arguments are what give the style their unique behavior for completion.</p><p>Patterns make a comeback here as well, so you can use them as tokens for each of the subsequent arguments when defining a style. As usual, order matters when you want to define your styles, so try to put the less-specific or general-purpose styles at the bottom of your definitions, otherwise you'll end up overriding your more-specific functions.</p><p>The most general type of style you can define is <code class="literal">:completion:*</code>, which will apply to almost anything, so be careful when ordering something that resembles it.</p><p>As you might have imagined, zsh has a few tricks up its sleeve, such as being capable of displaying some useful messages with the list of matches. For this to work though, we need to enable the following style:</p><div><pre class="programlisting">zstyle ':completion:*' format %d</pre></div><p>By adding this to your <code class="literal">.zshrc</code> file, you can now get a bit more information whenever zsh is performing a completion. For example:</p><div><pre class="programlisting">
<strong>% true&lt;Tab&gt;</strong>
<strong>no argument or option</strong>
</pre></div><p>The astute reader might have noticed the <code class="literal">%d</code> pattern lying within the style format. That's right, we can use the same escape sequences as that we used when defining our prompts.</p><div><div><h3 class="title"><a id="tip40"/>Tip</h3><p>Tired of hearing beeps already? That's zsh's way of telling us that an ambiguous completion was attempted. You can put off this rather annoying attitude towards ambiguity by unsetting the <code class="literal">LIST_BEEP</code> option in your <code class="literal">.zshrc</code> file:</p><div><pre class="programlisting">unsetopt LIST_BEEP</pre></div></div></div><p>As we mentioned earlier, you can also narrow down the behavior of your styles to a more specific context.<a class="indexterm" id="id204"/> For example, you could use any of the following:</p><div><pre class="programlisting">zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format %d
zstyle ':completion:*:warnings' format 'No matches for: %d'</pre></div><p>This is just to set a custom pattern for the messages belonging to <code class="literal">warnings</code>, <code class="literal">messages</code>, and <code class="literal">descriptions</code> groups. As you can see, <code class="literal">warnings</code> will now be reported as <code class="literal">No matches for: &lt;argument&gt;</code>, which is a bit less dronish.</p><p>You <a class="indexterm" id="id205"/>could also <a class="indexterm" id="id206"/>add a little more flair to your results with something along the following lines:</p><div><pre class="programlisting">zstyle ':completion:*' group-name ''</pre></div><p>This will display all the different types of matches separately. If no tag or group is defined for a particular match, it'll get displayed under the <code class="literal">default</code> group.</p><div><div><h3 class="title"><a id="tip41"/>Tip</h3><p>Did the menu selection tickle your fancy? Here's how we make it available for all of your matches:</p><div><pre class="programlisting">zstyle ':completion:*' menu select=1</pre></div></div></div><p>Getting comfortable with the styles? Glad to hear. As you can see from the examples, there's no arcane magic involved here—just some documentation and creativity to fill the gap between you and your custom styles.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Command correction</h1></div></div></div><p>Completion can <a class="indexterm" id="id207"/>also correct any misspelled <a class="indexterm" id="id208"/>commands that you might have typed. We'll use the following format for our style:</p><div><pre class="programlisting">zstyle ':completion:*' completer _expand _complete _correct</pre></div><p>And we'll test the autocorrect functionality with the following:</p><div><pre class="programlisting">
<strong>% prnti&lt;Tab&gt;</strong>
<strong>corrections (2 errors)</strong>
<strong>print   printf</strong>
<strong>original</strong>
<strong>prnti</strong>
</pre></div><p>Zstyle noticed that we misspelled <code class="literal">print</code> and is being quite verbose regarding this. Remember you can use the <em>Tab</em> key to cycle through the list of available options.</p><p>Alternatively, you could use the <code class="literal">correct</code> option if you want a more "hold me by the hand" approach. Specifically, this option will make zsh ask you for confirmation every time it suggests a correction:</p><div><pre class="programlisting">
<strong>% setopt correct</strong>
<strong>% prnti&lt;Tab&gt;</strong>
<strong>zsh: correct 'prnti' to 'print' [nyae]?</strong>
</pre></div><p>This<a class="indexterm" id="id209"/> peculiar <code class="literal">nyae</code> acronym stands for <em>No</em>, <em>Yes</em>, <em>Abort</em>, and <em>Edit</em>, and works in the following way:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">n</code>: This will force the shell to execute whatever you typed in the command line (<code class="literal">prnti</code> in this particular case).</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: This will execute the correction (effectively, changing <code class="literal">prnti</code> to <strong>print</strong> in this example).</li><li class="listitem" style="list-style-type: disc"><code class="literal">a</code>: This will abort and allow you to type a completely different command. Think of it as a panic button.</li><li class="listitem" style="list-style-type: disc"><code class="literal">e</code>: This will allow you to edit the current text in the command line. Use this for a more fine-grained control in case suggestions made by the shell are completely off.</li></ul></div><p>What about command options? You know, those flags we pass around all the time? Well, turns out there is a style for that too. The following will make the commands show the descriptions for their options:</p><div><pre class="programlisting">zstyle ':completion:*' verbose yes</pre></div><p>These can be easily accounted for; now, go ahead and type the following:</p><div><pre class="programlisting">
<strong>% print -&lt;Tab&gt;</strong>
</pre></div><div><pre class="programlisting">
<strong>-- option --</strong>
<strong>-C  -- print arguments in specified number of columns</strong>
<strong>-D  -- substitute any arguments which are named directories using ~ notation</strong>
<strong>-N  -- print arguments separated and terminated by nulls</strong>
<strong>-O  -- sort arguments in descending order</strong>
<strong>(list goes on...)</strong>
</pre></div><p>Not too shabby, right? Remember how I mentioned we wouldn't be in such a dire need for manpages after we learned some styles? No? Well, we won't be in such... never mind.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Completers</h2></div></div></div><p>The third entry on the zstyle is <a class="indexterm" id="id210"/>reserved for completers<a class="indexterm" id="id211"/>. These are the functions that handle the different types of completions available. By default, the list of completers consists of a single function, <code class="literal">_complete</code>, but each member of the completers family will add its own unique behavior to your styles.</p><div><pre class="programlisting">zstyle ':completion:*' completer _expand _complete _correct</pre></div><p>Used<a class="indexterm" id="id212"/> in <a class="indexterm" id="id213"/>your <code class="literal">.zshrc</code> file, this completer will use globbing for expanding the input and match it against the <code class="literal">_complete</code> and <code class="literal">_correct</code> completers. The <code class="literal">_correct</code> completer is used here for correcting any typos and spelling mistakes. We're leaving it at the end of the argument list so that <code class="literal">_complete</code> takes precedence.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>When used within a style, completer names omit the leading underscore:</p><div><pre class="programlisting">zstyle ':completion::complete:*' use-cache on</pre></div><p>This style configures the <code class="literal">_complete</code> completer by enabling a cache layer for any completions that require it, improving the overall responsiveness of such functions.</p></div></div><p>Similar to <code class="literal">_correct</code>, <code class="literal">_approximate</code> will carry out the same tasks with the added benefit of allowing a few extra characters to be misspelled at the cursor position. Notice that you will need to put <code class="literal">_approximate</code> before <code class="literal">_correct</code>, should you need to use both in your style.</p><p>As a function, zstyle also uses flags. Of particular interest to us is the <code class="literal">-e</code> option, which tells zstyle to evaluate the final string as an argument on each call. This allows us to use more dynamic styles such as the following:</p><div><pre class="programlisting"># One error for every three characters
zstyle -e ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'</pre></div><p>This configures the <code class="literal">approximate</code> completer to evaluate the argument for the <code class="literal">max-errors</code> parameter dynamically, each time it is invoked. The <code class="literal">reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )</code> string uses the <code class="literal">reply</code> hook for displaying the results within the line editor and sets its value as the expression, <code class="literal">(PREFIX + SUFFIX)/3</code>. This is our way of saying "one error for every three characters". Both <code class="literal">PREFIX</code> and <code class="literal">SUFFIX</code> are variables that contain the values before and after the cursor position, respectively.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Ignoring matches</h2></div></div></div><p>Sometimes, <a class="indexterm" id="id214"/>some matching suggestions <a class="indexterm" id="id215"/>jump out at you as being completely out of place. Luckily for us, the developers of zsh have included an <code class="literal">_ignore</code> completer.</p><p>Take the following directory tree as an example:</p><div><pre class="programlisting">zsh
├── README.md
├── Completion/
├── Misc/
├── Scripts/
└── Util/</pre></div><p>When <a class="indexterm" id="id216"/>working on any of the subdirectories mentioned previously—for example, the <code class="literal">Completion</code> folder—see what happens when we try to change directory, using <code class="literal">cd</code>, to another at the same level:</p><div><pre class="programlisting">
<strong>% cd ../ &lt;Tab&gt;</strong>
<strong>directory</strong>
<strong>Completion/</strong>
<strong>Misc/</strong>
<strong>Scripts/</strong>
<strong>Util/</strong>
</pre></div><p>Having the <code class="literal">Completion</code> mechanism display the folder we're currently located in is a bit awkward, and it makes the whole <code class="literal">cd</code> deal a bit pointless. In order to make the shell a bit more context-sensitive, we can alter the completion behavior for the <code class="literal">cd</code> command using the <code class="literal">ignore-parents</code>, <code class="literal">parent</code>, and <code class="literal">pwd</code> options:</p><div><pre class="programlisting">zstyle ':completion:*:cd:*' ignore-parents parent pwd</pre></div><p>The following will remove the respective matches from the completion results. Notice how <code class="literal">Completion</code> is now missing from the results:</p><div><pre class="programlisting">
<strong>% cd ../ &lt;Tab&gt;</strong>
<strong>directory</strong>
<strong>Misc/</strong>
<strong>Scripts/</strong>
<strong>Util/</strong>
</pre></div><p>While we're at it, you can use the following style to remove the trailing slash when using a directory as an argument:</p><div><pre class="programlisting">zstyle ':completion:*' squeeze-slashes true</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Function definitions</h1></div></div></div><p>Finally, <a class="indexterm" id="id217"/>we will turn our attention to <code class="literal">compsys</code>, zsh's completion system. This is one of the most complex parts of the shell for users and developers alike. Before we dive into <code class="literal">compsys</code>, however, we need to make a quick stop and meet an actual function in the wild.</p><div><div><h3 class="title"><a id="tip42"/>Tip</h3><p>As usual, you can learn more about <code class="literal">compsys</code> via the manpages. Of particular interest are <code class="literal">man zshcompsys</code> and <code class="literal">man zshcompwid</code>.</p></div></div><p>Here's what one of these looks like:</p><div><pre class="programlisting">hi() {
print 'Hello, world'
}</pre></div><p>Here, <a class="indexterm" id="id218"/>we have defined the <code class="literal">hi</code> function, which is how we'll call it again later when we need it. This will, in turn, print <code class="literal">Hello, world</code> every time we use it. So let's get to it, shall we?</p><p>Open your terminal emulator of choice, and type the following (one line at a time):</p><div><pre class="programlisting">
<strong>% hi() {</strong>
<strong>function&gt; print 'Hello, World!'</strong>
<strong>function&gt; }</strong>
</pre></div><p>Notice how zsh realized this was indeed a function we were trying to define and immediately used the continuation prompt (<code class="literal">function&gt;</code>), allowing you to continue working on it? How nice of zsh to wait for us until we properly close our curly braces.</p><p>Now, go ahead and test your first function:</p><div><pre class="programlisting">
<strong>% hi</strong>
<strong>Hello, World!</strong>
</pre></div><p>They grow so fast!</p><p>And, now for the sad part—this was defined for your current session only, just like when we defined aliases back in <a class="link" href="ch02.html" title="Chapter 2. Alias and History">Chapter 2</a>, <em>Alias and History</em>, at the beginning of our zsh adventure. If you want <code class="literal">hi()</code>, or any other function to tag along in each interactive session of yours, you'll need to add it to your startup files.</p><p>A word of advice though: once you start with the completion and functions, these startup files will get pretty crowded. So, it's probably best that you start relocating your functions into a more comfy space like their own <code class="literal">.zsh_functions</code> file. Fret not, as the process is easy.</p><p>First, we create a hidden file; you can name it whatever you fancy, but we'll go with <code class="literal">.zsh_functions</code> (see the leading dot, so we can tell the system that it can hide it).</p><div><pre class="programlisting">
<strong>% touch ~/.zsh_functions</strong>
</pre></div><p>Once you have created the file in your <code class="literal">$HOME</code> directory, it's simply a matter of adding your functions in here. You can use your favorite editor; we'll just roll with <code class="literal">cat</code> here for convenience:</p><div><pre class="programlisting">
<strong>% cat &gt;&gt; ~/.zsh_functions</strong>
<strong>greet() {</strong>
<strong>  print 'Hello, World!'</strong>
<strong>}</strong>
</pre></div><p>Press <em>Ctrl</em> + <em>D</em> to close the file.</p><p>Now, as<a class="indexterm" id="id219"/> we learned previously, this wouldn't do anything by itself unless we source the file. And since sourcing the file manually in each session would be a pain in the neck, we just need to go a step further and add the <code class="literal">.zsh_functions</code> sourcing to our startup files. So, go ahead and open your <code class="literal">.zshrc</code> file, and add the following:</p><div><pre class="programlisting">[[ -f ~/.zsh_functions ]] &amp;&amp; source ~/.zsh_functions</pre></div><p>This is a conditional statement. The double square braces (<code class="literal">[[</code>) shown here are known as the <code class="literal">test</code> command (or <em>new test</em> if you have been around the command line for a while), and they help you compare strings and test for file attributes. The <code class="literal">-f</code> switch is for regular files and succeeds only if the file exists. So we're literally trying to say "test whether the <code class="literal">~/.zsh_functions</code> file exists". If the test passes, the following part of the command will get chained and we'll finally source our functions file.</p><p>As a side note, this expression supports filename globbing, so all the tricks we learned in <a class="link" href="ch04.html" title="Chapter 4. Globbing">Chapter 4</a>, <em>Globbing</em>, still apply here.</p><p>You can source as many files as you like with this same mechanism; just remember to add the line into your <code class="literal">.zshrc</code> file, and don't forget about the test fail-switch, which will avoid sourcing files that do not exist in the system (and of course, errors).</p><p>As always, you can scuba dive into the <code class="literal">test</code> command simply by typing <code class="literal">man [</code> in your terminal. For more details regarding the <code class="literal">[[</code> compound command, check the <em>CONDITIONAL EXPRESSIONS</em> section under the <code class="literal">zshmisc(1)</code> manual entry.</p><p>Okay, I hear you. So what do functions have to do with completion? Well, everything! See, <code class="literal">compsys</code> is entirely made out of functions: functions that will be called automatically whenever you hit the <em>Tab</em> key. The difference lies in how these set of functions use some other special commands to interact with our old pal, ZLE, in order to show the available completions. Don't worry though; contrary to popular belief, there's no arcane magic in here.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>The path of the function</h2></div></div></div><p>So, functions. A <a class="indexterm" id="id220"/>truckload of them to be more precise (well, you be the judge of this). How does zsh know where to look? It is easier than it sounds; the shell will load anything that belongs to its function path or <code class="literal">$fpath</code>, a series of directories that contain the files with the functions required for completion. Go ahead and have a look at it: </p><div><pre class="programlisting">
<strong>% print -l $fpath</strong>
</pre></div><p>All the directories that show up in your function path list will be scanned and loaded by the shell during startup, provided you call <code class="literal">compinit</code> first. So remember to call <code class="literal">autoload –U compinit</code> in your <code class="literal">.zshrc</code> file. Note, however, that call will load anything that resides in<a class="indexterm" id="id221"/> your <code class="literal">$fpath</code>. If you happen to have a special requirement for a single function, you could call it explicitly via <code class="literal">autoload</code>. If you save the previous function as a file named <code class="literal">_greet</code> and put it into one of the directories within your <code class="literal">$fpath</code>, you could then use the following inside your startup files for loading the function into the shell automatically:</p><div><pre class="programlisting">
<strong>% cat &gt;&gt; _greet</strong>
<strong>echo 'Hello world!'</strong>

<strong>autoload -Uz _greet</strong>
</pre></div><p>See that <code class="literal">-Uz</code> flag? The <code class="literal">-U</code> flag works by telling the shell to use the name <code class="literal">_greet</code> to refer to the function we just created, whereas the <code class="literal">-z</code> flag tells zsh to load the function in the native mode. Both <code class="literal">-U</code> and <code class="literal">-z</code> flags are always added implicitly whenever you call <code class="literal">autoload</code>, but I'm leaving it there for you to be aware of them.</p><p>Okay, so it's all fun and single-line functions until someone needs something a bit more complex. Single functions within a file will be loaded without any problem whatsoever. So, how do we use helper functions (auxiliary methods for our main functionality) in our files? The zsh way states that we should define a function and name it just like the file and call it in the last line of the file:</p><div><pre class="programlisting">_greet() {
    echo "Hello, World!"
}

_meet() {
    _greet
    echo "Ohai there $@"
}

_meet "$@"</pre></div><p>That last line in the file takes care of calling the function named <code class="literal">_foo</code> inside the file, and passing it the same arguments used. So if you called it <code class="literal">meet John</code>, the arguments will be passed to the <code class="literal">meet</code> function.</p><p>Save the file as <code class="literal">meet</code> (no extension) inside any of your <code class="literal">$fpath</code> folders; restart your shell and call the following:</p><div><pre class="programlisting">
<strong>% meet John</strong>
<strong>Hello, World!</strong>
<strong>Ohai there john</strong>
</pre></div><div><div><h3 class="title"><a id="tip43"/>Tip</h3><p>
<strong>Extending your fpath</strong>
</p><p>If you don't want to be messing around with copies or links to your functions, you can easily extend <code class="literal">fpath</code> with more folders by setting the variable as follows:</p><div><pre class="programlisting">fpath=(~/my_folder $fpath)</pre></div><p>This will prepend the folder, <code class="literal">my_folder</code>, to the shell's <code class="literal">fpath</code>, effectively extending it with whatever lies inside your folders. This is particularly useful for those times when you lack the appropriate permissions on a given system. Note that we are using the absolute path to the folder.</p></div></div><p>So let's take <a class="indexterm" id="id222"/>a look at a formal completion function. Don't worry, we'll start with an easy one, such as <code class="literal">_md5sum</code>, which is typically located under your <code class="literal">$ZSH_INSTALL_DIR/functions/</code> folder. Here it lies in all its glory:</p><div><pre class="programlisting">#compdef md5sum

_arguments -S \
  '(-b --binary)'{-b,--binary}'[read in binary mode]' \
  '(-c --check)'{-c,--check}'[read MD5 sums from the FILEs and check them]' \
  '(-t --text)'{-t,--text}'[read in text mode]' \
  '--status[no output, status code shows success]' \
  '(-w --warn)'{-w,--warn}'[warn about improperly formatted checksum lines]' \
  '--help[display help and exit]' \
  '--version[output version information and exit]' \
  '*:files:_files'</pre></div><p>Go ahead and test this by typing <code class="literal">md5sum -</code> followed by pressing the <em>Tab </em>key, and you'll be prompted with the options from <code class="literal">arguments</code>.</p><p>Your very first line of code in any completion function must be the <code class="literal">#compdef</code> clause, followed by the name of the program to be completed by the function (<code class="literal">md5sum</code>, in this particular case).</p><p>Next up is a call to the internal <code class="literal">_arguments</code> function, which does the actual handling of the options to be formatted and displayed on screen. This function is typically used when specifying the completion of commands whose arguments follow standard Unix conventions in their options and arguments' lists. Using the <code class="literal">-S</code> option, we declare that no option will be completed after <code class="literal">--</code> shows up on the line. This is the delimiter used to end the parsing of the option, so this argument would be typically ignored unless we explicitly say otherwise.</p><p>If you look closely though, you'll notice that each of the argument entries (split into continuation lines via <code class="literal">\</code>) follows the same pattern:</p><div><pre class="programlisting">'(optional exclusion list)'{options}'[help text in brackets]'</pre></div><p>Note that the<a class="indexterm" id="id223"/> curly braces around the option and its verbose variant are there to group them together, otherwise they are optional.</p><p>The exclusion list works by explicitly telling zsh what should not be included in the results. In other words, whenever the <code class="literal">option</code> parameter is typed, hide all the other options from <code class="literal">(exclusions)</code>. Take for example the following line:</p><div><pre class="programlisting">'(-t --text)'{-t,--text}'[read in text mode]'</pre></div><p>If <code class="literal">-t</code> or <code class="literal">--text</code> appears in the command line, do not show the <code class="literal">-t</code> or <code class="literal">--text</code> options as completions.</p><p>This makes even more sense for commands such as <code class="literal">ln</code>, where you want to avoid offering some potentially misguiding options:</p><div><pre class="programlisting">'(-L -P)-H[with -R, follow symlinks on the command line]'</pre></div><p>Hide the options <code class="literal">-L</code> and <code class="literal">-P</code> if <code class="literal">-H</code> is being used; this is because both the options are used for "always follow symbolic links" and "never follow symbolic links", respectively.</p><p>Finally, there's the last line of the <code class="literal">_md5sum</code> function:</p><div><pre class="programlisting">'*:files:_files'</pre></div><p>This uses the <code class="literal">_files</code> helper function that is somewhat the standard tool for completing filenames. With this line, we make sure that filenames are completed even if no other options' flags are suggested.</p><p>Moreover, <code class="literal">_files</code> uses an additional function, <code class="literal">_path_files</code>, and passes its arguments to the latter. On its own, <code class="literal">_path_files</code> is the de facto function for completing filenames within the completion system. As if it wasn't enough, <code class="literal">_path_files</code> has some really handy tricks up its sleeve such as completion of partial paths, which enables things such as<code class="literal"> /u/bi/zs</code> to be completed to <code class="literal">/usr/bin/zsh</code>.</p><p>Then, there are also helper functions such as <code class="literal">_call_program</code>, which are used to execute any kind of commands available to the system. A common practice when using <code class="literal">_call_program</code> is to redirect the standard error to <code class="literal">/dev/null</code> (this is a nice way of saying it's silencing any error-induced screams) and allows us to save the output of the command into a variable.</p><p>And that's all there's to it. Well, at least for getting started with the completion mechanism and custom-made functions. Although, on some occasions, getting your hands dirty and extending the completion system with your own functions will only get you so far, this quick fly-by should be enough to get you excited about the possibilities lying there. Again, it's advisable that you try not to reinvent the wheel—as we'll see in the next chapter, there are many other projects out there that can give you a nice boost in the completion department.</p><p>You can now<a class="indexterm" id="id224"/> go ahead and take a deep dive into the <code class="literal">functions</code> folder of your zsh installation to start getting familiarized with the thousands of lines of code there. Who knows? Perhaps the starting template for the next completion function is just waiting there for you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>We are almost done with this adventure, and it seems you are now more ready than ever to start tackling major annoyances like your favorite program not having a set of completion definitions. Even better, you can tweak and improve the existing functionality, which otherwise would make your work really frustrating.</p><p>Besides writing your own functions, we also learned how to tweak the shell behavior and go a step above filename completion. With a bit of practice and further tweaking, you can now become a real speed demon of the command line. Best of all, it only takes a couple of <em>Tab</em> presses to get there.</p><p>Summing it up, here's what's covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The types of completion available to zsh—zstyles and functions, which allow you to customize the behavior of the completion mechanism and extend its functionality</li><li class="listitem" style="list-style-type: disc">The different types of completers (particularly <code class="literal">correct</code>, <code class="literal">approximate</code> &amp; <code class="literal">ignore</code>) and their role when defining zstyles</li><li class="listitem" style="list-style-type: disc">A few tips for creating and extending your our own completion functions</li></ul></div><p>Okay then, before I get sentimental, we should hurry to the next chapter that has a few suggestions before we're done with this journey of ours.</p></div></body></html>