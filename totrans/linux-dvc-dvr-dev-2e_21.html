<html><head></head><body>
		<div id="_idContainer071">
			<h1 id="_idParaDest-254"><em class="italic"><a id="_idTextAnchor256"/>Chapter 17</em>: Leveraging the Linux Kernel Input Subsystem</h1>
			<p>Input devices are devices that you can use to interact with the system. Such devices include buttons, keyboards, touchscreens, mice, and more. They work by sending events that are caught and broadcast over the system by the input core. This chapter will explain each structure that's used by the input core to handle input devices, as well as how to manage events from the user space.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to the Linux kernel input subsystem – its data structures and APIs</li>
				<li>Allocating and registering an input device</li>
				<li>Using polled input devices</li>
			</ul>
			<ul>
				<li>Generating and reporting input events</li>
				<li>Handling input devices from the user space</li>
			</ul>
			<h1 id="_idParaDest-255"><a id="_idTextAnchor257"/>Introduction to the Linux kernel input subsystem – its data structures and APIs</h1>
			<p>The main<a id="_idIndexMarker1474"/> data structures and APIs of this subsystem<a id="_idIndexMarker1475"/> can be found in the <strong class="source-inline">include</strong>/<strong class="source-inline">linux</strong>/<strong class="source-inline">input.h</strong> files. The following line is required in any input device driver:</p>
			<p class="source-code">#include &lt;linux/input.h&gt;</p>
			<p>Whatever type of input device it is, whatever type of event it sends, an input device is represented in the kernel as an instance of the struct <strong class="source-inline">input_dev</strong>:</p>
			<p class="source-code">struct input_dev {</p>
			<p class="source-code">  const char *name;</p>
			<p class="source-code">  const char *phys;</p>
			<p class="source-code">  unsigned long evbit[BITS_TO_LONGS(EV_CNT)];</p>
			<p class="source-code">  unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];</p>
			<p class="source-code">  unsigned long relbit[BITS_TO_LONGS(REL_CNT)];</p>
			<p class="source-code">  unsigned long absbit[BITS_TO_LONGS(ABS_CNT)];</p>
			<p class="source-code">  unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)];</p>
			<p class="source-code">  unsigned int repeat_key;</p>
			<p class="source-code">  int rep[REP_CNT];</p>
			<p class="source-code">  struct input_absinfo *absinfo;</p>
			<p class="source-code">  unsigned long key[BITS_TO_LONGS(KEY_CNT)];</p>
			<p class="source-code">  int (*open)(struct input_dev *dev);</p>
			<p class="source-code">  void (*close)(struct input_dev *dev);</p>
			<p class="source-code">  unsigned int users;</p>
			<p class="source-code">  struct device dev;</p>
			<p class="source-code">  unsigned int num_vals;</p>
			<p class="source-code">  unsigned int max_vals;</p>
			<p class="source-code">  struct input_value *vals;</p>
			<p class="source-code">  bool devres_managed;</p>
			<p class="source-code">};</p>
			<p>For the sake <a id="_idIndexMarker1476"/>of readability, some elements in the<a id="_idIndexMarker1477"/> structure have been omitted. Let's look at these fields in more detail:</p>
			<ul>
				<li><strong class="source-inline">name</strong> represents the name of the device.</li>
				<li><strong class="source-inline">phys</strong> is the physical path to the device in the system hierarchy.</li>
				<li><strong class="source-inline">evbit</strong> is a bitmap of the types of events that are supported by the device. The following are some events:<ul><li><strong class="source-inline">EV_KEY</strong> is for devices that support sending key events (for example, keyboards, buttons, and so on)</li><li><strong class="source-inline">EV_REL</strong> is for devices that support sending relative positions (for example, mice, digitizers, and so on)</li><li><strong class="source-inline">EV_ABS</strong> is for devices that support sending absolute positions (for example, joysticks) The list of events is available in the kernel source in the<em class="italic"> </em><strong class="source-inline">include/linux/input-event-codes.h</strong> file. You can use the <strong class="source-inline">set_bit()</strong> macro to set the appropriate bit, depending on your input device's capabilities. Of course, a device can support more than one type of event. For example, a mouse driver will set both <strong class="source-inline">EV_KEY</strong> and <strong class="source-inline">EV_REL</strong>, as shown here:<p class="source-code">    set_bit(EV_KEY, my_input_dev-&gt;evbit);</p><p class="source-code">    set_bit(EV_REL, my_input_dev-&gt;evbit);</p></li></ul></li>
				<li><strong class="source-inline">keybit</strong> is for <strong class="source-inline">EV_KEY</strong> enabled devices and consists of a bitmap of keys/buttons that this device exposes; for example, <strong class="source-inline">BTN_0</strong>, <strong class="source-inline">KEY_A</strong>, <strong class="source-inline">KEY_B</strong>, and so on. The complete list of keys/buttons can be found in the <strong class="source-inline">include/linux/input-event-codes.h</strong> file.</li>
				<li><strong class="source-inline">relbit</strong> is for <strong class="source-inline">EV_REL</strong> enabled devices and consists of a bitmap of relative axes for the device; for example, <strong class="source-inline">REL_X</strong>, <strong class="source-inline">REL_Y</strong>, <strong class="source-inline">REL_Z</strong>, and so on. Have a look at <strong class="source-inline">include/linux/input-event-codes.h</strong> for the complete list.</li>
				<li><strong class="source-inline">absbit</strong> is for <strong class="source-inline">EV_ABS</strong> enabled devices and consists of a bitmap of absolute axes for the device; for example, <strong class="source-inline">ABS_Y</strong>, <strong class="source-inline">ABS_X</strong>, and so on. Have a look at the same previous file for the complete list.</li>
				<li><strong class="source-inline">mscbit</strong> is for <strong class="source-inline">EV_MSC</strong> enabled devices and consists of a bitmap of miscellaneous events that are supported by the device.</li>
				<li><strong class="source-inline">repeat_key</strong> stores the key code of the last key pressed; it is used when the autorepeat feature is implemented by the software.</li>
				<li><strong class="source-inline">rep</strong> stores the <a id="_idIndexMarker1478"/>current values for auto repeat parameters, typically <a id="_idIndexMarker1479"/>the delay and rate.</li>
				<li><strong class="source-inline">absinfo</strong> is an array of <strong class="source-inline">&amp;struct input_absinfo</strong> elements that holds information about the absolute axes (the current value, <strong class="source-inline">min</strong>, <strong class="source-inline">max</strong>, <strong class="source-inline">flat</strong>, <strong class="source-inline">fuzz</strong>, and the resolution). You should use the <strong class="source-inline">input_set_abs_params()</strong> function to set those values:<p class="source-code">void input_set_abs_params(struct input_dev *dev,</p><p class="source-code">                       unsigned int axis, int min,</p><p class="source-code">                       int max, int fuzz, int flat)</p></li>
				<li><strong class="source-inline">min</strong> and <strong class="source-inline">max</strong> specify the lower and upper bound values, respectively. <strong class="source-inline">fuzz</strong> indicates the expected noise on the specified channel of the specified input device. In the following examples, we're setting each channel's bound:<p class="source-code">#define ABSMAX_ACC_VAL      0x01FF</p><p class="source-code">#define ABSMIN_ACC_VAL      -(ABSMAX_ACC_VAL)</p><p class="source-code">[...]</p><p class="source-code">set_bit(EV_ABS, idev-&gt;evbit);</p><p class="source-code">input_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL,</p><p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p><p class="source-code">input_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL,</p><p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p><p class="source-code">input_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL,</p><p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p></li>
				<li><strong class="source-inline">key</strong> reflects the current state of the device's keys/buttons.</li>
				<li><strong class="source-inline">open</strong> is a method that's called when the very first user calls <strong class="source-inline">input_open_device()</strong>. Use this method to prepare the device, such as to interrupt a request, poll a thread start, and so on.</li>
				<li><strong class="source-inline">close</strong> is called when the very last user calls <strong class="source-inline">input_close_device()</strong>. Here, you can stop polling (which consumes a lot of resources).</li>
				<li><strong class="source-inline">users</strong> stores the number of<a id="_idIndexMarker1480"/> users (input handlers) that opened this device. It is used by <strong class="source-inline">input_open_device()</strong> and <strong class="source-inline">input_close_device()</strong> to ensure that <strong class="source-inline">dev-&gt;open()</strong> is only called when the first user opens the device and that <strong class="source-inline">dev-&gt;close()</strong> is only called when the very last user closes the device.</li>
				<li><strong class="source-inline">dev</strong> is the struct <a id="_idIndexMarker1481"/>device associated with this device (for device model).</li>
				<li><strong class="source-inline">num_vals</strong> is the number of values that are queued in the current frame.</li>
				<li><strong class="source-inline">max_vals</strong> is the maximum number of values that are queued in a frame.</li>
				<li><strong class="source-inline">Vals</strong> is the array of values that are queued in the current frame.</li>
				<li><strong class="source-inline">devres_managed</strong> indicates that the devices are managed with the <strong class="bold">devres</strong> framework and don't need to be explicitly unregistered or freed.</li>
			</ul>
			<p>Now that you're familiar with the main input device's data structure, we can start registering such devices within the system.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor258"/>Allocating and registering an input device</h1>
			<p>Before the events that<a id="_idIndexMarker1482"/> are supported by an input device can be seen by the system, memory<a id="_idIndexMarker1483"/> needs to be allocated for this device first using the <strong class="source-inline">devm_input_allocate_device()</strong> API. Then, the device needs to be registered with the system using <strong class="source-inline">input_device_register()</strong>. The former API will take care of freeing up the memory and unregistering the device when it leaves the system. However, non-managed allocation is still available but not recommended, <strong class="source-inline">input_allocate_device()</strong>. By using non-managed allocation, the driver becomes responsible for making sure that <strong class="source-inline">input_unregister_device()</strong> and <strong class="source-inline">input_free_device()</strong> are called to unregister the device and free its memory when they're on the unloading path of the driver, respectively. The following are the respective prototypes of these APIs:</p>
			<p class="source-code">struct input_dev *input_allocate_device(void)</p>
			<p class="source-code">struct input_dev *devm_input_allocate_device(</p>
			<p class="source-code">                                       struct device *dev)</p>
			<p class="source-code">void input_free_device(struct input_dev *dev)</p>
			<p class="source-code">int input_register_device(struct input_dev *dev)</p>
			<p class="source-code">void input_unregister_device(struct input_dev *dev)</p>
			<p>Device <a id="_idIndexMarker1484"/>allocation may sleep, so it must not be called in the atomic <a id="_idIndexMarker1485"/>context or with a spinlock being held. The following is an excerpt of the <strong class="source-inline">probe</strong> function of an input device sitting on the I2C bus:</p>
			<p class="source-code">struct input_dev *idev;</p>
			<p class="source-code">int error;</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * such allocation will take care of memory freeing and</p>
			<p class="source-code"> * device unregistering</p>
			<p class="source-code"> */</p>
			<p class="source-code">idev = devm_input_allocate_device(&amp;client-&gt;dev);</p>
			<p class="source-code">if (!idev)</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">idev-&gt;name = BMA150_DRIVER;</p>
			<p class="source-code">idev-&gt;phys = BMA150_DRIVER "/input0";</p>
			<p class="source-code">idev-&gt;id.bustype = BUS_I2C;</p>
			<p class="source-code">idev-&gt;dev.parent = &amp;client-&gt;dev;</p>
			<p class="source-code">set_bit(EV_ABS, idev-&gt;evbit);</p>
			<p class="source-code">input_set_abs_params(idev, ABS_X, ABSMIN_ACC_VAL,</p>
			<p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p>
			<p class="source-code">input_set_abs_params(idev, ABS_Y, ABSMIN_ACC_VAL,</p>
			<p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p>
			<p class="source-code">input_set_abs_params(idev, ABS_Z, ABSMIN_ACC_VAL,</p>
			<p class="source-code">                     ABSMAX_ACC_VAL, 0, 0);</p>
			<p class="source-code">error = input_register_device(idev);</p>
			<p class="source-code">if (error)</p>
			<p class="source-code">    return error;</p>
			<p class="source-code">error = devm_request_threaded_irq(&amp;client-&gt;dev,</p>
			<p class="source-code">            client-&gt;irq,</p>
			<p class="source-code">            NULL, my_irq_thread,</p>
			<p class="source-code">            IRQF_TRIGGER_RISING | IRQF_ONESHOT,</p>
			<p class="source-code">            BMA150_DRIVER, NULL);</p>
			<p class="source-code">if (error) {</p>
			<p class="source-code">    dev_err(&amp;client-&gt;dev, "irq request failed %d, </p>
			<p class="source-code">           error %d\n", client-&gt;irq, error);</p>
			<p class="source-code">    return error;</p>
			<p class="source-code">}</p>
			<p class="source-code">return 0;</p>
			<p>As you may have <a id="_idIndexMarker1486"/>noticed, in the preceding code, no memory freeing nor<a id="_idIndexMarker1487"/> device unregistering is performed when an error occurs because we have used the managed allocation for both the input device and the IRQ. That said, the input device has an IRQ line so that we're notified of a state change on the underlying device. This is not always the case as the system may lack available IRQ lines, in which case the input core will have to poll the device frequently so that it doesn't miss events. We discuss this in the next section.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor259"/>Using polled input devices</h1>
			<p>Polled input devices<a id="_idIndexMarker1488"/> are special input devices that rely on polling to sense device state changes; the generic input device type relies on IRQ to sense changes and send events to the input core.</p>
			<p>A polled input device is described in the kernel as an instance of <strong class="source-inline">struct input_polled_dev</strong> structure, which is a wrapper around the generic <strong class="source-inline">struct input_dev</strong> structure. The following is its declaration:</p>
			<p class="source-code">struct input_polled_dev {</p>
			<p class="source-code">    void *private;</p>
			<p class="source-code">    void (*open)(struct input_polled_dev *dev);</p>
			<p class="source-code">    void (*close)(struct input_polled_dev *dev);</p>
			<p class="source-code">    void (*poll)(struct input_polled_dev *dev);</p>
			<p class="source-code">    unsigned int poll_interval; /* msec */</p>
			<p class="source-code">    unsigned int poll_interval_max; /* msec */</p>
			<p class="source-code">    unsigned int poll_interval_min; /* msec */</p>
			<p class="source-code"> </p>
			<p class="source-code">    struct input_dev *input;</p>
			<p class="source-code">    bool devres_managed;</p>
			<p class="source-code">};</p>
			<p>Let's take a look at the <a id="_idIndexMarker1489"/>elements in this structure: </p>
			<ul>
				<li><strong class="source-inline">private</strong> is the driver's private data.</li>
				<li><strong class="source-inline">open</strong> is an optional method that prepares the device for polling (enables the device and sometimes flushes the device's state).</li>
				<li><strong class="source-inline">close</strong> is an optional method that is called when the device is no longer being polled. It is used to put devices into low power mode.</li>
				<li><strong class="source-inline">poll</strong> is a mandatory method that's called whenever the device needs to be polled. It is called at the frequency of <strong class="source-inline">poll_inteval</strong>.</li>
				<li><strong class="source-inline">poll_interval</strong> is the frequency at which the <strong class="source-inline">poll()</strong> method should be called. It defaults to 500 milliseconds unless it's overridden when you're registering the device.</li>
				<li><strong class="source-inline">poll_interval_max</strong> specifies the upper bound for the poll interval. It defaults to the initial value of <strong class="source-inline">poll_interval</strong>.</li>
				<li><strong class="source-inline">poll_interval_min</strong> specifies the lower bound for the poll interval. It defaults to 0.</li>
				<li><strong class="source-inline">input</strong> is the input device that the polled device is built around. It must be initialized by the driver (by its ID, name, and bits). The polled input device just provides an interface to use polling instead of IRQ, to sense device state change.</li>
			</ul>
			<p>Memory can be allocated for a polled input device using <strong class="source-inline">devm_input_allocate_polled_device()</strong>. This is a managed allocation API that takes care of freeing memory and unregistering the device as appropriate. Similarly, the non-managed API can be used for allocation, <strong class="source-inline">input_allocate_polled_device()</strong>, in which case you must take care of calling <strong class="source-inline">input_free_polled_device()</strong> by yourself. The following code shows the prototypes of those APIs:</p>
			<p class="source-code">struct input_polled_dev</p>
			<p class="source-code">     *devm_input_allocate_polled_device(</p>
			<p class="source-code">                                  struct device *dev)</p>
			<p class="source-code">struct input_polled_dev *input_allocate_polled_device(void)</p>
			<p class="source-code">void input_free_polled_device(struct </p>
			<p class="source-code">                               input_polled_dev *dev)</p>
			<p>For resource-managed devices, the <strong class="source-inline">input_dev-&gt;devres_managed</strong> field will be set to <strong class="source-inline">true</strong> by the input core. Then, you should take care of initializing the mandatory fields of the underlying <strong class="source-inline">struct input_dev</strong>, as we saw in the previous section. The polling interval must be set too; otherwise, it will default to 500 ms.</p>
			<p>Once the fields<a id="_idIndexMarker1490"/> have been allocated and initialized, the polled input device can be registered using <strong class="source-inline">input_register_polled_device()</strong>, which returns <strong class="source-inline">0</strong> on success. For managed allocation, unregistering is handled by the system; you need to call <strong class="source-inline">input_unregister_polled_device()</strong> by yourself to perform the reverse operation. The following are their prototypes:</p>
			<p class="source-code">int input_register_polled_device(</p>
			<p class="source-code">                        struct input_polled_dev *dev)</p>
			<p class="source-code">void  input_unregister_polled_device(</p>
			<p class="source-code">                        struct input_polled_dev *dev)</p>
			<p>A typical example of the <strong class="source-inline">probe()</strong> function for such a device may look as follows. First, we define the driver data structure, which will gather all the necessary resources: </p>
			<p class="source-code">struct my_struct {</p>
			<p class="source-code">    struct input_pulled_dev *polldev;</p>
			<p class="source-code">    struct gpio_desc *gpio_btn;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>Once the driver data structure has been defined, the <strong class="source-inline">probe()</strong> function can be implemented. The<a id="_idIndexMarker1491"/> following is its body:</p>
			<p class="source-code">static int button_probe(struct platform_device *pdev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct my_struct *ms;</p>
			<p class="source-code">    struct input_dev *input_dev;</p>
			<p class="source-code">    int error;</p>
			<p class="source-code">    struct device *dev = &amp;pdev-&gt;dev;</p>
			<p class="source-code">    ms = devm_kzalloc(dev, sizeof(*ms), GFP_KERNEL);</p>
			<p class="source-code">    if (!ms)</p>
			<p class="source-code">        return -ENOMEM;</p>
			<p class="source-code">    ms-&gt;polldev = devm_input_allocate_polled_device(dev);</p>
			<p class="source-code">    if (!ms-&gt;polldev)</p>
			<p class="source-code">        return -ENOMEM;</p>
			<p class="source-code">    /* This gpio is not mapped to IRQ */</p>
			<p class="source-code">    ms-&gt;gpio_btn = devm_gpiod_get(dev, "my-btn", GPIOD_IN);</p>
			<p class="source-code">    ms-&gt;polldev-&gt;private = ms;</p>
			<p class="source-code">    ms-&gt;polldev-&gt;poll = my_btn_poll;</p>
			<p class="source-code">    ms-&gt;polldev-&gt;poll_interval = 200;/* Poll every 200ms */</p>
			<p class="source-code">    ms-&gt;polldev-&gt;open = my_btn_open;</p>
			<p class="source-code">     /* Initializing the underlying input_dev fields */</p>
			<p class="source-code">    input_dev = ms-&gt;poll_dev-&gt;input;</p>
			<p class="source-code">    input_dev-&gt;name = "System Reset Btn";</p>
			<p class="source-code">    /* The gpio belongs to an expander sitting on I2C */</p>
			<p class="source-code">    input_dev-&gt;id.bustype = BUS_I2C; </p>
			<p class="source-code">    input_dev-&gt;dev.parent = dev;</p>
			<p class="source-code">    /* Declare the events generated by this driver */</p>
			<p class="source-code">    set_bit(EV_KEY, input_dev-&gt;evbit);</p>
			<p class="source-code">    set_bit(BTN_0, input_dev-&gt;keybit); /* buttons */</p>
			<p class="source-code">    retval = input_register_polled_device(ms-&gt;poll_dev);</p>
			<p class="source-code">    if (retval) {</p>
			<p class="source-code">        dev_err(dev, "Failed to register input device\n");</p>
			<p class="source-code">        return retval;  </p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Once again, neither <a id="_idIndexMarker1492"/>unregistering nor freeing are handled by ourselves when an error occurs because we have used managed allocations. </p>
			<p>The following is what our <strong class="source-inline">open</strong> callback may look like:</p>
			<p class="source-code">static void my_btn_open(struct input_polled_dev *poll_dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct my_strut *ms = poll_dev-&gt;private;</p>
			<p class="source-code">    dev_dbg(&amp;ms-&gt;poll_dev-&gt;input-&gt;dev, "reset open()\n");</p>
			<p class="source-code">}</p>
			<p>In our example, it does nothing. However, the <strong class="source-inline">open</strong> method is used to prepare the resources that are needed by the device.</p>
			<p>Deciding whether you should implement a polled input device is straightforward. The usual way is to use classic input devices if an IRQ line is available; alternatively, you can fall back to the polled device:</p>
			<p class="source-code">if(client-&gt;irq &gt; 0){</p>
			<p class="source-code">    /* Use generic input device */</p>
			<p class="source-code">} else {</p>
			<p class="source-code">    /* Use polled device */</p>
			<p class="source-code">}</p>
			<p>Other elements may <a id="_idIndexMarker1493"/>need to be considered when you're choosing between implementing a polled input device or an IRQ-based one; the preceding code is just a suggestion.</p>
			<p>Now that we are familiar with this subset of input devices, we can consider registering and unregistering input devices. That said, even though the input device has been registered, we can't interact with it yet. In the next section, we will learn how the input device can report events to the kernel.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor260"/>Generating and reporting input events</h1>
			<p>Device allocation and <a id="_idIndexMarker1494"/>registration are essential, but they are useless if the device is<a id="_idIndexMarker1495"/> unable to report events to the input core, which is what input devices are designed to do. Depending on the type of event our device can support, the kernel provides the appropriate APIs to report them to the core.</p>
			<p>Given an <strong class="source-inline">EV_XXX</strong> capable device, the corresponding report function would be <strong class="source-inline">input_report_xxx()</strong>. The following table shows the mappings between the most important event types and their report functions:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B17934_Table_01.jpg" alt="Table 17.1 – Mapping the input device's capabilities and the report APIs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 17.1 – Mapping the input device's capabilities and the report APIs</p>
			<p>The prototypes for<a id="_idIndexMarker1496"/> these report<a id="_idIndexMarker1497"/> APIs are as follows:</p>
			<p class="source-code">void input_report_abs(struct input_dev *dev,</p>
			<p class="source-code">                      unsigned int code, int value)</p>
			<p class="source-code">void input_report_key(struct input_dev *dev,</p>
			<p class="source-code">                      unsigned int code, int value)</p>
			<p class="source-code">void input_report_rel(struct input_dev *dev,</p>
			<p class="source-code">                      unsigned int code, int value)</p>
			<p>The list of available report functions can be found in <strong class="source-inline">include/linux/input.h</strong> in the kernel source file. They all have the same skeleton:</p>
			<ul>
				<li><strong class="source-inline">dev</strong> is the input device that's responsible for the event.</li>
				<li><strong class="source-inline">code</strong> represents the event code; for example, <strong class="source-inline">REL_X</strong> or <strong class="source-inline">KEY_BACKSPACE</strong>. The complete list can be found in <strong class="source-inline">include/linux/input-event-codes.h</strong>.</li>
				<li><strong class="source-inline">value</strong> is the value the event carries. For an <strong class="source-inline">EV_REL</strong> event type, it carries the relative change. For an <strong class="source-inline">EV_ABS</strong> (joysticks and so on) event type, it contains an absolute new value. For an <strong class="source-inline">EV_KEY</strong> event type, it should be set to <strong class="source-inline">0</strong> for key release, <strong class="source-inline">1</strong> for a keypress, and <strong class="source-inline">2</strong> for auto-repeat.</li>
			</ul>
			<p>Once all these<a id="_idIndexMarker1498"/> changes have been reported, the driver should call <strong class="source-inline">input_sync()</strong> on the input device to indicate that this event is complete. The input <a id="_idIndexMarker1499"/>subsystem will collect these events into a single packet and send it through <strong class="source-inline">/dev/input/event&lt;X&gt;</strong>, which is the character device that represents our <strong class="source-inline">struct input_dev</strong> on the system. Here, <strong class="source-inline">&lt;X&gt;</strong> is the interface number that's been assigned to the driver by the input core: </p>
			<p class="source-code">void input_sync(struct input_dev *dev)</p>
			<p>Let's look at an example of this. The following is an excerpt from the <strong class="bold">bma150</strong> digital acceleration sensors drivers in <strong class="source-inline">drivers/input/misc/bma150.c</strong>:</p>
			<p class="source-code">static void threaded_report_xyz(struct bma150_data *bma150)</p>
			<p class="source-code">{</p>
			<p class="source-code">  u8 data[BMA150_XYZ_DATA_SIZE];</p>
			<p class="source-code">  s16 x, y, z;</p>
			<p class="source-code">  s32 ret;</p>
			<p class="source-code">  ret = i2c_smbus_read_i2c_block_data(bma150-&gt;client,</p>
			<p class="source-code">                       BMA150_ACC_X_LSB_REG,</p>
			<p class="source-code">                       BMA150_XYZ_DATA_SIZE, data);</p>
			<p class="source-code">  if (ret != BMA150_XYZ_DATA_SIZE)</p>
			<p class="source-code">    return;</p>
			<p class="source-code">  x = ((0xc0 &amp; data[0]) &gt;&gt; 6) | (data[1] &lt;&lt; 2);</p>
			<p class="source-code">  y = ((0xc0 &amp; data[2]) &gt;&gt; 6) | (data[3] &lt;&lt; 2);</p>
			<p class="source-code">  z = ((0xc0 &amp; data[4]) &gt;&gt; 6) | (data[5] &lt;&lt; 2);</p>
			<p class="source-code">  /* sign extension */</p>
			<p class="source-code">  x = (s16) (x &lt;&lt; 6) &gt;&gt; 6;</p>
			<p class="source-code">  y = (s16) (y &lt;&lt; 6) &gt;&gt; 6;</p>
			<p class="source-code">  z = (s16) (z &lt;&lt; 6) &gt;&gt; 6;</p>
			<p class="source-code">  input_report_abs(bma150-&gt;input, ABS_X, x);</p>
			<p class="source-code">  input_report_abs(bma150-&gt;input, ABS_Y, y);</p>
			<p class="source-code">  input_report_abs(bma150-&gt;input, ABS_Z, z);</p>
			<p class="source-code">  /* Indicate this event is complete */</p>
			<p class="source-code">  input_sync(bma150-&gt;input);</p>
			<p class="source-code">}</p>
			<p>In the preceding excerpt, <strong class="source-inline">input_sync()</strong> tells the core to consider the three reports as the same event. This makes sense since the position has three axes (<em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em>) and we do not want <em class="italic">X</em>, <em class="italic">Y</em>, or <em class="italic">Z</em> to be reported separately.</p>
			<p>The best place <a id="_idIndexMarker1500"/>to report the event is inside the poll function for a<a id="_idIndexMarker1501"/> polled device or the IRQ routine (threaded part or not) for an IRQ-enabled device. If you perform some operations that may sleep, you should process your report inside the threaded part of the IRQ handler. The following code shows how our initial example could implement the <strong class="source-inline">poll</strong> method:</p>
			<p class="source-code">static void my_btn_poll(struct input_polled_dev *poll_dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct my_struct *ms = polldev-&gt;private;</p>
			<p class="source-code">    struct i2c_client *client = mcp-&gt;client;</p>
			<p class="source-code"> </p>
			<p class="source-code">    input_report_key(polldev-&gt;input, BTN_0,</p>
			<p class="source-code">                     gpiod_get_value(ms-&gt;rgpio_btn) &amp; 1);</p>
			<p class="source-code">    input_sync(poll_dev-&gt;input);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, our input <a id="_idIndexMarker1502"/>device reports the <strong class="source-inline">0</strong> key code. In the next section, we <a id="_idIndexMarker1503"/>will discuss how the user space can handle those report events and codes.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor261"/>Handling input devices from the user space</h1>
			<p>A node will be <a id="_idIndexMarker1504"/>created in the <strong class="source-inline">/dev/input/</strong> directory<a id="_idIndexMarker1505"/> for each input device (polled or not) that has been successfully registered with the system. In my case, the node corresponds to <strong class="source-inline">event0</strong> because it is the first and only input device on my target board. You can use the <strong class="source-inline">udevadm</strong> tool to display information about the device:</p>
			<p class="source-code"># udevadm info /dev/input/event0 </p>
			<p class="source-code">P: /devices/platform/input-button.0/input/input0/event0</p>
			<p class="source-code">N: input/event0</p>
			<p class="source-code">S: input/by-path/platform-input-button.0-event</p>
			<p class="source-code">E: DEVLINKS=/dev/input/by-path/platform-input-button.0-event</p>
			<p class="source-code">E: DEVNAME=/dev/input/event0</p>
			<p class="source-code">E: DEVPATH=/devices/platform/input-button.0/input/input0/event0</p>
			<p class="source-code">E: ID_INPUT=1</p>
			<p class="source-code">E: ID_PATH=platform-input-button.0</p>
			<p class="source-code">E: ID_PATH_TAG=platform-input-button_0</p>
			<p class="source-code">E: MAJOR=13</p>
			<p class="source-code">E: MINOR=64</p>
			<p class="source-code">E: SUBSYSTEM=input</p>
			<p class="source-code">E: USEC_INITIALIZED=74842430</p>
			<p>Another tool that <a id="_idIndexMarker1506"/>you can use, which allows you to print the<a id="_idIndexMarker1507"/> keys that are supported by the device, is <strong class="source-inline">evetest</strong>. It can also catch and print events when they are reported by the device. The following code shows its usage on our input device:</p>
			<p class="source-code"># evtest /dev/input/event0 </p>
			<p class="source-code">input device opened()</p>
			<p class="source-code">Input driver version is 1.0.1</p>
			<p class="source-code">Input device ID: bus 0x0 vendor 0x0 product 0x0 version 0x0</p>
			<p class="source-code">Input device name: "Packt Btn"</p>
			<p class="source-code">Supported events:</p>
			<p class="source-code">   Event type 0 (EV_SYN)</p>
			<p class="source-code">   Event type 1 (EV_KEY)</p>
			<p class="source-code">      Event code 256 (BTN_0)</p>
			<p>Not only the input devices we have written drivers for can be managed with <strong class="source-inline">evetest</strong>. In the following example, I am using the USB-C headset that's connected to my computer. It has input device capabilities since it provides volume-related keys:</p>
			<p class="source-code">jma@labcsmart-sqy:~$ sudo evtest /dev/input/event4</p>
			<p class="source-code">Input driver version is 1.0.1</p>
			<p class="source-code">Input device ID: bus 0x3 vendor 0x12d1 product 0x3a07 version 0x111</p>
			<p class="source-code">Input device name: "Synaptics HUAWEI USB-C HEADSET"</p>
			<p class="source-code">Supported events:</p>
			<p class="source-code">  Event type 0 (EV_SYN)</p>
			<p class="source-code">  Event type 1 (EV_KEY)</p>
			<p class="source-code">    Event code 114 (KEY_VOLUMEDOWN)</p>
			<p class="source-code">    Event code 115 (KEY_VOLUMEUP)</p>
			<p class="source-code">    Event code 164 (KEY_PLAYPAUSE)</p>
			<p class="source-code">    Event code 582 (KEY_VOICECOMMAND)</p>
			<p class="source-code">  Event type 4 (EV_MSC)</p>
			<p class="source-code">    Event code 4 (MSC_SCAN)</p>
			<p class="source-code">Properties:</p>
			<p class="source-code">Testing ... (interrupt to exit)</p>
			<p class="source-code">Event: time 1640231369.347093, type 4 (EV_MSC), code 4 (MSC_SCAN), value c00e9</p>
			<p class="source-code">Event: time 1640231369.347093, type 1 (EV_KEY), code 115 (KEY_VOLUMEUP), value 1</p>
			<p class="source-code">Event: time 1640231369.347093, -------------- SYN_REPORT ------------</p>
			<p class="source-code">Event: time 1640231369.487017, type 4 (EV_MSC), code 4 (MSC_SCAN), value c00e9</p>
			<p class="source-code">Event: time 1640231369.487017, type 1 (EV_KEY), code 115 (KEY_VOLUMEUP), value 0</p>
			<p class="source-code">Event: time 1640231369.487017, -------------- SYN_REPORT ------------</p>
			<p>In the preceding code, I pushed the up volume key to see how it is reported. <strong class="source-inline">evtest</strong> can even be used with your keyboard, with the only condition being that you identify the corresponding input device node in <strong class="source-inline">/dev/input/</strong>.</p>
			<p>As we have seen, every<a id="_idIndexMarker1508"/> registered input device is represented by a <strong class="source-inline">/dev/input/event&lt;X&gt;</strong> character device, which we can use to read the event from the user space. An application that's reading this file will receive event packets in the <strong class="source-inline">struct input_event</strong> format, which has the following declaration:</p>
			<p class="source-code">struct input_event {</p>
			<p class="source-code">  struct timeval time;</p>
			<p class="source-code">  __u16 type;</p>
			<p class="source-code">  __u16 code;</p>
			<p class="source-code">  __s32 value;</p>
			<p class="source-code">}</p>
			<p>Let's look at the <a id="_idIndexMarker1509"/>meaning of each element in the structure:</p>
			<ul>
				<li><strong class="source-inline">time</strong> is a <a id="_idIndexMarker1510"/>timestamp that corresponds to the time when the event happened.</li>
				<li><strong class="source-inline">type</strong> is the event type; for example, <strong class="source-inline">EV_KEY</strong> for a keypress or release, <strong class="source-inline">EV_REL</strong> for a relative moment, or <strong class="source-inline">EV_ABS</strong> for an absolute one. More types are defined in <strong class="source-inline">include/linux/input-event-codes.h</strong>.</li>
				<li><strong class="source-inline">code</strong> is the event code; for example, <strong class="source-inline">REL_X</strong> or <strong class="source-inline">KEY_BACKSPACE</strong>. Again, a complete list can be found in <strong class="source-inline">include/linux/input-event-codes.h</strong>.</li>
				<li><strong class="source-inline">value</strong> is the value that the event carries. For an <strong class="source-inline">EV_REL</strong> event type, it carries the relative change. For an <strong class="source-inline">EV_ABS</strong> (joysticks and so on) event type, it contains the absolute new value. For an <strong class="source-inline">EV_KEY</strong> event type, it is set to <strong class="source-inline">0</strong> for a key release, <strong class="source-inline">1</strong> for a keypress, and <strong class="source-inline">2</strong> for auto-repeat.</li>
			</ul>
			<p>A user space application can use blocking and non-blocking reads, but also <strong class="source-inline">poll()</strong> or <strong class="source-inline">select()</strong> system calls, to be notified of events after opening this device. The following is an example of the <strong class="source-inline">select()</strong> system call. Let's start by enumerating the headers we need to implement our example:</p>
			<p class="source-code">#include &lt;unistd.h&gt;</p>
			<p class="source-code">#include &lt;fcntl.h&gt;</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;linux/input.h&gt;</p>
			<p class="source-code">#include &lt;sys/select.h&gt;</p>
			<p>Then, we must define our input device path as a macro as it will be used often:</p>
			<p class="source-code">#define INPUT_DEVICE "/dev/input/event0"</p>
			<p class="source-code">int main(int argc, char **argv)</p>
			<p class="source-code">{   </p>
			<p class="source-code">    int fd, ret;</p>
			<p class="source-code">    struct input_event event;</p>
			<p class="source-code">    ssize_t bytesRead;</p>
			<p class="source-code">    fd_set readfds;</p>
			<p>Next, we must <a id="_idIndexMarker1511"/>open the input device and keep its file <a id="_idIndexMarker1512"/>descriptor for later use. Failing to open the input device is considered as an error, so we must exit the program:</p>
			<p class="source-code">    fd = open(INPUT_DEVICE, O_RDONLY);</p>
			<p class="source-code">    if(fd &lt; 0){</p>
			<p class="source-code">        fprintf(stderr,</p>
			<p class="source-code">             "Error opening %s for reading", INPUT_DEVICE);</p>
			<p class="source-code">        exit(EXIT_FAILURE);</p>
			<p class="source-code">    }</p>
			<p>Now, we have a file descriptor representing our opened input device. We can use the <strong class="source-inline">select()</strong> system call to sense any key press or release:</p>
			<p class="source-code">    while(1){ </p>
			<p class="source-code">        FD_ZERO(&amp;readfds);</p>
			<p class="source-code">        FD_SET(fd, &amp;readfds);</p>
			<p class="source-code">        ret = select(fd + 1, &amp;readfds, NULL, NULL, NULL);</p>
			<p class="source-code">        if (ret == -1) {</p>
			<p class="source-code">            fprintf(stderr,</p>
			<p class="source-code">                   "select call on %s: an error ocurred",</p>
			<p class="source-code">                    INPUT_DEVICE);</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        else if (!ret) { /* If we used timeout */</p>
			<p class="source-code">            fprintf(stderr,</p>
			<p class="source-code">                    "select on %s: TIMEOUT", INPUT_DEVICE);</p>
			<p class="source-code">            break;</p>
			<p class="source-code">        }</p>
			<p>At this point, we <a id="_idIndexMarker1513"/>have done the necessary sanity <a id="_idIndexMarker1514"/>checks on the return path of <strong class="source-inline">select()</strong>. Note that <strong class="source-inline">select()</strong> returns zero if it timed out before any file descriptors became ready, hence <strong class="source-inline">else if</strong> in the preceding code.</p>
			<p>The change is effective now, let's read the data to see what it corresponds to:</p>
			<p class="source-code">        /* File descriptor is now ready */</p>
			<p class="source-code">        if (FD_ISSET(fd, &amp;readfds)) {</p>
			<p class="source-code">            bytesRead = read(fd, &amp;event,</p>
			<p class="source-code">                             sizeof(struct input_event));</p>
			<p class="source-code">            if(bytesRead == -1)</p>
			<p class="source-code">                /* Process read input error*/</p>
			<p class="source-code">                [...]</p>
			<p class="source-code">            if(bytesRead != sizeof(struct input_event))</p>
			<p class="source-code">                /* Read value is not an input event */</p>
			<p class="source-code">                [...] /* handle this error */</p>
			<p>If the execution flow reaches this mean, it means that everything went well. Now, we can walk through<a id="_idIndexMarker1515"/> the events that are supported by our input<a id="_idIndexMarker1516"/> device and compare them to the event that is reported by the input core before a decision is made:</p>
			<p class="source-code">            /* We could have done a switch/case if we had</p>
			<p class="source-code">             * many codes to look for */</p>
			<p class="source-code">            if (event.code == BTN_0) {</p>
			<p class="source-code">                /* it concerns our button */</p>
			<p class="source-code">                if (event.value == 0) {</p>
			<p class="source-code">                    /* Process keyRelease if need be */</p>
			<p class="source-code">                    [...]</p>
			<p class="source-code">                }</p>
			<p class="source-code">                else if(event.value == 1){</p>
			<p class="source-code">                    /* Process KeyPress */</p>
			<p class="source-code">                    [...]</p>
			<p class="source-code">                }</p>
			<p class="source-code">            }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    close(fd);</p>
			<p class="source-code">    return EXIT_SUCCESS;</p>
			<p class="source-code">}</p>
			<p>For further debugging purposes, if your input device is based on GPIOs, you can successively push/release the button and check whether the GPIO's state has changed:</p>
			<p class="source-code"># cat /sys/kernel/debug/gpio  | grep button</p>
			<p class="source-code"> gpio-195 (gpio-btn         ) in  hi    </p>
			<p class="source-code"># cat /sys/kernel/debug/gpio  | grep button</p>
			<p class="source-code"> gpio-195 (gpio-btn         ) in  lo</p>
			<p>Moreover, if<a id="_idIndexMarker1517"/> the input device has an IRQ line, it may make <a id="_idIndexMarker1518"/>sense to check the statistic for this IRQ line to make sure it is coherent. For example, here, we must check whether the request has succeeded and how many times it has been fired:</p>
			<p class="source-code"># cat /proc/interrupts | grep packt</p>
			<p class="source-code">160:      0      0      0      0  gpio-mxc   0  packt-input-button</p>
			<p>In this section, we learned how to deal with the input device from the user space and provided some debugging tips for when something goes wrong. We used the <strong class="source-inline">select()</strong> system call to sense input events, though we could have used <strong class="source-inline">poll()</strong> as well.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor262"/>Summary</h1>
			<p>This chapter described the input framework and highlighted the difference between polled and interrupt-driven input devices. At this point, you should have the necessary knowledge to write a driver for any input driver, whatever its type, and whatever input event it supports. The user space interface was also discussed, and an example was provided. </p>
		</div>
	</body></html>