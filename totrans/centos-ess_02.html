<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Getting Started with etcd" id="aid-H5A41"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Getting Started with etcd</h1></div></div></div><p>In this chapter, we will cover <code class="literal">etcd</code>, CoreOS's central hub of services, which provides a reliable way of storing shared data across cluster machines and monitoring it.</p><p>For testing, we will use our already installed CoreOS VM from the previous chapter. In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Introducing <code class="literal">etcd</code></li><li class="listitem">Reading and writing to <code class="literal">etcd</code> from the host machine</li><li class="listitem">Reading and writing from an application container</li><li class="listitem">Watching changes in <code class="literal">etcd</code></li><li class="listitem">TTL (Time to Live) examples</li><li class="listitem">Use cases of <code class="literal">etcd</code></li></ul></div><div class="section" title="Introducing etcd"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Introducing etcd</h1></div></div></div><p>The <code class="literal">etcd</code> function is<a id="id17" class="indexterm"/> an open source distributed key value store on a computer network where information is stored on more than one node and data is replicated using the Raft consensus algorithm. The <code class="literal">etcd</code> function is used to store the CoreOS cluster service discovery and the shared configuration.</p><p>The configuration is stored in the write-ahead log and includes the cluster member ID, cluster ID and cluster configuration, and is accessible by all cluster members.</p><p>The <code class="literal">etcd</code> function runs on each cluster's central services role machine, and gracefully handles master election during network partitions and in the event of a loss of the current master.</p></div></div>
<div class="section" title="Reading and writing to etcd from the host machine" id="aid-I3QM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Reading and writing to etcd from the host machine</h1></div></div></div><p>You are going to learn how<a id="id18" class="indexterm"/> read and write to <code class="literal">ectd</code> from the host<a id="id19" class="indexterm"/> machine. We will use both the <code class="literal">etcdctl</code> and <code class="literal">curl</code> examples here.</p><div class="section" title="Logging in to the host"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Logging in to the host</h2></div></div></div><p>To log in to <a id="id20" class="indexterm"/>CoreOS VM, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Boot the CoreOS VM installed in the first chapter. In your terminal, type this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cdcoreos-vagrant</strong></span>
<span class="strong"><strong>$ vagrant up</strong></span>
</pre></div></li><li class="listitem">We need to log in to the host via <code class="literal">ssh</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vagrant ssh</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Reading and writing to ectd"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Reading and writing to ectd</h2></div></div></div><p>Let's read and <a id="id21" class="indexterm"/>write to <code class="literal">etcd</code><a id="id22" class="indexterm"/> using <code class="literal">etcdctl</code>. So, perform these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set a <code class="literal">message1</code> key with <code class="literal">etcdctl</code> with <code class="literal">Book1 </code>as the value:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl set /message1 Book1</strong></span>
<span class="strong"><strong>Book1 (we got respond for our successful write to etcd)</strong></span>
</pre></div></li><li class="listitem">Now, let's read the key value to double-check whether everything is fine there:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl get /message1</strong></span>
<span class="strong"><strong>Book1</strong></span>
<span class="strong"><strong>Perfect!</strong></span>
</pre></div></li><li class="listitem">Next, let's try to do the same using <code class="literal">curl</code> via an HTTP-based API. The <code class="literal">curl </code>function is handy for accessing <code class="literal">etcd</code> from any place from where you have access to an <code class="literal">etcd</code> cluster but don't want/need to use the <code class="literal">etcdctl</code> client:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -L -X PUT http://127.0.0.1:2379/v2/keys/message2 -d value="Book2"</strong></span>
<span class="strong"><strong>{"action":"set","key":"/message2","prevValue":"Book1","value":"Book2","index":13371}</strong></span>
</pre></div><p>Let's read it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ curl -L http://127.0.0.1:2379/v2/keys/message2</strong></span>
<span class="strong"><strong>{"action":"get","node":{"key":"/message2","value":"Book2","modifiedIndex":13371,"createdIndex":13371}}</strong></span>
</pre></div><p>Using the HTTP-based <code class="literal">etcd</code> API means that <code class="literal">etcd</code> can be read from and written to by client applications without the need to interact with the command line.</p></li><li class="listitem">Now, if we want to delete the key-value pair, we type the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl rm /message1</strong></span>
<span class="strong"><strong>$ curl -L -X DELETE http://127.0.0.1:2379/v2/keys/message2</strong></span>
</pre></div></li><li class="listitem">Also, we can add a key value pair to a directory, as directories are created automatically<a id="id23" class="indexterm"/> when a key is placed inside. We only need one command to<a id="id24" class="indexterm"/> put a key inside a directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl set /foo-directory/foo-key somekey</strong></span>
</pre></div></li><li class="listitem">Let's now check the directory's content:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl ls /foo-directory –recursive</strong></span>
<span class="strong"><strong>/foo-directory/foo-key</strong></span>
</pre></div></li><li class="listitem">Finally, we get the key value from the directory by typing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl get /foo-directory/foo-key</strong></span>
<span class="strong"><strong>somekey</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div></div>
<div class="section" title="Reading and writing from the application container" id="aid-J2B81"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Reading and writing from the application container</h1></div></div></div><p>Usually, application <a id="id25" class="indexterm"/>containers (this is a general term for <code class="literal">docker</code>, <code class="literal">rkt</code>, and other types of containers) do not have <code class="literal">etcdctl</code> or even <code class="literal">curl</code> installed by default. Installing <code class="literal">curl</code> is much easier than installing <code class="literal">etcdctl</code>.</p><p>For our example, we<a id="id26" class="indexterm"/> will use the Alpine Linux docker image, which is very small in size and will not take much time to pull from the <code class="literal">docker</code> registry:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Firstly, we need to check the <code class="literal">docker0</code> interface IP, which we will use with <code class="literal">curl</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo"$(ifconfig docker0 | awk'/\&lt;inet\&gt;/ { print $2}'):2379"</strong></span>
<span class="strong"><strong>10.1.42.1:2379</strong></span>
</pre></div></li><li class="listitem">Let's run the <code class="literal">docker</code> container with a <code class="literal">bash</code> shell:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker run -it alpine ash</strong></span>
</pre></div><p>We should see something like this in Command Prompt:<code class="literal">/ #</code>.</p></li><li class="listitem">As <code class="literal">curl</code> is not installed by default on Alpine Linux, we need to install it:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ apk update&amp;&amp;apk add curl</strong></span>
<span class="strong"><strong>$ curl -L http://10.1.42.1:2379/v2/keys/</strong></span>
<span class="strong"><strong>{"action":"get","node":{"key":"/","dir":true,"nodes":[{"key":"/coreos.com","dir":true,"modifiedIndex":3,"createdIndex":3}]}}</strong></span>
</pre></div></li><li class="listitem">Repeat steps 3 and 4 from the previous subtopic so that you understand that no matter where you <a id="id27" class="indexterm"/>are connecting to <code class="literal">etcd</code> from, <code class="literal">curl</code> still works in the same way.</li><li class="listitem">Press <span class="emphasis"><em>Ctrl</em></span> +<span class="emphasis"><em>D</em></span> to exit from<a id="id28" class="indexterm"/> the <code class="literal">docker</code> container.</li></ol><div style="height:10px; width: 1px"/></div></div>
<div class="section" title="Watching changes in etcd" id="aid-K0RQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Watching changes in etcd</h1></div></div></div><p>This time, let's watch the key changes in <code class="literal">etcd</code>. Watching key changes is useful when we have, for example, one<a id="id29" class="indexterm"/> <code class="literal">fleet</code> unit with <code class="literal">nginx</code> writing its port to <code class="literal">etcd</code>, and another reverse proxy application watching for changes and updating its configuration:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We need to create a directory in <code class="literal">etcd</code> first:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctlmkdir /foo-data</strong></span>
</pre></div></li><li class="listitem">Next, we watch for changes in this directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl watch /foo-data--recursive</strong></span>
</pre></div></li><li class="listitem">Now open another CoreOS shell in a new terminal window:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cdcoreos-vagrant</strong></span>
<span class="strong"><strong>$ vagrantssh</strong></span>
</pre></div></li><li class="listitem">We add a new key to the <code class="literal">/foo-data</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl set /foo-data/Book is_cool</strong></span>
</pre></div></li><li class="listitem">In the first terminal, we should see a notification saying that the key was changed:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>is_cool</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div>
<div class="section" title="TTL (time to live) examples" id="aid-KVCC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>TTL (time to live) examples</h1></div></div></div><p>Sometimes, it is handy to <a id="id30" class="indexterm"/>put a <span class="strong"><strong>time to live</strong></span> (<span class="strong"><strong>TTL</strong></span>) for a key to expire in a certain amount of time. This is useful, for example, in the case of watching a key with a 60 second TTL, from a reverse proxy. So, if the <code class="literal">nginx fleet</code> service has not updated the key, it will expire in 60 seconds and will be removed from <code class="literal">etcd</code>. Then the reverse proxy checks for it and does not find it. Hence, it will remove the <code class="literal">nginx</code> service from <code class="literal">config</code>.</p><p>Let's set a TTL of 30 seconds in this example:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Type this in a terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl set /foo "I'm Expiring in 30 sec" --ttl 30</strong></span>
<span class="strong"><strong>I'm Expiring in 30 sec</strong></span>
</pre></div></li><li class="listitem">Verify that the key is still there:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl get /foo</strong></span>
<span class="strong"><strong>I'm Expiring in 30 sec</strong></span>
</pre></div></li><li class="listitem">Check again after 30 seconds :<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ etcdctl get /foo</strong></span>
</pre></div></li><li class="listitem">If your requested key has already expired, you will be returned <code class="literal">Error</code>: <code class="literal">100</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Error: 100: Key not found (/foo) [17053]</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>This time the key got<a id="id31" class="indexterm"/> deleted by <code class="literal">etcd</code> because we put a TTL of 30 seconds for it.</p><div class="note" title="Note"><h3 class="title"><a id="note03"/>Note</h3><p>TTL is very handy to use to communicate between the different services using <code class="literal">etcd</code> as the checking point.</p></div></div>
<div class="section" title="Use cases of etcd" id="aid-LTSU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Use cases of etcd</h1></div></div></div><p>Application <a id="id32" class="indexterm"/>containers running on worker nodes with <code class="literal">etcd</code> in proxy mode can read and write to an <code class="literal">etcd</code> cluster.</p><p>Very common <code class="literal">etcd</code> use cases are as follows: storing database connection settings, cache settings, and shared settings. For example, the <a id="id33" class="indexterm"/>Vulcand proxy server (<a class="ulink" href="http://vulcanproxy.com/">http://vulcanproxy.com/</a>) uses <code class="literal">etcd</code> to store web host connection details, and it becomes available for all cluster-connected worker machines. Another example could be to store a database password for MySQL and retrieve it when running an application container.</p><p>We will cover more details about cluster setup, central services, and worker role machines in the upcoming chapters.</p></div>
<div class="section" title="Summary" id="aid-MSDG1"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>In this short chapter, we covered the basics of <code class="literal">etcd</code> and how to read and write to <code class="literal">etcd</code>, watch for changes in <code class="literal">etcd</code>, and use TTL for <code class="literal">etcd</code> keys.</p><p>In the next chapter, you will learn how to use the <code class="literal">systemd</code> and <code class="literal">fleet</code> units.</p></div></body></html>