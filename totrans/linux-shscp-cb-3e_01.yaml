- en: Shell Something Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 做一些事
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Displaying output in a terminal
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中显示输出
- en: Using variables and environment variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量和环境变量
- en: Function to prepend to environment variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向环境变量添加前缀的函数
- en: Math with the shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 shell 进行数学运算
- en: Playing with file descriptors and redirection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转文件描述符与重定向
- en: Arrays and associative arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和关联数组
- en: Visiting aliases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问别名
- en: Grabbing information about the terminal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关终端的信息
- en: Getting and setting dates and delays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置日期与延迟
- en: Debugging the script
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试脚本
- en: Functions and arguments
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数与参数
- en: Sending output from one command to another
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个命令的输出发送到另一个命令
- en: Reading `n` characters without pressing the return key
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不按回车键的情况下读取 `n` 个字符
- en: Running a command until it succeeds
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一直运行命令直到成功
- en: Field separators and iterators
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段分隔符和迭代器
- en: Comparisons and tests
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较与测试
- en: Customizing bash with configuration files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过配置文件自定义 bash
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the beginning, computers read a program from cards or tape and generated
    a single report. There was no operating system, no graphics monitors, not even
    an interactive prompt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，计算机通过读取卡片或磁带中的程序并生成单个报告来工作。当时没有操作系统、图形显示器，甚至没有交互式提示符。
- en: By the 1960s, computers supported interactive terminals (frequently a teletype
    or glorified typewriter) to invoke commands.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到了 1960 年代，计算机支持交互式终端（通常是电传打字机或升级版打字机）来调用命令。
- en: When Bell Labs created an interactive user interface for the brand new Unix
    operating system, it had a unique feature. It could read and evaluate the same
    commands from a text file (called a shell script), as it accepted being typed
    on a terminal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当贝尔实验室为全新的 Unix 操作系统创建交互式用户界面时，它具有一个独特的功能。它能够读取和评估来自文本文件（称为 shell 脚本）的相同命令，就像它接受从终端键入的命令一样。
- en: This facility was a huge leap forward in productivity. Instead of typing several
    commands to perform a set of operations, programmers could save the commands in
    a file and run them later with just a few keystrokes. Not only does a shell script
    save time, it also documents what you did.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在生产力上是一次巨大的飞跃。程序员无需输入多个命令来执行一组操作，而是可以将命令保存在文件中，并只需通过几次按键就能运行它们。Shell 脚本不仅节省了时间，还记录了你所做的操作。
- en: Initially, Unix supported one interactive shell, written by Stephen Bourne,
    and named it the **Bourne Shell** (**sh**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Unix 只支持一个交互式 shell，由 Stephen Bourne 编写，并命名为 **Bourne Shell**（**sh**）。
- en: In 1989, Brian Fox of the GNU Project took features from many user interfaces
    and created a new shell—the **Bourne Again Shell** (**bash**). The bash shell
    understands all of the Bourne shell constructs and adds features from csh, ksh,
    and others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 1989 年，GNU 项目的 Brian Fox 从许多用户界面中借鉴了特性，并创建了一个新的 shell —— **Bourne Again Shell**（**bash**）。bash
    shell 理解所有 Bourne shell 的构造，并添加了来自 csh、ksh 和其他 shell 的特性。
- en: As Linux has become the most popular implementation of Unix like operating systems,
    the bash shell has become the de-facto standard shell on Unix and Linux.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Linux 成为最流行的类 Unix 操作系统实现，bash shell 已成为 Unix 和 Linux 的事实标准 shell。
- en: This book focuses on Linux and bash. Even so, most of these scripts will run
    on both Linux and Unix, using bash, sh, ash, dash, ksh, or other sh style shells.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书聚焦于 Linux 和 bash。尽管如此，大多数脚本可以在 Linux 和 Unix 上运行，使用 bash、sh、ash、dash、ksh 或其他
    sh 风格的 shell。
- en: This chapter will give readers an insight into the shell environment and demonstrate
    some basic shell features.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为读者提供关于 shell 环境的洞察，并演示一些基本的 shell 特性。
- en: Displaying output in a terminal
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在终端中显示输出
- en: Users interact with the shell environment via a terminal session. If you are
    running a GUI-based system, this will be a terminal window. If you are running
    with no GUI, (a production server or ssh session), you will see the shell prompt
    as soon as you log in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过终端会话与 shell 环境进行交互。如果你使用的是基于 GUI 的系统，那么显示的将是一个终端窗口。如果你在没有 GUI 的环境下工作（例如生产服务器或
    ssh 会话），你一登录就会看到 shell 提示符。
- en: Displaying text in the terminal is a task most scripts and utilities need to
    perform regularly. The shell supports several methods and different formats for
    displaying text.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中显示文本是大多数脚本和实用工具需要定期执行的任务。Shell 支持多种方法和不同格式来显示文本。
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Commands are typed and executed in a terminal session. When a terminal is opened,
    a prompt is displayed. The prompt can be configured in many ways, but frequently
    resembles this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在终端会话中输入并执行。当终端被打开时，会显示一个提示符。提示符可以通过多种方式进行配置，但通常如下所示：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, it can also be configured as `root@hostname #` or simply as
    `$` or `#`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '另外，也可以将其配置为 `root@hostname #`，或者仅仅是 `$` 或 `#`。'
- en: The `$` character represents regular users and `#` represents the administrative
    user root. Root is the most privileged user in a Linux system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 字符代表普通用户，`#` 代表管理员用户 root。Root 是 Linux 系统中权限最高的用户。'
- en: It is a bad idea to directly use the shell as the root user (administrator)
    to perform tasks. Typing errors have the potential to do more damage when your
    shell has more privileges. It is recommended that you log in as a regular user
    (your shell may denote this as `$` in the prompt), and use tools such as `sudo`
    to run privileged commands. Running a command as `sudo <command> <arguments>`
    will run it as root.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 直接以根用户（管理员）身份使用 shell 执行任务是一个不好的主意。因为当你的 shell 拥有更多权限时，输入错误可能会造成更大的损害。建议以普通用户身份登录（你的
    shell 提示符可能会显示为 `$`），并使用像 `sudo` 这样的工具来执行特权命令。使用 `sudo <command> <arguments>`
    以 root 身份运行命令。
- en: 'A shell script typically begins with a shebang:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 shell 脚本通常以 shebang 开头：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Shebang is a line on which `#!` is prefixed to the interpreter path. `/bin/bash`
    is the interpreter command path for Bash. A line starting with a `#` symbol is
    treated by the bash interpreter as a comment. Only the first line of a script
    can have a shebang to define the interpreter to be used to evaluate the script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang 是一行，在该行前缀加上 `#!`，后面跟着解释器路径。`/bin/bash` 是 Bash 的解释器命令路径。以 `#` 符号开头的行被
    bash 解释器视为注释。只有脚本的第一行可以包含 shebang 来定义用于评估脚本的解释器。
- en: 'A script can be executed in two ways:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以通过两种方式执行：
- en: 'Pass the name of the script as a command-line argument:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本名称作为命令行参数传递：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the execution permission on a script file to make it executable:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置脚本文件的执行权限，使其可以执行：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If a script is run as a command-line argument for `bash`, the shebang is not
    required. The shebang facilitates running the script on its own. Executable scripts
    use the interpreter path that follows the shebang to interpret a script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本作为 `bash` 的命令行参数运行，则不需要 shebang。shebang 使得脚本可以独立运行。可执行脚本使用 shebang 后面的解释器路径来解释脚本。
- en: 'Scripts are made executable with the `chmod` command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过 `chmod` 命令使其可执行：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command makes a script executable by all users. The script can be executed
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使得脚本对所有用户可执行。脚本可以按如下方式执行：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, the script can be executed like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，脚本也可以像这样执行：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The kernel will read the first line and see that the shebang is `#!/bin/bash`.
    It will identify `/bin/bash` and execute the script as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内核会读取第一行，看到 shebang 为 `#!/bin/bash`，它会识别 `/bin/bash` 并按如下方式执行脚本：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When an interactive shell starts, it executes a set of commands to initialize
    settings, such as the prompt text, colors, and so on. These commands are read
    from a shell script at `~/.bashrc` (or `~/.bash_profile` for login shells), located
    in the home directory of the user. The Bash shell maintains a history of commands
    run by the user in the `~/.bash_history` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当交互式 shell 启动时，它会执行一组命令来初始化设置，例如提示文本、颜色等。这些命令从位于用户家目录中的 `~/.bashrc`（或登录 shell
    时的 `~/.bash_profile`）脚本中读取。Bash shell 会在 `~/.bash_history` 文件中保存用户运行的命令历史记录。
- en: The `~` symbol denotes your home directory, which is usually `/home/user`, where
    user is your username or `/root` for the root user. A login shell is created when
    you log in to a machine. However, terminal sessions you create while logged in
    to a graphical environment (such as GNOME, KDE, and so on), are not login shells. Logging
    in with a display manager such as GDM or KDM may not read a `.profile` or `.bash_profile`
    (most don't), but logging in to a remote system with ssh will read the `.profile`. The
    shell delimits each command or command sequence with a semicolon or a new line.
    Consider this example: `$ cmd1 ; cmd2`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`~` 符号表示你的家目录，通常是 `/home/user`，其中 `user` 是你的用户名，或者是 `/root`，对于 root 用户。登录 shell
    在你登录计算机时会创建。然而，在图形化环境中登录后创建的终端会话（如 GNOME、KDE 等）并不是登录 shell。通过显示管理器（如 GDM 或 KDM）登录时，可能不会读取
    `.profile` 或 `.bash_profile`（大多数不会），但通过 ssh 登录远程系统时会读取 `.profile`。shell 通过分号或新的一行来分隔每个命令或命令序列。请看这个例子：`$
    cmd1 ; cmd2`'
- en: 'This is equivalent to these:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下内容：
- en: '`$ cmd1`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cmd1`'
- en: '`$ cmd2`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ cmd2`'
- en: 'A comment starts with `#` and proceeds up to the end of the line. The comment
    lines are most often used to describe the code, or to disable execution of a line
    of code during debugging:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注释以`#`开始，并持续到行尾。注释行通常用于描述代码，或在调试时禁用某行代码的执行：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's move on to the basic recipes in this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续学习本章的基本示例。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The `echo` command is the simplest command for printing in the terminal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令是终端中最简单的打印命令。'
- en: 'By default, `echo` adds a newline at the end of every echo invocation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`echo`在每次调用后会添加换行符：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Simply, using double-quoted text with the `echo` command prints the text in
    the terminal. Similarly, text without double quotes also gives the same output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，使用双引号括起来的文本和`echo`命令一起打印文本到终端。类似地，未使用双引号的文本也会输出相同的结果：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another way to do the same task is with single quotes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种完成相同任务的方法是使用单引号：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These methods appear similar, but each has a specific purpose and side effects.
    Double quotes allow the shell to interpret special characters within the string.
    Single quotes disable this interpretation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法看起来相似，但每个方法都有特定的用途和副作用。双引号允许shell解释字符串中的特殊字符。单引号则禁用这种解释。
- en: 'Consider the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下命令：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This returns the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you need to print special characters such as `!`, you must either not use
    any quotes, use single quotes, or escape the special characters with a backslash
    (`\`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要打印像`!`这样的特殊字符，必须要么不使用任何引号，要么使用单引号，或者用反斜杠（`\`）转义特殊字符：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, use this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用这个：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, it can be used like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以这样使用：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When using `echo` without quotes, we cannot use a semicolon, as a semicolon
    is the delimiter between commands in the Bash shell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不带引号的`echo`时，不能使用分号，因为分号是Bash shell中命令之间的分隔符：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From the preceding line, Bash takes `echo hello` as one command and the second
    `hello` as the second command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的行来看，Bash将`echo hello`视为一个命令，第二个`hello`视为另一个命令。
- en: Variable substitution, which is discussed in the next recipe, will not work
    within single quotes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中讨论的变量替换，在单引号内将不起作用。
- en: 'Another command for printing in the terminal is `printf`. It uses the same
    arguments as the C library `printf` function. Consider this example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在终端中打印的命令是`printf`。它使用与C库中的`printf`函数相同的参数。请考虑以下示例：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `printf` command takes quoted text or arguments delimited by spaces. It supports
    formatted strings. The format string specifies string width, left or right alignment,
    and so on. By default, `printf` does not append a newline. We have to specify
    a newline when required, as shown in the following script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`命令接受用引号括起来的文本或由空格分隔的参数。它支持格式化字符串。格式字符串指定了字符串宽度、左对齐或右对齐等。默认情况下，`printf`不会附加换行符。当需要时，我们必须显式地指定换行符，如以下脚本所示：'
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will receive the following formatted output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到以下格式化输出：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `%s`, `%c`, `%d`, and `%f` characters are format substitution characters,
    which define how the following argument will be printed. The `%-5s` string defines
    a string substitution with left alignment (`-` represents left alignment) and
    a `5` character width. If `-` was not specified, the string would have been aligned
    to the right. The width specifies the number of characters reserved for the string.
    For `Name`, the width reserved is `10`. Hence, any name will reside within the
    10-character width reserved for it and the rest of the line will be filled with
    spaces up to 10 characters total.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s`、`%c`、`%d`和`%f`字符是格式替换字符，用于定义后续参数的打印方式。`%-5s`字符串定义了一个左对齐的字符串替换（`-`表示左对齐），并且字符宽度为`5`。如果没有指定`-`，字符串将会右对齐。宽度指定了为字符串保留的字符数。对于`Name`，保留的宽度是`10`。因此，任何名称都会位于为其保留的10个字符宽度内，剩余部分将填充空格，直到总共有10个字符。'
- en: For floating point numbers, we can pass additional parameters to round off the
    decimal places.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，我们可以传递附加参数来四舍五入小数位数。
- en: For the Mark section, we have formatted the string as `%-4.2f`, where `.2` specifies
    rounding off to two decimal places. Note that for every line of the format string,
    a newline (`\n`) is issued.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Mark部分，我们将字符串格式化为`%-4.2f`，其中`.2`表示四舍五入到小数点后两位。请注意，对于每一行的格式化字符串，都会发出一个换行符（`\n`）。
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While using flags for `echo` and `printf`, place the flags before any strings
    in the command, otherwise Bash will consider the flags as another string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`echo`和`printf`的标志时，应将标志放在命令中的任何字符串之前，否则Bash会将标志视为另一个字符串。
- en: Escaping newline in echo
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在echo中转义换行符
- en: 'By default, `echo` appends a newline to the end of its output text. Disable
    the newline with the `-n` flag. The `echo` command accepts escape sequences in
    double-quoted strings as an argument. When using escape sequences, use `echo`
    as `echo -e "string containing escape sequences"`. Consider the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`echo`会在输出文本的末尾附加一个换行符。使用`-n`标志可以禁用换行符。`echo`命令接受双引号字符串作为参数，并可以处理转义序列。使用转义序列时，使用`echo`命令为`echo
    -e "包含转义序列的字符串"`。考虑以下示例：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Printing a colored output
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印彩色输出
- en: A script can use escape sequences to produce colored text on the terminal.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以使用转义序列在终端上生成彩色文本。
- en: Colors for text are represented by color codes, including, reset = 0, black
    = 30, red = 31, green = 32, yellow = 33, blue = 34, magenta = 35, cyan = 36, and
    white = 37.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的颜色由颜色代码表示，包括reset = 0，black = 30，red = 31，green = 32，yellow = 33，blue = 34，magenta
    = 35，cyan = 36，white = 37。
- en: 'To print colored text, enter the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印彩色文本，请输入以下命令：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `\e[1;31m` is the escape string to set the color to red and `\e[0m` resets
    the color back. Replace `31` with the required color code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`\e[1;31m`是设置颜色为红色的转义字符串，而`\e[0m`将颜色重置。将`31`替换为所需的颜色代码。
- en: For a colored background, reset = 0, black = 40, red = 41, green = 42, yellow
    = 43, blue = 44, magenta = 45, cyan = 46, and white=47, are the commonly used
    color codes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于彩色背景，reset = 0，black = 40，red = 41，green = 42，yellow = 43，blue = 44，magenta
    = 45，cyan = 46，white = 47，是常用的颜色代码。
- en: 'To print a colored background, enter the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印彩色背景，请输入以下命令：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These examples cover a subset of escape sequences. The documentation can be
    viewed with `man console_codes`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例涵盖了部分转义序列。文档可以通过`man console_codes`查看。
- en: Using variables and environment variables
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量和环境变量
- en: All programming languages use variables to retain data for later use or modification.
    Unlike compiled languages, most scripting languages do not require a type declaration
    before a variable is created. The type is determined by usage. The value of a
    variable is accessed by preceding the variable name with a dollar sign. The shell
    defines several variables it uses for configuration and information like available
    printers, search paths, and so on. These are called **environment variables**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言都使用变量来保存数据，以便稍后使用或修改。与编译语言不同，大多数脚本语言在创建变量之前不需要声明类型。类型由使用情况决定。通过在变量名前加上美元符号来访问变量的值。Shell定义了多个它用于配置和信息的变量，例如可用的打印机、搜索路径等。这些被称为**环境变量**。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: Variables are named as a sequence of letters, numbers, and underscores with
    no whitespace. Common conventions are to use UPPER_CASE for environment variables
    and camelCase or lower_case for variables used within a script.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名规则是字母、数字和下划线的组合，不允许有空格。常见的约定是环境变量使用大写字母（UPPER_CASE），而在脚本中使用的变量使用驼峰命名法或小写字母（camelCase或lower_case）。
- en: 'All applications and scripts can access the environment variables. To view
    all the environment variables defined in your current shell, issue the `env` or
    `printenv` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序和脚本都可以访问环境变量。要查看当前Shell中定义的所有环境变量，请执行`env`或`printenv`命令：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To view the environment of other processes, use the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其他进程的环境，请使用以下命令：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Set `PID` with a process ID of the process (`PID` is an integer value).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`PID`为进程的进程ID（`PID`是一个整数值）。
- en: 'Assume an application called `gedit` is running. We obtain the process ID of
    `gedit` with the `pgrep` command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个名为`gedit`的应用程序正在运行。我们通过`pgrep`命令获取`gedit`的进程ID：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We view the environment variables associated with the process by executing
    the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行以下命令查看与进程相关的环境变量：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that the previous output has many lines stripped for convenience. The actual
    output contains more variables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的输出有许多行被去除以方便阅读。实际输出包含更多的变量。
- en: The `/proc/PID/environ` special file contains a list of environment variables
    and their values. Each variable is represented as a name=value pair, separated
    by a null character (`\0`). This is not easily human readable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/PID/environ`特殊文件包含环境变量及其值的列表。每个变量以name=value对的形式表示，两个部分之间由空字符（`\0`）分隔。这对于人类来说并不容易阅读。'
- en: 'To make a human-friendly report, pipe the output of the `cat` command to `tr`,
    to substitute the `\0` character with `\n`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成易于阅读的报告，可以将`cat`命令的输出通过管道传递给`tr`，将`\0`字符替换为`\n`：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'Assign a value to a variable with the equal sign operator:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用等号操作符为变量赋值：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The name of the variable is `varName` and `value` is the value to be assigned
    to it. If `value` does not contain any space character (such as space), it need
    not be enclosed in quotes, otherwise it must be enclosed in single or double quotes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称是`varName`，`value`是要赋给它的值。如果`value`中不包含空格字符（如空格），则不需要用引号括起来；否则，必须用单引号或双引号括起来。
- en: Note that `var = value` and `var=value` are different. It is a usual mistake
    to write `var = value` instead of `var=value`. An equal sign without spaces is
    an assignment operation, whereas using spaces creates an equality test.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`var = value`和`var=value`是不同的。将`var = value`写成`var=value`是常见错误。没有空格的等号是赋值操作，而使用空格会创建一个相等性测试。
- en: Access the contents of a variable by prefixing the variable name with a dollar
    sign (`$`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在变量名前加上美元符号（`$`）来访问变量的内容。
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You may also use it like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样使用：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This output will be displayed:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出将显示如下：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Variable values within double quotes can be used with `printf`, `echo`, and
    other shell commands:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号中的变量值可以与`printf`、`echo`和其他Shell命令一起使用：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output will be as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because the shell uses a space to delimit words, we need to add curly braces
    to let the shell know that the variable name is `fruit`, not `fruit(s)`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Shell使用空格来分隔单词，我们需要添加花括号，以让Shell知道变量名是`fruit`，而不是`fruit(s)`。
- en: Environment variables are inherited from the parent processes. For example,
    `HTTP_PROXY` is an environment variable that defines which proxy server to use
    for an Internet connection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是从父进程继承的。例如，`HTTP_PROXY`是一个环境变量，定义了用于Internet连接的代理服务器。
- en: 'Usually, it is set as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它被设置为如下：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `export` command declares one or more variables that will be inherited by
    child tasks. After variables are exported, any application executed from the current
    shell script, receives this variable. There are many standard environment variables
    created and used by the shell, and we can export our own variables.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`命令声明一个或多个将由子任务继承的变量。变量被导出后，当前Shell脚本中执行的任何应用程序都会接收到这些变量。Shell创建并使用了许多标准环境变量，我们也可以导出自己的变量。'
- en: 'For example, the `PATH` variable lists the folders, which the shell will search
    for an application. A typical `PATH` variable will contain the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PATH`变量列出了Shell搜索应用程序的文件夹。一个典型的`PATH`变量包含以下内容：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Directory paths are delimited by the `:` character. Usually, `$PATH` is defined
    in `/etc/environment`, `/etc/profile` or `~/.bashrc`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 目录路径由`:`字符分隔。通常，`$PATH`在`/etc/environment`、`/etc/profile`或`~/.bashrc`中定义。
- en: 'To add a new path to the `PATH` environment, use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新路径添加到`PATH`环境中，使用以下命令：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, use these commands:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用这些命令：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we have added `/home/user/bin` to `PATH`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将`/home/user/bin`添加到`PATH`中。
- en: Some of the well-known environment variables are `HOME`, `PWD`, `USER`, `UID`,
    and `SHELL`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的环境变量有`HOME`、`PWD`、`USER`、`UID`和`SHELL`。
- en: When using single quotes, variables will not be expanded and will be displayed
    as it is. This means, `$ echo '$var'` will display `$var`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单引号时，变量不会展开，显示的就是原样内容。这意味着，`$ echo '$var'`将显示`$var`。
- en: Whereas, `$ echo "$var"` will display the value of the `$var` variable if it
    is defined, or nothing if it is not defined.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 而`$ echo "$var"`将在`$var`变量已定义时显示其值，未定义时显示空值。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The shell has many more built-in features. Here are a few more:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Shell还有许多内置功能。以下是一些额外功能：
- en: Finding the length of a string
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找字符串的长度
- en: 'Get the length of a variable''s value with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取变量值的长度：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Consider this example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `length` parameter is the number of characters in the string.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`参数表示字符串中的字符数。'
- en: Identifying the current shell
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别当前Shell
- en: To identify the shell which is currently being used, use the `SHELL environment`
    variable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别当前使用的Shell，可以使用`SHELL environment`变量。
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, use this command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用以下命令：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Consider this example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, by executing the `echo $0` command, we will get the same output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通过执行`echo $0`命令，我们将得到相同的输出：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Checking for super user
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查超级用户
- en: 'The `UID` environment variable holds the User ID. Use this value to check whether
    the current script is being run as a root user or regular user. Consider this example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`UID`环境变量保存用户ID。使用此值可以检查当前脚本是以root用户还是普通用户身份运行。考虑这个例子：'
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that `[` is actually a command and must be separated from the rest of
    the string with spaces. We can also write the preceding script as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`[` 实际上是一个命令，必须与其余字符串用空格分开。我们也可以将前面的脚本写成如下形式：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `UID` value for the root user is `0`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: root 用户的 `UID` 值为 `0`。
- en: Modifying the Bash prompt string (username@hostname:~$)
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改 Bash 提示符字符串（username@hostname:~$）
- en: 'When we open a terminal or run a shell, we see a prompt such as `user@hostname:
    /home/$`. Different GNU/Linux distributions have different prompts and different
    colors. The `PS1` environment variable defines the primary prompt. The default
    prompt is defined by a line in the `~/.bashrc` file.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们打开终端或运行 shell 时，会看到类似 `user@hostname: /home/$` 的提示符。不同的 GNU/Linux 发行版有不同的提示符和颜色。`PS1`
    环境变量定义了主提示符。默认的提示符由 `~/.bashrc` 文件中的一行定义。'
- en: 'View the line used to set the `PS1` variable:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看设置 `PS1` 变量的行：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To modify the prompt, enter the following command:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要修改提示符，可以输入以下命令：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can use colored text using the special escape sequences such as `\e[1;31`
    (refer to the *Displaying output in a terminal *recipe of this chapter).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用特殊的转义序列来显示彩色文本，例如 `\e[1;31`（参见本章的 *在终端中显示输出* 这一小节）。
- en: Certain special characters expand to system parameters. For example, `\u` expands
    to username, `\h` expands to hostname, and `\w` expands to the current working
    directory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 某些特殊字符会扩展为系统参数。例如，`\u` 扩展为用户名，`\h` 扩展为主机名，`\w` 扩展为当前工作目录。
- en: Function to prepend to environment variables
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于向环境变量添加前缀的函数
- en: 'Environment variables are often used to store a list of paths of where to search
    for executables, libraries, and so on. Examples are `$PATH` and  `$LD_LIBRARY_PATH`,
    which will typically resemble this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量通常用于存储一系列搜索可执行文件、库等的路径。例如，`$PATH` 和 `$LD_LIBRARY_PATH` 通常类似于下面的形式：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This means that whenever the shell has to execute an application (binary or
    script), it will first look in `/usr/bin` and then search `/bin`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，每当 shell 需要执行一个应用程序（二进制文件或脚本）时，它会首先在 `/usr/bin` 中查找，然后再搜索 `/bin`。
- en: When building and installing a program from source, we often need to add custom
    paths for the new executable and libraries. For example, we might install `myapp`
    in `/opt/myapp`, with binaries in a `/opt/myapp/bin` folder and libraries in `/opt/myapp/lib`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在从源代码构建并安装程序时，我们经常需要为新的可执行文件和库添加自定义路径。例如，我们可能会将 `myapp` 安装在 `/opt/myapp` 中，其中二进制文件在
    `/opt/myapp/bin` 文件夹，库文件在 `/opt/myapp/lib` 文件夹。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This example shows how to add new paths to the beginning of an environment variable.
    The first example shows how to do this with what's been covered so far, the second
    demonstrates creating a function to simplify modifying the variable. Functions
    are covered later in this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何将新路径添加到环境变量的开头。第一个示例展示了如何使用目前为止讲解的内容来实现，第二个示例展示了如何创建一个函数来简化修改变量的过程。函数的内容将在本章后面介绍。
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `PATH` and `LD_LIBRARY_PATH` variables should now look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 和 `LD_LIBRARY_PATH` 变量现在应该类似于以下内容：'
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can make adding a new path easier by defining a prepend function in the `.bashrc`
    file.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `.bashrc` 文件中定义一个 prepend 函数，使得添加新路径更加简单。
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This can be used in the following way:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式使用：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `prepend()` function first confirms that the directory specified by the
    second parameter to the function exists. If it does, the `eval` expression sets
    the variable, with the name in the first parameter equal to the second parameter
    string, followed by `:` (the path separator), and then the original value for
    the variable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`prepend()` 函数首先确认由函数第二个参数指定的目录是否存在。如果存在，`eval` 表达式会设置变量，变量名为第一个参数的值，等于第二个参数字符串，后跟
    `:`（路径分隔符），然后是变量的原始值。'
- en: 'If the variable is empty when we try to prepend, there will be a trailing `:`
    at the end. To fix this, modify the function to this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试添加前缀时变量为空，末尾会有一个多余的 `:`。为了解决这个问题，可以将函数修改为如下形式：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this form of the function, we introduce a shell parameter expansion of the
    form:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式的函数中，我们引入了一种 shell 参数扩展，形式如下：
- en: '`${parameter:+expression}`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`${parameter:+expression}`'
- en: This expands to expression if parameter is set and is not null.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数已设置且不为 null，则扩展为表达式。
- en: With this change, we take care to try to append `:` and the old value if, and
    only if, the old value existed when trying to prepend.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此更改，我们确保在尝试添加前缀时，如果旧值存在，则仅在旧值存在的情况下追加 `:` 和旧值。
- en: Math with the shell
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 shell 进行数学运算
- en: The Bash shell performs basic arithmetic operations using the `let`, `(( ))`,
    and `[]` commands. The `expr` and `bc` utilities are used to perform advanced
    operations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell使用`let`、`(( ))`和`[]`命令执行基本的算术操作。`expr`和`bc`工具用于执行高级操作。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A numeric value is assigned to a variable the same way strings are assigned.
    The value will be treated as a number by the methods that access it:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数值的赋值与字符串赋值相同。访问它的方法会将其作为数字处理：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `let` command is used to perform basic operations directly. Within a `let`
    command, we use variable names without the `$` prefix. Consider this example:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let`命令用于直接执行基本操作。在`let`命令内，我们使用没有`$`前缀的变量名。请参考这个例子：'
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Other uses of `let` command are as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`命令的其他用法如下：'
- en: 'Use this for increment:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此命令进行递增：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For decrement, use this:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递减操作使用此命令：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use these for shorthands:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些来表示简写：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These are equal to `let no=no+6` and `let no=no-6`, respectively.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些等同于`let no=no+6`和`let no=no-6`。
- en: 'Alternate methods are as follows:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代方法如下：
- en: 'The `[]` operator is used in the same way as the `let` command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`操作符的使用方式与`let`命令相同：'
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using the $ prefix inside the [] operator is legal; consider this example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[]`操作符内部使用`$`前缀是合法的；请参考这个例子：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `(( ))` operator can also be used. The prefix variable names          
                 with a `$` within the `(( ))` operator:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`(( ))`操作符也可以使用。变量名前缀带有`$`的方式在`(( ))`操作符内使用：'
- en: '[PRE62]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `expr` expression can be used for basic operations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr`表达式可用于基本操作：'
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The preceding methods do not support floating point numbers,
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法不支持浮动点数，
- en: and operate on integers only.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对整数操作。
- en: 'The `bc` application, the precision calculator, is an advanced utility for
    mathematical operations. It has a wide range of options. We can perform floating
    point arithmetic and use advanced functions:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bc`应用程序，精度计算器，是一个用于数学运算的高级工具。它有广泛的选项，我们可以进行浮点运算并使用高级函数：'
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `bc` application accepts prefixes to control the operation. These are separated
    from each other with a semicolon.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`bc`应用程序接受前缀来控制操作。这些前缀通过分号分隔。'
- en: '**Decimal places scale with bc**: In the following example, the `scale=2` parameter
    sets the number of decimal places to `2`. Hence, the output of `bc` will contain
    a number with two decimal places:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小数位数使用bc调整**：在下面的例子中，`scale=2`参数将小数位数设置为`2`。因此，`bc`的输出将包含一个两位小数的数字：'
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '**Base conversion with bc**: We can convert from one base number system to
    another one. This code converts numbers from decimal to binary and binary to decimal:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用bc进行进制转换**：我们可以将一个进制的数字转换为另一个进制。以下代码将数字从十进制转换为二进制，并将二进制转换为十进制：'
- en: '[PRE66]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following examples demonstrate calculating squares and square roots:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下示例演示了如何计算平方和平方根：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Playing with file descriptors and redirection
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件描述符和重定向
- en: File descriptors are integers associated with the input and output streams.
    The best-known file descriptors are `stdin`, `stdout`, and `stderr`. The contents
    of one stream can be redirected to another. This recipe shows examples on how
    to manipulate and redirect with file descriptors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是与输入输出流相关联的整数。最常见的文件描述符是`stdin`、`stdout`和`stderr`。一个流的内容可以被重定向到另一个流。这个示例展示了如何操作和重定向文件描述符。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Shell scripts frequently use standard input (`stdin`), standard output (`stdout`),
    and standard error (`stderr`). A script can redirect output to a file with the
    greater-than symbol. Text generated by a command may be normal output or an error
    message. By default, both normal output (`stdout`) and error messages (`stderr`)
    are sent to the display. The two streams can be separated by specifying a specific
    descriptor for each stream.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本常常使用标准输入（`stdin`）、标准输出（`stdout`）和标准错误（`stderr`）。脚本可以使用大于号符号将输出重定向到文件。命令生成的文本可以是正常输出或错误消息。默认情况下，正常输出（`stdout`）和错误消息（`stderr`）都会显示在屏幕上。通过为每个流指定特定的描述符，两个流可以被分开。
- en: 'File descriptors are integers associated with an opened file or data stream.
    File descriptors 0, 1, and 2 are reserved, as given here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是与打开的文件或数据流相关联的整数。文件描述符0、1和2是保留的，如下所示：
- en: '0: `stdin`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '0: `stdin`'
- en: '1: `stdout`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '1: `stdout`'
- en: '2: `stderr`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2: `stderr`'
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the greater-than symbol to append text to a file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用大于号符号将文本追加到文件：
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This stores the echoed text in `temp.txt`. If `temp.txt` already exists, the
    single greater-than sign will delete any previous contents.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将回显的文本存储到`temp.txt`中。如果`temp.txt`已存在，单个大于符号会删除之前的内容。
- en: 'Use double-greater-than to append text to a file:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用双大于符号将文本追加到文件中：
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use `cat` to view the contents of the file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令查看文件内容：
- en: '[PRE70]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The next recipes demonstrate redirecting `stderr`. A message is printed to
    the `stderr` stream when a command generates an error message. Consider the following
    example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例演示了如何重定向`stderr`。当命令生成错误信息时，会将一条消息打印到`stderr`流中。考虑以下示例：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here `+` is an invalid argument and hence an error is returned.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`+`是一个无效参数，因此返回错误。
- en: Successful and unsuccessful commands
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 成功与失败的命令
- en: When a command exits because of an error, it returns a nonzero exit status.
    The command returns zero when it terminates after successful completion. The return
    status is available in the special variable `$?` (run echo `$?` immediately after
    the command execution statement to print the exit status).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个命令因错误退出时，它会返回一个非零的退出状态。命令在成功完成后退出时返回零。返回状态可以在特殊变量`$?`中获得（在执行命令后立即运行`echo
    $?`来打印退出状态）。
- en: 'The following command prints the `stderr` text to the screen rather than to
    a file (and because there is no `stdout` output, `out.txt` will be empty):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将`stderr`文本打印到屏幕上，而不是文件中（由于没有`stdout`输出，`out.txt`将为空）：
- en: '[PRE72]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the following command, we redirect `stderr` to `out.txt` with `2>` (two
    greater-than):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令中，我们使用`2>`（两个大于符号）将`stderr`重定向到`out.txt`：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can redirect `stderr` to one file and `stdout` to another file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`stderr`重定向到一个文件，将`stdout`重定向到另一个文件。
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It is also possible to redirect `stderr` and `stdout` to a single file by converting
    `stderr` to `stdout` using this preferred method:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过将`stderr`转换为`stdout`来将`stderr`和`stdout`重定向到同一个文件，使用这种首选方法：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This can be done even using an alternate approach:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过另一种方法来完成此操作：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you don''t want to see or save any error messages, you can redirect the
    stderr output to `/dev/null`, which removes it completely. For example, consider
    that we have three files `a1`, `a2`, and `a3`. However, `a1` does not have the
    read-write-execute permission for the user. To print the contents of all files
    starting with the letter `a`, we use the `cat` command. Set up the test files
    as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想看到或保存任何错误消息，可以将`stderr`输出重定向到`/dev/null`，这样可以完全去除它。例如，假设我们有三个文件`a1`、`a2`和`a3`，但是`a1`对用户没有读写执行权限。为了打印所有以字母`a`开头的文件内容，我们使用`cat`命令。可以按如下方式设置测试文件：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Displaying the contents of the files using wildcards (`a*`), will generate
    an error message for the `a1` file because that file does not have the proper
    read permission:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通配符(`a*`)显示文件内容时，将会因为`a1`文件没有适当的读权限而生成错误消息：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, `cat: a1: Permission denied` belongs to the `stderr` data. We can redirect
    the `stderr` data into a file, while sending `stdout` to the terminal.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '这里，`cat: a1: Permission denied`属于`stderr`数据。我们可以将`stderr`数据重定向到一个文件，同时将`stdout`输出到终端。'
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Some commands generate output that we want to process and also save for future
    reference or other processing. The `stdout` stream is a single stream that we
    can redirect to a file or pipe to another program. You might think there is no
    way for us to have our cake and eat it too.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有些命令生成我们想要处理的输出，并且还希望将其保存以供将来参考或进一步处理。`stdout`流是一个单一的流，我们可以将其重定向到文件或通过管道传递给另一个程序。你可能认为我们无法做到既得其所，又能两全其美。
- en: However, there is a way to redirect data to a file, while providing a copy of
    redirected data as `stdin` to the next command in a pipe. The `tee` command reads
    from `stdin` and redirects the input data to `stdout` and one or more files.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一种方法可以将数据重定向到文件的同时，将重定向的数据作为`stdin`提供给管道中的下一个命令。`tee`命令从`stdin`读取并将输入数据重定向到`stdout`和一个或多个文件。
- en: '[PRE80]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the following code, the `stdin` data is received by the `tee` command. It
    writes a copy of `stdout` to the `out.txt` file and sends another copy as `stdin`
    for the next command. The `cat -n` command puts a line number for each line received
    from `stdin` and writes it into `stdout`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`stdin`数据由`tee`命令接收。它将`stdout`的副本写入`out.txt`文件，并将另一副本作为`stdin`传递给下一个命令。`cat
    -n`命令为每一行从`stdin`接收的内容加上行号，并写入`stdout`：
- en: '[PRE81]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Use `cat` to examine the contents of `out.txt`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cat`命令查看`out.txt`的内容：
- en: '[PRE82]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Observe that `cat: a1: Permission denied` does not appear, because it was sent
    to `stderr`. The `tee` command reads only from `stdin`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到 `cat: a1: Permission denied` 不会显示，因为它被发送到了 `stderr`。`tee` 命令仅从 `stdin`
    读取。'
- en: By default, the `tee` command overwrites the file. Including the `-a` option
    will force it to append the new data.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tee` 命令会覆盖文件。加入 `-a` 选项会强制它将新数据附加到文件末尾。
- en: '[PRE83]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Commands with arguments follow the format: `command FILE1 FILE2 ...` or simply
    `command FILE`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 带有参数的命令遵循格式：`command FILE1 FILE2 ...` 或简单的 `command FILE`。
- en: 'To send two copies of the input to `stdout`, use `-` for the filename argument:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输入的两份副本发送到 `stdout`，请使用 `-` 作为文件名参数：
- en: '[PRE84]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Consider this example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 参考此示例：
- en: '[PRE85]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Alternately, we can use `/dev/stdin` as the output filename to use `stdin`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `/dev/stdin` 作为输出文件名来使用 `stdin`。
- en: Similarly, use `/dev/stderr` for standard error and `/dev/stdout` for standard
    output. These are special device files that correspond to `stdin`, `stderr`, and
    `stdout`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，使用 `/dev/stderr` 表示标准错误，`/dev/stdout` 表示标准输出。这些是特殊的设备文件，分别对应 `stdin`、`stderr`
    和 `stdout`。
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The redirection operators (`>` and `>>`) send output to a file instead of the
    terminal. The `>` and `>>` operators behave slightly differently. Both redirect
    output to a file, but the single greater-than symbol (`>`) empties the file and
    then writes to it, whereas the double greater-than symbol (`>>`) adds the output
    to the end of the existing file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向操作符（`>` 和 `>>`）将输出发送到文件，而不是终端。`>` 和 `>>` 操作符的行为略有不同。两者都将输出重定向到文件，但单个大于号符号（`>`）会清空文件并写入新内容，而双大于号符号（`>>`）会将输出添加到现有文件的末尾。
- en: By default, the redirection operates on standard output. To explicitly take
    a specific file descriptor, you must prefix the descriptor number to the operator.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，重定向作用于标准输出。要明确使用特定的文件描述符，必须将描述符数字作为前缀添加到操作符。
- en: The `>` operator is equivalent to `1>` and similarly it applies for `>>` (equivalent
    to `1>>`).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 操作符等同于 `1>`，类似地，`>>` 也等同于 `1>>`。'
- en: When working with errors, the `stderr` output is dumped to the `/dev/null` file.
    The `./dev/null` file is a special device file where any data received by the
    file is discarded. The null device is often known as a **black hole**, as all
    the data that goes into it is lost forever.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理错误时，`stderr` 输出会被转储到 `/dev/null` 文件中。`./dev/null` 文件是一个特殊的设备文件，接收到的数据会被丢弃。这个空设备通常被称为
    **黑洞**，因为所有进入它的数据都会永远丢失。
- en: There's more...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: 'Commands that read input from `stdin` can receive data in multiple ways. It
    is possible to specify file descriptors of our own, using `cat` and pipes. Consider
    this example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `stdin` 读取输入的命令可以通过多种方式接收数据。我们可以使用 `cat` 和管道来指定我们自己的文件描述符。参考此示例：
- en: '[PRE86]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Redirection from a file to a command
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件重定向到命令
- en: 'We can read data from a file as `stdin` with the less-than symbol (`<`):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过小于符号（`<`）从文件中读取数据作为 `stdin`：
- en: '[PRE87]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Redirecting from a text block enclosed within a script
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从脚本中封闭的文本块进行重定向
- en: 'Text can be redirected from a script into a file. To add a warning to the top
    of an automatically generated file, use the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以从脚本重定向到文件。要在自动生成的文件顶部添加警告，请使用以下代码：
- en: '[PRE88]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The lines that appear between `cat <<EOF >log.txt` and the next `EOF` line
    will appear as the `stdin` data. The contents of `log.txt` are shown here:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 出现于 `cat <<EOF >log.txt` 和下一个 `EOF` 行之间的内容将作为 `stdin` 数据显示。`log.txt` 的内容如下：
- en: '[PRE89]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Custom file descriptors
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义文件描述符
- en: A file descriptor is an abstract indicator for accessing a file. Each file access
    is associated with a special number called a file descriptor. 0, 1, and 2 are
    reserved descriptor numbers for `stdin`, `stdout`, and `stderr`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是访问文件的抽象标识符。每次文件访问都会关联一个称为文件描述符的特殊数字。0、1 和 2 是保留的描述符数字，分别代表 `stdin`、`stdout`
    和 `stderr`。
- en: 'The `exec` command can create new file descriptors. If you are familiar with
    file access in other programming languages, you may be familiar with the modes
    for opening files. These three modes are commonly used:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 命令可以创建新的文件描述符。如果你熟悉其他编程语言中的文件访问，你可能已经了解了打开文件的模式。这三种模式通常使用：'
- en: Read mode
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读模式
- en: Write with append mode
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用追加模式写入
- en: Write with truncate mode
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用截断模式写入
- en: The `<` operator reads from the file to `stdin`. The `>` operator writes to
    a file with truncation (data is written to the target file after truncating the
    contents). The `>>` operator writes to a file by appending (data is appended to
    the existing file contents and the contents of the target file will not be lost).
    File descriptors are created with one of the three modes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 运算符将文件内容读取到 `stdin`。`>` 运算符将数据写入文件并截断（数据写入目标文件，内容会被截断）。`>>` 运算符将数据追加到文件中（数据附加到现有文件内容，不会丢失目标文件的内容）。文件描述符是通过这三种模式之一创建的。'
- en: 'Create a file descriptor for reading a file:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于读取文件的文件描述符：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can use it in the following way:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now you can use file descriptor `3` with commands. For example, we will use
    `cat<&3`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用文件描述符`3`与命令一起操作。例如，我们将使用`cat<&3`：
- en: '[PRE92]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If a second read is required, we cannot reuse the file descriptor `3`. We must
    create a new file descriptor (perhaps 4) with `exec` to read from another file
    or re-read from the first file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要第二次读取，不能重用文件描述符`3`。我们必须使用`exec`创建一个新的文件描述符（可能是 4），以从另一个文件读取或重新从第一个文件读取。
- en: 'Create a file descriptor for writing (truncate mode):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于写入的文件描述符（截断模式）：
- en: '[PRE93]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Consider this example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE94]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now create a file descriptor for writing (append mode):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个用于写入的文件描述符（追加模式）：
- en: '[PRE95]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Consider the following example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE96]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Arrays and associative arrays
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和关联数组
- en: Arrays allow a script to store a collection of data as separate entities using
    indices. Bash supports both regular arrays that use integers as the array index,
    and associative arrays, which use a string as the array index. Regular arrays
    should be used when the data is organized numerically, for example, a set of successive
    iterations. Associative arrays can be used when the data is organized by a string,
    for example, host names. In this recipe, we will see how to use both of these.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许脚本通过索引将一组数据存储为独立的实体。Bash 支持两种类型的数组：普通数组（使用整数作为数组索引）和关联数组（使用字符串作为数组索引）。当数据按数字顺序组织时，应使用普通数组，例如一系列连续的迭代。关联数组可以用于数据按字符串组织时，例如主机名。在本例中，我们将看到如何使用这两种数组。
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use associate arrays, you must have Bash Version 4 or higher.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用关联数组，必须使用 Bash 版本 4 或更高版本。
- en: How to do it...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Arrays can be defined using different techniques:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以使用不同的技术来定义：
- en: 'Define an array using a list of values in a single line:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一行值的列表定义数组：
- en: '[PRE97]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Alternately, define an array as a set of index-value pairs:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将数组定义为一组索引-值对：
- en: '[PRE98]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Print the contents of an array at a given index using the following commands:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令打印数组中给定索引的内容：
- en: '[PRE99]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Print all of the values in an array as a list, using the following commands:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令打印数组中的所有值作为列表：
- en: '[PRE100]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Alternately, you can use the following command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令：
- en: '[PRE101]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Print the length of an array (the number of elements in an array):'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印数组的长度（数组中元素的数量）：
- en: '[PRE102]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: There's more...
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Associative arrays have been introduced to Bash from Version 4.0\. When the
    indices are a string (site names, user names, nonsequential numbers, and so on),
    an associative array is easier to work with than a numerically indexed array.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组从 Bash 版本 4.0 开始引入。当索引是字符串时（例如站点名称、用户名、非顺序数字等），关联数组比数字索引数组更容易使用。
- en: Defining associative arrays
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义关联数组
- en: 'An associative array can use any text data as an array index. A declaration
    statement is required to define a variable name as an associative array:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组可以使用任何文本数据作为数组索引。需要声明语句来定义变量名为关联数组：
- en: '[PRE103]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'After the declaration, elements are added to the associative array using either
    of these two methods:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明后，使用以下两种方法之一向关联数组添加元素：
- en: 'Inline index-value list method:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联索引-值列表方法：
- en: '[PRE104]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Separate index-value assignments:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离的索引-值赋值：
- en: '[PRE105]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'For example, consider the assignment of prices for fruits, using an associative
    array:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑为水果分配价格，使用关联数组：
- en: '[PRE106]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Display the contents of an array:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 显示数组的内容：
- en: '[PRE107]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Listing of array indexes
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出数组索引
- en: Arrays have indexes for indexing each of the elements. Ordinary and associative
    arrays differ in terms of index type.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 数组通过索引对每个元素进行索引。普通数组和关联数组在索引类型上有所不同。
- en: Obtain the list of indexes in an array.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数组中的索引列表。
- en: '[PRE108]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Alternatively, we can also use the following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们也可以使用以下命令：
- en: '[PRE109]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In the previous `fruits_value` array example, consider the following command:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`fruits_value`数组示例中，考虑以下命令：
- en: '[PRE110]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This will work for ordinary arrays too.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于普通数组。
- en: Visiting aliases
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问别名
- en: An **alias** is a shortcut to replace typing a long-command sequence. In this
    recipe, we will see how to create aliases using the `alias` command.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名**是一个快捷方式，用来替代输入长命令序列。在本教程中，我们将看到如何使用`alias`命令创建别名。'
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These are the operations you can perform on aliases:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以对别名执行的操作：
- en: 'Create an alias:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建别名：
- en: '[PRE111]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This example creates a shortcut for the `apt-get install` command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例为`apt-get install`命令创建了一个快捷方式：
- en: '[PRE112]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Once the alias is defined, we can type `install` instead of `sudo apt-get install`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了别名，我们可以输入`install`代替`sudo apt-get install`。
- en: 'The `alias` command is temporary: aliases exist until we close the current
    terminal. To make an alias available to all shells, add this statement to the
    `~/.bashrc` file. Commands in `~/.bashrc` are always executed when a new interactive
    shell process is spawned:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`alias`命令是临时的：别名存在直到我们关闭当前终端。要使别名在所有Shell中有效，可以将此语句添加到`~/.bashrc`文件中。`~/.bashrc`中的命令总是在启动新的交互式Shell进程时执行：'
- en: '[PRE113]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: To remove an alias, remove its entry from `~/.bashrc` (if any) or use the `unalias`
    command. Alternatively, `alias example=` should unset the alias named `example`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除别名，删除`~/.bashrc`文件中的相关条目（如果有），或者使用`unalias`命令。或者，`alias example=`可以取消名为`example`的别名。
- en: 'This example creates an alias for `rm` that will delete the original and keep
    a copy in a backup directory:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例创建了一个`rm`的别名，它会删除原始文件并在备份目录中保留一份副本：
- en: '[PRE114]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: When you create an alias, if the item being aliased already exists, it will
    be replaced by this newly aliased command for that user.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个别名时，如果被别名的项已经存在，它将会被新创建的别名命令替代，仅对该用户有效。
- en: There's more...
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When running as a privileged user, aliases can be a security breach. To avoid
    compromising your system, you should escape commands.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当以特权用户身份运行时，别名可能会成为安全隐患。为了避免危及系统安全，你应该转义命令。
- en: Escaping aliases
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义别名
- en: 'Given how easy it is to create an alias to masquerade as a native command,
    you should not run aliased commands as a privileged user. We can ignore any aliases
    currently defined, by escaping the command we want to run. Consider this example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到创建别名伪装成原生命令是多么简单，你不应该以特权用户身份运行有别名的命令。我们可以通过转义我们要运行的命令来忽略当前定义的任何别名。考虑以下示例：
- en: '[PRE115]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `\` character escapes the command, running it without any aliased changes.
    When running privileged commands on an untrusted environment, it is always a good
    security practice to ignore aliases by prefixing the command with `\`. The attacker
    might have aliased the privileged command with his/her own custom command, to
    steal critical information that is provided by the user to the command.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`字符用于转义命令，执行时不进行任何别名替换。当在不受信任的环境中运行特权命令时，通过在命令前加`\`来忽略别名总是一种良好的安全实践。攻击者可能已经将特权命令与其自定义命令别名，借此窃取用户提供给命令的关键信息。'
- en: Listing aliases
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出别名
- en: 'The `alias` command lists the currently defined aliases:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias`命令列出当前定义的别名：'
- en: '[PRE116]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Grabbing information about the terminal
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取终端信息
- en: While writing command-line shell scripts, we often need to manipulate information
    about the current terminal, such as the number of columns, rows, cursor positions,
    masked password fields, and so on. This recipe helps in collecting and manipulating
    terminal settings.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写命令行脚本时，我们经常需要操作关于当前终端的信息，比如列数、行数、光标位置、被隐藏的密码字段等。这个教程帮助收集和操作终端设置。
- en: Getting ready
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `tput` and `stty` commands are utilities used for terminal manipulations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`tput`和`stty`命令是用于终端操作的工具。'
- en: How to do it...
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are some capabilities of the `tput` command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`tput`命令的一些功能：
- en: 'Return the number of columns and rows in a terminal:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回终端中的列数和行数：
- en: '[PRE117]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Return the current terminal name:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回当前终端名称：
- en: '[PRE118]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Move the cursor to a 100,100 position:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标移动到100,100的位置：
- en: '[PRE119]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Set the terminal background color:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置终端背景颜色：
- en: '[PRE120]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The value of `n` can be a value in the range of 0 to 7
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`的值可以是0到7之间的一个值'
- en: 'Set the terminal foreground color:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置终端前景颜色：
- en: '[PRE121]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The value of `n` can be a value in the range of 0 to 7
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`的值可以是0到7之间的一个值'
- en: Some commands including the common `color ls` may reset the foreground and background
    color.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令，包括常用的`color ls`，可能会重置前景和背景颜色。
- en: 'Make text bold, using this command:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此命令使文本加粗：
- en: '[PRE122]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Perform start and end underlining:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行起始和结束下划线操作：
- en: '[PRE123]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To delete from the cursor to the end of the line, use the following command:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除从光标到行尾的内容，可以使用以下命令：
- en: '[PRE124]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'A script should not display the characters while entering a password. The following
    example demonstrates disabling character echo with the `stty` command:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入密码时，脚本不应显示字符。以下示例展示了使用`stty`命令禁用字符回显：
- en: '[PRE125]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `-echo` option in the preceding command disables the output to the terminal,
    whereas `echo` enables output.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令中的`-echo`选项禁用终端输出，而`echo`选项则启用输出。
- en: Getting and setting dates and delays
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置日期以及延迟
- en: A time delay is used to wait a set amount of time(such as 1 second) during the
    program execution, or to monitor a task every few seconds (or every few months).
    Working with times and dates requires an understanding of how time and date are
    represented and manipulated. This recipe will show you how to work with dates
    and time delays.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 时间延迟用于在程序执行过程中等待设定的时间（例如 1 秒），或每隔几秒钟（或几个月）监控一个任务。处理时间和日期时需要了解时间和日期的表示方式以及如何操作它们。本篇食谱将展示如何处理日期和时间延迟。
- en: Getting ready
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Dates can be printed in a variety of formats. Internally, dates are stored as
    an integer number of seconds since 00:00:00 1970-01-01\. This is called **epoch**
    or **Unix time**.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 日期可以以多种格式打印。内部上，日期是以自1970年1月1日00:00:00以来的秒数存储的，这被称为**纪元时间**或**Unix时间**。
- en: The system's date can be set from the command line. The next recipes demonstrate
    how to read and set dates.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的日期可以通过命令行设置。接下来的食谱展示了如何读取和设置日期。
- en: How to do it...
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何做的...
- en: It is possible to read the dates in different formats and also to set the date.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以不同的格式读取日期，也可以设置日期。
- en: 'Read the date:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取日期：
- en: '[PRE126]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Print the epoch time:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印纪元时间：
- en: '[PRE127]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The date command can convert many formatted date strings into the epoch time.
    This lets you use dates in multiple date formats as input. Usually, you don't
    need to bother about the date string format you use if you are collecting the
    date from a system log or any standard application generated output.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`命令可以将许多格式化的日期字符串转换为纪元时间。这使得你可以使用多种日期格式作为输入。通常，如果你从系统日志或任何标准应用程序生成的输出中收集日期，格式无需过多关注。'
- en: 'Convert the date string into epoch:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 将日期字符串转换为纪元时间：
- en: '[PRE128]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The `--date` option defines a date string as input. We can use any date formatting
    options to print the output. The date command can be used to find the day of the
    week given a date string:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`--date`选项定义了一个日期字符串作为输入。我们可以使用任何日期格式选项来打印输出。`date`命令可以用来根据日期字符串查找星期几：'
- en: '[PRE129]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The date format strings are listed in the table mentioned in the *How it works...*
    section
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式字符串在*它是如何工作的...*部分中列出。
- en: 'Use a combination of format strings prefixed with `+` as an argument for the
    `date` command, to print the date in the format of your choice. Consider this example:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以`+`为前缀的格式字符串组合作为`date`命令的参数，可以将日期按你选择的格式打印。考虑以下示例：
- en: '[PRE130]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Set the date and time:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置日期和时间：
- en: '[PRE131]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'On a system connected to a network, you''ll want to use `ntpdate` to set the
    date and time:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到网络的系统上，您可能需要使用`ntpdate`来设置日期和时间：
- en: '`/usr/sbin/ntpdate -s time-b.nist.gov`'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/sbin/ntpdate -s time-b.nist.gov`'
- en: 'The rule for optimizing your code is to measure first. The date command can
    be used to time how long it takes a set of commands to execute:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化代码的规则是先进行测量。`date`命令可以用来计算一组命令执行的时间：
- en: '[PRE132]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The date command''s minimum resolution is one second. A better method for timing
    commands is the `time` command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`date`命令的最小分辨率为一秒。对命令进行计时的更好方法是`time`命令：'
- en: '`time commandOrScriptName`.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`time commandOrScriptName`。'
- en: How it works...
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Unix epoch is defined as the number of seconds that have elapsed since
    midnight proleptic **Coordinated Universal Time** (**UTC**) of January 1, 1970,
    not counting leap seconds. Epoch time is useful when you need to calculate the
    difference between two dates or times. Convert the two date strings to epoch and
    take the difference between the epoch values. This recipe calculates the number
    of seconds between two dates:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: Unix纪元定义为自1970年1月1日00:00:00（不包括闰秒）以来的秒数，采用**协调世界时**（**UTC**）。纪元时间在需要计算两个日期或时间之间的差异时非常有用。将两个日期字符串转换为纪元时间并取其差值。此食谱计算两个日期之间的秒数：
- en: '[PRE133]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Displaying a time in seconds since midnight of January 1, 1970, is not easily
    read by humans. The date command supports output in human readable formats.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 显示自1970年1月1日午夜以来的秒数对人类来说不易阅读。`date`命令支持以人类可读的格式输出。
- en: The following table lists the format options that the date command supports.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了`date`命令支持的格式选项。
- en: '| **Date component** | **Format** |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| **日期组件** | **格式** |'
- en: '| --- | --- |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Weekday | `%a` (for example, Sat)`%A` (for example, Saturday) |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| 星期几 | `%a`（例如，Sat）`%A`（例如，Saturday） |'
- en: '| Month | `%b` (for example, Nov)`%B` (for example, November) |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 月份 | `%b`（例如，Nov）`%B`（例如，November） |'
- en: '| Day | `%d` (for example, 31) |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| 日 | `%d`（例如，31） |'
- en: '| Date in format (mm/dd/yy) | `%D` (for example, 10/18/10) |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| 日期格式（mm/dd/yy） | `%D`（例如，10/18/10） |'
- en: '| Year | `%y` (for example, 10)`%Y` (for example, 2010) |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| 年 | `%y`（例如，10）`%Y`（例如，2010） |'
- en: '| Hour | `%I` or `%H` (For example, 08) |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| 小时 | `%I` 或 `%H`（例如，08） |'
- en: '| Minute | `%M` (for example, 33) |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 | `%M`（例如，33） |'
- en: '| Second | `%S` (for example, 10) |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| 秒 | `%S`（例如，10） |'
- en: '| Nano second | `%N` (for example, 695208515) |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 纳秒 | `%N`（例如，695208515） |'
- en: '| Epoch Unix time in seconds | `%s` (for example, 1290049486) |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| Unix时间戳（秒） | `%s`（例如，1290049486） |'
- en: There's more...
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Producing time intervals is essential when writing monitoring scripts that execute
    in a loop. The following examples show how to generate time delays.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 生成时间间隔在编写循环执行的监控脚本时非常重要。以下示例展示了如何生成时间延迟。
- en: Producing delays in a script
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在脚本中产生延迟
- en: 'The sleep command will delay a script''s execution period of time given in
    `seconds`. The following script counts from 0 to 40 seconds using `tput` and `sleep`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep`命令将根据给定的`秒`数延迟脚本的执行时间。以下脚本使用`tput`和`sleep`从0计数到40秒：'
- en: '[PRE134]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In the preceding example, a variable steps through the list of numbers generated
    by the `seq` command. We use `tput sc` to store the cursor position. On every
    loop execution, we write the new count in the terminal by restoring the cursor
    position using `tput rc`, and then clearing to the end of the line with `tputs
    ed`. After the line is cleared, the script echoes the new value. The sleep command
    causes the script to delay for 1 second between each iteration of the loop.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，一个变量遍历由`seq`命令生成的数字列表。我们使用`tput sc`来存储光标位置。每次循环执行时，我们通过恢复光标位置（使用`tput
    rc`）并使用`tputs ed`清除到行尾，将新计数值写入终端。清除行后，脚本会输出新值。`sleep`命令会使脚本在每次循环迭代之间延迟1秒。
- en: Debugging the script
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试脚本
- en: Debugging frequently takes longer than writing code. A feature every programming
    language should implement is to produce trace information when something unexpected
    happens. Debugging information can be read to understand what caused the program
    to behave in an unexpected fashion. Bash provides debugging options every developer
    should know. This recipe shows how to use these options.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 调试通常比编写代码所需时间更长。每种编程语言都应实现一个功能，在发生意外时产生追踪信息。通过读取调试信息，可以了解程序为何会出现意外的行为。Bash提供了每个开发者都应了解的调试选项。本食谱展示了如何使用这些选项。
- en: How to do it...
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can either use Bash''s inbuilt debugging tools or write our scripts in such
    a manner that they become easy to debug; here''s how:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Bash内建的调试工具，或者编写便于调试的脚本；方法如下：
- en: Add the `-x` option to enable debug tracing of a shell script.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`-x`选项以启用shell脚本的调试跟踪。
- en: '[PRE135]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Running the script with the `-x` flag will print each source line with the current
    status.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-x`标志运行脚本会打印每行源代码及其当前状态。
- en: You can also use `sh -x script`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`sh -x script`。
- en: 'Debug only portions of the script using `set -x` and `set +x`. Consider this example:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅调试脚本的某些部分，使用`set -x`和`set +x`。考虑以下示例：
- en: '[PRE136]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In the preceding script, the debug information for `echo $i` will only be printed,
    as debugging is restricted to that section using `-x` and `+x`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的脚本中，只有`echo $i`的调试信息会被打印，因为调试仅限于该部分，使用了`-x`和`+x`来控制。
- en: The script uses the `{start..end}` construct to iterate from a start to end
    value, instead of the `seq` command used in the previous example. This construct
    is slightly faster than invoking the `seq` command.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用`{start..end}`构造从开始到结束值进行迭代，而不是前面示例中使用的`seq`命令。这个构造比调用`seq`命令稍快。
- en: The aforementioned debugging methods are provided by Bash built-ins. They produce
    debugging information in a fixed format. In many cases, we need debugging information
    in our own format. We can define a _DEBUG environment variable to enable and disable
    debugging and generate messages in our own debugging style.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述调试方法由Bash内建提供。它们以固定格式输出调试信息。在许多情况下，我们需要以自定义格式输出调试信息。我们可以定义一个_DEBUG环境变量来启用和禁用调试，并按照自己的调试风格生成消息。
- en: 'Look at the following example code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例代码：
- en: '[PRE137]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Run the preceding script with debugging set to "on":'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用调试模式“开启”运行前面的脚本：
- en: '[PRE138]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We prefix `DEBUG` before every statement where debug information is to be printed.
    If `_DEBUG=on` is not passed to the script, debug information will not be printed.
    In Bash, the command `:` tells the shell to do nothing.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个需要打印调试信息的语句前加上 `DEBUG` 前缀。如果没有将 `_DEBUG=on` 传递给脚本，调试信息将不会被打印。在 Bash 中，命令
    `:` 会告诉 shell 什么都不做。
- en: How it works...
  id: totrans-500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `-x` flag outputs every line of script as it is executed. However, we may
    require only some portions of the source lines to be observed. Bash uses a `set
    builtin` to enable and disable debug printing within the script:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '`-x` 标志会输出每一行脚本的执行情况。然而，我们可能只需要观察源代码的某些部分。Bash 使用 `set builtin` 来在脚本中启用和禁用调试打印：'
- en: '`set -x`: This displays arguments and commands upon their execution'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -x`：这会在命令执行时显示参数和命令。'
- en: '`set +x`: This disables debugging'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set +x`：这会禁用调试功能。'
- en: '`set -v`: This displays input when they are read'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -v`：这会在读取时显示输入。'
- en: '`set +v`: This disables printing input'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set +v`：这会禁用打印输入。'
- en: There's more...
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: We can also use other convenient ways to debug scripts. We can make use of shebang
    in a trickier way to debug scripts.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用其他方便的方式来调试脚本。我们可以通过更复杂的方式使用 shebang 来调试脚本。
- en: Shebang hack
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shebang 黑客技巧
- en: The shebang can be changed from `#!/bin/bash` to `#!/bin/bash -xv` to enable
    debugging without any additional flags (`-xv` flags themselves).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Shebang 可以从 `#!/bin/bash` 改为 `#!/bin/bash -xv`，以启用调试功能而无需额外的标志（即 `-xv` 标志本身）。
- en: 'It can be hard to track execution flow in the default output when each line
    is preceded by `+`. Set the PS4 environment variable to `''$LINENO:''` to display
    actual line numbers:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认输出中，每行前都有 `+`，这可能使得跟踪执行流程变得困难。可以将 PS4 环境变量设置为 `'$LINENO:'`，以显示实际的行号：
- en: '[PRE139]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The debugging output may be long. When using `-x` or set `-x`, the debugging
    output is sent to `stderr`. It can be redirected to a file with the following
    command:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 调试输出可能很长。当使用 `-x` 或设置 `-x` 时，调试输出会被发送到 `stderr`。可以使用以下命令将其重定向到文件：
- en: '[PRE140]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Bash 4.0 and later support using a numbered stream for debugging output:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 4.0 及更高版本支持使用编号流来调试输出：
- en: '[PRE141]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Functions and arguments
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数与参数
- en: Functions and aliases appear similar at a casual glance, but behave slightly
    differently. The big difference is that function arguments can be used anywhere
    within the body of the function, while an alias simply appends arguments to the
    end of the command.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与别名乍一看相似，但行为略有不同。主要区别在于，函数参数可以在函数体内的任何地方使用，而别名仅将参数附加到命令末尾。
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A function is defined with the function command, a function name, open/close
    parentheses, and a function body enclosed in curly brackets:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过 `function` 命令定义，函数名称、圆括号以及用大括号括起来的函数体：
- en: 'A function is defined as follows:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的定义如下：
- en: '[PRE142]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Alternatively, it can be defined as:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以按如下方式定义：
- en: '[PRE143]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'It can even be defined as follows (for simple functions):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至可以按如下方式定义（适用于简单函数）：
- en: '[PRE144]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'A function is invoked using its name:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数名称调用一个函数：
- en: '[PRE145]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Arguments passed to functions are accessed positionally, `$1` is the first
    argument, `$2` is the second, and so on:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给函数的参数是按位置访问的，`$1` 是第一个参数，`$2` 是第二个，以此类推：
- en: '[PRE146]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The following is the definition of the function `fname`. In the `fname` function,
    we have included various ways of accessing the function arguments.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `fname` 函数的定义。在 `fname` 函数中，我们包含了多种访问函数参数的方式。
- en: '[PRE147]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Arguments passed to scripts can be accessed as `$0` (the name of the script):'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给脚本的参数可以通过 `$0` 访问（脚本的名称）：
- en: '`$1` is the first argument'
  id: totrans-533
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1` 是第一个参数'
- en: '`$2` is the second argument'
  id: totrans-534
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2` 是第二个参数'
- en: '`$n` is the *n*th argument'
  id: totrans-535
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$n` 是第 *n* 个参数。'
- en: '`"$@"` expands as `"$1" "$2" "$3"` and so on'
  id: totrans-536
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$@"` 扩展为 `"$1" "$2" "$3"`，依此类推。'
- en: '`"$*"` expands as `"$1c$2c$3"`, where `c` is the first character of IFS'
  id: totrans-537
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$*"` 扩展为 `"$1c$2c$3"`，其中 `c` 是 IFS 的第一个字符。'
- en: '`"$@"` is used more often than `$*`, since the former provides all arguments
    as a single string'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$@"` 比 `$*` 使用得更频繁，因为前者将所有参数作为一个单独的字符串提供。'
- en: '**Compare alias to function**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较别名与函数**'
- en: 'Here''s an alias to display a subset of files by piping `ls` output to `grep`.
    The argument is attached to the end of the command, so `lsg txt` is expanded to
    `ls | grep txt`:'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面是一个别名，通过将 `ls` 输出传递给 `grep` 来显示文件的子集。参数附加在命令的末尾，因此 `lsg txt` 会展开为 `ls | grep
    txt`：
- en: '[PRE148]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'If we wanted to expand that to get the IP address for a device in `/sbin/ifconfig`,
    we might try the following:'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要扩展它来获取 `/sbin/ifconfig` 中设备的 IP 地址，可能会尝试如下操作：
- en: '[PRE149]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The `grep` command found the `eth0` string, not the IP address. If we use a
    function instead of an alias, we can pass the argument to the `ifconfig`, instead
    of appending it to the `grep`:'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`命令找到的是`eth0`字符串，而不是IP地址。如果我们使用函数而不是别名，我们可以将参数传递给`ifconfig`，而不是将其附加到`grep`上：'
- en: '[PRE150]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: There's more...
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's explore more tips on Bash functions.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索更多Bash函数的技巧。
- en: The recursive function
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: Functions in Bash also support recursion (the function can call itself). For
    example, `F() { echo $1; F hello; sleep 1; }`.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中的函数也支持递归（函数可以调用自身）。例如，`F() { echo $1; F hello; sleep 1; }`。
- en: Fork bomb
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Fork bomb
- en: 'A recursive function is a function that calls itself: recursive functions must
    have an exit condition, or they will spawn until the system exhausts a resource
    and crashes.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数是指调用自身的函数：递归函数必须有一个退出条件，否则它们会一直生成进程，直到系统耗尽资源并崩溃。
- en: This function: `:(){ :|:& };:` spawns processes forever and ends up in a denial-of-service
    attack.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数：`:(){ :|:& };:` 会永远生成进程，最终导致拒绝服务攻击。
- en: The `&` character is postfixed with the function call to bring the subprocess
    into the background. This dangerous code forks processes forever and is called
    a fork bomb.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`字符被附加到函数调用后面，将子进程带入后台。这个危险的代码会无限生成进程，称为fork bomb。'
- en: You may find it difficult to interpret the preceding code. Refer to the Wikipedia
    page [h t t p ://e n . w i k i p e d i a . o r g /w i k i /F o r k _ b o m b](https://en.wikipedia.org/wiki/Fork_bomb)
    for more details and interpretation of the fork bomb.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得很难理解前面的代码。请参考Wikipedia页面 [h t t p ://e n . w i k i p e d i a . o r g /w
    i k i /F o r k _ b o m b](https://en.wikipedia.org/wiki/Fork_bomb) 了解更多细节和对fork
    bomb的解释。
- en: Prevent this attack by restricting the maximum number of processes that can
    be spawned by defining the `nproc` value in `/etc/security/limits.conf`.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`/etc/security/limits.conf`中定义`nproc`值来限制能够生成的最大进程数，从而防止此类攻击。
- en: 'This line will limit all users to 100 processes:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将限制所有用户最多只能启动100个进程：
- en: '`hard nproc 100`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`hard nproc 100`'
- en: '**Exporting functions**'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**导出函数**'
- en: 'Functions can be exported, just like environment variables, using the `export`
    command. Exporting extends the scope of the function to subprocesses:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以像环境变量一样通过`export`命令导出。导出扩展了函数的作用域到子进程：
- en: '[PRE151]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Reading the return value (status) of a command
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取命令的返回值（状态）
- en: The return value of a command is stored in the `$?` variable.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令的返回值存储在`$?`变量中。
- en: '[PRE152]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The return value is called **exit status**. This value can be used to determine
    whether a command completed successfully or unsuccessfully. If the command exits
    successfully, the exit status will be zero, otherwise it will be a nonzero value.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值被称为**退出状态**。这个值可以用来判断一个命令是否成功执行。如果命令成功退出，退出状态将为零，否则为非零值。
- en: 'The following script reports the success/failure status of a command:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本报告命令的成功/失败状态：
- en: '[PRE153]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Passing arguments to commands
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向命令传递参数
- en: 'Most applications accept arguments in different formats. Suppose `-p` and `-v`
    are the options available, and `-k N` is another option that takes a number. Also,
    the command requires a filename as argument. This application can be executed
    in multiple ways:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序接受不同格式的参数。假设`-p`和`-v`是可用的选项，`-k N`是另一个需要数字的选项。此外，命令需要一个文件名作为参数。这个应用程序可以通过多种方式执行：
- en: '`$ command -p -v -k 1 file`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ command -p -v -k 1 file`'
- en: '`$ command -pv -k 1 file`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ command -pv -k 1 file`'
- en: '`$ command -vpk 1 file`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ command -vpk 1 file`'
- en: '`$ command file -pvk 1`'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ command file -pvk 1`'
- en: Within a script, the command-line arguments can be accessed by their position
    in the command line. The first argument will be `$1`, the second `$2`, and so
    on.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，命令行参数可以通过它们在命令行中的位置进行访问。第一个参数是`$1`，第二个是`$2`，依此类推。
- en: 'This script will display the first three command line arguments:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本会显示前三个命令行参数：
- en: '[PRE154]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'It''s more common to iterate through the command arguments one at a time. The
    `shift` command shifts eachh argument one space to the left, to let a script access
    each argument as `$1`. The following code displays all the command-line values:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，逐个迭代命令参数。`shift`命令将每个参数向左移动一个位置，使脚本可以将每个参数作为`$1`来访问。以下代码显示所有命令行的值：
- en: '[PRE155]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Sending output from one command to another
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个命令的输出发送给另一个命令
- en: One of the best features of the Unix shells is the ease of combining many commands
    to produce a report. The output of one command can appear as the input to another,
    which passes its output to another command, and so on. The output of this sequence
    can be assigned to a variable. This recipe illustrates how to combine multiple
    commands and how the output can be read.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Unix shell的一个最好的特点是可以轻松地组合多个命令来生成报告。一个命令的输出可以作为另一个命令的输入，而另一个命令则将其输出传递给下一个命令，依此类推。这个命令序列的输出可以分配给一个变量。这个示例展示了如何组合多个命令以及如何读取输出。
- en: Getting ready
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: The input is usually fed into a command through `stdin` or arguments. The output
    is sent to `stdout` or `stderr`. When we combine multiple commands, we usually
    supply input via `stdin` and generate output to `stdout`.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 输入通常通过`stdin`或参数传递给命令。输出发送到`stdout`或`stderr`。当我们组合多个命令时，通常通过`stdin`提供输入，并生成输出到`stdout`。
- en: 'In this context, the commands are called **filters**. We connect each filter
    using pipes, sympolized by the piping operator (`|`), like this:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，命令被称为**过滤器**。我们使用管道（由管道操作符`|`表示）将每个过滤器连接起来，如下所示：
- en: '[PRE156]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Here, we combine three commands. The output of `cmd1` goes to `cmd2`, the output
    of `cmd2` goes to `cmd3`, and the final output (which comes out of `cmd3`) will
    be displayed on the monitor, or directed to a file.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们组合了三个命令。`cmd1`的输出传递给`cmd2`，`cmd2`的输出传递给`cmd3`，最终输出（来自`cmd3`）将显示在屏幕上，或者被重定向到一个文件。
- en: How to do it...
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Pipes can be used with the subshell method for combining outputs of multiple
    commands.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 管道可以与子壳方法一起使用，用于组合多个命令的输出。
- en: 'Let''s start with combining two commands:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从组合两个命令开始：
- en: '[PRE157]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The output of `ls` (the listing of the current directory) is passed to `cat
    -n`, which in turn prepends line numbers to the input received through `stdin`.
    The output is redirected to `out.txt`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`（当前目录的列表）的输出被传递给`cat -n`，后者在通过`stdin`接收到的输入前加上行号。输出被重定向到`out.txt`。'
- en: 'Assign the output of a sequence of commands to a variable:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一系列命令的输出分配给一个变量：
- en: '[PRE158]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This is called the **subshell method**. Consider this example:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**子壳方法**。考虑以下这个例子：
- en: '[PRE159]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Another method, called **back quotes** (some people also refer to it as **back
    tick**) can also be used to store the command output:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，称为**反引号**（有些人也称之为**反勾引号**），也可以用来存储命令输出：
- en: '[PRE160]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Consider this example:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下这个例子：
- en: '[PRE161]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Back quote is different from the single-quote character. It is the character
    on the *~* button on the keyboard.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号与单引号字符不同。它是键盘上*~*键上的字符。
- en: There's more...
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are multiple ways of grouping commands.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以对命令进行分组。
- en: Spawning a separate process with subshell
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子壳生成一个独立的进程
- en: 'Subshells are separate processes. A subshell is defined using the `( )` operators:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 子壳是独立的进程。子壳使用`( )`运算符来定义：
- en: The `pwd` command prints the path of the working directory
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwd`命令打印工作目录的路径'
- en: 'The `cd` command changes the current directory to the given directory path:'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`命令将当前目录更改为给定的目录路径：'
- en: '[PRE162]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: When commands are executed in a subshell, none of the changes occur in the current
    shell; changes are restricted to the subshell. For example, when the current directory
    in a subshell is changed using the `cd` command, the directory change is not reflected
    in the main shell environment.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令在子壳中执行时，当前shell不会发生任何变化；更改仅限于子壳。例如，当使用`cd`命令在子壳中更改当前目录时，目录更改不会反映在主shell环境中。
- en: Subshell quoting to preserve spacing and the newline character
  id: totrans-607
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子壳引用来保留空格和换行符
- en: 'Suppose we are assigning the output of a command to a variable using a subshell
    or the back quotes method, we must use double quotes to preserve the spacing and
    the newline character (`\n`). Consider this example:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用子壳或反引号方法将命令的输出分配给一个变量，我们必须使用双引号来保留空格和换行符（`\n`）。考虑这个例子：
- en: '[PRE163]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Reading n characters without pressing the return key
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取n个字符而无需按回车键
- en: The bash command `read` inputs text from the keyboard or standard input. We
    can use `read` to acquire input from the user interactively, but `read` is capable
    of more. Most input libraries in any programming language read the input from
    the keyboard and terminate the string when return is pressed. There are certain
    situations when return cannot be pressed and string termination is done based
    on a number of characters received (perhaps a single character). For example,
    in an interactive game, a ball is moved upward when *+* is pressed. Pressing *+*
    and then pressing *return* to acknowledge the *+* press is not efficient.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: bash 命令 `read` 从键盘或标准输入中读取文本。我们可以使用 `read` 来交互式地获取用户输入，但 `read` 还能做更多事情。任何编程语言中的大多数输入库都会从键盘读取输入，并在按下回车时终止字符串。在某些情况下，无法按下回车键，而字符串的终止是基于接收到的字符数（可能是单个字符）。例如，在一个互动游戏中，当按下
    *+* 时，球会向上移动。按下 *+* 然后再按 *return* 来确认 *+* 的按下是不高效的。
- en: This recipe uses the `read` command to accomplish this task without having to
    press *return*.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案使用 `read` 命令来完成此任务，无需按 *return* 键。
- en: How to do it...
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'You can use various options of the `read` command to obtain different results,
    as shown in the following steps:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `read` 命令的各种选项来获取不同的结果，如下所示：
- en: 'The following statement will read *n* characters from input into the `variable_name`
    variable:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句将从输入中读取 *n* 个字符到 `variable_name` 变量中：
- en: '[PRE164]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Consider this example:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑这个示例：
- en: '[PRE165]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Read a password in the non-echoed mode:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以不回显的模式读取密码：
- en: '[PRE166]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Display a message with `read` using the following command:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令通过 `read` 显示一条消息：
- en: '[PRE167]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Read the input after a timeout:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在超时后读取输入：
- en: '[PRE168]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Consider the following example:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE169]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Use a delimiter character to end the input line:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分隔符字符来结束输入行：
- en: '[PRE170]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Consider this example:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE171]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Running a command until it succeeds
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行命令直到它成功
- en: Sometimes a command can only succeed when certain conditions are met. For example,
    you can only download a file after the file is created. In such cases, one might
    want to run a command repeatedly until it succeeds.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，命令只能在满足特定条件时成功。例如，只有在文件创建后才能下载该文件。在这种情况下，你可能希望重复执行命令直到它成功。
- en: How to do it...
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Define a function in the following way:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下方式定义一个函数：
- en: '[PRE172]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Alternatively, add this to your shell''s `rc` file for ease of use:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将此添加到 shell 的 `rc` 文件中以便于使用：
- en: '[PRE173]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: How it works...
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This repeat function has an infinite `while` loop, which attempts to run the
    command passed as a parameter (accessed by `$@`) to the function. It returns if
    the command was successful, thereby exiting the loop.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重复函数有一个无限的 `while` 循环，尝试执行作为参数传递给函数的命令（通过 `$@` 访问）。如果命令执行成功，则返回并退出循环。
- en: There's more...
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We saw a basic way to run commands until they succeed. Let's make things more
    efficient.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一种基本的执行命令直到成功的方法。让我们使其更加高效。
- en: A faster approach
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快速的方法
- en: 'On most modern systems, true is implemented as a binary in `/bin`. This means
    that each time the aforementioned `while` loop runs, the shell has to spawn a
    process. To avoid this, we can use the shell built-in `:` command, which always
    returns an exit code 0:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代系统中，`true` 被实现为 `/bin` 中的一个二进制文件。这意味着每次上述的 `while` 循环运行时，shell 都需要启动一个进程。为了避免这种情况，我们可以使用
    shell 内建的 `:` 命令，它始终返回退出码 0：
- en: '[PRE174]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Though not as readable, this is faster than the first approach.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法不如第一种方法可读，但它比第一种方法更快。
- en: Adding a delay
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加延迟
- en: 'Let''s say you are using `repeat()` to download a file from the Internet which
    is not available right now, but will be after some time. An example would be as
    follows:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在使用 `repeat()` 从互联网上下载一个当前不可用，但稍后会可用的文件。示例如下：
- en: '[PRE175]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This script will send too much traffic to the web server at `www.example.com`,
    which causes problems for the server (and maybe for you, if the server blacklists
    your IP as an attacker). To solve this, we modify the function and add a delay,
    as follows:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将向 `www.example.com` 发送过多的流量，导致服务器出现问题（如果服务器将你的 IP 列入黑名单，可能也会对你造成麻烦）。为了解决这个问题，我们修改了函数并添加了延迟，具体如下：
- en: '[PRE176]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: This will cause the command to run every 30 seconds.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使命令每 30 秒运行一次。
- en: Field separators and iterators
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段分隔符和迭代器
- en: The **internal field separator** (**IFS**) is an important concept in shell
    scripting. It is useful for manipulating text data.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '**内部字段分隔符**（**IFS**）是 shell 脚本中的一个重要概念。它对文本数据的处理非常有用。'
- en: An IFS is a delimiter for a special purpose. It is an environment variable that
    stores delimiting characters. It is the default delimiter string used by a running
    shell environment.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: IFS是一个特殊目的的定界符。它是一个存储分隔字符的环境变量，是运行的shell环境使用的默认定界符字符串。
- en: Consider the case where we need to iterate through words in a string or **comma
    separated values** (**CSV**). In the first case, we will use `IFS=" "` and in
    the second, `IFS=","`.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑需要遍历字符串中的单词或**以逗号分隔的值**（**CSV**）的情况。在第一种情况下，我们将使用`IFS=" "`，在第二种情况下，使用`IFS=","`。
- en: Getting ready
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Consider the case of CSV data:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑CSV数据的情况：
- en: '[PRE177]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'This generates the following output:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成以下输出：
- en: '[PRE178]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The default value of IFS is a white-space (newline, tab, or a space character).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: IFS的默认值是空白字符（换行符、制表符或空格字符）。
- en: When IFS is set as `,` the shell interprets the comma as a delimiter character,
    therefore, the `$item` variable takes substrings separated by a comma as its value
    during the iteration.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 当IFS设置为`,`时，shell将逗号解释为分隔符字符，因此在迭代过程中，`$item`变量将获取由逗号分隔的子字符串作为其值。
- en: If IFS is not set as `,` then it will print the entire data as a single string.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IFS没有设置为`,`，则会将整个数据作为一个字符串打印出来。
- en: How to do it...
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's go through another example usage of IFS to parse the `/etc/passwd` file.
    In the `/etc/passwd` file, every line contains items delimited by `:`. Each line
    in the file corresponds to an attribute related to a user.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过另一个使用IFS的例子来解析`/etc/passwd`文件。在`/etc/passwd`文件中，每行包含用`:`分隔的项。文件中的每一行对应于与用户相关的一个属性。
- en: 'Consider the input: `root:x:0:0:root:/root:/bin/bash`. The last entry on each
    line specifies the default shell for the user.'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑输入：`root:x:0:0:root:/root:/bin/bash`。每行的最后一项指定了该用户的默认shell。
- en: 'Print users and their default shells using the IFS hack:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IFS技巧打印用户及其默认shell：
- en: '[PRE179]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The output will be as follows:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE180]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Loops are very useful in iterating through a sequence of values. Bash provides
    many types of loops.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 循环在遍历一系列值时非常有用。Bash提供了多种类型的循环。
- en: '**List-oriented `for` loop**:'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向列表的`for`循环**：'
- en: '[PRE181]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: A list can be a string or a sequence of values.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以是一个字符串或一系列值。
- en: 'We can generate sequences with the `echo` command:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`echo`命令生成序列：
- en: '[PRE182]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: We can combine these to concatenate data.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些结合起来以连接数据。
- en: 'In the following code, in each iteration, the variable i will hold a character
    in the a to z range:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，每次迭代中，变量i将包含a到z范围内的字符：
- en: '[PRE183]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '**Iterate through a range of numbers**:'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遍历一系列数字**：'
- en: '[PRE184]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '**Loop until a condition is met**:'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环直到满足条件**：'
- en: 'The while loop continues while a condition is true, the until loop runs until
    a condition is true:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: while循环在条件为真时继续运行，而until循环在条件为真之前执行：
- en: '[PRE185]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'For an infinite loop, use `true` as the condition:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无限循环，使用`true`作为条件：
- en: '**Use a `until` loop**:'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用`until`循环**：'
- en: 'A special loop called `until` is available with Bash. This executes the loop
    until the given condition becomes true. Consider this example:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中有一个特殊的循环叫做`until`。这个循环会一直执行直到给定条件变为真。请考虑这个例子：
- en: '[PRE186]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Comparisons and tests
  id: totrans-689
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和测试
- en: Flow control in a program is handled by comparison and test statements. Bash
    comes with several options to perform tests. We can use `if`, `if else`, and logical
    operators to perform tests and comparison operators to compare data items. There
    is also a command called `test`, which performs tests.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的流程控制通过比较和测试语句来处理。Bash提供了几种执行测试的选项。我们可以使用`if`、`if else`和逻辑运算符来执行测试，并使用比较运算符来比较数据项。还有一个叫做`test`的命令，它也用于执行测试。
- en: How to do it...
  id: totrans-691
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here are some methods used for comparisons and performing tests:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些用于比较和执行测试的方法：
- en: 'Use an `if` condition:'
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`条件：
- en: '[PRE187]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Use `else if` and `else`:'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`else if`和`else`：
- en: '[PRE188]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Nesting is possible with if and else. The if conditions can be lengthy; to
    make them shorter we can use logical operators:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: if和else可以嵌套。if条件可能很长；为了简化它们，我们可以使用逻辑运算符：
- en: '`[ condition ] && action;` # action executes if the condition is true'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ condition ] && action;` # 如果条件为真，执行动作'
- en: '`[ condition ] || action;` # action executes if the condition is false'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ condition ] || action;` # 如果条件为假，执行动作'
- en: '`&&` is the logical AND operation and `||` is the logical OR operation. This
    is a very helpful trick while writing Bash scripts.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`是逻辑与操作，`||`是逻辑或操作。这在编写Bash脚本时非常有用。'
- en: 'Performing mathematical comparisons: usually, conditions are enclosed in square
    brackets `[]`. Note that there is a space between `[` or `]` and operands. It
    will show an error if no space is provided.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 执行数学比较：通常，条件包含在方括号 `[]` 中。注意，`[` 或 `]` 和操作数之间有空格。如果没有空格，将会出现错误。
- en: '[PRE189]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Perform mathematical tests on variables and values, like this:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 对变量和值进行数学测试，如下所示：
- en: '[PRE190]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Other important operators include the following:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要的运算符包括以下内容：
- en: '`-gt`: Greater than'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`：大于'
- en: '`-lt`: Less than'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`：小于'
- en: '`-ge`: Greater than or equal to'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`：大于或等于'
- en: '`-le`: Less than or equal to'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`：小于或等于'
- en: 'The `-a` operator is a logical AND and the `-o` operator is the logical OR.
    Multiple test conditions can be combined:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a` 运算符是逻辑与，`-o` 运算符是逻辑或。多个测试条件可以组合使用：'
- en: '[PRE191]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Filesystem-related tests are as follows:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件系统相关的测试如下：
- en: Test different filesystem-related attributes using different condition flags
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的条件标志测试不同的文件系统属性。
- en: '`[ -f $file_var ]`: This returns true if the given variable holds a regular
    file path or filename'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -f $file_var ]`：如果给定的变量保存的是一个常规文件路径或文件名，返回 true。'
- en: '`[ -x $var ]`: This returns true if the given variable holds a file path or
    filename that is executable'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -x $var ]`：如果给定的变量保存的是一个可执行的文件路径或文件名，返回 true。'
- en: '`[ -d $var ]`: This returns true if the given variable holds a directory path
    or directory name'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -d $var ]`：如果给定的变量保存的是目录路径或目录名称，返回 true。'
- en: '`[ -e $var ]`: This returns true if the given variable holds an existing file'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -e $var ]`：如果给定的变量保存的是一个存在的文件，返回 true。'
- en: '`[ -c $var ]`: This returns true if the given variable holds the path of a
    character device file'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -c $var ]`：如果给定的变量保存的是一个字符设备文件的路径，返回 true。'
- en: '`[ -b $var ]`: This returns true if the given variable holds the path of a
    block device file'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -b $var ]`：如果给定的变量保存的是一个块设备文件路径，返回 true。'
- en: '`[ -w $var ]`: This returns true if the given variable holds the path of a
    file that is writable'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -w $var ]`：如果给定的变量保存的是一个可写的文件路径，返回 true。'
- en: '`[ -r $var ]`: This returns true if the given variable holds the path of a
    file that is readable'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -r $var ]`：如果给定的变量保存的是一个可读的文件路径，返回 true。'
- en: '`[ -L $var ]`: This returns true if the given variable holds the path of'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -L $var ]`：如果给定的变量保存的是路径，返回 true。'
- en: a symlink
  id: totrans-723
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 符号链接
- en: 'Consider this example:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE192]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'String comparisons: When using string comparison, it is best to use double
    square brackets, since the use of single brackets can sometimes lead to errors'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串比较：在使用字符串比较时，最好使用双中括号，因为使用单中括号有时可能会导致错误。
- en: Note that the double square bracket is a Bash extension. If the script will
    be run using ash or dash (for better performance), you cannot use the double square.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，双中括号是 Bash 扩展。如果脚本将在 ash 或 dash 中运行（为了提高性能），则不能使用双中括号。
- en: '**Test if two strings are identical**:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试两个字符串是否相同**：'
- en: '`[[ $str1 = $str2 ]]`: This returns true when `str1` equals `str2`, that is,
    the text contents of `str1` and `str2` are the same'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 = $str2 ]]`：当 `str1` 等于 `str2` 时返回 true，即 `str1` 和 `str2` 的文本内容相同。'
- en: '`[[ $str1 == $str2 ]]`: It is an alternative method for string'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 == $str2 ]]`：这是另一种字符串比较的方法。'
- en: equality check
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相等性检查
- en: '**Test if two strings are not identical**:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试两个字符串是否不相同**：'
- en: '`[[ $str1 != $str2 ]]`: This returns true when `str1` and `str2` mismatch'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 != $str2 ]]`：当 `str1` 和 `str2` 不匹配时返回 true。'
- en: 'Find alphabetically larger string:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字母顺序上较大的字符串：
- en: Strings are compared alphabetically by comparing the ASCII value of the characters.
    For example, "A" is 0x41 and "a" is 0x61\. Thus "A" is less than "a", and "AAa"
    is less than "Aaa".
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通过比较字符的 ASCII 值按字母顺序进行比较。例如，"A" 是 0x41，而 "a" 是 0x61。因此，"A" 小于 "a"，而 "AAa"
    小于 "Aaa"。
- en: '`[[ $str1 > $str2 ]]`: This returns true when `str1` is alphabetically greater
    than `str2`'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 > $str2 ]]`：当 `str1` 在字母顺序上大于 `str2` 时返回 true。'
- en: '`[[ $str1 < $str2 ]]`: This returns true when `str1` is alphabetically lesser
    than `str2`'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 < $str2 ]]`：当 `str1` 在字母顺序上小于 `str2` 时返回 true。'
- en: A space is required after and before `=`; if it is not provided, it is not a
    comparison, but it becomes an assignment statement.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `=` 前后需要空格；如果没有提供空格，它就不是比较，而是赋值语句。
- en: '**Test for an empty string**:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试空字符串**：'
- en: '`[[ -z $str1 ]]`: This returns true if `str1` holds an empty string'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ -z $str1 ]]`：如果 `str1` 保存的是一个空字符串，返回 true。'
- en: '`[[ -n $str1 ]]`: This returns true if `str1` holds a nonempty string'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ -n $str1 ]]`：如果 `str1` 保存的是一个非空字符串，返回 true。'
- en: 'It is easier to combine multiple conditions using logical operators such as
    `&&` and `||`, as in the following code:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符 `&&` 和 `||` 来组合多个条件更为简便，如以下代码所示：
- en: '[PRE193]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Consider this example:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE194]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'This will be the output:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出：
- en: '[PRE195]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The test command can be used for performing condition checks. This reduces the
    number of braces used and can make your code more readable. The same test conditions
    enclosed within `[]` can be used with the test command.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 命令可以用来进行条件检查。这减少了使用大括号的数量，并且可以使代码更具可读性。`[]` 中的相同测试条件也可以与 `test` 命令一起使用。'
- en: Note that test is an external program which must be forked, while [ is an internal
    function in Bash and thus more efficient. The test program is compatible with
    Bourne shell, ash, dash, and others.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`test` 是一个外部程序，必须被 fork，而 `[` 是 Bash 中的内部函数，因此效率更高。`test` 程序与 Bourne shell、ash、dash
    等兼容。
- en: 'Consider this example:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE196]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Customizing bash with configuration files
  id: totrans-752
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用配置文件定制 bash
- en: Most commands you type on the command line can be placed in a special file,
    to be evaluated when you log in or start a new bash session. It's common to customize
    your shell by putting function definitions, aliases, and environment variable
    settings in one of these files.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 你在命令行中输入的大多数命令都可以放入一个特殊文件中，在登录或启动新的 bash 会话时进行评估。通过将函数定义、别名和环境变量设置放入这些文件之一来定制你的
    shell 是很常见的做法。
- en: 'Common commands to put into a configuration file include the following:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的命令可以放入配置文件中，包括以下内容：
- en: '[PRE197]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '**What customization file should I use?**'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该使用哪个定制文件？**'
- en: Linux and Unix have several files that might hold customization scripts. These
    configuration files are divided into three camps—those sourced on login, those
    evaluated when an interactive shell is invoked, and files evaluated whenever a
    shell is invoked to process a script file.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 Unix 有几个文件可能包含自定义脚本。这些配置文件分为三类——登录时加载的文件、交互式 shell 调用时评估的文件，以及每次 shell
    被调用以处理脚本文件时评估的文件。
- en: How to do it...
  id: totrans-758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'These files are evaluated when a user logs into a shell:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件会在用户登录到 shell 时被评估：
- en: '[PRE198]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Note that `/etc/profile`, `$HOME/.profile` and `$HOME/.bash_profile` may not
    be sourced if you log in via a graphical login manager. That's because the graphical
    window manager doesn't start a shell. When you open a terminal window, a shell
    is created, but it's not a login shell.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果通过图形登录管理器登录，则可能不会加载 `/etc/profile`、`$HOME/.profile` 和 `$HOME/.bash_profile`。这是因为图形窗口管理器不会启动
    shell。当你打开一个终端窗口时，会创建一个 shell，但这不是登录 shell。
- en: If a `.bash_profile` or `.bash_login` file is present, a `.profile` file will
    not be read.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在 `.bash_profile` 或 `.bash_login` 文件，则 `.profile` 文件不会被读取。
- en: 'These files will be read by an interactive shell such as a X11 terminal session
    or using `ssh` to run a single command like: `ssh 192.168.1.1 ls /tmp`.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件将被交互式 shell 读取，如 X11 终端会话，或使用 `ssh` 执行类似命令 `ssh 192.168.1.1 ls /tmp`。
- en: '[PRE199]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Run a shell script like this:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示运行 shell 脚本：
- en: '[PRE200]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'None of these files will be sourced unless you have defined the `BASH_ENV`
    environment variable:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你已定义了 `BASH_ENV` 环境变量，否则这些文件都不会被加载：
- en: '[PRE201]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Use `ssh` to run a single command, as with the following:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ssh` 执行单个命令，如下所示：
- en: '[PRE202]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: This will start a bash shell which will evaluate `/etc/bash.bashrc` and `$HOME/.bashrc`,
    but not `/etc/profile` or `.profile`.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个 bash shell，评估 `/etc/bash.bashrc` 和 `$HOME/.bashrc`，但不会评估 `/etc/profile`
    或 `.profile`。
- en: 'Invoke a ssh login session, like this:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 ssh 登录会话，如下所示：
- en: '[PRE203]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'This creates a new login bash shell, which will evaluate the following:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的登录 bash shell，系统将评估以下内容：
- en: '[PRE204]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'DANGER: Other shells, such as the traditional Bourne shell, ash, dash, and
    ksh, also read this file. Linear arrays (lists) and associative arrays, are not
    supported in all shells. Avoid using these in `/etc/profile` or `$HOME/.profile`.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 危险：其他外壳，如传统的 Bourne shell、ash、dash 和 ksh，也会读取此文件。线性数组（列表）和关联数组，并非所有外壳都支持。在 `/etc/profile`
    或 `$HOME/.profile` 中避免使用它们。
- en: 'Use these files to define non-exported items such as aliases desired by all
    users. Consider this example:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件来定义所有用户都希望拥有的非导出项，如别名。考虑这个例子：
- en: '[PRE205]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Use these files to hold personal settings. They are useful for setting paths
    that must be inherited by other bash instances. They might include lines like
    these:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件来存储个人设置。它们对于设置必须由其他 bash 实例继承的路径很有用。它们可能包含如下行：
- en: '[PRE206]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: If `.bash_login` or `.bash_profile` are present, `.profile` will not be read.
    A `.profile` file may be read by other shells.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `.bash_login` 或 `.bash_profile` 存在，`.profile` 文件将不会被读取。`.profile` 文件可能会被其他
    shell 读取。
- en: 'Use these files to hold your personal values that need to be defined whenever
    a new shell is created. Define aliases and functions here if you want them available
    in an X11 terminal session:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些文件来保存每次创建新 Shell 时需要定义的个人值。如果你希望它们在 X11 终端会话中可用，可以在这里定义别名和函数：
- en: '[PRE207]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Exported variables and functions are propagated to subordinate shells, but aliases
    are not. You must define `BASH_ENV` to be the `.bashrc` or `.profile`, where aliases
    are defined in order to use them in a shell script.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的变量和函数会传播到下级 Shell，但别名不会。你必须将 `BASH_ENV` 定义为 `.bashrc` 或 `.profile`，在这些文件中定义别名，才能在
    Shell 脚本中使用它们。
- en: 'This file is evaluated when a user logs out of a session:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登出会话时，此文件会被执行：
- en: '[PRE208]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: For example, if the user logs in remotely they should clear the screen when
    they log out.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户远程登录，他们在登出时应清除屏幕。
- en: '[PRE209]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
