- en: Shell Something Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying output in a terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables and environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function to prepend to environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Math with the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with file descriptors and redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and associative arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visiting aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grabbing information about the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and setting dates and delays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending output from one command to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading `n` characters without pressing the return key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a command until it succeeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field separators and iterators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons and tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing bash with configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the beginning, computers read a program from cards or tape and generated
    a single report. There was no operating system, no graphics monitors, not even
    an interactive prompt.
  prefs: []
  type: TYPE_NORMAL
- en: By the 1960s, computers supported interactive terminals (frequently a teletype
    or glorified typewriter) to invoke commands.
  prefs: []
  type: TYPE_NORMAL
- en: When Bell Labs created an interactive user interface for the brand new Unix
    operating system, it had a unique feature. It could read and evaluate the same
    commands from a text file (called a shell script), as it accepted being typed
    on a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: This facility was a huge leap forward in productivity. Instead of typing several
    commands to perform a set of operations, programmers could save the commands in
    a file and run them later with just a few keystrokes. Not only does a shell script
    save time, it also documents what you did.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Unix supported one interactive shell, written by Stephen Bourne,
    and named it the **Bourne Shell** (**sh**).
  prefs: []
  type: TYPE_NORMAL
- en: In 1989, Brian Fox of the GNU Project took features from many user interfaces
    and created a new shell—the **Bourne Again Shell** (**bash**). The bash shell
    understands all of the Bourne shell constructs and adds features from csh, ksh,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: As Linux has become the most popular implementation of Unix like operating systems,
    the bash shell has become the de-facto standard shell on Unix and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on Linux and bash. Even so, most of these scripts will run
    on both Linux and Unix, using bash, sh, ash, dash, ksh, or other sh style shells.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give readers an insight into the shell environment and demonstrate
    some basic shell features.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying output in a terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users interact with the shell environment via a terminal session. If you are
    running a GUI-based system, this will be a terminal window. If you are running
    with no GUI, (a production server or ssh session), you will see the shell prompt
    as soon as you log in.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text in the terminal is a task most scripts and utilities need to
    perform regularly. The shell supports several methods and different formats for
    displaying text.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commands are typed and executed in a terminal session. When a terminal is opened,
    a prompt is displayed. The prompt can be configured in many ways, but frequently
    resembles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can also be configured as `root@hostname #` or simply as
    `$` or `#`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `$` character represents regular users and `#` represents the administrative
    user root. Root is the most privileged user in a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: It is a bad idea to directly use the shell as the root user (administrator)
    to perform tasks. Typing errors have the potential to do more damage when your
    shell has more privileges. It is recommended that you log in as a regular user
    (your shell may denote this as `$` in the prompt), and use tools such as `sudo`
    to run privileged commands. Running a command as `sudo <command> <arguments>`
    will run it as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shell script typically begins with a shebang:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Shebang is a line on which `#!` is prefixed to the interpreter path. `/bin/bash`
    is the interpreter command path for Bash. A line starting with a `#` symbol is
    treated by the bash interpreter as a comment. Only the first line of a script
    can have a shebang to define the interpreter to be used to evaluate the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script can be executed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the name of the script as a command-line argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the execution permission on a script file to make it executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If a script is run as a command-line argument for `bash`, the shebang is not
    required. The shebang facilitates running the script on its own. Executable scripts
    use the interpreter path that follows the shebang to interpret a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scripts are made executable with the `chmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command makes a script executable by all users. The script can be executed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the script can be executed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel will read the first line and see that the shebang is `#!/bin/bash`.
    It will identify `/bin/bash` and execute the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When an interactive shell starts, it executes a set of commands to initialize
    settings, such as the prompt text, colors, and so on. These commands are read
    from a shell script at `~/.bashrc` (or `~/.bash_profile` for login shells), located
    in the home directory of the user. The Bash shell maintains a history of commands
    run by the user in the `~/.bash_history` file.
  prefs: []
  type: TYPE_NORMAL
- en: The `~` symbol denotes your home directory, which is usually `/home/user`, where
    user is your username or `/root` for the root user. A login shell is created when
    you log in to a machine. However, terminal sessions you create while logged in
    to a graphical environment (such as GNOME, KDE, and so on), are not login shells. Logging
    in with a display manager such as GDM or KDM may not read a `.profile` or `.bash_profile`
    (most don't), but logging in to a remote system with ssh will read the `.profile`. The
    shell delimits each command or command sequence with a semicolon or a new line.
    Consider this example: `$ cmd1 ; cmd2`
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ cmd1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ cmd2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comment starts with `#` and proceeds up to the end of the line. The comment
    lines are most often used to describe the code, or to disable execution of a line
    of code during debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let's move on to the basic recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `echo` command is the simplest command for printing in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `echo` adds a newline at the end of every echo invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply, using double-quoted text with the `echo` command prints the text in
    the terminal. Similarly, text without double quotes also gives the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to do the same task is with single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These methods appear similar, but each has a specific purpose and side effects.
    Double quotes allow the shell to interpret special characters within the string.
    Single quotes disable this interpretation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to print special characters such as `!`, you must either not use
    any quotes, use single quotes, or escape the special characters with a backslash
    (`\`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `echo` without quotes, we cannot use a semicolon, as a semicolon
    is the delimiter between commands in the Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding line, Bash takes `echo hello` as one command and the second
    `hello` as the second command.
  prefs: []
  type: TYPE_NORMAL
- en: Variable substitution, which is discussed in the next recipe, will not work
    within single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command for printing in the terminal is `printf`. It uses the same
    arguments as the C library `printf` function. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `printf` command takes quoted text or arguments delimited by spaces. It supports
    formatted strings. The format string specifies string width, left or right alignment,
    and so on. By default, `printf` does not append a newline. We have to specify
    a newline when required, as shown in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following formatted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `%s`, `%c`, `%d`, and `%f` characters are format substitution characters,
    which define how the following argument will be printed. The `%-5s` string defines
    a string substitution with left alignment (`-` represents left alignment) and
    a `5` character width. If `-` was not specified, the string would have been aligned
    to the right. The width specifies the number of characters reserved for the string.
    For `Name`, the width reserved is `10`. Hence, any name will reside within the
    10-character width reserved for it and the rest of the line will be filled with
    spaces up to 10 characters total.
  prefs: []
  type: TYPE_NORMAL
- en: For floating point numbers, we can pass additional parameters to round off the
    decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: For the Mark section, we have formatted the string as `%-4.2f`, where `.2` specifies
    rounding off to two decimal places. Note that for every line of the format string,
    a newline (`\n`) is issued.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using flags for `echo` and `printf`, place the flags before any strings
    in the command, otherwise Bash will consider the flags as another string.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping newline in echo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `echo` appends a newline to the end of its output text. Disable
    the newline with the `-n` flag. The `echo` command accepts escape sequences in
    double-quoted strings as an argument. When using escape sequences, use `echo`
    as `echo -e "string containing escape sequences"`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Printing a colored output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A script can use escape sequences to produce colored text on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Colors for text are represented by color codes, including, reset = 0, black
    = 30, red = 31, green = 32, yellow = 33, blue = 34, magenta = 35, cyan = 36, and
    white = 37.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print colored text, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `\e[1;31m` is the escape string to set the color to red and `\e[0m` resets
    the color back. Replace `31` with the required color code.
  prefs: []
  type: TYPE_NORMAL
- en: For a colored background, reset = 0, black = 40, red = 41, green = 42, yellow
    = 43, blue = 44, magenta = 45, cyan = 46, and white=47, are the commonly used
    color codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print a colored background, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These examples cover a subset of escape sequences. The documentation can be
    viewed with `man console_codes`.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables and environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All programming languages use variables to retain data for later use or modification.
    Unlike compiled languages, most scripting languages do not require a type declaration
    before a variable is created. The type is determined by usage. The value of a
    variable is accessed by preceding the variable name with a dollar sign. The shell
    defines several variables it uses for configuration and information like available
    printers, search paths, and so on. These are called **environment variables**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are named as a sequence of letters, numbers, and underscores with
    no whitespace. Common conventions are to use UPPER_CASE for environment variables
    and camelCase or lower_case for variables used within a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'All applications and scripts can access the environment variables. To view
    all the environment variables defined in your current shell, issue the `env` or
    `printenv` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the environment of other processes, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Set `PID` with a process ID of the process (`PID` is an integer value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume an application called `gedit` is running. We obtain the process ID of
    `gedit` with the `pgrep` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We view the environment variables associated with the process by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that the previous output has many lines stripped for convenience. The actual
    output contains more variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `/proc/PID/environ` special file contains a list of environment variables
    and their values. Each variable is represented as a name=value pair, separated
    by a null character (`\0`). This is not easily human readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a human-friendly report, pipe the output of the `cat` command to `tr`,
    to substitute the `\0` character with `\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assign a value to a variable with the equal sign operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The name of the variable is `varName` and `value` is the value to be assigned
    to it. If `value` does not contain any space character (such as space), it need
    not be enclosed in quotes, otherwise it must be enclosed in single or double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `var = value` and `var=value` are different. It is a usual mistake
    to write `var = value` instead of `var=value`. An equal sign without spaces is
    an assignment operation, whereas using spaces creates an equality test.
  prefs: []
  type: TYPE_NORMAL
- en: Access the contents of a variable by prefixing the variable name with a dollar
    sign (`$`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Variable values within double quotes can be used with `printf`, `echo`, and
    other shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because the shell uses a space to delimit words, we need to add curly braces
    to let the shell know that the variable name is `fruit`, not `fruit(s)`.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are inherited from the parent processes. For example,
    `HTTP_PROXY` is an environment variable that defines which proxy server to use
    for an Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, it is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `export` command declares one or more variables that will be inherited by
    child tasks. After variables are exported, any application executed from the current
    shell script, receives this variable. There are many standard environment variables
    created and used by the shell, and we can export our own variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PATH` variable lists the folders, which the shell will search
    for an application. A typical `PATH` variable will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Directory paths are delimited by the `:` character. Usually, `$PATH` is defined
    in `/etc/environment`, `/etc/profile` or `~/.bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a new path to the `PATH` environment, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added `/home/user/bin` to `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the well-known environment variables are `HOME`, `PWD`, `USER`, `UID`,
    and `SHELL`.
  prefs: []
  type: TYPE_NORMAL
- en: When using single quotes, variables will not be expanded and will be displayed
    as it is. This means, `$ echo '$var'` will display `$var`.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas, `$ echo "$var"` will display the value of the `$var` variable if it
    is defined, or nothing if it is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shell has many more built-in features. Here are a few more:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the length of a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Get the length of a variable''s value with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `length` parameter is the number of characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the current shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To identify the shell which is currently being used, use the `SHELL environment`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, by executing the `echo $0` command, we will get the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Checking for super user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `UID` environment variable holds the User ID. Use this value to check whether
    the current script is being run as a root user or regular user. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `[` is actually a command and must be separated from the rest of
    the string with spaces. We can also write the preceding script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `UID` value for the root user is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Bash prompt string (username@hostname:~$)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we open a terminal or run a shell, we see a prompt such as `user@hostname:
    /home/$`. Different GNU/Linux distributions have different prompts and different
    colors. The `PS1` environment variable defines the primary prompt. The default
    prompt is defined by a line in the `~/.bashrc` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'View the line used to set the `PS1` variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify the prompt, enter the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We can use colored text using the special escape sequences such as `\e[1;31`
    (refer to the *Displaying output in a terminal *recipe of this chapter).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain special characters expand to system parameters. For example, `\u` expands
    to username, `\h` expands to hostname, and `\w` expands to the current working
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Function to prepend to environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Environment variables are often used to store a list of paths of where to search
    for executables, libraries, and so on. Examples are `$PATH` and  `$LD_LIBRARY_PATH`,
    which will typically resemble this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This means that whenever the shell has to execute an application (binary or
    script), it will first look in `/usr/bin` and then search `/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: When building and installing a program from source, we often need to add custom
    paths for the new executable and libraries. For example, we might install `myapp`
    in `/opt/myapp`, with binaries in a `/opt/myapp/bin` folder and libraries in `/opt/myapp/lib`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example shows how to add new paths to the beginning of an environment variable.
    The first example shows how to do this with what's been covered so far, the second
    demonstrates creating a function to simplify modifying the variable. Functions
    are covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PATH` and `LD_LIBRARY_PATH` variables should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can make adding a new path easier by defining a prepend function in the `.bashrc`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `prepend()` function first confirms that the directory specified by the
    second parameter to the function exists. If it does, the `eval` expression sets
    the variable, with the name in the first parameter equal to the second parameter
    string, followed by `:` (the path separator), and then the original value for
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the variable is empty when we try to prepend, there will be a trailing `:`
    at the end. To fix this, modify the function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this form of the function, we introduce a shell parameter expansion of the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${parameter:+expression}`'
  prefs: []
  type: TYPE_NORMAL
- en: This expands to expression if parameter is set and is not null.
  prefs: []
  type: TYPE_NORMAL
- en: With this change, we take care to try to append `:` and the old value if, and
    only if, the old value existed when trying to prepend.
  prefs: []
  type: TYPE_NORMAL
- en: Math with the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bash shell performs basic arithmetic operations using the `let`, `(( ))`,
    and `[]` commands. The `expr` and `bc` utilities are used to perform advanced
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A numeric value is assigned to a variable the same way strings are assigned.
    The value will be treated as a number by the methods that access it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `let` command is used to perform basic operations directly. Within a `let`
    command, we use variable names without the `$` prefix. Consider this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Other uses of `let` command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this for increment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For decrement, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these for shorthands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These are equal to `let no=no+6` and `let no=no-6`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternate methods are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[]` operator is used in the same way as the `let` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the $ prefix inside the [] operator is legal; consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `(( ))` operator can also be used. The prefix variable names          
                 with a `$` within the `(( ))` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expr` expression can be used for basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The preceding methods do not support floating point numbers,
  prefs: []
  type: TYPE_NORMAL
- en: and operate on integers only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bc` application, the precision calculator, is an advanced utility for
    mathematical operations. It has a wide range of options. We can perform floating
    point arithmetic and use advanced functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `bc` application accepts prefixes to control the operation. These are separated
    from each other with a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decimal places scale with bc**: In the following example, the `scale=2` parameter
    sets the number of decimal places to `2`. Hence, the output of `bc` will contain
    a number with two decimal places:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**Base conversion with bc**: We can convert from one base number system to
    another one. This code converts numbers from decimal to binary and binary to decimal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The following examples demonstrate calculating squares and square roots:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Playing with file descriptors and redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File descriptors are integers associated with the input and output streams.
    The best-known file descriptors are `stdin`, `stdout`, and `stderr`. The contents
    of one stream can be redirected to another. This recipe shows examples on how
    to manipulate and redirect with file descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell scripts frequently use standard input (`stdin`), standard output (`stdout`),
    and standard error (`stderr`). A script can redirect output to a file with the
    greater-than symbol. Text generated by a command may be normal output or an error
    message. By default, both normal output (`stdout`) and error messages (`stderr`)
    are sent to the display. The two streams can be separated by specifying a specific
    descriptor for each stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'File descriptors are integers associated with an opened file or data stream.
    File descriptors 0, 1, and 2 are reserved, as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: `stdin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: `stdout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: `stderr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the greater-than symbol to append text to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This stores the echoed text in `temp.txt`. If `temp.txt` already exists, the
    single greater-than sign will delete any previous contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use double-greater-than to append text to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `cat` to view the contents of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The next recipes demonstrate redirecting `stderr`. A message is printed to
    the `stderr` stream when a command generates an error message. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here `+` is an invalid argument and hence an error is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Successful and unsuccessful commands
  prefs: []
  type: TYPE_NORMAL
- en: When a command exits because of an error, it returns a nonzero exit status.
    The command returns zero when it terminates after successful completion. The return
    status is available in the special variable `$?` (run echo `$?` immediately after
    the command execution statement to print the exit status).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command prints the `stderr` text to the screen rather than to
    a file (and because there is no `stdout` output, `out.txt` will be empty):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following command, we redirect `stderr` to `out.txt` with `2>` (two
    greater-than):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can redirect `stderr` to one file and `stdout` to another file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to redirect `stderr` and `stdout` to a single file by converting
    `stderr` to `stdout` using this preferred method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be done even using an alternate approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t want to see or save any error messages, you can redirect the
    stderr output to `/dev/null`, which removes it completely. For example, consider
    that we have three files `a1`, `a2`, and `a3`. However, `a1` does not have the
    read-write-execute permission for the user. To print the contents of all files
    starting with the letter `a`, we use the `cat` command. Set up the test files
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying the contents of the files using wildcards (`a*`), will generate
    an error message for the `a1` file because that file does not have the proper
    read permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `cat: a1: Permission denied` belongs to the `stderr` data. We can redirect
    the `stderr` data into a file, while sending `stdout` to the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Some commands generate output that we want to process and also save for future
    reference or other processing. The `stdout` stream is a single stream that we
    can redirect to a file or pipe to another program. You might think there is no
    way for us to have our cake and eat it too.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a way to redirect data to a file, while providing a copy of
    redirected data as `stdin` to the next command in a pipe. The `tee` command reads
    from `stdin` and redirects the input data to `stdout` and one or more files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the `stdin` data is received by the `tee` command. It
    writes a copy of `stdout` to the `out.txt` file and sends another copy as `stdin`
    for the next command. The `cat -n` command puts a line number for each line received
    from `stdin` and writes it into `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `cat` to examine the contents of `out.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe that `cat: a1: Permission denied` does not appear, because it was sent
    to `stderr`. The `tee` command reads only from `stdin`.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `tee` command overwrites the file. Including the `-a` option
    will force it to append the new data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Commands with arguments follow the format: `command FILE1 FILE2 ...` or simply
    `command FILE`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To send two copies of the input to `stdout`, use `-` for the filename argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Alternately, we can use `/dev/stdin` as the output filename to use `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, use `/dev/stderr` for standard error and `/dev/stdout` for standard
    output. These are special device files that correspond to `stdin`, `stderr`, and
    `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The redirection operators (`>` and `>>`) send output to a file instead of the
    terminal. The `>` and `>>` operators behave slightly differently. Both redirect
    output to a file, but the single greater-than symbol (`>`) empties the file and
    then writes to it, whereas the double greater-than symbol (`>>`) adds the output
    to the end of the existing file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the redirection operates on standard output. To explicitly take
    a specific file descriptor, you must prefix the descriptor number to the operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `>` operator is equivalent to `1>` and similarly it applies for `>>` (equivalent
    to `1>>`).
  prefs: []
  type: TYPE_NORMAL
- en: When working with errors, the `stderr` output is dumped to the `/dev/null` file.
    The `./dev/null` file is a special device file where any data received by the
    file is discarded. The null device is often known as a **black hole**, as all
    the data that goes into it is lost forever.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commands that read input from `stdin` can receive data in multiple ways. It
    is possible to specify file descriptors of our own, using `cat` and pipes. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Redirection from a file to a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can read data from a file as `stdin` with the less-than symbol (`<`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting from a text block enclosed within a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Text can be redirected from a script into a file. To add a warning to the top
    of an automatically generated file, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines that appear between `cat <<EOF >log.txt` and the next `EOF` line
    will appear as the `stdin` data. The contents of `log.txt` are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Custom file descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A file descriptor is an abstract indicator for accessing a file. Each file access
    is associated with a special number called a file descriptor. 0, 1, and 2 are
    reserved descriptor numbers for `stdin`, `stdout`, and `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `exec` command can create new file descriptors. If you are familiar with
    file access in other programming languages, you may be familiar with the modes
    for opening files. These three modes are commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: Read mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write with append mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write with truncate mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<` operator reads from the file to `stdin`. The `>` operator writes to
    a file with truncation (data is written to the target file after truncating the
    contents). The `>>` operator writes to a file by appending (data is appended to
    the existing file contents and the contents of the target file will not be lost).
    File descriptors are created with one of the three modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file descriptor for reading a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use file descriptor `3` with commands. For example, we will use
    `cat<&3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: If a second read is required, we cannot reuse the file descriptor `3`. We must
    create a new file descriptor (perhaps 4) with `exec` to read from another file
    or re-read from the first file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file descriptor for writing (truncate mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a file descriptor for writing (append mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and associative arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays allow a script to store a collection of data as separate entities using
    indices. Bash supports both regular arrays that use integers as the array index,
    and associative arrays, which use a string as the array index. Regular arrays
    should be used when the data is organized numerically, for example, a set of successive
    iterations. Associative arrays can be used when the data is organized by a string,
    for example, host names. In this recipe, we will see how to use both of these.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use associate arrays, you must have Bash Version 4 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arrays can be defined using different techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an array using a list of values in a single line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, define an array as a set of index-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the contents of an array at a given index using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Print all of the values in an array as a list, using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the length of an array (the number of elements in an array):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Associative arrays have been introduced to Bash from Version 4.0\. When the
    indices are a string (site names, user names, nonsequential numbers, and so on),
    an associative array is easier to work with than a numerically indexed array.
  prefs: []
  type: TYPE_NORMAL
- en: Defining associative arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An associative array can use any text data as an array index. A declaration
    statement is required to define a variable name as an associative array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After the declaration, elements are added to the associative array using either
    of these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline index-value list method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Separate index-value assignments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, consider the assignment of prices for fruits, using an associative
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the contents of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Listing of array indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays have indexes for indexing each of the elements. Ordinary and associative
    arrays differ in terms of index type.
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the list of indexes in an array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can also use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous `fruits_value` array example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: This will work for ordinary arrays too.
  prefs: []
  type: TYPE_NORMAL
- en: Visiting aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **alias** is a shortcut to replace typing a long-command sequence. In this
    recipe, we will see how to create aliases using the `alias` command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the operations you can perform on aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an alias:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This example creates a shortcut for the `apt-get install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Once the alias is defined, we can type `install` instead of `sudo apt-get install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alias` command is temporary: aliases exist until we close the current
    terminal. To make an alias available to all shells, add this statement to the
    `~/.bashrc` file. Commands in `~/.bashrc` are always executed when a new interactive
    shell process is spawned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: To remove an alias, remove its entry from `~/.bashrc` (if any) or use the `unalias`
    command. Alternatively, `alias example=` should unset the alias named `example`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This example creates an alias for `rm` that will delete the original and keep
    a copy in a backup directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: When you create an alias, if the item being aliased already exists, it will
    be replaced by this newly aliased command for that user.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When running as a privileged user, aliases can be a security breach. To avoid
    compromising your system, you should escape commands.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given how easy it is to create an alias to masquerade as a native command,
    you should not run aliased commands as a privileged user. We can ignore any aliases
    currently defined, by escaping the command we want to run. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The `\` character escapes the command, running it without any aliased changes.
    When running privileged commands on an untrusted environment, it is always a good
    security practice to ignore aliases by prefixing the command with `\`. The attacker
    might have aliased the privileged command with his/her own custom command, to
    steal critical information that is provided by the user to the command.
  prefs: []
  type: TYPE_NORMAL
- en: Listing aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `alias` command lists the currently defined aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Grabbing information about the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing command-line shell scripts, we often need to manipulate information
    about the current terminal, such as the number of columns, rows, cursor positions,
    masked password fields, and so on. This recipe helps in collecting and manipulating
    terminal settings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tput` and `stty` commands are utilities used for terminal manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some capabilities of the `tput` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the number of columns and rows in a terminal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the current terminal name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the cursor to a 100,100 position:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the terminal background color:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The value of `n` can be a value in the range of 0 to 7
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the terminal foreground color:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The value of `n` can be a value in the range of 0 to 7
  prefs: []
  type: TYPE_NORMAL
- en: Some commands including the common `color ls` may reset the foreground and background
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make text bold, using this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform start and end underlining:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete from the cursor to the end of the line, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'A script should not display the characters while entering a password. The following
    example demonstrates disabling character echo with the `stty` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The `-echo` option in the preceding command disables the output to the terminal,
    whereas `echo` enables output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting dates and delays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A time delay is used to wait a set amount of time(such as 1 second) during the
    program execution, or to monitor a task every few seconds (or every few months).
    Working with times and dates requires an understanding of how time and date are
    represented and manipulated. This recipe will show you how to work with dates
    and time delays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates can be printed in a variety of formats. Internally, dates are stored as
    an integer number of seconds since 00:00:00 1970-01-01\. This is called **epoch**
    or **Unix time**.
  prefs: []
  type: TYPE_NORMAL
- en: The system's date can be set from the command line. The next recipes demonstrate
    how to read and set dates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to read the dates in different formats and also to set the date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the epoch time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The date command can convert many formatted date strings into the epoch time.
    This lets you use dates in multiple date formats as input. Usually, you don't
    need to bother about the date string format you use if you are collecting the
    date from a system log or any standard application generated output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert the date string into epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--date` option defines a date string as input. We can use any date formatting
    options to print the output. The date command can be used to find the day of the
    week given a date string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The date format strings are listed in the table mentioned in the *How it works...*
    section
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a combination of format strings prefixed with `+` as an argument for the
    `date` command, to print the date in the format of your choice. Consider this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the date and time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'On a system connected to a network, you''ll want to use `ntpdate` to set the
    date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/usr/sbin/ntpdate -s time-b.nist.gov`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rule for optimizing your code is to measure first. The date command can
    be used to time how long it takes a set of commands to execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The date command''s minimum resolution is one second. A better method for timing
    commands is the `time` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`time commandOrScriptName`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unix epoch is defined as the number of seconds that have elapsed since
    midnight proleptic **Coordinated Universal Time** (**UTC**) of January 1, 1970,
    not counting leap seconds. Epoch time is useful when you need to calculate the
    difference between two dates or times. Convert the two date strings to epoch and
    take the difference between the epoch values. This recipe calculates the number
    of seconds between two dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a time in seconds since midnight of January 1, 1970, is not easily
    read by humans. The date command supports output in human readable formats.
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists the format options that the date command supports.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date component** | **Format** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Weekday | `%a` (for example, Sat)`%A` (for example, Saturday) |'
  prefs: []
  type: TYPE_TB
- en: '| Month | `%b` (for example, Nov)`%B` (for example, November) |'
  prefs: []
  type: TYPE_TB
- en: '| Day | `%d` (for example, 31) |'
  prefs: []
  type: TYPE_TB
- en: '| Date in format (mm/dd/yy) | `%D` (for example, 10/18/10) |'
  prefs: []
  type: TYPE_TB
- en: '| Year | `%y` (for example, 10)`%Y` (for example, 2010) |'
  prefs: []
  type: TYPE_TB
- en: '| Hour | `%I` or `%H` (For example, 08) |'
  prefs: []
  type: TYPE_TB
- en: '| Minute | `%M` (for example, 33) |'
  prefs: []
  type: TYPE_TB
- en: '| Second | `%S` (for example, 10) |'
  prefs: []
  type: TYPE_TB
- en: '| Nano second | `%N` (for example, 695208515) |'
  prefs: []
  type: TYPE_TB
- en: '| Epoch Unix time in seconds | `%s` (for example, 1290049486) |'
  prefs: []
  type: TYPE_TB
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing time intervals is essential when writing monitoring scripts that execute
    in a loop. The following examples show how to generate time delays.
  prefs: []
  type: TYPE_NORMAL
- en: Producing delays in a script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The sleep command will delay a script''s execution period of time given in
    `seconds`. The following script counts from 0 to 40 seconds using `tput` and `sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a variable steps through the list of numbers generated
    by the `seq` command. We use `tput sc` to store the cursor position. On every
    loop execution, we write the new count in the terminal by restoring the cursor
    position using `tput rc`, and then clearing to the end of the line with `tputs
    ed`. After the line is cleared, the script echoes the new value. The sleep command
    causes the script to delay for 1 second between each iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging frequently takes longer than writing code. A feature every programming
    language should implement is to produce trace information when something unexpected
    happens. Debugging information can be read to understand what caused the program
    to behave in an unexpected fashion. Bash provides debugging options every developer
    should know. This recipe shows how to use these options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can either use Bash''s inbuilt debugging tools or write our scripts in such
    a manner that they become easy to debug; here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `-x` option to enable debug tracing of a shell script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Running the script with the `-x` flag will print each source line with the current
    status.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `sh -x script`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug only portions of the script using `set -x` and `set +x`. Consider this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, the debug information for `echo $i` will only be printed,
    as debugging is restricted to that section using `-x` and `+x`.
  prefs: []
  type: TYPE_NORMAL
- en: The script uses the `{start..end}` construct to iterate from a start to end
    value, instead of the `seq` command used in the previous example. This construct
    is slightly faster than invoking the `seq` command.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned debugging methods are provided by Bash built-ins. They produce
    debugging information in a fixed format. In many cases, we need debugging information
    in our own format. We can define a _DEBUG environment variable to enable and disable
    debugging and generate messages in our own debugging style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding script with debugging set to "on":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: We prefix `DEBUG` before every statement where debug information is to be printed.
    If `_DEBUG=on` is not passed to the script, debug information will not be printed.
    In Bash, the command `:` tells the shell to do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-x` flag outputs every line of script as it is executed. However, we may
    require only some portions of the source lines to be observed. Bash uses a `set
    builtin` to enable and disable debug printing within the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set -x`: This displays arguments and commands upon their execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set +x`: This disables debugging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set -v`: This displays input when they are read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set +v`: This disables printing input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use other convenient ways to debug scripts. We can make use of shebang
    in a trickier way to debug scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Shebang hack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The shebang can be changed from `#!/bin/bash` to `#!/bin/bash -xv` to enable
    debugging without any additional flags (`-xv` flags themselves).
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be hard to track execution flow in the default output when each line
    is preceded by `+`. Set the PS4 environment variable to `''$LINENO:''` to display
    actual line numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugging output may be long. When using `-x` or set `-x`, the debugging
    output is sent to `stderr`. It can be redirected to a file with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash 4.0 and later support using a numbered stream for debugging output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Functions and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and aliases appear similar at a casual glance, but behave slightly
    differently. The big difference is that function arguments can be used anywhere
    within the body of the function, while an alias simply appends arguments to the
    end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function is defined with the function command, a function name, open/close
    parentheses, and a function body enclosed in curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function is defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'It can even be defined as follows (for simple functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'A function is invoked using its name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments passed to functions are accessed positionally, `$1` is the first
    argument, `$2` is the second, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The following is the definition of the function `fname`. In the `fname` function,
    we have included various ways of accessing the function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments passed to scripts can be accessed as `$0` (the name of the script):'
  prefs: []
  type: TYPE_NORMAL
- en: '`$1` is the first argument'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2` is the second argument'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$n` is the *n*th argument'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$@"` expands as `"$1" "$2" "$3"` and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$*"` expands as `"$1c$2c$3"`, where `c` is the first character of IFS'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"$@"` is used more often than `$*`, since the former provides all arguments
    as a single string'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compare alias to function**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an alias to display a subset of files by piping `ls` output to `grep`.
    The argument is attached to the end of the command, so `lsg txt` is expanded to
    `ls | grep txt`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to expand that to get the IP address for a device in `/sbin/ifconfig`,
    we might try the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grep` command found the `eth0` string, not the IP address. If we use a
    function instead of an alias, we can pass the argument to the `ifconfig`, instead
    of appending it to the `grep`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore more tips on Bash functions.
  prefs: []
  type: TYPE_NORMAL
- en: The recursive function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions in Bash also support recursion (the function can call itself). For
    example, `F() { echo $1; F hello; sleep 1; }`.
  prefs: []
  type: TYPE_NORMAL
- en: Fork bomb
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive function is a function that calls itself: recursive functions must
    have an exit condition, or they will spawn until the system exhausts a resource
    and crashes.'
  prefs: []
  type: TYPE_NORMAL
- en: This function: `:(){ :|:& };:` spawns processes forever and ends up in a denial-of-service
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: The `&` character is postfixed with the function call to bring the subprocess
    into the background. This dangerous code forks processes forever and is called
    a fork bomb.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it difficult to interpret the preceding code. Refer to the Wikipedia
    page [h t t p ://e n . w i k i p e d i a . o r g /w i k i /F o r k _ b o m b](https://en.wikipedia.org/wiki/Fork_bomb)
    for more details and interpretation of the fork bomb.
  prefs: []
  type: TYPE_NORMAL
- en: Prevent this attack by restricting the maximum number of processes that can
    be spawned by defining the `nproc` value in `/etc/security/limits.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line will limit all users to 100 processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hard nproc 100`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exporting functions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can be exported, just like environment variables, using the `export`
    command. Exporting extends the scope of the function to subprocesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Reading the return value (status) of a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The return value of a command is stored in the `$?` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The return value is called **exit status**. This value can be used to determine
    whether a command completed successfully or unsuccessfully. If the command exits
    successfully, the exit status will be zero, otherwise it will be a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script reports the success/failure status of a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Passing arguments to commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications accept arguments in different formats. Suppose `-p` and `-v`
    are the options available, and `-k N` is another option that takes a number. Also,
    the command requires a filename as argument. This application can be executed
    in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ command -p -v -k 1 file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ command -pv -k 1 file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ command -vpk 1 file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ command file -pvk 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within a script, the command-line arguments can be accessed by their position
    in the command line. The first argument will be `$1`, the second `$2`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will display the first three command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s more common to iterate through the command arguments one at a time. The
    `shift` command shifts eachh argument one space to the left, to let a script access
    each argument as `$1`. The following code displays all the command-line values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Sending output from one command to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best features of the Unix shells is the ease of combining many commands
    to produce a report. The output of one command can appear as the input to another,
    which passes its output to another command, and so on. The output of this sequence
    can be assigned to a variable. This recipe illustrates how to combine multiple
    commands and how the output can be read.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The input is usually fed into a command through `stdin` or arguments. The output
    is sent to `stdout` or `stderr`. When we combine multiple commands, we usually
    supply input via `stdin` and generate output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this context, the commands are called **filters**. We connect each filter
    using pipes, sympolized by the piping operator (`|`), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Here, we combine three commands. The output of `cmd1` goes to `cmd2`, the output
    of `cmd2` goes to `cmd3`, and the final output (which comes out of `cmd3`) will
    be displayed on the monitor, or directed to a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipes can be used with the subshell method for combining outputs of multiple
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with combining two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The output of `ls` (the listing of the current directory) is passed to `cat
    -n`, which in turn prepends line numbers to the input received through `stdin`.
    The output is redirected to `out.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the output of a sequence of commands to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'This is called the **subshell method**. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method, called **back quotes** (some people also refer to it as **back
    tick**) can also be used to store the command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Back quote is different from the single-quote character. It is the character
    on the *~* button on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways of grouping commands.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a separate process with subshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Subshells are separate processes. A subshell is defined using the `( )` operators:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pwd` command prints the path of the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `cd` command changes the current directory to the given directory path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: When commands are executed in a subshell, none of the changes occur in the current
    shell; changes are restricted to the subshell. For example, when the current directory
    in a subshell is changed using the `cd` command, the directory change is not reflected
    in the main shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: Subshell quoting to preserve spacing and the newline character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose we are assigning the output of a command to a variable using a subshell
    or the back quotes method, we must use double quotes to preserve the spacing and
    the newline character (`\n`). Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Reading n characters without pressing the return key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bash command `read` inputs text from the keyboard or standard input. We
    can use `read` to acquire input from the user interactively, but `read` is capable
    of more. Most input libraries in any programming language read the input from
    the keyboard and terminate the string when return is pressed. There are certain
    situations when return cannot be pressed and string termination is done based
    on a number of characters received (perhaps a single character). For example,
    in an interactive game, a ball is moved upward when *+* is pressed. Pressing *+*
    and then pressing *return* to acknowledge the *+* press is not efficient.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses the `read` command to accomplish this task without having to
    press *return*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use various options of the `read` command to obtain different results,
    as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement will read *n* characters from input into the `variable_name`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Read a password in the non-echoed mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Display a message with `read` using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the input after a timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a delimiter character to end the input line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Running a command until it succeeds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a command can only succeed when certain conditions are met. For example,
    you can only download a file after the file is created. In such cases, one might
    want to run a command repeatedly until it succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Define a function in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, add this to your shell''s `rc` file for ease of use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This repeat function has an infinite `while` loop, which attempts to run the
    command passed as a parameter (accessed by `$@`) to the function. It returns if
    the command was successful, thereby exiting the loop.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a basic way to run commands until they succeed. Let's make things more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: A faster approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On most modern systems, true is implemented as a binary in `/bin`. This means
    that each time the aforementioned `while` loop runs, the shell has to spawn a
    process. To avoid this, we can use the shell built-in `:` command, which always
    returns an exit code 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Though not as readable, this is faster than the first approach.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a delay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say you are using `repeat()` to download a file from the Internet which
    is not available right now, but will be after some time. An example would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will send too much traffic to the web server at `www.example.com`,
    which causes problems for the server (and maybe for you, if the server blacklists
    your IP as an attacker). To solve this, we modify the function and add a delay,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the command to run every 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Field separators and iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **internal field separator** (**IFS**) is an important concept in shell
    scripting. It is useful for manipulating text data.
  prefs: []
  type: TYPE_NORMAL
- en: An IFS is a delimiter for a special purpose. It is an environment variable that
    stores delimiting characters. It is the default delimiter string used by a running
    shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the case where we need to iterate through words in a string or **comma
    separated values** (**CSV**). In the first case, we will use `IFS=" "` and in
    the second, `IFS=","`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the case of CSV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The default value of IFS is a white-space (newline, tab, or a space character).
  prefs: []
  type: TYPE_NORMAL
- en: When IFS is set as `,` the shell interprets the comma as a delimiter character,
    therefore, the `$item` variable takes substrings separated by a comma as its value
    during the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: If IFS is not set as `,` then it will print the entire data as a single string.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go through another example usage of IFS to parse the `/etc/passwd` file.
    In the `/etc/passwd` file, every line contains items delimited by `:`. Each line
    in the file corresponds to an attribute related to a user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the input: `root:x:0:0:root:/root:/bin/bash`. The last entry on each
    line specifies the default shell for the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print users and their default shells using the IFS hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Loops are very useful in iterating through a sequence of values. Bash provides
    many types of loops.
  prefs: []
  type: TYPE_NORMAL
- en: '**List-oriented `for` loop**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: A list can be a string or a sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can generate sequences with the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: We can combine these to concatenate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, in each iteration, the variable i will hold a character
    in the a to z range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '**Iterate through a range of numbers**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '**Loop until a condition is met**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The while loop continues while a condition is true, the until loop runs until
    a condition is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'For an infinite loop, use `true` as the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use a `until` loop**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A special loop called `until` is available with Bash. This executes the loop
    until the given condition becomes true. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Comparisons and tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flow control in a program is handled by comparison and test statements. Bash
    comes with several options to perform tests. We can use `if`, `if else`, and logical
    operators to perform tests and comparison operators to compare data items. There
    is also a command called `test`, which performs tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some methods used for comparisons and performing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an `if` condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `else if` and `else`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting is possible with if and else. The if conditions can be lengthy; to
    make them shorter we can use logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ condition ] && action;` # action executes if the condition is true'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ condition ] || action;` # action executes if the condition is false'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` is the logical AND operation and `||` is the logical OR operation. This
    is a very helpful trick while writing Bash scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Performing mathematical comparisons: usually, conditions are enclosed in square
    brackets `[]`. Note that there is a space between `[` or `]` and operands. It
    will show an error if no space is provided.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform mathematical tests on variables and values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Other important operators include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-gt`: Greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-lt`: Less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ge`: Greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-le`: Less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-a` operator is a logical AND and the `-o` operator is the logical OR.
    Multiple test conditions can be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Filesystem-related tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Test different filesystem-related attributes using different condition flags
  prefs: []
  type: TYPE_NORMAL
- en: '`[ -f $file_var ]`: This returns true if the given variable holds a regular
    file path or filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -x $var ]`: This returns true if the given variable holds a file path or
    filename that is executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -d $var ]`: This returns true if the given variable holds a directory path
    or directory name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -e $var ]`: This returns true if the given variable holds an existing file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -c $var ]`: This returns true if the given variable holds the path of a
    character device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -b $var ]`: This returns true if the given variable holds the path of a
    block device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -w $var ]`: This returns true if the given variable holds the path of a
    file that is writable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -r $var ]`: This returns true if the given variable holds the path of a
    file that is readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[ -L $var ]`: This returns true if the given variable holds the path of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a symlink
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'String comparisons: When using string comparison, it is best to use double
    square brackets, since the use of single brackets can sometimes lead to errors'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the double square bracket is a Bash extension. If the script will
    be run using ash or dash (for better performance), you cannot use the double square.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test if two strings are identical**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 = $str2 ]]`: This returns true when `str1` equals `str2`, that is,
    the text contents of `str1` and `str2` are the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ $str1 == $str2 ]]`: It is an alternative method for string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: equality check
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Test if two strings are not identical**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 != $str2 ]]`: This returns true when `str1` and `str2` mismatch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Find alphabetically larger string:'
  prefs: []
  type: TYPE_NORMAL
- en: Strings are compared alphabetically by comparing the ASCII value of the characters.
    For example, "A" is 0x41 and "a" is 0x61\. Thus "A" is less than "a", and "AAa"
    is less than "Aaa".
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ $str1 > $str2 ]]`: This returns true when `str1` is alphabetically greater
    than `str2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ $str1 < $str2 ]]`: This returns true when `str1` is alphabetically lesser
    than `str2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A space is required after and before `=`; if it is not provided, it is not a
    comparison, but it becomes an assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test for an empty string**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[[ -z $str1 ]]`: This returns true if `str1` holds an empty string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[[ -n $str1 ]]`: This returns true if `str1` holds a nonempty string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is easier to combine multiple conditions using logical operators such as
    `&&` and `||`, as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The test command can be used for performing condition checks. This reduces the
    number of braces used and can make your code more readable. The same test conditions
    enclosed within `[]` can be used with the test command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that test is an external program which must be forked, while [ is an internal
    function in Bash and thus more efficient. The test program is compatible with
    Bourne shell, ash, dash, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Customizing bash with configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most commands you type on the command line can be placed in a special file,
    to be evaluated when you log in or start a new bash session. It's common to customize
    your shell by putting function definitions, aliases, and environment variable
    settings in one of these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common commands to put into a configuration file include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '**What customization file should I use?**'
  prefs: []
  type: TYPE_NORMAL
- en: Linux and Unix have several files that might hold customization scripts. These
    configuration files are divided into three camps—those sourced on login, those
    evaluated when an interactive shell is invoked, and files evaluated whenever a
    shell is invoked to process a script file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These files are evaluated when a user logs into a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Note that `/etc/profile`, `$HOME/.profile` and `$HOME/.bash_profile` may not
    be sourced if you log in via a graphical login manager. That's because the graphical
    window manager doesn't start a shell. When you open a terminal window, a shell
    is created, but it's not a login shell.
  prefs: []
  type: TYPE_NORMAL
- en: If a `.bash_profile` or `.bash_login` file is present, a `.profile` file will
    not be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'These files will be read by an interactive shell such as a X11 terminal session
    or using `ssh` to run a single command like: `ssh 192.168.1.1 ls /tmp`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Run a shell script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'None of these files will be sourced unless you have defined the `BASH_ENV`
    environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ssh` to run a single command, as with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: This will start a bash shell which will evaluate `/etc/bash.bashrc` and `$HOME/.bashrc`,
    but not `/etc/profile` or `.profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke a ssh login session, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new login bash shell, which will evaluate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'DANGER: Other shells, such as the traditional Bourne shell, ash, dash, and
    ksh, also read this file. Linear arrays (lists) and associative arrays, are not
    supported in all shells. Avoid using these in `/etc/profile` or `$HOME/.profile`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these files to define non-exported items such as aliases desired by all
    users. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Use these files to hold personal settings. They are useful for setting paths
    that must be inherited by other bash instances. They might include lines like
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: If `.bash_login` or `.bash_profile` are present, `.profile` will not be read.
    A `.profile` file may be read by other shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these files to hold your personal values that need to be defined whenever
    a new shell is created. Define aliases and functions here if you want them available
    in an X11 terminal session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Exported variables and functions are propagated to subordinate shells, but aliases
    are not. You must define `BASH_ENV` to be the `.bashrc` or `.profile`, where aliases
    are defined in order to use them in a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file is evaluated when a user logs out of a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: For example, if the user logs in remotely they should clear the screen when
    they log out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
