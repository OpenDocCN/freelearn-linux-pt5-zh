["```\nstruct irq_chip {\n    struct device    *parent_device;\n    const char       *name;\n    void   (*irq_enable)(struct irq_data *data);\n    void   (*irq_disable)(struct irq_data *data);\n    void   (*irq_ack)(struct irq_data *data);\n    void   (*irq_mask)(struct irq_data *data);\n    void   (*irq_unmask)(struct irq_data *data);\n    void   (*irq_eoi)(struct irq_data *data);\n    int    (*irq_set_affinity)(struct irq_data *data,\n                const struct cpumask *dest, bool force);\n    int    (*irq_retrigger)(struct irq_data *data);\n    int    (*irq_set_type)(struct irq_data *data,\n                           unsigned int flow_type);\n    int    (*irq_set_wake)(struct irq_data *data,\n                           unsigned int on);\n    void   (*irq_bus_lock)(struct irq_data *data);\n    void   (*irq_bus_sync_unlock)(struct irq_data *data);\n    int   (*irq_get_irqchip_state)(struct irq_data *data,\n               enum irqchip_irq_state which, bool *state);\n    int   (*irq_set_irqchip_state)(struct irq_data *data,\n               enum irqchip_irq_state which, bool state);\n    void  (*ipi_send_single)(struct irq_data *data, \n                              unsigned int cpu);\n   void   (*ipi_send_mask)(struct irq_data *data,\n                           const struct cpumask *dest);\n    unsigned long    flags;\n};\n```", "```\nstruct irq_domain {\n    const char *name;\n    const struct irq_domain_ops *ops;\n    void *host_data;\n    unsigned int flags;\n    unsigned int mapcount;\n    /* Optional data */\n    struct fwnode_handle *fwnode;\n    [...]\n};\n```", "```\n    struct irq_domain *irq_domain_add_linear(\n                       struct device_node *of_node,\n                       unsigned int size,\n                       const struct irq_domain_ops *ops,\n                       void *host_data)\n    ```", "```\n    struct irq_domain *irq_domain_add_tree(\n                      struct device_node *of_node,\n                      const struct irq_domain_ops *ops,\n                      void *host_data)\n    ```", "```\n    struct irq_domain *irq_domain_add_nomap(\n                       struct device_node *of_node,\n                       unsigned int max_irq,\n                       const struct irq_domain_ops *ops,\n                       void *host_data)\n    ```", "```\nunsigned int irq_create_mapping(struct irq_domain \n              *domain, irq_hw_number_t hwirq)\n```", "```\nstruct irq_domain_ops {\n    int (*map)(struct irq_domain *d, unsigned int virq,\n          irq_hw_number_t hw);\n    void (*unmap)(struct irq_domain *d, \n                   unsigned int virq);\n    int (*xlate)(struct irq_domain *d, \n                   struct device_node *node,\n                   const u32 *intspec,\n                   unsigned int intsize,\n                   unsigned long *out_hwirq, \n                   unsigned int *out_type);\n[...]\n};\n```", "```\n    void irq_set_chip_and_handler(unsigned int irq,\n                              struct irq_chip *chip,\n                              irq_flow_handler_t handle)\n    ```", "```\nstatic int ativic32_irq_domain_map(\n                struct irq_domain *id,\n                unsigned int virq, \n                irq_hw_number_t hw)\n{\n[...]\n    if (int_trigger_type & (BIT(hw))) {\n        irq_set_chip_and_handler(virq, \n                     &ativic32_chip,\n                     handle_edge_irq);\n        type = IRQ_TYPE_EDGE_RISING;\n    } else {\n        irq_set_chip_and_handler(virq, \n                     &ativic32_chip, \n                     handle_level_irq);\n        type = IRQ_TYPE_LEVEL_HIGH;\n    }\n    irqd_set_trigger_type(irq_data, type);\n    return 0;\n}\n```", "```\nstatic struct irq_domain_ops mcp23016_irq_domain_ops = {\n    .map    = mcp23016_irq_domain_map,\n    .xlate  = irq_domain_xlate_twocell,\n};\n```", "```\nstruct irq_desc {\n    struct irq_data        irq_data;\n    unsigned int __percpu  *kstat_irqs;\n    irq_flow_handler_t     handle_irq;\n    struct irqaction       *action;\n    unsigned int           irqs_unhandled;\n    raw_spinlock_t         lock;\n    struct cpumask         *percpu_enabled;\n    atomic_t               threads_active;\n    wait_queue_head_t      wait_for_threads;\n#ifdef CONFIG_PM_SLEEP\n    unsigned int           nr_actions;\n    unsigned int           no_suspend_depth;\n    unsigned int           force_resume_depth;\n#endif\n#ifdef CONFIG_PROC_FS\n    struct proc_dir_entry   *dir;\n#endif\n    Int               parent_irq;\n    struct module     *owner;\n    const char        *name;\n};\n```", "```\nstruct irqaction {\n    irq_handler_t     handler;\n    void              *dev_id;\n    void __percpu     *percpu_dev_id;\n    struct irqaction  *next;\n    irq_handler_t     thread_fn;\n    struct task_struct     *thread;\n    unsigned int      irq;\n    unsigned int      flags;\n    unsigned long     thread_flags;\n    unsigned long     thread_mask;\n    const char        *name;\n    struct proc_dir_entry   *dir;\n};\n```", "```\nstruct irq_data {\n    [...]\n    unsigned int     irq;\n    unsigned long           hwirq;\n    struct irq_chip         *chip;\n    struct irq_domain *domain;\n    void              *chip_data;\n};\n```", "```\nint request_any_context_irq(unsigned int irq,\n                            irq_handler_t handler,\n                            unsigned long flags,\n                            const char * name,\n                            void * dev_id);\n```", "```\nstatic irqreturn_t packt_btn_interrupt(int irq,\n                                        void *dev_id)\n{\n    struct btn_data *priv = dev_id;\n    input_report_key(priv->i_dev, BTN_0,\n                   gpiod_get_value(priv->btn_gpiod) & 1);\n    input_sync(priv->i_dev);\n    return IRQ_HANDLED;\n}\nstatic int btn_probe(struct platform_device *pdev)\n{\n    struct gpio_desc *gpiod;\n    int ret, irq;\n    [...]\n    gpiod = gpiod_get(&pdev->dev, \"button\", GPIOD_IN);\n    if (IS_ERR(gpiod))\n        return -ENODEV;\n    priv->irq = gpiod_to_irq(priv->btn_gpiod);\n    priv->btn_gpiod = gpiod;\n    [...]\n    ret = request_any_context_irq(\n            priv->irq,\n            packt_btn_interrupt,\n            (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),\n            \"packt-input-button\", priv);\n    if (ret < 0) {\n        dev_err(&pdev->dev,\n           \"Unable to request GPIO interrupt line\\n\");\n        goto err_btn;\n    }\n    return ret;\n}\n```", "```\nint request_threaded_irq(unsigned int irq, \n                  irq_handler_t handler,\n                  irq_handler_t thread_fn, \n                  unsigned long irqflags,\n                  const char *devname, void *dev_id)\n```", "```\naction->handler = handler;\naction->thread_fn = thread_fn;\naction->flags = irqflags;\naction->name = devname;\naction->dev_id = dev_id;\n```", "```\nhandle_arch_irq = mdesc->handle_irq\n```", "```\nset_handle_irq(gic_handle_irq);\n```", "```\nenum ipi_msg_type {\n    IPI_WAKEUP,\n    IPI_TIMER,\n    IPI_RESCHEDULE,\n    IPI_CALL_FUNC,\n    IPI_CPU_STOP,\n    IPI_IRQ_WORK,\n    IPI_COMPLETION,\n    NR_IPI,\n[...]\n    MAX_IPI\n};\n```", "```\nstatic const char *ipi_types[NR_IPI] = {\n    [IPI_WAKEUP] = \"CPU wakeup interrupts\",\n    [IPI_TIMER] = \"Timer broadcast interrupts\",\n    [IPI_RESCHEDULE] = \"Rescheduling interrupts\",\n    [IPI_CALL_FUNC]  = \"Function call interrupts\",\n    [IPI_CPU_STOP]   = \"CPU stop interrupts\",\n    [IPI_IRQ_WORK]   = \"IRQ work interrupts\",\n    [IPI_COMPLETION] = \"completion interrupts\",\n};\n```", "```\nvoid __init set_smp_ipi_range(int ipi_base, int n)\n{\n    int i;\n    WARN_ON(n < MAX_IPI);\n    nr_ipi = min(n, MAX_IPI);\n    for (i = 0; i < nr_ipi; i++) {\n        int err;\n        err = request_percpu_irq(ipi_base + i,\n                 ipi_handler, \"IPI\", &irq_stat);\n        WARN_ON(err);\n        ipi_desc[i] = irq_to_desc(ipi_base + i);\n        irq_set_status_flags(ipi_base + i, IRQ_HIDDEN);\n    }\n    ipi_irq_base = ipi_base;\n    /* Setup the boot CPU immediately */\n    ipi_setup(smp_processor_id());\n}\n```", "```\nstatic irqreturn_t ipi_handler(int irq, void *data)\n{\n    do_handle_IPI(irq - ipi_irq_base);\n    return IRQ_HANDLED;\n}\n```", "```\nstatic void do_handle_IPI(int ipinr)\n{\n    unsigned int cpu = smp_processor_id();\n    if ((unsigned)ipinr < NR_IPI)\n        trace_ipi_entry_rcuidle(ipi_types[ipinr]);\n    switch (ipinr) {\n    case IPI_WAKEUP:\n        break;\n#ifdef CONFIG_GENERIC_CLOCKEVENTS_BROADCAST\n    case IPI_TIMER:\n        tick_receive_broadcast();\n        break;\n#endif\n    case IPI_RESCHEDULE:\n        scheduler_ipi();\n        break;\n    case IPI_CPU_STOP:\n        ipi_cpu_stop(cpu);\n        break;\n[...]\n    default:\n        pr_crit(\"CPU%u: Unknown IPI message 0x%x\\n\",\n                cpu, ipinr);\n        break;\n    }\n    if ((unsigned)ipinr < NR_IPI)\n         trace_ipi_exit_rcuidle(ipi_types[ipinr]);\n}\n```", "```\nroot@udoo-labcsmart:~# cat /proc/interrupts | grep IPI\nIPI0:          0          0  CPU wakeup interrupts\nIPI1:         29         22  Timer broadcast interrupts\nIPI2:      84306     322774  Rescheduling interrupts\nIPI3:        970       1264  Function call interruptsIPI4:          0          0  CPU stop interrupts\nIPI5:    2505436    4064821  IRQ work interrupts\nIPI6:          0          0  completion interrupts\nroot@udoo-labcsmart:~#\n```"]