<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Blinking Lights and Sensing the World"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Blinking Lights and Sensing the World</h1></div></div></div><p>Until now, we have covered several aspects of Cubieboard, but they were all software-related. When interfacing with real-world scenarios, ranging from blinking a <span class="strong"><strong>Light Emitting Diode</strong></span> (<span class="strong"><strong>LED</strong></span>) and <a id="id368" class="indexterm"/>switching on a light to spinning motors, things become much more interesting. There are numerous things you can do once you connect the board to the various devices available today. A robot vacuum cleaner very much started its development life on a development board, where engineers connected various sensors to make the robot see what was around it. Connecting all these devices can be highly complex and might involve more than just the basics of electronics; therefore, this chapter will be dedicated to the fundamentals of electronics to help you to get to grips with some basics in connecting an LED, making it blink, and connecting a button to respond to a push.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An overview of a few concepts in basic electronics</li><li class="listitem" style="list-style-type: disc">How to toggle a <a id="id369" class="indexterm"/><span class="strong"><strong>General Purpose Input/Output</strong></span> (<span class="strong"><strong>GPIO</strong></span>)</li><li class="listitem" style="list-style-type: disc">How to connect a button and read its status</li></ul></div><div class="section" title="Making an LED glow"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Making an LED glow</h1></div></div></div><p>A world <a id="id370" class="indexterm"/>without LEDs seems almost unimaginable today. They inform us of messages on our smartphones, they have been used as indicator lights on TV and stereo equipment for years, and there are even big screens built of nothing but LEDs. Ironically, the invention of the LED was more of an annoying side effect of the first diodes. The intention was not to emit light at all, and in early equipment, the diodes were covered in black paint to hide their glow. The name LED is so ubiquitous that their meaning might almost have been forgotten.</p><p>Making an LED glow, however, does require a few tricks and some know-how to make sure not to break it. Each LED has<a id="id371" class="indexterm"/> certain characteristics, such as the amount of voltage it requires to function and the maximum amount of current that can flow through it. A blue LED, for example, requires more voltage and more current than a red LED. It is, therefore, imperative to know the technical details of an LED.</p><div class="section" title="Resistance required"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec38"/>Resistance required</h2></div></div></div><p>An LED is<a id="id372" class="indexterm"/> just a special form of diode. It is a one-way street <a id="id373" class="indexterm"/>for electricity, that is, the current is only allowed to travel in one predefined way. Also, caution must be taken while connecting an LED; if it is connected in the wrong direction, no current will flow at all, thus emitting no light. The other way around, however, is more interesting.</p><p>Let us examine what happens when an LED is connected in the correct direction. Once a certain threshold voltage is supplied, read the forward voltage, the diode starts conducting, and the LED emits light. As for the current flowing through the diode, things look a little different. A diode will conduct all the current that is supplied to it. Different kinds of diodes serve different purposes in the electric design that they are used; in the case of LEDs, the purpose is often to emit light. These types of diodes often can only sustain a very small amount of current to flow through them, usually in the milliampere range. A resistor, as the name suggests, restricts the flow of the current going through it and thus is used for regulation of current, as depicted in the following diagram:</p><div class="mediaobject"><img src="graphics/1572OS_08_01.jpg" alt="Resistance required"/></div><p>There are plenty websites that can help in calculating the correct resistance for a given voltage and current; the math behind it is not very complex. Ohm's law is the common formula used to calculate resistances. It is represented as follows:</p><div class="mediaobject"><img src="graphics/1572OS_08_07.jpg" alt="Resistance required"/></div><p>And:</p><div class="mediaobject"><img src="graphics/1572OS_08_08.jpg" alt="Resistance required"/></div><p>To calculate <a id="id374" class="indexterm"/>the resistance, <span class="inlinemediaobject"><img src="graphics/1572OS_08_09.jpg" alt="Resistance required"/></span>, the voltage, <span class="inlinemediaobject"><img src="graphics/1572OS_08_10.jpg" alt="Resistance required"/></span>, needs to be divided <a id="id375" class="indexterm"/>by the current <span class="inlinemediaobject"><img src="graphics/1572OS_08_11.jpg" alt="Resistance required"/></span>. Let us understand how we determine the required voltage. For this, the diode's forward voltage is subtracted from the available voltage. This produces the following variant of Ohm's law:</p><div class="mediaobject"><img src="graphics/1572OS_08_12.jpg" alt="Resistance required"/></div><p>Let us assume that our voltage source is 3.0 volt and the forward voltage of the diode is 1.2 volt. Suppose the required current for this example is 30 milliampere, then filling in these values in Ohm's law yields the following result:</p><p>From this little bit of math, we understand that a resistance of 60 Ohm is required to make the LED glow without trying to consume all the available current. A resistor of 60 Ohm, however, might be hard to find, and only two options are available. Connect several <a id="id376" class="indexterm"/>resistors in series, one after another, to obtain the required value, or find a resistor that is reasonably<a id="id377" class="indexterm"/> close in value, such as 68 Ohm. Rearranging Ohm's law and filling it in yields 26.5 milliampere of current flowing through the LED. This should generally be enough to light up the LED. This calculation can be seen in the following formula:</p><div class="mediaobject"><img src="graphics/1572OS_08_13.jpg" alt="Resistance required"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip23"/>Tip</h3><p>Using a resistor to limit the current flowing through an LED is not the most power-efficient method of lighting up an LED, but is very common and the simplest method. Ideally, a constant current supply is recommended, which would no longer require a resistor. After all, the maximum available current to the LED is what it would like to receive in the first place. While out of the scope of this book, it is a good exercise, to learn more about constant current power supplies and driving LEDs.</p></div></div></div><div class="section" title="Sinking and sourcing"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec39"/>Sinking and sourcing</h2></div></div></div><p>To connect a device to a GPIO, it would be ideal if the GPIO can deliver the correct voltage and current. Unfortunately, this<a id="id378" class="indexterm"/> rarely is the case. The voltage supplied by a pin is often either the supply voltage or the I/O voltage, both of which are input voltages to the chip. In the case of the Allwinner A series of chips, this will be 3.3 volt. The amount of current a GPIO can deliver or absorb is limited. Supplying current, or sourcing, as it is called, can vary from 10 milliampere to 40 milliampere. The amount of current a pin can source is configured in the FEX file, which is explained in more detail in <a class="link" href="apc.html" title="Appendix C. The FEX Configuration File">Appendix C</a>, <span class="emphasis"><em>The FEX Configuration File</em></span>. The opposite of sourcing is sinking, but before that is covered, let us first examine the following diagram where an LED is connected directly to a GPIO:</p><div class="mediaobject"><img src="graphics/1572OS_08_02.jpg" alt="Sinking and sourcing"/></div><p>In the preceding diagram, it is quite obvious that the GPIO pin supplies the voltage and the current flows through<a id="id379" class="indexterm"/> the diode into the ground. The GPIO is the "source" of the current. The opposite is possible too; the GPIO absorbs or sinks the current, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/1572OS_08_03.jpg" alt="Sinking and sourcing"/></div><p>In the preceding diagram, the diode gets supplied with a voltage and current from a power source; in electronics, it is often called VCC. The current then flows as before through the diode and through the resistor, and is then absorbed by the GPIO. The GPIO "sinks" the current. While this second method works just as well as the first, there are a few things to notice. The power source needs to supply an appropriate voltage, or the GPIO can get overloaded and burn up parts or even the whole chip. On the software side, the pin will function in the opposite way; when the GPIO is high, the voltage is the same as that of VCC and thus no current flows. If the pin is set to low, the voltage can now flow.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip24"/>Tip</h3><p>An observant reader will probably notice that if the GPIO is set up to a source of 30 milliampere, a resistor is not even needed. While it is bad practice, it is still possible; however, it should never be done in a final design.</p></div></div></div></div></div>
<div class="section" title="Amplifying the voltage and current"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Amplifying the voltage and current</h1></div></div></div><p>All the preceding <a id="id380" class="indexterm"/>methods work only if a small amount of current <a id="id381" class="indexterm"/>is required. What do you do when there is a higher <a id="id382" class="indexterm"/>current demanded? In this case, a simple transistor is used. A transistor can be thought of like a valve on a water pipe. Normally, the valve is closed and no water is allowed to flow. When current is applied to the base <span class="strong"><strong>B</strong></span> of the <a id="id383" class="indexterm"/>transistor, the valve slowly starts to open and conduct current from the collector <span class="strong"><strong>C</strong></span> to the emitter <span class="strong"><strong>E</strong></span>. The flow of current is proportional to the current applied to the base, as a transistor is by nature a current amplifier. In addition to that, the current applied to the base is also added to the output of the emitter, as shown in the following diagram:</p><div class="mediaobject"><img src="graphics/1572OS_08_04.jpg" alt="Amplifying the voltage and current"/></div><p>The voltage supplied via the VCC is determined by the specification of the transistor, not the GPIO. It is <a id="id384" class="indexterm"/>easily possible that 24 volt is regulated via the transistor, assuming the transistor allows this, while controlling it via the 3.3 volt of the GPIO. In essence, this is a voltage amplifier, and a transistor is most commonly used for this effect.</p><p>There are two <a id="id385" class="indexterm"/>kinds of transistors: PNP and NPN. The general working of an NPN transistor was explained in the previous paragraph. The PNP transistor works the other way around, meaning it conducts current by default when there is no current applied to the base of the transistor via the GPIO. If current is applied to the transistors' base, the transistor will stop conducting current.</p></div>
<div class="section" title="Controlling pins from software"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Controlling pins from software</h1></div></div></div><p>There are<a id="id386" class="indexterm"/> several ways to<a id="id387" class="indexterm"/> control a GPIO from within Linux. From within the kernel through a driver or from one of the many programming languages, such as a C program or a Python script. The quickest and most basic way, however, is right from the console. This is assuming, of course, that the driver to control the GPIOs is loaded as a module or compiled into the kernel. Refer to <a class="link" href="ch07.html" title="Chapter 7. Compiling the Bootloader and Kernel Using a BSP">Chapter 7</a>, <span class="emphasis"><em>Compiling the Bootloader and Kernel Using a BSP</em></span>, to recompile a kernel and to add the GPIO driver. Depending on the kernel version used, it is called the <span class="emphasis"><em>GPIO support for the sunxi platform</em></span> and can be found under <span class="strong"><strong>GPIO</strong></span> in the <span class="strong"><strong>Device Drivers</strong></span> option. Depending on which GPIO is used, the FEX file will need to be modified to configure the GPIO pin. To set up one pin as output GPIO, the following code snippet can be used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[gpio_para]</strong></span>
<span class="strong"><strong>gpio_used = 1</strong></span>
<span class="strong"><strong>gpio_num = 1</strong></span>
<span class="strong"><strong>gpio_pin_1 = port:PB03&lt;1&gt;&lt;1&gt;&lt;default&gt;&lt;default&gt;&lt;default&gt;</strong></span>
</pre></div><p>If everything has been set up appropriately, the GPIO pins can be toggled via the filesystem, for example, writing <code class="literal">1</code> into <code class="literal">pb03</code> makes the GPIO high, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~ $ echo 1 &gt; /sys/devices/virtual/misc/sunxi-gpio/pin/pb03</strong></span>
</pre></div><p>Similarly, writing <code class="literal">0</code> makes it low again.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Not only is a transistor required on higher current loads from one pin, often there is a maximum current that can be sourced from all the combined GPIOs. Thus, the best method to control things is to always use a transistor.</p></div></div></div>
<div class="section" title="Pulling up and pulling down"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Pulling up and pulling down</h1></div></div></div><p>A GPIO that is configured as an input simply takes a measurement of the voltage applied to it. If it is above a certain threshold, it is considered to be high, or <code class="literal">1</code>. If it is below <a id="id388" class="indexterm"/>a certain threshold, it is considered as <code class="literal">0</code>. In the case of the Allwinner A series, generally speaking, everything above 2.5 volt is considered high, and everything below 0.8 volt is <code class="literal">0</code>. Anything in between is undefined and could be either <code class="literal">0</code> or <code class="literal">1</code>.</p><p>With that knowledge at hand, it is easy to just have a three-way switch and connect it to either the ground or the 3.3 volt. The following diagram illustrates a switch directly connected to a GPIO:</p><div class="mediaobject"><img src="graphics/1572OS_08_05.jpg" alt="Pulling up and pulling down"/></div><p>There are a few caveats to consider. There is a transition phase, where the switch moves <a id="id389" class="indexterm"/>from one state to the other and the voltage could be anything between 3.3 volt and 0 volt. Additionally, the maximum amount of current that a pin can source will flow into the GPIO, making a very inefficient design and could even damage the chip. Both issues can be addressed by connecting either state permanently to the GPIO via a resistor. If a resistor is used to permanently connect the VCC, it is called a <a id="id390" class="indexterm"/>pull-up resistor, as the resistor pulls the voltage up. If the resistor is used to pull the pin down to ground, it is called a pull-down resistor, as the resistor pulls the voltage down to ground. The following diagram demonstrates the usage of a pull-up resistor in conjunction with a switch:</p><div class="mediaobject"><img src="graphics/1572OS_08_06.jpg" alt="Pulling up and pulling down"/></div><p>In this scenario, the GPIO will see the high voltage and interpret it as a logical <code class="literal">1</code>. When the switch is pressed, the <a id="id391" class="indexterm"/>current prefers to take the path of least resistance, and as the GPIO has a natural resistance internally, the ground is where all the current will go.</p><p>If the <a id="id392" class="indexterm"/>positions of the switch and the resistor are swapped, a pull-down circuit is created. In such a scenario, by default the GPIO will see the low voltage<a id="id393" class="indexterm"/> and interpret it as a logical <code class="literal">0</code>. When the switch is pressed, the current will naturally flow to the ground and the GPIO interprets it as a logical <code class="literal">1</code>.</p><p>In both cases, the resistor value needs to be calculated in much the same way as the resistor for the LED was. Ideally, the resistor will be as high as possible so that only a very limited amount of current can flow, thus not wasting any power. Choosing a resistor that is too high, however, results in too little current to flow, and thus the pin cannot sense the voltage.</p><p>In both these cases of the Allwinner SoC, there is an internal pull-up or <a id="id394" class="indexterm"/>pull-down resistor available that can be configured via the FEX file. The following command can be used in this case:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[gpio_para]</strong></span>
<span class="strong"><strong>gpio_used = 1</strong></span>
<span class="strong"><strong>gpio_num = 1</strong></span>
<span class="strong"><strong>gpio_pin_1 = port:PB03&lt;1&gt;&lt;0&gt;&lt;1&gt;&lt;default&gt;&lt;default&gt;</strong></span>
</pre></div><p>For additional details, see <a class="link" href="apc.html" title="Appendix C. The FEX Configuration File">Appendix C</a>, <span class="emphasis"><em>The FEX Configuration File</em></span>. The choice of whether to use a pull-up resistor or a pull-down resistor depends on the project's requirements. Generally speaking, if the pin has to be read as <code class="literal">0</code> by default and changed to <code class="literal">1</code> when a button is pressed, a pull-down resistor is used. In practice, however, a pull-up resistor tends to be <a id="id395" class="indexterm"/>more power efficient and is commonly used.</p></div>
<div class="section" title="Reading a switch"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Reading a switch</h1></div></div></div><p>Reading the <a id="id396" class="indexterm"/>status of a switch is similar to writing to the LED. All the prerequisites apply equally. The only difference is that the GPIO is read via <code class="literal">cat</code>, rather than written via <code class="literal">echo</code>, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~ $ cat /sys/devices/virtual/misc/sunxi-gpio/pin/pb03</strong></span>
<span class="strong"><strong>1</strong></span>
</pre></div><p>Using this knowledge, reading a button can be done from various programming languages in various forms.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip25"/>Tip</h3><p>A good exercise can be to write a simple script that reads the status of the button and makes the LED reflect this status. Both of the previous examples use the same pin as GPIO, so a second pin will need to be configured as GPIO if not already configured.</p></div></div><p>From here on out, there are many more ways and methods to interact. There are <a id="id397" class="indexterm"/>
<span class="strong"><strong>analog-to-digital converters</strong></span> (<span class="strong"><strong>ADCs</strong></span>) available to read an analog voltage, the <span class="strong"><strong>Serial Peripheral Interface</strong></span> (<span class="strong"><strong>SPI</strong></span>)<a id="id398" class="indexterm"/> bus and the <span class="strong"><strong>Inter-IC</strong></span> (<span class="strong"><strong>I2C</strong></span>) bus, also known as the <a id="id399" class="indexterm"/>
<span class="strong"><strong>Two Wire Interface</strong></span> (<span class="strong"><strong>TWI</strong></span>), to connect a plethora of peripherals, each allowing wonderful inventions to be created. Since this is an introductory book, going into detail would require many more pages explaining the various techniques. But hopefully, an interest has been sparked in you to find resources to continue experimenting and working with Allwinner-based boards.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Summary</h1></div></div></div><p>In this chapter, we covered some fundamental electronics, teaching the reader how to connect an LED and a switch. We also covered the most common pitfalls and best practices when interfacing with LED switches. Blinking an LED is considered as the Hello World of embedded development.</p></div></body></html>