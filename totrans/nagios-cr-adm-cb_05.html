<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Monitoring Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Monitoring Methods</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monitoring PING for any host</li><li class="listitem" style="list-style-type: disc">Monitoring SSH for any host</li><li class="listitem" style="list-style-type: disc">Checking an alternative SSH port</li><li class="listitem" style="list-style-type: disc">Monitoring mail services</li><li class="listitem" style="list-style-type: disc">Monitoring web services</li><li class="listitem" style="list-style-type: disc">Checking that a website returns a given string</li><li class="listitem" style="list-style-type: disc">Monitoring database services</li><li class="listitem" style="list-style-type: disc">Monitoring the output of an SNMP query</li><li class="listitem" style="list-style-type: disc">Monitoring a RAID or other hardware device</li><li class="listitem" style="list-style-type: disc">Creating an SNMP OID to monitor</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Introduction</h1></div></div></div><p>Nagios Core is <a id="id241" class="indexterm"/>best thought of as a monitoring framework that uses plugins to perform appropriate checks on hosts and services, and returns results about their states in a format that it understands and can use for sending notifications and keeping track of states on a long-term basis.</p><p>The design is quite flexible. As explained in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span>, Nagios Core can use as a plugin any command-line application that gives appropriate return values as defined in the Nagios Core header files, Perl library, or shell script. In turn, Nagios Core can be configured to use the same plugin in many different ways, taking advantage of any switch provided by the plugin to adjust its behavior, including providing metadata to it in the form of the values of Nagios Core macros, such as <code class="literal">$HOSTADDRESS$</code>.</p><p>The collection of plugins available on the Nagios Exchange<a id="id242" class="indexterm"/> website at <a class="ulink" href="http://exchange.nagios.org/">http://exchange.nagios.org/</a> is fairly large, and documenting all of them is well out of the scope of this book. However, some of the most useful plugins are included as part of the Nagios Plugins set, and are installed as part of the recommended quick start guides for Nagios Core<a id="id243" class="indexterm"/> at <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/quickstart.html">http://nagios.sourceforge.net/docs/3_0/quickstart.html</a>. They include programs to monitor very common network features in typical ways, such as monitoring basic network connectivity, web services, mail servers, and many others. The plugin site itself is at <a class="ulink" href="http://nagiosplugins.org/">http://nagiosplugins.org/</a>.</p><p>This chapter will demonstrate the usage of some of the most useful components of this plugin set, which it assumes you have already installed. The focus will be on monitoring tasks that will be relevant to most or even all networks of various sizes, hopefully bringing the reader well past the point of thinking of Nagios Core as merely a process to send PING requests. The last few recipes will show how you can use the <span class="strong"><strong>Simple Network Management Protocol</strong></span> (<span class="strong"><strong>SNMP</strong></span>)<a id="id244" class="indexterm"/> as a method for checking any generic network service or system property that may not be covered by the standard Nagios Plugins set.</p></div></div>
<div class="section" title="Monitoring PING for any host"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Monitoring PING for any host</h1></div></div></div><p>In this recipe, we'll learn how to set up PING monitoring for a host. We'll use the <code class="literal">check_ping</code> plugin, and its command of the same name, to send <code class="literal">ICMP</code> <code class="literal">ECHO</code> requests to a host. We'll use this as a simple diagnostic check to make sure <a id="id245" class="indexterm"/>
<a id="id246" class="indexterm"/>that the host's network stack is responding in a consistent and timely fashion, in much the same way as an administrator might use the <code class="literal">ping</code> command interactively to check the same properties.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec152"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">corinth.naginet</code>, a host defined in its own file. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec153"/>How to do it...</h2></div></div></div><p>We can add a new PING service check to our existing host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the objects configuration <a id="id247" class="indexterm"/>directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        windows-server
    host_name  corinth.naginet
    alias      corinth
    address    10.128.0.27
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a service definition referring to <code class="literal">check_ping</code>. You may like to use the <code class="literal">generic-service</code> template, as follows:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            corinth.naginet
    service_description  PING
    check_command        check_ping!100,20%!200,40%
}</pre></div></li><li class="listitem">Validate the configuration and restart the <a id="id248" class="indexterm"/>Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service check will start taking place, with the appropriate contacts and contact groups notified when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>Round Trip Time</strong></span> (<span class="strong"><strong>RTT</strong></span>)<a id="id249" class="indexterm"/> of the request and its response exceeds 200ms, or more than 40 percent of the packets are lost during the check; a <code class="literal">CRITICAL</code> notification is fired for the service in either case.</li><li class="listitem" style="list-style-type: disc">If a <code class="literal">CRITICAL</code> notification was not fired, and the RTT of the request and its response exceeds 100ms, or more than 20 percent of the packets are lost during the check; in this case, a <code class="literal">WARNING</code> notification is fired for the service.</li></ul></div><p>The information about the thresholds is given in the definition for the <code class="literal">check_command</code> directive<a id="id250" class="indexterm"/>, as arguments to the <code class="literal">check_ping</code> command<a id="id251" class="indexterm"/>.</p><p>More information about this service will also be visible in the web interface, under the <span class="strong"><strong>Services</strong></span> section.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec154"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section defines a new service check on the existing <code class="literal">corinth.naginet</code> host<a id="id252" class="indexterm"/> to check that the RTT and the packet loss for an <code class="literal">ICMP</code> <code class="literal">ECHO</code> request and response are within acceptable limits.</p><p>For most network configurations, it may well be the case that the host itself is also being checked by <code class="literal">check_ping</code>, by way of the command <code class="literal">check-host-alive</code>. The difference is that the thresholds for the RTT and packet loss are intentionally set very high for this command, because it is intended to establish whether the host is up or down at all, not how responsive it is.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec155"/>There's more...</h2></div></div></div><p>In networks where most of the hosts are configured to respond to <code class="literal">ICMP</code> <code class="literal">ECHO</code> requests, it could perhaps be worthwhile to configure service checks on all of the hosts in a configuration. This can be done using the <code class="literal">*</code> wildcard when defining <code class="literal">host_name</code> for the service:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            *
    service_description  PING
    check_command        check_ping!100,20%!200,40%
}</pre></div><p>This will apply the same check, with a <code class="literal">service_description</code> directive of <code class="literal">PING</code>, to all of the hosts configured in the database. This method will save the hassle of configuring a service separately for all the hosts.</p><p>If some of the hosts in a network do not respond to PING, it may be more appropriate to place the ones that do in a hostgroup, perhaps named something such as <code class="literal">icmp</code>:</p><div class="informalexample"><pre class="programlisting">define hostgroup {
    hostgroup_name  icmp
    alias           ICMP enabled hosts
    members         sparta.naginet,corinth.naginet
}</pre></div><p>The single service can then be applied to all the hosts in that group, using the <code class="literal">hostgroup_name</code> directive<a id="id253" class="indexterm"/> in the <code class="literal">service</code> definition:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    hostgroup_name       icmp
    service_description  PING
    check_command        check_ping!100,20%!200,40%
}</pre></div><p>It's generally a good idea to have network hosts respond to ICMP messages wherever possible, in order to comply with the recommendations in RFC1122 and to ease debugging.</p><p>Finally, note that the thresholds for the RTT and the packet loss are not fixed; in fact, they're defined in the service definition, in the <code class="literal">check_command</code> line. For hosts that have higher latency, perhaps due to network load or topology, it may be appropriate to adjust these thresholds, which is covered in the <span class="emphasis"><em>Changing thresholds for ping RTT and packet loss</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Working with Checks and States">Chapter 3</a>, <span class="emphasis"><em>Working with Checks and States</em></span>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec156"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span>, <span class="emphasis"><em>Creating a new service</em></span>, and <span class="emphasis"><em>Creating a new hostgroup</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using an alternative check command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Changing thresholds for ping RTT and packet loss</em></span> recipe in <a class="link" href="ch03.html" title="Chapter 3. Working with Checks and States">Chapter 3</a>, <span class="emphasis"><em>Working with Checks and States</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring SSH for any host"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Monitoring SSH for any host</h1></div></div></div><p>In this recipe, we'll learn how to check that the SSH daemon on a remote host responds to requests, using the <code class="literal">check_ssh</code> plugin, and the <a id="id254" class="indexterm"/>command of the same name. This will allow us to be notified as soon as there are problems connecting to the SSH service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec157"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">troy.naginet</code>, a host <a id="id255" class="indexterm"/>defined in its own file. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>It may be a good idea to first verify that the host for which you want to add monitoring is presently running the SSH service that requires checking. This can be done by running the <code class="literal">ssh</code> client to make a connection to the host:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ssh troy.naginet</strong></span>
</pre></div><p>We should also check that the plugin itself will return the result required when run against the applicable host, as the <code class="literal">nagios</code> user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_ssh troy.naginet</strong></span>
</pre></div><p>If you're unable to get a positive response from the SSH service on the target machine, even if you're sure it's running, then this could perhaps be a symptom of unrelated connectivity or filtering problems. We may, for example, need to add the monitoring server on which Nagios Core is running to the whitelist for SSH (normally TCP destination port <code class="literal">22</code>) on any applicable firewalls or routers.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec158"/>How to do it...</h2></div></div></div><p>We can add a new SSH service check<a id="id256" class="indexterm"/>
<a id="id257" class="indexterm"/> to our existing host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing the definition for the host. <a id="id258" class="indexterm"/>The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  troy.naginet
    alias      troy
    address    10.128.0.25
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a <a id="id259" class="indexterm"/>service definition referring to <code class="literal">check_ssh</code>. It may help to use the <code class="literal">generic-service</code> template<a id="id260" class="indexterm"/> or another suitable template, as follows:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            troy.naginet
    service_description  SSH
    check_command        check_ssh
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service check will start taking place, with the appropriate contacts and contact groups notified when an attempt to connect to the <a id="id261" class="indexterm"/>SSH server fails. The service check will be visible in the web interface, on the <span class="strong"><strong>Services</strong></span> page.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec159"/>How it works...</h2></div></div></div><p>The preceding configuration defines a new service with a <code class="literal">service_description</code> of <code class="literal">SSH</code> for the existing <code class="literal">troy.naginet</code> host, using the values in the <code class="literal">generic-service</code> template and additionally defining a <code class="literal">check_command</code> directive<a id="id262" class="indexterm"/> of <code class="literal">check_ssh</code>.</p><p>This means that in addition to checking whether the host itself is up with <code class="literal">check-host-alive</code>, as done previously, Nagios Core will also check that the SSH service running on the host is working by attempting to make a connection with it. It will also notify the applicable contacts if there are any problems found with the service after the appropriate number of tests.</p><p>For example, if the plugin finds that the host is accessible but not responding to client tests, then it might notify with the following text:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Subject: ** PROBLEM Service Alert: troy.naginet/SSH is CRITICAL **</strong></span>

<span class="strong"><strong>***** Nagios *****</strong></span>

<span class="strong"><strong>Notification Type: PROBLEM</strong></span>

<span class="strong"><strong>Service: SSH</strong></span>
<span class="strong"><strong>Host: troy.naginet</strong></span>
<span class="strong"><strong>Address: troy.naginet</strong></span>
<span class="strong"><strong>State: CRITICAL</strong></span>

<span class="strong"><strong>Date/Time: Wed May 23 13:35:21 NZST 2012</strong></span>

<span class="strong"><strong>Additional Info:</strong></span>

<span class="strong"><strong>CRITICAL - Socket timeout after 10 seconds</strong></span>
</pre></div><p>Note that we don't need to actually supply credentials for the SSH check; the plugin simply ensures that the service is running and responding to connection attempts.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec160"/>There's more...</h2></div></div></div><p>The definition for the <code class="literal">check_ssh</code> command<a id="id263" class="indexterm"/> warrants some inspection if we're curious as to how the plugin is actually applied as a command, as defined in the QuickStart configuration in <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code>:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_ssh
    command_line  $USER1$/check_ssh $ARG1$ $HOSTADDRESS$
}</pre></div><p>This shows that the <a id="id264" class="indexterm"/>
<code class="literal">check_ssh</code> command is configured to run the <code class="literal">check_ssh</code> binary file in <code class="literal">$USER1$</code>, a macro that normally expands to <code class="literal">/usr/local/nagios/libexec</code>, against the host address of the applicable server. It adds in any other arguments beforehand. We haven't used any arguments in this recipe, since we simply want to make a <a id="id265" class="indexterm"/>normal check of the SSH service on its default port.</p><p>This check should work with most SSH2 compliant servers, most notably including the popular <span class="strong"><strong>OpenSSH</strong></span> server.</p><p>Checking SSH accessibility is a common enough thing for servers that you may wish to set up an SSH service check to apply to a hostgroup, rather than merely to an individual host. For example, if you had a group called <code class="literal">ssh-servers</code> containing several servers that should be checked with a <code class="literal">check_ssh</code> call, then you could configure them all to be checked with one service definition using the <code class="literal">hostgroup_name</code> directive<a id="id266" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    hostgroup_name       ssh-servers
    service_description  SSH
    check_command        check_ssh
}</pre></div><p>This would apply the same service check to each host in the group, which makes the definition easier to update if the check needs to be changed or removed in future.</p><p>Note that the <code class="literal">check_ssh</code> plugin<a id="id267" class="indexterm"/> is different from the <code class="literal">check_by_ssh</code> plugin, which is used to run checks on remote machines, much like NRPE.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec161"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Checking an alternative SSH port</em></span> recipe in this chapter </li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span>, <span class="emphasis"><em>Creating a new service</em></span>, and <span class="emphasis"><em>Creating a new hostgroup</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using check_by_ssh with key authentication instead of NRPE</em></span> and <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipes in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li></ul></div></div></div>
<div class="section" title="Checking an alternative SSH port"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Checking an alternative SSH port</h1></div></div></div><p>In this recipe, we'll learn how to deal with the common situation of a machine running an SSH daemon that is listening on an alternative port. So, a service definition that uses <code class="literal">check_ssh</code>, as used in the <span class="emphasis"><em>Monitoring SSH for any host</em></span> recipe, fails because the plugin defaults to using the standard SSH TCP port number of 22.</p><p>This kind of setup is common in situations where an SSH server should not be open to the general public and is often employed as a "security by obscurity" method to reduce automated attacks against the server. The SSH <a id="id268" class="indexterm"/>daemon is therefore configured to listen on a different port, usually with a much higher number; administrators who need to use it are told what the port number is.</p><p>We'll deal with this situation and monitor the service in Nagios Core, even though it's running on a non-standard port. We'll do this by defining a new command that checks SSH on a specified port number, and creating a service definition that uses that command. The command will accept the port number to check as an argument.</p><p>The principles here should generalize well to any other situation where checking an alternative port is necessary, and the Nagios Core plugin being used to make the check supports doing so on an alternative port.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec162"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">troy.naginet</code>, a host defined in its own file, and listening on the non-standard SSH port of <code class="literal">5022</code>. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>A good first step may be to verify that we're able to access the SSH daemon from the monitoring server on the specified port. We can do this from the command line using the <code class="literal">ssh</code> client, specifying the port number with the <code class="literal">-p</code> option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ssh troy.naginet -p 5022</strong></span>
</pre></div><p>Alternatively, you can run the <code class="literal">check_ssh</code> plugin directly from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_ssh -p 5022 troy.naginet</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec163"/>How to do it...</h2></div></div></div><p>We can set up a service check for SSH on a <a id="id269" class="indexterm"/>non-standard port as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit a suitable file containing command definitions, and find the definition for the <code class="literal">check_ssh</code> command<a id="id270" class="indexterm"/>. In the default installation, this file is <code class="literal">commands.cfg</code>. The <code class="literal">check_ssh</code> definition looks similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_ssh
    command_line  $USER1$/check_ssh $ARG1$ $HOSTADDRESS$
}</pre></div></li><li class="listitem">Beneath the <code class="literal">check_ssh</code> definition, add a new command definition as follows:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_ssh_altport
<span class="strong"><strong>    command_line  $USER1$/check_ssh -p $ARG1$ $HOSTADDRESS$</strong></span>
}</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  troy.naginet
    alias      troy
    address    10.128.0.25
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a new service definition using our new command:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            troy.naginet
    service_description  SSH_5022
    check_command        check_ssh_altport!5022
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, Nagios Core will begin running service checks using the <code class="literal">check_ssh</code> plugin, but will use the alternative destination port <code class="literal">5022</code> for its connection attempts for the service, which has a <code class="literal">service_description</code> of <code class="literal">SSH_5022</code>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec164"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section has <a id="id271" class="indexterm"/>almost exactly the same end result as adding a default <code class="literal">check_ssh</code> service; the only difference is that a different port is checked in order to make the connection. We use the <code class="literal">check_ssh_altport</code> command<a id="id272" class="indexterm"/> to do this, which we also defined ourselves in a syntax very similar to the <code class="literal">check_ssh</code> definition.</p><p>The difference is that the command accepts an argument which is used as a value for the <code class="literal">-p</code> option to the <code class="literal">check_ssh</code> plugin, to check the specified port number; in this case, TCP port <code class="literal">5022</code>, rather than the default of port <code class="literal">22</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec165"/>There's more...</h2></div></div></div><p>Since arguments in Nagios Core can include spaces, we could also have defined the service check as follows, without having to define an extra command:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            troy.naginet
    service_description  SSH_5022
    check_command        check_ssh!-p 5022
}</pre></div><p>This is because the <code class="literal">$ARG1$</code> macro representing the argument is still used in the original <code class="literal">check_ssh</code> command, but it needs to have the option included as well as its value. The difference is mainly one of preference, depending on which we feel is clearer and more maintainable. It may help to consider whether a well-named <a id="id273" class="indexterm"/>command could assist someone else reading our configuration in understanding what is meant.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec166"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring SSH for any host</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring mail services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Monitoring mail services</h1></div></div></div><p>In this recipe, we'll learn how to monitor three common mail services for a nominated host: <span class="strong"><strong>SMTP</strong></span>, <span class="strong"><strong>POP</strong></span>, and <span class="strong"><strong>IMAP</strong></span>. We'll also see how to use the same structure to include additional checks for secure, encrypted versions of each of these services: <span class="strong"><strong>SMTPS</strong></span>, <span class="strong"><strong>POPS</strong></span>, and <span class="strong"><strong>IMAPS</strong></span>.</p><p>For simplicity, we'll assume in this recipe that all three of these services are running on the same host, but the procedure will generalize easily <a id="id274" class="indexterm"/>for the common case where there are designated servers for one or more of the preceding functions.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec167"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">troy.naginet</code>, a host defined in its own file. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>Checking the connectivity for the required services on the target server is also a good idea, to make sure that the automated connections the monitoring server will be making on the appropriate protocols and ports will actually work as expected. For the plain unencrypted mail services, this could be done via <span class="strong"><strong>Telnet</strong></span> to the appropriate ports. For SMTP:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ telnet marathon.naginet 25</strong></span>
<span class="strong"><strong>Trying 10.128.0.34...</strong></span>
<span class="strong"><strong>Connected to marathon.naginet.</strong></span>
<span class="strong"><strong>Escape character is '^]'.</strong></span>
<span class="strong"><strong>220 marathon.naginet ESMTP Postfix</strong></span>
</pre></div><p>For POP:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ telnet marathon.naginet 110</strong></span>
<span class="strong"><strong>Trying 10.128.0.34...</strong></span>
<span class="strong"><strong>Connected to marathon.naginet.</strong></span>
<span class="strong"><strong>Escape character is '^]'.</strong></span>
<span class="strong"><strong>+OK Hello there.</strong></span>
</pre></div><p>And for IMAP:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ telnet marathon.naginet 143</strong></span>
<span class="strong"><strong>Trying 10.128.0.34...</strong></span>
<span class="strong"><strong>Connected to marathon.naginet.</strong></span>
<span class="strong"><strong>Escape character is '^]'.</strong></span>
<span class="strong"><strong>* OK [CAPABILITY IMAP4rev1 UIDPLUS CHILDREN NAMESPACE...</strong></span>
</pre></div><p>For secure services, one possibility for checking is using the <code class="literal">openssl</code> client. For SMTPS on its "classic" port number of 465:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl s_client -host marathon.naginet -port 465</strong></span>
<span class="strong"><strong>CONNECTED(00000003)</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>220 marathon.naginet ESMTP Postfix</strong></span>
</pre></div><p>For POPS:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl s_client -host marathon.naginet -port 995</strong></span>
<span class="strong"><strong>CONNECTED(00000003)</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>+OK Hello there.</strong></span>
</pre></div><p>And for IMAPS:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ openssl s_client -host marathon.naginet -port 993</strong></span>
<span class="strong"><strong>CONNECTED(00000003)</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>* OK [CAPABILITY IMAP4rev1 UIDPLUS CHILDREN NAMESPACE...</strong></span>
</pre></div><p>If you prefer, you could instead use a network scanner such as <code class="literal">nmap</code> to test whether the ports are open and responsive.</p><p>Once we've verified the connectivity for the mail services that we need, and also verified whether the host itself is being configured and checked in Nagios Core, we can add the appropriate service checks.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec168"/>How to do it...</h2></div></div></div><p>We can add unencrypted mail service checks for SMTP, POP, and <a id="id275" class="indexterm"/>IMAP services on our host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  marathon.naginet
    alias      marathon
    address    10.128.0.34
}</pre></div></li><li class="listitem">Beneath the definition for the host, place three new service definitions, one for each of the appropriate mail services:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  SMTP
    check_command        check_smtp
}
define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  POP
    check_command        check_pop
}
define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  IMAP
    check_command        check_imap
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting"># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg
# /etc/init.d/nagios restart</pre></div></li></ol></div><p>With this done, three new service checks will start taking place, with the appropriate contacts and contact groups notified when an attempt to connect to any of the services fails. Details for these services will also become available in the <span class="strong"><strong>Services</strong></span> section of the web interface.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec169"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section adds three new service checks to the existing <code class="literal">marathon.naginet</code> host:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SMTP</code>, which uses the <code class="literal">check_smtp</code> command<a id="id276" class="indexterm"/> to open an SMTP session</li><li class="listitem" style="list-style-type: disc"><code class="literal">POP</code>, which uses the <code class="literal">check_pop</code> command<a id="id277" class="indexterm"/> to open a POP session</li><li class="listitem" style="list-style-type: disc"><code class="literal">IMAP</code>, which uses the <code class="literal">check_imap</code> command<a id="id278" class="indexterm"/> to open an IMAP session</li></ul></div><p>In all three cases, the connectivity and responsiveness of the service is checked, and determined to be <code class="literal">OK</code> if it returns appropriate values within an acceptable time frame.</p><p>It's important to note that the configuration defined here doesn't actually send or receive any e-mail messages; it merely checks the basic connectivity of the service, and whether it answers simple requests. Therefore, just because the status is <code class="literal">OK</code> does not necessarily mean that e-mail messages are being correctly delivered; <a id="id279" class="indexterm"/>it could just mean that the services are responding.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec170"/>There's more...</h2></div></div></div><p>If it's necessary to check the secure SSL/TLS versions of each of these services, then the configuration is very similar but requires a little extra setup beforehand. This is because although plugins to check them are included in the Nagios Plugins setup, they are not configured to be used as commands. Note that this may well change in future versions of Nagios Core.</p><p>To add the appropriate commands, the following stanzas could be added to the commands configuration file, normally <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code>:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_ssmtp
    command_line  $USER1$/check_ssmtp $ARG1$ -H $HOSTADDRESS$
}
define command {
    command_name  check_spop
    command_line  $USER1$/check_spop $ARG1$ -H $HOSTADDRESS$
}
define command {
    command_name  check_simap
    command_line  $USER1$/check_simap $ARG1$ -H $HOSTADDRESS$
}</pre></div><p>With this done, the following service definitions can be added to the appropriate host, either replacing or supplementing the checks for the <a id="id280" class="indexterm"/>unsecured services. They are just the same as the unsecured versions, except that an <code class="literal">s</code> is added to the <code class="literal">service_description</code> and to <code class="literal">check_command</code>:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  SSMTP
<span class="strong"><strong>    check_command        check_ssmtp</strong></span>
}
define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  SPOP
<span class="strong"><strong>    check_command        check_spop</strong></span>
}
define service {
    use                  generic-service
    host_name            marathon.naginet
    service_description  SIMAP
<span class="strong"><strong>    check_command        check_simap</strong></span>
}</pre></div><p>Finally, note that if you are managing more than one mail server running one or more of the preceding services, then it's a good practice to apply the service to a hostgroup containing all the applicable hosts, rather than creating new service definitions for each one. See the <span class="emphasis"><em>Running a service on all hosts in a group</em></span> recipe in <a id="id281" class="indexterm"/>
<a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span> to learn how to do this.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec171"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span>, <span class="emphasis"><em>Creating a new service</em></span>, <span class="emphasis"><em>Running a service on all hosts in a group</em></span>, and <span class="emphasis"><em>Creating a new hostgroup</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring web services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Monitoring web services</h1></div></div></div><p>In this recipe, we'll set up a service check to monitor the responsiveness of an HTTP and HTTPS server. We'll use the <code class="literal">check_http</code> command and the plugin of the same name provided in the Nagios Plugins set to make HTTP and HTTPS requests of a web server, to ensure that it returns an appropriate and timely response. <a id="id282" class="indexterm"/>This is useful in situations where it's required to check whether a website is still functioning, particularly if there are times when it comes under heavy load or suffers denial of service attacks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec172"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">sparta.naginet</code>, a host defined in its own file. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>An appropriate first step is making sure that the services we intend to check are accessible from the monitoring server running Nagios Core. This can be done from the command line, using an HTTP client such as <code class="literal">curl</code> or <code class="literal">wget</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget http://sparta.naginet/</strong></span>
<span class="strong"><strong>$ curl http://sparta.naginet/</strong></span>
</pre></div><p>The <code class="literal">check_http</code> plugin<a id="id283" class="indexterm"/> binary could also be called directly to test this connectivity; we'd be hoping for an <code class="literal">HTTP</code> <code class="literal">OK</code> response, with a code of <code class="literal">200</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_http -I sparta.naginet</strong></span>
<span class="strong"><strong>HTTP OK: HTTP/1.1 200 OK - 453 bytes in 0.004 second response time |time=0.004264s;;;0.000000 size=453B;;;0</strong></span>
</pre></div><p>Optionally, we can check HTTPS the same way, adding the <code class="literal">-S</code> option for the plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_http -S -I sparta.naginet</strong></span>
<span class="strong"><strong>HTTP OK: HTTP/1.1 200 OK - 453 bytes in 0.058 second response time |time=0.057836s;;;0.000000 size=453B;;;0</strong></span>
</pre></div><p>Both may require the installation of a default page to be served by the host, probably something such as <code class="literal">index.html</code> or <code class="literal">default.asp</code>, depending on the web server software.</p><p>Once the HTTP connectivity to the host from the monitoring server is verified as working with appropriate responses, we can proceed to add our service check.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec173"/>How to do it...</h2></div></div></div><p>We can add web service checks for our <a id="id284" class="indexterm"/>
<a id="id285" class="indexterm"/>host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  sparta.naginet
    alias      sparta
    address    10.128.0.21
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a new service definition for the HTTP check:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP
    check_command        check_http
}</pre></div></li><li class="listitem">If an HTTPS check is also needed, add an optional second service definition:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTPS
    check_command        check_http!-S
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service called HTTP and optionally one called HTTPS will be added to the <code class="literal">sparta.naginet</code> host, and HTTP requests will be made from the server regularly, reporting if connectivity fails or a response comes back with an unexpected status. These services will both be visible in the <span class="strong"><strong>Services</strong></span> <a id="id286" class="indexterm"/>
<a id="id287" class="indexterm"/>section of the web interface.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec174"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section uses <code class="literal">check_http</code> as a plugin to make scheduled requests of the <code class="literal">sparta.naginet</code> server<a id="id288" class="indexterm"/>. By default, the index page is requested, so the request takes the following form:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GET / HTTP/1.0</strong></span>
<span class="strong"><strong>User-Agent: check_http/v1.4.15 (nagios-plugins 1.4.15)</strong></span>
<span class="strong"><strong>Connection: close</strong></span>
</pre></div><p>The plugin awaits a response, and then returns a status based on the following criteria:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whether a well-formed HTTP response was received at all, within acceptable time bounds. If the response was too slow, it might raise a <code class="literal">CRITICAL</code> state when the plugin times out.</li><li class="listitem" style="list-style-type: disc">Whether the response code for the HTTP response was <code class="literal">200</code> <code class="literal">Found</code>, indicating that a document was identified and returned. A response code of <code class="literal">404</code> <code class="literal">Not</code> <code class="literal">Found</code> would prompt a <code class="literal">CRITICAL</code> state by default.</li></ul></div><p>Inspecting the command definition for the default <code class="literal">check_http</code> command in <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code> gives some insight into how it uses the plugin of the same name:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http
    command_line  $USER1$/check_http -I $HOSTADDRESS$ $ARG1$
}</pre></div><p>This uses three Nagios Core<a id="id289" class="indexterm"/> macros:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$USER1$</code>: This expands to the directory in which the plugin scripts and binaries are kept; usually <code class="literal">/usr/local/nagios/libexec</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTADDRESS$</code>: This is the value for the <code class="literal">address</code> directive defined in the service's associated host; in this case <code class="literal">10.0.128.21</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG1$</code>: This is one extra argument, if defined by the command; it allows us to add the <code class="literal">-S</code> option to the <code class="literal">check_http</code> call in order to run an HTTPS check.</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec175"/>There's more...</h2></div></div></div><p>There are a many other great switches available for the <code class="literal">check_http</code> plugin<a id="id290" class="indexterm"/>; a list of them is available by entering the command with no arguments:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ./check_http</strong></span>
<span class="strong"><strong>check_http: Could not parse arguments</strong></span>
<span class="strong"><strong>Usage:</strong></span>
<span class="strong"><strong> check_http -H &lt;vhost&gt; | -I &lt;IP-address&gt; [-u &lt;uri&gt;] [-p &lt;port&gt;]</strong></span>
<span class="strong"><strong>       [-w &lt;warn time&gt;] [-c &lt;critical time&gt;] [-t &lt;timeout&gt;] [-L] [-a auth]</strong></span>
<span class="strong"><strong>       [-b proxy_auth] [-f &lt;ok|warning|critcal|follow|sticky|stickyport&gt;]</strong></span>
<span class="strong"><strong>       [-e &lt;expect&gt;] [-s string] [-l] [-r &lt;regex&gt; | -R &lt;case-insensitive regex&gt;]</strong></span>
<span class="strong"><strong>       [-P string] [-m &lt;min_pg_size&gt;:&lt;max_pg_size&gt;] [-4|-6] [-N] [-M &lt;age&gt;]</strong></span>
<span class="strong"><strong>       [-A string] [-k string] [-S] [--sni] [-C &lt;age&gt;] [-T &lt;content-type&gt;]</strong></span>
<span class="strong"><strong>       [-j method]</strong></span>
</pre></div><p>One particularly useful option here is the <code class="literal">-u</code> option, which allows us to request specific URLs other than the default index document from the server. This can be useful if we're in a situation that requires setting up checks for more than one page on a site, which can be a nice supplement to code unit testing when a site is deployed or updated.</p><p>For example, if we wanted to check that three pages were returning <code class="literal">200</code> <code class="literal">Found</code> responses: <code class="literal">about.php</code>, <code class="literal">products.php</code>, and <code class="literal">contact.php</code>, then we could set up a new command similar to the following to check a specific page:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http_page
    command_line  $USER1$/check_http -I $HOSTADDRESS$ -u $ARG1$
}</pre></div><p>This would allow us to make three service checks similar to the following, using the new command:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-about
<span class="strong"><strong>    check_command        check_http_page!/about.php</strong></span>
}
define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-products
<span class="strong"><strong>    check_command        check_http_page!/products.php</strong></span>
}
define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-contact
<span class="strong"><strong>    check_command        check_http_page!/contact.php</strong></span>
}</pre></div><p>These service checks would run the same way as the one demonstrated in the recipe, except they would each request a specific page. Note the leading slashes on the URLs are required.</p><p>Similarly, the <code class="literal">-H</code> option<a id="id291" class="indexterm"/> allows you to specify hostnames, <a id="id292" class="indexterm"/>which is helpful on servers hosting more than one site. This could be done by setting up a command as follows:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http_host
    command_line  $USER1$/check_http -I $HOSTADDRESS$ -H $ARG1$
}</pre></div><p>This would allow you to check two sites on the same host, <a class="ulink" href="http://www.naginet/">http://www.naginet/</a> and <a class="ulink" href="http://dev.naginet/">http://dev.naginet/</a>, in separate service checks:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-www
<span class="strong"><strong>    check_command        check_http_host!www.naginet</strong></span>
}
define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-dev
<span class="strong"><strong>    check_command        check_http_host!dev.naginet</strong></span>
}</pre></div><p>It's worth noting that the <code class="literal">check_http</code> request will show up in your server logs with its regular requests. If you're concerned about these distorted statistics or the appearance of unwanted values in reports, then it may be easiest to filter these out using its <code class="literal">User-Agent</code> header value, which includes the string <code class="literal">check_http</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec176"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Checking a website returns a given string</em></span> in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> and <span class="emphasis"><em>Customizing an existing plugin</em></span> recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Checking that a website returns a given string"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Checking that a website returns a given string</h1></div></div></div><p>In this recipe, we'll build on the basic web service monitoring established in the <span class="emphasis"><em>Monitoring web services</em></span> recipe in this chapter, and learn how to create a command that uses the <code class="literal">check_http</code> plugin to ensure that a particular string is included as part of an HTTP response.</p><p>By default, there's no Nagios Core command defined to use the plugin in this way, so the recipe will include defining a command before using it <a id="id293" class="indexterm"/>as part of a service check.</p><p>This may be necessary if we're monitoring a website on a server that may not necessarily return a <code class="literal">404</code> <code class="literal">Not</code> <code class="literal">Found</code> or similar error that will flag a <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> state in Nagios; rather than merely checking if a document was found, we can check if it matches a string, to see if it resembles the particular document we expected.</p><p>This kind of setup is a nice complement to a suite of code unit tests for a website or web application.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec177"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">sparta.naginet</code>, a host defined in its own file, and we'll check that it's returning the simple string, <code class="literal">naginet</code>, in its responses. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>You should set up basic HTTP monitoring for the host first, as established in the <span class="emphasis"><em>Checking web services</em></span> recipe in this chapter, to make sure that there is connectivity between the monitoring server and the host, and that requests and responses are both working correctly with appropriate error codes.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec178"/>How to do it...</h2></div></div></div><p>We can set up a service check that includes an <a id="id294" class="indexterm"/>HTTP response content check as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit a suitable file containing command definitions, and find the definition for the <code class="literal">check_http</code> command. In the QuickStart installation, this file is <code class="literal">commands.cfg</code>. The <code class="literal">check_http</code> definition looks similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http
    command_line  $USER1$/check_http -I $HOSTADDRESS$ $ARG1$
}</pre></div></li><li class="listitem">Beneath the <code class="literal">check_http</code> definition, add a new command definition as follows:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http_content
<span class="strong"><strong>    command_line  $USER1$/check_http -I $HOSTADDRESS$ -s $ARG1$</strong></span>
}</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  sparta.naginet
    alias      sparta
    address    10.128.0.21
}</pre></div></li><li class="listitem">Beneath the definition for the host and beneath any other checks that might use <code class="literal">check_http</code>, place a new service definition using our new command:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP-content
    check_command        check_http_content!naginet
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, Nagios Core should begin making HTTP requests to monitor the service as <code class="literal">check_http</code> normally does, except that it will only return an <code class="literal">OK</code> state if the content of the website includes the string <code class="literal">naginet</code>. Otherwise, it will generate an alert and flag the service as <code class="literal">CRITICAL</code>, with a message similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP CRITICAL: HTTP/1.1 200 OK - string 'naginet' not found on 'http://10.128.0.21:80/' - 453 bytes in 0.006 second response time</strong></span>
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec179"/>How it works...</h2></div></div></div><p>One of the many options for <code class="literal">check_http</code> is <code class="literal">-s</code>, short for <code class="literal">--string</code>
<a id="id295" class="indexterm"/>, which takes a single argument specifying a string that must occur in the content for the service check to return an <code class="literal">OK</code> state.</p><p>When the HTTP response is received, <code class="literal">check_http</code> examines the text in the response to see if it matches the string specified, on top of its usual behavior of flagging <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> states for connectivity or timeout problems.</p><p>Note that in order to make this work, it was necessary to define a new command that uses the first argument (in this case the string <code class="literal">naginet</code>) as the value for the <code class="literal">-s</code> option to <code class="literal">check_http</code>. The full command line executed would look similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_http -H sparta.naginet -s naginet</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec180"/>There's more...</h2></div></div></div><p>The <code class="literal">check_http</code> plugin<a id="id296" class="indexterm"/> allows considerably more than single string checks, if it's necessary to test for the presence of a regular expression in the content. This can be done using the <code class="literal">-r</code> or <code class="literal">--regex</code> options. We could define a command to check for regular expressions as follows:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http_regex
    command_line  $USER1$/check_http -I $HOSTADDRESS$ -r $ARG1$
}</pre></div><p>If it's necessary to check that a particular regular expression doesn't match the content, this is possible by adding the <code class="literal">--invert-regex</code> flag<a id="id297" class="indexterm"/>:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_http_noregex
    command_line  $USER1$/check_http -I $HOSTADDRESS$ -r $ARG1$ --invert-regex
}</pre></div><p>A service check using this command would return <code class="literal">CRITICAL</code> if the response was found to match the pattern provided as the first argument to a <code class="literal">check_command</code> directive<a id="id298" class="indexterm"/>.</p><p>Other similar options include <code class="literal">-e</code> or <code class="literal">--expect</code>
<a id="id299" class="indexterm"/>, which allows specifying a comma-separated set of strings, at least one of which must match the first line of the header for the check to pass.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec181"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring web services</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> and <span class="emphasis"><em>Customizing an existing plugin</em></span> recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring database services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Monitoring database services</h1></div></div></div><p>In this recipe, we'll learn how Nagios Core can be used to monitor the status of a database server. We'll demonstrate this with the popular MySQL as an example, using the <code class="literal">check_mysql</code> plugin, and we'll discuss running an <a id="id300" class="indexterm"/>actual test query and specifying a similar check for PostgreSQL in the <span class="emphasis"><em>There's more</em></span> section of this recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec182"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">delphi.naginet</code>, a host defined in its own file. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>For a check on a remote host to work from the monitoring server, the database server will need to be listening on an appropriate network interface. It's also necessary to make sure that an appropriate database user account exists with which the <code class="literal">check_mysql</code> plugin may authenticate. It's a good idea to make this into a dedicated user with no privileges on any database, because the credentials need to be stored in plain text, which could be a security risk if more sensitive credentials were used.</p><p>For MySQL, we could create a new user with no privileges with the following command, assuming that the monitoring server <code class="literal">olympus.naginet</code> has <code class="literal">10.128.0.11</code> as an IPv4 address. I've used a randomly generated password here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>mysql&gt; CREATE USER 'nagios'@'10.128.0.11' IDENTIFIED BY 'UVocjPHoH0';</strong></span>
</pre></div><p>We can then check the connectivity using the <code class="literal">mysql</code> client <a id="id301" class="indexterm"/>on the monitoring server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mysql --host=delphi.naginet --user=nagios --password=UVocjPHoH0</strong></span>
<span class="strong"><strong>mysql&gt;</strong></span>
</pre></div><p>Or alternatively, by running the plugin directly from the command line as the <code class="literal">nagios</code> user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_mysql -H delphi.naginet -u nagios -p UVocjPHoH0</strong></span>
<span class="strong"><strong>Uptime: 1631  Threads: 1  Questions: 102  Slow queries: 0  Opens: 99  </strong></span>
<span class="strong"><strong>Flush tables: 1  Open tables: 23  Queries per second avg: 0.62</strong></span>
</pre></div><p>If we did not have the MySQL libraries installed when we built the Nagios plugins, we may find that we do not have the <code class="literal">check_mysql</code> and <code class="literal">check_mysql_query</code> binaries in <code class="literal">/usr/local/nagios/libexec</code>. We can fix this by installing the MySQL shared libraries on the monitoring system, and rebuilding and reinstalling the Nagios Plugins package.</p><p>By default, it's also necessary to define new commands to actually use these plugins as well, which we'll do in this recipe.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec183"/>How to do it...</h2></div></div></div><p>We can set up some basic database monitoring for our MySQL server as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit a suitable file containing command definitions, perhaps <code class="literal">commands.cfg</code>, and add the following definition:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_mysql
<span class="strong"><strong>    command_line  $USER1$/check_mysql -H $HOSTADDRESS$ -u $ARG1$ -p $ARG2$</strong></span>
}</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  delphi.naginet
    alias      delphi
    address    10.128.0.51
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a new service definition for the MySQL check, including the username and <a id="id302" class="indexterm"/>password chosen earlier for arguments:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            delphi.naginet
    service_description  MYSQL
<span class="strong"><strong>    check_command        check_mysql!nagios!UVocjPHoH0</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service check with description <code class="literal">MYSQL</code> will be added for the <code class="literal">delphi.naginet</code> host, which will employ the <code class="literal">check_mysql</code> plugin to report the status of the MySQL server. The output will also include statistics about its uptime, open tables, and query averages, and like all service output will be visible in the web interface under <span class="strong"><strong>Services</strong></span>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec184"/>How it works...</h2></div></div></div><p>This configuration defines a new command named <code class="literal">check_mysql</code> to use the plugin of the same name, accepting two arguments; the first is the username of the test Nagios Core user, in this case <code class="literal">nagios</code>, and the second is the password for that user. The <code class="literal">check_mysql</code> plugin acts as a MySQL client using the credentials provided to it, and requests diagnostic information from the database, which it returns as part of its check.</p><p>If it has problems connecting to or using the MySQL server, it will flag a status of <code class="literal">CRITICAL</code>, and generate appropriate notifications.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec185"/>There's more...</h2></div></div></div><p>We can optionally check access to a specific database using the plugin by supplying a value to the <code class="literal">-d</code> parameter. This should be a database to which the <code class="literal">nagios</code> user has been given access, otherwise the check would fail.</p><p>If we want to check whether we can actually run a query after connecting, we could extend this even further to use the <code class="literal">check_mysql_query</code> plugin:<a id="id303" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_mysql_query
<span class="strong"><strong>    command_line  $USER1$/check_mysql_query -H $HOSTADDRESS$ -u $ARG1$ -p $ARG2$ -d $ARG3$ -q $ARG4$</strong></span>
}
define service {
    use                  generic-service
    host_name            delphi.naginet
    service_description  MYSQL_QUERY
<span class="strong"><strong>    check_command        check_mysql_query!nagios!UVocjPHoH0!exampledb!"SELECT COUNT(1) FROM exampletbl"</strong></span>
}</pre></div><p>The preceding code snippet would attempt to run the <code class="literal">SELECT</code> <code class="literal">COUNT(1)</code> <code class="literal">FROM</code> <code class="literal">exampletbl</code> query on the <code class="literal">exampledb</code> database. Note that it is important to wrap the query in quotes so that it gets processed as one argument, rather than several.</p><p>A similar service check to the one specified in this recipe could be configured for PostgreSQL database servers, using the <code class="literal">check_pgsql</code> plugin, also part of the standard Nagios Plugins set. The command and service check definitions might look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_pgsql
    command_line  $USER1$/check_pgsql -H $HOSTADDRESS$ -p $ARG1$
}
define service {
    use                  generic-service
    host_name            delphi.naginet
    service_description  PGSQL
    check_command        check_pgsql!N4Nw8o8X
}</pre></div><p>In the preceding example, an access would need to be granted on the PostgreSQL server for the monitoring server's IP address in <code class="literal">pg_hba.conf</code>, with access to the default standard <code class="literal">template1</code> database.</p><p>In production environments, it's often the case that for security or programming policy reasons, database servers are not actually configured to accept direct connections over network interfaces, even on secure interfaces. Packaged MySQL and PostgreSQL servers on many systems will in fact default to listening only on the <code class="literal">localhost</code> interface on <code class="literal">127.0.0.1</code>.</p><p>This can complicate the monitoring setup a little, but it can usually be addressed by installing a remote Nagios plugin execution agent on the database server, such as NRPE or NSclient++. NRPE usage is addressed in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span>, and uses a MySQL server configured in this way as its demonstration of the concept.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec186"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring the output of an SNMP query"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Monitoring the output of an SNMP query</h1></div></div></div><p>In this recipe, we'll learn how to use the <code class="literal">check_snmp</code> plugin to monitor the output given by <span class="strong"><strong>Simple Network Management Protocol</strong></span> (<span class="strong"><strong>SNMP</strong></span>) requests.</p><p>Despite its name, SNMP is not really a very simple protocol, but it's a very common method for accessing information on many kinds of networked devices, including monitoring boards, usage meters, and storage appliances, as well as workstations, servers, and routing equipment.</p><p>Because SNMP is so widely supported and typically able to produce such a large volume of information to trusted hosts, it's an excellent way to gather information from hosts that's not otherwise retrievable from network services. For example, while checking for a PING response from a large router is simple enough, there may not be an easy way to check properties, such as the state of each of its interfaces, or the presence of a certain route in its routing tables.</p><p>Using <code class="literal">check_snmp</code> in Nagios Core allows automated retrieval of this information from the devices, and generating alerts appropriately. While its setup is somewhat complex, it is worth learning how to use it, as it is among the most powerful plugins in Nagios Core for network administrators, and it is quite typical to see dozens of commands defined for its use in a typical configuration for a large network. It can often be used to complement or even replace remote plugin execution daemons such as NRPE or NSclient++.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec187"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. You should also understand the basics of how hosts and services relate, which is covered in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span>.</p><p>This recipe assumes a basic knowledge of SNMP, including its general intended purpose, the concept of an SNMP community, and what SNMP MIBs and OIDs are. In particular, if you're looking to monitor some property of a network device that's available to you via SNMP, you should know what the OID for that data is. This information is often available in the documentation for network devices, or can be deduced by running an appropriate <code class="literal">snmpwalk</code> command<a id="id304" class="indexterm"/> against the host to view the output for all its OIDs.</p><p>You should check that an SNMP daemon is running on the target host, and also that the <code class="literal">check_snmp</code> plugin is available on the monitoring host. It is included as part of the standard Nagios Plugins, so provided the Net-SNMP libraries were available on the system when these were compiled, the plugin should be available. If it is not, you may need to install the Net-SNMP libraries on your monitoring system and recompile the plugins.</p><p>We'll use the example of retrieving the total process count from a Linux server with hostname <code class="literal">ithaca.naginet</code>, and flagging <code class="literal">WARNING</code> and <code class="literal">CRITICAL</code> states at appropriate high ranges. We'll also discuss how to test for the presence or absence of strings, rather than numeric thresholds.</p><p>It's a good idea to test that the host will respond to SNMP queries in the expected form. We can test this with <code class="literal">snmpget</code>. Assuming a community name of <code class="literal">public</code>, we could write:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ snmpget -v1 -c public ithaca.naginet .1.3.6.1.2.1.25.1.6.0</strong></span>
<span class="strong"><strong>iso.3.6.1.2.1.25.1.6.0 = Gauge32: 81</strong></span>
</pre></div><p>We can also test the plugin by running it directly as the <code class="literal">nagios</code> user:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_snmp -H ithaca.naginet -C public -o .1.3.6.1.2.1.25.1.6.0</strong></span>
<span class="strong"><strong>SNMP OK - 81 | iso.3.6.1.2.1.25.1.6.0=81</strong></span>
</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec188"/>How to do it...</h2></div></div></div><p>We can define a command and service check for the Linux process count OID as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default path is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, then move to its directory instead.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit a suitable file containing command definitions, perhaps <code class="literal">commands.cfg</code>, and add the following definition to the end of the file.<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_snmp_linux_procs
<span class="strong"><strong>    command_line  $USER1$/check_snmp -H $HOSTADDRESS$ -C $ARG1$ -o .1.3.6.1.2.1.25.1.6.0 -w 100 -c 200</strong></span>
}</pre></div></li><li class="listitem">Edit the file containing the definition for the host. The host definition might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use        linux-server
    host_name  ithaca.naginet
    alias      ithaca
    address    10.128.0.61
}</pre></div></li><li class="listitem">Beneath the definition for the host, place a new service definition using our new command. Replace <code class="literal">public</code> with the name of your SNMP community if it differs:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            ithaca.naginet
    service_description  SNMP_PROCS
<span class="strong"><strong>    check_command        check_snmp_linux_procs!public</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service check with a description of <code class="literal">SNMP_PROCS</code> will be added to the <code class="literal">ithaca.naginet</code> host, and the <code class="literal">check_snmp</code> plugin will issue a request for the value of the specified OID as its regular check. It will flag a <code class="literal">WARNING</code> state if the count is greater than <code class="literal">100</code>, and a <code class="literal">CRITICAL</code> state if greater than <code class="literal">200</code>, notifying accordingly. All this appears in the web interface the same way as any other service, under the <span class="strong"><strong>Services</strong></span> menu item.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec189"/>How it works...</h2></div></div></div><p>The preceding configuration defines both a new command based around the <code class="literal">check_snmp</code> plugin, and in turn, a new service check using that command for the <code class="literal">ithaca.naginet</code> server. The community name for the SNMP request, <code class="literal">public</code>, is passed into the command as an argument; everything else, including the OID to be requested, is fixed into the <code class="literal">check_snmp_linux_procs</code> command<a id="id305" class="indexterm"/> definition.</p><p>A part of the command line defined includes the <code class="literal">-w</code> and <code class="literal">-c</code> options. For numeric outputs like ours, these are used to define the limits for the value beyond which a <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> state is raised, respectively. In this case, we define a <code class="literal">WARNING</code> threshold of <code class="literal">100</code> processes, and a <code class="literal">CRITICAL</code> threshold of <code class="literal">200</code> processes.</p><p>Similarly, if the SNMP check fails completely due to connectivity problems or syntax errors, an <code class="literal">UNKNOWN</code> state will be reported.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec190"/>There's more...</h2></div></div></div><p>It's also possible to test the output of SNMP checks to see if they match a particular string or pattern to determine whether the check succeeded. If we needed to check that the system's hostname was <code class="literal">ithaca.naginet</code>, for example (perhaps as a simple test SNMP query that should always succeed), then we might set up a command definition as follows:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_snmp_hostname
<span class="strong"><strong>    command_line  $USER1$/check_snmp -H $HOSTADDRESS$ -C $ARG1$ -o .1.3.6.1.2.1.1.5.0 -r $ARG2$</strong></span>
}</pre></div><p>With a corresponding service check as follows:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service    host_name            ithaca.naginet
    service_description  SNMP_HOSTNAME
<span class="strong"><strong>    check_command        check_snmp_hostname!public!ithaca</strong></span>
}</pre></div><p>This particular check would only succeed if the SNMP query succeeds and returns a string matching the string <code class="literal">ithaca</code>, as specified in the second argument.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec191"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating an SNMP OID to monitor</em></span> in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Monitoring a RAID or other hardware device"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Monitoring a RAID or other hardware device</h1></div></div></div><p>In this recipe, we'll learn a general strategy for monitoring the <a id="id306" class="indexterm"/>
<a id="id307" class="indexterm"/>properties of hardware devices. Because of the different ways that vendors implement their hardware, this tends to be less straightforward than monitoring standard network services.</p><p>There are at least four general approaches to this problem.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec192"/>Getting ready</h2></div></div></div><p>You will need to know some specifics about the hardware that you want to monitor, including the model number. You should preferably also have a Nagios Core 3.0 server that was compiled with Net-SNMP libraries available to build the <code class="literal">check_snmp</code> plugin, part of the Nagios Plugins set.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec193"/>How to do it...</h2></div></div></div><p>We can find a way to monitor an arbitrary hardware device on a <a id="id308" class="indexterm"/>
<a id="id309" class="indexterm"/>local or remote machine as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Check if official or unofficial Nagios Core plugins already exist for polling the particular device. The best place to start is with Nagios Exchange at <a class="ulink" href="http://exchange.nagios.org/"><span class="emphasis"><em>http://exchange.nagios.org/</em></span></a>; just search for the make of hardware, and see if a plugin already exists, per the <span class="emphasis"><em>Finding a plugin</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span>. You can then install it by following the <span class="emphasis"><em>Installing a plugin</em></span> recipe in the same chapter.</li><li class="listitem">Check if any of the values you need from the hardware are or can be exported as SNMP OIDs, to be checked with the <span class="emphasis"><em>Monitoring the output of an SNMP query</em></span> recipe in this chapter.</li><li class="listitem">If they aren't, but there's a command-line diagnostic tool with output, or a return value that can be used as the check, you could consider exporting it as a custom OID in an SNMP server, by using the <span class="emphasis"><em>Creating a new SNMP OID to monitor</em></span> recipe in this chapter.</li><li class="listitem">Finally, we may have to resort to writing our own plugin. This is not actually as difficult as it may seem; it is discussed in the <span class="emphasis"><em>Writing a new plugin from scratch</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span>. This may be the only option for custom or very uncommon hardware.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec194"/>How it works...</h2></div></div></div><p>If we find an appropriate plugin for the hardware online, the main snag here is that we will need to not only be sure that the plugin works, by testing it against the hardware in both an <code class="literal">OK</code> and a <code class="literal">CRITICAL</code> state (which might be hard to do), but we will also need to make sure that the plugin is safe to run. The plugins on Nagios Exchange are reviewed before they are added, but the code for plugins that you find on any other website might not be safe to run.</p><p>Using SNMP for these kinds of checks wherever possible has two advantages, in that the values can be checked using a standard Nagios plugin, <code class="literal">check_snmp</code>, and the values can also be read over the network, meaning that we may not need to rely on remote execution daemons such as NRPE or NSclient++ to get this information.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec195"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring the output of an SNMP query</em></span> and <span class="emphasis"><em>Creating a new SNMP OID to monitor</em></span> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Finding a plugin</em></span>, <span class="emphasis"><em>Installing a plugin</em></span>, and <span class="emphasis"><em>Writing a new plugin from scratch</em></span> recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li></ul></div></div></div>
<div class="section" title="Creating an SNMP OID to monitor"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Creating an SNMP OID to monitor</h1></div></div></div><p>In this recipe, we'll learn how to configure a Net-SNMP <code class="literal">snmpd</code> server on a Linux  server to return the output of a command in an SNMP OID. This can be useful as an alternative to NRPE monitoring for information that is not otherwise available in a checkable network service, so that Nagios Core can check it via its standard <code class="literal">check_snmp</code> method.</p><p>As an example, this can be a very good way of monitoring <a id="id310" class="indexterm"/>hardware devices, such as <span class="strong"><strong>RAID</strong></span> arrays on remote servers, where command-line diagnostic tools are available to report a status as a number or string, but they only work locally and don't otherwise include any information in an SNMP MIB tree.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec196"/>Getting ready</h2></div></div></div><p>The host we intend to check should be running a Net-SNMP <code class="literal">snmpd</code> server that allows full read access to the MIB tree for a specified community string, such as <code class="literal">public</code>. This SNMP server should be capable of using the <code class="literal">exec</code> directive in its configuration to return the output of a command as the value of an SNMP OID when requested by an SNMP client. As such, you will need to know the basics of SNMP.</p><p>You will also need a Nagios Core 3.0 or newer server with SNMP enabled in order to actually monitor the OID, which is explained in the <span class="emphasis"><em>Monitoring the output of an SNMP query</em></span> recipe.</p><p>In this example, we'll deal with a simple script running on a target host <code class="literal">ithaca.naginet</code> called <code class="literal">/usr/local/bin/raidstat</code> that returns an integer: zero for the RAID being in a good state, and non-zero to signal any problems. We'll assume this tool can be run as any user and does not require root privileges.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec197"/>How to do it...</h2></div></div></div><p>We can set up our custom SNMP OID as <a id="id311" class="indexterm"/>follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following line to the <code class="literal">snmpd.conf</code> file on the target host, substituting in the path of the command that generates the needed output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>exec raidstat /usr/local/bin/raidstat</strong></span>
</pre></div></li><li class="listitem">Restart the <code class="literal">snmpd</code> server on the target host, which might be done as follows, depending on the system:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /etc/init.d/snmpd restart</strong></span>
</pre></div></li><li class="listitem">Back on the monitoring server, we can walk the <code class="literal">.1.3.6.1.4.1.2021</code> OID, and find our <code class="literal">raidstat</code> OID and its value in the output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ snmpwalk -v1 -c public ithaca.naginet .1.3.6.1.4.1.2021 | less</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>iso.3.6.1.4.1.2021.8.1.2.1 = STRING: "raidstat"</strong></span>
<span class="strong"><strong>iso.3.6.1.4.1.2021.8.1.3.1 = STRING: "/usr/local/bin/raidstat"</strong></span>
<span class="strong"><strong>iso.3.6.1.4.1.2021.8.1.100.1 = INTEGER: 0</strong></span>
<span class="strong"><strong>iso.3.6.1.4.1.2021.8.1.101.1 = STRING: "GOOD"</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div></li><li class="listitem">We now know which OID we can query <a id="id312" class="indexterm"/>for a check using the <span class="emphasis"><em>Monitoring the output of an SNMP query</em></span> recipe in this chapter, and can test retrieving it directly with <code class="literal">snmpget</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ snmpget -v1 -c public ithaca.naginet .1.3.6.1.4.1.2021.8.1.100.1</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec198"/>How it works...</h2></div></div></div><p>The <code class="literal">exec</code> call in the <code class="literal">snmpd</code> configuration defines a program that should be run to return a new value in the OID tree. The four OIDs we found in the output are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">1.3.6.1.4.1.2021.8.1.2.1</code>: This is the name of the OID we've assigned, <code class="literal">raidstat</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">1.3.6.1.4.1.2021.8.1.3.1</code>: This is the full path to the script that was called, <code class="literal">/usr/local/bin/raidstat</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">1.3.6.1.4.1.2021.8.1.100.1</code>: This is the return value from the call, expressed as an integer</li><li class="listitem" style="list-style-type: disc"><code class="literal">1.3.6.1.4.1.2021.8.1.101.1</code>: This is any output from the call, expressed as a string</li></ul></div><p>This setup can therefore be used to check the return value and character output of any command that the <code class="literal">snmpd</code> user is able to execute, a good method for ad hoc monitoring for very specific cases like this.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec199"/>There's more...</h2></div></div></div><p>More than one <code class="literal">exec</code> command can be added to the server configuration if required. For example, if we needed to check the state of the CPU temperature with a command <code class="literal">tempstat</code>, then we might define:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>exec raidstat /usr/local/bin/raidstat</strong></span>
<span class="strong"><strong>exec tempstat /usr/local/bin/tempstat</strong></span>
</pre></div><p>The return values and output for both would then show up in the SNMP output, in separate OIDs.</p><p>If necessary, the command definitions can also be followed by arguments:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>exec tempstat /usr/local/bin/tempstat --cpu=0</strong></span>
</pre></div><p>A full discussion of how <code class="literal">exec</code> and the similar <code class="literal">pass</code> configuration for Net-SNMP works is outside the scope of this book, but is discussed extensively in its documentation available at the time of writing at <a class="ulink" href="http://www.net-snmp.org/docs/readmefiles.html">http://www.net-snmp.org/docs/readmefiles.html</a>.</p><p>Note that if exporting values via SNMP is unsuitable, an alternative for remote monitoring is to use <span class="strong"><strong>Nagios Remote Plugin Executor</strong></span> (<span class="strong"><strong>NRPE</strong></span>)<a id="id313" class="indexterm"/> to run a check on the target server and return the result to the monitoring server. This is discussed in the recipes of <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec200"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating an SNMP OID to monitor</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new host</em></span> and <span class="emphasis"><em>Creating a new service</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipes in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li></ul></div></div></div></body></html>