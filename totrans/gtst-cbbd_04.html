<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Manually Installing an Alternative Operating System</h1></div></div></div><p>Installing a <a id="id99" class="indexterm"/>full-blown desktop <strong>operating system</strong> (<strong>OS</strong>) onto an SD card via an image is certainly useful, but limitations arise quickly. What if an installation to an SSD is desired? Or what about having a very minimal installation for use as a server? Surely no heavy GUI is needed for this? All these questions will be covered in this chapter.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Partitioning and formatting a destination medium</li><li class="listitem" style="list-style-type: disc">Creating rootfs</li><li class="listitem" style="list-style-type: disc">Allowing booting of the destination medium</li><li class="listitem" style="list-style-type: disc">Updating the OS</li><li class="listitem" style="list-style-type: disc">Installing additional software</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Prerequisites for this chapter</h1></div></div></div><p>In this <a id="id100" class="indexterm"/>chapter, Debian (or even Ubuntu) will be installed to an alternative installation medium. A SATA SSD<a id="id101" class="indexterm"/> will be used, but a regular SATA disk can be equally used given that enough electrical power is available to power the drive; a power adapter with at least 2 amperes is required in such a case. Alternatively, a second microSD card can be used in a microSD-to-USB adapter.</p><p>When installing to a SATA drive, however, the Cubieboard still requires an SD card to boot, as the SoC cannot boot from a SATA drive directly. Technically, the onboard NAND flash or an onboard SPI flash could be used for this instead, but SPI flash-enabled Cubieboards are hard to find, and working with NAND requires a very old u-boot, which lacks a lot of new features. In this chapter, the microSD card created in the previous chapter will be repurposed and used to accomplish all these tasks.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>USB flash drives can, in theory, be used, but at the time of writing this book, the USB boot code has not landed in u-boot. At the moment, a USB flash drive can only be used after booting a kernel with USB support, which has been loaded from either a NAND or an SD card.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Preparing the destination medium</h1></div></div></div><p>To <a id="id102" class="indexterm"/>install Debian to a SATA drive, the destination drive will need some preparation. It needs to be partitioned and formatted.</p><p>Assuming<a id="id103" class="indexterm"/> the Cubieboard is booted up using the Fedora image created earlier and has either a SATA drive, USB flash drive, or a microSD card with a USB adapter connected, it is time to start <code class="literal">fdisk</code> on the destination medium, which is assumed to be <code class="literal">/dev/sda</code>. Please make sure that the correct device node is used; otherwise, the following actions will destroy anything present on the medium.</p><p>The most common tool of choice to partition a device is <a id="id104" class="indexterm"/>
<code class="literal">fdisk</code>. While <code class="literal">fdisk</code> has a few parameters, starting it with a device node will start <code class="literal">fdisk</code> in an interactive mode where a disk can be prepared. Root access is required to use <code class="literal">fdisk</code> and thus may need to be prefixed with <code class="literal">sudo</code>, as shown in the following screenshot:</p><div><img src="img/1572OS_04_01.jpg" alt="Preparing the destination medium"/></div><p>There should not be any previous data present or at least be backed up, which will not be covered here. Pressing the <em>o</em> key should clear any previously created partitions, as shown here:</p><div><img src="img/1572OS_04_02.jpg" alt="Preparing the destination medium"/></div><p>Partitions are <a id="id105" class="indexterm"/>a useful thing, they allow a logical<a id="id106" class="indexterm"/> separation. There are many reasons and choices when dividing a disk, as but here, only the following four partitions are of interest:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Boot</strong>: This<a id="id107" class="indexterm"/> partition holds all the relevant boot files</li><li class="listitem" style="list-style-type: disc"><strong>Root</strong>: This <a id="id108" class="indexterm"/>partition holds all the relevant system files</li><li class="listitem" style="list-style-type: disc"><strong>Home</strong>: This<a id="id109" class="indexterm"/> partition holds all the user files</li><li class="listitem" style="list-style-type: disc"><strong>Swap</strong>: This <a id="id110" class="indexterm"/>partition expands the RAM memory</li></ul></div><p>In this example, only three primary partitions will be created as the boot partition will be on the SD card. For the root partition, 6 GB is used, and for a swap partition, 512 MB is used. The remainder is used for the home partition.</p><p>Ultimately, however, it is up to the reader to define what is useful to you as this can differ greatly. With the <code class="literal">n</code> command, a new partition can be created. In the following screenshot, the three partitions explained earlier are created:</p><div><img src="img/1572OS_04_03.jpg" alt="Preparing the destination medium"/></div><p>When not <a id="id111" class="indexterm"/>entering a value for the last sector, <code class="literal">fdisk</code> will use the last sector available as default, thus using the remainder of the medium.</p><p>Partitions <a id="id112" class="indexterm"/>should not only be created, but also need to be categorized. By default, <code class="literal">fdisk</code> will turn all newly created partitions into regular Linux filesystem partitions, which is fine except for the swap partition. This partition needs a different type applied to it. The <code class="literal">t</code> command is used to categorize a partition, which in turn wants to know the exact type to use. For swap, this is type 82. The <code class="literal">l</code> command can be used at any time to get an overview of the available types. The following screenshot shows how to turn partition <code class="literal">2</code> into a swap partition:</p><div><img src="img/1572OS_04_04.jpg" alt="Preparing the destination medium"/></div><p>Using<a id="id113" class="indexterm"/> the<a id="id114" class="indexterm"/> commands <code class="literal">w</code> to write and <code class="literal">q</code> to quit, the newly created partition table is saved to the disk and <code class="literal">fdisk</code> quits, as shown here:</p><div><img src="img/1572OS_04_05.jpg" alt="Preparing the destination medium"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Formatting the newly created partitions</h1></div></div></div><p>With<a id="id115" class="indexterm"/> freshly created partitions available, they now need to be formatted. In this book, <code class="literal">ext4</code> will be used as the filesystem.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>While not yet supported by the 3.4.x kernel used in this book, <code class="literal">f2fs</code>
<a id="id116" class="indexterm"/> is very interesting as it is optimized for SSD, USB, or microSD flash usage. This is something that could be interesting in future.</p></div></div><p>The command to format a partition is <a id="id117" class="indexterm"/>
<code class="literal">mkfs.ext4</code>, and the parameters that are of interest are the device node being formatted and optionally <code class="literal">-L</code>, which is used to give the partition a name.</p><p>Formatting the root partition is shown here:</p><div><img src="img/1572OS_04_06.jpg" alt="Formatting the newly created partitions"/></div><p>Formatting<a id="id118" class="indexterm"/> the swap partition can be done using the command in the following screenshot:</p><div><img src="img/1572OS_04_07.jpg" alt="Formatting the newly created partitions"/></div><p>Formatting the remainder for the user files can be done as shown here:</p><div><img src="img/1572OS_04_08.jpg" alt="Formatting the newly created partitions"/></div><p>To ensure<a id="id119" class="indexterm"/> that all the data is written to the appropriate places, the partitions are mounted on the existing filesystem as follows:</p><div><pre class="programlisting">
<strong>[root@packt ~]# mount /dev/sda1 /mnt</strong>
<strong>[root@packt ~]# mkdir /mnt/home</strong>
<strong>[root@packt ~]# mount /dev/sda3 /mnt/home</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Creating a Debian or Ubuntu rootfs</h1></div></div></div><p>The first thing<a id="id120" class="indexterm"/> that should be mentioned here is that Ubuntu is a Debian derivative. To cut a long story short, it is basically Debian, and as a result, it does not hugely matter <a id="id121" class="indexterm"/>which distribution is used for installation, be it Debian or Ubuntu. So when talking about installing Ubuntu or Debian, the same thing is really being said. The tool used for installation here is called <a id="id122" class="indexterm"/>
<strong>debootstrap</strong> and is available in a lot of distributions.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Installing debootstrap</h2></div></div></div><p>Fedora<a id="id123" class="indexterm"/> has debootstrap available and can be installed <a id="id124" class="indexterm"/>via the Yum tool, as shown here:</p><div><img src="img/1572OS_04_09.jpg" alt="Installing debootstrap"/></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec13"/>Running debootstrap</h2></div></div></div><p>With<a id="id125" class="indexterm"/> debootstrap installed, it is almost time to get started. A few<a id="id126" class="indexterm"/> things need to be mentioned first; debootstrap, which stands for Debian bootstrap, can be used to install any Debian variant for any architecture for at least Debian and Ubuntu. It does require a mirror to be supplied to its list of arguments. The list of mirrors can be obtained for Debian at <a class="ulink" href="http://www.debian.org/mirror/list-full">http://www.debian.org/mirror/list-full</a>, but for Ubuntu, there is no official list of mirrors. However, using the country code in the URL can result in a mirror, for example, in the Netherlands, <a class="ulink" href="http://nl.ports.ubuntu.com">http://nl.ports.ubuntu.com</a> is a valid mirror. Using a mirror has the obvious advantage that the download will proceed much faster.</p><p>Since Allwinner SoCs are based on the ARMv7 architecture, for the architecture, <strong>armhf</strong> will<a id="id127" class="indexterm"/> be used for that.</p><p>The <strong>suite</strong>, as it <a id="id128" class="indexterm"/>is called, depends on what is desired. For Debian, there are the stable, testing, and unstable <a id="id129" class="indexterm"/>suites, where <strong>Wheezy</strong><a id="id130" class="indexterm"/> is the name of the stable branch, <strong>Jessie</strong><a id="id131" class="indexterm"/> is testing, and <strong>sid</strong><a id="id132" class="indexterm"/> is the unstable branch. It should be noted that in future, the names Wheezy and Jessie will change to new suite names, but sid will always remain the unstable development version.</p><p>Finally, debootstrap is prefixed with the <code class="literal">PATH</code> variable to ensure debootstrap uses the correct path. This is due to a bug currently in debootstrap in combination with the newer distributions.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>The <code class="literal">–foreign</code> parameter can be used to bootstrap any architecture, even on an x86-based system, as no code is executed. Bootstrapping will require some additional work using the <code class="literal">–second-stage</code> parameter. It is up to the reader to learn more about this when cross bootstrapping.</p></div></div><p>The following command will start the installation of Debian Wheezy for arm-hard-float into <code class="literal">/mnt</code> using the <a class="ulink" href="http://ftp.nl.debian.org/debian/">http://ftp.nl.debian.org/debian/</a> mirror, as shown here:</p><div><img src="img/1572OS_04_10.jpg" alt="Running debootstrap"/></div><p>As debootstrap is written in Perl. It may be possible that <strong>Perl</strong> is not currently installed on the system where debootstrap is being used. Installing Perl may follow a long list of packages that need to be downloaded and installed.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Similarly, debootstrap <code class="literal">–foreign --arch=armhf trusty /mnt http://nl.ports.ubuntu.com</code> can be used to install <strong>Ubuntu Trusty Tahr</strong> with a note that this will only be the base system. Also, debootstrap might not come with all the suites as expected. All Ubuntu suites are symlinks to the gutsy suite at <code class="literal">/usr/share/debootstrap/scripts</code> as long as it exists on <a class="ulink" href="http://ports.ubuntu.com/dists/">http://ports.ubuntu.com/dists/</a>. Use <code class="literal">ln -s gutsy utopic</code> in the scripts directory, for example, to add utopic as a valid suite.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec14"/>Configuring the base system</h2></div></div></div><p>The so-called <a id="id133" class="indexterm"/>
<code class="literal">fstab</code> file in Linux is responsible for mounting partitions in their designated positions. Using any editor, the following changes need to be added to the <code class="literal">fstab</code> file. While the UUID-based mount points can be used, only standard entries are used here. However, you are welcome and even encouraged to use the UUID-based mount points. A common editor that is relatively easy to use is <strong>nano</strong>. After modifying the file, exit nano with the <em>Ctrl</em> key in combination with the <em>x</em> key and answer the question to save the modified buffer with the <em>y</em> key. The filename should remain the same, thus answering with the <em>Enter</em> key. The <code class="literal">fstab</code> file in the editor is shown in the following screenshot:</p><div><img src="img/1572OS_04_11.jpg" alt="Configuring the base system"/></div><p>With <code class="literal">/boot</code> mounted read-only, it makes sure that not only no accidental writes happen, but also no intended writes occur. Also, as mentioned earlier in this chapter, the boot partition of the microSD card, which was created in the previous chapter, is reused here.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec15"/>Configuring the networking</h2></div></div></div><p>Debian and <a id="id134" class="indexterm"/>Ubuntu use the <code class="literal">interfaces</code> file at <code class="literal">/etc/network/interfaces</code> to configure networking. Note that this is a more permanent configuration used when not using the graphical utilities, such as network manager. If the final goal of this setup is a graphical desktop, it is probably wise to skip setting up the <code class="literal">interfaces</code> file.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Using the network interface <code class="literal">eth0</code> as the parameter for <code class="literal">dhclient</code> should result in a working network connection, as shown in the following command. However, this will be lost after a reboot.</p><div><pre class="programlisting">
<strong>dhclient eth0</strong>
</pre></div></div></div><p>Use nano to open the <code class="literal">interfaces</code> file at <code class="literal">/mnt/etc/network/interfaces</code> and make the following addition at the bottom:</p><div><pre class="programlisting">
<strong>auto eth0</strong>
<strong>iface eth0 inet dhcp</strong>
</pre></div><p>Generally, a similar section exists for the loopback device.</p><p>If a static IP configuration is required, the following can be used as an example (do replace the proper values with all numbers for the desired network).</p><div><pre class="programlisting">
<strong>auto eth0</strong>
<strong>iface eth0 inet static</strong>
<strong>     address 192.168.0.10</strong>
<strong>     network 192.168.0.0</strong>
<strong>     netmask 255.255.255.0</strong>
<strong>     broadcast 192.168.0.255</strong>
<strong>     gateway 192.168.0.1</strong>
</pre></div><p>When using a static IP address, the system also needs to be told how to resolve things; the <code class="literal">resolv.conf</code> file at <code class="literal">/etc/resolv.conf</code> is responsible for this. Note that this file will get overwritten if the network is configured either via <code class="literal">dhcp</code> or via a network manager. Using nano as an example editor, open the <code class="literal">resolv.conf</code> file at <code class="literal">/mnt/etc/resolv.conf</code> to add the following lines to it:</p><div><pre class="programlisting">
<strong>search homedomain.local</strong>
<strong>nameserver 192.168.0.1</strong>
</pre></div><p>Also here, we need to properly replace the values with whatever is appropriate for the network used. Remember to save the file using <em>Ctrl</em> + <em>x</em>.</p><p>If there is more than one nameserver on the local network, a new line prefixed with the word nameserver should be used for each additional nameserver.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>In the unlikely event that there is no nameserver available on the local network, Google's or OpenDNS's nameservers can be used. For Google, they are <code class="literal">8.8.8.8</code> and <code class="literal">8.8.4.4</code>, and for OpenDNS, they are <code class="literal">208.67.222.222</code> and <code class="literal">208.67.220.220</code>.</p></div></div><p>Finally, the system needs to be named on the network—the so-called <code class="literal">hostname</code>. Simply write a name that is unique on the network in the <code class="literal">hostname</code> file at <code class="literal">/mnt/etc/hostname</code>, as shown here:</p><div><pre class="programlisting">
<strong>[root@packt ~]# echo "PacktPublishing" &gt; /mnt/etc/hostname</strong>
</pre></div><p>Another<a id="id135" class="indexterm"/> thing that needs to be set up is the so-called hosts file. It serves as the most basic way to look up a hostname, for example, when there is no DNS server available. The hostname needs to be in here in addition to any other hostnames that are required to be available from the network; for example, there is a time server on the network from where all the computers get their current time. Every system queries this server via <code class="literal">time.example.com</code>. Even if there's no Internet connectivity and no DNS service available, to ensure the time server is always able to be looked up, an entry to the hosts file can be added. With <code class="literal">192.168.0.15</code> being the local time server, the following command can be used as an example for the hostname and a guide to add additional hosts. Note that quite often, there is little need to add additional hosts, as DNS is nearly always used for this purpose. Remember to save the file using <em>Ctrl</em> + <em>x</em>.</p><div><pre class="programlisting">
<strong>[root@packt ~]# nano /mnt/etc/hosts</strong>
<strong>127.0.0.1       localhost</strong>
<strong>127.0.0.1       PacktPublishing</strong>
<strong>192.168.0.15    time.example.com</strong>
<strong>::1             localhost ip6-localhost ip6-loopback</strong>
<strong>fe00::0         ip6-localnet</strong>
<strong>ff00::0         ip6-mcastprefix</strong>
<strong>ff02::1         ip6-allnodes</strong>
<strong>ff02::2         ip6-allrouters</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Making the destination medium bootable</h1></div></div></div><p>Unfortunately, as<a id="id136" class="indexterm"/> mentioned before, the SoC cannot boot from SATA drives or USB flash drives; it requires a helper component. In this book, a <a id="id137" class="indexterm"/>small microSD card is used for this purpose. As such, it will hold the bootloader, the kernel, and a little bit of configuration to glue it all together. In the previous chapter, the installation script used for the Fedora installation was done automatically. The kernel that will be installed onto the microSD card will, by default, continue loading the rootfs from the microSD card. This will obviously need to be adjusted so that the microSD card will boot the newly created medium. To do this, the boot partition needs to be mounted first, as shown in the following command:</p><div><pre class="programlisting">
<strong>[root@packt ~]# mount /dev/mmcblk0p1 /mnt/boot</strong>
</pre></div><p>Using nano, edit<a id="id138" class="indexterm"/> the <code class="literal">uEnv.txt</code> file and modify the <a id="id139" class="indexterm"/>line that starts with root <code class="literal">/dev/sda1</code>, as shown in the following screenshot. Remember to save the file using <em>Ctrl</em> + <em>x</em>.</p><div><img src="img/1572OS_04_12.jpg" alt="Making the destination medium bootable"/></div><p>With the microSD card set up to boot from the newly created medium, it is safe to unmount it again with the following command:</p><div><pre class="programlisting">
<strong>[root@packt ~]# umount /mnt/foo</strong>
</pre></div><p>If things go wrong and the Cubieboard refuses to boot, the microSD card can be used in a microSD-to-USB adapter and the <code class="literal">uEnv.txt</code> file can be opened with a locally installed text editor. The OS used to make this modification, however, will need to be able to read and write <code class="literal">ext4</code> or at least <code class="literal">ext2</code> filesystems.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>The root user</h1></div></div></div><p>While a <a id="id140" class="indexterm"/>root user <a id="id141" class="indexterm"/>exists with any default Debian or Ubuntu installation, the question arises as to how to log in as the root user. The following are the two options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Precreate a regular user that has administrative rights via <code class="literal">sudo</code> and don't allow the root user to log in</li><li class="listitem" style="list-style-type: disc">Or the easier way, set up a root password for the root user and use it</li></ul></div><p>Security-wise, the first option is safer. Both options will be briefly covered here. It is up to the reader to decide which option is better suited and how important the security aspect of it all is. This book is also not about properly securing a system. This is left to the reader as an exercise and is far beyond the scope of this book.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec16"/>Preparing the chroot command</h2></div></div></div><p>To set up<a id="id142" class="indexterm"/> a root password, a few steps are <a id="id143" class="indexterm"/>required, as this has to be done actually from within the system. The <code class="literal">chroot</code> command makes it possible to actually enter the system as if it was booted as such. But there is a prerequisite, that is, certain dynamic directories need to be populated, namely, <code class="literal">/dev</code> and <code class="literal">/proc</code>, as shown here:</p><div><pre class="programlisting">
<strong>[root@packt ~]# mount --rbind /dev /mnt/dev</strong>
<strong>[root@packt ~]# mount none -t proc /mnt/proc</strong>
</pre></div><p>Here, the existing <code class="literal">/dev</code> mount is reused whereas the <code class="literal">proc</code> filesystem is mounted normally. Now, it is possible to use <code class="literal">chroot</code> into the filesystem, as shown here:</p><div><pre class="programlisting">
<strong>[root@packt ~]# PATH=/bin:/sbin:/usr/bin:/usr/sbin chroot /mnt /bin/bash</strong>
<strong>root@packt:/#</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Changing the root password</h3></div></div></div><p>The<a id="id144" class="indexterm"/> <code class="literal">passwd</code> command <a id="id145" class="indexterm"/>will be used to start the password change for the root user, where a new password is entered twice. The system will not echo anything back to the user, as shown here:</p><div><pre class="programlisting">
<strong>root@packt:/# passwd</strong>
<strong>Enter new UNIX password:</strong>
<strong>Retype new UNIX password:</strong>
<strong>passwd: password updated successfully</strong>
<strong>root@packt:/#</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Creating a new super user</h3></div></div></div><p>To create a <a id="id146" class="indexterm"/>new user, the <code class="literal">useradd</code> command is used. There are a lot of options to this command and it is up to you to get familiarized with them. The options used in this example are, however, the ones generally used. Besides a new user, a new group matching the user's username will also be automatically created; the <code class="literal">-U</code> flag is responsible for that. Additionally, the <code class="literal">-s</code> flag is used to supply an alternative login shell. This is completely optional but recommended as Debian defaults to the default <code class="literal">sh</code> shell, which is rather limited. The <code class="literal">-m</code> flag creates a directory for the user and copies some basic files. In the following example, the username used will be <code class="literal">packt</code>:</p><div><pre class="programlisting">
<strong>root@packt:/# useradd -m -G sudo -s /bin/bash -U packt</strong>
<strong>root@packt:/#</strong>
</pre></div><p>To give the new user administrative powers, it will need rights to the <code class="literal">sudo</code> command. The user has already been made a part of the <code class="literal">sudo</code> user group via the <code class="literal">-G</code> parameter. But the command needs to be actually available to be usable. While the usage of <code class="literal">apt</code> will be discussed later in this chapter, use the following command to install <code class="literal">sudo</code>:</p><div><pre class="programlisting">
<strong>root@packt:/# apt-get install sudo</strong>
</pre></div><p>Finally, the user will also require a password to actually log in. The following <code class="literal">passwd</code> command can be used for this:</p><div><pre class="programlisting">
<strong>root@packt:/# passwd packt</strong>
<strong>Enter new UNIX password:</strong>
<strong>Retype new UNIX password:</strong>
<strong>passwd: password updated successfully</strong>
<strong>root@packt:/#</strong>
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec17"/>Exiting chroot</h2></div></div></div><p>The<a id="id147" class="indexterm"/> <code class="literal">chroot</code> environment can now be exited using the <code class="literal">exit</code> command, as follows:</p><div><pre class="programlisting">
<strong>root@packt:/# exit</strong>
<strong>exit</strong>
<strong>[root@packt ~]#</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Adding the serial console</h1></div></div></div><p>If the <a id="id148" class="indexterm"/>system were to be rebooted at this point, the login console would show up on <code class="literal">tty0</code>, which is the normal console when a monitor and keyboard are connected. There <a id="id149" class="indexterm"/>might, however, be a case where the connected monitor is not immediately compatible or where for some reason the USB keyboard or monitor cannot be used. The serial console has served us very well until now, and thus, in order to enable it on this, the Debian or Ubuntu installation is strongly recommended. Here, the first difference between Debian and Ubuntu, however, becomes apparent. Debian still uses the older <code class="literal">sysvinit</code>, whereas Ubuntu still uses <code class="literal">upstart</code>, and while both are slowly in the progress of migrating <a id="id150" class="indexterm"/>to <code class="literal">systemd</code>, this<a id="id151" class="indexterm"/> is not applicable at this moment. Ironically, with <code class="literal">systemd</code>, or at least with the one that is installed and currently running, the Fedora image has the serial console set up by default.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec18"/>Adding the serial console to Debian</h2></div></div></div><p>The file responsible for<a id="id152" class="indexterm"/> spawning the various <code class="literal">init</code> services is <code class="literal">inittab</code> at <code class="literal">/etc/inittab</code>, and uses nano; this can be edited to add the serial console. Find the following section, uncomment the line starting with <code class="literal">#T0</code>, and remove the hashtag. Also note that by default the baud speed is <code class="literal">9600</code>, and our entire setup assumes a baud speed of <code class="literal">115200</code>, so make sure that this change has been performed, as shown in the following example. Remember to save the file using <em>Ctrl</em> + <em>x</em>.</p><div><pre class="programlisting">
<strong>[root@packt ~]# nano /mnt/etc/inittab</strong>
<strong># Example how to put a getty on a serial line (for a terminal)</strong>
<strong>#</strong>
<strong>T0:23:respawn:/sbin/getty -L ttyS0 115200 vt100</strong>
<strong>#T1:23:respawn:/sbin/getty -L ttyS1 9600 vt100</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec19"/>Adding the serial console to Ubuntu</h2></div></div></div><p>For <code class="literal">upstart</code>, the <a id="id153" class="indexterm"/>situation is completely different. The files in the <code class="literal">/etc/init/</code> directory are parsed by <code class="literal">upstart</code>. First, copy the file <code class="literal">tty1.conf</code> to <code class="literal">ttyS0.conf</code> as this makes editing much easier; the files are similar after all, as shown here:</p><div><pre class="programlisting">
<strong>[root@packt ~]# cd /mnt/etc/init/</strong>
<strong>[root@packt init]# cp tty1.conf ttyS0.conf</strong>
</pre></div><p>However, a few changes need to be made to this file. First, replace all occurrences of <code class="literal">tty1</code> with <code class="literal">ttyS0</code>. Next, in addition to <code class="literal">2345</code>, add <code class="literal">1</code> to the number of run levels. Also, remove the <code class="literal">and</code> <code class="literal">(…)</code> section. Finally, the <code class="literal">getty</code> line needs to be adjusted to listen to a serial port at <code class="literal">115200</code> bps. The following command shows you how the file eventually should look like. Alternatively, a new file can be created with the following content. Remember to save the file using <em>Ctrl</em> + <em>x</em>.</p><div><pre class="programlisting">
<strong># ttyS0 - getty</strong>
<strong>#</strong>
<strong># This service maintains a getty on ttyS0 from the point the system </strong>
<strong># is started until it is shut down again.</strong>

<strong>start on stopped rc RUNLEVEL=[12345]</strong>
<strong>stop on runlevel [!12345]</strong>

<strong>respawn</strong>
<strong>exec /sbin/getty -L 115200 ttyS0 vt102</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Rebooting the new OS</h1></div></div></div><p>With all the <a id="id154" class="indexterm"/>required changes in place, it is time to reboot into the new operating system. First, unmount all partitions that have been mounted for this installation. Make sure that none of the mounted directories are in use. The <code class="literal">umount -l</code> command<a id="id155" class="indexterm"/> is used, where the <code class="literal">-l</code> parameter stands for lazy, which means that <code class="literal">umount</code> will try to unmount all subdirectories first and finish with unmounting the requested directory. In case of errors, manual unmounting is probably required. The <code class="literal">reboot</code> command will then reboot the system, as shown here:</p><div><pre class="programlisting">
<strong>[root@packt etc]# cd</strong>
<strong>[root@packt ~]# umount -l /mnt</strong>
<strong>[root@packt ~]# reboot</strong>
</pre></div><p>After the reboot, you will be greeted with a login prompt, as shown in the following screenshot. Obviously, this differs slightly between Debian and Ubuntu. After logging in with either the created user or the root, the installation part of this chapter is completed, congratulations!</p><div><img src="img/1572OS_04_13.jpg" alt="Rebooting the new OS"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Getting around the new OS via the command line</h1></div></div></div><p>If you are new to <a id="id156" class="indexterm"/>GNU/Linux in general, using the cheatsheet as shown in <a class="link" href="apb.html" title="Appendix B. Basic Linux Commands Cheatsheet">Appendix B</a>, <em>Basic Linux Commands Cheatsheet</em>, will be helpful, as a few common Linux commands can be explored, and it can be considered as a beginner's guide to GNU/Linux. This section will focus a little more on common tasks, keeping Debian or Ubuntu up to date and installing new software.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec20"/>Introducing apt</h2></div></div></div><p>Both<a id="id157" class="indexterm"/> Debian and Ubuntu rely heavily on apt for their software needs. Apt is a suite of commands that allows the installation of new software packages or keeping the existing ones up to date. Apt works closely together with dpkg although a regular user will probably never invoke dpkg directly. Apt is responsible for downloading a requested piece of software, checking what its dependencies are, and telling dpkg to install them. It is the Swiss army knife of package management under Debian and Ubuntu. It was the command-line AppStore before AppStores even existed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec21"/>Configuring apt</h2></div></div></div><p>Apt does<a id="id158" class="indexterm"/> not require a whole lot of configuring. What apt does need is a list of places where it can check and download software from. The Debian and Ubuntu defaults might not offer everything of interest. The file responsible for apt's configuration is <code class="literal">sources.list</code> at <code class="literal">/etc/apt/sources.list</code>, and if you are logged in as a regular user, it requires <code class="literal">sudo</code> to grant the user additional privileges to edit the file. In the following example, the non-free component and the security repository will be added to the main component. Note that the various sources in the <code class="literal">sources.list</code> file will vary between various suites or derivatives, such as Ubuntu.</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:/etc/apt$ sudo nano sources.list</strong>
<strong>[sudo] password for packt:</strong>
<strong>deb http://ftp.nl.debian.org/debian wheezy main non-free</strong>

<strong>deb http://security.debian.org/ wheezy/updates main non-free</strong>
<strong>deb-src http://security.debian.org/ wheezy/updates main non-free</strong>
</pre></div><p>With these changes in place, apt will need to be updated, but that is handled in the next subsection.</p><p>Debian has a good tutorial for <a id="id159" class="indexterm"/>more in-depth reading at <a class="ulink" href="https://wiki.debian.org/SourcesList">https://wiki.debian.org/SourcesList</a>, and an additional components and repositories are listed at <a class="ulink" href="https://wiki.debian.org/UnofficialRepositories">https://wiki.debian.org/UnofficialRepositories</a>. For Ubuntu, the <a id="id160" class="indexterm"/>source list can be found at <a class="ulink" href="https://help.ubuntu.com/community/SourcesList">https://help.ubuntu.com/community/SourcesList</a> and additional <a id="id161" class="indexterm"/>repositories at <a class="ulink" href="https://help.ubuntu.com/community/Repositories/Ubuntu">https://help.ubuntu.com/community/Repositories/Ubuntu</a>. Further configuration beyond what is listed in this subsection is left as an exercise to the reader. Note that while in <a id="id162" class="indexterm"/>theory Ubuntu and Debian repositories can be mixed, it is not recommended and will likely cause issues.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec22"/>Keeping the OS up to date</h2></div></div></div><p>Regularly checking and<a id="id163" class="indexterm"/> installing updates can be critical to security. Also, new versions of existing software packages potentially yielding new features or fixing bugs are also obtained in this way. The steps are identical for Ubuntu and Debian.</p><p>To download and update apt with a new list of the software, the first apt command <code class="literal">apt-get</code> is introduced. The <code class="literal">apt-get</code> command<a id="id164" class="indexterm"/> without parameters, however, will not do a lot more than print a help screen. As the intended action is to update the list of applications that will be the <code class="literal">update</code> parameter passed. Again, if run as a regular user, it should be prefixed with <code class="literal">sudo</code>. Also, if the network has not been configured yet and the intention is to let the graphical user interface configure the network, remember to run <code class="literal">dhclient eth0</code> to obtain a temporary network configuration. The following command in the screenshot runs an update of apt:</p><div><img src="img/1572OS_04_14.jpg" alt="Keeping the OS up to date"/></div><p>If sections and components were not added in the previous subsection, the list would obviously be shorter. At this point, the apt has an up-to-date list of the available software. To upgrade all installed packages, most importantly because of security updates, the <code class="literal">upgrade</code> parameter to <code class="literal">apt-get</code> is used, as shown in the following screenshot:</p><div><img src="img/1572OS_04_15.jpg" alt="Keeping the OS up to date"/></div><p>In the preceding<a id="id165" class="indexterm"/> example, there was only one update available, which was an update to <code class="literal">libgnutls</code>. This list can vary depending on the amount of updates, naturally.</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>The <code class="literal">apt</code> file at <code class="literal">/etc/cron.daily/apt</code> is responsible for the daily update of apt and installing security critical packages, thus running the <code class="literal">apt-get</code> update is not always required.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec23"/>Installing additional software</h2></div></div></div><p>The most <a id="id166" class="indexterm"/>exciting thing about any OS probably is the software. However, the default created Debian or Ubuntu installation lacks most of the software. It is, after all, just the bare minimum.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Finding packages</h3></div></div></div><p>While<a id="id167" class="indexterm"/> installing packages, a problem can occur when a name is roughly remembered but not to exactly. In that case, there is an apt tool called <a id="id168" class="indexterm"/>
<code class="literal">apt-cache</code>. Using the <a id="id169" class="indexterm"/>
<code class="literal">search</code> parameter, the internal cached apt database can be searched for available packages. Especially in combination with the <code class="literal">grep</code> command, these two can be helpful to find what is needed, as shown in the following screenshot. The <code class="literal">grep –</code> command<a id="id170" class="indexterm"/> is explained in <a class="link" href="apb.html" title="Appendix B. Basic Linux Commands Cheatsheet">Appendix B</a>, <em>Basic Linux Commands Cheatsheet</em>.</p><div><img src="img/1572OS_04_16.jpg" alt="Finding packages"/></div><p>Additionally, you might want to search for a filename of an application. There is an apt tool for that as well. The <code class="literal">apt-file</code> tool<a id="id171" class="indexterm"/> using the <code class="literal">search</code> parameter will allow you to search for files <a id="id172" class="indexterm"/>inside packages. Unfortunately, at the time of writing this book, the <code class="literal">apt-file</code> tool is not yet included in the current stable release of Debian or Ubuntu, but should be hopefully added soon.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Installing the software package using apt-get</h3></div></div></div><p>The most<a id="id173" class="indexterm"/> basic way to<a id="id174" class="indexterm"/> install a software package is also via <code class="literal">apt-get</code>, the parameter not surprisingly being install. Nano has been used often as an example editor. This is because it is very easy to use and nearly always preinstalled as it is so small. <strong>Vi</strong> <a id="id175" class="indexterm"/>is another small editor that is nearly always preinstalled but is far from easy to use. Vi has a bigger brother called Vi improved or vim. Let us install vim via <code class="literal">apt-get</code>, as follows:</p><div><img src="img/1572OS_04_17.jpg" alt="Installing the software package using apt-get"/></div><p>After downloading <a id="id176" class="indexterm"/>and <a id="id177" class="indexterm"/>installing a few packages, vim is now installed.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>Installing the software package using tasksel</h3></div></div></div><p>More than <a id="id178" class="indexterm"/>often, a collection <a id="id179" class="indexterm"/>of packages is required to have the system perform certain functions. The <code class="literal">tasksel</code> command can be used to install a collection of packages to perform a certain task. Running <code class="literal">tasksel</code> with elevated privileges yields the menu, as shown in the following screenshot. Ubuntu does not have <code class="literal">tasksel</code> preinstalled and requires it to be installed via <code class="literal">apt-get</code>, as shown in the previous example for vim.</p><div><img src="img/1572OS_04_18.jpg" alt="Installing the software package using tasksel"/></div><p>Installing the <a id="id180" class="indexterm"/>Debian desktop environment task will install a graphical desktop environment based on <strong>GNOME</strong><a id="id181" class="indexterm"/> and some <a id="id182" class="indexterm"/>additional packages marked as standard by Debian, such as LibreOffice.</p><p>The downloading and installation might take a while depending on the target medium and Internet connection speed. Installation on an SSD with a very fast Internet connection can take about thirty minutes.</p><p>Under Ubuntu, <code class="literal">tasksel</code> will look slightly different, but even here there is an Ubuntu desktop option, as shown in the following screenshot. This will take about the same time thirty minutes or more.</p><div><img src="img/1572OS_04_19.jpg" alt="Installing the software package using tasksel"/></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec14"/>Installing packages via metapackages</h3></div></div></div><p>The<a id="id183" class="indexterm"/> tasks available via <code class="literal">tasksel</code> appear to be rather limited. Instead, it is probably easier to use metapackages. Metapackages <a id="id184" class="indexterm"/>are, in effect, not that much different from tasks; in fact, they very well might be the same in the background. A metapackage is not really a package that installs anything, rather it is a list of packages or a collection of packages that get installed from it. For example, <code class="literal">xfce4</code>
<a id="id185" class="indexterm"/> is a metapackage for Debian, which will install all the packages required for the <code class="literal">xfce4</code> desktop environment and will also install software that the package maintainers thought would make sense to have for a full-fledged desktop environment, such as a file manager.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>For Ubuntu, this metapackage is just called xfce, though the xubuntu-desktop metapackage should be more interesting here.</p></div></div><p>Another interesting metapackage to match the <code class="literal">xfce4</code> metapackage is <code class="literal">xfce4-goodies</code>. In fact, the following command will show you how to install multiple packages in one go. Running the command will result in a huge list of packages to be installed, but will yield a usable <code class="literal">xfcef4</code> desktop, as if it were installed from a CD, for example. One could even argue that an installation CD would do just that, as shown here:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~$ sudo apt-get install xfce4 xfce4-goodies</strong>
</pre></div><p>After waiting about 30 minutes for the xfce4 desktop to get installed, xfce4 can be started using the <code class="literal">startx</code> command. At this point, however, the monitor and keyboard will have to be used. Xfce4 cannot be used or started over the serial console. This yields an almost usable desktop environment. Almost means here that certain things with permissions are missing. A user is not allowed to shut down the machine by default, for example.</p><p>There are <a id="id186" class="indexterm"/>several ways to allow these things to work properly, and one is the use of a login manager; xfce4, however, does<a id="id187" class="indexterm"/> not come with one, but that is okay. There are plenty of login managers to choose from. GNOME comes with <code class="literal">gdm</code>, but going with a lightweight login manager that matches Xfce4 as a lightweight desktop manager, LightDM should be a good candidate. Installing the <code class="literal">lightdm</code> package should require no extra instructions. Rebooting the Cubieboard now will yield an active login window, which upon login, wraps up this chapter.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>Having worked through this chapter, admittedly a big one, the result should technically be the same as the previous chapter; a working desktop environment based on either Debian or Ubuntu. The installation of additional software via the command line is now a breeze, and keeping the system up to date is not an issue at all.</p><p>The next chapter will take this installation and turn it into a server for various tasks, optionally retaining the desktop functionality.</p></div></body></html>