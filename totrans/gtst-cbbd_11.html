<html><head></head><body><div><div><div><div><h1 class="title"><a id="appC"/>Appendix C. The FEX Configuration File</h1></div></div></div><p>Many systems have a way <a id="id476" class="indexterm"/>of configuring themselves, be it software or, in this case, hardware. Allwinner-based hardware is no different; there are some bits and pieces that do require configuring, such as GPIO pins. A chip cannot configure itself; that is, it cannot parse a configuration file and configure itself. The actual configuration of the chip is done by the various drivers. The procedure is illustrated in the following sections.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec96"/>Initial boot up</h1></div></div></div><p>The chip <a id="id477" class="indexterm"/>starts in a hardwired way, where certain components are preprogrammed to be active on specific pins. Because of this, the chip can boot from various boot media, as mentioned in <a class="link" href="ch03.html" title="Chapter 3. Installing an Operating System">Chapter 3</a>, <em>Installing an Operating System</em>, and load the bootloader. The bootloader is also preconfigured to a certain hardware setup. Hence, as mentioned earlier, each board has its own bootloader.</p><p>Besides bringing up certain components, the bootloader has the following two important tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading the kernel into memory and later executing it</li><li class="listitem" style="list-style-type: disc">Loading a configuration file into the memory for the kernel to use</li></ul></div><p>However, the bootloader itself does not parse the configuration file.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>It has to be mentioned that when using a mainline kernel, the principle is the same: the bootloader still loads a configuration file named device tree binary, which the kernel uses for configuration.</p></div></div><p>The FEX configuration concept is interesting in itself, where one file is changed to configure an entire device. As mentioned earlier, the FEX file is loaded into the memory by the bootloader, and the bootloader only checks one specific location. While u-boot is more flexible and could be configured to allow reading the configuration file from any location or any <a id="id478" class="indexterm"/>filename, the bootloader that is preprogrammed into the onboard NAND flash storage will only check the first partition on the device, and that has to be FAT formatted. As such, this is a common convention that we will follow for the remainder of this chapter. Additionally, this file has to be called by a specific name, <code class="literal">script.bin</code>, and the duplicate backup by the name <code class="literal">script0.bin</code> file. When booting a kernel that supports the onboard <code class="literal">nand</code> flash, the device node where this file will be stored is <code class="literal">/dev/nanda</code>. Otherwise, normal device nodes will be used, most commonly the SD card at <code class="literal">/dev/mmcblk0p1</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Compiling and decompiling the FEX file</h1></div></div></div><p>The <code class="literal">script.bin</code> file is, as <a id="id479" class="indexterm"/>its file extension suggests, a binary file. However, it<a id="id480" class="indexterm"/> is not possible to directly modify this file. The linux-sunxi community has created a set of tools to convert this binary<a id="id481" class="indexterm"/> file into a text file and vice versa. They can be found in their GitHub repository at <a class="ulink" href="https://github.com/linux-sunxi/sunxi-tools">https://github.com/linux-sunxi/sunxi-tools</a>.</p><p>After cloning this repository, the <code class="literal">make fex2bin</code> command is run to build the <a id="id482" class="indexterm"/>
<strong>fexc</strong>, the fex decompiler. Compiling and running this tool is probably best on a system that has a comfortable text editor available.</p><p>Running fexc to decompile the binary file will look like this:</p><div><pre class="programlisting">
<strong>[packt@packt:~]$ fexc -I bin -O fex script.bin script.fex</strong>
</pre></div><p>There are two shorthands in the form of symlinks to fexc, namely <code class="literal">fex2bin</code> and <code class="literal">bin2fex</code>. Using these makes the <code class="literal">-I</code> and <code class="literal">-O</code> parameters unnecessary.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Understanding the FEX file format</h1></div></div></div><p>Using any <a id="id483" class="indexterm"/>text editor, a FEX file will show that it is divided in various sections, prepended by a header within brackets, <code class="literal">[]</code>. In the following example, the UART <code class="literal">0</code> component is explained:</p><div><pre class="programlisting">
<strong>[uart_para0]</strong>
<strong>uart_used = 1</strong>
<strong>uart_port = 0</strong>
<strong>uart_tx = port:PB22&lt;2&gt;&lt;1&gt;&lt;default&gt;&lt;default&gt;</strong>
<strong>uart_rx = port:PB23&lt;2&gt;&lt;1&gt;&lt;default&gt;&lt;default&gt;</strong>
</pre></div><p>Here, the component called <code class="literal">uart_para0</code>, the first serial port or UART, has four fields that a serial driver would read. Each field is set up as a key-value pair, where the key is on the left-hand side and the value is on the right-hand side of the equal sign. In this case, the key <code class="literal">uart_used</code> is set to the number <code class="literal">1</code> indicating that this definition should be parsed and activated.</p><p>Following that is <a id="id484" class="indexterm"/>the <code class="literal">uart_port</code> key, which is set to the number <code class="literal">0</code>, indicating that this configuration is about UART 0—the first UART port. Some of the settings are very straightforward key-value pairs, that is, a key on the left and a string or a number on the right. There is, however, a key-value pair that needs some special attention, and that is the pin configuration, where the value is a port definition. Every component might require certain pins to function.</p><p>A basic UART requires two pins: a transmit pin and a receive pin. The SoC can provide several UARTs on several pins. In the preceding example, two pins are defined, the transmit pin, <code class="literal">uart_tx</code>, and the receive pin, <code class="literal">uart_rx</code>. The pins on a SoC are very often grouped, usually by a related function.</p><p>In the case of the A10, it has nine groups called ports. Each port can consist of a varying amount of pins. Port B, for example, has 24 pins. The last two pins of the set are the UART transmit and UART receive pins. The numbering starts at 0, following from which, it should be no surprise that <code class="literal">PB22</code> and <code class="literal">PB23</code> in the preceding example are Port B: pin 22 and pin 23.</p><p>As mentioned before, each pin has multiple features, or as they say, many functions are multiplexed onto a pin. These multiplexes, or muxes, are enumerated, where MUX 0 always configures a pin as GPIO input, and MUX 1 always configures a pin as GPIO output. Depending on the port and pin, MUX 2 and beyond can have various meanings—in the case of <code class="literal">PB22</code> and <code class="literal">PB23</code> MUX 2 are the UART pins. The first parameter surrounded by angle brackets, <code class="literal">&lt;&gt;</code>, is thus defined as MUX 2.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec40"/>Pin configurations</h2></div></div></div><p>
<a class="link" href="ch08.html" title="Chapter 8. Blinking Lights and Sensing the World">Chapter 8</a>, <em>Blinking Lights and Sensing the World</em>, talks about the purpose of a pull-up resistor and a <a id="id485" class="indexterm"/>pull-down resistor. Allwinner-based SoCs actually have pull-up or pull-down resistors attached internally to the pins. The second angle-bracket surrounded parameter, <code class="literal">&lt;1&gt;</code>, in this case, enables the internal pull-up, a <code class="literal">&lt;0&gt;</code> here disables the pull-up/pull-down feature, and a <code class="literal">&lt;2&gt;</code> enables the pull-down feature. The pull-down feature is, however, only valid when the port is configured as an input; the SoC does not support pull-down on outputs. One more valid option is to use the keyword <code class="literal">&lt;default&gt;</code>, which tells the driver to use a safe default value.</p><p>The third angle-bracket surrounded parameter defines the current strength that the pin should output. There are four valid values: <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>, where <code class="literal">0</code> corresponds to 10 mA, <code class="literal">1</code> to 20 mA, <code class="literal">2</code> to 30 mA, and <code class="literal">3</code> to 40 mA. The default value can be used to let the driver choose a safe default.</p><p>The fourth position defines the initial output level of the pin, which<a id="id486" class="indexterm"/> can be either low, <code class="literal">&lt;0&gt;</code>, or high, <code class="literal">&lt;1&gt;</code>. Naturally, this is only valid when configuring the pin as output. Also here, default means that the driver uses a safe default value.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>While Port B: pins 22 and 23 were discussed and explained here, the rest of the pins and their muxes can be found on<a id="id487" class="indexterm"/> the linux-sunxi community wiki at <a class="ulink" href="http://linux-sunxi.org/PIO">http://linux-sunxi.org/PIO</a>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec99"/>Further reading</h1></div></div></div><p>The FEX file <a id="id488" class="indexterm"/>contains many other such components that can be set up, varying from configuring which pins are used for the SD card reader to what color format is used for the LCD. All options that have been discovered are also documented at the linux-sunxi wiki page, <a class="ulink" href="http://linux-sunxi.org/Fex_Guide">http://linux-sunxi.org/Fex_Guide</a>. However, since each driver is written to read a key-value pair, things easily and often do change depending on the progression of the driver and kernel as a whole. When in doubt, the kernel source code can always be checked.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec100"/>Installing the configured FEX file</h1></div></div></div><p>Compiling<a id="id489" class="indexterm"/> the FEX file back into a bin file is nearly identical.</p><div><pre class="programlisting">
<strong>[packt@packt:~]$ fexc -I fex -O bin script.fex script.bin</strong>
</pre></div><p>Depending what boot medium is being used, <code class="literal">script.bin</code> has to be copied back so that the device can use these new, changed values. This can be the <code class="literal">/dev/nanda</code> partition on the onboard NAND flash or the first partition that is FAT formatted on a microSD card.</p><p>After having put the <code class="literal">script.bin</code> into place, a reboot is required for the system to read these changes.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec101"/>Summary</h1></div></div></div><p>This appendix gave a small introduction to the FEX file and showed how to modify it. The next appendix will try to cover the most basic troubleshooting for the most common pitfalls.</p></div></body></html>