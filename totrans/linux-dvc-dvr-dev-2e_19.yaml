- en: '*Chapter 15*: Digging into the IIO Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 15 章*：深入挖掘 IIO 框架'
- en: '**Industrial input/output** (**IIO**) is a kernel subsystem dedicated to **analog-to-digital
    converters** (**ADCs**) and **digital-to-analog converters** (**DACs**). With
    the growing numbers of sensors (measurement devices with analog-to-digital or
    digital-to-analog capabilities) with different code implementations, scattered
    across kernel sources, gathering them became necessary. That is what the IIO framework
    does, in a generic way. Jonathan Cameron and the Linux IIO community have been
    developing it since 2009\. Accelerometers, gyroscopes, current/voltage measurement
    chips, light sensors, and pressure sensors all fall into the IIO family of devices.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**工业输入/输出** (**IIO**) 是一个内核子系统，专门用于**模数转换器** (**ADC**) 和**数模转换器** (**DAC**)
    。随着传感器数量的增加（具有模数转换或数模转换功能的测量设备），以及不同代码实现的散布在内核源代码中，收集它们变得必要。这正是 IIO 框架所做的，以一种通用的方式。Jonathan
    Cameron 和 Linux IIO 社区自 2009 年以来一直在开发该框架。加速度计、陀螺仪、电流/电压测量芯片、光传感器和压力传感器都属于 IIO
    设备家族。'
- en: 'The IIO model is based on device and channel architecture:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 模型基于设备和通道架构：
- en: The device represents the chip itself, the top level of the hierarchy.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备代表芯片本身，是层次结构的顶层。
- en: The channel represents a single acquisition line of the device. A device may
    have one or more channels. For example, an accelerometer is a device with three
    channels, one for each axis (*x*, *y*, and *z*).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道代表设备的单个采集线路。一个设备可能有一个或多个通道。例如，加速度计是一个具有三个通道的设备，每个轴对应一个通道（*x*、*y* 和 *z*）。
- en: The IIO chip is the physical and hardware sensor/converter. It is exposed to
    the user space as a character device (when a triggered buffer is supported) and
    a sysfs directory entry that will contain a set of files, some of which represent
    the channels.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 芯片是物理硬件传感器/转换器。它作为字符设备（当支持触发缓冲区时）和一个 sysfs 目录条目暴露给用户空间，该条目将包含一组文件，其中一些文件代表通道。
- en: 'These are the two ways to interact with an IIO device from user space:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式可以用来从用户空间与 IIO 设备进行交互：
- en: '`/sys/bus/iio/iio:deviceX/`, a sysfs directory that represents the device along
    with its channels'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/`，一个 sysfs 目录，表示设备及其通道'
- en: '`/dev/iio:deviceX`, a character device that exports the device''s events and
    data buffer'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/iio:deviceX`，一个字符设备，导出设备的事件和数据缓冲区'
- en: 'As a picture is worth a thousand words, the following is a figure showing an
    overview of the IIO framework:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一张图胜过千言万语，下面是展示 IIO 框架概述的图：
- en: '![Figure 15.1 – IIO framework overview'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – IIO 框架概述'
- en: '](img/B17934_15_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_15_001.jpg)'
- en: Figure 15.1 – IIO framework overview
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – IIO 框架概述
- en: The preceding figure shows how the IIO framework is organized between the kernel
    and the user space. The driver manages the hardware and reports processing to
    the IIO core, using a set of facilities and APIs exposed by the IIO core. The
    IIO subsystem then abstracts the whole underlying mechanism to user space by means
    of the sysfs interface and the character device, on top of which users can execute
    system calls.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了 IIO 框架在内核和用户空间之间的组织方式。驱动程序管理硬件，并将处理信息报告给 IIO 核心，利用 IIO 核心暴露的一组设施和 API。然后，IIO
    子系统通过 sysfs 接口和字符设备将整个底层机制抽象到用户空间，用户可以在其之上执行系统调用。
- en: 'IIO APIs are spread over several header files, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: IIO API 分布在几个头文件中，具体如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we will describe and handle every concept of the IIO framework,
    such as walking through its data structure (devices, channels, and so on), dealing
    with triggered buffer support and continuous capture, along with its sysfs interface,
    exploring existing IIO triggers, learning how to capture data in either one-shot
    mode or continuous mode, and listing tools that can help the developer in testing
    their devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述并处理 IIO 框架中的每个概念，例如遍历其数据结构（设备、通道等），处理触发缓冲区支持和连续捕获，以及其 sysfs 接口，探索现有的
    IIO 触发器，学习如何在单次模式或连续模式下捕获数据，并列出可以帮助开发者测试其设备的工具。
- en: 'In other words, we will cover the following topics in this chapter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，本章将涵盖以下主题：
- en: Introduction to IIO data structures
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IIO 数据结构简介
- en: Integrating IIO triggered buffer support
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 IIO 触发缓冲区支持
- en: Accessing IIO data
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 IIO 数据
- en: Dealing with the in-kernel IIO consumer interface
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理内核中的 IIO 消费者接口
- en: Walking through user-space IIO tools
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览用户空间 IIO 工具
- en: Introduction to IIO data structures
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO 数据结构简介
- en: The IIO framework is made of a few data structures among which is one representing
    the IIO device, another one describing this device, and the last one enumerating
    the channels exposed by the device. An IIO device is represented in the kernel
    as an instance of `struct iio_dev` and described by a `struct iio_info` structure.
    All the important IIO structures are defined in `include/linux/iio/iio.h`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 框架由几个数据结构组成，其中一个表示 IIO 设备，另一个描述该设备，最后一个列举设备暴露的通道。IIO 设备在内核中表示为 `struct iio_dev`
    实例，并通过 `struct iio_info` 结构描述。所有重要的 IIO 结构都定义在 `include/linux/iio/iio.h` 中。
- en: Understanding the struct iio_dev structure
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `struct iio_dev` 结构
- en: The `struct iio_dev` structure represents the IIO device, describing the device
    and its driver. It tells us how many channels are available on the device and
    what modes the device can operate in (one-shot or triggered buffer, for example).
    Moreover, this data structure exposes some hooks to be provided by the driver.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct iio_dev` 结构表示 IIO 设备，描述设备及其驱动程序。它告诉我们设备上可用的通道数量以及设备可以操作的模式（例如一次性转换或触发缓冲区）。此外，该数据结构还暴露了一些驱动程序需要提供的挂钩。'
- en: 'This data structure has the following definition:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据结构的定义如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the sake of readability, only relevant elements for us have been listed
    in the preceding excerpt. The complete structure definition lies in `include/linux/iio/iio.h`.
    The following are the meanings of the elements in the data structure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，在前面的摘录中只列出了与我们相关的元素。完整的结构定义位于 `include/linux/iio/iio.h`。以下是数据结构中各元素的含义：
- en: '`modes` represents the different modes supported by the device. Possible modes
    are as follows:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modes` 表示设备支持的不同模式。可能的模式如下：'
- en: '`INDIO_DIRECT_MODE`: This says the device provides sysfs-type interfaces.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_DIRECT_MODE`：表示设备提供类似 sysfs 的接口。'
- en: '`INDIO_BUFFER_TRIGGERED`: This says that the device supports hardware triggers
    associated with a buffer. This flag mode is automatically set when you set up
    a triggered buffer using the `iio_triggered_buffer_setup()` function.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_BUFFER_TRIGGERED`：表示设备支持与缓冲区相关的硬件触发。当你使用 `iio_triggered_buffer_setup()`
    函数设置触发缓冲区时，此标志模式会自动设置。'
- en: '`INDIO_BUFFER_SOFTWARE`: In continuous conversions, the buffering will be implemented
    in software, by the kernel itself. The kernel will push data into the internal
    FIFO with a possible interrupt at a specified watermark.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_BUFFER_SOFTWARE`：在连续转换中，缓冲区将由内核软件实现。内核将数据推送到内部 FIFO，并在达到指定水位时可能会触发中断。'
- en: '`INDIO_BUFFER_HARDWARE`: This means the device has a hardware buffer. In continuous
    conversions, the buffering can be handled by the device. This means that the data
    stream can be obtained directly from the hardware backend.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_BUFFER_HARDWARE`：表示设备具有硬件缓冲区。在连续转换中，缓冲区由设备处理。这意味着数据流可以直接从硬件后端获取。'
- en: '`INDIO_ALL_BUFFER_MODES`: A union of the preceding three.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_ALL_BUFFER_MODES`：前三种模式的联合。'
- en: '`INDIO_EVENT_TRIGGERED`: Conversion can be triggered by some sort of event,
    such as a threshold voltage reached on an ADC, but no interrupt or timer trigger.
    This flag is intended to be used for comparator-equipped chips with no other way
    to trigger conversion.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_EVENT_TRIGGERED`：转换可以由某种事件触发，例如 ADC 上的阈值电压达到，但没有中断或定时器触发。此标志适用于没有其他触发转换方式的带有比较器的芯片。'
- en: '`INDIO_HARDWARE_TRIGGERED`: Can be triggered by hardware events, such as IRQ
    or clock events.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_HARDWARE_TRIGGERED`：可以通过硬件事件触发，例如 IRQ 或时钟事件。'
- en: '`INDIO_ALL_TRIGGERED_MODES` union of `INDIO_BUFFER_TRIGGERED`, `INDIO_EVENT_TRIGGERED`,
    and `INDIO_HARDWARE_TRIGGERED`.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_ALL_TRIGGERED_MODES`：`INDIO_BUFFER_TRIGGERED`、`INDIO_EVENT_TRIGGERED`
    和 `INDIO_HARDWARE_TRIGGERED` 的联合。'
- en: '`currentmode`: This represents the mode used by the device.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentmode`：表示设备使用的模式。'
- en: '`dev`: This represents the struct device (according to Linux Device Model)
    the IIO device is tied to.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：表示 IIO 设备所绑定的 `struct device` 结构（根据 Linux 设备模型）。'
- en: '`buffer`: This is your data buffer, pushed to the user space when using triggered
    buffer mode. It is automatically allocated and associated with your device when
    you enable triggered buffer support using the `iio_triggered_buffer_setup` function.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`：这是你的数据缓冲区，当使用触发缓冲区模式时，它会被推送到用户空间。当你使用 `iio_triggered_buffer_setup`
    函数启用触发缓冲区支持时，它会自动分配并与设备关联。'
- en: '`scan_bytes`: This is the number of bytes captured to be fed to the buffer.
    When using a trigger buffer from the user space, the buffer should be at least
    `indio->scan_bytes` bytes large.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_bytes`：这是捕获的字节数，用于填充缓冲区。在使用来自用户空间的触发缓冲区时，缓冲区的大小应该至少为`indio->scan_bytes`字节。'
- en: '`available_scan_masks`: This is an optional array of allowed bitmasks. When
    using a triggered buffer, you can enable channels to be captured and fed into
    the IIO buffer. If you do not want to allow some channels to be enabled, you should
    fill this array with only allowed ones. An example of an accelerometer (with X,
    Y, and Z channels) is as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available_scan_masks`：这是一个可选的允许的位掩码数组。使用触发缓冲区时，可以启用要捕获并输入IIO缓冲区的通道。如果不希望启用某些通道，应该仅在此数组中填写允许的通道。以下是一个加速度计（具有X、Y和Z通道）的示例：'
- en: '[PRE2]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`active_scan_mask`: This is a bitmask of enabled channels. Only the data from
    those channels should be pushed into the buffer. For example, for an eight-channel
    ADC converter, if you only enable the first (index 0), the third (index 2), and
    the last (index 7) channels, the bitmask would be `0b10000101` (`0x85`). `active_scan_mask`
    will be set to `0x85`. The driver can then use the `for_each_set_bit` macro to
    walk through each set bit, fetch the data from the corresponding channels, and
    fill the buffer.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_scan_mask`：这是已启用通道的位掩码。只有来自这些通道的数据应该被推送到缓冲区。例如，对于一个八通道的ADC转换器，如果只启用第一个（索引0）、第三个（索引2）和最后一个（索引7）通道，则位掩码将为`0b10000101`（`0x85`）。`active_scan_mask`将被设置为`0x85`。然后，驱动程序可以使用`for_each_set_bit`宏遍历每个位，获取相应通道的数据并填充缓冲区。'
- en: '`scan_timestamp`: This tells whether to push the capture timestamp into the
    buffer or not. If `true`, the timestamp will be pushed as the last element of
    the buffer. The timestamp is 8 bytes (64 bits) large.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_timestamp`：该字段指示是否将捕获的时间戳推送到缓冲区。如果为`true`，时间戳将作为缓冲区的最后一个元素推送。时间戳大小为8字节（64位）。'
- en: '`trig`: This is the current device trigger (when buffer mode is supported).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trig`：这是当前的设备触发器（当支持缓冲区模式时）。'
- en: '`pollfunc`: This is the function run on the trigger being received.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pollfunc`：这是在触发接收到时运行的函数。'
- en: '`channels`: This represents the table channel specification structure, to describe
    every channel the device has.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels`：表示表通道规范结构，用于描述设备具有的每个通道。'
- en: '`num_channels`: This represents the number of channels specified in `channels`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_channels`：表示在`channels`中指定的通道数量。'
- en: '`name`: This represents the device name.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：表示设备名称。'
- en: '`info`: Callbacks and constant information from the driver.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：来自驱动程序的回调和常量信息。'
- en: '`setup_ops`: A set of callback functions to call before and after the buffer
    is enabled/disabled. This structure is defined in `include/linux/iio/iio.h`, as
    follows:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_ops`：在缓冲区启用/禁用前后调用的一组回调函数。这个结构在`include/linux/iio/iio.h`中定义，如下所示：'
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that each callback in this data structure is optional.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数据结构中的每个回调都是可选的。
- en: '`chrdev`: Associated character device created by the IIO core, with `iio_buffer_fileops`
    as the file operation table.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chrdev`：IIO核心创建的关联字符设备，文件操作表为`iio_buffer_fileops`。'
- en: 'Now that we are familiar with the IIO device structure, the next step is to
    allocate memory for it. The appropriate function to achieve that is `devm_iio_device_alloc()`,
    which is the managed version for `iio_device_alloc()` and has the following definition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了IIO设备结构，下一步是为其分配内存。实现此目标的合适函数是`devm_iio_device_alloc()`，它是`iio_device_alloc()`的管理版本，定义如下：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is recommended to use the managed version in a new driver as the `devres`
    core takes care of freeing the memory when it is no longer needed. In the preceding
    function prototype, `dev` is the device to allocate `iio_dev` for and `sizeof_priv`
    is the extra memory space to allocate for any private data structure. The function
    returns `NULL` if the allocation fails.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在新的驱动程序中使用管理版本，因为`devres`核心会在不再需要时自动释放内存。在上述函数原型中，`dev`是分配`iio_dev`的设备，`sizeof_priv`是为任何私有数据结构分配的额外内存空间。如果分配失败，函数将返回`NULL`。
- en: 'After the IIO device memory has been allocated, the next step is to initialize
    different fields. Once done, the device must be registered with the IIO subsystem
    using the `devm_iio_device_register()` function, the prototype of which is the
    following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配了IIO设备内存后，下一步是初始化不同的字段。完成后，设备必须使用`devm_iio_device_register()`函数注册到IIO子系统中，该函数的原型如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function is the managed version of `iio_device_register()` and takes care
    of unregistering the IIO device on driver detach. In its parameters, `dev` is
    the same device as the one for which the IIO device has been allocated, and `indio_dev`
    is the IIO device previously initialized. The device will be ready to accept requests
    from the user space after this function succeeds (returns `0`). The following
    is an example showing how to register an IIO device:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`iio_device_register()`的托管版本，并负责在驱动程序分离时取消注册IIO设备。在其参数中，`dev`是与为其分配了IIO设备的设备相同的设备，`indio_dev`是先前初始化的IIO设备。此函数成功执行后（返回`0`），设备将准备好接受来自用户空间的请求。以下是一个示例，展示了如何注册IIO设备：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If an error occurs, `devm_iio_device_register()` will return a negative error
    code. The reverse operation for the non-managed variant (usually done in the release
    function) is `iio_device_unregister()`, which has the following declaration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，`devm_iio_device_register()`将返回负的错误代码。非托管变体的反向操作（通常在释放函数中进行）是`iio_device_unregister()`，其声明如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, managed registration takes care of unregistering the device on driver
    detach or when the device leaves the system. Moreover, because we used a managed
    allocation variant, there is no need to free the memory as this will be internal
    to the core.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，托管注册负责在驱动程序分离或设备离开系统时取消注册设备。此外，由于我们使用了托管分配变体，因此无需手动释放内存，因为这将由核心内部处理。
- en: 'You might have also noticed we used a new function in the excerpt, `iio_priv()`.
    This accessor returns the address of the private data allocated with the IIO device.
    It is recommended to use this function instead of doing a direct dereference.
    As an example, given an IIO device, the corresponding private data can be retrieved
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到我们在摘录中使用了一个新函数，`iio_priv()`。这个访问器返回与IIO设备分配的私有数据的地址。建议使用这个函数，而不是直接解引用。例如，给定一个IIO设备，可以按如下方式检索相应的私有数据：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The IIO device is useless on its own. Now that we are done with the main IIO
    device data structure, we have to add a set of hooks allowing us to interact with
    the device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: IIO设备本身是没有用的。现在我们完成了主要的IIO设备数据结构，我们必须添加一组钩子，以便与设备进行交互。
- en: Understanding the struct iio_info structure
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`struct iio_info`结构
- en: 'The `struct iio_info` structure is used to declare the hooks used by the IIO
    core to read/write channel/attribute values. The following is part of its declaration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct iio_info`结构用于声明IIO核心读取/写入通道/属性值时使用的钩子。以下是其声明的一部分：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, the full definition of this data structure can be found in `/include/linux/iio/iio.h`.
    For the enumerated elements in the preceding structure excerpt, the following
    are their meanings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，完整的定义可以在`/include/linux/iio/iio.h`中找到。对于前面结构摘录中的枚举元素，以下是它们的含义：
- en: '`attrs` represents the device attributes exposed to user space.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attrs`表示暴露给用户空间的设备属性。'
- en: '`read_raw` is the callback invoked when a user reads a device sysfs file attribute.
    The `mask` parameter is a bitmask allowing us to know which type of value is requested.
    The `chan` parameter lets us know the channel concerned. `*val` and `*val2` are
    output parameters that must contain the elements making up the returned value.
    They must be set with raw values read from the device.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_raw`是当用户读取设备sysfs文件属性时调用的回调。`mask`参数是一个位掩码，允许我们知道请求的值类型。`chan`参数让我们知道相关的通道。`*val`和`*val2`是输出参数，必须包含组成返回值的元素。它们必须使用从设备读取的原始值进行设置。'
- en: 'The return value of this callback is kind of standardized and indicates how
    `*val` and `*val2` must be handled by the IIO core to compute the real value.
    Possible return values are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该回调的返回值是标准化的，指示IIO核心如何处理`*val`和`*val2`以计算真实值。可能的返回值如下：
- en: '`IIO_VAL_INT`: The output value is an integer. In this case, the driver must
    set `*val` only.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_INT`：输出值是一个整数。在这种情况下，驱动程序必须仅设置`*val`。'
- en: '`IIO_VAL_INT_PLUS_MICRO`: The output value is made of an integer part and a
    micro part. The driver must set `*val` with the integer value, while `*val2` must
    be set with the micro value.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_INT_PLUS_MICRO`：输出值由整数部分和微小部分组成。驱动程序必须使用整数值设置`*val`，而`*val2`必须设置为微小值。'
- en: '`IIO_VAL_INT_PLUS_NANO`: This is the same as the micro, but `*val2` must be
    set with the nano value.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_INT_PLUS_NANO`：这与微小部分相同，但`*val2`必须设置为纳米值。'
- en: '`IIO_VAL_INT_PLUS_MICRO_DB`: The output values are in `*val` must be set with
    the integer part and `*val2` must set with the micro part, if any.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_INT_PLUS_MICRO_DB`：输出值中的`*val`必须设置为整数部分，`*val2`必须设置为微部分（如果有的话）。'
- en: '`IIO_VAL_INT_MULTIPLE`: `val` is considered as an array of integers and `*val2`
    is the number of entries in the array. They must be set accordingly then. The
    maximum size of `val` is `INDIO_MAX_RAW_ELEMENTS`, defined as `4`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_INT_MULTIPLE`：`val`被视为整数数组，`*val2`是数组中的条目数。它们必须相应地设置。`val`的最大大小是`INDIO_MAX_RAW_ELEMENTS`，定义为`4`。'
- en: '`IIO_VAL_FRACTIONAL`: The final value is fractional. The driver must set `*val`
    with the numerator and `*val2` with the denominator.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_FRACTIONAL`：最终值是分数形式。驱动程序必须将`*val`设置为分子，`*val2`设置为分母。'
- en: '`IIO_VAL_FRACTIONAL_LOG2`: The final value is a logarithmic fractional. The
    IIO core expects the denominator (`*val2`) to be specified as the *log2* of the
    actual denominator. For example, for ADCs and DACs, this will usually be the number
    of significant bits. `*val` is a normal integer denominator.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_FRACTIONAL_LOG2`：最终值是对数分数。IIO核心期望分母（`*val2`）作为实际分母的*log2*形式指定。例如，对于ADC和DAC，这通常是有效位数。`*val`是一个正常的整数分母。'
- en: '`IIO_VAL_CHAR`: The IIO core expects `*val` to be a character. This is, most
    of the time, used with the `IIO_CHAN_INFO_THERMOCOUPLE_TYPE` mask, in which case
    the driver must return the type of thermocouple.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IIO_VAL_CHAR`：IIO核心期望`*val`是一个字符。这个通常与`IIO_CHAN_INFO_THERMOCOUPLE_TYPE`掩码一起使用，在这种情况下，驱动程序必须返回热电偶的类型。'
- en: All the preceding does not change the fact that, in case of an error, the callback
    must return a negative error code, for example, `-EINVAL`. I recommend you have
    a look at how the final value is processed in `iio_convert_raw_to_processed_unlocked()`
    in the `drivers/iio/inkern.c` source file.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述内容并不改变这一事实：在发生错误的情况下，回调必须返回一个负的错误代码，例如`-EINVAL`。我建议你查看`drivers/iio/inkern.c`源文件中`iio_convert_raw_to_processed_unlocked()`函数，了解最终值是如何处理的。
- en: '`write_raw` is the callback used to write a value to the device. You can use
    it, for example, to set the sampling frequency or change the scale.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_raw`是用于将值写入设备的回调。例如，你可以用它来设置采样频率或改变量程。'
- en: 'An example of setting up the `struct iio_info` structure is the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`struct iio_info`结构体的示例如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You must not confuse this `struct iio_info` with the user-space `iio_info` tool,
    which is part of the `libiio` package.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将这个`struct iio_info`与用户空间的`iio_info`工具混淆，后者是`libiio`包的一部分。
- en: The concept of IIO channels
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIO通道的概念
- en: 'In IIO terminology, a channel represents a single acquisition line of a sensor.
    This means each data mesurement entity a sensor can provide/sense is called a
    `struct iio_chan_spec` is the structure that represents and describes a single
    channel in the kernel, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在IIO术语中，通道表示传感器的单一采集线路。这意味着传感器能够提供/感知的每一个数据测量实体称为`struct iio_chan_spec`，这是表示和描述内核中单一通道的结构体，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following are the meanings of elements in the data structure:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是数据结构中各元素的含义：
- en: '`type` specifies which type of measurement the channel makes. In the case of
    voltage measurement, it should be `IIO_VOLTAGE`. For a light sensor, it is `IIO_LIGHT`.
    For an accelerometer, `IIO_ACCEL` is used. All available types are defined in
    `include/uapi/linux/iio/types.h`, as `enum iio_chan_type`. To write a driver for
    a given converter, you have to look into that file to see the type each of your
    converter channels falls into.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`指定通道进行的测量类型。在电压测量的情况下，它应该是`IIO_VOLTAGE`。对于光传感器，是`IIO_LIGHT`。对于加速度计，使用`IIO_ACCEL`。所有可用的类型在`include/uapi/linux/iio/types.h`中定义，作为`enum
    iio_chan_type`。要为给定的转换器编写驱动程序，你需要查看该文件，以确定每个转换器通道属于哪种类型。'
- en: '`channel` specifies the channel index when `.indexed` is set to `1`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel`在`.indexed`被设置为`1`时指定通道索引。'
- en: '`channel2` specifies the channel modifier when `.modified` is set to `1`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel2`在`.modified`被设置为`1`时指定通道修改器。'
- en: 'The `scan_index` and `scan_type` fields are used to identify elements from
    a buffer, when using buffer triggers. `scan_index` sets the position of the captured
    channel inside the buffer. Channels are placed in the buffer ordered by `scan_index`,
    from the lowest index (placed first) to the highest index. Setting `.scan_index`
    to `-1` will prevent the channel from buffered capture (no entry in the `scan_elements`
    directory). Elements in this substructure have the folowing meanings:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_index` 和 `scan_type` 字段用于在使用缓冲触发时识别缓冲区中的元素。`scan_index` 设置捕获的通道在缓冲区中的位置。通道按
    `scan_index` 从最低索引（最先放置）到最高索引排列。将 `.scan_index` 设置为 `-1` 将防止通道被缓冲捕获（在 `scan_elements`
    目录中没有条目）。此子结构中的元素具有以下含义：'
- en: '`sign`: `s` or `u` specifies symbols (signed (complement of 2) or unsigned).'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sign`: `s` 或 `u` 指定符号（有符号（补码）或无符号）。'
- en: '`realbits`: The number of valid data bits.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realbits`: 有效数据位的数量。'
- en: '`storagebits`: The number of digits occupied by this channel in the buffer.
    That is to say, a value can really be encoded with 12 bits, but it occupies 16
    bits (storage bits) in the buffer. Therefore, the data must be moved four times
    to the right to get the actual value. This parameter depends on the device and
    you should refer to its datasheet.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storagebits`: 此通道在缓冲区中占用的位数。也就是说，一个值可以用 12 位来编码，但它在缓冲区中占用了 16 位（存储位）。因此，数据必须右移四次才能得到实际值。此参数取决于设备，您应参考其数据手册。'
- en: '`shift`: Represents the number of times data values should be right-shifted
    before masking out unused bits. This parameter is not always required. If the
    number of valid bits equals the number of storage bits, the shift will be `0`.
    This parameter can also be found in the device datasheet.'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`: 表示在屏蔽掉未使用的位之前，数据值应该右移的次数。此参数并非总是必需的。如果有效位数等于存储位数，则移位值为 `0`。此参数也可以在设备数据手册中找到。'
- en: '`repeat`: The number of times real/storage bits repeat.'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`: 实际/存储位重复的次数。'
- en: '`endianness`: Represents the data endianness. It is of the `enum iio_endian`
    type and should be set with one of `IIO_CPU`, `IIO_LE`, or `IIO_BE`, which mean,
    the native CPU endianness, little endian, or big endian respectively.'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endianness`: 表示数据的字节序。它是 `enum iio_endian` 类型，应该设置为 `IIO_CPU`、`IIO_LE` 或 `IIO_BE`
    中的一个，分别表示本地 CPU 字节序、小端字节序或大端字节序。'
- en: The `modified` field specifies whether a modifier is to be applied to this channel
    attribute name or not. In that case, the modifier is set in `.channel2`. (For
    example, `IIO_MOD_X`, `IIO_MOD_Y`, and `IIO_MOD_Z` are modifiers for axial-sensors
    about the `X`, `Y`, and `Z` axis). The available modifier list is defined in the
    kernel IIO header as `enum iio_modifier`. Modifiers only mangle the channel attribute
    name in sysfs, not the value.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modified` 字段指定是否对该通道属性名称应用修改器。如果是，修改器将设置在 `.channel2` 中。（例如，`IIO_MOD_X`、`IIO_MOD_Y`
    和 `IIO_MOD_Z` 是针对 `X`、`Y` 和 `Z` 轴的轴向传感器的修改器）。可用的修改器列表在内核 IIO 头文件中定义为 `enum iio_modifier`。修改器仅在
    sysfs 中改变通道属性名称，而不改变其值。'
- en: '`indexed` specifies whether the channel attribute name has an index or not.
    If yes, the index is specified in the `.channel` field.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexed` 指定通道属性名称是否具有索引。如果有，索引将在 `.channel` 字段中指定。'
- en: '`info_mask_separate` marks the attribute as being specific to this channel.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_separate` 将该属性标记为特定于此通道。'
- en: '`info_mask_shared_by_type` marks the attribute as being shared by all channels
    of the same type. The information exported is shared by all channels of the same
    type.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_type` 将该属性标记为同一类型的所有通道共享。导出的信息由同一类型的所有通道共享。'
- en: '`info_mask_shared_by_dir` marks the attribute as being shared by all channels
    of the same direction. The information exported is shared by all channels of the
    same direction.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_dir` 将该属性标记为同一方向的所有通道共享。导出的信息由同一方向的所有通道共享。'
- en: '`info_mask_shared_by_all` marks the attribute as being shared by all channels,
    whatever their type or their direction may be. The information exported is shared
    by all channels.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_all` 将该属性标记为所有通道共享，无论其类型或方向如何。导出的信息由所有通道共享。'
- en: '`iio_chan_spec.info_mask_*` elements are masks used to specify channel sysfs
    attributes exposed to user space depending on their shared information. Therefore,
    masks must be set by ORing one or more bitmasks, all of which are defined in `include/linux/iio/types.h`,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`iio_chan_spec.info_mask_*` 元素是掩码，用于根据其共享信息指定暴露给用户空间的通道 sysfs 属性。因此，掩码必须通过按位或（OR）一个或多个位掩码来设置，这些位掩码都在
    `include/linux/iio/types.h` 中定义，如下所示：'
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is an example of specifying a mask for a given channel:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指定给定通道的掩码的示例：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means raw and processed attributes are specific to the channel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着原始和处理过的属性是特定于通道的。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While not specified in the preceding `struct iio_chan_spec` structure description,
    the term *attribute* refers to a *sysfs attribute*. This applies across the whole
    chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在前面的 `struct iio_chan_spec` 结构描述中没有明确指定，术语 *属性* 指的是 *sysfs 属性*。这适用于整章内容。
- en: Having described the channel data structure, let's decipher the mystery about
    channel attribute naming, which respects a specific convention.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过描述通道数据结构，我们来解开通道属性命名的谜团，它遵循特定的约定。
- en: Channel attribute naming convention
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通道属性命名约定
- en: 'An attribute''s name is automatically generated by the IIO core following a
    predefined pattern, `{direction}_{type}{index}_{modifier}_{info_mask}`. The following
    are descriptions of each field in the pattern:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的名称由 IIO 核心根据预定义模式自动生成，模式为 `{direction}_{type}{index}_{modifier}_{info_mask}`。以下是模式中每个字段的描述：
- en: '`{direction}` corresponds to the attribute direction, according to the `struct
    iio_direction` structure in `drivers/iio/industrialio-core.c`:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{direction}` 对应于属性方向，依据 `drivers/iio/industrialio-core.c` 中的 `struct iio_direction`
    结构：'
- en: '[PRE14]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do note that an input channel is a channel that can generate samples (such channels
    are handled in the read method, for instance, an ADC channel). On the other hand,
    an output channel is a channel that can receive samples (such channels are handled
    in the write method, for instance, a DAC channel).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输入通道是可以生成样本的通道（此类通道在读取方法中处理，例如 ADC 通道）。另一方面，输出通道是可以接收样本的通道（此类通道在写入方法中处理，例如
    DAC 通道）。
- en: '`{type}` corresponds to the channel type string, according to the constant
    `iio_chan_type_name_spec` char array (indexed by the channel type of type `enum
    iio_chan_type`) defined in `drivers/iio/industrialio-core.c`, as follows:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{type}` 对应于通道类型字符串，依据 `drivers/iio/industrialio-core.c` 中的常量 `iio_chan_type_name_spec`
    字符数组（由 `enum iio_chan_type` 类型的通道类型索引）定义，如下所示：'
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`{index}` depends on the channel `.indexed` field being set or not. If set,
    the index will be taken from the `.channel` field in order to replace the `{index}`
    pattern.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{index}` 取决于通道 `.indexed` 字段是否被设置。如果已设置，索引将从 `.channel` 字段中获取，并用来替代 `{index}`
    模式。'
- en: 'The `{modifier}` pattern depends on the channel `.modified` field being set
    or not. If set, the modifier will be taken from the `.channel2` field, and the
    `{modifier}` field in the pattern will be replaced according to the `char` array
    `struct iio_modifier_names` structure:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{modifier}` 模式取决于通道 `.modified` 字段是否被设置。如果已设置，修饰符将从 `.channel2` 字段中获取，且模式中的
    `{modifier}` 字段将根据 `char` 数组 `struct iio_modifier_names` 结构进行替换：'
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`{info_mask}` depends on the channel info mask, private or shared, indexing
    the value in the `iio_chan_info_postfix` char array, defined as the following:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{info_mask}` 取决于通道信息掩码，私有或共享，索引 `iio_chan_info_postfix` 字符数组中的值，定义如下：'
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Channel naming convention should have no more secrets for us now. Now that we
    are familiar with the naming, let's learn how to precisely identify channels.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通道命名约定现在应该没有更多的疑问了。既然我们已经熟悉了命名规则，接下来让我们学习如何准确地识别通道。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this naming pattern, if an element is not present, then the directly preceding
    underscore will be omitted. For example, if the modifier is not specified, the
    pattern becomes `{direction}_{type}{index}_{info_mask}` instead of `{direction}_{type}{index}__{info_mask}`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命名模式中，如果某个元素不存在，那么直接前面的下划线将被省略。例如，如果未指定修饰符，则模式将变为 `{direction}_{type}{index}_{info_mask}`，而不是
    `{direction}_{type}{index}__{info_mask}`。
- en: Distinguishing channels
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分通道
- en: 'You may face some difficulties when there are multiple data channels of the
    same type. The dilemma would be *how to precisely identify each of them*. There
    are two solutions for that: **indexes** and **modifiers**.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个相同类型的数据通道时，你可能会遇到一些困难。这个难题是 *如何精确识别每个通道*。对此有两种解决方案：**索引**和**修饰符**。
- en: Channel identification using an index
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用索引进行通道标识
- en: 'Given an ADC device with one channel line, indexing is not needed. Its channel
    definition would be as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个具有单个通道线的 ADC 设备，不需要索引。其通道定义如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Given the preceding excerpt, the attribute name will be `in_voltage_raw`, and
    its absolute sysfs path will be `/sys/bus/iio/iio:deviceX/in_voltage_raw`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的摘录，属性名称将是 `in_voltage_raw`，其绝对 sysfs 路径将是 `/sys/bus/iio/iio:deviceX/in_voltage_raw`。
- en: 'Now let''s say the ADC has four or even eight channels. How do we identify
    each of them? The solution is to use indexes. Setting the `.indexed` field to
    `1` will modify the channel attribute name with the `.channel` value, replacing
    `{index}` in the naming pattern:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 ADC 有四个甚至八个通道。我们该如何识别每个通道？解决方案是使用索引。将 `.indexed` 字段设置为 `1`，可以通过 `.channel`
    值修改通道属性名称，替换命名模式中的 `{index}`：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are the full sysfs paths of the resulting channel attributes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的通道属性的完整 sysfs 路径：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, even if they all have the same type, they are differentiated
    by their index.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使它们都是同类型的，它们也通过索引区分开来。
- en: Channel identification using a modifier
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用修饰符进行通道识别
- en: 'To highlight the concept of modifiers, let''s consider a light sensor with
    two channels – one for infrared light and the other for both infrared and visible
    light. Without an index or a modifier, an attribute name would be `in_intensity_raw`.
    Using indexes here can be error-prone because it makes no sense to have `in_intensity0_ir_raw`
    and `in_intensity1_ir_raw` as it would mean they are channels of the same type.
    Using a modifier will help us to have meaningful attribute names. The channel
    definition could look as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出修饰符的概念，假设有一个带有两个通道的光传感器——一个用于红外光，另一个同时用于红外光和可见光。如果没有索引或修饰符，属性名称会是 `in_intensity_raw`。在这里使用索引可能会容易出错，因为如果有
    `in_intensity0_ir_raw` 和 `in_intensity1_ir_raw`，它们看起来像是同类型的通道，这毫无意义。使用修饰符可以帮助我们获得有意义的属性名称。通道定义可以如下所示：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting attributes would be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结果生成的属性如下：
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_ir_raw` for the channel measuring IR
    intensity'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_intensity_ir_raw` 用于测量红外强度的通道'
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_both_raw` for the channel measuring
    both'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_intensity_both_raw` 用于同时测量红外和可见光的通道'
- en: '`/sys/bus/iio/iio:deviceX/in_illuminance_input` for the processed data'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_illuminance_input` 用于处理后的数据'
- en: '`/sys/bus/iio/iio:deviceX/sampling_frequency` for the sampling frequency, shared
    by all'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/sampling_frequency` 用于采样频率，所有设备共享'
- en: This is valid with an accelerometer too, as we will see in a later case study.
    For now, let's summarize what we have discussed so far by implementing a dummy
    IIO driver.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在加速度计中同样适用，我们将在后续的案例研究中看到。现在，让我们通过实现一个虚拟的 IIO 驱动来总结到目前为止讨论的内容。
- en: Putting it all together – writing a dummy IIO driver
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合起来——编写一个虚拟的 IIO 驱动
- en: Let's summarize what we have seen so far with a simple dummy driver, which will
    expose four voltage channels. We will not care about the `read()` or `write()`
    functions for the moment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的虚拟驱动程序来总结到目前为止的内容，该驱动将暴露四个电压通道。暂时我们不关心 `read()` 或 `write()` 函数。
- en: 'First, let''s define the headers we''ll need for the development:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义开发过程中需要的头文件：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, because channel description is a generic and repetitive operation, let''s
    define a macro that will populate the channel description for us, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于通道描述是一个通用且重复的操作，我们可以定义一个宏，来为我们填充通道描述，如下所示：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the channel population macro has been defined, let''s define our driver
    state data structure, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了通道填充宏之后，我们可以定义我们的驱动状态数据结构，如下所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The data structure defined previously is useless. It is there just to show
    the concept. Then, since we do not need read or write operations in this dummy
    driver example, let''s create empty read and write functions that just return
    `0` (meaning that everything went successfully):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的数据结构是没有用的。它仅仅是用来展示这个概念。接着，因为我们在这个虚拟驱动程序示例中不需要读取或写入操作，让我们创建空的读取和写入函数，这些函数只返回
    `0`（表示一切正常）：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can now declare our IIO channels using the macro we defined earlier. Moreover,
    we can set up our `iio_info` data structure as follows, assigned at the same time
    as the fake read and write operations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用之前定义的宏来声明我们的 IIO 通道。此外，我们还可以按如下方式设置 `iio_info` 数据结构，并在同一时间分配虚拟的读取和写入操作：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that all the necessary IIO data structures have been set up, we can switch
    to platform driver-related data structures and implementing its methods, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有必要的 IIO 数据结构已经设置完毕，我们可以切换到与平台驱动相关的数据结构并实现其方法，如下所示：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding probing method, we have exclusively used resource-managed
    APIs for allocation and registering. This significantly simplifies the code and
    gets rid of the driver''s `remove` method. The driver declaration and registering
    would then look like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的探测方法中，我们仅使用了资源管理的 API 进行分配和注册。这大大简化了代码，并且去除了驱动程序的 `remove` 方法。驱动程序的声明和注册将如下所示：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After loading the preceding module, you will have the following output while
    listing available IIO devices on the system:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 加载上述模块后，在系统中列出可用的 IIO 设备时，您将看到以下输出：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A very complete IIO driver that can be used for learning purposes or a development
    model is the IIO simple dummy driver, in `drivers/iio/dummy/iio_simple_dummy.c`.
    It can be made available on the target by enabling the `IIO_SIMPLE_DUMMY` kernel
    config option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常完整的 IIO 驱动程序，可以用于学习目的或开发模型，是位于 `drivers/iio/dummy/iio_simple_dummy.c` 的
    IIO 简单虚拟驱动程序。通过启用 `IIO_SIMPLE_DUMMY` 内核配置选项，可以在目标上使其可用。
- en: Now that we have addressed the basic IIO concept, we can go a step further by
    implementing buffer support and the concept of triggers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本的 IIO 概念，接下来我们可以进一步实现缓冲区支持和触发器概念。
- en: Integrating IIO triggered buffer support
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 IIO 触发的缓冲区支持
- en: 'It might be useful to be able to capture data based on some external signals
    or events (triggers) in data acquisition applications. These triggers might be
    the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据采集应用程序中，能够基于一些外部信号或事件（触发器）捕获数据可能会很有用。这些触发器可能包括以下几种：
- en: A data ready signal
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据就绪信号
- en: An IRQ line connected to some external system (GPIO or whatever)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个连接到某个外部系统（如 GPIO 或其他）的 IRQ 线路
- en: On processor periodic interrupt (a timer, for example)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理器的周期性中断（例如定时器）
- en: User space reading/writing a specific file in sysfs
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间读取/写入 sysfs 中的特定文件
- en: IIO device drivers are completely decorrelated from the triggers, whose drivers
    are implemented in `drivers/iio/trigger/`. A trigger may initialize data capture
    on one or many devices. These triggers are used to fill buffers, exposed to user
    space through the character device created during the registration of the IIO
    device.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 设备驱动程序与触发器完全解耦，触发器的驱动程序实现位于 `drivers/iio/trigger/` 中。触发器可以初始化一个或多个设备的数据采集。这些触发器用于填充缓冲区，并通过在
    IIO 设备注册期间创建的字符设备暴露给用户空间。
- en: 'You can develop your own trigger driver, but it is out of the scope of this
    book. We will try to focus on existing ones only. These are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开发自己的触发器驱动程序，但这超出了本书的范围。我们将专注于现有的触发器。这些触发器如下：
- en: '`iio-trig-interrupt`: This allows using IRQs as IIO triggers. In old kernel
    versions (prior to v3.11), it used to be `iio-trig-gpio`. To support this trigger
    mode, you should enable `CONFIG_IIO_INTERRUPT_TRIGGER` in the kernel config. If
    built as a module, the module will be called `iio-trig-interrupt`.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-interrupt`：这允许使用 IRQ 作为 IIO 触发器。在旧版本的内核中（v3.11 之前），它曾经是 `iio-trig-gpio`。要支持此触发模式，您应在内核配置中启用
    `CONFIG_IIO_INTERRUPT_TRIGGER`。如果作为模块构建，则模块将命名为 `iio-trig-interrupt`。'
- en: '`iio-trig-hrtimer`: Provides a frequency-based IIO trigger using high-resolution
    timers as an interrupt source (since kernel v4.5). In an older kernel version,
    it used to be `iio-trig-rtc`. To support this trigger mode in the kernel, the
    `IIO_HRTIMER_TRIGGER` config option must be enabled. If built as a module, the
    module will be called `iio-trig-hrtimer`.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-hrtimer`：提供一个基于频率的 IIO 触发器，使用高分辨率定时器作为中断源（自内核 v4.5 起）。在旧版本的内核中，它曾经是
    `iio-trig-rtc`。要在内核中支持此触发模式，必须启用 `IIO_HRTIMER_TRIGGER` 配置选项。如果作为模块构建，则模块将命名为 `iio-trig-hrtimer`。'
- en: '`iio-trig-sysfs`: This allows us to use the `SYSFS` entry to trigger data capture.
    `CONFIG_IIO_SYSFS_TRIGGER` is the kernel option to add the support of this trigger
    mode.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-sysfs`：这允许我们使用 `SYSFS` 条目来触发数据采集。`CONFIG_IIO_SYSFS_TRIGGER` 是内核选项，用于支持此触发模式。'
- en: '`iio-trig-bfin-timer`: This allows us to use a Blackfin timer as an IIO trigger
    (still in staging).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-bfin-timer`：这使我们能够使用 Blackfin 定时器作为 IIO 触发器（仍处于阶段中）。'
- en: 'IIO exposes an API so that we can do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 提供了一个 API，允许我们执行以下操作：
- en: Declare any given number of triggers.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明任何数量的触发器。
- en: Choose which channels will have their data pushed into a buffer.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择哪些通道将其数据推送到缓冲区中。
- en: If your IIO device provides the support of a trigger buffer, you must set `iio_dev.pollfunc`,
    which is executed when the trigger fires. This handler has the responsibility
    of finding enabled channels through `indio_dev->active_scan_mask`, retrieving
    their data, and feeding them into `indio_dev->buffer` using the `iio_push_to_buffers_with_timestamp`
    function. Therefore, buffers and triggers are tightly connected in the IIO subsystem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的IIO设备支持触发器缓冲区，你必须设置`iio_dev.pollfunc`，它会在触发器触发时执行。这个处理程序的职责是通过`indio_dev->active_scan_mask`查找启用的通道，获取它们的数据，并通过`iio_push_to_buffers_with_timestamp`函数将数据推送到`indio_dev->buffer`中。因此，在IIO子系统中，缓冲区和触发器是紧密关联的。
- en: 'The IIO core provides a set of helper functions to set up triggered buffers,
    which you can find in `drivers/iio/industrialio-triggered-buffer.c`. The following
    are the steps to support a triggered buffer from within your driver:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: IIO核心提供了一组辅助函数，用于设置触发器缓冲区，你可以在`drivers/iio/industrialio-triggered-buffer.c`中找到它们。以下是支持触发器缓冲区的步骤：
- en: 'Fill an `iio_buffer_setup_ops` structure if needed:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，填写`iio_buffer_setup_ops`结构：
- en: '[PRE30]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Write the top half associated with the trigger. In 99% of cases, you just have
    to feed the timestamp associated with the capture:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写与触发器相关的上半部分。在99%的情况下，你只需要提供与捕获相关的时间戳：
- en: '[PRE31]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We then return a special value so the kernel knows it must schedule the bottom
    half, which will run in a threaded context.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们返回一个特殊值，以便内核知道它必须调度底半部分，这将在一个线程上下文中运行。
- en: 'Write the trigger bottom half, which will fetch data from each enabled channel
    and feed it into the buffer:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写触发器的底半部分，它将从每个启用的通道获取数据并将其推送到缓冲区：
- en: '[PRE32]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, in the probe function, you have to set up the buffer itself, prior
    to registering the device:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在探测函数中，你必须在注册设备之前设置缓冲区本身：
- en: '[PRE33]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The magic function here is `iio_triggered_buffer_setup()`. It will also give
    the `INDIO_BUFFER_TRIGGERED` capability to the device, meaning that a polled ring
    buffer is possible.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键函数是`iio_triggered_buffer_setup()`。它还会将`INDIO_BUFFER_TRIGGERED`能力授予设备，意味着可以使用轮询环形缓冲区。
- en: 'When a trigger is assigned (from user space) to the device, the driver has
    no way of knowing when the capture will be fired. This is the reason why, while
    continuous buffered capture is active, you should prevent (by returning an error)
    the driver from handling sysfs per-channel data capture (performed by the `read_raw()`
    hook) in order to avoid undetermined behavior, since both the trigger handler
    and the `read_raw()` hook will try to access the device at the same time. The
    function used to check whether buffered mode is currently enabled is `iio_buffer_enabled()`.
    The hook will look as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发器（来自用户空间）被分配给设备时，驱动程序无法知道捕获何时被触发。这就是为什么，在连续缓冲捕获活动时，你应该阻止（通过返回错误）驱动程序处理sysfs每通道的数据捕获（由`read_raw()`钩子执行），以避免不确定的行为，因为触发器处理程序和`read_raw()`钩子会同时尝试访问设备。用于检查当前是否启用了缓冲模式的函数是`iio_buffer_enabled()`。该钩子如下所示：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `iio_buffer_enabled()` function simply tests whether the device''s current
    mode corresponds to one of the IIO buffered modes. This function is defined as
    the following in `include/linux/iio/iio.h`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`iio_buffer_enabled()`函数只是测试设备当前模式是否与IIO缓冲区模式之一相对应。该函数在`include/linux/iio/iio.h`中定义如下：'
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now describe some important things used in the preceding code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述一下在前面的代码中使用的一些重要内容：
- en: '`iio_buffer_setup_ops` provides buffer setup functions to be called at a fixed
    step of the buffer configuration sequence (before/after enable/disable). If not
    specified, the default `iio_triggered_buffer_setup_ops` will be given to your
    device by the IIO core.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_setup_ops`提供了在缓冲区配置过程中固定步骤时调用的缓冲区设置函数（启用/禁用前后）。如果没有指定，IIO核心将为你的设备提供默认的`iio_triggered_buffer_setup_ops`。'
- en: '`sensor_iio_pollfunc` is the trigger''s top half. As with every top half, it
    runs in an interrupt context and must do as little processing as possible. In
    99% of cases, recording the timestamp associated with the capture will be enough.
    Once again, you can use the default IIO `iio_pollfunc_store_time()` function.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor_iio_pollfunc`是触发器的上半部分。像所有上半部分一样，它在中断上下文中运行，并且必须尽量减少处理工作。99%的情况下，记录与捕获相关的时间戳就足够了。你仍然可以使用默认的IIO函数`iio_pollfunc_store_time()`。'
- en: '`sensor_trigger_handler` is the bottom half, which runs in a kernel thread,
    allowing you to do any processing, even acquiring a mutex or sleeping. The heavy
    processing should take place here. Most of the job here consists of reading data
    from the device and storing this data in the internal buffer together with the
    timestamp that has been recorded in the top half and pushing these to the IIO
    device buffer.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor_trigger_handler` 是下半部分，运行在内核线程中，允许你进行任何处理，甚至获取互斥锁或休眠。重的处理工作应该在这里进行。这里的大部分工作包括从设备读取数据，并将这些数据与在上半部分记录的时间戳一起存储到内部缓冲区中，并将其推送到
    IIO 设备缓冲区。'
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: A triggered buffer involves a trigger. It tells the driver when to read the
    sample from the device and put it into the buffer. A triggered buffer is not mandatory
    for writing an IIO device driver. You can use a single-shot capture through sysfs
    too, by reading the raw attribute of the channel, which will only perform a single
    conversion (for the channel attribute being read). Buffer mode allows continuous
    conversions, thus capturing more than one channel in a single shot.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 触发缓冲区涉及一个触发器。它告诉驱动程序何时从设备读取样本并将其放入缓冲区。触发缓冲区并不是编写 IIO 设备驱动程序的必需条件。你也可以通过读取通道的原始属性来使用单次捕获，这将只执行单次转换（对于被读取的通道属性）。缓冲模式允许连续转换，从而在一次捕获中捕捉多个通道。
- en: Now that we are comfortable with all the in-kernel aspects of triggered buffers,
    let's introduce their setup in user space using the sysfs interface.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了触发缓冲区在内核中的所有方面，让我们介绍如何使用 sysfs 接口在用户空间进行设置。
- en: IIO trigger and sysfs (user space)
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIO 触发器和 sysfs（用户空间）
- en: 'At runtime, there are two sysfs directories from where triggers can be managed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，有两个 sysfs 目录可以管理触发器：
- en: '`/sys/bus/iio/devices/trigger<Y>/`: This directory is created once an IIO trigger
    is registered with the IIO core. In this path, `<Y>` corresponds to a trigger
    with an index. There is at least a `name` attribute in that directory, which is
    the trigger name that can be later used for association with a device.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/devices/trigger<Y>/`：一旦 IIO 触发器在 IIO 核心中注册，这个目录将会创建。在此路径中，`<Y>`
    对应于具有索引的触发器。该目录中至少有一个 `name` 属性，这是触发器的名称，之后可以用于与设备关联。'
- en: '`/sys/bus/iio/devices/iio:deviceX/trigger/*`: This directory will be automatically
    created if your device supports a triggered buffer. A trigger can be associated
    with our device by writing the trigger''s name in the `current_trigger` file in
    this directory.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/devices/iio:deviceX/trigger/*`：如果你的设备支持触发缓冲区，此目录将自动创建。通过在此目录中的
    `current_trigger` 文件中写入触发器的名称，可以将触发器与我们的设备关联。'
- en: Having enumerated the trigger-related sysfs directories, let's start by describing
    how the sysfs trigger interface works.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在枚举了与触发器相关的 sysfs 目录之后，让我们开始描述 sysfs 触发器接口是如何工作的。
- en: The sysfs trigger interface
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sysfs 触发器接口
- en: 'A sysfs trigger is enabled in the kernel with the `CONFIG_IIO_SYSFS_TRIGGER=y`
    config option, which will result in the `/sys/bus/iio/devices/iio_sysfs_trigger/`
    folder being automatically created, which can be used for sysfs trigger management.
    There will be two files in the directory, `add_trigger` and `remove_trigger`.
    Its driver is `drivers/iio/trigger/iio-trig-sysfs.c`. The following are descriptions
    of each of these attributes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中通过 `CONFIG_IIO_SYSFS_TRIGGER=y` 配置选项启用 sysfs 触发器，这将自动创建 `/sys/bus/iio/devices/iio_sysfs_trigger/`
    文件夹，该文件夹可用于 sysfs 触发器管理。该目录中将有两个文件，`add_trigger` 和 `remove_trigger`。其驱动程序是 `drivers/iio/trigger/iio-trig-sysfs.c`。以下是这些属性的描述：
- en: '`add_trigger`: Used to create a new sysfs trigger. You can create a new trigger
    by writing a positive value (which will be used as a trigger ID) into that file.
    It will create the new sysfs trigger, accessible at `/sys/bus/iio/devices/triggerX`,
    where `X` is the trigger number. For example, `echo 2 > add_trigger` will create
    a new sysfs trigger, accessible at `/sys/bus/iio/devices/trigger2`. An invalid
    argument message will be returned if a trigger with the supplied ID already exists
    in the system. The sysfs trigger name pattern is `sysfstrig{ID}`. The `echo 2
    > add_trigger` command will create the `/sys/bus/iio/devices/trigger2` trigger,
    whose name is `sysfstrig2`, and you can check it with `cat /sys/bus/iio/devices/trigger2/name`.
    Each sysfs trigger contains at list one file: `trigger_now`. Writing `1` into
    that file will instruct all devices with the corresponding trigger name in their
    `current_trigger` to start the capture and push data into their respective buffers.
    Each device buffer must have its size set and must be enabled (`echo 1 > /sys/bus/iio/devices/iio:deviceX/buffer/enable`).'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_trigger`：用于创建一个新的sysfs触发器。你可以通过将一个正值（将用作触发器ID）写入该文件来创建一个新的触发器。它会创建一个新的sysfs触发器，可以在`/sys/bus/iio/devices/triggerX`访问，其中`X`是触发器编号。例如，`echo
    2 > add_trigger`将创建一个新的sysfs触发器，可以在`/sys/bus/iio/devices/trigger2`访问。如果系统中已经存在一个带有提供ID的触发器，将返回无效参数的消息。sysfs触发器的名称模式为`sysfstrig{ID}`。`echo
    2 > add_trigger`命令将创建`/sys/bus/iio/devices/trigger2`触发器，其名称为`sysfstrig2`，你可以通过`cat
    /sys/bus/iio/devices/trigger2/name`来检查它。每个sysfs触发器至少包含一个文件：`trigger_now`。将`1`写入该文件将指示所有设备，若其`current_trigger`中有相应的触发器名称，则开始捕获并将数据推送到各自的缓冲区。每个设备的缓冲区必须设置大小并启用（`echo
    1 > /sys/bus/iio/devices/iio:deviceX/buffer/enable`）。'
- en: '`remove_trigger`: Used to remove a trigger. The following command will be sufficient
    to remove the previously created trigger:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_trigger`：用于删除触发器。以下命令足以删除之前创建的触发器：'
- en: '[PRE36]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, the value used in `add_trigger` while creating the trigger must
    be the same value you use when removing the trigger.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在创建触发器时使用的`add_trigger`中的值必须与删除触发器时使用的值相同。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You should note that the driver will only capture data when the associated trigger
    is triggered. Thus, when using the sysfs trigger, the data will only be captured
    at the time when `1` is written into the `trigger_now` attribute. Thus, to implement
    continuous data capture, you should run `echo 1 > trigger_now` as many times as
    you need a sample count, in a loop, for example. This is because a single call
    of `echo 1 > trigger_now` is equivalent to a single trigging and thus will perform
    only one capture, which will be pushed in the buffer. With interrupt-based triggers,
    data is captured and pushed in the buffer anytime an interrupt occurs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意，驱动程序只有在关联的触发器被触发时才会捕获数据。因此，使用sysfs触发器时，数据只会在`trigger_now`属性中写入`1`时被捕获。因此，要实现连续数据捕获，你应该在一个循环中根据需要的样本数多次运行`echo
    1 > trigger_now`，例如。因为单次执行`echo 1 > trigger_now`相当于一次触发，因此只会执行一次捕获，并将其推送到缓冲区。对于基于中断的触发器，数据会在每次发生中断时被捕获并推送到缓冲区。
- en: Now we are done with the trigger setup, this trigger must be assigned to a device
    so that it can trigger data capture on this device, as we will see in the next
    section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了触发器的设置，接下来必须将该触发器分配给设备，以便它可以在此设备上触发数据捕获，正如我们将在下一部分看到的那样。
- en: Tying a device to a trigger
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将设备与触发器绑定
- en: 'Associating a device with a given trigger consists of writing the name of the
    trigger to the `current_trigger` file available under the device''s trigger directory.
    For example, let''s say we need to tie a device with the trigger that has index
    `2`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将设备与给定触发器关联的过程是将触发器的名称写入设备触发器目录下的`current_trigger`文件。例如，假设我们需要将设备与索引为`2`的触发器绑定：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To detach the trigger from the device, you should write an empty string to
    the `current_trigger` file of the device trigger directory, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要从设备中分离触发器，应将空字符串写入设备触发器目录下的`current_trigger`文件，如下所示：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We will see later in the chapter (in the *Capturing data using a sysfs trigger*
    section) a practical example dealing with sysfs triggers for data capture.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面的部分（*使用sysfs触发器捕获数据*部分），我们将看到一个实际的例子，涉及用于数据捕获的sysfs触发器。
- en: Interrupt trigger interface
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断触发器接口
- en: 'Say we have the following sample:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下样本：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this sample, we declare our IRQ- (that the IIO interrupt trigger will register
    using `request_irq()`) based trigger as a platform device. It will result in the
    IRQ trigger standalone module (whose source file is `drivers/iio/trigger/iio-trig-interrupt.c`)
    being loaded. After the probing succeeds, there will be a directory corresponding
    to the trigger. IRQ trigger names have the form `irqtrigX`, where `X` corresponds
    to the IRQ we just passed. This name is the one you will see in `/proc/interrupt`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们声明我们的 IRQ-（使用 `request_irq()` 注册的 IIO 中断触发器）作为平台设备。它将导致 IRQ 触发器独立模块（源文件为
    `drivers/iio/trigger/iio-trig-interrupt.c`）被加载。探测成功后，将有一个与触发器相对应的目录。IRQ 触发器的名称采用
    `irqtrigX` 形式，其中 `X` 对应于刚刚传递的 IRQ。此名称是您将在 `/proc/interrupt` 中看到的名称：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we have done with other triggers, you just have to assign that trigger to
    your device, by writing its name into your device''s `current_trigger` file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对其他触发器所做的那样，您只需将该触发器分配给您的设备，将其名称写入设备的 `current_trigger` 文件中：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, every time the interrupt fires, device data will be captured.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当中断触发时，将捕获设备数据。
- en: 'The IRQ trigger driver is implemented in `drivers/iio/trigger/iio-trig-interrupt.c`.
    Since the driver requires a resource, we can use a device tree without any code
    change, with the only condition to respect the `compatible` property, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: IRQ 触发器驱动程序实现在 `drivers/iio/trigger/iio-trig-interrupt.c` 中。由于驱动程序需要资源，我们可以使用设备树进行配置，无需进行任何代码更改，唯一的条件是遵守
    `compatible` 属性，如下所示：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The example assumes the IRQ line is `GPIO#30`, which belongs to the `gpio4`
    GPIO controller node. This consists of using a GPIO as an interrupt source, so
    that whenever the GPIO changes to a given state, the interrupt is raised, thus
    triggering the capture.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设 IRQ 线为 `GPIO#30`，属于 `gpio4` GPIO 控制器节点。这包括使用 GPIO 作为中断源，因此每当 GPIO 变化到给定状态时，都会引发中断，从而触发捕获。
- en: The hrtimer trigger interface
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hrtimer 触发器接口
- en: '`hrtimer trigger` is implemented in `drivers/iio/trigger/iio-trig-hrtimer.c`
    and relies on the `configfs` filesystem (see `Documentation/iio/iio_configfs.txt`
    in kernel sources), which can be enabled via the `CONFIG_IIO_CONFIGFS` config
    option and mounted on our system (usually under the `/config` directory):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`hrtimer trigger` 实现在 `drivers/iio/trigger/iio-trig-hrtimer.c` 中，并依赖于 `configfs`
    文件系统（请参阅内核源中的 `Documentation/iio/iio_configfs.txt`），可以通过 `CONFIG_IIO_CONFIGFS`
    配置选项启用，并安装在我们的系统上（通常位于 `/config` 目录下）：'
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, loading the `iio-trig-hrtimer` module will create IIO groups accessible
    under `/config/iio`, allowing users to create `hrtimer` triggers under `/config/iio/triggers/hrtimer`.
    The following is an example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载 `iio-trig-hrtimer` 模块将创建可在 `/config/iio` 下访问的 IIO 组，允许用户在 `/config/iio/triggers/hrtimer`
    下创建 `hrtimer` 触发器。以下是一个示例：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each `hrtimer` trigger contains a single `sampling_frequency` attribute in the
    trigger directory. A full and working example is provided later in the chapter
    in the *Data capture using an hrtimer trigger* section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `hrtimer` 触发器在触发器目录中包含一个 `sampling_frequency` 属性。本章稍后的 *使用 hrtimer 触发器进行数据捕获*
    部分提供了一个完整且可工作的示例。
- en: IIO buffers
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IIO 缓冲区
- en: An IIO buffer offers continuous data capture, where more than one data channel
    can be read at once. The buffer is accessible from the user space via the `/dev/iio:device`
    character device node. From within the trigger handler, the function used to fill
    the buffer is `iio_push_to_buffers_with_timestamp()`. In order to allocate and
    set up a trigger buffer for a device, drivers must use `iio_triggered_buffer_setup()`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 缓冲区提供连续数据捕获，允许同时读取多个数据通道。该缓冲区可通过用户空间中的 `/dev/iio:device` 字符设备节点访问。在触发器处理程序内部，用于填充缓冲区的函数是
    `iio_push_to_buffers_with_timestamp()`。为了为设备分配和设置触发器缓冲区，驱动程序必须使用 `iio_triggered_buffer_setup()`。
- en: IIO buffer sysfs interface
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIO 缓冲区 sysfs 接口
- en: 'An IIO buffer has an associated attributes directory under `/sys/bus/iio/iio:deviceX/buffer/*`.
    The following are some of the existing attributes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: IIO 缓冲区有一个关联的属性目录，位于 `/sys/bus/iio/iio:deviceX/buffer/*` 下。以下是一些现有的属性：
- en: '`length`: The capacity of the buffer. It represents the total number of data
    samples that can be stored by the buffer. It is the number of scans contained
    by the buffer.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`: 缓冲区的容量。它代表可以由缓冲区存储的总数据样本数。它是缓冲区包含的扫描次数。'
- en: '`enable`: Activate the buffer capture and start the buffer capture up.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable`: 激活缓冲区捕获并启动缓冲区捕获。'
- en: '`watermark`: This attribute has been available since kernel version v4.2\.
    It is a positive number that specifies how many scan elements a blocking read
    should wait for. If using the `poll()` system call, for example, it will block
    until the watermark is reached. It makes sense only if the watermark is greater
    than the requested amount of reads. It does not affect non-blocking reads. A maximum
    delay guarantee can be achieved by blocking on `poll()` with a timeout and reading
    the available samples after the timeout expires.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watermark`：这个属性自内核版本 v4.2 起就已可用。它是一个正数，指定阻塞读取应等待多少个扫描元素。例如，使用 `poll()` 系统调用时，它会阻塞，直到达到水印值。只有当水印大于请求的读取数量时，这个参数才有意义。它不会影响非阻塞读取。通过在
    `poll()` 上阻塞并设置超时，你可以获得最大延迟保证，并在超时后读取可用的样本。'
- en: Now that we have enumerated and described the attributes present in the IIO
    buffer directory, let's discuss how to set up the IIO buffer.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经列举并描述了 IIO 缓冲区目录中存在的属性，接下来让我们讨论如何设置 IIO 缓冲区。
- en: IIO buffer setup
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IIO 缓冲区设置
- en: 'A channel whose data is to be read and pushed into the buffer is called a `/sys/bus/iio/iio:deviceX/scan_elements/*`
    directory, containing the following attributes:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 需要读取数据并将其推送到缓冲区的通道称为 `/sys/bus/iio/iio:deviceX/scan_elements/*` 目录，包含以下属性：
- en: '`*_en`: This is a suffix for the attribute name, used to enable the channel.
    If, and only if, the value of its attribute is non-zero, then a triggered capture
    will contain data samples for this channel. For example, `in_voltage0_en` and
    `in_voltage1_en` are attributes that enable `in_voltage0` and `in_voltage1`. Therefore,
    if the value of `in_voltage1_en` is non-zero, then the output of a triggered capture
    on the underlying IIO device will include the `in_voltage1` channel value.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*_en`：这是属性名的后缀，用于启用该通道。只有当其属性值非零时，触发的捕获才会包含该通道的数据样本。例如，`in_voltage0_en` 和
    `in_voltage1_en` 是启用 `in_voltage0` 和 `in_voltage1` 的属性。因此，如果 `in_voltage1_en`
    的值非零，那么触发捕获时底层 IIO 设备的输出将包括 `in_voltage1` 通道的值。'
- en: '`type`: Describes the scan element data storage within the buffer and hence
    the form in which it is read from user space. For example, `in_voltage0_type`
    is an example of a channel type. The format respects the following pattern: `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`.
    The following are the meanings of each field in the following format:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：描述了缓冲区内扫描元素数据的存储方式，以及它是如何从用户空间读取的。例如，`in_voltage0_type` 是一个通道类型的示例。格式遵循以下模式：`[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`。以下是每个字段的含义：'
- en: '`be` or `le` specifies the endianness (big or little).'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be` 或 `le` 指定字节序（大端或小端）。'
- en: '`s` or `u` specifies the sign, either signed (two''s complement) or unsigned.'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` 或 `u` 指定符号，表示有符号（补码）或无符号。'
- en: '`bits` is the number of valid data bits.'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits` 是有效数据位的数量。'
- en: '`storagebits` is the number of bits this channel occupies in the buffer. That
    said, a value may really be coded on 12 bits (`bits`) but occupies 16 bits (`storagebits`)
    in the buffer. You must, therefore, shift the data four times to the right to
    obtain the actual value. This parameter depends on the device, and you should
    refer to its datasheet.'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storagebits` 是该通道在缓冲区中占用的位数。也就是说，一个值可能实际是用 12 位（`bits`）编码的，但在缓冲区中占用 16 位（`storagebits`）。因此，你需要将数据右移四次以获得实际值。这个参数取决于设备，具体情况请参考设备的数据手册。'
- en: '`shift` represents the number of times you must shift the data value prior
    to masking out unused bits. This parameter is not always needed. If the number
    of valid bits is equal to the number of storage bits, the shift will be `0`. You
    can also find this parameter in the device datasheet.'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift` 表示在屏蔽掉未使用的位之前，数据值需要右移的次数。这个参数并非总是需要的。如果有效位数等于存储位数，则 shift 为 `0`。你也可以在设备的数据手册中找到这个参数。'
- en: The `repeat` element specifies the number of times `bits`/`storagebits` is repeated.
    The repeat value is omitted when the repeat element is `0` or `1`.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat` 元素指定 `bits`/`storagebits` 重复的次数。当 repeat 元素为 `0` 或 `1` 时，重复值会被省略。'
- en: 'The best way to explain this section is by providing an excerpt of the kernel
    docs, which you can find here: [https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html](https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html).
    Let''s consider a driver for a 3-axis accelerometer with 12-bit resolution where
    data is stored in two 8-bit (thus 16 bits) registers, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解释这个部分的方法是提供内核文档的摘录，你可以在这里找到：[https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html](https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html)。让我们考虑一个12位分辨率的三轴加速度计驱动程序，其中数据存储在两个8位（即16位）寄存器中，如下所示：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'According to the preceding description, each axis will have the following scan
    element:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述描述，每个轴将具有以下扫描元素：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should interpret this as being little-endian signed data, 16 bits in size,
    which needs to be shifted right by 4 bits before masking out the 12 valid bits
    of data.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将其理解为小端有符号数据，大小为16位，需要右移4位，然后掩码出12位有效数据。
- en: 'The element of `struct iio_chan_spec` responsible for determining how a channel''s
    value should be stored in a buffer is `scant_type`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct iio_chan_spec`中负责确定如何将通道值存储到缓冲区的元素是`scant_type`：'
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This structure absolutely matches `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`,
    which was the pattern described previously. Let''s have a look at each part of
    the structure:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构完全匹配`[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`，这是前面描述的模式。让我们看看结构的每个部分：
- en: '`sign` represents the sign of the data and matches `[s|u]` in the pattern.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sign`表示数据的符号，并与模式中的`[s|u]`匹配。'
- en: '`realbits` corresponds to `bits` in the pattern.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realbits`对应于模式中的`bits`。'
- en: '`storagebits` matches `storagebits` in the pattern.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storagebits`与模式中的`storagebits`匹配。'
- en: '`shift` corresponds to `shift` in the pattern, as well as `repeat`.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`对应于模式中的`shift`，以及`repeat`。'
- en: '`iio_indian` represents the endianness and matches `[be|le]` in the pattern.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_indian`表示字节序，并与模式中的`[be|le]`匹配。'
- en: 'At this point, we should be able to implement the IIO channel structure that
    corresponds to the type explained previously:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该能够实现与前面解释的类型对应的IIO通道结构：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Buffer and trigger support are the last concepts in our learning process of
    the IIO framework. Now that we are familiar with that, we can put everything together
    and summarize the knowledge we have acquired with a concrete, lite example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区和触发支持是我们学习IIO框架的最后一个概念。现在我们已经熟悉了这些，我们可以将所有内容整合在一起，并通过一个具体的简洁示例总结我们所学到的知识。
- en: Putting it all together
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将它们结合在一起
- en: 'Let''s have a closer look at the BMA220 digital triaxial acceleration sensor
    from Bosch. This is an SPI/I2C-compatible device, with 8-bit-sized registers,
    along with an on-chip motion-triggered interrupt controller, which senses tilt,
    motion, and shock vibration. Its datasheet is available here: [http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF](http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF).
    Its driver is available thanks to the `CONFIG_BMA200` kernel config option. Let''s
    walk through it.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看来自博世的BMA220数字三轴加速度传感器。这是一款兼容SPI/I2C的设备，具有8位大小的寄存器，并且配备了一个片上运动触发中断控制器，用于感应倾斜、运动和冲击振动。它的技术资料可以在这里找到：[http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF](http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF)。由于`CONFIG_BMA200`内核配置选项的支持，它的驱动程序也可以使用。我们一起来看一下。
- en: 'We first declare our channels using `struct iio_chan_spec`. If the triggered
    buffer will be used, then we need to fill in the `scan_index` and `scan_type`
    fields. The following code excerpt shows the declaration of our channels:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`struct iio_chan_spec`声明通道。如果将使用触发缓冲区，则需要填写`scan_index`和`scan_type`字段。以下代码片段展示了我们声明的通道：
- en: '[PRE49]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)` means there will be a `*_raw`
    sysfs entry (attribute) for each channel, and `.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)`
    says that there is only a `*_scale` sysfs entry for all channels of the same type:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)`表示每个通道将有一个`*_raw`的sysfs条目（属性），而`.info_mask_shared_by_type
    = BIT(IIO_CHAN_INFO_SCALE)`表示所有同类型的通道只有一个`*_scale`的sysfs条目：'
- en: '[PRE50]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Reading `in_accel_scale` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_SCALE`.
    Reading `in_accel_x_raw` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_RAW`.
    The real value is then `raw_value x scale`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 读取`in_accel_scale`时调用`read_raw()`钩子，并将掩码设置为`IIO_CHAN_INFO_SCALE`。读取`in_accel_x_raw`时调用`read_raw()`钩子，并将掩码设置为`IIO_CHAN_INFO_RAW`。然后，真实值为`raw_value
    x scale`。
- en: 'What `.scan_type` says is that each channel''s return value is signed, 8 bits
    in size (will occupy 8 bits in the buffer), but the useful payload only occupies
    6 bits, and data must be right-shifted twice prior to masking out unused bits.
    Any scan element type will look as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`.scan_type` 表示每个通道的返回值是带符号的，大小为 8 位（在缓冲区中占 8 位），但有效载荷只占 6 位，数据必须先右移两位，然后才能去除未使用的位。任何扫描元素类型将如下所示：'
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is our `pullfunc` (actually, it is the bottom half), which reads
    a sample from the device and pushes read values into the buffer (`iio_push_to_buffers_with_timestamp()`).
    Once done, we inform the core (`iio_trigger_notify_done()`):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的 `pullfunc`（实际上是底半部），它从设备读取一个样本并将读取的值推送到缓冲区（`iio_push_to_buffers_with_timestamp()`）。完成后，我们通知核心（`iio_trigger_notify_done()`）：
- en: '[PRE52]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is the read function. It is a hook called every time you read
    a sysfs entry of the device:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是读取功能。它是每次读取设备的 sysfs 条目时调用的钩子：
- en: '[PRE53]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you read a `*raw` sysfs file, the hook is called given `IIO_CHAN_INFO_RAW`
    in the `mask` parameter and the corresponding channel in the `*chan` parameter.
    `*val` and `*val2` are actually output parameters that must be set with the raw
    value (read from the device). Any read performed on the `*scale` sysfs file will
    call the hook with `IIO_CHAN_INFO_SCALE` in the `mask` parameter, and so on for
    each attribute mask.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取 `*raw` sysfs 文件时，钩子将根据 `mask` 参数中的 `IIO_CHAN_INFO_RAW` 和 `*chan` 参数中的相应通道进行调用。`*val`
    和 `*val2` 实际上是输出参数，必须用原始值（从设备读取）设置它们。对 `*scale` sysfs 文件的任何读取都会调用带有 `IIO_CHAN_INFO_SCALE`
    的钩子，其他属性掩码也类似。
- en: 'The same principle applies in the write function, used to write a value to
    the device. There is an 80% chance your driver does not require a `write` operation.
    In the following example, the `write` hook lets the user change the device''s
    scale, though other parameters can be changed, such as sampling frequency or digital-to-analog
    raw value:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原理适用于写入功能，用于向设备写入一个值。你的驱动程序有 80% 的机会不需要 `write` 操作。在下面的示例中，`write` 钩子允许用户更改设备的缩放比例，尽管其他参数也可以更改，如采样频率或数字到模拟的原始值：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This function is called whenever you write a value to the device, and only supports
    scaling value change. An example of usage in user space could be `echo $desired_scale
    > /sys/bus/iio/devices/iio:devices0/in_accel_scale`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向设备写入一个值时，将调用此功能，并且仅支持缩放值的变化。在用户空间中的一个使用示例可能是 `echo $desired_scale > /sys/bus/iio/devices/iio:devices0/in_accel_scale`。
- en: 'Now it comes time to fill a `struct iio_info` structure to be given to our
    `iio_device`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候填充一个 `struct iio_info` 结构体并将其传递给我们的 `iio_device` 了：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the `probe` function, we allocate and set up a `struct iio_dev iio` device.
    Memory for private data is reserved too:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `probe` 函数中，我们分配并设置一个 `struct iio_dev iio` 设备。私有数据的内存也会被保留：
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can enable this driver by means of the `CONFIG_BMA220` kernel option. That
    says, *this is available only from v4.8 in the kernel*. The closest device you
    can use on older kernel versions is BMA180, which you can enable using the `CONFIG_BMA180`
    option.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `CONFIG_BMA220` 内核选项启用此驱动程序。这意味着，*该功能仅在内核版本 v4.8 或更高版本中可用*。对于旧版本内核，你可以使用
    BMA180，它可以通过 `CONFIG_BMA180` 选项启用。
- en: Note
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To enable buffered capture in the IIO simple dummy driver, you must enable the
    `IIO_SIMPLE_DUMMY_BUFFER` kernel config option.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 IIO 简单虚拟驱动程序中启用缓冲捕获，必须启用 `IIO_SIMPLE_DUMMY_BUFFER` 内核配置选项。
- en: Now that we are familiar with IIO buffers, we will learn how to access the data
    coming from IIO devices and resulting from channel acquisitions.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 IIO 缓冲区，我们将学习如何访问来自 IIO 设备并由通道采集产生的数据。
- en: Accessing IIO data
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 IIO 数据
- en: 'You may have guessed, there are only two ways to access data with the IIO framework:
    one-shot capture through sysfs channels or continuous mode (triggered buffer)
    via an IIO character device.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，使用 IIO 框架访问数据的方式只有两种：通过 sysfs 通道进行单次捕获，或者通过 IIO 字符设备进行连续模式（触发的缓冲区）。
- en: Single-shot capture
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单次捕获
- en: 'Single-shot data capture is done through the sysfs interface. By reading the
    sysfs entry that corresponds to a channel, you''ll capture only the data specific
    to that channel. Say we have a temperature sensor with two channels: one for the
    ambient temperature and the other for the thermocouple temperature:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 单次数据捕获是通过 sysfs 接口完成的。通过读取与通道对应的 sysfs 条目，你只会捕获该通道的特定数据。假设我们有一个温度传感器，包含两个通道：一个用于环境温度，另一个用于热电偶温度：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The processed value is obtained by multiplying the scale by the raw value:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 处理后的值是通过将缩放值与原始值相乘得到的：
- en: '*Voltage value: 6646 * 0.305175781 = 2028.19824053*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*电压值：6646 * 0.305175781 = 2028.19824053*'
- en: The device datasheet says the process value is given in mV. In our case, it
    corresponds to *2.02819 V*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 设备数据表明，过程值以毫伏为单位。在我们的例子中，它对应于*2.02819 V*。
- en: Accessing the data buffer
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数据缓冲区
- en: To get a triggered acquisition working, trigger support must have been implemented
    in your driver. Then, to acquire data from within the user space, you must create
    a trigger, assign it, enable the ADC channels, set the dimension of the buffer,
    and enable it. The code for this is given in the following section.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使触发采集工作，驱动程序必须实现触发器支持。然后，要从用户空间采集数据，您必须创建触发器、分配触发器、启用ADC通道、设置缓冲区的尺寸并启用它。以下部分提供了这部分代码。
- en: Capturing data using a sysfs trigger
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sysfs触发器进行数据采集
- en: 'Data capture using sysfs triggers consists of sending a set of commands and
    a few sysfs files. Let''s go through what you should do to achieve that:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sysfs触发器进行数据采集需要发送一组命令和几个sysfs文件。让我们通过以下步骤来了解如何实现：
- en: '**Creating the trigger**: Before the trigger can be assigned to any device,
    it should be created:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建触发器**：在触发器分配给任何设备之前，应先创建触发器：'
- en: '[PRE58]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding command, `0` corresponds to the index we need to assign to
    the trigger. After this command, the trigger directory will be available under
    `/sys/bus/iio/devices/` as `trigger0`. The trigger's full patch will be `/sys/bus/iio/devices/trigger0`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，`0`对应于我们需要分配给触发器的索引。执行此命令后，触发器目录将在`/sys/bus/iio/devices/`下作为`trigger0`可用。触发器的完整路径将是`/sys/bus/iio/devices/trigger0`。
- en: '`0` as the index, the trigger will be named `sysfstrig0`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`0`作为索引，触发器将被命名为`sysfstrig0`：
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We could have used this command too:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个命令：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, if the value you have written does not correspond to an existing trigger
    name, nothing will happen. To make sure the trigger has been defined successfully,
    you can use the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您写入的值与现有触发器名称不对应，则不会发生任何事情。为了确保触发器已成功定义，您可以使用以下命令：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`available_scan_masks` in the driver:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 驱动程序中的`available_scan_masks`：
- en: '[PRE62]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Setting up the buffer size**: Here, you should set the number of sample sets
    that may be held by the buffer:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置缓冲区大小**：在这里，您应该设置缓冲区可以容纳的样本集数：'
- en: '[PRE63]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**Enabling the buffer**: This step consists of marking the buffer as being
    ready to receive pushed data:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用缓冲区**：此步骤包括将缓冲区标记为准备好接收推送数据：'
- en: '[PRE64]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: To stop the capture, we'll have to write `0` in the same file.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止采集，我们必须在同一文件中写入`0`。
- en: '**Firing the trigger**: Launch acquisition. This must be done as many times
    as data sample counts are needed in the buffer, in a loop, for example:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发触发器**：启动采集。这必须根据缓冲区所需的数据样本数在循环中执行多次，例如：'
- en: '[PRE65]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now that acquisition is done, you can do the following.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在采集已完成，您可以执行以下操作。
- en: 'Disable the buffer:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用缓冲区：
- en: '[PRE66]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Detach the trigger:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离触发器：
- en: '[PRE67]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Dump the contents of our IIO character device:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转储我们的IIO字符设备内容：
- en: '[PRE68]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have learned how to use sysfs triggers, it will be easier to deal
    with hrtimer-based ones as they kind of use the same theoretical principle.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了如何使用sysfs触发器，处理基于hrtimer的触发器会更容易一些，因为它们在理论原理上使用了相同的方法。
- en: Data capture using an hrtimer trigger
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用hrtimer触发器进行数据采集
- en: 'hrtimers are high-resolution kernel timers with up to nanosecond granularity
    when the hardware allows it. As with sysfs-based triggers, data capture using
    hrtimer triggers requires a few commands for their setup. These commands can be
    split into the following steps:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: hrtimer是具有纳秒级粒度的高分辨率内核定时器，当硬件允许时。与基于sysfs的触发器一样，使用hrtimer触发器进行数据采集需要几个命令来进行设置。这些命令可以分为以下几个步骤：
- en: 'Create the hrtimer-based trigger:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建基于hrtimer的触发器：
- en: '[PRE69]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding command will create a trigger named `trigger0`. This name will
    be used to assign this trigger to a device.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`trigger0`的触发器。这个名称将用于将触发器分配给设备。
- en: 'Define the sampling frequency:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义采样频率：
- en: '[PRE70]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: There is no configurable attribute in the `config` directory for the `hrtimer`
    trigger type. It introduces the `sampling_frequency` attribute to trigger directory.
    That attribute sets the polling frequency in Hz, with mHz precision. In the preceding
    example, we have defined a polling at 50 Hz (every 20 ms).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`config`目录中没有`hrtimer`触发器类型的可配置属性。它引入了`samping_frequency`属性到触发器目录。该属性设置以赫兹为单位的轮询频率，精度为毫赫兹。在前面的示例中，我们定义了50
    Hz的轮询（每20毫秒一次）。
- en: 'Link the trigger with the IIO device:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将触发器与IIO设备链接：
- en: '[PRE71]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Choose on which channels data must be captured and pushed into the buffer:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要在哪些通道上捕获数据并推送到缓冲区：
- en: '[PRE72]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Start the hrtimer capture, which will perform periodic data capture at the
    frequency we defined earlier and on channels that have been enabled previously:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动hrtimer捕获，它将在我们之前定义的频率下，并在先前启用的通道上执行周期性数据捕获：
- en: '[PRE73]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Finally, data can be dumped using `cat /dev/iio\:device0 | xxd –`. Because the
    trigger is an hrtimer, data will be captured and pushed at every hrtimer period
    interval.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以使用`cat /dev/iio\:device0 | xxd –`来转储数据。由于触发器是hrtimer，数据将在每个hrtimer周期间隔捕获并推送。
- en: 'To disable this periodic capture, the command to use is the following:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要禁用此周期性捕获，使用的命令如下：
- en: '**echo 0 > /sys/bus/iio/devices/iio:device0/buffer/enable**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**echo 0 > /sys/bus/iio/devices/iio:device0/buffer/enable**'
- en: 'Then, to remove this hrtimer trigger, the following command must be used:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要删除此hrtimer触发器，必须使用以下命令：
- en: '**rmdir /sys/kernel/config/iio/triggers/hrtimer/trigger0**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**rmdir /sys/kernel/config/iio/triggers/hrtimer/trigger0**'
- en: We can notice how easy it is to set up either a simple sysfs trigger or an hrtimer-based
    one. They both consist of a few commands to set up and start the capture. However,
    captured data would be meaningless or even dangerously misleading if not interpreted
    as it should, which we'll discuss in the next section.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，设置一个简单的sysfs触发器或基于hrtimer的触发器是多么容易。它们都只需要几个命令来设置并启动捕获。然而，如果没有按正确的方式解读，捕获的数据将毫无意义，甚至可能误导，这是我们将在下一节中讨论的内容。
- en: Interpreting the data
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解读数据
- en: 'Now that everything has been set up, we can dump the data using the following
    command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切已设置好，我们可以使用以下命令转储数据：
- en: '[PRE74]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding command will dump raw data that would need more processing to
    obtain the real data. In order to be able to understand the data output and process
    it, we need to look at the channel type, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将转储原始数据，这些数据需要进一步处理才能获得真实数据。为了能够理解数据输出并处理它，我们需要查看通道类型，如下所示：
- en: '[PRE75]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In the preceding, `be:s14/16>>2` means big-endian (`be:`) signed data (`s`)
    stored on 16 bits but whose real number of bits is 14\. Moreover, it also means
    that the data must be shifted to the right two times (`>>2`) to obtain the real
    value. This means, for example, to obtain the voltage value in the first sample
    (`0x188`), this value must be right-shifted twice in order to mask unused bits:
    *0 x 188 >> 2 = 0 x 62 = 98*. Now, the real value is *98 * 250 = 24500 = 24.5
    V*. If there were an offset attribute, the real value would be `(raw + offset)
    * scale`.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述内容中，`be:s14/16>>2`表示大端（`be:`）有符号数据（`s`），存储在16位中，但其实际位数为14。此外，这也意味着数据必须右移两次（`>>2`）以获得实际值。例如，要获得第一个样本的电压值（`0x188`），该值必须右移两次以屏蔽未使用的位：*0x188
    >> 2 = 0x62 = 98*。现在，实际值是*98 * 250 = 24500 = 24.5 V*。如果有一个偏移量属性，实际值将是`(raw + offset)
    * scale`。
- en: We are now familiar with IIO data access (from user space) and we are also done
    with the IIO producer interface in the kernel. It is not just the user space that
    can consume data from the IIO channel. There is an in-kernel interface as well,
    which we will discuss in the next section.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经熟悉了IIO数据访问（来自用户空间），并且也完成了内核中的IIO生产者接口。不仅仅是用户空间可以从IIO通道中消费数据，内核中也有一个接口，我们将在下一节中讨论。
- en: Dealing with the in-kernel IIO consumer interface
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理内核中的IIO消费者接口
- en: So far, we have dealt with the user-space consumer interface since data was
    consumed in user space. There are situations where a driver will require a dedicated
    IIO channel. An example is a battery charger that needs to measure the battery
    voltage as well. This measurement can be achieved using a dedicated IIO channel.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经处理了用户空间消费者接口，因为数据是在用户空间中消费的。某些情况下，驱动程序需要一个专用的IIO通道。例如，一个需要测量电池电压的电池充电器。这种测量可以通过使用专用的IIO通道来实现。
- en: 'IIO channel attribution is done in the device tree. From the producer side,
    only one thing must be done: specifying the `#io-channel-cells` property according
    to the number of channels of the IIO device. Typically, it is `0` for nodes with
    a single IIO output and `1` for nodes with multiple IIO outputs. The following
    is an example:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: IIO通道的分配是在设备树中完成的。从生产者方面来看，只需要做一件事：根据IIO设备的通道数量指定`#io-channel-cells`属性。通常，对于单个IIO输出的节点，它为`0`；对于多个IIO输出的节点，它为`1`。以下是一个示例：
- en: '[PRE76]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'On the consumer side, there are a few properties to provide. These are the
    following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者端，需要提供一些属性。以下是需要的属性：
- en: '`io-channels`: This is the only mandatory property. It represents the list
    of phandle (reference or pointer to a device tree node) and IIO specifier pairs,
    one pair for each IIO input to the device. Do note that if the IIO provider''s
    `#io-channel-cells` property is `0`, then only the phandle portion should be specified
    when referring to it in the consumer node. This is the case for single-channel
    IIO devices, for example, a temperature sensor. Otherwise, both the phandle and
    the channel index must be specified.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io-channels`：这是唯一的必需属性。它表示 phandle（设备树节点的引用或指针）和 IIO 指定符对的列表，每对表示设备的一个 IIO
    输入。请注意，如果 IIO 提供者的`#io-channel-cells`属性为`0`，则在消费者节点中引用它时应仅指定 phandle 部分。这适用于单通道
    IIO 设备，例如温度传感器。否则，必须同时指定 phandle 和通道索引。'
- en: '`io-channel-names`: This is an optional but recommended property that is a
    list of IIO channel name strings. These names must be sorted in the same order
    as their corresponding channels, which are enumerated in the `io-channels` property.
    Consumer drivers should use these names to match IIO input names with IIO specifiers.
    This eases the channel identification in the driver.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io-channel-names`：这是一个可选但推荐的属性，它是一个 IIO 通道名称字符串的列表。这些名称必须与其对应通道的顺序相同，这些通道在`io-channels`属性中枚举。消费者驱动程序应该使用这些名称将
    IIO 输入名称与 IIO 指定符匹配。这可以简化驱动程序中的通道识别。'
- en: 'Take the following example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE77]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The preceding node describes a device with two IIO resources, named `vcc` and
    `vdd`, respectively. The `vcc` channel originates from the `&adc` device output
    `1`, while the `vdd` channel comes from the `&ref` device output `0`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的节点描述了一个具有两个 IIO 资源的设备，分别命名为`vcc`和`vdd`。`vcc`通道来自于`&adc`设备的输出`1`，而`vdd`通道则来自于`&ref`设备的输出`0`。
- en: 'Another example consuming several channels of the same ADC is the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用同一 ADC 的多个通道的示例如下：
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Now that we are familiar with IIO binding and channel hogging, we can see how
    to play with those channels using the kernel IIO consumer API.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 IIO 绑定和通道占用的概念，可以看到如何使用内核 IIO 消费者 API 来操作这些通道。
- en: Consumer kernel API
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者内核 API
- en: 'The kernel IIO consumer interface relies on a few functions and data structures.
    The following is the main API:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 内核 IIO 消费者接口依赖于一些函数和数据结构。以下是主要的 API：
- en: '[PRE79]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following are descriptions of each API:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个 API 的描述：
- en: '`devm_iio_channel_get()`: Used to get a single channel. `dev` is the pointer
    to the consumer device, and `consumer_channel` is the channel name as specified
    in the `io-channel-names` property. On success, it returns a pointer to a valid
    IIO channel, or a pointer to a negative error number if it is not able to get
    the IIO channel.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devm_iio_channel_get()`：用于获取单个通道。`dev`是消费者设备的指针，`consumer_channel`是`io-channel-names`属性中指定的通道名称。成功时，它返回一个指向有效
    IIO 通道的指针；如果无法获取 IIO 通道，则返回指向负错误号的指针。'
- en: '`devm_iio_channel_get_all()`: Used to look up IIO channels. It returns a pointer
    to a negative error number if it is not able to get the IIO channel; otherwise,
    it returns an array of `iio_channel` structures terminated with 0 null `iio_dev`
    pointer. Say we have the following consumer node:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devm_iio_channel_get_all()`：用于查找 IIO 通道。如果无法获取 IIO 通道，它返回指向负错误号的指针；否则，它返回一个以空`iio_dev`指针终止的`iio_channel`结构体数组。假设我们有以下消费者节点：'
- en: '[PRE80]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The following code is an example of using `devm_iio_channel_get_all()` to get
    the IIO channels. This code also shows how to check for the last valid channel
    (the one with the null `iio_dev` pointer):'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例演示了如何使用`devm_iio_channel_get_all()`来获取 IIO 通道。该代码还展示了如何检查最后一个有效通道（即指针为空的`iio_dev`）：
- en: '[PRE81]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`iio_get_channel_type()`: Returns the type of a channel, such as `IIO_VOLTAGE`
    or `IIO_TEMP`. This function fills `enum iio_chan_type` of the channel in the
    `type` output parameter. On error, the function returns a negative error number;
    otherwise, it returns `0`.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_get_channel_type()`：返回通道的类型，例如 `IIO_VOLTAGE` 或 `IIO_TEMP`。此函数将通道的`enum
    iio_chan_type`填充到`type`输出参数中。如果出错，函数返回负错误号；否则，返回`0`。'
- en: '`iio_read_channel_processed()`: Reads the channel processed value in the correct
    unit, for example, in micro-volts for voltage and milli-degrees for temperature.
    `val` is the processed value read back. This function returns `0` on success or
    a negative value otherwise.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_read_channel_processed()`：读取通道的处理值，单位正确，例如电压为微伏，温度为毫度。`val`是读取的处理值。此函数在成功时返回`0`，否则返回负值。'
- en: '`iio_read_channel_raw()`: Used to read a raw value from the channel. In this
    case, the consumer may need scale (`iio_read_channel_scale()`) and offset (`iio_read_channel_offset()`)
    in order to compute the processed value. `val` is the raw value read back.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding APIs, `struct iio_channel` represents an IIO channel from
    the consumer point of view. It has the following declaration:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the preceding code, `iio_dev` is the IIO device to which the channel belongs,
    and `channel` is the underlying channel spec as seen by the provider.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Writing user-space IIO applications
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the long journey through the kernel-side implementation, it might be interesting
    to have a look at the other side, the user space. IIO support in user space can
    be handled through sysfs or using **libiio**, a library that has been specially
    developed for this purpose and follows the kernel-side evolutions. This library
    abstracts the hardware's low-level details and provides an easy and comprehensive
    programming interface that can also be used for complex projects.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be using version 0.21 of the library, whose documentation
    can be found here: [https://analogdevicesinc.github.io/libiio/v0.21/libiio/index.html](https://analogdevicesinc.github.io/libiio/v0.21/libiio/index.html).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '`libiio` can run on the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: A target, that is, the embedded system running Linux that includes IIO drivers
    for devices that are physically connected to the system, such as ADCs and DACs.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A remote computer connected to the embedded system through a network, USB, or
    serial connection. This remote computer may be a PC running a Linux distribution,
    Windows, macOS, or OpenBSD/NetBSD. This remote PC communicates with the embedded
    system via the `iiod` server, which is a daemon running on the target.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the architecture:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – libiio overview'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_15_002.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – libiio overview
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '`libiio` is built around five concepts, each of which corresponds to a data
    structure, altogether making almost all the API. These concepts are the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '**The backend**: This represents the connectivity (or the communication channel)
    between your application and the target on which the IIO devices to interact with
    are connected. This backend (thus connectivity) can be via USB, network, serial,
    or local. Independently from the hardware connectivity available, supported backends
    are library compile-time defined.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The context**: A context is a library instance that represents a collection
    of IIO devices, which in most cases correspond to a global view of the IIO devices
    on a running target. In this way, a context gathers all the IIO devices the target
    contains, as well as their channels and their attributes. For instance, when looking
    for an IIO device, code must create a context and request the target IIO device
    from this context.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because applications may run remotely to the target board, the context will
    need a communication channel with that target. This is where the backend intervenes.
    Therefore, a context must be backed by a backend, which represents the connectivity
    between the target and the machine running the application. However, remotely
    running applications are not always aware of the target environment; thus, the
    library allows look up for available backends, allowing, among other things, dynamic
    behavior. This lookup is referred to as IIO context scanning. That said, applications
    may not bother with scanning if running locally to the target.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用可能远程运行在目标板上，上下文将需要与目标建立通信通道。这时后端将发挥作用。因此，一个上下文必须由后端支持，后端代表了目标和运行应用的机器之间的连接。然而，远程运行的应用并不总是能够了解目标环境；因此，库允许查找可用的后端，从而支持包括动态行为在内的多种功能。这一查找过程被称为IIO上下文扫描。也就是说，如果应用本地运行在目标上，可能不需要扫描。
- en: A context is represented with an instance of `struct iio_context`. A context
    object may contain zero or more devices. However, a device object is associated
    with only one context.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一个上下文通过`struct iio_context`的实例表示。一个上下文对象可以包含零个或多个设备。然而，一个设备对象只与一个上下文关联。
- en: '`struct iio_device`, which is the user-space (`libiio` actually) counterpart
    of the in-kernel `struct iio_dev`. A device object may contain zero or more channels,
    while a channel is associated with only one device.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct iio_device`，是用户空间（实际上是`libiio`）对应内核中的`struct iio_dev`。一个设备对象可以包含零个或多个通道，而一个通道只与一个设备关联。'
- en: '`struct iio_buffer`. A device may be associated with one buffer object, and
    a buffer is associated with only one device.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct iio_buffer`。一个设备可以与一个缓冲区对象关联，而一个缓冲区只与一个设备关联。'
- en: '`struct iio_channel`. A device may contain zero or more channels, and a channel
    is associated with only one device.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct iio_channel`。一个设备可以包含零个或多个通道，而一个通道只与一个设备关联。'
- en: 'After becoming familiar with these concepts, we can split IIO application development
    into the following steps:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉这些概念之后，我们可以将IIO应用开发分为以下几个步骤：
- en: Creating a context, after having (optionally) scanned for available backends
    to create this context with.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个上下文，在（可选地）扫描可用的后端以创建该上下文之后。
- en: Iterating over all devices, or looking for and picking the one of interest.
    Eventually getting/setting the device parameters via its attributes.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有设备，或寻找并选择感兴趣的设备，最终通过其属性获取/设置设备参数。
- en: Walking through the device channels and enabling channels of interest (or disabling
    the ones we are not interested in). Eventually getting/setting the channel parameters
    via their attributes.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历设备通道并启用感兴趣的通道（或禁用我们不感兴趣的通道）。最终通过其属性获取/设置通道参数。
- en: If a device needs a trigger, then associating a trigger with the given device.
    This trigger must have been created before creating the context.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果设备需要触发器，则将触发器与该设备关联。该触发器必须在创建上下文之前创建。
- en: Creating a buffer and associating this buffer with the device, and then starting
    streaming.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建缓冲区并将该缓冲区与设备关联，然后开始流式传输。
- en: Starting the capture and reading the data.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动捕获并读取数据。
- en: Scanning and creating an IIO context
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描并创建IIO上下文
- en: When creating a context, the library will identify the IIO devices (including
    triggers) that can be used and identify the channels for each device; then, it
    will identify all device- and channel-specific attributes and also identify attributes
    shared by all channels; finally, the library will create a context where all those
    entities are placed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 创建上下文时，库会识别可用的IIO设备（包括触发器），并为每个设备识别其通道；然后，它会识别所有设备和通道特定的属性，并识别所有通道共享的属性；最后，库会创建一个上下文，将所有这些实体放入其中。
- en: 'A context can be created using one of the following APIs:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下API之一创建上下文：
- en: '[PRE83]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Each of these functions returns a valid context object on success and `NULL`
    otherwise, with `errno` set appropriately. That said, while they all return the
    same values, their arguments may vary, as described in the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些函数在成功时返回有效的上下文对象，否则返回`NULL`，并且`errno`会适当设置。也就是说，尽管它们返回相同的值，它们的参数可能有所不同，如下所述：
- en: '`iio_create_local_context()`: Used to create a local context:'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_create_local_context()`：用于创建本地上下文：'
- en: '[PRE84]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that the local backend interfaces the Linux kernel through the sysfs virtual
    filesystem.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本地后端通过sysfs虚拟文件系统与Linux内核接口。
- en: '`iio_create_network_context()`: Creates a network context. It takes as a parameter
    a string representing the IPv4 or IPv6 network address of the remote target:'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_create_network_context()`：创建一个网络上下文。它的参数是一个字符串，表示远程目标的 IPv4 或 IPv6 网络地址：'
- en: '[PRE85]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'USB context can be created using an URI-based API, `iio_create_context_from_uri()`.
    The argument is a string identifying the USB device using the following pattern
    – `usb:[device:port:instance]`:'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用基于 URI 的 API `iio_create_context_from_uri()` 创建 USB 上下文。参数是一个字符串，用于标识 USB
    设备，使用以下模式：`usb:[device:port:instance]`：
- en: '[PRE86]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'A serial context, like a USB context, uses a URI-based API. However, its URI
    must match the following pattern – `serial:[port][,baud][,config]`:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串口上下文与 USB 上下文类似，使用基于 URI 的 API。但是，它的 URI 必须匹配以下模式：`serial:[port][,baud][,config]`：
- en: '[PRE87]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`iio_create_context_from_uri()` is a URI-based API, taking as a parameter a
    valid URI (starting with the backend to use). For local context, the URI must
    be `"local:"`. For a URI-based network context, the URI pattern must match `"ip:<ipaddr>"`,
    where `<ipaddr>` is the IPv4 or IPv6 of the remote target. More information on
    URI-based contexts can be found here: https://analogdevicesinc.github.io/libiio/v0.21/libiio/group__Context.html#gafdcee40508700fa395370b6c636e16fe.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_create_context_from_uri()` 是一个基于 URI 的 API，参数为一个有效的 URI（以要使用的后端开头）。对于本地上下文，URI
    必须为 `"local:"`。对于基于 URI 的网络上下文，URI 模式必须匹配 `"ip:<ipaddr>"`，其中 `<ipaddr>` 是远程目标的
    IPv4 或 IPv6 地址。有关基于 URI 的上下文的更多信息，请参见：[https://analogdevicesinc.github.io/libiio/v0.21/libiio/group__Context.html#gafdcee40508700fa395370b6c636e16fe](https://analogdevicesinc.github.io/libiio/v0.21/libiio/group__Context.html#gafdcee40508700fa395370b6c636e16fe)。'
- en: '`iio_context_clone()` duplicates the context given as a parameter and returns
    the new clone. This function is not supported on `usb:` contexts, since `libusb`
    can only claim the interface once.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_context_clone()` 复制给定的上下文，并返回新的克隆对象。此函数不支持 `usb:` 上下文，因为 `libusb` 只能一次性声明接口。'
- en: 'Before creating a context, the user might be interested in scanning the available
    contexts (that is, looking for available backends). To find what IIO contexts
    are available, the user code must do the following:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建上下文之前，用户可能希望扫描可用的上下文（即查找可用的后端）。为了找出哪些 IIO 上下文是可用的，用户的代码必须执行以下操作：
- en: Invoke `iio_create_scan_context()` to create an instance of `iio_scan_context
    object`. The first argument to this function is a string that is used as a filter
    (`usb:`, `ip:`, `local:`, `serial:`, or a mix, such as `usb:ip`, where the default
    (`NULL`) means any backend that is compiled in).
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `iio_create_scan_context()` 创建一个 `iio_scan_context` 对象的实例。此函数的第一个参数是一个字符串，用作过滤器（`usb:`、`ip:`、`local:`、`serial:`，或者它们的混合，例如
    `usb:ip`，其中默认值（`NULL`）表示任何已编译的后端）。
- en: Call `iio_scan_context_get_info_list()` given the previous `iio_scan_context`
    object as parameter. This will return an array `iio_context_info` object from
    the `iio_scan_context` object. Each `iio_context_info` object can be examined
    with `iio_context_info_get_description()` and `iio_context_info_get_uri()` to
    determine which URI you want to attach to.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `iio_scan_context_get_info_list()`，将先前的 `iio_scan_context` 对象作为参数传递。此方法将返回一个
    `iio_context_info` 对象数组，这些对象来自 `iio_scan_context` 对象。可以使用 `iio_context_info_get_description()`
    和 `iio_context_info_get_uri()` 来检查每个 `iio_context_info` 对象，以确定要附加到哪个 URI。
- en: Once done, the `info` object array and the `scan` object must be released with
    `iio_context_info_list_free()` and `iio_scan_context_destroy()`, respectively.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成后，必须分别使用 `iio_context_info_list_free()` 和 `iio_scan_context_destroy()` 释放
    `info` 对象数组和 `scan` 对象。
- en: 'The following is a demonstration of scanning available contexts and creating
    one:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是扫描可用上下文并创建一个上下文的演示：
- en: '[PRE88]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the preceding code, if the `CHECK_REMOTE` macro is defined, the code will
    first scan for available contexts (that is, backends) by filtering USB and network
    ones. The code first looks for the USB context before looking for a network context.
    If none is available, it falls back to a local context.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果定义了 `CHECK_REMOTE` 宏，代码将首先通过过滤 USB 和网络上下文来扫描可用的上下文（即后端）。代码首先查找 USB
    上下文，然后再查找网络上下文。如果没有找到，它将回退到本地上下文。
- en: 'In addition, you can get some context-related information using the following
    APIs:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用以下 API 获取一些与上下文相关的信息：
- en: '[PRE89]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In the preceding APIs, `iio_context_get_version()` returns the version of the
    backend in use into `major`, `minor`, and `git_tag` output arguments, and `iio_context_get_name()`
    returns a pointer to a static `NULL`-terminated string corresponding to the backend
    name, which can be `local`, `xml`, or `network` when the context has been created
    with the local, XML, and network backends, respectively.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述API中，`iio_context_get_version()`将返回正在使用的后端版本，输出参数包括`major`、`minor`和`git_tag`，`iio_context_get_name()`返回一个指向静态`NULL`终止字符串的指针，该字符串对应后端名称，当上下文是通过本地、XML和网络后端创建时，名称分别为`local`、`xml`或`network`。
- en: 'The following is a demonstration:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示：
- en: '[PRE90]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now that the context has been created, and we are able to read its information,
    the user might be interested in walking through it, that is, navigating the entities
    this context is made of, for instance, getting the number of IIO devices or getting
    an instance of a given device.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上下文已经创建，并且我们能够读取其信息，用户可能会有兴趣遍历上下文，即导航该上下文包含的实体，例如获取IIO设备的数量或获取给定设备的实例。
- en: Note
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A context is a punctual and fixed view of IIO entities on the target. For instance,
    if a user creates an IIO trigger device after having created the context, this
    trigger device won't be accessible from this context. Because there is no context
    synchronization API, the proper way to do things would be to destroy and re-create
    things or to create the needed dynamic IIO elements at the beginning of the program
    before creating the context.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文是目标上IIO实体的即时且固定的视图。例如，如果用户在创建上下文之后创建了一个IIO触发设备，则无法从该上下文访问该触发设备。由于没有上下文同步API，因此正确的做法是销毁并重新创建对象，或者在程序开始时创建所需的动态IIO元素，再创建上下文。
- en: Walking through and managing IIO devices
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历并管理IIO设备
- en: 'The following are APIs to navigate through the devices in an IIO context:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于在IIO上下文中遍历设备的API：
- en: '[PRE91]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: From a context, `iio_context_get_devices_count()` returns the number of IIO
    devices in this context.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 从上下文中，`iio_context_get_devices_count()`返回该上下文中IIO设备的数量。
- en: '`iio_context_get_device()` returns a handle for an IIO device specified by
    its index (or ID). This ID corresponds to `<X>` in `/sys/bus/iio/devices/iio:device<X>/`.
    For example, the ID of the `/sys/bus/iio/devices/iio:device1` device is `1`. If
    the index is invalid, `NULL` is returned. Alternatively, given a device object,
    its ID can be retrieved with `iio_device_get_id()`.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`iio_context_get_device()`返回指定IIO设备的句柄，该设备通过其索引（或ID）来指定。该ID对应`/sys/bus/iio/devices/iio:device<X>/`中的`<X>`。例如，`/sys/bus/iio/devices/iio:device1`设备的ID为`1`。如果索引无效，则返回`NULL`。或者，给定设备对象，可以通过`iio_device_get_id()`获取其ID。'
- en: '`iio_context_find_device()` looks for an IIO device by its name. This name
    must correspond to the name specified in `iio_indev->name` specified in the driver.
    You can obtain this name either by using a dedicated `iio_device_get_name()` API
    or by reading the `name` attribute in this device''s sysfs directory:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`iio_context_find_device()`通过名称查找IIO设备。此名称必须与驱动程序中指定的`iio_indev->name`对应。你可以通过使用专门的`iio_device_get_name()`API或读取该设备的sysfs目录中的`name`属性来获取此名称：'
- en: '[PRE92]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following is an example of going through all devices and printing their
    names and IDs:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是遍历所有设备并打印其名称和ID的示例：
- en: '[PRE93]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The preceding code example iterates over IIO devices present in the context
    (a local context) and prints their names and IDs.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例遍历上下文中存在的IIO设备（本地上下文），并打印它们的名称和ID。
- en: Walking through and managing IIO channels
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历并管理IIO通道
- en: 'The main channel management APIs are the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的通道管理API如下：
- en: '[PRE94]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can get the number of available channels from an `iio_device` object thanks
    to `iio_device_get_channels_count()`. Then, each `iio_channel` object can be accessed
    with `iio_device_get_channel()`, specifying the index of this channel. For example,
    on a three-axis (*x*, *y*, *z*) accelerometer, `iio_device_get_channel(iio_device,
    0)` will correspond to getting channel 0, that is, `accel_x`. On an eight-channel
    ADC converter, `iio_device_get_channel(iio_device, 0)` will correspond to getting
    channel 0, that is, `voltage0`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`iio_device_get_channels_count()`从`iio_device`对象中获取可用通道的数量。然后，可以通过`iio_device_get_channel()`访问每个`iio_channel`对象，指定该通道的索引。例如，在一个三轴(*x*,
    *y*, *z*)加速度计上，`iio_device_get_channel(iio_device, 0)`将对应获取通道0，即`accel_x`。在一个八通道的ADC转换器上，`iio_device_get_channel(iio_device,
    0)`将对应获取通道0，即`voltage0`。
- en: 'Alternatively, it is possible to look up a channel by its name using `iio_device_find_channel()`,
    which expects in arguments the channel name and a Boolean, which tells you whether
    the channel is an output or not. If you remember, in the *Channel attribute naming
    convention* section, we saw that attribute names respect the following pattern:
    `{direction}_{type}{index}_{modifier}_{info_mask}`. The subset in this pattern
    that needs to be used with `iio_device_find_channel()` is `{type}{index}_{modifier}`.
    Then, depending on the value of the Boolean parameter, the final name will be
    obtained by adding either `in_` or `out_` as a prefix. For instance, to obtain
    channel `X` of the accelerometer, we would use `iio_device_find_channel(iio_device,
    "accel_x", 0)`. For the first channel of the analog-to-digital converter, we would
    use `iio_device_find_channel(iio_device, "voltage0", 0)`.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`iio_device_find_channel()`按名称查找通道，该函数期望的参数是通道名称和一个布尔值，用于指示该通道是否为输出。如果你记得，在*通道属性命名约定*部分中，我们看到属性名称遵循以下模式：`{direction}_{type}{index}_{modifier}_{info_mask}`。在此模式中，需要与`iio_device_find_channel()`一起使用的子集是`{type}{index}_{modifier}`。然后，取决于布尔参数的值，最终名称将通过添加`in_`或`out_`作为前缀来获得。例如，要获取加速度计的`X`通道，我们将使用`iio_device_find_channel(iio_device,
    "accel_x", 0)`。对于模拟-数字转换器的第一个通道，我们将使用`iio_device_find_channel(iio_device, "voltage0",
    0)`。
- en: 'The following is an example of going through all devices and all channels of
    each device:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是遍历所有设备及每个设备的所有通道的示例：
- en: '[PRE95]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The preceding code creates a local context and walks through all the devices
    in this context. Then, for each device, it iterates over channels and prints their
    name.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建一个本地上下文，并遍历该上下文中的所有设备。然后，对于每个设备，它遍历通道并打印其名称。
- en: 'Additionally, there are miscellaneous APIs allowing us to obtain channel properties.
    These are the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些杂项API允许我们获取通道属性。以下是这些API：
- en: '[PRE96]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding APIs, the first one checks whether the IIO channel is output
    or not, and the others mainly return each of the elements the name pattern is
    made of.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述API中，第一个检查IIO通道是否为输出，其他的主要返回名称模式中每个元素的值。
- en: Working with a trigger
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与触发器一起工作
- en: In `libiio`, a trigger is assimilated to a device, as both are represented by
    `struct iio_device`. The trigger must be created before creating the context,
    else this trigger won't be seen/available from that context.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在`libiio`中，触发器被视为设备，因为它们都由`struct iio_device`表示。触发器必须在创建上下文之前创建，否则该上下文无法看到/使用该触发器。
- en: 'In order to do so, you must create the trigger yourself, as we saw in the *IIO
    trigger and sysfs (user space)* section. Then, to find this trigger from a context,
    as it is assimilated to a device, you can use one of the device-related lookup
    APIs that we described in the *Walking through and managing IIO devices* section.
    In this section, let''s use `iio_context_find_device()`, which as you''ll recall
    is defined as the following:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您必须自己创建触发器，正如我们在*IIO触发器和sysfs（用户空间）*部分看到的那样。然后，要从上下文中找到此触发器，由于它被视为设备，您可以使用我们在*遍历和管理IIO设备*部分中描述的设备相关查找API之一。在本节中，让我们使用`iio_context_find_device()`，正如您所记得，它定义如下：
- en: '[PRE97]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This function looks for a device by its name in the given context. This is the
    reason why the trigger must have been created before creating the context. In
    parameters, `ctx` is the context from where to look for the trigger and `name`
    is the name of the trigger, as you would have written it to the `current_trigger`
    sysfs file.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数根据给定上下文中的设备名称查找设备。这就是为什么触发器必须在创建上下文之前创建的原因。在参数中，`ctx`是查找触发器的上下文，`name`是触发器的名称，就像你在`current_trigger`
    sysfs文件中写的那样。
- en: 'Once the trigger found, it must be assigned to a device using `iio_device_set_trigger()`,
    defined as the following:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到触发器，必须使用`iio_device_set_trigger()`将其分配给设备，定义如下：
- en: '[PRE98]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This function associates the trigger, `trig`, to the device, `dev`, and returns
    `0` on success or a negative `errno` code on failure. If the `trig` parameter
    is `NULL`, then any trigger associated with the given device will be disassociated.
    In other words, to disassociate a trigger from the device, you should call `iio_device_set_trigger(dev,
    NULL)`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将触发器`trig`与设备`dev`关联，并在成功时返回`0`，失败时返回负的`errno`代码。如果`trig`参数为`NULL`，则与给定设备关联的任何触发器将被解除关联。换句话说，要将触发器从设备中解除关联，应调用`iio_device_set_trigger(dev,
    NULL)`。
- en: 'Let''s see how trigger lookup and association work in a little example:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个小例子来看一下触发器查找和关联是如何工作的：
- en: '[PRE99]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the preceding example, we first create a local context, and we make sure
    this context contains at least two devices. Then, from this context, we look for
    a trigger named `hrtimer-1` and a device named `iio-device-dummy`. Once both are
    found, we associate the trigger to the device. Finally, when done with the trigger,
    it is disassociated from the device.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们首先创建一个本地上下文，并确保该上下文包含至少两个设备。然后，从该上下文中查找一个名为`hrtimer-1`的触发器和一个名为`iio-device-dummy`的设备。一旦找到这两个对象，我们将触发器与设备关联。最后，当触发器不再使用时，它将与设备解除关联。
- en: Creating a buffer and reading data samples
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建缓冲区并读取数据样本
- en: 'Note that channels we are interested in need to be enabled before creating
    the buffer. To do so, you can use the following APIs:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们感兴趣的通道需要在创建缓冲区之前启用。为此，你可以使用以下API：
- en: '[PRE100]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The first function enables the channel so that its data will be captured and
    pushed in the buffer. The second one is a helper checking whether a channel has
    already been enabled or not.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数启用通道，以便其数据将被捕获并推送到缓冲区。第二个是一个帮助函数，用于检查通道是否已经启用。
- en: 'In order to disable a channel, you can use `iio_channel_disable()`, defined
    as the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了禁用通道，你可以使用`iio_channel_disable()`，其定义如下：
- en: '[PRE101]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now that we are able to enable the channels, we need their data to be captured.
    We can create a buffer using `iio_device_create_buffer()`, defined as the following:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够启用通道，我们需要捕获它们的数据。我们可以使用`iio_device_create_buffer()`创建一个缓冲区，其定义如下：
- en: '[PRE102]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This function configures and enables a buffer. In the preceding function, `samples_count`
    is the total number of data samples that can be stored by the buffer, whatever
    the number of enabled channels. It corresponds to the `length` attribute described
    in the *IIO buffer sysfs interface* section. `cyclic`, if `true`, enables cyclic
    mode. This mode makes sense for output devices only (such as DACs). However, in
    this section, we deal with input devices only (that is, ADCs).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数配置并启用缓冲区。在前面的函数中，`samples_count`是缓冲区能够存储的总数据样本数，无论启用的通道数量如何。它对应于*IIO缓冲区sysfs接口*章节中描述的`length`属性。`cyclic`如果为`true`，则启用循环模式。此模式仅对输出设备有意义（如DAC）。然而，在本节中，我们仅处理输入设备（即ADC）。
- en: 'Once you are done with a buffer, you can call `iio_buffer_destroy()` on this
    buffer, which disables it (thus stopping the capture) and frees the data structure.
    This API is defined as the following:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了对缓冲区的操作，你可以调用`iio_buffer_destroy()`来销毁该缓冲区，这将禁用缓冲区（从而停止捕获）并释放数据结构。此API的定义如下：
- en: '[PRE103]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Do note that capturing starts as soon as the buffer is created, that is, after
    `iio_device_create_buffer()` has succeeded. However, samples are only pushed into
    the kernel buffers. In order to fetch samples from the kernel buffer to the user-space
    buffer, we need to use `iio_buffer_refill()`. While `iio_device_create_buffer()`
    has to be called only once to create the buffer and start the in-kernel continuous
    capture, `iio_buffer_refill()` must be called every time we need to fetch samples
    from the kernel buffer. It could be used in the processing loop, for example.
    The following is its definition:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，捕获一旦缓冲区创建成功后就会开始，即在`iio_device_create_buffer()`成功后。然而，样本仅会被推送到内核缓冲区。为了将样本从内核缓冲区获取到用户空间缓冲区，我们需要使用`iio_buffer_refill()`。虽然`iio_device_create_buffer()`只需调用一次以创建缓冲区并启动内核中的连续捕获，`iio_buffer_refill()`必须每次调用来获取内核缓冲区中的样本。它可以在处理循环中使用，例如。以下是它的定义：
- en: '[PRE104]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'With `iio_device_create_buffer()`, with the low-speed interface, the kernel
    allocates a single underlying buffer block (whose size equals `samples_count *
    nb_buffers * sample_size`) to handle the captures and immediately starts feeding
    samples inside. This default block count is `4` by default, and can be changed
    with `iio_device_set_kernel_buffers_count()`, defined as the following:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iio_device_create_buffer()`，通过低速接口，内核会分配一个单独的底层缓冲区块（其大小为`samples_count *
    nb_buffers * sample_size`）来处理捕获，并立即开始将样本填充到其中。默认情况下，默认的块数量为`4`，可以通过`iio_device_set_kernel_buffers_count()`进行更改，其定义如下：
- en: '[PRE105]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In high-speed mode, the kernel allocates `nb_buffers` buffer blocks, managed
    with the FIFO concept of an input queue (empty buffers) and output queue (buffers
    containing samples) in a way that, upon creation, all the buffers are filled with
    samples and put in the outgoing queue. When `iio_buffer_refill()` is called, the
    first buffer's data in the output queue is pushed (or mapped) to user space and
    this buffer is put back in the input queue waiting to be filled again. At the
    next call to `iio_buffer_refill()`, the second one is used, and so on, over and
    over. It must be noted that small buffers result in less latency but more overhead,
    while large buffers result in less overhead but more latency. The application
    must make tradeoffs between latency and management overhead. When cyclic mode
    is `true`, only a single buffer will be created, whatever the number of blocks
    specified.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在高速模式下，内核分配 `nb_buffers` 个缓冲块，通过输入队列（空缓冲区）和输出队列（包含样本的缓冲区）以 FIFO 概念进行管理。在创建时，所有缓冲区都会填充样本并放入输出队列。当调用
    `iio_buffer_refill()` 时，输出队列中的第一个缓冲区的数据会被推送（或映射）到用户空间，并且该缓冲区会被放回输入队列，等待再次填充。在下一次调用
    `iio_buffer_refill()` 时，将使用第二个缓冲区，依此类推，不断循环。需要注意的是，小缓冲区会导致较低的延迟，但开销较大；而大缓冲区会导致较低的开销，但延迟较高。应用程序必须在延迟和管理开销之间做出权衡。当循环模式为
    `true` 时，将只创建一个缓冲区，无论指定的块数是多少。
- en: 'In order to read the data samples, the following APIs can be used:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取数据样本，可以使用以下 API：
- en: '[PRE106]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The following are the meanings and usages of each API listed:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个列出 API 的含义和用法：
- en: '`iio_buffer_end()` returns a pointer corresponding to the user-space address
    that immediately follows the last sample present in the buffer.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_end()` 返回指向缓冲区中最后一个样本之后的用户空间地址的指针。'
- en: '`iio_buffer_start()` returns the address of the user-space buffer. Do, however,
    note that this address might change after `iio_buffer_refill()` (especially with
    a high-speed interface, where several buffer blocks are used).'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_start()` 返回用户空间缓冲区的地址。然而，请注意，在调用 `iio_buffer_refill()` 后，该地址可能会发生变化（尤其是在使用高速接口时，多个缓冲块被使用）。'
- en: '`iio_buffer_step()` returns the spacing between sample sets in the buffer.
    That is, it returns the difference between the addresses of two consecutive samples
    of one same channel.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_step()` 返回缓冲区中样本集之间的间隔。也就是说，它返回同一通道中两个连续样本地址之间的差值。'
- en: '`iio_buffer_first()` returns the address of the first sample for a channel
    or the address of the end of the buffer if no sample for the given channel is
    present in the buffer.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_first()` 返回给定通道的第一个样本的地址，如果缓冲区中没有该通道的样本，则返回缓冲区末尾的地址。'
- en: '`iio_buffer_foreach_sample()` iterates over each sample in a buffer and calls
    a supplied callback for each sample found.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_foreach_sample()` 遍历缓冲区中的每个样本，并为找到的每个样本调用提供的回调函数。'
- en: The preceding list of APIs can be split into three families, depending on how
    the data samples are read.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 前述 API 列表可以根据读取数据样本的方式分为三类。
- en: Buffer pointer reading
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区指针读取
- en: 'In this read method, `iio_buffer_first()` is coupled with `iio_buffer_step()`
    and `iio_buffer_end()` in order to iterate on all the samples of a given channel
    present in the buffer. This can be achieved in the following manner:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种读取方法中，`iio_buffer_first()` 与 `iio_buffer_step()` 和 `iio_buffer_end()` 配合使用，以便迭代缓冲区中给定通道的所有样本。可以通过以下方式实现：
- en: '[PRE107]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: In the preceding example, from within the loop, `ptr` will point to one sample
    of the channel we're interested in, that is, `chan`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在循环中，`ptr` 将指向我们感兴趣的通道样本，即 `chan`。
- en: 'The following is an example:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE108]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The preceding code reads the channel data format to check whether the value
    is repeated or not. This repeat corresponds to `iio_chan_spec.scan_type.repeat`.
    Then, assuming the code could work with two variants of a converter (the first
    one coding data on 16 bits and the second coding data on 64 bits), a check for
    the data length is performed to print in the appropriate format. This length corresponds
    to `iio_chan_spec.scan_type.storagebits`. Do note that `PRIi16` and `PRIi64` are
    the integer `printf` formats for `int16_t` and `int64_t`, respectively.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码读取通道数据格式，以检查值是否重复。这个重复对应于 `iio_chan_spec.scan_type.repeat`。然后，假设代码可以处理两种不同的转换器（第一种使用
    16 位编码数据，第二种使用 64 位编码数据），会进行数据长度的检查，以便以适当的格式打印。这段长度对应于 `iio_chan_spec.scan_type.storagebits`。需要注意的是，`PRIi16`
    和 `PRIi64` 是 `int16_t` 和 `int64_t` 的整数 `printf` 格式。
- en: Callback-based sample reading
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于回调的样本读取
- en: 'In callback-based sample reading, `iio_buffer_foreach_sample()` is at the heart
    of the reading logic. It has the following definition:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This function calls the supplied callback for each sample found in a buffer.
    `data` is user data, which, if set, will be passed to the callback in the last
    argument. This function iterates over samples, and each sample is read and passed
    to a callback, along with the channel from where this sample originates. This
    callback has the following definition:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The callback receives four arguments, as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the `iio_channel` structure that produced the sample
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the sample itself
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the sample in bytes, that is, the storage bits divided by 8, `iio_chan_spec.scan_type.storagebits/8`
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user-specified pointer optionally passed to `iio_buffer_foreach_sample()`
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method may be used to read from (in the case of input devices) or write
    to (in the case of output devices) the buffer. The main difference from the previous
    method is that the callback function is invoked for each sample of the buffer,
    not ordered by channels, but in the order that they appear in the buffer.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of this kind of callback implementation:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then, in the main code, we loop and iterate over samples in the buffer, as
    follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The preceding code, instead of playing with samples directly, delegates the
    job to a callback.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: High-level channel (raw) reading
  id: totrans-537
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method in this read series is to use one of the higher-level functions
    provided by the `iio_channel` class. These are `iio_channel_read_raw()`, `iio_channel_write_raw()`,
    `iio_channel_read()`, and `iio_channel_write()`, all defined as the following:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The former two will basically copy the first `N` samples of a channel (`chan`)
    to a user-specified buffer (`dst`), which must have been allocated beforehand
    (`N` depending on the size of this buffer and a sample's storage size, that is,
    `iio_chan_spec.scan_type.storagebits / 8`). The difference between the two is
    that the `_raw` variant won't convert the samples and the user buffer will contain
    raw data, while the other variant will convert each sample so that the user buffer
    will contain processed values. These functions kind of demultiplex (since they
    target one channel's samples among several ones) samples of a given channel.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `iio_channel_write_raw()` and `iio_channel_write()` will
    copy the sample data from the user-specified buffer to the device, by targeting
    a given channel. These functions multiplex the samples as they gather samples
    targeting one channel among many. The difference between the two is that the `_raw`
    variant will copy data as is and the other will convert the data into hardware
    format before sending it to the device.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to use the preceding APIs to read data from a device:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the preceding example, we first fetch data samples from the kernel using
    `iio_buffer_refill()`. Then, for each channel, we obtain the data format of this
    channel using `iio_channel_get_data_format()`, from which we grab the size of
    a sample for this channel. After that, we use this sample's size to compute the
    user buffer size to allocate for receiving this channel's samples. Obtaining a
    channel's sample size allows us to precisely determine the size of the user buffer
    to allocate.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Walking through user-space IIO tools
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though we have already gone through the steps required to capture IIO data,
    it might be tedious and confusing since each step must be performed manually.
    There are some useful tools you can use to ease and speed up your app development
    dealing with IIO devices. These are all from the `libiio` package, developed by
    Analog Devices, Inc. to interface IIO devices, available here: [https://github.com/analogdevicesinc/libiio](https://github.com/analogdevicesinc/libiio).'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'User-space applications can easily use the `libiio` library, which under the
    hood is a wrapper that relies on the following interfaces:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/bus/iio/devices`, the IIO sysfs interface, which is mainly used for configuration/settings'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/dev/iio/deviceX` character device, for data/acquisitions
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding are exactly what we have manually dealt with so far. The tool''s
    source code can be found under the library''s `tests` directory: [https://github.com/analogdevicesinc/libiio/tree/master/tests](https://github.com/analogdevicesinc/libiio/tree/master/tests)
    offers tools such as the following:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: The `iiod` server daemon, acting as a network backend to serve any application
    over a network link
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio_info` to dump attributes'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iio_readdev` to read or scan from a device'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We ended this chapter by enumerating tools, which can ease prototyping or device/driver
    testing. Links pointing to either sources, documentation, or examples of usage
    of these tools have been mentioned.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-555
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you are familiar with the IIO framework and vocabulary.
    You know what channels, devices, and triggers are. You can even play with your
    IIO device from the user space, through sysfs or a character device. The time
    to write your own IIO driver has come. There are a lot of available existing drivers
    that don't support trigger buffers. You can try to add this feature to one of
    them.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will play with the GPIO subsystem, which is a basic
    concept that has been introduced in this chapter as well.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
