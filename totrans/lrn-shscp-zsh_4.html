<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Globbing</h1></div></div></div><p>In this chapter, we will get to know one of the most powerful features of zsh: filename generation. We will learn new ways of dealing with the system's files and directories and even expand the functionalities of some of the more traditional commands by applying parameter substitution and modifiers. The chapter also serves as an introduction to zmv, a built-in function that provides a number of useful functionalities to deal with both the mundane and the more complex tasks regarding files. We will learn to use zmv for renaming, copying, and linking files based on our newly learned patterns. Feeling excited already?</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Quoting your strings</h1></div></div></div><p>A safe way <a class="indexterm" id="id126"/>of declaring your string variables involves the usage of<a class="indexterm" id="id127"/> quotes. Think of it as a way of telling the function "<em>here</em> starts and <em>over here</em> ends my string". Although <a class="indexterm" id="id128"/>not necessary on this particular example, you can quote a phrase when using <code class="literal">echo</code> as follows:</p><div><pre class="programlisting">
<strong>% echo 'this is a quoted phrase'</strong>
<strong>&gt; this is a quoted phrase</strong>
</pre></div><p>Single quotes<a class="indexterm" id="id129"/> are treated as delimiters by the shell and as such, they are completely ignored. The same rule applies to the <code class="literal">print</code> built-in function:</p><div><pre class="programlisting">
<strong>% print 'this is a quoted phrase'</strong>
<strong>&gt; this is a quoted phrase</strong>
</pre></div><p>So, what's the point of using quotes then? Well, imagine for a moment that your output looks something like the following:</p><div><pre class="programlisting">
<strong>% echo this is a backslash: \</strong>
<strong>~&gt;</strong>
</pre></div><p>Yes, that will trigger a continuation line, so there's seemingly no way around it, save for using quotes. Let's try it again:</p><div><pre class="programlisting">
<strong>% echo 'this is a backslash: \'</strong>
<strong>&gt; this is a backslash: \</strong>
</pre></div><p>So, as a rule of thumb, we use single quotes when there are special characters on our string as follows:</p><div><pre class="programlisting">
<strong>% echo 'special characters like * # and \ need to be quoted'</strong>
<strong>&gt; special characters like * # and \ need to be quoted</strong>
</pre></div><p>Now, what's it <a class="indexterm" id="id130"/>that makes these special? Well, earlier in this book, we saw that comments are defined by a <code class="literal">#</code> sign; we can use the <code class="literal">*</code> character as a wildcard that matches filenames and the <code class="literal">\</code> character can be used for escaping sequences with special meaning. Think of all these as <em>special characters</em> that will never literally mean what the keyboard says, unless you quote them.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>Some special characters need to be "escaped". This means that they will have a different meaning other than the characters they represent, unless there's a <code class="literal">\</code> character before them, that is.</p></div></div><p>For example, <code class="literal">echo *.rb</code> will list all the files that have an <code class="literal">.rb</code> extension. If you wanted to list a directory named <code class="literal">*.rb</code>—weird, I know—you would have to call <code class="literal">echo</code> escaping the <code class="literal">*</code> special character as follows:</p><div><pre class="programlisting">
<strong>% echo \*.rb</strong>
</pre></div><p>Also worth noting is that <code class="literal">\</code> is actually a special character, so in cases where a literal backslash is required, you will need to escape it too:</p><div><pre class="programlisting">
<strong>% echo \\</strong>
<strong>&gt; \</strong>
</pre></div><p>As we saw in the previous chapter, a single backslash (<code class="literal">\</code>) will only trigger a continuation line.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>You can make the shell output the raw string by supplying the <code class="literal">(q)</code> argument:</p><div><pre class="programlisting">% string="This is a *string* with various 'special' characters"
% echo ${(q)string}
&gt; this\ is\ a\ \*string\*\ with\ various\ \'special\'\ characters</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Double quotes</h2></div></div></div><p>Okay, so what happens when we need to use the niceties of the special characters and also need them to appear as their literal representations? Enter the double quotes.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>The option <code class="literal">RC_QUOTES</code> allows you to use single quotes within a single-quoted string:</p><div><pre class="programlisting">% setopt rcquotes
% echo 'a single ''quoted'' string'
&gt; a single ''quoted'' string</pre></div></div></div><p>Double quotes <a class="indexterm" id="id131"/>work by allowing you to retain the value of any string and also enabling<a class="indexterm" id="id132"/> <em>parameter substitution</em> and <em>shell expansion</em> <a class="indexterm" id="id133"/>within them.</p><p>Take a long, hard look at the following example:</p><div><pre class="programlisting">
<strong>% echo "My username is $(whoami) and my home folder is located at '$HOME'."</strong>
<strong>&gt; My username is gfestari and my home folder is located at '/Users/gfestari'.</strong>
</pre></div><p>The shell works inside the double quotes by executing the command within the <code class="literal">$()</code> construct before anything else. In this particular case, we are using the <code class="literal">whoami</code> program to tell the current user ID—<code class="literal">gfestari</code> in this particular case—(if that's also your name, then <em>hello</em>, long-lost brother).</p><p>The shell then moves on to expand the environment variable <code class="literal">$HOME</code>, which holds the current user's home folder currently pointing at <code class="literal">/Users/gfestari</code> on my system. Notice how the single quotes are treated like any other character within double quotes.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec22"/>Getting started with Globbing</h1></div></div></div><p>Filename Generation, popularly known as <a class="indexterm" id="id134"/>
<strong>Globbing</strong> (as in, Global substitution), is the ability of the shell to generate filenames from patterns. This is but the name for the process that allows the shell to read a pattern and generate a series of filenames; as a matter of fact, you might notice you have been using Globbing for quite a while in this book, the only difference is, we're now formally introducing the feature. Also, be aware that whenever we mention <em>filenames</em> in this text, it means both file <em>and</em> folder names, as you can use pretty much the same patterns to match both.</p><p>The really important thing you need to remember when dealing with Globbing is that filename substitution happens in the shell <em>right before</em> the line you typed is sent to the command. In other words, you type, zsh does the substitution, and <em>only then </em>sends the result, an expanded string and not whatever you just typed, to the function or program. There are ways around this, but just be mindful.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>If you'd like to take a deeper look at some of the features covered in this chapter, you can always refer to the official documentation by typing <code class="literal">man zshexpn</code>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Globbing with the stars</h2></div></div></div><p>Globbing works by using a series of special characters known as<a class="indexterm" id="id135"/> <em>operators</em>, to create a pattern that is later expanded by the shell into more complex, traditional strings without you even noticing the extra effort required. Arguably, the most popular of these <a class="indexterm" id="id136"/>operators is the asterisk or star (<code class="literal">*</code>). The star works as a<a class="indexterm" id="id137"/> <em>wildcard</em>, allowing you to match any filenames, even if you provide no pattern at all:</p><div><pre class="programlisting">
<strong>% echo *</strong>
<strong>README.md todo.txt draft.txt new_file.txt</strong>
</pre></div><p>This will list any file and folder on your current directory. Notice how we only needed a <em>single star</em> for this. However, if we want all files with a <code class="literal">.txt</code> extension, we simply need to provide the appropriate pattern: anything that ends with the desired extension.</p><div><pre class="programlisting">
<strong>% echo *.txt</strong>
<strong>todo.txt draft.txt new_file.txt</strong>
</pre></div><p>What happens is that zsh reads the <code class="literal">*.txt</code> pattern, transforms it into its literal meaning (all the filenames with a <code class="literal">txt</code> extension), and only then passes the result as the argument for <code class="literal">echo</code>, which in turn never deals with the actual pattern.</p><p>Arguably, the best thing the star has going on is its versatility. Just like a drunken sailor, a star can get along with practically anything, not just files:</p><div><pre class="programlisting">
<strong>% echo *folder</strong>
<strong>out_folder src_folder</strong>
</pre></div><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>You can use the <code class="literal">NO_CASE_GLOB</code> option if you want to make Globbing case-insensitive (that is, treat upper and lowercase characters as equals).</p><div><pre class="programlisting">% setopt nocaseglob
% echo *.jpg
photo.jpg pic.JPG</pre></div></div></div><p>It's not all sunshine and rainbows though. There's a fine print detail that you should consider when using the star operator: hidden files. If you recall from <a class="link" href="ch02.html" title="Chapter 2. Alias and History">Chapter 2</a>, <em>Alias and History</em>, we used an alias, <code class="literal">la</code> (or <code class="literal">ls -a</code>), in order to list the hidden files within a directory; otherwise, the command wouldn't list them. </p><p>Because of how big a headache it could cause you to do things like <code class="literal">rm *</code> and end up deleting a parent folder, most Unix shells will simply ignore hidden files for most commands. The same rules apply to Globbing when using the wildcard operator. A workaround for dealing with this behavior would be to explicitly use a pattern along the lines of <code class="literal">.*some_pattern</code> in order to include hidden files just like the following:</p><div><pre class="programlisting">
<strong>% echo .*zsh*</strong>
<strong>.zsh_aliases .zsh_funcs .zsh_history .zsh_prompt .zshenv .zshrc</strong>
</pre></div><p>We use two stars in order to list all the files that start with a dot (traditional hidden files in Unix) and contain a <code class="literal">zsh</code> pattern somewhere in their name. In other words, our startup files.</p><p>The <a class="indexterm" id="id138"/>takeaway lesson here: <em>you can use the star anywhere on a pattern</em>, you don't have to limit yourself with length or just extensions; be mindful of the hidden files though, as a star won't show you any hidden files, you'll need something along the lines of <code class="literal">.*some_pattern</code> for that to work.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>You can always circumvent the "ignore files starting with dots" behavior by setting the <code class="literal">GLOBDOTS</code> option; however, it's advisable you refrain from setting it permanently on your startup files as it can lead to issues such as you deleting the parent (<code class="literal">.</code>) directory and so on.</p><p>The most important thing to keep in mind when using this option on your scripts or functions is ensuring a call to <code class="literal">setopt NO_GLOBDOTS</code> right before exiting. Most times though, you'll do just fine by using the <code class="literal">.*</code> pattern discussed previously.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Questions for any single character</h2></div></div></div><p>The<a class="indexterm" id="id139"/> question mark symbol works pretty much like the <a class="indexterm" id="id140"/>star, except it matches a single character instead of many. For example, you can use <code class="literal">ls ???</code> to list the contents of any three-lettered directory, or get a bit more practical and use the following to list any two-lettered extension file:</p><div><pre class="programlisting">
<strong>% echo *.??</strong>
<strong>script.sh</strong>
</pre></div><p>We can even view all files with an extension via the following, similar expression:</p><div><pre class="programlisting">
<strong>% echo main.?*</strong>
<strong>main.c main.o main.tmp</strong>
</pre></div><p>This is similar to the wildcard qualifier; however, you won't be able to match any filenames with leading dots unless you explicitly declare so.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Brackets for a sequence of characters</h2></div></div></div><p>You can use <a class="indexterm" id="id141"/>the square brackets construct to match a group of <a class="indexterm" id="id142"/>characters within a pattern. For example, you can use <code class="literal">[ML]*</code> to match any filename that starts with either an uppercase letter <code class="literal">M</code> or <code class="literal">L</code>.</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>Log.log Main.rb README.md script.sh</strong>
<strong>% echo [ML]*</strong>
<strong>Log.log Main.rb</strong>
</pre></div><p>Notice how we need to combine the character class operator with the wildcard in order to denote the filenames that might have more than a single uppercase letter.</p><p>Even more useful is the use of a hyphen (or minus sign) in order to name ranges of contiguous characters to match. For example, you can use the <code class="literal">[A-Z]*</code> pattern to match any file that starts with an uppercase letter from the alphabet. Likewise, you can use the same pattern for contiguous natural numbers:</p><div><pre class="programlisting">
<strong>% echo *.log_[1-9]</strong>
<strong>out.log_1 out.log_2 out.log_3</strong>
</pre></div><p>Simple enough, right? Remember you can declare your own character classes. Here's an example that matches any filename starting with any number from one to five or an uppercase <code class="literal">M</code>:</p><div><pre class="programlisting">
<strong>% echo [1-5M]*.*</strong>
<strong>Main.rb</strong>
</pre></div><p>Just as before, a <code class="literal">[.]*</code> pattern won't work as you might expect; in fact, it won't work at all.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>
<strong>A note about ranges</strong>
</p><p>If your system is <a class="indexterm" id="id143"/>using a non-English alphabet or something other than the ASCII character set, chances are you might expect things like <code class="literal">ü</code> to match classes like <code class="literal">[a-z]</code>. This behavior, however, is ruled by the <code class="literal">LANG</code> and <code class="literal">LC_*</code> family of environment variables and is <em>very</em> system dependent, not to mention, beyond the scope of this book.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Using safer ranges on your scripts</h2></div></div></div><p>Although<a class="indexterm" id="id144"/> nothing to<a class="indexterm" id="id145"/> write home about if you have been using any modern shell lately, there's a series of shortcuts that save you from boredom when working with the garden variety of character classes. You can access them via the <code class="literal">[[:shortcut:]]</code> pattern.</p><p>So, for example, if you needed any letter from the alphabet (say, the range that includes both uppercase and lowercase English characters <code class="literal">[A-Za-z]</code>), you could use the <code class="literal">alpha</code> shortcut to list any filename that starts with a character from the alphabet like so:</p><div><pre class="programlisting">
<strong>% echo [[:alpha:]]*</strong>
</pre></div><p>Feeling enthusiastic about character sets already? The following table lists some of the popular ones:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Character set</p>
</th><th style="text-align: left" valign="bottom"><p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ascii</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Anything from the ASCII character set (see <code class="literal">man ascii</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lower</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Lowercase character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">upper</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Uppercase character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">alpha</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Letter</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">digit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Number</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">alnum</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Alphanumeric character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">print</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Any printable character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blank</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Space or tab character</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">space</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Space character (tab, carriage return, newline and co.)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">punct</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Anything but an <code class="literal">alnum</code> nor a <code class="literal">space</code></p>
</td></tr></tbody></table></div><p>You can combine<a class="indexterm" id="id146"/> multiple patterns and character sets; just remember <a class="indexterm" id="id147"/>that the innermost brackets belong to the character set, and everything else goes between the outermost brackets. For example, if we want all the files that start with either a <code class="literal">digit</code> character or the lowercase <code class="literal">b</code> letter, we might roll with the following:</p><div><pre class="programlisting">
<strong>% echo [[:digit:]b]*.c</strong>
<strong>bindings.c</strong>
</pre></div><p>As you can see, the inner set of brackets declares the character set, while the <code class="literal">b</code> character is there just as though we had typed <code class="literal">[b]</code>.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Avoiding characters</h3></div></div></div><p>Okay, we have been giving <a class="indexterm" id="id148"/>patterns a warm welcome so far, but what happens when we want the thing that does <em>not</em> match whatever we're looking for? Turns out there's also an easy way to tell zsh "I want the filenames that have nothing to do with this particular pattern", so let's get to it.</p><p>Suppose we have the following files in a given directory:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>bindings.c  bindings.h  bindings.o  main.c  main.o</strong>
</pre></div><p>And we just want to select the actual code files, the ones ending in <code class="literal">.c</code> and <code class="literal">.h</code>, and avoid everything ending in <code class="literal">.o</code>. With what we have learned so far, we could get away with something along the lines of the following:</p><div><pre class="programlisting">
<strong>% echo *.[hc]</strong>
<strong>bindings.c bindings.h main.c</strong>
</pre></div><p>But as you can see, the more complex our requirements, the more likely we end up with a gigantic mess of a character class. Luckily, we can get the complement of a class via the caret (<code class="literal">^</code>) operator:</p><div><pre class="programlisting">
<strong>% echo *.[^o]</strong>
<strong>bindings.c bindings.h main.c</strong>
</pre></div><p>What we did back there was told zsh to expand the class for those filenames <em>that do not match</em> the <code class="literal">o</code> extension. Notice how the rest of the pattern remains unchanged and the caret is immediately after the left bracket that does the actual negation. Feel free to read this as "anything but whatever comes inside the brackets".</p><div><div><h3 class="title"><a id="tip32"/>Tip</h3><p>You can negate a character set by using a caret before the inner brackets. For example, if we wish to skip files that start with an uppercase letter, we might as well do the following:</p><div><pre class="programlisting">% echo [^[:upper:]]*</pre></div></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Handling mismatches</h2></div></div></div><p>So far we have seen how<a class="indexterm" id="id149"/> to make the shell interpret our patterns and attempt to match whatever filenames it can. During the remainder of this Globbing trip of ours, we'll take a look at what happens with the unlucky patterns, those that fail to match anything and how the shell deals with them.</p><p>Let's try listing some nonexistent zip files:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>bindings.c  bindings.h  bindings.o  main.c  main.o</strong>

<strong>% echo *.zip</strong>
<strong>zsh: no matches found: *.zip</strong>
</pre></div><p>It seems that zsh defaults to an error message and aborts the execution of the command. Luckily, there are plenty of things for us to do about it in the form of options.</p><p>First, there's <code class="literal">NULL_GLOB</code>, which will make the shell discard any pattern without a proper match. The following is an example, where a blank line gets printed when no matches are performed:</p><div><pre class="programlisting">
<strong>% setopt null_glob</strong>
<strong>% echo *.zip</strong>
<strong>&gt; </strong>
</pre></div><p>This comes in handy when passing multiple patterns, but can make you call some programs without any arguments whatsoever, so consider that before updating your startup files willy-nilly.</p><div><pre class="programlisting">
<strong>% echo *.c *.zip</strong>
<strong>bindings.c main.c</strong>
</pre></div><p>The first pattern (<code class="literal">*.c</code>) matches and lists all files with a <code class="literal">.c</code> extension; whereas the second pattern (<code class="literal">*.zip</code>) doesn't match anything and is discarded (a null second entry is passed to <code class="literal">echo</code>).</p><p>Moving on, there's <a class="indexterm" id="id150"/>also the <code class="literal">NOMATCH</code> option, which you can unset to achieve a behavior that pretty much emulates bash; any pattern that does not match is passed as a <em>literal argument</em> to the command. This is relatively easy to test with the following example:</p><div><pre class="programlisting">
<strong>% unsetopt nomatch</strong>
<strong>% echo *.zip</strong>
<strong>*.zip</strong>
</pre></div><p>What do you know? Seems the manpage was right and now the failing <code class="literal">*.zip</code> pattern acts just as though we had called <code class="literal">echo '*.zip'</code>. This works differently from <code class="literal">NULL_GLOB</code>, in that the pattern is also ignored by the shell, but passed <em>as an argument</em> to the program regardless of it matching anything.</p><div><div><h3 class="title"><a id="tip33"/>Tip</h3><p>Remember you could also use <code class="literal">setopt NO_NOMATCH</code> instead of <code class="literal">unsetopt</code>.</p></div></div><p>Lastly, there's an option which mimics the legacy behavior of <code class="literal">csh</code>, aptly named <code class="literal">CSH_NULL_GLOB</code>. Yes, naming conventions spare no expenses. Anyway, here's what happens when you set it:</p><div><pre class="programlisting">
<strong>% setopt csh_null_glob</strong>
<strong>% echo *.zip</strong>
<strong>zsh: no match</strong>
</pre></div><p>Seems it's back to the "error message and abort command" zone for us. Like the curious learners we are, let's kick it up a notch and see what happens when dealing with multiple patterns:</p><div><pre class="programlisting">
<strong>% echo *.c *.zip</strong>
<strong>bindings.c main.c</strong>
</pre></div><p>Ok, now that's a lot nicer. What happens is that <code class="literal">CSH_NULL_GLOB</code> will show you an error message and abort the command line whenever any single pattern does not match, but will go ahead and discard the failing patterns if there's at least one that matches. Think of this as the product of that night of unrestrained passion between zsh's default behavior and <code class="literal">NULL_GLOB</code>. And while we're at it, don't blame me for that mental picture.</p><p>Before we move <a class="indexterm" id="id151"/>on to another subject though, there's another option you should familiarize yourself with when dealing with patterns. But first, let's take a look at what happens when we try to pass a wrong pattern to the shell:</p><div><pre class="programlisting">
<strong>% echo *[[:alpha:]</strong>
<strong>zsh: bad pattern: *[[:alpha:]</strong>
</pre></div><p>Notice how we missed the closing bracket (<code class="literal">]</code>)? The shell complains about the pattern and we are left with the sour taste of failed scripting. Let's try that again, but now we'll set the following option:</p><div><pre class="programlisting">
<strong>% setopt no_bad_pattern</strong>
<strong>% echo *[[:alpha:]</strong>
<strong>*[[:alpha:]</strong>
</pre></div><p>We turned on <code class="literal">NO_BAD_PATTERN</code> (or unset <code class="literal">BAD_PATTERN</code>, whatever floats your boat) and guess what happened? That's right; the bad pattern <em>is ignored</em> by the shell expansion mechanism and passed instead as an argument to the command. Pretty handy if you don't want those pesky warnings while experimenting with your newly learned patterns.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec23"/>Extended Globbing</h1></div></div></div><p>As you might have noticed at this point, when it comes to<a class="indexterm" id="id152"/> Globbing, zsh goes above and beyond the call of duty and then some more. What we'll discuss next is the more advanced aspects of Globbing, commonly referred to as <em>extended Globbing</em>. Put simply, we'll learn a new set of characters and expressions that expand on what we have been using to provide even more functionality to the shell's operations. However, before we ride that horse, pry open that <code class="literal">.zshrc</code> file of yours and add the following option:</p><div><pre class="programlisting">setopt EXTENDED_GLOB</pre></div><p>Or call it from your terminal if you plan on adding it later on. As we'll see in no time, extended Globbing is there to give a special meaning to characters like <code class="literal">#</code>, which if you recall, is typically used for comments. Now let's get our hands dirty.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Special patterns</h2></div></div></div><p>Zsh's vast repertoire also <a class="indexterm" id="id153"/>includes a series of shortcuts or special patterns that aim to make mundane tasks a bit more tolerable. We will get familiarized with them in this section.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Recursive searching</h3></div></div></div><p>Arguably, the most popular<a class="indexterm" id="id154"/> pattern out there is<a class="indexterm" id="id155"/> recursive searching. Accessible through the <code class="literal">**/ </code>combination, this pattern tells zsh to perform a recursive search, starting from the current directory and working its way inwards along the directory tree. </p><p>For example, here's how we look for all the markdown files (files which typically have the <code class="literal">.md</code> extension) on the current working directory:</p><div><pre class="programlisting">
<strong>% echo **/*.md</strong>
<strong>README.md brew/README.md git/README.md scripts/README.md zsh/README.md</strong>
</pre></div><p>Then there's also the <code class="literal">***/</code> flavor, which tells the shell to follow symbolic links. Be careful though, as it can lead to errors such as "file name too long", which is the operating system's way of telling you that either the rabbit hole is too deep, or you have a circular reference somewhere.</p><div><div><h3 class="title"><a id="tip34"/>Tip</h3><p>Keep in mind that specialized tools like <code class="literal">find</code> or The Silver Searcher<a class="indexterm" id="id156"/> (<a class="ulink" href="https://github.com/ggreer/the_silver_searcher">https://github.com/ggreer/the_silver_searcher</a>) will run circles around the shell's directory recursion mechanism. Thus, you should avoid relying on it for "serious" operations.</p></div></div><p>As for the caveats of using the recursive pattern expression, you might eventually be greeted with an "argument list too long" warning from the system. This usually means the shell is taking up too much memory space when expanding the <code class="literal">**/</code> pattern into the directory structure, which in turn could happen if you have a really complex tree to work on. A workaround, if you insist on using the recursive expansion, is to pass each argument with the help of <code class="literal">xargs</code> as follows:</p><div><pre class="programlisting">
<strong>% find **/*.md | xargs echo</strong>
</pre></div><p>I know, this example is a bit dumb as the same could be accomplished just with a simple <code class="literal">find **/*.md</code> for a multiple-row result. The idea here is that you get to know how to <code class="literal">pipe</code> the results of the find into <code class="literal">echo</code> by splitting them with <code class="literal">xargs</code>, so bear with me.</p><p>Lastly, there's somewhat of a<a class="indexterm" id="id157"/> hack you can use in <a class="indexterm" id="id158"/>case you want to exclude the current directory from the pattern:</p><div><pre class="programlisting">
<strong>% echo */**/*.md</strong>

</pre></div><p>That way, only filenames that include <code class="literal">base_dir/any_dir</code> will match the pattern.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Alternate patterns</h3></div></div></div><p>Having to choose between two <a class="indexterm" id="id159"/>options and then being given a third one clearly inferior, can make a person rethink his decision... or so the story goes. Luckily, the shell is not a complex creature like us, and we can provide it with a choice of patterns to select should one fail. We do that by using the parentheses with a pipe construct, like the following example:</p><div><pre class="programlisting">
<strong>% echo [[:upper:]]*.(md|txt)</strong>
<strong>README.md README.txt</strong>
</pre></div><p>We continue on our search for the <code class="literal">README</code> files, using a named range to specify the filename we want with an uppercase letter before defining either an <code class="literal">md</code> or a <code class="literal">txt</code> extension. Simple, right? Well, not quite. Just be careful so as not to start the command line with parentheses, as this might make them run in a subshell instead. Zsh is smart enough to discriminate between intended usages, so you'll probably be safe most of the time. Try not to push your luck though.</p><p>Before we move on, it bears mentioning you can't use a pattern that contains a <code class="literal">/</code> character within the group alternatives we just learned. You have been warned!</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Numeric ranges</h3></div></div></div><p>You can make the shell match any<a class="indexterm" id="id160"/> series of digits it encounters with the <code class="literal">&lt;-&gt;</code> special pattern. What makes this construct great though, is that it can match any series of digits without a length restriction (this is because the shell processes each digit independently and not as a whole integer).</p><p>Take, for example, the following directory:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>log.txt      log_002.txt  log_010.txt  log_031.txt</strong>
<strong>log_001.txt  log_009.txt  log_030.txt</strong>
</pre></div><p>We want to work with those files that match the <code class="literal">log_xxx.txt</code> pattern, where <code class="literal">xxx</code> is a digit. Let's put what we just learned to good use:</p><div><pre class="programlisting">
<strong>% echo log_&lt;-&gt;.txt</strong>
<strong>log_001.txt log_002.txt log_009.txt log_010.txt log_030.txt log_031.txt</strong>
</pre></div><p>What if we want those logfiles from <code class="literal">10</code> upwards? Zsh has you covered:</p><div><pre class="programlisting">
<strong>% echo log_&lt;10-&gt;.txt</strong>
<strong>log_010.txt log_030.txt log_031.txt</strong>
</pre></div><p>As you can see, the <code class="literal">&lt;-&gt;</code> pattern can define a range with lower and upper bounds. Let's try again, this time for files between <code class="literal">10</code> and <code class="literal">20</code>:</p><div><pre class="programlisting">
<strong>% echo log_&lt;10-20&gt;.txt</strong>
<strong>log_010.txt</strong>
</pre></div><p>Another cool feat of this expression is that it doesn't take into account leading zeroes, allowing you to sort things such as <code class="literal">00010</code> and <code class="literal">00013</code>. Speaking of which, there's the <code class="literal">NUMERIC_GLOB_SORT</code> option, which you can also set in order to output a sorted<a class="indexterm" id="id161"/> numeric match of any pattern matches (and that's <em>any</em> as in, not just the numeric range pattern).</p><div><pre class="programlisting">
<strong>% setopt numericglobsort</strong>
<strong>% echo log_*</strong>
<strong>log_001.txt log_002.txt log_009.txt log_010.txt log_030.txt log_031.txt</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Revisiting the caret operator</h3></div></div></div><p>As we saw<a class="indexterm" id="id162"/> earlier, we use the <a class="indexterm" id="id163"/>caret (<code class="literal">^</code>) operator to negate patterns (remember: "anything but what matches this"). Here's another way to use the caret:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>README.md  README.txt  bindings.c  bindings.h  bindings.o  main.c  main.o</strong>

<strong>% echo b^*.o</strong>
<strong>bindings.c bindings.h</strong>
</pre></div><p>So basically, we're telling the shell to expand that pattern so as to match the filenames that start with <code class="literal">b</code> but do not have an <code class="literal">.o</code> extension.</p><p>We can then safely say that the <code class="literal">pattern^other_pattern</code> expressions work by matching the first pattern and avoiding matches on the <code class="literal">other_pattern</code> side of the expression. A word of caution now that we are using special characters with different meanings though is, remember to wrap names or expressions that you want taken literally with single quotes, like in the following example:</p><div><pre class="programlisting">
<strong>% echo '^c'</strong>

</pre></div><p>Otherwise, you might be asking for trouble.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>The tilde operator</h3></div></div></div><p>Similar to the<a class="indexterm" id="id164"/> caret operator's second usage, the<a class="indexterm" id="id165"/> tilde (<code class="literal">~</code>) operator can be used to define a pattern that consists of a part that should match and a second part that shouldn't:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>README.md  README.txt  bindings.c  bindings.h  bindings.o  main.c  main.o</strong>

<strong>% echo b*~*.o</strong>
<strong>bindings.c bindings.h</strong>
</pre></div><p>Basically, this is just a combination of two patterns: <code class="literal">b*</code> and <code class="literal">*.o</code>, linked with the "do not match what follows" operator: <code class="literal">~</code>. Again, we can read that as "match everything that starts with a lowercase b and does not match anything that ends with .o".</p><p>If you recall, we used <code class="literal">b^*.o</code> with the caret, so the tilde version seems a bit more straightforward if I might say so. But don't take my word for it. Let's use the tilde to exclude, for example, any files within a temporary directory:</p><div><pre class="programlisting">
<strong>% ls tmp</strong>
<strong>delete_me.sh  out.txt</strong>

<strong>% echo **/*.sh~tmp/*</strong>
<strong>src/script.sh</strong>
</pre></div><p>What happens is that the shell runs the first pattern (<code class="literal">**/*.sh</code>) and recursively checks for all files with the <code class="literal">sh</code> extension. The preliminary result is a list of possible filenames that is then matched against the second pattern (<code class="literal">tmp/*</code>). The filenames that match the latter are removed from the list, and we are left with the filenames we were searching for.</p><p>Just for academic purposes, it might be a good time to mention that <code class="literal">**/</code> is equivalent to the <code class="literal">(*/)#</code> pattern. As it stands, the special operator <code class="literal">#</code> will match a single repeating character (in parentheses), or a recurrent expression (in brackets).</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Glob qualifiers</h2></div></div></div><p>Besides operators, zsh boasts <a class="indexterm" id="id166"/>qualifiers, which are essentially a sort of filters<a class="indexterm" id="id167"/> you apply to your pattern in order to restrict things like matching only files or folders, type of permissions for those filenames, or even the owner of such entries.</p><p>So in the following example, we'll list all the <em>directories</em> that match the <code class="literal">*tmp</code> pattern. Notice the <code class="literal">(/)</code> construct, that's what intuitively sets files and folders apart:</p><div><pre class="programlisting">
<strong>% echo *tmp(/)  </strong>
<strong>tmp</strong>
</pre></div><p>What about matching only vanilla files then? Fair enough, <code class="literal">(.)</code> is your designed qualifier for files-only restrictions. </p><div><pre class="programlisting">
<strong>% ls -F</strong>
<strong>README.txt  script.zsh  zsh/  src/</strong>
</pre></div><p>Suddenly, a wild filename appears:</p><div><pre class="programlisting">
<strong>% echo *zsh(.)</strong>
<strong>script.zsh</strong>
</pre></div><p>We have a <code class="literal">zsh</code> directory and a script file with a <code class="literal">.zsh</code> extension. Typically, we would roll with an <code class="literal">echo *zsh</code> construct to list both of them, or a more restrictive <code class="literal">echo *.zsh</code> construct if we were just looking for files with an extension; however, the <code class="literal">(.)</code> qualifier is arguably better suited for complex tree searches or when dealing with lots of similar filenames and directories.</p><p>What follows is a "cheatsheet" for the <a class="indexterm" id="id168"/>most common qualifiers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">(N)</code>: Remove <a class="indexterm" id="id169"/>argument if no matches are found, silently ignore errors. Acts as a per-command <code class="literal">NO_GLOB</code> option.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(@)</code>: Symlink qualifier. Used <a class="indexterm" id="id170"/>for only selecting symbolic links.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(-@)</code>: A <a class="indexterm" id="id171"/>special variation of the previous one. Use this to find any <em>broken</em> symlinks.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(/)</code>: Directories<a class="indexterm" id="id172"/> only.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(.)</code>: Files only. Whatever <a class="indexterm" id="id173"/>is not either a link, directory, or any of the previous will be selected by this.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(*)</code>: Executable files. Directories<a class="indexterm" id="id174"/> need not apply. Think of this as <code class="literal">(.)</code> for those files with <code class="literal">+x</code> permissions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(r)</code>: File is<a class="indexterm" id="id175"/> readable by the current shell user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(w)</code>: File is <a class="indexterm" id="id176"/>writable by the current shell user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(x)</code>: File is <a class="indexterm" id="id177"/>executable by the current shell user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(U)</code>: File is<a class="indexterm" id="id178"/> owned by the current shell user.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(R)</code>: File is<a class="indexterm" id="id179"/> readable by anyone.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(W)</code>: File is<a class="indexterm" id="id180"/> writable by anyone.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(X)</code>: File is <a class="indexterm" id="id181"/>executable by anyone.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(u:root:)</code>: File <a class="indexterm" id="id182"/>is owned by the user <code class="literal">root</code>. You can replace the <code class="literal">:</code> character with any another pair of symbols such as curly braces: <code class="literal">(u{root})</code>. Just refrain from using pipes (<code class="literal">|</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">(on)</code>: Sort filenames <a class="indexterm" id="id183"/>by name. The <code class="literal">echo *(on)</code> construct will be analogous to <code class="literal">ls</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(On)</code>: Reverse-sort <a class="indexterm" id="id184"/>filenames by name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(oL)</code>: Sort filenames<a class="indexterm" id="id185"/> by file size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(OL)</code>: Reverse-sort <a class="indexterm" id="id186"/>filenames by file size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(om)</code>: Sort<a class="indexterm" id="id187"/> filenames by modification date.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(Om)</code>: Reverse-sort<a class="indexterm" id="id188"/> filenames by modification date.</li></ul></div><p>As always, feel free to mix and match to spice up things. Like poking with <code class="literal">(*r^w)</code> for regular files that are readable but not writable by your user, or <code class="literal">(@,/)</code> for either symlinks or directories.</p><div><div><h3 class="title"><a id="tip35"/>Tip</h3><p>Eager to find out more about qualifiers and what have you? Fret not dear reader, and embrace the mystical powers of... never mind, we'll just resort to <em>context completion</em>.</p><p>Type the following, and remember to press <em>Tab</em> right after the opening parentheses:</p><div><pre class="programlisting">% echo *zsh<em>&lt;Tab&gt;</em>
</pre></div><p>This will yield context completion for the glob qualifiers listed here (and many more!).</p></div></div><p>What follows are the more complex <a class="indexterm" id="id189"/>batch of qualifiers, such as timestamps and file size, which require a bit more explaining before delving right into their usage.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec12"/>Timestamp qualifiers</h3></div></div></div><p>Unix systems <a class="indexterm" id="id190"/>typically record three timestamps on their filesystems: modification, access, and change times. With that in mind, you can use the following <a class="indexterm" id="id191"/>construct for Globbing filenames:</p><div><pre class="programlisting">
<strong>% echo *(mh-1)</strong>
</pre></div><p>This will provide you with the files modified in the last hour. You can easily check this result via an <code class="literal">ls -l</code> qualifier. The <code class="literal">m</code> there is the modification time, which is the most common type of timestamp you'll be interested in. Nevertheless, you could also check for either access (<code class="literal">(ah-1)</code>) or creation (<code class="literal">(ch-1)</code>) qualifiers within the last hour.</p><p>Regarding that "last hour" bit, it's represented by the <code class="literal">h-1</code> qualifier, where <code class="literal">h</code> stands for hour (yes, yes, I know) and could be replaced by either minutes (<code class="literal">m</code>), weeks (<code class="literal">w</code>), or Months (an uppercase "<code class="literal">M</code>"). Note that the default unit for this qualifier is days, so <code class="literal">(m-1)</code> will mean a day ago or, more precisely, up to 24 hours before the current system time.</p><p>Similarly, the plus operator can be translated as "more than", allowing you to describe such patterns as <code class="literal">(mw+3)</code>, which is a concise way of saying "more than three weeks from today". Finally, you can also specify a range by combining the two operators:</p><div><pre class="programlisting">
<strong>% echo *(m-5mh+2)</strong>
</pre></div><p>This will provide the files modified between five and two hours.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec13"/>File size qualifiers</h3></div></div></div><p>The last qualifier <a class="indexterm" id="id192"/>you'll get to know today is the file size. As you might have <a class="indexterm" id="id193"/>guessed already, we can query filenames on the basis of their size on the disk:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">(Lm+size)</code>: The file size is larger than <code class="literal">size</code> megabytes. For example: <code class="literal">(Lm+5)</code>—larger than five megabytes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(Lm-size)</code>: The file is smaller than <code class="literal">size</code> megabytes. For example: <code class="literal">(Lm-2)</code>—smaller than two megabytes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(Lk+size)</code>: The file size is larger than <code class="literal">size</code> kilobytes. For example:<code class="literal"> (Lk+5000)</code>—larger than 5000 kilobytes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">(Lk-size)</code>: The file is smaller than <code class="literal">size</code> kilobytes. For example: <code class="literal">(Lm-2000)</code>—smaller than 2000 kilobytes.</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>The zmv function</h1></div></div></div><p>In the previous <a class="indexterm" id="id194"/>chapter, we learned about <code class="literal">zle</code>; zsh's module in charge of the command line. It's time we take advantage of our newly learned Globbing skills and get acquainted with <code class="literal">zmv</code>, a function that was created to make copying, moving, and linking files a breeze.</p><p>So, you ask, what's the deal with zmv? What's special about this built-in function in comparison to, say vanilla <code class="literal">cp</code>, is that zmv works its magic based on patterns. Further, as we'll see in this section, zmv is designed to be safe by default, which means it will ask you for a confirmation before taking on any kind of risky operation such as overwriting files.</p><p>Before we get started though, you should add the following to your <code class="literal">.zshrc</code> file, remembering to source it or restarting your terminal emulator of choice:</p><div><pre class="programlisting">autoload zmv</pre></div><p>This will make zsh load the function on startup, making it available to your session. You can now just type <code class="literal">zmv</code> and you'll be greeted with a fairly straightforward set of instructions. Basically, the zmv syntax expects two patterns: one for matching filenames and a second one into which the results will be converted:</p><div><pre class="programlisting">zmv [OPTIONS] old_pattern new_pattern</pre></div><p>As you might have guessed, zmv goes along with a great deal of Globbing, which is why we are only getting acquainted with it now. Here's how we can use it to rename our <code class="literal">.txt</code> files into markdown (<code class="literal">.md</code>):</p><div><pre class="programlisting">
<strong>% zmv -Wv '*.txt' '*.rb'</strong>
<strong>mv -- README.txt README.md</strong>
</pre></div><p>We used the verbose <code class="literal">-v</code> option flag, so we can learn more from the output. The <code class="literal">zmv</code> function works by expanding both patterns and then delegating the actual functionality to a more capable command such as <code class="literal">cp</code>, <code class="literal">ln</code>, or in this particular case, <code class="literal">mv</code>.</p><p>You can use the <code class="literal">-W</code> option to allow automatic conversion of the wildcards. Combined with <code class="literal">noglob</code>, you can add a brand new functionality to the <code class="literal">mv</code> command, which resembles the special behavior of the Windows systems' <code class="literal">cmd</code> variant:</p><div><pre class="programlisting">alias mmv='noglob zmv -W'</pre></div><p>You can now move<a class="indexterm" id="id195"/> files and rename them on the same call:</p><div><pre class="programlisting">
<strong>% mmv *.c.orig orig/*.c</strong>
</pre></div><p>As for the rest of the option flags that apply to zmv, here's a handful of the most relevant:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-f</code>: Force overwriting of destination files</li><li class="listitem" style="list-style-type: disc"><code class="literal">-i</code>: Interactive prompt for each operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">-n</code>: No execution, just print what happens</li><li class="listitem" style="list-style-type: disc"><code class="literal">-v</code>: Verbose—print a line as it is executed</li><li class="listitem" style="list-style-type: disc"><code class="literal">-w</code>: Implicitly add parenthesis to wildcards in the pattern</li><li class="listitem" style="list-style-type: disc"><code class="literal">-W</code>: Like <code class="literal">-w</code>, but turn wildcards in replacement patterns into references</li></ul></div><p>However, don't even think you'll need to remember these. As we'll see in the next chapter, you can always use <em>Tab</em> for context completion or, in zmv's particular case, you can get the full list by simply typing <code class="literal">zmv</code> and pressing <em>Return</em> on your terminal. Just know there are at least a couple of options available to you.</p><div><div><h3 class="title"><a id="tip37"/>Tip</h3><p>You can do what's popularly known as a dry run by passing the <code class="literal">-n</code> flag. This will make zmv only print out what will be done without actually doing it. This is by far the best way of testing and debugging your scripts before… well, you know, panic ensues.</p><div><pre class="programlisting">% ls foo
% zmv -n '(*)' '${(U)1}''mv -- foo FOO</pre></div></div></div><p>Should you require more advanced usage, you could use several expressions such as the <code class="literal">old_pattern</code> parameter. Filenames that match these will in turn be grouped and accessible by the <code class="literal">new_pattern</code> expression following the <code class="literal">$1</code>, <code class="literal">$2</code>, … pattern. For example, we can use the following for recursively renaming pictures on a folder tree so that their extensions are all lowercase:</p><div><pre class="programlisting">
<strong>% zmv '(**/)(*).(#i)jpg' '$1$2.jpg'</strong>
</pre></div><p>Summing up, with a bit of Globbing and practice, you can get a lot of mileage out of your zmv usage. You just need an appropriate pattern to match and a string to actually use that pattern. <code class="literal">zmv</code> will actually ignore any file whose name is not changed during expansion and it doesn't even care if the target is supposed to be a directory or a simple file.</p><div><div><h3 class="title"><a id="tip38"/>Tip</h3><p>You can access zmv's advanced documentation by typing <code class="literal">man zshcontrib</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Summary</h1></div></div></div><p>This is the part of our journey that requires us to pack up our things and wrap up the chapter. On this occasion though, we went from using Globbing as something we thought was "quite like a regular expression" to understanding what is actually a whole different beast. Luckily for us, that beast was pretty easy to tame once we learned the behavior of the most popular operators and qualifiers. We then expanded on those constructs with more special patterns and got to know <strong>zmv</strong> in order to make most of our daily tasks a breeze. Summing up, we can say that we:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learned about quotes, escaping symbols, and double quotes together with shell expansion within them</li><li class="listitem" style="list-style-type: disc">Got started with Globbing and parameter substitution within the command line</li><li class="listitem" style="list-style-type: disc">Kicked it up a notch and dove headfirst into extended Globbing, learning about recursive searching, and operators for negating and excluding patterns</li><li class="listitem" style="list-style-type: disc">We learned about glob qualifiers, how to use them to discriminate files by the system time and size</li><li class="listitem" style="list-style-type: disc">And finally discovered zmv, which lets us put all of the preceding things together to make working with complex filenames something like a walk in the park</li></ul></div><p>Seems like we have seen a whole lot so far, which will cater to most of our needs. Not a bad deal, if I might say so. Actually, I might, as that's one of the advantages of wearing the writer's hat.</p><p>The next chapter covers completion. And we have come together quite well so far, so I won't lie to you (again); completion is actually what makes most people never look back once they try zsh. You have tasted a sample of it so far, but there's plenty more waiting for you, right around this page.</p><p>Next up then is <a class="link" href="ch05.html" title="Chapter 5. Completion">Chapter 5</a>, <em>Completion</em>. Hurry up!</p></div></body></html>