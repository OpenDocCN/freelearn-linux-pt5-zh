<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Working with KVM Guests" id="E9OE1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Working with KVM Guests</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Installing and configuring a KVM</li><li class="listitem">Configuring resources</li><li class="listitem">Building VMs</li><li class="listitem">Adding CPUs on the fly</li><li class="listitem">Adding RAM on the fly</li><li class="listitem">Adding disks on the fly</li><li class="listitem">Moving disks to another storage</li><li class="listitem">Moving VMs</li><li class="listitem">Backing up your VM metadata</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Working with KVM Guests" id="E9OE1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">This book will attempt to show you how to deploy RHEL 7 systems without too much of a hassle. As this book is written with automation in mind, I will emphasize on command-line utilities rather than elaborating on its GUI counterparts, which are useless for automation.</p><p class="calibre7">This chapter explains how to build and manage KVM guests using the libvirt interface and various tools built around it. It will provide a brief overview on how to set up a KVM on RHEL and manage its resources. The setup provided in this overview is far from the ready enterprise as it doesn't provide any redundancy, which is generally required in enterprises. However, the recipes provided are relevant in enterprise setups as the interface stays the same. Most of the time, you will probably use a management layer (such as RHEV or oVirt), which will make your life easier in managing redundancy.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre7">Libvirt is the API between the<a id="id0" class="calibre1"/> user and the various virtualization and container layers that are available, such as KVM, VMware, Hyper-V, and Linux Containers. Check <a class="calibre1" href="https://libvirt.org/drivers.html">https://libvirt.org/drivers.html</a> for a <a id="id1" class="calibre1"/>complete list of supported hypervisors and container solutions.</p></div><p class="calibre7">As most tasks performed need to be automated in the end, I tend not to use any graphical interfaces as these do not allow an easy conversion into script. Hence, you will not find any recipes in this chapter involving a graphical interface. These recipes will primarily focus on <code class="email">virsh</code>, the libvirt management user interface that is used to manage various aspects of your KVM host and guests. While a lot of people rely on the edit option of <code class="email">virsh</code>, it doesn't allow you to edit a guest's configuration in real time. Editing your guest's XML configuration in this way will require you to shut down and boot your guest for the changes to take effect. A reboot of your guest doesn't do the trick as the XML configuration needs to be completely reread by the guest's instance in order for it to apply the changes. Only a fresh boot of the guest will do this.</p><p class="calibre7">The <code class="email">virsh</code> interface is also <a id="id2" class="calibre1"/>a shell, so by launching <code class="email">virsh</code> without any commands, you will enter the libvirt management shell. A very interesting command is <code class="email">help</code>. This<a id="id3" class="calibre1"/> will output all the available commands grouped by keyword. Each command accepts the <code class="email">--help</code> argument to show a detailed list of the possible arguments, and their explanation, which you can use.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Installing and configuring a KVM"><div class="book" id="F8902-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Installing and configuring a KVM</h1></div></div></div><p class="calibre7">This recipe covers the installing of virtualization tools and packages on RHEL 7.</p><p class="calibre7">By default, a RHEL 7 system<a id="id4" class="calibre1"/> doesn't come with a KVM or libvirt preinstalled. This can be<a id="id5" class="calibre1"/> installed in three ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Through the graphical setup during the system's setup</li><li class="listitem">Via a kickstart installation</li><li class="listitem">Through a manual installation from the command line</li></ul></div><p class="calibre7">For this recipe, you should know how to install packages using yum, and your system should be configured to have access to the default RHEL 7 repository (refer to <a class="calibre1" title="Chapter 8. Yum and Repositories" href="part0066_split_000.html#1UU541-501a83dd54944cb1bf060a2ce9fab11f">Chapter 8</a>, <span class="strong"><em class="calibre9">Yum and Repositories</em></span>, for more information), which is required for the packages that we will use.</p><p class="calibre7">Alternatively, you could install packages from the installation media using <code class="email">rpm</code>, but you'll need to figure out the dependencies yourself.</p><p class="calibre7">Check the dependencies of an <code class="email">rpm</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# rpm -qpR &lt;rpm file&gt;</strong></span>
</pre></div><p class="calibre7">This will output a list of binaries, libraries, and files that you need installed prior to installing this package.</p><p class="calibre7">Check which package contains these files through this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# rpm -qlp &lt;rpm package&gt;</strong></span>
</pre></div><p class="calibre7">As you can imagine, this is<a id="id6" class="calibre1"/> a tedious job and can take quite some time as you need to figure out every <a id="id7" class="calibre1"/>dependency for every package that you want to install in this way.</p></div>

<div class="book" title="Installing and configuring a KVM">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec12" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">To install a KVM, you will require at least 6 GB of free disk space, 2 GB of RAM, and an additional core or thread per guest.</p><p class="calibre7">Check whether your CPU supports a virtualization flag (such as SVM or VMX). Some hardware vendors disable this in the BIOS, so you may want to check your BIOS as well. Run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# grep -E 'svm|vmx' /proc/cpuinfo</strong></span>
<span class="strong"><strong class="calibre8">flags    : ... vmx ...</strong></span>
</pre></div><p class="calibre7">Alternatively, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# grep -E 'svm|vmx' /proc/cpuinfo</strong></span>
<span class="strong"><strong class="calibre8">flags    : ... svm ...</strong></span>
</pre></div><p class="calibre7">Check whether the hardware virtualization modules (such as <code class="email">kvm_intel</code> and <code class="email">kvm</code>) are loaded in the kernel using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# lsmod | grep kvm</strong></span>
<span class="strong"><strong class="calibre8">kvm_intel             155648  0</strong></span>
<span class="strong"><strong class="calibre8">kvm                   495616  1 kvm_intel</strong></span>
</pre></div></div></div>

<div class="book" title="Installing and configuring a KVM">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec13" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">We'll look at the three ways of installing a KVM onto your system.</p><div class="book" title="Manual installation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Manual installation</h3></div></div></div><p class="calibre7">This way of installing a<a id="id8" class="calibre1"/> KVM is generally done once the base system is installed by some other means. You need to perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Install the software needed to provide an environment to host virtualized guests with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# yum -y install qemu-kvm qemu-img libvirt</strong></span>
</pre></div><p class="calibre13">The installation of these packages will include quite a lot of dependencies.</p></li><li class="listitem" value="2">Install additional utilities required to configure <code class="email">libvirt</code> and install virtual machines by running this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# yum -y install virt-install libvirt-python python-virthost libvirt-client</strong></span>
</pre></div></li><li class="listitem" value="3">By default, the <code class="email">libvirt</code> daemon is marked to <code class="email">autostart</code> on each boot. Check whether it is enabled by executing the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# systemctl status libvirtd</strong></span>
<span class="strong"><strong class="calibre8">libvirtd.service - Virtualization daemon</strong></span>
<span class="strong"><strong class="calibre8">   Loaded: loaded (/usr/lib/systemd/system/libvirtd.service; enabled)</strong></span>
<span class="strong"><strong class="calibre8">   Active: inactive</strong></span>
<span class="strong"><strong class="calibre8">     Docs: man:libvirtd(8)</strong></span>
<span class="strong"><strong class="calibre8">           http://libvirt.org</strong></span>
</pre></div></li><li class="listitem" value="4">If for some reason<a id="id9" class="calibre1"/> this is not the case, mark it for autostart by executing the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# systemctl enable libvirtd</strong></span>
</pre></div></li><li class="listitem" value="5">To manually stop/start/restart the <code class="email">libvirt</code> daemon, this is what you'll need to execute:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# systemctl stop libvirtd</strong></span>
<span class="strong"><strong class="calibre8">~]# systemctl start libvirtd</strong></span>
<span class="strong"><strong class="calibre8">~]# systemctl restart libvirtd</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="Kickstart installation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Kickstart installation</h3></div></div></div><p class="calibre7">Installing a KVM during kickstart offers you an easy way to automate the installation of KVM instances. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Add the following<a id="id10" class="calibre1"/> package groups to your kickstarted file in the <code class="email">%packages</code> section:<div class="informalexample"><pre class="programlisting">@virtualization-hypervisor
@virtualization-client
@virtualization-platform
@virtualization-tools</pre></div></li><li class="listitem" value="2">Start the installation of your host with this kickstart file.</li></ol><div class="calibre14"/></div></div><div class="book" title="Graphical setup during the system's setup"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Graphical setup during the system's setup</h3></div></div></div><p class="calibre7">This is probably the<a id="id11" class="calibre1"/> least common way of installing a KVM. The only time I used this was during the course of writing this recipe. Here's how you can do this:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Boot from the RHEL 7 Installation media.</li><li class="listitem" value="2">Complete all steps besides the <span class="strong"><strong class="calibre8">Software selection</strong></span> step.<div class="mediaobject"><img src="../images/00002.jpeg" alt="Graphical setup during the system's setup" class="calibre10"/></div><p class="calibre15"> </p></li><li class="listitem" value="3">Go to <span class="strong"><strong class="calibre8">Software Selection</strong></span> to complete the KVM software selection.</li><li class="listitem" value="4">Select the <span class="strong"><strong class="calibre8">Virtualization host</strong></span> radio button in <span class="strong"><strong class="calibre8">Base Environment</strong></span>, and check the <span class="strong"><strong class="calibre8">Virtualization Platform</strong></span> checkbox in <span class="strong"><strong class="calibre8">Add-Ons for Selected Environment</strong></span>:<div class="mediaobject"><img src="../images/00003.jpeg" alt="Graphical setup during the system's setup" class="calibre10"/></div><p class="calibre15"> </p></li><li class="listitem" value="5">Finalize<a id="id12" class="calibre1"/> the installation.</li><li class="listitem" value="6">On the <span class="strong"><strong class="calibre8">Installation Summary</strong></span> screen, complete any other steps and click on <span class="strong"><strong class="calibre8">Begin Installation</strong></span>.</li></ol><div class="calibre14"/></div></div></div></div>

<div class="book" title="Installing and configuring a KVM">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec14" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">To set up your repositories, check out <a class="calibre1" title="Chapter 8. Yum and Repositories" href="part0066_split_000.html#1UU541-501a83dd54944cb1bf060a2ce9fab11f">Chapter 8</a>, <span class="strong"><em class="calibre9">Yum and Repositories</em></span>.</p><p class="calibre7">To deploy a system using kickstart, refer to <a class="calibre1" title="Chapter 2. Deploying RHEL &quot;En Masse&quot;" href="part0025_split_000.html#NQU21-501a83dd54944cb1bf060a2ce9fab11f">Chapter 2</a>, <span class="strong"><em class="calibre9">Deploying RHEL "En Masse"</em></span>.</p><p class="calibre7">For more in-depth information about<a id="id13" class="calibre1"/> using libvirt, go to <a class="calibre1" href="http://www.libvirt.org/">http://www.libvirt.org/</a>.</p><p class="calibre7">RHEL 7 has certain support<a id="id14" class="calibre1"/> limits, which are listed at these locations:</p><p class="calibre7">
<a class="calibre1" href="https://access.redhat.com/articles/rhel-kvm-limits">https://access.redhat.com/articles/rhel-kvm-limits</a>
</p><p class="calibre7">
<a class="calibre1" href="https://access.redhat.com/articles/rhel-limits">https://access.redhat.com/articles/rhel-limits</a>
</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Configuring resources"><div class="book" id="G6PI2-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Configuring resources</h1></div></div></div><p class="calibre7">Virtual machines require CPUs, memory, storage, and network access, similar to physical machines. This recipe will show you how to set up a basic KVM environment for easy resource management through libvirt.</p><p class="calibre7">A storage pool is a virtual<a id="id15" class="calibre1"/> container limited by two factors:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The maximum size allowed by <code class="email">qemu-kvm</code></li><li class="listitem">The size of the disk on the physical machine</li></ul></div><p class="calibre7">Storage pools may not<a id="id16" class="calibre1"/> exceed the size of the disk on the host. The maximum sizes are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">virtio-blk = 2^63 bytes or 8 exabytes (raw files or disk)</li><li class="listitem">EXT4 = ~ 16 TB (using 4 KB block size)</li><li class="listitem">XFS = ~8 exabytes</li></ul></div></div>

<div class="book" title="Configuring resources">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec15" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">For this recipe, you will need a volume of at least 2 GB mounted on <code class="email">/vm</code> and access to an NFS server and export.</p><p class="calibre7">We'll use <code class="email">NetworkManager</code> to create a bridge, so ensure that you don't disable <code class="email">NetworkManager</code> and have <code class="email">bridge-utils</code> installed.</p></div></div>

<div class="book" title="Configuring resources">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec16" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's have a look into managing storage pools and networks.</p><div class="book" title="Creating storage pools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>Creating storage pools</h3></div></div></div><p class="calibre7">In order to create<a id="id17" class="calibre1"/> storage pools, we need to provide the necessary details to the KVM for it to be able to create it. You can do this as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a <code class="email">localfs</code> storage pool using <code class="email">virsh</code> on <code class="email">/vm</code>, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-define-as --name localfs-vm --type </strong></span>
<span class="strong"><strong class="calibre8">dir --target /vm</strong></span>
</pre></div></li><li class="listitem" value="2">Create the target for the storage pool through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~# mkdir -p /nfs/vm</strong></span>
</pre></div></li><li class="listitem" value="3">Create an NFS storage pool using <code class="email">virsh</code> on NFS server:<code class="email">/export/vm</code>, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-define-as --name nfs-vm --type network --source-host nfsserver --source-path /export/vm –target /nfs/vm</strong></span>
</pre></div></li><li class="listitem" value="4">Make the storage pools persistent across reboots through the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-autostart localfs-vm</strong></span>
<span class="strong"><strong class="calibre8">~]# virsh pool-autostart nfs-vm</strong></span>
</pre></div></li><li class="listitem" value="5">Start the storage pool, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-start localfs-vm</strong></span>
<span class="strong"><strong class="calibre8">~]# virsh pool-start nfs-vm</strong></span>
</pre></div></li><li class="listitem" value="6">Verify that<a id="id18" class="calibre1"/> the storage pools are created, started, and<a id="id19" class="calibre1"/> persistent across reboots. Run the following for this:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-list</strong></span>
<span class="strong"><strong class="calibre8"> Name                 State      Autostart</strong></span>
<span class="strong"><strong class="calibre8">-------------------------------------------</strong></span>
<span class="strong"><strong class="calibre8"> localfs-vm           active     yes</strong></span>
<span class="strong"><strong class="calibre8"> nfs-vm               active     yes</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="Querying storage pools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Querying storage pools</h3></div></div></div><p class="calibre7">At some point in time, you<a id="id20" class="calibre1"/> will need to know how much space you have left in your storage pool.</p><p class="calibre7">Get the information of the storage pool by executing the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-info --pool &lt;pool name&gt;</strong></span>
<span class="strong"><strong class="calibre8">Name:           nfs-vm</strong></span>
<span class="strong"><strong class="calibre8">UUID:           some UUID</strong></span>
<span class="strong"><strong class="calibre8">State:          running</strong></span>
<span class="strong"><strong class="calibre8">Persistent:     yes</strong></span>
<span class="strong"><strong class="calibre8">Autostart:      yes</strong></span>
<span class="strong"><strong class="calibre8">Capacity:       499.99 GiB</strong></span>
<span class="strong"><strong class="calibre8">Allocation:     307.33 GiB</strong></span>
<span class="strong"><strong class="calibre8">Available:      192.66 GiB</strong></span>
</pre></div><p class="calibre7">As you can see, this command easily shows you its disk space allocation and availability.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">Be careful though; if you use a filesystem that supports sparse files, these numbers will most likely be incorrect. You will have to manually calculate the sizes yourself!</p><p class="calibre7">To detect whether a file is sparse, run <code class="email">ls -lhs</code> against the file. The <code class="email">-s</code> command will show an additional column (the first), showing the exact space that the file is occupying, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# ls -lhs myfile</strong></span>
<span class="strong"><strong class="calibre8">121M -rw-------. 1 root root  30G Jun 10 10:27 myfile</strong></span>
</pre></div></div></div><div class="book" title="Removing storage pools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>Removing storage pools</h3></div></div></div><p class="calibre7">Sometimes, storage is phased out. So, it needs to be removed from the host.</p><p class="calibre7">You have to ensure that<a id="id21" class="calibre1"/> no guest is using volumes on the storage pool before proceeding, and you need to remove all the remaining volumes from the storage pool. Here's how to do this:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Remove the storage volume, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-delete --pool &lt;pool name&gt; --vol &lt;volume name&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">Stop the storage pool through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-destroy --pool &lt;pool name&gt;</strong></span>
</pre></div></li><li class="listitem" value="3">Delete the storage pool using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-delete --pool &lt;pool name&gt;</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="Creating a virtual network"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>Creating a virtual network</h3></div></div></div><p class="calibre7">Before creating the virtual networks, we need to build a bridge over our existing network interface. For the sake of convenience, this NIC will be called <code class="email">eth0</code>. Ensure that you record your current network configuration as we'll destroy it and recreate it on the bridge.</p><p class="calibre7">Unlike the storage<a id="id22" class="calibre1"/> pool, we need to create an XML configuration file to define the networks. There is no command similar to <code class="email">pool-create-as</code> for networks. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a bridge interface on your network's interface, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# nmcli connection add type bridge autoconnect yes con-name bridge-eth0 ifname bridge-eth0</strong></span>
</pre></div></li><li class="listitem" value="2">Remove your NIC's configuration using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# nmcli connection delete eth0</strong></span>
</pre></div></li><li class="listitem" value="3">Configure your bridge, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# nmcli connection modify bridge-eth0 ipv4.addresses &lt;ip address/cidr&gt; ipv4.method manual</strong></span>
<span class="strong"><strong class="calibre8">~# nmcli connection modify bridge-eth0 ipv4.gateway &lt;gateway ip address&gt;</strong></span>
<span class="strong"><strong class="calibre8">~]# nmcli connection modify bridge-eth0 ipv4.dns &lt;dns servers&gt;</strong></span>
</pre></div></li><li class="listitem" value="4">Finally, add your NIC to the bridge by executing the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# nmcli connection add type bridge-slave autoconnect yes con-name slave-eth0 ifname eth0 master bridge-eth0</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre7">For starters, we'll take a look at how we can create a NATed network similar to the one that is configured by default and called the default:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the network XML configuration file, <code class="email">/tmp/net-nat.xml</code>, as follows:<div class="informalexample"><pre class="programlisting">&lt;network&gt;
  &lt;name&gt;NATted&lt;/name&gt;
  &lt;forward mode='nat'&gt;
    &lt;nat&gt;
      &lt;port start='1024' end='65535'/&gt;
    &lt;/nat&gt;
  &lt;/forward&gt;
  &lt;bridge name='virbr0' stp='on' delay='0'/&gt;
  &lt;ip address='192.168.0.1' netmask='255.255.255.0'&gt;
    &lt;dhcp&gt;
      &lt;range start='192.168.0.2' end='192.168.0.254'/&gt;
    &lt;/dhcp&gt;
  &lt;/ip&gt;
&lt;/network&gt;</pre></div></li><li class="listitem" value="2">Define the network in the KVM using the preceding XML configuration file. Execute the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-define /tmp/net-nat.xml</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre7">Now, let's create a<a id="id23" class="calibre1"/> bridged network that can use the network bound to this bridge through the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the network XML configuration file, <code class="email">/tmp/net-bridge-eth0.xml</code>, by running the following:<div class="informalexample"><pre class="programlisting">&lt;network&gt;
    &lt;name&gt;bridge-eth0&lt;/name&gt;
    &lt;forward mode="bridge" /&gt;
    &lt;bridge name="bridge-eth0" /&gt;
&lt;/network&gt;</pre></div></li><li class="listitem" value="2">Create the network in the KVM using the preceding file, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-define /tmp/net-bridge-eth0.xml</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre7">There's one more type of network that is worth mentioning: the isolated network. This network is only accessible to guests defined in this network as there is no connection to the "real" world. </p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create the network XML configuration file, <code class="email">/tmp/net-local.xml</code>, by using the following code:<div class="informalexample"><pre class="programlisting">&lt;network&gt;
  &lt;name&gt;isolated&lt;/name&gt;
  &lt;bridge name='virbr1' stp='on' delay='0'/&gt;
  &lt;domain name='isolated'/&gt;
&lt;/network&gt;</pre></div></li><li class="listitem" value="2">Create the network in KVM by using the above file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-define /tmp/net-local.xml</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre7">Creating networks in this way will register them with the KVM but will not activate them or make them persistent through reboots. So, this is an additional step that you need to perform for each network. Now, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Make the<a id="id24" class="calibre1"/> network persistent across reboots using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-autostart &lt;network name&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">Activate the network, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-start &lt;network name&gt;</strong></span>
</pre></div></li><li class="listitem" value="3">Verify the existence of the KVM network by executing the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-list --all</strong></span>
<span class="strong"><strong class="calibre8"> Name                 State      Autostart     Persistent</strong></span>
<span class="strong"><strong class="calibre8">----------------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre8"> bridge-eth0          active     yes           yes</strong></span>
<span class="strong"><strong class="calibre8"> default              inactive   no            yes</strong></span>
<span class="strong"><strong class="calibre8"> isolated             active     yes           yes</strong></span>
<span class="strong"><strong class="calibre8"> NATted               active     yes           yes</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="Removing networks"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Removing networks</h3></div></div></div><p class="calibre7">On some<a id="id25" class="calibre1"/> occasions, the networks are phased out; in this case, we need to remove the network from our setup.</p><p class="calibre7">Prior to executing this, you need to ensure that no guest is using the network that you want to remove. Perform the following steps to remove the networks:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Stop the network with the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~# virsh net-destroy --network &lt;network name&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">Then, delete the network using this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh net-undefine --network &lt;network name&gt;</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div></div>

<div class="book" title="Configuring resources">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec17" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">It's easy to create<a id="id26" class="calibre1"/> multiple storage pools using the define-pool-as command, as you can see. Every type of storage pool needs more, or fewer, arguments. In the case of the NFS storage pool, we need to specify the NFS server and export. This is done by specifying--source-host and--source-path respectively.</p><p class="calibre7">Creating networks is a bit more complex as it requires you to create a XML configuration file. When you want a network connected transparently to your physical networks, you can only use bridged networks as it is impossible to bind a network straight to your network's interface.</p></div></div>

<div class="book" title="Configuring resources">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec18" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">The storage <a id="id27" class="calibre1"/>backend created in this recipe is not the limit. Libvirt also supports the following backend pools:</p><div class="book" title="Local storage pools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec09" class="calibre1"/>Local storage pools</h3></div></div></div><p class="calibre7">Local storage pools are<a id="id28" class="calibre1"/> directly connected to the physical machine. They include local directories, disks, partitions, and LVM volume groups. Local storage pools are not suitable for enterprises as these do not support live migration.</p></div><div class="book" title="Networked or shared storage pools"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec10" class="calibre1"/>Networked or shared storage pools</h3></div></div></div><p class="calibre7">Network storage pools<a id="id29" class="calibre1"/> include storage shared through standard protocols over a network. This is required when we migrate virtual machines <a id="id30" class="calibre1"/>between physical hosts. The supported network storage protocols are Fibre Channel-based LUNs, iSCSI, NFS, GFS2, and SCSI RDMA.</p><p class="calibre7">By defining the storage pools and networks in libvirt, you ensure the availability of the resources for your guest. If, for some reason, the resource is unavailable, the KVM will not attempt to start the guests that use these resources.</p><p class="calibre7">When checking out the man page for <span class="strong"><em class="calibre9">virsh (1)</em></span>, you will find a similar command to <code class="email">net-define</code>, <code class="email">pool-define</code>: <code class="email">net-create</code>, and <code class="email">pool-create</code> (and <code class="email">pool-create-as</code>). The <code class="email">net-create</code> command, similar to <code class="email">pool-create</code> and <code class="email">pool-create-as</code>, creates transient (or temporary) resources, which will be gone when libvirt is restarted. On the other hand, <code class="email">net-define</code> and <code class="email">pool-define</code> (as also <code class="email">pool-define-as</code>) create persistent (or permanent) resources, which will still be there after you restart libvirt.</p></div></div></div>

<div class="book" title="Configuring resources">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec19" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">You can find out<a id="id31" class="calibre1"/> more on libvirt storage backend pools at <a class="calibre1" href="https://libvirt.org/storage.html">https://libvirt.org/storage.html</a>
</p><p class="calibre7">More information on<a id="id32" class="calibre1"/> libvirt networking can be found at <a class="calibre1" href="http://wiki.libvirt.org/page/Networking">http://wiki.libvirt.org/page/Networking</a>
</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Building guests"><div class="book" id="H5A42-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Building guests</h1></div></div></div><p class="calibre7">After you install and <a id="id33" class="calibre1"/>configure a KVM on the host system, you can create guest operating systems. Every guest is defined by a set of resources and parameters stored in the XML format. When you want to create a new guest, creating such an XML file is quite cumbersome. There are two ways to create a guest:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using <code class="email">virt-manager</code></li><li class="listitem">Using <code class="email">virt-install</code></li></ul></div><p class="calibre7">This recipe will employ the latter as it is perfect for scripting, while <code class="email">virt-manager</code> is a GUI and not very well suited to automate things.</p></div>

<div class="book" title="Building guests">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec20" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In this recipe, we will cover a generic approach to create a new virtual machine using the <code class="email">bridge-eth0</code> network bridge and create a virtual disk on the <code class="email">localfs-vm</code> storage pool, which is formatted as QCOW2. The QCOW2 format is a popular virtual disk format as it allows thin provisioning and snapshotting. We will boot the RHEL 7 installation media located on the <code class="email">localfs-iso</code> storage pool (<code class="email">rhel7-install.iso</code>) to start installing a new RHEL 7 system.</p></div></div>

<div class="book" title="Building guests">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec21" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's create some guests and delete them.</p><div class="book" title="Create a guest"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec11" class="calibre1"/>Create a guest</h3></div></div></div><p class="calibre7">Let's first create a disk<a id="id34" class="calibre1"/> for the guest and then create the guest on this disk, as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a 10 GB QCOW2 format disk in the <code class="email">localfs-vm</code> pool, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-create-as --pool localfs-vm --name rhel7_guest-vda.qcows2 --format qcows2 –capacity 10G</strong></span>
</pre></div></li><li class="listitem" value="2">Create the virtual machine and start it through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virt-install \</strong></span>
<span class="strong"><strong class="calibre8">--hvm \</strong></span>
<span class="strong"><strong class="calibre8">--name rhel7_guest \</strong></span>
<span class="strong"><strong class="calibre8">–-memory=2048,maxmemory=4096 \</strong></span>
<span class="strong"><strong class="calibre8">--vcpus=2,maxvcpus=4 \</strong></span>
<span class="strong"><strong class="calibre8">--os-type linux \</strong></span>
<span class="strong"><strong class="calibre8">--os-variant rhel7 \</strong></span>
<span class="strong"><strong class="calibre8">--boot hd,cdrom,network,menu=on \</strong></span>
<span class="strong"><strong class="calibre8">--controller type=scsi,model=virtio-scsi \</strong></span>
<span class="strong"><strong class="calibre8">--disk device=cdrom,vol=localfs-iso/rhel7-install.iso,readonly=on,bus=scsi \</strong></span>
<span class="strong"><strong class="calibre8">--disk device=disk,vol=localfs-vm/rhel7_guest-vda.qcow2,cache=none,bus=scsi \</strong></span>
<span class="strong"><strong class="calibre8">--network network=bridge-eth0,model=virtio \</strong></span>
<span class="strong"><strong class="calibre8">--graphics vnc \</strong></span>
<span class="strong"><strong class="calibre8">--graphics spice \</strong></span>
<span class="strong"><strong class="calibre8">--noautoconsole \</strong></span>
<span class="strong"><strong class="calibre8">--memballoon virtio</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="Deleting a guest"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec12" class="calibre1"/>Deleting a guest</h3></div></div></div><p class="calibre7">At some point, you'll need<a id="id35" class="calibre1"/> to remove the guests. You can do this as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, ensure that the guest is down by running the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh list –all</strong></span>
<span class="strong"><strong class="calibre8"> Id    Name                           State</strong></span>
<span class="strong"><strong class="calibre8">----------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre8">-     rhel7_guest                     shut off</strong></span>
</pre></div><p class="calibre13">If the state is not <code class="email">shut off</code>, you can forcefully shut it down:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh destroy --domain &lt;guest name&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">List the storage volumes in use by your guest and copy this somewhere:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh domblklist &lt;guest name&gt;</strong></span>
<span class="strong"><strong class="calibre8">Type       Device     Target     Source</strong></span>
<span class="strong"><strong class="calibre8">------------------------------------------------</strong></span>
<span class="strong"><strong class="calibre8">file       disk       vda        /vm/rhel7_guest-vda.qcow2</strong></span>
<span class="strong"><strong class="calibre8">file       cdrom      hda        /iso/rhel7-install.iso</strong></span>
</pre></div></li><li class="listitem" value="3">Delete the guest through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh undefine --domain &lt;guest name&gt; --storage vda</strong></span>
</pre></div><p class="calibre13">Adding <code class="email">--remove-all-storage</code> to the command will wipe off the data on the storage volumes dedicated to this guest prior to deleting the volume from the pool.</p></li></ol><div class="calibre14"/></div></div></div></div>

<div class="book" title="Building guests">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec22" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The <code class="email">virt-install</code> command supports creating storage volumes (disks) by specifying the pool, size, and<a id="id36" class="calibre1"/> format. However, if this storage volume already exists, the application will fail. Depending on the speed of your KVM host disks (local or network) and the size of the guest's disks, the process <a id="id37" class="calibre1"/>of creating a new disk may take some time to be completed. By specifying an existing disk with <code class="email">virt-install</code>, you can reuse the disk should you need to reinstall the guest. It would be possible to only create the disk on the first pass and change your command line appropriately after this. However, the fact remains that using <code class="email">virsh vol-create-as</code> gives you more granular control of what you want to do.</p><p class="calibre7">We're using the QCOW2 format to contain the guest's disk as it is a popular format when it comes to storing KVM guest disks. This is because it supports thin provisioning and snapshotting.</p><p class="calibre7">When creating the guest, we specify both the <code class="email">maxmemory</code> option for memory configuration and the <code class="email">maxvcpus</code> option for vcpus configuration. This will allow us to add CPUs and RAM to the guest while it is running. If we do not assign these, we'll have to shut down the system before being able to change the XML configuration using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~# virsh edit &lt;hostname&gt;</strong></span>
</pre></div><p class="calibre7">As you can see, we're using the <code class="email">virtio</code> driver for any hardware (network, disks, or balloon) that supports it as it is native to the KVM and is included in the RHEL 7 kernel.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre7">If, for some reason, your guest OS doesn't support <code class="email">virtio</code> drivers, you should remove the <code class="email">--controller</code> option of the command line and the bus specification from the <code class="email">--disk</code> option.</p><p class="calibre7">For more information on<a id="id38" class="calibre1"/> <code class="email">virtio</code> support, go to <a class="calibre1" href="http://wiki.libvirt.org/page/Virtio">http://wiki.libvirt.org/page/Virtio</a>.</p></div><p class="calibre7">The <code class="email">--memballoon</code> option will ensure that we do not run into problems when we overcommit our memory. When specific guests require more memory, the ballooning driver will ensure that the "idle" guests' memory can be evenly redistributed.</p><p class="calibre7">The <code class="email">graphics</code> option will allow you to connect to the guest through the host using either VNC (which is a popular client to control remote computers) or spice (which is the default client for <code class="email">virt-manager</code>). The configuration for both VNC and spice is insecure, though. You can either set this up by specifying a password—by adding <code class="email">password=&lt;password&gt;</code> to each graphics stanza—or by editing the <code class="email">/etc/libvirt/qemu.conf</code> file on the KVM host, which will be applied to all guests.</p></div></div>

<div class="book" title="Building guests">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec23" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">In this recipe, we used "local" install media in the form of an ISO image to install the system. However, it is also possible<a id="id39" class="calibre1"/> to install a guest without a CD, DVD, or an ISO image. The <code class="email">--location</code> installation method option allows you to specify a URI that contains your kernel/initrd pair, which is required to start the installation.</p><p class="calibre7">Using <code class="email">--location</code> in combination with <code class="email">--extra-args</code> will allow you to specify kernel command-line arguments to pass to the installer. This can be used, for instance, to pass on the location of an Anaconda kickstart file for automated installs and/or specifying your IP configuration during the installer.</p></div></div>

<div class="book" title="Building guests">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec24" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">Check the man page of <span class="strong"><em class="calibre9">virt-install (1)</em></span> for more information on how to use it to your advantage.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding CPUs on the fly" id="I3QM1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Adding CPUs on the fly</h1></div></div></div><p class="calibre7">Imagine an <a id="id40" class="calibre1"/>enterprise having to correctly add dimension to all their systems right from the start. In my experience, this is very difficult. You will either underdimension it, and your customers will complain about performance at some point, or you will overdimension it, and then the machine will sit there, idling about, which is not optimal either. This is the reason hardware vendors have come up with <code class="email">hot-add</code> resources. This allows a system to have its CPUs, memory, and/or disks to be upgraded/increased without the need for a shutdown. A KVM implements a similar functionality for its guests. It allows you to increase the CPUs, memory, and disks on the fly.</p><p class="calibre7">The actual recipe is very simple to execute, but there are some prerequisites to be met.</p></div>

<div class="book" title="Adding CPUs on the fly" id="I3QM1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec25" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In order to be able to add CPUs on the fly to a guest, the guest's configuration must support them.</p><p class="calibre7">There are two ways to achieve this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">It must be created with the max option, as follows:<div class="informalexample"><pre class="programlisting">--vcpus 2,maxvcpus=4</pre></div></li><li class="listitem">You can set the maximum using <code class="email">virsh</code> (which will be applied at the next boot) through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh setvcpus --domain &lt;guestname&gt; --count &lt;max cpu count&gt; --config --maximum</strong></span>
</pre></div></li><li class="listitem">You can edit the guests' XML files, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh edit &lt;guestname&gt;</strong></span>
</pre></div></li></ul></div><p class="calibre7">The last two options<a id="id41" class="calibre1"/> will require you to shut down and boot (not reboot) your guest as these commands cannot change the "live" configuration.</p><p class="calibre7">The guest's XML file must contain the following element with the subsequent attributes:</p><div class="informalexample"><pre class="programlisting">&lt;domain type='kvm'&gt;
...
&lt;vcpu current='2'&gt;4&lt;/vcpu&gt;
...
&lt;/domain&gt;</pre></div><p class="calibre7">Here, <code class="email">current</code> indicates the number of CPUs in use, and the number within the node indicates the maximum number of vCPUs that can be assigned. This number can be increased but should never exceed the number of cores or threads in your host.</p></div></div>

<div class="book" title="Adding CPUs on the fly" id="I3QM1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec26" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's add some CPUs to the guest.</p><div class="book" title="On the KVM host, perform the following steps:"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec13" class="calibre1"/>On the KVM host, perform the following steps:</h3></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Get the maximum <a id="id42" class="calibre1"/>number vCPUs that you can assign, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh dumpxml &lt;guestname&gt; |grep vcpu</strong></span>
<span class="strong"><strong class="calibre8">&lt;vcpu placement='static' current='4'&gt;8&lt;/vcpu&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">Now, set the new number of vCPUs through this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh setvcpus --domai</strong></span>
<span class="strong"><strong class="calibre8">n &lt;guestname&gt; --count &lt;# of CPUs&gt; --live</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div><div class="book" title="On the KVM guest, perform the following:"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec14" class="calibre1"/>On the KVM guest, perform the following:</h3></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Tell your guest<a id="id43" class="calibre1"/> OS there are more CPUs available by executing the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# for i in $(grep -H 0 /sys/devices/system/cpu/cpu*/online | awk -F: '{print $1}'); do echo 1 &gt; $i; done</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding RAM on the fly" id="J2B81-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Adding RAM on the fly</h1></div></div></div><p class="calibre7">As with CPUs, the possibility to add memory on the fly is an added value in mission-critical environments where downtime can literally cost a company millions of Euros.</p><p class="calibre7">The recipe<a id="id44" class="calibre1"/> presented here is quite simple, similar to the one on CPUs. Here, your guest needs to be prepared to use this functionality as well.</p></div>

<div class="book" title="Adding RAM on the fly" id="J2B81-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec27" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">If you want to be able to add memory on the fly to a guest, it must be configured to support it. As with the CPU, this has to be activated. There are three ways to do this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The guest must be created with the <code class="email">maxmem</code> option, as follows:<div class="informalexample"><pre class="programlisting">--memory 2G,maxmemory=4G</pre></div></li><li class="listitem">You can set the maximum memory using the <code class="email">virsh</code> command, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh setmaxmem --domain &lt;guestname&gt; --size &lt;max mem&gt; --live</strong></span>
</pre></div></li><li class="listitem">You can edit the guests' XML files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh edit &lt;guestname&gt;</strong></span>
</pre></div></li></ul></div><p class="calibre7">Of course, the latter 2 option requires you to shut down the guest, which is not always possible in production environments.</p><p class="calibre7">Ensure that the guests' XML configuration files contain the following elements with the subsequent attributes:</p><div class="informalexample"><pre class="programlisting">&lt;domain type='kvm'&gt;
...
    &lt;memory unit='KiB'&gt;4194304&lt;/memory&gt;
    &lt;currentMemory unit='KiB'&gt;2097152&lt;/currentMemory&gt;
...
&lt;/domain&gt;</pre></div></div></div>

<div class="book" title="Adding RAM on the fly" id="J2B81-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec28" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's increase the guest's memory.</p><p class="calibre7">On the KVM host, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Get the current and maximum memory allocation for a guest, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh dumpxml srv00002 |grep -i memory</strong></span>
<span class="strong"><strong class="calibre8">  &lt;memory unit='KiB'&gt;4194304&lt;/memory&gt;</strong></span>
<span class="strong"><strong class="calibre8">  &lt;currentMemory unit='KiB'&gt;4194304&lt;/currentMemory&gt;</strong></span>
</pre></div></li><li class="listitem" value="2">Set the new amount of memory for the guest by executing the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh setmem --domain &lt;guestname&gt; --size &lt;memory&gt; --live</strong></span>
</pre></div></li></ol><div class="calibre14"/></div><p class="calibre7">On the KVM guest, perform the following:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Tell your guest OS <a id="id45" class="calibre1"/>about the memory increase through this command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# for i in $(grep -H offline /sys/devices/system/memory/memory*/state | awk -F: '{print $1}'); do echo online &gt; $i; done</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Adding disks on the fly" id="K0RQ1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Adding disks on the fly</h1></div></div></div><p class="calibre7">This recipe includes<a id="id46" class="calibre1"/> instructions on how to create different types of storage volumes. Storage volumes are dedicated storage sets aside for use by guests.</p></div>

<div class="book" title="Adding disks on the fly" id="K0RQ1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec29" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">There is not a lot of preparation to be done in order to add disks to your guest, which is in contrast to adding CPUs and RAM.</p><p class="calibre7">You only need to ensure that the storage pool has enough free disk space to accommodate the new disk.</p></div></div>

<div class="book" title="Adding disks on the fly" id="K0RQ1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec30" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Similar to the recipe for creating guests, you'll need to create a disk first. This can be done as follows:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's create a raw disk in the <code class="email">localfs-vm</code> pool that is <code class="email">30</code> GB big through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-create-as --pool localfs-vm --name rhel7_guest-vdb.raw --format raw --capacity 30G</strong></span>
</pre></div></li><li class="listitem" value="2">Look up the path of the newly created volume, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-list --pool localfs-vm |awk '$1 ~ /^rhel7_guest-vdb.raw$/ {print $2}'</strong></span>
</pre></div><p class="calibre13">This will result in the path of your volume; here's an example:</p><div class="informalexample"><pre class="programlisting">
<code class="email">/vm/rhel7_guest-vdb.raw</code>
</pre></div></li><li class="listitem" value="3">Attach the disk to the guest, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh attach-disk --domain &lt;guestname&gt; --source &lt;the above path&gt; --target vdb --cache none --persistent –live</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Adding disks on the fly" id="K0RQ1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec31" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Creating a disk using <code class="email">vol-create-as</code> may take some time depending on the speed of your host's disks and the size of the guest's disks.</p><p class="calibre7">We will look up the path of the newly created volume as it is a required argument for the command that attaches the disk to the guest. In most cases, you won't need to do this as you'll know how <a id="id47" class="calibre1"/>your host is configured, but when you script this kind of functionality, you will require this step.</p><p class="calibre7">Adding a disk in this way will attach a disk using the <code class="email">virtio</code> driver, which, as specified earlier, is optimized for use with KVMs.</p></div></div>

<div class="book" title="Adding disks on the fly" id="K0RQ1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec32" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">If, for some reason, the original guest doesn't support <code class="email">virtio</code> drivers or you do not have the <code class="email">virtio</code> controller, you can create this yourself. Store the XML configuration file as <code class="email">/tmp/controller.xml</code> with the following contents:</p><div class="informalexample"><pre class="programlisting">&lt;controller type='scsi' model='virtio' /&gt;</pre></div><p class="calibre7">You can find this out by checking the host's XML file for the preceding statement.</p><p class="calibre7">Then, import the XML configuration file, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh attach-device –domain &lt;guestname&gt; /tmp/controller.xml</strong></span>
</pre></div><p class="calibre7">This will allow you to create disks using <code class="email">virtio</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Moving disks to another storage" id="KVCC1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Moving disks to another storage</h1></div></div></div><p class="calibre7">Moving disks around is part of the life cycle of a guest. Disks in the storage pools (local or network) may<a id="id48" class="calibre1"/> fail or fill up due to bad capacity management. Another reason may be the cost or speed of the disks involved. Sooner or later, one of these things will happen, and then you will need to move the storage somewhere else.</p><p class="calibre7">Ordinarily, one would have to shut down the guest, copy the storage volume file elsewhere (if it is a file), wait, update the machine's XML configuration, and launch it again. However, in today's mission-critical enterprises, this may not always be possible.</p></div>

<div class="book" title="Moving disks to another storage" id="KVCC1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec33" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">In order to perform this copy, you need the source and destination paths of the disk. You can get the source path by checking the XML configuration file or, even better, by querying the storage volume itself. This does require you to know which storage pool it is located on.</p><p class="calibre7">Execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-list --pool &lt;storage pool&gt; |awk '$1 ~ /^&lt;volume name&gt;$/ {print $2}'</strong></span>
</pre></div><p class="calibre7">Ensure that your destination is an existing storage pool; if not, go ahead and create it.</p><p class="calibre7">Check out the <span class="strong"><em class="calibre9">Configuring resources</em></span> recipe in this chapter to create storage pools.</p><p class="calibre7">If you can't remember the path to your pool's location, run the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh pool-dumpxml &lt;poolname&gt; |awk '/&lt;path&gt;.*&lt;\/path&gt;/ {print $1}'</strong></span>
</pre></div></div></div>

<div class="book" title="Moving disks to another storage" id="KVCC1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec34" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Moving disks can<a id="id49" class="calibre1"/> take some time, so ensure that you have plenty of time available. Perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Dump the inactive XML configuration file for the guest, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh dumpxml --inactive &lt;guestname&gt; &gt; /tmp/&lt;guestname&gt;.xml</strong></span>
</pre></div><p class="calibre13">The <code class="email">–-inactive</code> file will ensure that it doesn't copy any temporary information that is irrelevant to the guest.</p></li><li class="listitem" value="2">Undefine the guest through the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh undefine &lt;guestname&gt;</strong></span>
</pre></div></li><li class="listitem" value="3">Copy the virtual disk to another location by executing the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh blockcopy --domain &lt;guestname&gt; --path &lt;original path&gt; --dest &lt;destination path&gt; --wait --verbose –-pivot</strong></span>
</pre></div></li><li class="listitem" value="4">Now, edit the guest's XML configuration file and change the path of the disk to the new location.</li><li class="listitem" value="5">Redefine the guest, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh define /tmp/&lt;guestname&gt;.xml</strong></span>
</pre></div></li><li class="listitem" value="6">Remove the source disk after you are happy with the results. Run the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh vol-delete --pool &lt;poolname&gt; --vol &lt;volname&gt;</strong></span>
</pre></div></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Moving disks to another storage" id="KVCC1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec35" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The moving of disks can only be performed on transient domains, which is the reason we execute the <code class="email">virsh undefine</code> command. In order to be able to make it persistent again after the transfer, we also need to dump the XML configuration file and modify the storage volume path.</p><p class="calibre7">Moving the disk does<a id="id50" class="calibre1"/> two things, which are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Firstly, it copies all the data of the source to the destination</li><li class="listitem">Secondly, when the copying is complete, both source and destination remain mirrored until it is either canceled with <code class="email">blockjob --abort</code> or actually switched over to the new target by executing the <code class="email">blockjob --pivot</code> command</li></ul></div><p class="calibre7">The preceding <code class="email">blockcopy</code> command does everything at the same time. The <code class="email">--wait</code> command will not give control back to the user until the command fails or succeeds. It is essentially the same as the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh blockcopy --domain &lt;guestname&gt; --path &lt;source path&gt; --dest &lt;destination path&gt;</strong></span>
</pre></div><p class="calibre7">Monitor the progress of the copy by executing the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# watch -n10 "virsh blockjob –domain &lt;guestname&gt; --path &lt;source path&gt; --info"</strong></span>
</pre></div><p class="calibre7">When it's done, execute this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh blockjob –domain &lt;guestname&gt; --path &lt;source path&gt; --pivot</strong></span>
</pre></div></div></div>

<div class="book" title="Moving disks to another storage" id="KVCC1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec36" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">It is also possible to change the disk format on the fly, by specifying the <code class="email">--format</code> argument with the format that you want to convert your disk into. If you want to copy it to a block device, specify <code class="email">--blockdev</code>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec17" class="calibre1"/>Moving VMs</h1></div></div></div><p class="calibre7">Moving disks will mitigate the risk of failing disks. When your CPUs, memory, and other non-disk-related components start failing, you have no other option but to move the guests to other host(s).</p><p class="calibre7">The recipe<a id="id51" class="calibre1"/> for this task is rather simple, but it's the prerequisites that can make it succeed or fail miserably.</p></div>

<div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec37" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">The prerequisites for this recipe are quite extended.</p><p class="calibre7">For the host, the following are the requirements:</p><div class="book"><ul class="itemizedlist"><li class="listitem">You'll need to have access to shared data. Both the source and destination KVM machine will need to be able to access the same storage—for example, iSCSI, NFS, and so on.</li><li class="listitem">Both hosts need the same type of CPU—that is, Intel or AMD (one cannot live migrate a guest from a host with Intel CPUs to a host with AMD CPUs).</li><li class="listitem">Both hosts need to be installed with the same version and updates of libvirt.</li><li class="listitem">Both hosts need to have the same network ports open.</li><li class="listitem">Both hosts must have identical KVM network configurations or at least the same network configurations for the interfaces used by the guest.</li><li class="listitem">Both hosts must be accessible through the network.</li><li class="listitem">It's a good idea<a id="id52" class="calibre1"/> to have a management network set up and connected to the two hosts, which can be used for data transfer. This will cause less network traffic on your "production" network and increase the overall speed.</li><li class="listitem">The <code class="email">No execution</code> bit must be the same on both hosts.</li></ul></div><p class="calibre7">The requirement for the guest is:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The <code class="email">cache=none</code> must be specified for all block devices that are opened in write mode.</li></ul></div></div></div>

<div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec38" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">There are multiple ways to migrate hosts, but we will only highlight the two most common ways.</p><div class="book" title="Live native migration over the default network"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec15" class="calibre1"/>Live native migration over the default network</h3></div></div></div><p class="calibre7">This process to <a id="id53" class="calibre1"/>migrate a host is luckily very simple and can be summarized in one command.</p><p class="calibre7">On the source host, execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh migrate --domain &lt;guestname&gt; --live –-persistent --undefinesource --verbose --desturl qemu+ssh://&lt;host 2&gt;/system</strong></span>
</pre></div></div><div class="book" title="Live native migration over a dedicated network"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec16" class="calibre1"/>Live native migration over a dedicated network</h3></div></div></div><p class="calibre7">It is possible to perform the <a id="id54" class="calibre1"/>migration over a dedicated network. By default, this will use the first network it finds that suits it needs. You'll need to specify the listening address (on the host) and the protocol. This requires the same command as before, but we'll need to specify the local listening IP address and protocol, such as TCP.</p><p class="calibre7">On the source host, execute the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# virsh migrate --domain &lt;guestname&gt; --live –-persistent --undefinesource --verbose --desturl qemu+ssh://&lt;host 2&gt;/system tcp://&lt;local ip address on dedicated network&gt;/</strong></span>
</pre></div></div></div></div>

<div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec39" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">This type <a id="id55" class="calibre1"/>of migration is called a "hypervisor native" transport. The biggest advantage of this type of migration is that it incurs the lowest computational cost by minimizing the number of data copies involved.</p><p class="calibre7">When we migrate a host, it performs a copy of the memory of the guest to the new host. When the copying is successful, it kills the guest on the source host and starts it on the new host. As the memory is copied, the interruption will be very short-lived.</p></div></div>

<div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec40" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Communication between the two hosts is over SSH, which is already pretty secure. However, it's also possible to tunnel the data over an even more strongly encrypted channel by specifying the <code class="email">--tunnelled</code> option. This will impose more traffic on your network as there will be extra data communication between the two hosts.</p><p class="calibre7">The <code class="email">--compress</code> option can help you out if you wish to reduce the traffic over your network, but this will increase the load on both your hosts as they need to compress/decompress the data, which, in turn, may impact your guests performance. If time is not of the essence but traffic is, this is a good solution.</p></div></div>

<div class="book" title="Moving VMs" id="LTSU1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec41" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">There's very good <a id="id56" class="calibre1"/>and in-depth documentation about this process at <a class="calibre1" href="https://libvirt.org/migration.html">https://libvirt.org/migration.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Backing up your VM metadata" id="MSDG1-501a83dd54944cb1bf060a2ce9fab11f"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec18" class="calibre1"/>Backing up your VM metadata</h1></div></div></div><p class="calibre7">While a KVM <a id="id57" class="calibre1"/>stores some of the resources' configuration on the disk in a human readable format, it is a good idea to query libvirt for the configuration of your resources.</p></div>

<div class="book" title="Backing up your VM metadata" id="MSDG1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec42" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">In this recipe we'll back up all relevant KVM metadata by performing the following steps:</p><p class="calibre7">Here's the network configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# for i in $(virsh net-list --all | sed -e '1,2d' |awk '{print $1}'); do \</strong></span>
<span class="strong"><strong class="calibre8">    virsh net-dumpxml --network $i --inactive &gt; /tmp/net-$i.xml; \</strong></span>
<span class="strong"><strong class="calibre8">done</strong></span>
</pre></div><p class="calibre7">Here's the storage configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# for i in $(virsh pool-list --all | sed -e '1,2d' |awk '{print $1}'); do \</strong></span>
<span class="strong"><strong class="calibre8">    for j in $(virsh vol-list --pool $i |sed -e '1,2d') | awk '{print $1}'; do \</strong></span>
<span class="strong"><strong class="calibre8">        virsh vol-dumpxml --pool $i --vol $j &gt; /tmp/vol-$j.xml; \</strong></span>
<span class="strong"><strong class="calibre8">    done \</strong></span>
<span class="strong"><strong class="calibre8">    virsh pool-dumpxml --pool $i --inactive &gt; /tmp/pool-$i.xml; \</strong></span>
<span class="strong"><strong class="calibre8">done</strong></span>
</pre></div><p class="calibre7">Here's the guest configuration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">~]# for i in $(virsh list --all | sed -e '1,2d' |awk '{print $1}'); do \</strong></span>
<span class="strong"><strong class="calibre8">    virsh dumpxml --domain $i --inactive &gt; /tmp/domain-$i.xml; \</strong></span>
<span class="strong"><strong class="calibre8">done</strong></span>
</pre></div></div></div>

<div class="book" title="Backing up your VM metadata" id="MSDG1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec43" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">The <code class="email">virsh net-dumpxml</code> command allows you to dump the precise configuration of the specified network. In combination with <code class="email">virsh net-list</code>, you can create a loop that enumerates all <a id="id58" class="calibre1"/>networks and dumps them on the file. By specifying <code class="email">–-all</code>, you will export all networks, even those that are not active. If you do not wish to back up the configuration for nonactive networks, substitute <code class="email">virsh net-list --all</code> with <code class="email">virsh net-list</code>.</p><p class="calibre7">Storage pools can be enumerated, similarly to networks, using <code class="email">virsh net-list</code>. However, besides the individual storage pool configuration, we are also interested in the configuration of individual storage volumes. Luckily, both implement a <code class="email">list</code> and <code class="email">dumpxml</code> command! If you're not interested in nonactive pools, you can omit the <code class="email">--all</code> option with <code class="email">virsh pool-list</code>.</p><p class="calibre7">Guests can similarly be enumerated and their XML configuration dumped using <code class="email">dumpxml</code>. Again, if you're not interested in nonactive guests, you can omit the <code class="email">--all</code> option with <code class="email">virsh list</code>.</p></div></div>

<div class="book" title="Backing up your VM metadata" id="MSDG1-501a83dd54944cb1bf060a2ce9fab11f">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec44" class="calibre1"/>See also</h2></div></div></div><p class="calibre7">The man page for <span class="strong"><em class="calibre9">virsh (1)</em></span> lists all the possible options for the commands used in the preceding section.</p></div></div></body></html>