<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Setting Up Separate Roles</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing SELinux users</li><li class="listitem" style="list-style-type: disc">Mapping Linux users to SELinux users</li><li class="listitem" style="list-style-type: disc">Running commands in a specified role with sudo</li><li class="listitem" style="list-style-type: disc">Running commands in a specified role with runcon</li><li class="listitem" style="list-style-type: disc">Switching roles</li><li class="listitem" style="list-style-type: disc">Creating a new role</li><li class="listitem" style="list-style-type: disc">Initial role based on entry</li><li class="listitem" style="list-style-type: disc">Defining role transitions</li><li class="listitem" style="list-style-type: disc">Looking into access privileges</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Introduction</h1></div></div></div><p>Roles provide <a id="id404" class="indexterm"/>a flexible, manageable approach to grant multiple users the proper rights. Instead of assigning privileges to individual users, roles are created to which privileges are granted. Users are then granted the role and inherit the privileges associated with this role.</p><p>In SELinux, roles are used to grant access to domains. An application domain that is used to manage certificates on a system is assigned to one or more roles, thus allowing users with that role to possibly transition into that application domain. If the user role does not have this privilege, then the necessary permissions to manage certificates through that application domain are not accessible for the user.</p><p>The following diagram shows the relation between Linux logins (regular Linux accounts), SELinux users, SELinux roles, and SELinux domains:</p><div><img src="img/9669OS_06_01.jpg" alt="Introduction"/></div><p>To assign roles to users, Linux accounts are first mapped to an SELinux user. An SELinux user defines <a id="id405" class="indexterm"/>which roles are accessible (as users can have multiple roles assigned) as well as which security clearance the user can have at most (although lower security clearances can be assigned to users individually as well).</p><p>On systems where SELinux is primarily meant to confine network-facing services and not the users, this chapter will have little value. All users on these systems are mapped to the <code class="literal">unconfined_u</code> SELinux user, which has a default user domain of <code class="literal">unconfined_t</code> and is meant to be almost unrestricted—hence, the name, unconfined. When this is applicable, most distributions call the SELinux policy store <strong>targeted</strong> to reflect that the confinement is<a id="id406" class="indexterm"/> targeting specific applications and not the entire system.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Managing SELinux users</h1></div></div></div><p>In order <a id="id407" class="indexterm"/>to grant a Linux login the right set of roles, we first need to create an SELinux user that has just those roles assigned. Existing SELinux users can be modified easily, and if an SELinux user was added previously, it can be removed from the system as well.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>How to do it…</h2></div></div></div><p>Managing SELinux users is done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Use <code class="literal">semanage user</code> to list the currently available SELinux users:<div><pre class="programlisting">
<strong>~# semanage user -l</strong>
<strong>                Labeling   MLS/       MLS/</strong>
<strong>SELinux User    Prefix     MCS Level  MCS Range                      SELinux Roles</strong>

<strong>git_shell_u     user       s0         s0                             git_shell_r</strong>
<strong>guest_u         user       s0         s0                             guest_r</strong>
<strong>root            user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</strong>
<strong>staff_u         user       s0         s0-s0:c0.c1023                 staff_r sysadm_r system_r unconfined_r</strong>
<strong>sysadm_u        user       s0         s0-s0:c0.c1023                 sysadm_r</strong>
<strong>system_u        user       s0         s0-s0:c0.c1023                 system_r unconfined_r</strong>
<strong>unconfined_u    user       s0         s0-s0:c0.c1023                 system_r unconfined_r</strong>
<strong>user_u          user       s0         s0                             user_r</strong>
<strong>xguest_u        user       s0         s0                             xguest_r</strong>
</pre></div></li><li class="listitem">If no<a id="id408" class="indexterm"/> SELinux user exists yet, with the right set of roles, create it with <code class="literal">semanage user</code>. For instance, to create a database administration SELinux user, run the following command:<div><pre class="programlisting">
<strong>~# semanage user -a -R "staff_r dbadm_r" dbadm_u</strong>
</pre></div></li><li class="listitem">Existing users can be modified as follows:<div><pre class="programlisting">
<strong>~# semanage user -m -R "staff_r dbadm_r" staff_u</strong>
</pre></div></li><li class="listitem">An SELinux user can also be removed from the system:<div><pre class="programlisting">
<strong>~# semanage user -d dbadm_u</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec129"/>How it works…</h2></div></div></div><p>When an SELinux user is created, SELinux will update its configuration files at <code class="literal">/etc/selinux/</code> to include support for this SELinux user. It is a general best practice to name SELinux <a id="id409" class="indexterm"/>users after their functional purpose, so a <strong>database administrator</strong> (<strong>DBA</strong>) is called <code class="literal">dbadm_u</code>, whereas a website administrator is called <code class="literal">webadm_u</code>.</p><p>The set of roles that are available to the administrator can be obtained using <code class="literal">seinfo</code>:</p><div><pre class="programlisting">
<strong>~# seinfo -r</strong>
</pre></div><p>Existing SELinux users can be modified. However, it is important that logged-in users are logged out (and perhaps temporarily locked) from the system during the change. Otherwise, the SELinux policy could suddenly mark their session as having an invalid context and interrupt those users in their operations.</p><p>When an<a id="id410" class="indexterm"/> SELinux user is removed from the system, it is also important that all the remaining files that have this SELinux user in their context are relabeled. Otherwise, these files (and other resources) are labeled with an invalid context, making the files and resources inaccessible to others.</p><p>Once an SELinux user is created, it is ready to be assigned to one or more Linux users.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec130"/>There's more...</h2></div></div></div><p>With SELinux users, MLS settings can be provided as well. For instance, to set a specific security clearance, the following command is used:</p><div><pre class="programlisting">
<strong>~# semanage user -a -r s0-s0:c0.c110 dbadm_u</strong>
</pre></div><p>For an SELinux user, this is the upper limit of the security clearance that a users' context can be in. When we assign users to an SELinux user, it is possible to force a lower security clearance individually so that there is no need to create separate SELinux users for every difference in security clearance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Mapping Linux users to SELinux users</h1></div></div></div><p>With<a id="id411" class="indexterm"/> the SELinux users available, we can now<a id="id412" class="indexterm"/> map Linux users to SELinux users. This will ensure that the users, when logged in to the system, are assigned a default context aligned with this SELinux user.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec131"/>How to do it…</h2></div></div></div><p>In order to map Linux users to SELinux users, the following steps can be taken:</p><div><ol class="orderedlist arabic"><li class="listitem">List the existing mappings with <code class="literal">semanage login</code>:<div><pre class="programlisting">
<strong>~# semanage login -l</strong>
<strong>Login Name           SELinux User              MLS/MCS Range</strong>

<strong>__default__          user_u                    s0-s0:c0.c1023</strong>
<strong>root                 root                      s0-s0:c0.c1023</strong>
<strong>system_u             system_u                  s0-s0:c0.c1023</strong>
<strong>%wheel               sysadm_u                  s0-s0:c0.c1023</strong>
</pre></div></li><li class="listitem">For an individual user account, map the account to an SELinux user with <code class="literal">semanage login</code>:<div><pre class="programlisting">
<strong>~# semanage login -a -s dbadm_u user1</strong>
</pre></div></li><li class="listitem">It is also possible to assign a group of users to an SELinux user through their primary Linux group. For instance, if a <code class="literal">dba</code> group exists, it can be assigned to an SELinux user as follows:<div><pre class="programlisting">
<strong>~# semanage login -a -s dbadm_u %dba</strong>
</pre></div></li><li class="listitem">Mappings <a id="id413" class="indexterm"/>can be modified easily:<div><pre class="programlisting">
<strong>~# semanage login -m -s webadm_u user1</strong>
</pre></div></li><li class="listitem">If a mapping is no longer needed, it can be removed as well:<div><pre class="programlisting">
<strong>~# semanage login -d user1</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec132"/>How it works…</h2></div></div></div><p>The <code class="literal">semanage login</code> application manages the <code class="literal">seusers</code> file in <code class="literal">/etc/selinux/</code>. This file is<a id="id414" class="indexterm"/> used by SELinux's <code class="literal">pam_selinux.so</code> authentication library that is called when a user logs in to a system. Upon invocation, SELinux will check the <code class="literal">seusers</code> file to see which SELinux user a Linux account is mapped to. It will then perform an SELinux context switch so that the rest of the login process (including the shell or graphical environment that is launched) will have the right SELinux context assigned to it.</p><p>Creating login mappings does not influence the existing sessions, so if a user is already logged in, it is wise to have the user log out first. Also, any files created by the user in the past might have a wrong SELinux user associated with them. Any login that isn't specifically mentioned will be assigned a default SELinux user. If the SELinux user changes, then the files owned by this Linux login will suddenly have a wrong SELinux user set. If the user-based access control feature in SELinux is enabled, then these files will not be accessible anymore by the user. In this case, the administrator will need to relabel the files forcefully (which includes resetting the SELinux user):</p><div><pre class="programlisting">
<strong>~# restorecon -RF /home/user1</strong>
</pre></div><p>In case of both user mappings and group-based mappings, the first mapping that is mentioned in the <code class="literal">seusers</code> file that matches a particular login is used.</p><p>When a user logs in and no mapping matches the login itself (either through a direct match against a Linux account name or through a group membership), then SELinux will look at the login mapping for the <code class="literal">__default__</code> user. This is a special rule that acts as a fallback rule. On systems with unconfined users, the <code class="literal">__default__</code> user is usually mapped to the <code class="literal">unconfined_u</code> SELinux user. On systems without unconfined users, <code class="literal">__default__</code> usually maps to the (unprivileged) <code class="literal">user_u</code> SELinux user.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Running commands in a specified role with sudo</h1></div></div></div><p>When a<a id="id415" class="indexterm"/> user has been assigned multiple roles, they usually <a id="id416" class="indexterm"/>work with their primary role (such as <code class="literal">staff_r</code>) and only selectively execute commands with the other role. This can be accomplished through the <code class="literal">sudo</code> command, as these commands usually also require a different Linux user (which can be <code class="literal">root</code> or the <code class="literal">postgresql</code> account for DBA tasks on the PostgreSQL database server).</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec133"/>How to do it…</h2></div></div></div><p>In order to configure <code class="literal">sudo</code> to perform the right role and type transition, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open up the <code class="literal">sudoers</code> file through <code class="literal">visudo</code>:<div><pre class="programlisting">
<strong>~# visudo</strong>
</pre></div></li><li class="listitem">Define the commands that the user(s) are allowed to execute. For instance, to allow all users in the <code class="literal">dba</code> group to call <code class="literal">initdb</code> in the <code class="literal">dbadm_r</code> role, define the commands as follows:<div><pre class="programlisting">%dba ALL=(postgres) ROLE="dbadm_r" TYPE="dbadm_t" /usr/sbin/initdb</pre></div></li><li class="listitem">The users in the <code class="literal">dba</code> group can now call <code class="literal">initdb</code>, and <code class="literal">sudo</code> will automatically switch to the <code class="literal">dbadm_r</code> role and the <code class="literal">dbadm_t</code> user domain when <code class="literal">initdb</code> is called:<div><pre class="programlisting">
<strong>~$ sudo -u postgres initdb</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec134"/>How it works…</h2></div></div></div><p>The regular user domains that users run with are, by default, not that privileged. Although it is possible to extend the privileges of the role and user domains directly, the best segregation is provided through different roles. Such an approach allows unprivileged user domains, such as <code class="literal">staff_t</code>, to be used by multiple, different organizational roles (and thus, SELinux users).</p><p>Once a privileged command needs to be executed, users will need to switch their active role. If this is only needed for a small set of commands, which also require switching the Linux user itself (such as switching to the <code class="literal">postgres</code> runtime account), then privilege delegation tools such as <code class="literal">sudo</code> are often used.</p><p>The <code class="literal">sudo</code> command is<a id="id417" class="indexterm"/> an SELinux-aware application that can be configured to assist in switching the SELinux context as well. This can be done through the command line directly if the user wants:</p><div><pre class="programlisting">
<strong>~$ sudo -u postgres -r dbadm_r -t dbadm_t initdb</strong>
</pre></div><p>However, most administrators will want to configure this in the <code class="literal">sudoers</code> file. This is more user friendly as the end user does not need to continuously pass the role and type parts of the context in which commands need to be executed.</p><p>Of course, this <a id="id418" class="indexterm"/>requires that the SELinux user that is<a id="id419" class="indexterm"/> calling <code class="literal">sudo</code> has the privilege to run commands in the <code class="literal">dbadm_r</code> role. If not, then even if the <code class="literal">sudoers</code> file mentions that the user can execute the command, the transition (and thus, the command) will fail, as shown in the following command:</p><div><pre class="programlisting">
<strong>~$ sudo -u postgres initdb</strong>
<strong>sudo: webadm_u:dbadm_r:dbadm_t:s0-s0:c0.c1023 is not a valid context</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec135"/>See also</h2></div></div></div><p>For more information on <code class="literal">sudo</code> and the <code class="literal">sudoers</code> file, check out their associated manual pages:</p><div><pre class="programlisting">
<strong>~$ man sudo</strong>
<strong>~$ man sudoers</strong>
</pre></div><p>The main project <a id="id420" class="indexterm"/>site for the <code class="literal">sudo</code> application is at <a class="ulink" href="https://www.sudo.ws">https://www.sudo.ws</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Running commands in a specified role with runcon</h1></div></div></div><p>Using <code class="literal">sudo</code> is not mandatory. SELinux also provides a command called <code class="literal">runcon</code> that allows<a id="id421" class="indexterm"/> users to run a command in a different context. Of <a id="id422" class="indexterm"/>course, SELinux restrictions still apply—the user must have the proper privileges to execute commands with a different context.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec136"/>How to do it…</h2></div></div></div><p>Running a command using a specified role and type is done by completing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the domain in which the command should run, usually by checking the executables' context and searching for the <code class="literal">entrypoint</code> definition:<div><pre class="programlisting">
<strong>~$ ls -Z auditctl</strong>
<strong>system_u:object_r:auditctl_exec_t    auditctl</strong>
<strong>~$ sesearch -t auditctl_exec_t -c file -p entrypoint -A</strong>
<strong>Found 1 semantic av rules:</strong>
<strong>  allow auditctl_t auditctl_exec_t : file { … entrypoint … };</strong>
</pre></div></li><li class="listitem">Call the command, passing along the role and target type:<div><pre class="programlisting">
<strong>~$ runcon -r secadm_r -t auditctl_t auditctl -l</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec137"/>How it works…</h2></div></div></div><p>The <code class="literal">runcon</code> application tells SELinux that the invocation of the command should result in a type and role transition towards the specified type (<code class="literal">auditctl_t</code>) and role (<code class="literal">secadm_r</code>). SELinux <a id="id423" class="indexterm"/>will perform multiple checks<a id="id424" class="indexterm"/> and validations before this will actually succeed. These checks are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the current user have the right to execute <code class="literal">auditctl</code> (execute rights on <code class="literal">auditctl_exec_t</code>)?</li><li class="listitem" style="list-style-type: disc">Is a role switch from the current role (say <code class="literal">staff_r</code>) to the new role (<code class="literal">secadm_r</code>) allowed?</li><li class="listitem" style="list-style-type: disc">Is there a policy in place that allows transition from the current type (say <code class="literal">staff_t</code>) to the selected type (<code class="literal">auditctl_t</code>)?</li><li class="listitem" style="list-style-type: disc">Is <code class="literal">auditctl_t</code> a valid target domain if the executed file is <code class="literal">auditctl_exec_t</code> (which is the <code class="literal">entrypoint</code> check)?</li><li class="listitem" style="list-style-type: disc">Is the target context (such as <code class="literal">staff_u:secadm_r:auditctl_t</code>) a valid context (which implies that the current SELinux user has access to the given role)?</li></ul></div><p>The <code class="literal">runcon</code> application can<a id="id425" class="indexterm"/> be used when no Linux user transition needs to occur (although this doesn't exclude the use of <code class="literal">sudo</code>). In the example of <code class="literal">auditctl</code>, this means that the regular access controls on Linux still apply—if the current user does not have the rights to access the files used by <code class="literal">auditctl</code>, then using <code class="literal">runcon</code> will not suffice.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Switching roles</h1></div></div></div><p>When a role<a id="id426" class="indexterm"/> transition is needed for more than just a couple of commands, it is necessary to open a shell with the new role. This will ensure that the entire session is now running with the new role assigned to it. Every activity performed from within this session will then run with the target role.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec138"/>How to do it…</h2></div></div></div><p>Switching roles with <code class="literal">sudo</code> or <code class="literal">newrole</code> is done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Switching a role can be done using <code class="literal">sudo -i</code> or <code class="literal">sudo -s</code> if allowed by the <code class="literal">sudoers</code> file. If the <code class="literal">ROLE</code> and <code class="literal">TYPE</code> attributes are set, then the target shell will have the proper context assigned:<div><pre class="programlisting">
<strong>~$ id -Z</strong>
<strong>dbadm_u:staff_r:staff_t:s0</strong>
<strong>~$ sudo -u postgres -i</strong>
<strong>Password: </strong>
<strong>~$ id -Z</strong>
<strong>dbadm_u:dbadm_r:dbadm_t:s0</strong>
</pre></div></li><li class="listitem">Switching roles can also be done using <code class="literal">newrole</code>:<div><pre class="programlisting">
<strong>~$ newrole -r dbadm_r</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec139"/>How it works…</h2></div></div></div><p>Getting a<a id="id427" class="indexterm"/> shell after switching roles is not all that different from executing commands. However, the SELinux policy might not allow running shells and regular binaries in the target domain. For instance, a user who is allowed the <code class="literal">puppetca_t</code> domain through some role will not be able to run a shell in this domain, as <code class="literal">puppetca_t</code> is not allowed to be used through a shell—it is a domain for a particular set of commands.</p><p>Most user roles have a default user domain associated with them. The default user domain for a <code class="literal">dbadm_r</code> role is <code class="literal">dbadm_t</code>; the default domain for a <code class="literal">webadm_r</code> role is <code class="literal">webadm_t</code>. These user domains do have the privileges to be used through a shell.</p><p>The <code class="literal">newrole</code> command only <a id="id428" class="indexterm"/>requires the target role, as it will check the default type of a role (which is documented in the <code class="literal">default_type</code> file inside <code class="literal">/etc/selinux/mcs/contexts/</code>) and use this as the target type.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Creating a new role</h1></div></div></div><p>Roles <a id="id429" class="indexterm"/>are part of SELinux policies. In order to create a new role, it isn't possible to just invoke a few <code class="literal">semanage</code> commands. Instead, an SELinux policy module will need to be created.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec140"/>How to do it…</h2></div></div></div><p>The SELinux policy needs to be updated in order to create a new role. The following steps can be used to do just that:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new policy module named after the role to be created, such as <code class="literal">pgsqladm</code> (for a PostgreSQL administration role).</li><li class="listitem">In the policy module, call the <code class="literal">userdom_login_user_template</code> interface:<div><pre class="programlisting">userdom_login_user_template(pgsqladm)</pre></div></li><li class="listitem">Assign the proper privileges to the <code class="literal">pgsqladm_r</code> role and <code class="literal">pgsqladm_t</code> type:<div><pre class="programlisting">postgresql_admin(pgsqladm_t, pgsqladm_r)</pre></div></li><li class="listitem">Edit the <code class="literal">default_type</code> file in <code class="literal">/etc/selinux/mcs/contexts/</code> to make <code class="literal">pgsqladm_t</code> the default type for the <code class="literal">pgsqladm_r</code> role:<div><pre class="programlisting">pgsqladm_r:pgsqladm_t</pre></div></li><li class="listitem">Edit <a id="id430" class="indexterm"/>the <code class="literal">default_contexts</code> file in <code class="literal">/etc/selinux/mcs/contexts/</code> to inform the system to which types a transition has to be made when a user switch is triggered by an application. For instance, for a local login session, the following code can be used for this purpose:<div><pre class="programlisting">system_r:local_login_t  user_r:user_t … pgsqladm_r:pgsqladm_t …</pre></div></li><li class="listitem">Now, build and load the policy, and verify that the new role is available:<div><pre class="programlisting">
<strong>~# seinfo -r | grep pgsqladm_r</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec141"/>How it works…</h2></div></div></div><p>Creating new roles for an SELinux system requires changes on multiple levels. Updating the SELinux policy is just one of these.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec37"/>Defining a role in the policy</h3></div></div></div><p>The first <a id="id431" class="indexterm"/>step is to create a new role and user domain <a id="id432" class="indexterm"/>through the SELinux policy. There are a couple<a id="id433" class="indexterm"/> of templates available in the reference policy to easily build new roles. The relation between these templates is visualized in the following diagram:</p><div><img src="img/9669OS_06_02.jpg" alt="Defining a role in the policy"/></div><p>The various blocks in the diagram represent the following templates:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In <code class="literal">userdom_base_user_template</code>, the basic rules and privileges for roles and <a id="id434" class="indexterm"/>user domains are documented, regardless of their future use. If a role needs to be declared with an absolute minimum of privileges, the use of this template is preferred.</li><li class="listitem" style="list-style-type: disc">Inside <code class="literal">userdom_login_user_template</code>,<code class="literal"> userdom_base_user_template</code> is <a id="id435" class="indexterm"/>called and extended with privileges related<a id="id436" class="indexterm"/> to interactive logins. When a role is created that is meant to be logged on directly (without the need to call <code class="literal">newrole</code> or <code class="literal">sudo</code>), then this interface is needed.</li><li class="listitem" style="list-style-type: disc">Within <code class="literal">userdom_restricted_user_template</code>, the <code class="literal">userdom_login_user_template</code> interface is called, but the user domain is also <a id="id437" class="indexterm"/>associated<a id="id438" class="indexterm"/> with <a id="id439" class="indexterm"/>the <code class="literal">unpriv_userdomain</code> attribute, meant for end <a id="id440" class="indexterm"/>user domains that have little security impact on the system.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">userdom_common_user_template</code> interface adds privileges and rules that are <a id="id441" class="indexterm"/>common for both unprivileged and privileged <a id="id442" class="indexterm"/>roles.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">userdom_unpriv_user_template</code> interface <a id="id443" class="indexterm"/>calls both <code class="literal">userdom_common_user_template</code> and <code class="literal">userdom_restricted_user_template</code> and is meant to declare unprivileged roles and user domains with interactive logon and general system access.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">userdom_admin_user_template</code> interface<a id="id444" class="indexterm"/> calls both <code class="literal">userdom_common_user_template</code> and <code class="literal">userdom_login_user_template</code>, and creates a role and user domain that is meant to be used for administrative purposes.</li></ul></div><p>Whenever such an appropriate interface is called, the proper role and type is created and can be used in the remainder of the policy module.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec38"/>Extending the role privileges</h3></div></div></div><p>In the <a id="id445" class="indexterm"/>example, we assigned PostgreSQL administrative <a id="id446" class="indexterm"/>rights to the <code class="literal">pgsqladm_t</code> user domain and allowed the <code class="literal">pgsqladm_r</code> role the proper PostgreSQL domains (if any).</p><p>The reference policy tends to provide two types of interfaces that can be assigned to new roles:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Administrative roles, whose interface name usually ends with <code class="literal">_admin</code></li><li class="listitem" style="list-style-type: disc">End user roles, whose interface name usually ends with <code class="literal">_role</code> or <code class="literal">_run</code></li></ul></div><p>Administrative roles allow for rights on all resources related to a particular domain. In case of the <code class="literal">postgresql_admin</code> interface, the role and user domain (which are passed on to the interface) are allowed to send signals to the PostgreSQL services, execute the <code class="literal">init</code> script (to launch or shut down the service), and manage the various resources of the domain (such as the database files, configuration files, and logs).</p><p>Services almost always have an <code class="literal">_admin</code> interface. These are called after the domain, such as <code class="literal">puppet_admin</code> for Puppet administration and <code class="literal">samba_admin</code> for Samba administration. Sometimes, an SELinux policy module has multiple administrative interfaces when there are different domains involved. An example would be the <code class="literal">logging_admin_audit</code> and <code class="literal">logging_admin_syslog</code> interfaces, as both auditing and system logging are provided by the same SELinux policy module, but the administration of these two services can be segregated.</p><p>End user roles allow the user to execute client applications or interact with services. Such interfaces, such as <code class="literal">puppet_run_puppetca</code> (which allows a user domain to run the <code class="literal">puppetca</code> application and transition to it) and <code class="literal">openvpn_run</code> (which allows users to run OpenVPN services), can still be somewhat administrative in nature, so make sure to validate the content of the interface. However, most of the time, this is governed through the application side and not infrastructure side—being able to launch VPN services does not mean that the user can manipulate routing tables as they see fit, even though the VPN service domain (<code class="literal">openvpn_t</code>) can.</p><p>It is important to review the interfaces before blindly granting them to new roles and users. In case of PostgreSQL, the <code class="literal">postgresql_role</code> role, for instance, does not allow the user to interact with the PostgreSQL service; instead, the interface is used to support SEPostgreSQL (SELinux-enabled PostgreSQL), which provides additional access controls <a id="id447" class="indexterm"/>in PostgreSQL based on SELinux <a id="id448" class="indexterm"/>policies. When users are assigned the <code class="literal">postgresql_role</code> role, they are granted basic privileges inside a PostgreSQL environment.</p><p>To allow users to interact with PostgreSQL, the <code class="literal">postgresql_stream_connect</code> and <code class="literal">postgresql_tcp_connect</code> interfaces can be used.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec39"/>Default types and default contexts</h3></div></div></div><p>The <code class="literal">default_types</code> file <a id="id449" class="indexterm"/>informs SELinux what the default <a id="id450" class="indexterm"/>type is if no context is specified otherwise, and it is used by commands <a id="id451" class="indexterm"/>such as <code class="literal">newrole</code> to know what the default <a id="id452" class="indexterm"/>type is for a user.</p><p>The <code class="literal">default_contexts</code> file (which can be overridden through SELinux user-specific files in the <code class="literal">users/</code> subdirectory) informs the SELinux libraries and subsystem what specific SELinux <a id="id453" class="indexterm"/>type to transition to when a user and role switch has occurred from within a specified domain. For instance, a <code class="literal">cron</code> daemon runs in the <code class="literal">system_r:crond_t</code> context, but when it executes the user <code class="literal">cron</code> jobs, these jobs themselves need to run in a different SELinux role and SELinux type. The following <code class="literal">default_contexts</code> configuration snippet would have the jobs of a user (whose role is <code class="literal">pgsqladm_r</code>) run as <code class="literal">cronjob_t</code> (rather than <code class="literal">pgsqladm_t</code>):</p><div><pre class="programlisting">system_r:crond_t  pgsqladm_r:cronjob_t</pre></div><p>These files are generated as part of the base policy. Sadly, there are no <code class="literal">default_types.local</code> or <code class="literal">default_contexts.local</code> files that can be used to provide system-specific changes. As a result, updates on the base SELinux policy might overwrite these files depending on how the Linux distribution treats these files. If the files are seen as configuration files (such as with Gentoo Linux), then they are not altered by system updates; instead, the system administrator is informed that an update on these files might be needed, keeping the manual changes made by the administrator in the past.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Initial role based on entry</h1></div></div></div><p>Users <a id="id454" class="indexterm"/>will often have multiple roles associated with them. Depending on how they interact with the system, a different initial role (and a user domain) might be needed. Consider a user who interacts with a system locally (through the console), remotely through SSH (for administrative purposes), and through FTP (as an end user), as depicted in the following diagram:</p><div><img src="img/9669OS_06_03.jpg" alt="Initial role based on entry"/></div><p>We want to make sure that the default role in which the user session starts on the system depends on the entry point on the system. Direct console logon can be in the administrative role, <code class="literal">sysadm_r</code>, whereas remote logon is first in the <code class="literal">staff_r</code> role (to ensure a stolen SSH key cannot be used to perform administrative tasks on the system without knowing the users' system password). The use of the FTP server should result in an unprivileged role, <code class="literal">ftp_shell_r</code>.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The <code class="literal">ftp_shell_r</code> role is a nondefault role and will not be available by default. Using <a id="id455" class="indexterm"/>SELinux with an FTP server in this setup requires that the FTP server is either SELinux aware (and supports context transitions) or uses PAM for its authentication rather than internal user accounts.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec142"/>How to do it…</h2></div></div></div><p>To <a id="id456" class="indexterm"/>configure the role to be used when a user logs on or starts a session, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, make sure that the user is assigned the various roles:<div><pre class="programlisting">
<strong>~# semanage user -m -R "staff_r sysadm_r ftp_shell_r" staff_u</strong>
</pre></div></li><li class="listitem">Edit the <code class="literal">default_contexts</code> file by reordering the contexts, making sure that the right role is always mentioned before the others (or that the others are not mentioned at all):<div><pre class="programlisting">system_r:local_login_t:s0  user_r:user_t:s0  sysadm_r:sysadm_t:s0 staff_r:staff_t:s0
system_r:sshd_t:s0  user_r:user_t:s0  staff_r:staff_t:s0
system_r:ftpd_t:s0  ftp_shell_r:ftp_shell_t:s0</pre></div></li><li class="listitem">Check whether the domains have support for specific Booleans that explicitly enable or disable transitioning into particular domains. For instance, consider the SSH daemon:<div><pre class="programlisting">
<strong>~# setsebool -P ssh_sysadm_login off</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec143"/>How it works…</h2></div></div></div><p>When applications call PAM to set up the user context, the PAM configuration will invoke methods provided by the <code class="literal">pam_selinux.so</code> file. These methods will check the <code class="literal">default_contexts</code> file to see what the context should be for a user. When <code class="literal">pam_selinux.so</code> is loaded through a daemon in the <code class="literal">system_r:sshd_t</code> context, for instance, then the lines for that particular daemon are interpreted:</p><div><pre class="programlisting">system_r:sshd_t:s0  user_r:user_t:s0  staff_r:staff_t:s0</pre></div><p>For the given user, the set of supported roles is obtained. In our case, this is <code class="literal">staff_r sysadm_r ftp_shell_r</code>. The entries in the <code class="literal">default_contexts</code> file are then looked at one by one, and the first role that is mentioned in the <code class="literal">default_contexts</code> file, that is also an allowed role for the user, will be used.</p><p>In the given example, as <code class="literal">user_r</code> is not an allowed role, <code class="literal">staff_r</code> is the next one on the list. This role is allowed, so when the user logs on through SSH, then its default role will be the <code class="literal">staff_r</code> role (and its associated user domain will be <code class="literal">staff_t</code>).</p><p>Some domains <a id="id457" class="indexterm"/>are also configured to allow or disallow direct logins into administrative roles. The SSH policy, for instance, uses an SELinux Boolean called <code class="literal">ssh_sysadm_login</code>, which<a id="id458" class="indexterm"/> allows transitioning into any user (<code class="literal">ssh_sysadm_login=on</code>) or only to unprivileged users (<code class="literal">ssh_sysadm_login=off</code>), specified policy-wise as follows:</p><div><pre class="programlisting">tunable_policy(`ssh_sysadm_login',`
  userdom_spec_domtrans_all_users(sshd_t)
  userdom_signal_all_users(sshd_t)
',`
  userdom_spec_domtrans_unpriv_users(sshd_t)
  userdom_signal_all_users(sshd_t)
')</pre></div><p>A similar approach can easily be built into custom policies. Note that the use of <code class="literal">userdom_spec_domtrans_unpriv_users</code> will only allow using the daemon for roles and types created through <code class="literal">userdom_unpriv_user_template</code>, as this interface assigns the <code class="literal">unpriv_userdomain</code> attribute that is used by the <code class="literal">userdom_spec_domtrans_unpriv_users</code> interface.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Defining role transitions</h1></div></div></div><p>It is possible <a id="id459" class="indexterm"/>to have SELinux automatically switch roles when a certain application is executed. The usual checks still apply (such as if the role is a valid one for the user, does the current user domain have execute rights, and many more), but then, there is no longer a need to call <code class="literal">runcon</code> or <code class="literal">sudo</code> to switch the role.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec144"/>How to do it…</h2></div></div></div><p>Role transitions can be configured as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the executable type on which a role transition has to occur:<div><pre class="programlisting">
<strong>~$ ls -Z puppetca</strong>
<strong>system_u:object_r:puppetca_exec_t  puppetca</strong>
</pre></div></li><li class="listitem">In the SELinux policy, create an interface that includes the role transitions:<div><pre class="programlisting">interface(`puppet_roletrans_puppetca',`
  gen_require(`
    role puppetadm_r;
    type puppetca_t, puppetca_exec_t;
  ')
  allow $1 puppetadm_r;
  role_transition $1 puppetca_exec_t puppetadm_r;
  domtrans_pattern($2, puppetca_exec_t, puppetca_t)
')</pre></div></li><li class="listitem">Assign the newly created interface to the user:<div><pre class="programlisting">puppet_roletrans_puppetca(staff_r, staff_t)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec145"/>How it works…</h2></div></div></div><p>The first rule that is activated is a role-allow rule. Such a rule tells SELinux what role switch is allowed and in which direction. The set of allowed role switches can be queried using <code class="literal">sesearch</code>:</p><div><pre class="programlisting">
<strong>~# sesearch --role_allow</strong>
</pre></div><p>Consider the following role-allow rule(s) for the <code class="literal">puppetadm_r</code> role:</p><div><pre class="programlisting">  allow staff_r puppetadm_r</pre></div><p>In this case, <em>only</em> the <code class="literal">staff_r</code> role is allowed to switch to the <code class="literal">puppetadm_r</code> role. Switching from the <code class="literal">puppetadm_r</code> role back to the <code class="literal">staff_r</code> role is not allowed.</p><p>The second rule tells SELinux that if a <code class="literal">puppetca_exec_t</code> labeled file is executed by the selected role (<code class="literal">staff_r</code>, in our case), then the role should switch to <code class="literal">puppetadm_r</code>. Of course, this is only done when the SELinux user is allowed the target role.</p><p>The third rule will perform a domain transition from <code class="literal">staff_t</code> to <code class="literal">puppetca_t</code> if <code class="literal">staff_t</code> executes a <code class="literal">puppetca_exec_t</code> labeled file.</p><p>It should be noted though that a forced role transition (that is, through the SELinux policy) is<a id="id460" class="indexterm"/> not a preferred method in the majority of cases, as it doesn't provide any flexibility to the administrator. If this is implemented, then using multiple roles is more difficult as some domains are hardcoded to a particular role.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Looking into access privileges</h1></div></div></div><p>To finish <a id="id461" class="indexterm"/>off, let's look at how to verify access privileges granted to users. Specifying roles and privileges allows users to do their job, but from a security point of view, it is also important to verify if (and which) users can manipulate certain resources. Auditors will want to have an overview of who is able to, say, manipulate SELinux policies or read private keys.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec146"/>How to do it…</h2></div></div></div><p>To properly investigate access rights, the following approach can help in identifying users (and processes) that have the permissions we want to be informed about:</p><div><ol class="orderedlist arabic"><li class="listitem">Verify file permissions that are not related to SELinux.</li><li class="listitem">Verify direct access to the resource (such as read rights on private keys).</li><li class="listitem">Look at who (users or applications) has the right to manipulate the SELinux policy.</li><li class="listitem">Check users and domains that are granted direct access to filesystems and raw devices.</li><li class="listitem">See when memory can be accessed directly.</li><li class="listitem">Review who can update authentication files.</li><li class="listitem">Analyze who can boot the system.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec147"/>How it works…</h2></div></div></div><p>Reviewing access is a lengthy process. It isn't sufficient to just look into file ownership (user and group) and look at the permissions of the file to find out who is actually able to read or modify the file (assuming that the privilege looked into is file access). Privilege delegation tools such as <code class="literal">sudo</code> (through the <code class="literal">sudoers</code> file or the <code class="literal">sudo</code> configuration in an LDAP server) need to be checked as well, together with the <code class="literal">setuid</code> application access, backup file access (when read access is to be examined), and more.</p><p>With the mandatory access controls that SELinux provides, checking the policy for access rights is an important part of such an evaluation. The <code class="literal">sesearch</code> application can assist <a id="id462" class="indexterm"/>in this quest.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec40"/>Direct access inspection</h3></div></div></div><p>To check<a id="id463" class="indexterm"/> direct access, we need to query <a id="id464" class="indexterm"/>both the access rights (such as write privileges on the resource) as well as relabeling rights. After all, a domain that is allowed to change the SELinux context of a file to another resource can theoretically switch the context, modify the file, and reset the context.</p><div><pre class="programlisting">
<strong>~# sesearch -t lvm_etc_t -c file -p write -ACST</strong>
<strong>Found 6 semantic av rules:</strong>
<strong>  allow sysadm_t non_auth_file_type : file { … };</strong>
<strong>  allow portage_t file_type : file { … };</strong>
<strong>...</strong>
<strong>~# sesearch -t lvm_etc_t -c file -p relabelfrom,relabelto -ACST</strong>
<strong>Found 5 semantic av rules:</strong>
<strong>  allow sysadm_t non_auth_file_type : file { … };</strong>
<strong>  allow restorecond_t non_auth_file_type : file { … };</strong>
<strong>  allow setfiles_t file_type : file { … };</strong>
<strong>…</strong>
</pre></div><p>This code shows not only the user domains that have the privileges, but also the application domains. In a review of permissions, it is necessary to also validate who can access and manipulate processes that run in these domains. This can be done by checking the transition permission:</p><div><pre class="programlisting">
<strong>~# sesearch -t setfiles_t -c process -p transition -ACST</strong>
</pre></div><p>For each of the domains, studying who can manipulate these processes is a time-consuming process and requires intimate knowledge of the application(s) that run in the given domain. For instance, the <code class="literal">restorecond</code> daemon will only reset file contexts to the context known by the SELinux tools (so, modifying the context temporarily is not possible through <code class="literal">restorecond</code>) and only on those locations that are configured in the <code class="literal">restorecond</code> configuration file.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec41"/>Policy manipulation</h3></div></div></div><p>Checking the SELinux policy isn't sufficient as the policy can be manipulated as well. Loading a <a id="id465" class="indexterm"/>new policy is governed<a id="id466" class="indexterm"/> through, among various other privileges, the <code class="literal">load_policy</code> permission:</p><div><pre class="programlisting">
<strong>~# sesearch -t security_t -c security -p load_policy -ACS</strong>
<strong>Found 2 semantic av rules:</strong>
<strong>EF allow kernel_t security_t : security load_policy  ; [ secure_mode_policyload ]</strong>
<strong>EF allow load_policy_t security_t : security load_policy ; [ secure_mode_policyload ]</strong>
</pre></div><p>Similarly, the access towards the selected domains (and the <code class="literal">load_policy_t</code> domain in particular) needs to be verified.</p><p>As can be seen from the output, manipulating the SELinux policy can also be controlled through an SELinux Boolean called <code class="literal">secure_mode_policyload</code>. When this Boolean is enabled, loading a new policy is no longer possible. If this Boolean is enabled and persisted, then even rebooting a system will not help unless the system is booted in the permissive mode.</p><p>Similarly, checking who can put the system in the permissive mode can be verified as well:</p><div><pre class="programlisting">
<strong>~# sesearch -p setenforce -ACS</strong>
</pre></div><p>This is governed through the same SELinux Boolean though.</p><p>Another way to manipulate the SELinux policy would be to boot the system in the permissive <a id="id467" class="indexterm"/>mode or even with SELinux disabled. This means<a id="id468" class="indexterm"/> that reviewing access to the boot files is also important (the <code class="literal">boot_t</code> type).</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec42"/>Indirect access</h3></div></div></div><p>It is also <a id="id469" class="indexterm"/>possible to access resources indirectly, for instance, by manipulating the raw devices (such as disk devices or memory). Access <a id="id470" class="indexterm"/>to device files is already quite privileged on Linux systems. With SELinux, additional controls might be put in place.</p><p>Disk devices are usually labeled as <code class="literal">fixed_disk_device_t</code>. Access to these files should only be granted to application domains, although some privileged user domains might be able to relabel such device nodes or manipulate application domains to perform actions not granted to the regular user.</p><div><pre class="programlisting">
<strong>~# sesearch -t fixed_disk_device_t -ACS</strong>
</pre></div><p>Users who are able to manipulate files related to system authentication can grant themselves different user roles, for instance, by logging on to the system as a different user (who does have the rights needed). This includes access to <code class="literal">/etc/pam.d/</code> (usually labeled as <code class="literal">etc_t</code>) or the authentication libraries themselves in <code class="literal">/lib/security/</code> (usually labeled as <code class="literal">lib_t</code>).</p></div></div></div></body></html>