<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started</h1></div></div></div><p>So, what's the deal with Z shell? You probably have a solid notion of what to expect from a modern shell, so things such as command history, completion, and autocorrection will not wow you as much as someone who just discovered Bash. However, unlike some of the other available shells out there, Z shell (zsh) boasts <a class="indexterm" id="id0"/>of a really powerful scripting language and an incredible completion system. Actually, incredible doesn't even begin to describe it. Swift and effortless sounds a bit more appropriate. Zsh also incorporates—and arguably, improves on—many of the useful features of Bash, ksh, and csh, even going so far as to allow you to emulate these shells in your scripts for an extra layer of compatibility.</p><p>Once you discover things such as multiline editing or start relying on automatic spell correction though, I promise you will look back at your old days of keyboard mashing buttons and wonder why you didn't make the switch sooner. So let's get started with it, shall we?</p><p>In this chapter, we will start by getting to know zsh, with a quick glimpse at some of the features that make it unique. Before we embark on our adventure though, we will need to install and configure our new shell, so we can ensure everything is up and running smoothly. We then move on to the configuration—what are the startup files, and how to use the different styles, escape sequences, and conditional expressions in order to customize the prompt.</p><div class="section" title="Installing zsh"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Installing zsh</h1></div></div></div><p>Like most <a class="indexterm" id="id1"/>things <a class="indexterm" id="id2"/>on your system, zsh needs to be installed and maintained; so, in this section we will learn how to do that. Note though, in order to avoid introducing inconsistencies and/or incompatibilities into your operating system, the recommended way of installing zsh is straight from your package maintainer's available sources. Either refer to your system's documentation or head to zsh's home page (<a class="ulink" href="http://zsh.sourceforge.net">http://zsh.sourceforge.net</a>) to learn more about the whole installation procedure.</p><p>Before getting started, it would be a good idea to check whether you will need to install or update your current installation of zsh, as the package could already be installed on some Unix systems. So, open up your favorite terminal emulator and type in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ echo $SHELL</strong></span>
</pre></div><p>This should <a class="indexterm" id="id3"/>print out<a class="indexterm" id="id4"/> something like <code class="literal">/bin/sh</code> or <code class="literal">/bin/bash</code> on most systems, and this means that your current login shell is something other than zsh. If you see <code class="literal">zsh</code> in the result though, go ahead and call the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ zsh --version</strong></span>
<span class="strong"><strong>zsh 5.0.2 (x86_64-apple-darwin12.3.0)</strong></span>
</pre></div><p>With some luck (and a healthy regime of system updates on your side, of course), you should see zsh's version, something that pretty much resembles the previous snippet. If that's the case, you can go ahead and skip this section. Should your operating system greet you with a polite <span class="strong"><strong>zsh not found</strong></span> message. That's ok though, otherwise you wouldn't be reading these lines. Let's get into the installation part of the deal, shall we?</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>We'll use the latest stable release—version 5.0.2 as at the time of writing this book—as a reference in this book. So it is advisable to try and update your current installation if you are running a previous release. Refer to your package manager's documentation in order to update zsh.</p></div></div><div class="section" title="Installing on Linux"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Installing on Linux</h2></div></div></div><p>Depending<a class="indexterm" id="id5"/> on <a class="indexterm" id="id6"/>which distribution of Linux your PC is currently sporting, zsh might (or might not) be in its repositories or, better yet, already installed on your OS. You should always refer to your OS's package listing in the rare event that zsh is unavailable.</p><p>On Debian and its multitude of derived distributions—such as Ubuntu and Linux Mint—you could get the whole installation process completed by simply opening a terminal and running the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get update</strong></span>
<span class="strong"><strong>$ sudo apt-get install zsh</strong></span>
</pre></div><p>Depending on your flavor of Debian and its repositories, you could get any version of zsh ranging from 4.3.x to 5.0.0 and upwards (if using any current release, at least). Again, try to stick to the latest and greatest whenever possible.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>You can always check the version of zsh by running <code class="literal">zsh --version</code> in the terminal.</p></div></div><p>Red Hat-based distributions such as Fedora will need you to input the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo yum check-update</strong></span>
<span class="strong"><strong>$ sudo yum install zsh</strong></span>
</pre></div><p>Then, there are the openSuSE users:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo zypper refresh</strong></span>
<span class="strong"><strong>$ sudo zypper install zsh</strong></span>
</pre></div><p>And let's not forget the Arch users:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pacman -S zsh</strong></span>
</pre></div><p>Wait for the download <a class="indexterm" id="id7"/>and installation scripts/triggers to complete, go ahead, and skip to the next section.</p></div><div class="section" title="Installing on OS X"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Installing on OS X</h2></div></div></div><p>Arguably, the <a class="indexterm" id="id8"/>easiest way to get your hands on zsh in OS X is either via Homebrew (<a class="ulink" href="http://www.brew.sh">http://www.brew.sh</a>) or MacPorts (<a class="ulink" href="http://www.macports.org">http://www.macports.org</a>), package managers that aim to extend the default options available to OS X users. Unfortunately, neither of these options come bundled with OS X. <a class="indexterm" id="id9"/>You will need to install either of the solutions before you can go ahead and make do with the latest version of zsh (which remains 5.0.2 at the time of writing this book). So, open your terminal emulator of preference, and either type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ brew install zsh</strong></span>
</pre></div><p>or</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo port install zsh</strong></span>
</pre></div><p>Wait for the download and installation scripts to finish, and then go ahead and jump straight into the next section. Also, refer to the documentation of each application in order to troubleshoot any kind of problems that could come up during the installation of the package.</p></div><div class="section" title="Compiling from source"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Compiling from source</h2></div></div></div><p>The<a class="indexterm" id="id10"/> official home for zsh is located at <a class="ulink" href="http://zsh.sourceforge.net">zsh.sourceforge.net</a>, and this is where you should point your browser in order to get started with your building adventure. Keep in mind, though, that the recommended way of obtaining a zsh binary for your system is via the compiled binaries packages. If for some reason, however, you just want to get the latest and greatest and don't mind dealing with more bugs than those of a stable release, you most likely will need to clone the repo using the Git version control software:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git clone git://git.code.sf.net/p/zsh/code zsh</strong></span>
</pre></div><p>Make sure <a class="indexterm" id="id11"/>you check-out and track the master branch, which is where the latest goodies have been committed. Also, keep in mind that there are some dependencies that need to be met before you can build your fresh local copy of zsh. These are all well-documented in the many configuration files that have been cloned into your disk, so take a long, hard look at the <code class="literal">README</code> file before you attempt things such as building the configure script.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Installing Git<a class="indexterm" id="id12"/> on your platform of choice goes beyond the scope of this book, but be rest assured that you won't have trouble following the instructions at <a class="ulink" href="http://www.git-scm.com">http://www.git-scm.com</a>.</p></div></div></div></div></div>
<div class="section" title="First run"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>First run</h1></div></div></div><p>Now that <a class="indexterm" id="id13"/>zsh is on your system, how about we take it for a spin? Go ahead and open your terminal emulator of choice and call the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ zsh</strong></span>
</pre></div><p>Like many other applications these days, zsh has a first-run wizard (bear with me, it almost resembles one). This is one of those magic creatures whose sole purpose is to help us configure our tools on a swift swoop of questions and decision making. We'll skip the new user configuration this time, but feel free to choose whatever method works best for you, taking the question-by-question approach or just pressing <span class="emphasis"><em>Q</em></span> on your keyboard to abort the operation. Just remember that the <code class="literal">newuser</code> module is called from <code class="literal">&lt;zshInstallFolder&gt;/Functions/Newuser/zsh-newuser-install</code> or <code class="literal">&lt;zshInstallFolder&gt;/functions/zsh-newuser-install</code> in OS X—should you require its services in the future.</p><p>In order to avoid having to skip the configuration options on each subsequent run, you can go ahead and create what is known as a <span class="emphasis"><em>startup file</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% touch ~/.zshrc</strong></span>
</pre></div><p>We just created our main preferences file; the problem is, it stands empty as it is. Let's go ahead and add some preferences, shall we?</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>There will be plenty of references to zsh's options—the various settings that alter the shell's behavior—thus, now is as good a time as any to establish a couple of conventions. Firstly, the naming scheme is somewhat too forgiving—it is case-insensitive and ignores underscores and ignores underscores. As such, both the following option names mean the same.</p><p>
<code class="literal">SOME_OPTION</code> and <code class="literal">SOMEOPTION</code>
</p><p>Secondly, try to think of options as <span class="emphasis"><em>switches</em></span>. As the name implies, they can either be turned <span class="emphasis"><em>on</em></span> or <span class="emphasis"><em>off</em></span>. Of the many ways that zsh provides to toggle its options, it is arguably easier to remember the <code class="literal">setopt</code>/<code class="literal">unsetopt</code> combo.</p><div class="informalexample"><pre class="programlisting">setopt SOME_OPTION # enables any option.
unsetopt SOME_OPTION # use this to disable an option.</pre></div><p>Conversely, you can negate the behavior of an option by prepending <code class="literal">NO</code> to its name, thus making <code class="literal">unsetopt SOME_OPTION</code> mean the same as <code class="literal">setopt NO_SOME_OPTION</code> or, keeping in mind that underscores are only there for human readability, the same as <code class="literal">setopt NOSOMEOPTION</code>.</p><p>Just for sanity's sake and because I do love me some standards, we'll use <code class="literal">ALL_CAPS_SNAKE_CASE</code> for the options in this book.</p></div></div><p>Open <code class="literal">~/.zshrc</code> with your favorite editor; you can use editors such as vim, Emacs, nano, or whatever kids find cool these days, and add the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>autoload -U promptinit # initialize the prompt system promptinit</strong></span>
</pre></div><p>Let's go over <a class="indexterm" id="id14"/>what we just typed: the first line of the code is our way to tell the shell to start its <code class="literal">promptinit</code> module<a class="indexterm" id="id15"/>—a series of functions that deal with handling the shell's various prompts and functionality. What you see right after the hash sign is just a comment to remind you of what the command is doing and why it is there. Finally, the last line is the one that actually calls and initializes the prompt module. It might not seem much, but it will come in handy when dealing with prompts, I promise.</p><p>Feel free to omit the comments and make sure you save your changes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Zsh will ignore each line that starts with a hash (<code class="literal">#</code>)—or pound—sign. This is really helpful for debugging preferences and, better yet, documenting your functionality. Consider the next example, with comments in bold:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># This is a comment and will be ignored by the shell.</strong></span>
HISTFILE=~/.zsh_history <span class="strong"><strong># sets the location of the history file</strong></span>
</pre></div></div></div><div class="section" title="Making zsh your login shell"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Making zsh your login shell</h2></div></div></div><p>If there's <a class="indexterm" id="id16"/>something that shells take seriously, is their role. See, the thing with shells is that they like to hang out in very specific categories—they are either interactive or non-interactive, and then there are login shells.</p><p>As you might have guessed from their name, <span class="emphasis"><em>interactive shells</em></span> allow you to interact with them; that is, they display a prompt, you enter a command, and they get back to you with an answer and a prompt that is ready for new input. On the other hand, Apply interactive shells get called to execute a script and go off their own merry way when the job is done.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Put simply, a prompt usually is the blinking cursor that tells you a shell is ready for you.</p></div></div><p>What about<a class="indexterm" id="id17"/> login shells then? Well, unlike interactive shells, <span class="emphasis"><em>login shells</em></span> are usually called when the user performs a login—be it either on the local machine or when using tools such as SSH, for example—and takes the trouble to go through your startup files and configuration bits and pieces of the shell. More importantly, your login shell doesn't necessarily need to be interactive.</p><p>In the previous section, we used a direct call to the binary <code class="literal">zsh</code> to start zsh. As you can imagine, this is but a temporary workaround, as typing the name of the shell every single time we want to use it seems a bit impractical, to say the least. Even worse is the thought of having your previous shell lurking beneath and ready to jump back at you as soon as you're done with zsh. If you don't trust me, go ahead and type <code class="literal">exit</code>; I'll wait. See that thing that's on your screen? That's your former command-line companion right there. Say your goodbyes and hop back into zsh by typing <code class="literal">zsh</code> and pressing <span class="emphasis"><em>return</em></span>.</p><p>So what comes next is—you guessed it—getting rid of that old shell of yours and saving yourself the trouble of remembering to call <code class="literal">zsh</code> each time you want to use it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>You can always trick zsh, and many other shells, into thinking it is a login shell by starting it with either the <code class="literal">-l</code> or <code class="literal">--login</code> flag. Open your terminal and type either of the following commands:</p><div class="informalexample"><pre class="programlisting">$ zsh -l</pre></div><p>or</p><div class="informalexample"><pre class="programlisting">$ zsh --login</pre></div><p>Voilà! A shell with a login complex.</p></div></div><p>Luckily for us, the Unix <code class="literal">chsh</code> command<a class="indexterm" id="id18"/> seems to be just what the doctor recommended, so go ahead and type the following in your terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chsh -s $(which zsh)</strong></span>
</pre></div><p>In the previous snippet, we're telling the system to change the shell for the current user. The option <code class="literal">-s</code> is used here to specify the location of the shell binary. That fancy <code class="literal">$()</code> construct you see there is our way of telling the shell to expand the result of the command within the parentheses, which is the result of the command <code class="literal">which zsh</code>.</p><p>You might recall <code class="literal">which</code> from the previous section, when we required its services to figure out the location of our existing zsh installation. The job of <code class="literal">which</code> consists of shouting out loud the location of any program file in the user's <code class="literal">$PATH</code> environment variable. Thus, we can safely assume that if <code class="literal">zsh</code> is not there, something has taken a wrong turn somewhere and, perhaps, it's advisable to retrace our steps.</p><p>It's more than <a class="indexterm" id="id19"/>likely that changing your login shell will require it to run with elevated privileges, so make sure you are using an account with the appropriate permissions.</p><p>From now on, you'll be greeted by zsh by default on your system and every time you start your terminal emulator of choice. And likely so, you have installed and made zsh your login shell. Next up is tweaking it.</p></div><div class="section" title="Shell options"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Shell options</h2></div></div></div><p>Besides <a class="indexterm" id="id20"/>tricking zsh into thinking it's a login shell with the <code class="literal">-l</code> flag, there are many<a class="indexterm" id="id21"/> other helpful options you can set when invoking it. Namely, <code class="literal">zsh -v</code> will switch on the verbose mode, which will make the shell print out any line before it gets executed. Then, there's <code class="literal">zsh -x</code>—for <code class="literal">xtrace</code>—which can prove invaluable when debugging your scripts, or <code class="literal">zsh -f</code> that will start a clean instance of zsh using the default settings.</p><p>Any of these options can also be set after the shell has been started; you simply have to call the desired option flag via the <code class="literal">set</code> command. The following example triggers the verbose mode on a running session:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% set -v</strong></span>
<span class="strong"><strong>% echo 'quite the echo in here'</strong></span>
<span class="strong"><strong>&gt; echo 'quite the echo in here'</strong></span>
<span class="strong"><strong>&gt; 'quite the echo in here'</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>And, you can<a class="indexterm" id="id22"/> disable any option with the same <code class="literal">set</code> command and replacing the dash/minus sign with a plus sign as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># disables verbose mode</strong></span>
<span class="strong"><strong>% set +v</strong></span>
</pre></div><p>More info regarding the various shell options and their usage can be found in the <code class="literal">zshoptions(1)</code> manpage (<code class="literal">man zshoptions</code>).</p></div><div class="section" title="The startup files"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The startup files</h2></div></div></div><p>Like most <a class="indexterm" id="id23"/>login shells, zsh relies on a series of configuration files known as <span class="emphasis"><em>startup</em></span> files, which contain the commands and preferences to be executed and set during the shell startup routine. We used the <code class="literal">.zshrc</code> file in the previous sections to avoid being bothered by the <code class="literal">newuser</code> function, but now that we have made zsh our login shell, it's time we take a closer look at what we can do with them.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>By default, zsh looks for startup files in the user's home directory, <code class="literal">$HOME</code> (or its alias, the more popular tilde, <code class="literal">~</code>. We'll alternate their use in this text as the path to the current user's home folder on the system), environment variable. You can tell zsh to look for your configuration files in another folder by setting the parameter <code class="literal">ZDOTDIR</code> to a directory of your choice in your <code class="literal">.zshenv</code> file under <code class="literal">$HOME</code>:</p><div class="informalexample"><pre class="programlisting">ZDOTDIR=/etc/my_kewl_folder/.zshrc</pre></div></div></div><p>During startup, zsh looks for, or <span class="emphasis"><em>sources</em></span>, a very specific system and user set of filenames under <code class="literal">/etc/</code>. Right after this, each of these files have a user-editable doppelganger, typically located in <code class="literal">$HOME</code>, which gets read. There are some rules, however, that might make zsh skip some of these files altogether. The ordering of these files is really important, as setting an option in the wrong file can result in commands getting executed at the wrong time and some really funky behavior. Thus, try to keep in mind the following order when setting preferences on your files:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">zshenv</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">zprofile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">zshrc</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">zlogin</code></li></ul></div><p>If zsh is not called as an interactive shell, <code class="literal">zprofile</code> and <code class="literal">zshrc</code> together with their counterparts in <code class="literal">$HOME</code> (<code class="literal">~/.zprofile</code> and <code class="literal">~/.zshrc</code>) will not be sourced. In addition, if zsh is not called as a login shell, <code class="literal">zlogin</code> and <code class="literal">$HOME/.zlogin</code> will also be skipped.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Depending on how you installed zsh, another directory besides <code class="literal">/etc/</code> can be used when looking for the global files.</p></div></div><p>Typically, you'd <a class="indexterm" id="id24"/>only like to mess with your own user's preferences, so we'll focus on the startup files that reside under <code class="literal">$HOME</code>, those are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">~/.zshenv</code>: This<a class="indexterm" id="id25"/> will be called immediately after <code class="literal">/etc/zshenv</code>. You should only add things such as the <code class="literal">PATH</code> settings and stuff you want to make available to any type of shell, whether it's interactive or not.</li><li class="listitem" style="list-style-type: disc"><code class="literal">~/.zprofile</code>: This is<a class="indexterm" id="id26"/> the companion to <code class="literal">/etc/zprofile</code> and kind of the boring guy out of the startup files bunch. You should put here any scripts you want executed before <code class="literal">~/.zshrc</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">~/.zshrc</code>: This is <a class="indexterm" id="id27"/>your workhorse. Most of your user settings and shell preferences end up here. Keep in mind it'll only be taken into account for interactive shells. As we'll see later on, you can declutter and expand its reach by sourcing multiple files.</li><li class="listitem" style="list-style-type: disc"><code class="literal">~/.zlogin</code>: This <a class="indexterm" id="id28"/>will be executed right after <code class="literal">~/.zshrc</code> and works pretty much like <code class="literal">~/.zprofile</code>, so you should put the scripts that you want called after your main startup file here.</li></ul></div><p>On the opposite corner of the startup files, there are the <span class="emphasis"><em>shutdown</em></span> files. As you can imagine, this relatively smaller set of files gets called not only in a specific order but also during the logout sequence of the login shell. The shutdown files can be considered a subset of the startup files, so there's no need to lose sleep over them. The important thing to remember is that when you type <code class="literal">logout</code> in the command line, the settings stored in the user configurable <code class="literal">~/.zlogout</code> file are read, followed by the installation file <code class="literal">/etc/zlogout</code>.</p><p>You can use the options <code class="literal">RCS</code> and <code class="literal">GLOBAL_RCS</code> to disable the loading mechanism of the startup files. This preference has to be unset on the system file <code class="literal">/etc/zshenv</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>unset</strong></span> RCS # disables loading of files other than zshenv
<span class="strong"><strong>unset</strong></span> GLOBAL_RCS # disables loading of files under /etc/</pre></div><p>For instance, if the <code class="literal">RCS</code> option is unset in <code class="literal">zshenv</code> (the first file that is read), <code class="literal">~/.zshenv</code> and all the remaining files will be skipped. Keep in mind though, that both of these options can be turned on again by any subsequent file that you load.</p><p>For example, if you have the following in <code class="literal">/etc/shenv</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>unset RCS</strong></span>
<span class="strong"><strong>source my_options_file.zsh</strong></span>
</pre></div><p>And then in <code class="literal">my_options_file.zsh</code> add:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># some more options here</strong></span>
<span class="strong"><strong>set RCS</strong></span>
</pre></div><p>Then, the shell will proceed and load <code class="literal">.zshenv</code> as if nothing happened. So, be careful!</p><p>We have taken a look at the startup files and their somewhat strict ordering; now, it's time we get up close and personal with the prompt.</p></div></div>
<div class="section" title="The shell prompt"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>The shell prompt</h1></div></div></div><p>Give anyone enough time<a class="indexterm" id="id29"/> with a shell and, inevitably, the question of "how do I add colors to it?" is bound to come up. Luckily though, zsh boasts a truckload of configuration options and escape sequences that will let you do just that and even more. In this section, we'll delve into the nuts and bolts of options at your disposal to customize the prompt.</p><div class="section" title="The prompt command"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The prompt command</h2></div></div></div><p>Zsh comes <a class="indexterm" id="id30"/>with a wide array of predefined prompt configurations that can be used as building blocks for something that more adequately meets your needs. Among other things, the utility <code class="literal">prompt</code> allows you to select your preferred theme. On a default installation, the various themes and user contributions are located under <code class="literal">&lt;zshFolder&gt;/Functions/Prompts</code> (or <code class="literal">&lt;zshFolder&gt;/functions</code> in OS X) and follow the naming scheme <code class="literal">prompt_&lt;theme&gt;_setup</code>. To have a look at what's included in the stock package, just type the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ prompt –p</strong></span>
</pre></div><p>And you should see a list of all the available prompt themes included with zsh. You can use the <code class="literal">-p</code> option together with a theme name to take a closer look at any of the themes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ prompt -p </strong></span>
</pre></div><p>In order to use the <code class="literal">prompt</code> function, you will need to set up the <code class="literal">promptinit</code> module on your shell. The easiest way to do this is to add it to your <code class="literal">.zshrc</code> file. Take a look at the section <span class="emphasis"><em>First run</em></span> if you haven't done so yet.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>You can refer to the <span class="emphasis"><em>PROMPT THEMES</em></span> section under the <code class="literal">zshcontrib(1)</code> manpage in order to get more in-depth information regarding prompts on zsh. Just type <code class="literal">man zshcontrib</code> in your terminal to get started.</p></div></div><p>You can test drive any theme you like, applying it temporarily to your current shell by typing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ prompt &lt;theme_name&gt;</strong></span>
</pre></div><p>Some themes, such as <code class="literal">adam1</code>, can even accept some extra configuration parameters like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ prompt adam1 red yellow magenta # sets the 'adam1' theme</strong></span>
</pre></div><p>By default, zsh won't be too fond of comments typed in the command line. Luckily, you can alter this behavior by setting the following option in your <code class="literal">.zshrc</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>setopt INTERACTIVE_COMMENTS  # allow inline comments like this one</strong></span>
</pre></div><p>In the previous snippet, <a class="indexterm" id="id31"/>we are passing a list of options to the theme, namely the colors <code class="literal">red</code>, <code class="literal">yellow</code>, and <code class="literal">magenta</code>. You can get a more thorough description of what's allowed for each prompt theme by calling the built-in help on any given theme:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ prompt -h &lt;theme_name&gt;</strong></span>
</pre></div><p>Try this on your favorite themes and see what else can be tweaked out of them.</p><p>Once you have found a combination that suits you, you can go ahead and commit to those changes. Just open your <code class="literal">.zshrc</code> file with your editor and add the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>autoload -U promptinit</strong></span>
<span class="strong"><strong>promptinit</strong></span>
<span class="strong"><strong>prompt adam1 red yellow magenta</strong></span>
</pre></div><p>We took our previous preferences file and sparkled some color in the default prompt <code class="literal">adam1</code>. So, how about we tweak it to make it feel more like home?</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>If you have invested a fair amount of time on customizing your prompt in your previous shell, it can be quite a headache trying to figure out the different rules set, so it can be ported to zsh. Luckily, zsh provides a series of tools for making the switch a more or less smooth experience. Located under <code class="literal">&lt;zshFolder&gt;/Misc</code>, you can use the <code class="literal">bash2zshprompt</code> or <code class="literal">c2z</code> scripts to migrate your Bash or csh preferences respectively. Note, however, that some distributions might be missing this, in which case you should head straight to the official repo and get your hands on a local copy. See the <span class="emphasis"><em>Compiling from source</em></span> section for more information on how to get the zsh source code.</p></div></div></div><div class="section" title="Customizing the prompt"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Customizing the prompt</h2></div></div></div><p>Zsh boasts<a class="indexterm" id="id32"/> five different prompts you can tweak, each with its specific purpose. Although you probably won't have to worry about dealing with them in most usage scenarios, it is, nevertheless, important that we get to know their role. For a more detailed description of each of them, I suggest you take a look at <code class="literal">man zshmisc</code>.</p><p>Zsh likes to refer to its main prompt variable as <code class="literal">$PS1</code> or its alias, <code class="literal">$PROMPT</code> (also <code class="literal">$prompt</code>). Rest assured though, both (actually the three of them, that is) are the same beast and are treated equally by zsh. Then there's <code class="literal">$RPS1</code> that prints a prompt at the right-hand side of the screen. Unlike other prompts though, it automatically disappears whenever line width is needed.</p><p>
<code class="literal">$PS2</code> gets displayed whenever the shell is waiting for more input, such as at the start of some unfinished syntactic structure or when you add inline comments to the command line. <code class="literal">$PS3</code> is used for making choices within a <code class="literal">select</code> loop control mechanism. Last but not the least, <code class="literal">$PS4</code> really comes in handy for debugging scripts.</p><p>Overall, these are the set of tools we will be working with, extending their functionality beyond the basics with a nifty set of tools known as escape sequences.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip04"/>Tip</h3><p>You can use the <code class="literal">source</code> command to reload your zsh configuration files at any time. Just save your changes and call the following command:</p><div class="informalexample"><pre class="programlisting">$ source file_path/file_name</pre></div><p>Remember to use double quotes if your file path includes spaces.</p><div class="informalexample"><pre class="programlisting">$ source "random folder/.zshenv"</pre></div></div></div></div><div class="section" title="Using escape sequences"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Using escape sequences</h2></div></div></div><p>Escape sequences <a class="indexterm" id="id33"/>are a <a class="indexterm" id="id34"/>set of predefined information shortcuts that can be added to zsh's prompt settings. They can<a class="indexterm" id="id35"/> show information such as the name of the machine to which you are logged on, the current date and time of the system, and even the current working directory. Most escape sequences are defined with a modulo or percent (<code class="literal">%</code>) operator, and some of them even take optional parameters to extend their functionality further.</p><p>For the magic to happen, however, we first need to add a new setting to our preferences file. Open <code class="literal">.zshrc</code> and add the following line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>setopt PROMPT_SUBST</strong></span>
</pre></div><p>By doing this, we're enabling the <code class="literal">PROMPT_SUBST</code> option. This will make zsh treat <code class="literal">$PROMPT</code> just as if it were a vanilla shell variable, and it will be checked against for command substitution, parameter and arithmetic expansion.</p><p>Next, we'll go through <a class="indexterm" id="id36"/>many of the available escape sequences and their meanings. Keep in mind that this is by no means a complete list of all the available options; as such, you can always refer to the <code class="literal">zshmisc(1)</code> manpage—particularly, the section titled <span class="emphasis"><em>Prompt Expansion</em></span>—should you need a more comprehensive listing of the available options.</p><div class="section" title="Shell state options"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl4sec03"/>Shell state options</h3></div></div></div><p>The following <a class="indexterm" id="id37"/>options serve as indicators for some aspects of the current state of the shell:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%#</code>: This displays <code class="literal">#</code> if the shell is running with elevated privileges and displays <code class="literal">%</code> otherwise</li><li class="listitem" style="list-style-type: disc"><code class="literal">%?</code>: This shows the exit status code of the last command executed</li><li class="listitem" style="list-style-type: disc"><code class="literal">%h</code> or <code class="literal">%!</code>: This shows the current history event number</li><li class="listitem" style="list-style-type: disc"><code class="literal">%L</code>: This displays the current value of the <code class="literal">$SHLVL</code> variable</li><li class="listitem" style="list-style-type: disc"><code class="literal">%j</code>: This prints the number of jobs being executed</li></ul></div></div><div class="section" title="Login information options"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl4sec04"/>Login information options</h3></div></div></div><p>The following options <a class="indexterm" id="id38"/>display more useful information about the host and machine on which the shell is currently running:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%M</code>: This shows the machine's <span class="emphasis"><em>hostname</em></span>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%m</code>: Same as the previous. Hostname is printed up to the first dot (<code class="literal">.</code>) separator. It takes an optional integer after <code class="literal">%</code> for the number of components to be displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%n</code>: This will have the same effect as printing environment variable <code class="literal">$USERNAME</code>.</li></ul></div></div><div class="section" title="Directory options"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl4sec05"/>Directory options</h3></div></div></div><p>The following<a class="indexterm" id="id39"/> options provide information regarding the path of the current working directory (<code class="literal">$PWD</code>) and filesystem directories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%d</code> or <code class="literal">%/</code>: This shows the current directory. Works just as printing the <code class="literal">$PWD</code> environment variable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%~</code>: Same as the previous, but if the current directory is <code class="literal">$HOME</code>, <code class="literal">~</code> is displayed instead.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%c</code> or <code class="literal">%.</code>: This lists the amount of directories trailing <code class="literal">$PWD</code>. It takes an integer as the parameter after <code class="literal">%</code>. Thus, <code class="literal">%2c</code> would show the two preceding directories to <code class="literal">$PWD</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%C</code>: Same as the previous, but directory names are not replaced with any symbols.</li></ul></div></div><div class="section" title="Date and time options"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl4sec06"/>Date and time options</h3></div></div></div><p>The following <a class="indexterm" id="id40"/>options provide miscellaneous date and time information:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%D</code>: This prints the current system date in the <code class="literal">yy-mm-dd</code> format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%W</code>: Same as the previous but in <code class="literal">mm/dd/yy</code> format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%w</code>: This shows the date in <code class="literal">day-dd</code> format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%T</code>: This displays the current time of the day, 24-hour format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%t</code> or <code class="literal">%@</code>: Same as the previous, uses a 12-hour, am/pm format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%*</code>: Same as the previous, also displays seconds.</li></ul></div></div><div class="section" title="Text formatting options"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl4sec07"/>Text formatting options</h3></div></div></div><p>Unlike the previous <a class="indexterm" id="id41"/>escape sequences, these need to be opened and closed around the desired part of the prompt. That is, in order to underline <code class="literal">word</code>, you need to type it as <code class="literal">%Uword%u</code>. Pay special attention to the difference in the case of the opening (UPPERCASE) and closing (lowercase) escape sequences, as shown in the following points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">%U %u</code>: This enables underline mode.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%B %b</code>: This enables boldface mode.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%K %k</code>: This sets the background color. Use it as <code class="literal">%K{red}%k</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%F %f</code>: Like the the previous, but applies to the <span class="emphasis"><em>foreground</em></span> color.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%S %s</code>: This enables <span class="emphasis"><em>standout</em></span> (highlight) mode.</li></ul></div><p>When dealing with escape sequences, both <code class="literal">%</code> and <code class="literal">)</code> are somewhat special as far as zsh is concerned; thus, remember to type <code class="literal">%%</code> if you need to display a literal <code class="literal">%</code> on your prompt. Likewise, a literal <code class="literal">)</code> should be typed as <code class="literal">%)</code>. This technique is commonly referred to as <span class="emphasis"><em>escaping characters</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>You can enable the <code class="literal">PROMPT_BANG</code> option on your zsh configuration to use a bang (<code class="literal">!</code>) in your prompt in order to display the current history event number instead of having to escape it (<code class="literal">%!</code>). Just remember to type <code class="literal">!!</code>, should you require a literal <code class="literal">!</code>.</p><div class="informalexample"><pre class="programlisting">setopt PROMPT_BANG # enables '!' substitution on prompt</pre></div></div></div></div></div><div class="section" title="Conditional expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Conditional expressions</h2></div></div></div><p>We will conclude<a class="indexterm" id="id42"/> our trip of the escape sequences by taking a look at the escape sequences available for conditional expansion<a class="indexterm" id="id43"/>. Luckily though, most of it can be summed up as the following ternary expression:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>%(X.true-text.false-text)</strong></span>
</pre></div><p>Basically, what this means is that if the condition <code class="literal">X</code> is true, do whatever is in <code class="literal">true-text</code>, otherwise do whatever is in <code class="literal">false-text</code>. The important thing to remember is that you should wrap your expression with <code class="literal">%()</code>, and that the dots (<code class="literal">.</code>) you see there are completely arbitrary, meaning you can replace both of them with whatever character you like.</p><p>Regarding the <code class="literal">true-text</code>/<code class="literal">false-text</code> expressions, the manpage (as when you visit <code class="literal">man zshmisc</code>) tells us that they can be replaced with the likes of <code class="literal">!</code>. This will evaluate to true if the shell is running with privileges or <code class="literal">?</code>, which in turn can be preceded by an integer <span class="emphasis"><em>n</em></span> and will evaluate to <code class="literal">true</code> only if the exit status of the last command matches. Thus, in order to display <code class="literal">#</code> as your main prompt to signal whether you are running on elevated privileges, with a bit of imagination, you can come up with things like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PS1=%(!.#.&gt;)</strong></span>
</pre></div><p>Likewise, you could use the following line to wrap the exit status of the last command that was run, if it was other than <code class="literal">0</code>, that is:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PS1=%(?..(%?%))</strong></span>
</pre></div></div><div class="section" title="Putting it all together"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Putting it all together</h2></div></div></div><p>As you are more than aware by now, zsh has many great features built in its prompt themes. So many in fact, that most of the time our custom solutions might feel like reinventing the wheel. We still need to take a shot at building our own prompt though; so, how about using one of the included themes as a starting point?</p><p>Navigate to your zsh installation folder or repository clone, and navigate to the Prompts folder under<code class="literal"> Functions</code>. As we saw earlier, all prompts come with a setup function that follows the <code class="literal">prompt_&lt;theme_name&gt;_setup</code> naming pattern. Look for the setup file for the SuSE theme and open it. It will most likely be under <code class="literal">prompt_suse_setup</code>.</p><p>What you see there is a shell function that goes by the same name as the file. A single call to this <code class="literal">prompt_suse_setup</code> function, with no parameters passed, is all that it takes to make two assignments—one for the <code class="literal">PS1</code> prompt and the other for <code class="literal">PS2</code>. Have a look at the following code, which has been formatted for this example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PS1="%n@%m:%~/ &gt; "</strong></span>
<span class="strong"><strong>PS2="&gt; "</strong></span>
</pre></div><p>So let's get started with hacking that prompt to pieces, shall we? Open your <code class="literal">.zshrc</code> file, and remember you will be adding the following line after the call to <code class="literal">promptinit</code>. We can start by highlighting the username, just like in the <code class="literal">adam1</code> prompt:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PS1="%K{yellow}%n%k@%m:%~/ &gt; "</strong></span>
</pre></div><p>If you recall from the previous section, the <code class="literal">%K%k</code> escape sequence defines the background color. Highlighted in the code, we wrap the escape sequence, <code class="literal">%n</code>, to add some background color to the current session, <code class="literal">$USERNAME</code>. On the right-hand side of the <code class="literal">@</code> symbol remains the short version of the machine name and some fancy line indicators, of course.</p><p>Let's add an error flag to the right-hand side, so we can check immediately for an abnormal command exit code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>RPS1="%(?..(%?%))"</strong></span>
</pre></div><p>If you feel like it, you can test our brand-new right-hand prompt by calling a program in a way that will end abnormally. Remember, an exit status of 0 is ok; everything else will trigger our prompt. Something such as <code class="literal">ls some_nonexistent_folder</code> should be enough:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>gfestari@machine:~/ &gt; ls nonexistent_folder</strong></span>
<span class="strong"><strong>ls: cannot access nonexistent_folder: No such file or directory</strong></span>
<span class="strong"><strong>gfestari@machine:~/ &gt;                                  (2)</strong></span>
</pre></div><p>You can sparkle some color into our right-hand prompt like we did for <code class="literal">PS1</code>. When you are done with your tweaking, try to leave <code class="literal">.zshrc</code> resembling the following code as much as possible:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>autoload -U promptinit</strong></span>
<span class="strong"><strong>promptinit</strong></span>

<span class="strong"><strong>PS1="%K{yellow}%n%k@%m:%~/ &gt; "</strong></span>
<span class="strong"><strong>PS2="&gt; "</strong></span>
<span class="strong"><strong>RPS1="%(?..(%?%))"</strong></span>
</pre></div><p>We left the <code class="literal">autoload -U promtpinit</code> and <code class="literal">promptinit</code> calls in the previous example, so the prompt module would be loaded and ready for use, should you eventually require its services. Note, however, that you do not require both these calls unless you are planning on using the <code class="literal">prompt</code> module.</p><p>Save your file and let's reload zsh configuration. We do this by sourcing the <code class="literal">.zshrc</code> file one more time. Be careful though as this could take a while depending on the links to other files you might have added:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% source ~/.zshrc</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<code class="literal">source</code> has a leaner and meaner brother: the dot (<code class="literal">.)</code> alias. Now that you've met him, feel free to do things such as the following:</p><div class="informalexample"><pre class="programlisting">% . ~/.zshrc</pre></div></div></div><p>How about we take advantage of the whole width of the terminal emulator's window? You know, because widescreen.</p><p>A particularly useful on-screen help is the current directory shortcut, which if you recall can be either <code class="literal">%~</code> or <code class="literal">%d</code>. So, how about we add a bit more context information to that lazy right-hand side prompt?</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>RPS1=%~</strong></span>
</pre></div><p>Come on, I know you didn't just think it was going to be that easy, right? We are adding functionality here, so it's not just about ditching our exit status indicator. Think about it; we need to add the current working directory to that right-hand prompt. Your first guess might be along the lines of the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># this won't work!</strong></span>
<span class="strong"><strong>RPS1=%(?..(%?%)) %~</strong></span>
</pre></div><p>This is almost perfect, save for the fact that it won't work straightaway.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>% source .zshrc</strong></span>
<span class="strong"><strong>&gt; job not found: ~</strong></span>
</pre></div><p>Bummer! However, the slight detail that's missing is the usage of double quotes. That's right, we can sneak those spaces through the shell's string processing and come out with no errors just by using double quotes, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>RPS1="%(?..(%?%)) %~"</strong></span>
</pre></div><p>This will tell the prompt function to take the <code class="literal">RPS1</code> variable as it is and to not worry about parsing multiple parameters.</p><p>And, that's it. You have your own version of the prompt on your brand-new installation of zsh. Although, you might be wondering what's the deal with the second prompt that we left there. I'll leave it for you to decide its fate, as I really like the current old-school <code class="literal">&gt;</code> indicator.</p><p>Before we are done with this chapter however, I'd like to point you towards the <span class="emphasis"><em>PROMPT THEMES</em></span> section in the <code class="literal">zshcontrib(1)</code> manpage. Go ahead and type <code class="literal">man zshcontrib</code> on the terminal emulator of your choice for more detailed information when creating your own prompt themes.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, we took a head-first dive into zsh by learning the essentials regarding its features and replacing your previous login shell. We even went that extra mile and added a touch of homemade goodness by customizing the prompt with the various escape sequences and configuration options available. Just because my memory is really awful, here's a list of what's been covered so far:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We learned how to configure and set up zsh, so we could ditch your current shell and replace it with your brand-new installation of zsh</li><li class="listitem" style="list-style-type: disc">We met the startup files, and now we have a clear understanding of what goes on behind the curtains moments before your terminal emulator window pops up on screen</li><li class="listitem" style="list-style-type: disc">We got acquainted with the shell prompt, and discovered that zsh offers much more than meets the eye</li><li class="listitem" style="list-style-type: disc">We went one step further and customized the prompt after learning about escape sequences and conditional expressions</li></ul></div><p>Now, your system should be all set and ready for what's left of this adventure. We still have plenty of ground to cover though, so we better get started with the next chapter, <span class="emphasis"><em>Alias and History</em></span>, where we'll learn about the <code class="literal">alias</code> mechanism, how to create your own shortcuts for functions, and we'll start working with the shell's history log.</p></div></body></html>