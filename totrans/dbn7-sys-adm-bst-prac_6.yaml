- en: Chapter 6. Basic System Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most critical tasks performed by system administrators is setting
    up and monitoring system security. Debian provides some assistance here, with
    special packages that help in hardening your systems, but this is only the beginning.
    In particular, you must pay attention to how you set up the root account, how
    to block improper access to your systems, and how to monitor your system for security
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: User administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things to consider is how to set up user groups and how to
    manage the root account. Although this can be changed any time, it should be done
    just after installation when changes will have less impact. The two basic issues
    are how to set up default user group assignment, and whether the root account
    should be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Default user group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, there are two ways to set up the default group assigned to a
    new user. The first is to have everyone assigned to a single users group. This
    will allow all users on the system access files and directories with group read
    (and execute) permissions, and write to files with group write permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The other way is to give each user his own groups, usually with the same name
    as his user ID. This is the default in Debian, and this scheme is often referred
    to as user private groups. If user A wants others to be able to access certain
    files or directories via the group permissions, someone with system privileges
    that allow group modification must add the appropriate user IDs to user A's group.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At one point, a single users group was common practice. Best practice at present,
    though, is to use user private groups.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the most common way to handle developer's access to each
    other's files. In this case, though, a new group, such as `web-dev` or whatever
    you feel is an appropriate group name, is created and the developers are assigned
    to it as necessary. A similar technique is used for some administration tasks
    as well. For example, an `ftpadmin` group that is allowed to modify the FTP server
    directories and files in ways that the normal (and especially the anonymous) ftp
    user cannot. Careful creation and assignment of groups can facilitate proper user
    access to files while preventing undesired access or modification.
  prefs: []
  type: TYPE_NORMAL
- en: User and group maintenance is handled by the standard command-line functions,
    such as `useradd`, `usermod`, `userdel`, `groupadd`, `groupmod`, and `groupdel`,
    all documented in the `passwd` package. Of course, there are GUI utilities available
    for user and group maintenance as well.
  prefs: []
  type: TYPE_NORMAL
- en: ACLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the traditional user/group/world permissions structure is adequate for
    many systems, there are times when more fine-grained control is required. This
    may be handled by using **Access Control Lists** (**ACL**). ACLs are implemented
    using the extended attributes available in various filesystems and are available
    by default in the EXT filesystems normally used in Debian Linux. The details may
    be found in the Debian `acl` package. In particular, check out the manual pages
    for the `getacl`, `setacl`, and `chacl` commands.
  prefs: []
  type: TYPE_NORMAL
- en: While ACLs are useful, there are some issues to be aware of. For example, most
    graphical file managers do not support them, and some utilities (EMACS comes to
    mind) clear the file ACL list when updating a file. This can be addressed somewhat
    by setting a default ACL for the directory, but non-default file ACLs will still
    need to be reconstructed if they are lost. Another issue is performance. On some
    filesystems, the existence of an ACL delays the initial file access due to the
    additional access verification required. Since this occurs only on the initial
    access, its impact is often minimal in practice. Finally, there is the issue of
    backups when you use ACLs. Most backup utilities now recognize ACLs. In Debian
    Linux, both `rsync` and `tar` now have options to allow them to recognize and
    back up ACLs, but they are only handled if you use the proper command options.
    The EXT backup utilities dump and restore also handle ACLs. However, some utilities
    may not recognize or handle ACLs properly, so always check the package documentation
    and manual pages if you use Access Control Lists.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, if you do use ACLs, you are not required to use them for all files
    and directories. It is quite possible to set them on only those files and directories
    that need them. Judicious use of file ACLs and default ACLs set for certain directories
    will help streamline ACL management.
  prefs: []
  type: TYPE_NORMAL
- en: The root account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Root access to a system is a serious issue. Anyone who knows the root password
    can do great damage, and the more people who know it, the greater the chance of
    the password getting into the wrong hands. To avoid this problem, the `sudo` package
    provides the ability to run commands as if one were the root user (including,
    if desired, a shell with full root permissions) without requiring the root password,
    only the user's own password and proper authorization. The advantage of this is
    that authorized commands are logged with the user's ID, providing an audit of
    who actually performed the command.
  prefs: []
  type: TYPE_NORMAL
- en: When `sudo` is used on a system, the only remaining use for the administrator
    password is when the system is booted into maintenance (single user) mode. Most
    Linux distributions, including Debian, require the root password before providing
    the root shell prompt in single user mode. However, this requirement can be bypassed
    in several ways by someone with access to the physical console. Therefore, many
    administrators completely disable the root password. When this is done, booting
    into maintenance or single user mode no longer prompts for the root password.
  prefs: []
  type: TYPE_NORMAL
- en: By disabling the root password completely, root-level access to the system via
    any method other than `sudo`, other programs that provide root privileges to normal
    users (also known as **setuid** programs), or via boot into single user mode is
    not possible. Note that, since booting into maintenance mode no longer requires
    a password, physical access to the system console must be controlled in some other
    way. This may be done by physical means, by requiring a password for the system
    boot via **BIOS** (**Basic Input/Output System**) or **UEFI** (**Unified Extensible
    Firmware Interface**), or by password protecting the GRUB or other system boot
    loader.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Best practice is to disable the root account login completely. **Ubuntu** now
    does this by default, and Debian is moving in that direction. Make sure you either
    restrict physical access to the console or password protect the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc/sudoers` file and files in the `/etc/sudoers.d` directory are where
    `sudo` access is configured. The details are provided in the `sudo` package documentation.
    Briefly, access to commands can be allowed or restricted by individual user, group
    members, or even lists and can allow access to commands depending on the remote
    host from which the user is accessing the system.
  prefs: []
  type: TYPE_NORMAL
- en: Debian hardening packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debian provides several packages to assist the administrator in securing the
    system. They are all meta packages, and include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`harden`: This installs harden-environment and harden-servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harden-clients`: This prevents installation of software clients that have
    the potential to expose critical information or allow unauthorized access to your
    system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harden-environment`: This installs tools for intrusion detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harden-nids`: This installs tools for network intrusion detection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harden-servers`: This prevents installation of services that are potentially
    insecure and could allow unauthorized access to your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`harden-tools`: This installs tools to help enhance and analyze system security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other hardening packages that install tools to analyze or audit systems
    remotely, and help developers create more secure programs. The packages can be
    found by searching the package cache for "harden". One way to do this is the command
    `apt-cache search harden`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing any of these packages is just a start, and won't automatically make
    your system secure. They are just a way of installing groups of security related
    packages, or preventing certain packages from being installed if they have potential
    security issues. In particular, if you install `harden-environment`, `harden-nids`,
    and `harden-tools`, you will also need to consult the appropriate package documentation
    and configure them properly to detect and analyze security issues, issue the proper
    warnings, or take the necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to be aware of is that some of these packages prevent the installation
    of certain services, such as an FTP server. If your server must provide FTP services
    (for example), then first install the appropriate hardening packages. After the
    install completes, install the FTP package confirming that you want to remove
    the hardening package. That way, you at least know that insecure services other
    than FTP have not been installed. To maintain that assurance, periodically test
    what `harden-servers` would remove if installed. This can be done, for example,
    by running `apt-get –dry-run install harden-servers`, and examining the output
    to see what would be done.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that the hardening packages do not provide is tools for protecting
    your systems via firewalls. This absence belies their importance in securing your
    systems, as a short search of Debian packages will show many tools for building
    firewalls. They vary from simple to complex, and from command line to full graphic
    interface. Nearly all are frontends for **IPTABLES**, the Linux kernel firewall
    modules and associated commands, and produce appropriate configuration files.
    Some provide a simple configuration language that is more readable than the standard
    `iptables` commands, which the tool then translates into the proper commands for
    you. Some provide a way of defining firewall policies, which are then translated
    into proper `iptables` configuration commands.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if your system is already behind a firewall, it is good practice to provide
    its own firewall as well. This multilayer approach provides additional protection
    in case the first firewall is somehow compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with the variety of firewall packages available, it is difficult
    to recommend any particular package over the others. Each has strengths and weaknesses.
    However, if we restrict ourselves to the more popular packages, there are a few
    general recommendations that can be made.
  prefs: []
  type: TYPE_NORMAL
- en: First, for desktop and development systems which don't require extremely complex
    configurations, **firestarter** (for GNOME) or **guarddog** (KDE) are good starting
    points. They are oriented towards beginners but have advanced options that can
    be useful to more experienced users. Both are graphical applications. A special
    case is **fireflier**, which actually analyzes the applications traffic on the
    system and recommends rules. Mason is a similar application, but it does not offer
    a graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: For servers or systems that require more robust protection, consider **fwbuilder**.
    It is similar to many enterprise firewall management systems and can provide configuration
    not only for Linux (both IPTABLES and IPCHAINS rules), but also BSD, Mac OS/X,
    and Cisco access-lists as well. Configurations for multiple servers can be kept
    in one place and installed remotely as needed. Refer to [http://www.fwbuilder.org/](http://www.fwbuilder.org/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: A popular alternative is **Shorewall**, which can also handle traffic shaping
    and IPsec to some extent. Shorewall uses text configuration files rather than
    a graphic interface. More information may be found at [http://shorewall.net/](http://shorewall.net/).
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, for Debian Linux, the firewall packages control traffic by generating
    the IPTABLES rules used by the kernel modules to recognize, analyze, and control
    network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: IPTABLES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPTABLES, which supersedes the old IPCHAINS code, is the generic name for what
    is actually a group of kernel modules and applications used to define and control
    Linux kernel firewalling. It actually includes modules and applications to provide
    IPv4, IPv6, ARP, and Ethernet Frame packet filtering as well as some stateful
    inspection of packets. There are many options for filtering, depending not only
    on the packet characteristics (such as protocol, source and destination addresses),
    but on how the packet is being handled, such as whether it is just entering the
    system, being forwarded, exiting to the network, needs address translation (such
    as **Network Address Translation** or **NAT**), related to an established connection.
    There are several good books available on IPTABLES, or you can start with the
    documentation on the [www.netfilter.org](http://www.netfilter.org) website, which
    is the home of IPTABLES code as well as many related projects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a project, **NFTABLES**, which is slated to replace IPTABLES in the
    kernel. It is still under development and at the time of writing, there is no
    official Debian support (either in Debian 7 or the testing release for Debian
    8). However, there are compatibility packages in the works, and once the code
    becomes part of the official Linux kernel, official Debian packages are expected
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Since most firewall packages provide their own ways to define your firewalls
    and output the appropriate iptables configuration commands, it is not necessary
    to understand all of the gritty details of IPTABLES, but a good administrator
    will want to understand the basics for a couple of reasons. First, it will help
    in understanding the capabilities of the firewall configuration software, since
    the features will be based on what can be done with IPTABLES, and second, it will
    be needed if you use something such as fireflier or mason, which propose rules
    and expect you to modify or delete them as required for your specific environment.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, beyond understanding what is possible, it is necessary to figure
    out what is required for your firewall.
  prefs: []
  type: TYPE_NORMAL
- en: Basic firewall design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many books and reams of Internet advice on building firewalls. The
    classic work on the subject is *Building Internet Firewalls* by *Elizabeth D.
    Zwicky*, *Simon Cooper*, and *D. Brent Chapman*, *O'Reilly Media*. However, for
    our present purposes, we'll cover some basic design principles.
  prefs: []
  type: TYPE_NORMAL
- en: Inbound opens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any time someone can open a connection to a system, that system can be attacked
    via that connection. This doesn't refer to inbound traffic in general, especially
    since much of this will be related to connections the local system established.
    It refers to the request from a remote system for a new connection to a local
    service. This is usually called an inbound open as it involves an initial request
    by a remote system to open a connection on a specific IP port.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if your system is a server that provides services to remote users,
    you must allow requests for services your server provides. Just don't allow any
    other inbound requests, and if you can, limit the source address of the requests
    unless the service is to be provided to anyone and everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Limit inbound requests (opens) to only those absolutely required to provide
    particular services to remote clients. Do not allow any other inbound traffic
    unless it is on or related to an established connection.
  prefs: []
  type: TYPE_NORMAL
- en: Outbound traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, outbound traffic is legitimate, and many administrators do not restrict
    traffic originating on the local system going to remote systems. Unfortunately,
    there are cases where this is not advisable. A common example is when a company
    wishes to restrict the outside services its employees can use (such as preventing
    the use of YouTube because it is inappropriate for them to be using it during
    working hours). Another example, though, is the case where a system has been compromised
    and starts contacting a remote command and control system for orders and additional
    malicious software to install.
  prefs: []
  type: TYPE_NORMAL
- en: Both cases may be handled by at least logging, and in many cases restricting
    outbound traffic. In most cases it is sufficient to limit outbound opens (requests
    for a new connection).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a personal system, outbound opens need not be restricted unless company policy
    requires such restrictions. On a server, outbound opens should be restricted to
    those services that the server requires for proper operation. Outbound traffic
    should be allowed only if it is on or related to an established connection.
  prefs: []
  type: TYPE_NORMAL
- en: Local loopback traffic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most administrators are not concerned with traffic on the local loopback interface.
    This is because such traffic is often necessary for proper operation of the local
    system. It is also rather difficult to analyze in order to determine what is necessary
    and what may be safely blocked without affecting normal operation. The major reason
    to firewall loopback traffic is that if rogue software is installed on the system
    by a virus or worm, then that software has more avenues to further attack the
    local system over the unprotected loopback interface. It may allow a minor compromise
    to exploit the opening to become a major system takeover.
  prefs: []
  type: TYPE_NORMAL
- en: The major trade-off here is whether the likelihood of compromise and the resulting
    potential for damage justify the additional time and effort required to analyze
    and create a proper firewall for the loopback interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a system is subject to frequent, serious attacks, consider firewalling the
    local loopback interface as well.
  prefs: []
  type: TYPE_NORMAL
- en: The perimeter network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably one of the most important ways to protect private networks while still
    providing services available to the public Internet is by using a perimeter network.
    Often called a **De-Militarized Zone** (**DMZ**), it is a buffer between attackers
    and your internal network.
  prefs: []
  type: TYPE_NORMAL
- en: '![The perimeter network](img/3118OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous diagram, there are two architectures given. The traditional
    design uses two firewalls with the perimeter network placed in between them. The
    reason for this is that if the external firewall which is exposed directly to
    the Internet and attack is compromised, the attacker still has to get through
    the internal firewall before he has access to systems on your internal network.
    Experience has shown that firewall compromise is uncommon enough that a single
    firewall can be used reasonably safely, as shown on the right. The dual firewall
    architecture is still preferred for high security environments.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the only systems that can be accessed from the Internet are those
    on the perimeter network. Those servers must not have any access to internal servers
    through the firewall. Internal servers can connect to the perimeter systems and
    thus allow two-way communication, but servers on the perimeter should never be
    able to initiate connections to internal systems. This prevents a compromised
    server from further endangering your internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter how careful you are, any server connected to the Internet will be
    attacked, and attacked frequently. Sooner or later, one of those attacks will
    succeed. No server that allows any outside access is completely immune to compromise.
    Best practice for any system, not just Debian, is to place Internet servers on
    a perimeter network in order to protect your internal systems and data in the
    event an Internet server is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: So, now you have your system properly firewalled. As mentioned previously, you
    will still be attacked, and eventually compromised. The next section deals with
    how to detect both the attempts and any compromise as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debian includes a number of intrusion detection applications. There are three
    basic classes: **Network Intrusion Detection Systems** (**NIDS**), File Monitors,
    and System Scanners. The former works by scanning network traffic to detect attempts
    to discover and exploit allowed network connections. The latter works by scanning
    a known clean system, then monitoring it for new, deleted, and modified files.'
  prefs: []
  type: TYPE_NORMAL
- en: NIDS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network Intrusion Detection basically involves monitoring network interfaces,
    analyzing all the packets seen, and providing alerts when certain attack characteristics
    are seen. On Debian, the primary tool for this is **Snort**. Snort will be installed
    if you install `harden-nids`, mentioned previously. Other packages are also available
    in Debian as well.
  prefs: []
  type: TYPE_NORMAL
- en: Snort can be paired with a package called `fwsnort` to not only detect potential
    attacks, but block them dynamically via adding IPTABLES rules when attacks are
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat is that NIDS can only analyze traffic they actually see. They will
    see all traffic on whatever interfaces they monitor (in fact, Snort will see it
    before IPTABLES does, ensuring that all traffic is analyzed). However, if your
    system is protected by an external firewall (for example, if it's on a perimeter
    network), it will only see packets that are allowed through the external firewall.
    Because of this, NIDS may be of limited use unless it is run on the external firewall.
    Nevertheless, it is still useful to detect attack attempts that manage to get
    through the external firewall.
  prefs: []
  type: TYPE_NORMAL
- en: File Monitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second level of intrusion detection involves monitoring the files on the
    system. There are several good monitors that will alert you to new, deleted, or
    modified files, usually filtering the reports so they include only changes that
    indicate a potential compromise. The most commonly used File Monitor is **Tripwire**
    and that is what is installed by the `harden-environment` package. However, Tripwire
    is now owned by a commercial enterprise that sells proprietary versions. While
    open source tripwire is still available, many administrators are switching to
    **AIDE** (**Advanced Intrusion Detection Environment**) or **Samhain** as alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configure your file monitors carefully to catch important changes and filter
    out as many false positives as possible without filtering out the true positives.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of filtering your results can't be overemphasized. An alert or
    report with too many false positives will frequently be skimmed at best or ignored
    at worst, and can result in missing a true positive indication of compromised
    files.
  prefs: []
  type: TYPE_NORMAL
- en: System scanners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System scanners include packages that scan for possible rootkits that may be
    installed or active on your system, and virus scanners. The packages `rkhunter`
    and `chkrootkit` are two of the most used rootkit detection packages. The `Tiger`
    package is a somewhat more comprehensive scanner that uses `chkrootkit` and Tripwire
    or AIDE as well as its own scripts to perform a full audit of your system's security.
    After the first audit of your clean system, `Tiger` will alert you to changes
    in your system's vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The only major function absent from `Tiger` is virus scanning, which can be
    handled by the `clamav` package, which also provides live scanning of email.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Best practice is to set up regular system security audits.
  prefs: []
  type: TYPE_NORMAL
- en: A final word on remote logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first things an accomplished hacker will do once he penetrates a
    system is attempt to erase all signs of system compromise. This includes removing
    entries from log files, hiding files, and network connections so they can't be
    shown using normal utilities, and so on. They may even go so far as to install
    their own compromised versions of your intrusion detection software, and your
    file and system scanners that won't report any sign of their illicit activities.
    One of the best countermeasures for this is to set your system up to write your
    system logs and NIDS and scan results to a remote system. Many scanners also provide
    ways to encrypt and verify configuration files and scan databases to protect them
    from compromise as well.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your system is subject to frequent attacks, set up remote logging, reporting,
    and alerting, and secure the configuration files and databases of your system
    and file scanners and your Intrusion Detection System.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: System security is one of the most important duties of an administrator. Ensure
    that your system is protected by setting up proper policies for users and groups,
    and hardening your systems (especially servers) when exposed to attack from the
    Internet. Firewall tools are useful in blocking attacks, and intrusion detection
    should be used to discover any system anomalies as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We've now been through pretty much all of the major administrative areas of
    Debian Linux, not counting individual software suites. Next, we will cover some
    advanced administration techniques.
  prefs: []
  type: TYPE_NORMAL
