<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Securing OpenLDAP</h1></div></div></div><a class="indexterm" id="id290"/><a class="indexterm" id="id291"/><p>In Chapter 2 we installed OpenLDAP and created a basic configuration file for the SLAPD server. Then, in the last chapter, we turned our attention to LDAP operations and LDAP clients. Now we will return to the SLAPD server, but with a specific focus: <strong>security</strong>. We will take a look at three major security considerations with OpenLDAP: securing connections between the server and client connections, authenticating users of the directory, and specifying what data particular users can access (and in what capacity they can access it). We will look at these security considerations on a practical level and, in doing so, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring SSL and TLS to protect network data</li><li class="listitem" style="list-style-type: disc">Using simple binding to authenticate DNS (Domain Name System) for using the directory</li><li class="listitem" style="list-style-type: disc">Using SASL to provide more robust authentication services</li><li class="listitem" style="list-style-type: disc">Integrating SASL and client SSL/TLS certificates for authentication</li><li class="listitem" style="list-style-type: disc">Configuring Access Control Lists (ACLs) to establish rules about what data users can access</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec24"/>LDAP Security: The Three Aspects</h1></div></div></div><a class="indexterm" id="id292"/><a class="indexterm" id="id293"/><p>As we have seen already, the directory contains sensitive information. One example of such sensitive information is the <code class="literal">userPassword</code> attribute. But other information that may be considered sensitive, such as personal information or confidential information about the organization, may exist in the directory. Such information needs to be protected.</p><p>We might ask what is meant by <em>protection</em> in this case. For it is certainly not the case that we want to prevent <em>all</em> clients from seeing <em>everything</em>. What we want rather, is to allow people to get at specific pieces of the directory information. But, on the other hand, there are cases where we want to deny certain users the ability to get at certain pieces of directory information. So protecting our data becomes a matter of providing information in some cases, while denying it in other cases.</p><p>While it is possible to draw finer-grained distinctions, here we are going to consider three broad aspects of security where we want to make sure that we are protecting the directory and its information. These three aspects are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Connection Security</strong>: <a class="indexterm" id="id294"/>This is the process of protecting directory information (and client information) as it is passed between a client and the directory server. We will talk about this in the context of network security with SSL and TLS.</li><li class="listitem" style="list-style-type: disc"><strong>Authentication</strong>: <a class="indexterm" id="id295"/>This is the process of ensuring that the user who tries to access the information in the directory is who he/she/it claims to be. In this chapter we will look at two types of authentication: simple and SASL Binding. SASL stands for <strong>Simple Authentication and Security Layer</strong><strong>.</strong></li><li class="listitem" style="list-style-type: disc"><strong>Authorization</strong>: <a class="indexterm" id="id296"/>This is the process of ensuring that an identified or authenticated user is allowed to access pieces of information within the directory. OpenLDAP ACLs are used to specify rules for authorization.</li></ul></div><p>In this chapter we will look at each of these three aspects of security. By combining all three we will be able to provide suitably fine-grained protection for our directory information.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Securing Network-Based Directory Connections with SSL/TLS</h1></div></div></div><a class="indexterm" id="id297"/><a class="indexterm" id="id298"/><p>The first element of security that we will examine is network security. Most clients connect to OpenLDAP over a network interface, and client requests, as well as the server's responses, are transferred over a network.</p><p>The LDAP protocol, by default, sends and receives messages in clear text. In this case no attempt is made to obscure the data as it is being transmitted across the network. Sending in clear text has a few advantages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is easier to configure and maintain.</li><li class="listitem" style="list-style-type: disc">LDAP services can function faster. The process of encrypting and decrypting messages can be processor-intensive, and eliminating that processing can serve to speed things up.</li></ul></div><p>But these advantages come at the cost of security. Other devices on the network may be able to intercept these unencrypted transmissions and read their contents and in doing so, they may obtain sensitive information. On a small Local Area Network (LAN) the risks may be smaller (though still present). On a large scale network, such as the Internet, the dangers are much greater.</p><p>In this section we will walk through the process of configuring <strong>Secure Sockets Layer </strong>(<strong>SSL</strong>) and <strong>Transport Layer Security (TLS)</strong> encryption to protect data as it is transmitted over a network. SSL and TLS are very similar, to the point where the terms are often used (acceptably) as synonyms. TLS though, is a refinement of SSL, and has been implemented in ways that are more flexible than the typical SSL implementation. The StartTLS method of securing a connection is an example.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>The Basics of SSL and TLS</h2></div></div></div><a class="indexterm" id="id299"/><p>OpenLDAP provides two  methods for encrypting network traffic. The first is to have OpenLDAP listen on a special port for requests (port 636, the LDAPS port, is used by default). Transmissions on this port will automatically be encrypted. This method is older, introduced as an addition to LDAP v2, but it is no longer the preferred method.</p><p>The second method, which is part of the LDAP v3 standard, is to allow clients connecting over the standard port (usually port 389) to request to switch from clear text transmissions to encrypted transmissions. I will cover both configurations here.</p><p>
<strong>Secure Sockets Layer</strong> (<strong>SSL</strong>) is a security process, originally developed by Netscape Communications for their web browser, designed to provide a safe way of exchanging trusted information between a server and any client on the network. There are two major features of the SSL process: establishing authenticity and conducting securely encrypted transactions.</p><p>As SSL developed and evolved it was handed over to a standard body, the <strong>Internet Engineering Task Force (IETF)</strong>, for standardization and continued development. IETF renamed it <strong>Transport Layer Security (TLS)</strong> and released version 1.0 (as RFC 2246). SSL 3.0 and TLS 1.0 do not have any notable differences, and most servers that support one also support the other. Because of their similarity and shared heritage, I refer to them jointly as SSL/TLS.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec39"/>Authenticity</h3></div></div></div><a class="indexterm" id="id300"/><p>Proving authenticity and providing encryption are the two major features of SSL/TLS. In regards to the first, SSL/TLS provides a way to establish the authenticity of the server (and, if desired, the client too). What this means is that SSL/TLS makes it possible for the client to be reasonably sure that the server belongs to whom it claims to belong.</p><p>Consider the case of online banking. If I use my browser to log on to my bank's website and conduct a few transactions, I want to be sure that the website I am connected to really is my bank's website, and not some other website masquerading as my bank. SSL/TLS provides tools to establish the authenticity of the server using <strong>X.509 certificates</strong>. An X.509 certificate has three important pieces of information:<a class="indexterm" id="id301"/>
<a class="indexterm" id="id302"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Information about the individual or organization that owns the certificate</li><li class="listitem" style="list-style-type: disc">A public encryption key (which we will discuss in the next section)</li><li class="listitem" style="list-style-type: disc">The <strong>digital signature</strong> of a certificate authority (CA)</li></ul></div><a class="indexterm" id="id303"/><a class="indexterm" id="id304"/><p>A certificate is designed as a sort of assurance that a server is associated with a particular individual or organization. When I contact a server that I believe to be my bank's, I want some assurance that it is, in fact, my bank's server. So one piece of information contained in the certificate is information about who owns the certificate. We can inspect this information ourselves, but since the certificate has a digital signature, it is also possible for software to computationally verify this—in a way much more reliable than reading the certificate and simply trusting that the certificate is accurate.</p><a class="indexterm" id="id305"/><a class="indexterm" id="id306"/><p>The digital signature is an encrypted bit of information. It is encrypted with a special "private" key that is owned by a Certificate Authority. The CA can then issue a public key that client software can use to verify that the certificate was in fact signed by the CA. The CA then, plays a very important role in establishing trust. We will discuss public and private keys in the <em>Encryption</em> section.</p><p>Certificate Authorities are responsible for issuing certificates. Ideally, a CA is a trusted source that can verify the authenticity of the certificate, and provide assurance that the certificate is really owned by the organization or individual that claims to own it.</p><p>There are a number of commercial CAs that provide certificate generation services for a price. To obtain a certificate through these services, an organization or individual must provide a certain amount of information that can be used to verify that the person or organization signing up for the certificate is legitimate. Once investigation of this material has been done, and the person or organization has paid the requisite fee, the CA issues a digitally-signed certificate.</p><p>The certificates of large CAs are included by default in most SSL-aware applications, such as popular web browsers (like Mozilla Firefox) and SSL libraries (like OpenSSL). These certificates include the public keys necessary for verifying digital signatures. Thus, when a client gets an X.509 certificate that is signed by one of these CAs, it has all of the tools it needs to verify the certificate's authenticity.</p><p>But it is possible, and often useful, for an organization or individual to simply create a locally used CA, and then use that CA to generate certificates for in-house applications. This is what we will do when we create a certificate for OpenLDAP.</p><p>Of course, certificates generated this way may not be considered reliable to users outside of your organization, but hosting an individual or organization-wide CA can be an effective way to add security to your own network, without having to purchase certificates from a commercial vendor.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Not all CAs use the same form of authoritative signing (and not all CAs charge for certificates). Some CAs, such as Cacert.org, use what is called a <strong>web of trust</strong> technique for establishing authenticity. In the web of trust the authenticity of a certificate is established by peers who can play the role of assuring that the certificate is owned by the person or organization that it claims to be owned by. For more information visit <a class="ulink" href="http://www.cacert.org/">http://www.cacert.org/</a>.</p></div></div><p>We have discussed the first role of SSL/TLS, establishing authenticity. Next we will turn to the second role of SSL/TLS; providing encryption services.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec40"/>Encryption</h3></div></div></div><a class="indexterm" id="id307"/><p>SSL/TLS provides the features required for sending encrypted messages back and forth between the client and the server. In a nutshell the process goes like this: the server sends the client its certificate, and inside the certificate (among other things) is the server's <strong>public key</strong>. The public key is the first half of a pair of keys. A public key can be used for encrypting a message, but not decrypting it. A second key, the <strong>private key</strong>, is then used for decrypting a message. The server keeps its private key to itself, but gives out its public key to any client that requests it. Clients can then send messages to the server that only the server can decrypt and interpret.</p><p>Depending on the configuration the client also sends the server its public key, which the server can use to send messages that only the client can decrypt. At this point, each can transmit encrypted messages to the other.</p><p>But there is a drawback to using public/private keys: they are slow and resource-intensive. Rather than trading all information through these public/private key combos, the client and server then negotiate a set of temporary symmetric encryption keys (which use the same key to encrypt and decrypt messages) that they will both use for the duration of the session. All traffic between the two clients is encrypted using these keys. Once the session is complete, both the client and server discard the temporary keys.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>For a more detailed introduction to SSL and TLS, as well as pointers to further sources of information, see the Wikipedia entry for Transport Layer Security: <a class="ulink" href="http://en.wikipedia.org/wiki/ Transport_Layer_Security">http://en.wikipedia.org/wiki/Transport_Layer_Security</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec41"/>StartTLS</h3></div></div></div><a class="indexterm" id="id308"/><a class="indexterm" id="id309"/><p>As it is typically implemented, SSL requires that the server listen for encrypted traffic on a port separate from the one it uses for unencrypted traffic. All traffic that comes over the SSL port is assumed to be SSL-encrypted traffic. This means that every server that needs to provide both cleartext and encrypted services must listen on at least two different ports.</p><p>The multi-port requirement seemed to some to be unnecessary, inelegant, and wasteful. There is no reason why the client should not be able to request on a cleartext (non-SSL) connection that further communication between the client and server be encrypted. The client and server could then perform all of the SSL/TLS negotiation over the same connection, and not have to switch to another SSL/TLS-only port. This suggestion was standardized in RFC2487 as <strong>StartTLS</strong>.</p><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>
<strong>Which to Pick: StartTLS or LDAPS?</strong>
</p><a class="indexterm" id="id310"/><p>The standardized way of implementing SSL/TLS in LDAP v.3 is to use the StartTLS method. This method should be implemented whenever possible. However, external considerations (such as network firewalling or clients without StartTLS support) may require that you use LDAPS and a dedicated SSL/TLS-protected port. LDAPS support is now listed as deprecated, though it is not yet slated for removal from OpenLDAP. Both options can be used on the same server.</p></div></div><p>In a StartTLS-supporting server, if the client sends the server the command <code class="literal">STARTTLS</code> then the server will begin the TLS encryption process. Assuming the TLS negotiation is successful, the client and server will then continue their transactions using encrypted traffic.</p><p>StartTLS has the obvious advantage of requiring only one listening port per server. And, it makes it possible for clients and servers to communicate in cleartext for unimportant data, and then switch over to TLS when security becomes important. Since encryption is resource intensive, requiring extra processing power to encrypt and decrypt messages, streamlining services the StartTLS way can improve performance and free up resources for other tasks.</p><p>There is a drawback for StartTLS though. Since both encrypted and cleartext traffic are sent over the same port, the method of simply blocking a port to prevent insecure data transmissions (by using a firewall for instance) is not effective with StartTLS. Security measures must be capable of inspecting transmissions at the protocol level.</p><p>In order to improve security services in such cases, OpenLDAP provides methods of testing the <strong>security strength factor (SSF)</strong> of a connection to see if it is encrypted (and if so, if the encryption scheme is strong enough). We will look at SSF in more detail later in this chapter in the section on <em>Using</em> <em>Security</em> <em>Strength</em> <em>Factors</em>.</p><p>At this point, you should have a fairly good idea of how SSL and TLS function. Now we will move on to more practical matters. We will create our own CA, and our own certificate, and then configure OpenLDAP to support SSL/TLS and StartTLS.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Creating an SSL/TLS CA</h2></div></div></div><a class="indexterm" id="id311"/><p>In order to create a Certificate Authority and generate certificates, you will need to have OpenSSL installed. Since many Ubuntu packages, including the OpenLDAP packages, require OpenSSL, it should be installed already.</p><p>If you build from source, as detailed in <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>, you may also enable support for SSL/TLS using the OpenSSL libraries.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>If you have a certificate already, you can skip this section and move to the <em>Configuring</em> <em>StartTLS</em> section. OpenLDAP uses certificates in the PEM format.</p></div></div><p>The first thing we will need to do is create our new CA.</p><p>While it is possible to manually configure your CA using the <code class="literal">openssl</code> command line tool, it is much simpler to use the <code class="literal">CA.pl</code> Perl script that is included with OpenSSL. This script streamlines many of the configuration options for OpenSSL, and the first thing that we will use it for is creating the environment for our new CA.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>Ubuntu maintains documentation on creating a new Certificate Authority the "long way" (creating all of the files by hand). This documentation is detailed and well worth reading. While I will follow the conventions established there, I will be using the <code class="literal">CA.pl</code> script to do most of the heavy lifting (<a class="ulink" href="https://help.ubuntu.com/community/OpenSSL">https://help.ubuntu.com/community/OpenSSL</a>).</p></div></div><p>You can put the CA environment anywhere on your system. Some prefer to keep CA files with the rest of the SSL configuration at <code class="literal">/etc/ssl/</code>. Others prefer keeping the certificate authority in a user directory so that it does not get overwritten during system upgrades (an unlikely, but possible, event). In keeping with the Ubuntu suggestion to keep CA info in a user's home directory, I will just put mine in my home directory, <code class="literal">/home/mbutcher/</code>:</p><div><pre class="programlisting">
<strong>  $ cd ~</strong>
<strong>  $ /usr/lib/ssl/misc/CA.pl -newca</strong>
</pre></div><p>Note that the <code class="literal">CA.pl</code> script is not in <code class="literal">$PATH</code>, so you will need to type in the entire path to the script.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>
<strong>Finding CA.pl</strong>
</p><p>Different operating system distributions will put <code class="literal">CA.pl</code> in different places. If running <code class="literal">which CA.pl</code> does not return any results, you may want to consult the man pages for SSL (<code class="literal">man config</code> or <code class="literal">man CA.pl</code>), or use the <code class="literal">find</code> or <code class="literal">slocate</code> utilities to find the <code class="literal">CA.pl</code> file.</p></div></div><p>The argument <code class="literal">-newca</code> instructs <code class="literal">CA.pl</code> to set up a new certificate authority environment. This will generate a directory structure along with a number of files.</p><p>The first thing that <code class="literal">CA.pl</code> will do is prompt you to enter a CA file:</p><div><pre class="programlisting">$ /usr/lib/ssl/misc/CA.pl -newca
CA certificate filename (or enter to create)</pre></div><p>Hit <em>Enter</em> to create a new CA certificate. <code class="literal">CA.pl</code> will then generate a new key and then prompt you for a password:</p><div><pre class="programlisting">CA certificate filename (or enter to create)

Making CA certificate 
Generating a 1024 bit RSA private key
....++++++<a class="indexterm" id="id312"/>
...................................++++++
unable to write 'random state'
writing new private key to './demoCA/private/cakey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----</pre></div><p>Once you have entered and re-entered your password, <code class="literal">CA.pl</code> will collect some information from you about your organization:</p><div><pre class="programlisting">You are about to be asked to enter information that will be 
    incorporated into your certificate request.
What you are about to enter is what is called a Distinguished Name or 
    a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
<strong>Country Name (2 letter code) [AU]:US</strong>
<strong>State or Province Name (full name) [Some-State]:Illinois</strong>
<strong>Locality Name (eg, city) []:Chicago</strong>
<strong>Organization Name (eg, company) [Internet Widgits]:Example.Com</strong>
<strong>Organizational Unit Name (eg, section) []:</strong>
<strong>Common Name (eg, YOUR name) []:Matt Butcher</strong>
<strong>Email Address []:matt@example.com </strong>

Please enter the following 'extra' attributes
    to be sent with your certificate request
<strong>A challenge password []:mypassword</strong>
<strong>An optional company name []:Example.Com</strong>
</pre></div><p>
<code class="literal">CA.pl</code> walks you through the process of creating a main certificate. The highlighted lines in the code listing are those where you will have to provide information at an interactive prompt. After setting the country, state, and city name for my locale, we set the <strong>Organization Name</strong> to <strong>Example.Com</strong>. While we left the <strong>Organizational Unit</strong> field blank, you can use that to further specify what part of the organization this CA is a member of.</p><div><div><h3 class="title"><a id="note45"/>Note</h3><p>You should consider using the same fields in your certificate that you used for your root DN when you set up your directory information tree in the previous two chapters.</p></div></div><p>Usually the <strong>Common Name</strong> and <strong>Email Address</strong> fields should contain information about the organization. Sometimes <strong>Common Name</strong> is used for the server name (as will be the case when we create our certificate). Sometimes, it is used for contact information. In the case that follows, we used my name and email. If the CA is to be the "official" CA for your organization, you should set this to the official contact person for certificate inquiries.<a class="indexterm" id="id313"/>
</p><p>Next, <code class="literal">CA.pl</code> will begin the process of generating a certificate request for the CA certificate. In other words, <code class="literal">CA.pl</code> will create a new certificate that will be the CA's own certificate. The first step in doing this is to create a certificate request. We will need to set a challenging password for the certificate request. We can also set a company name too. With the above information, <code class="literal">CA.pl</code> will continue the process of generating a new certificate:</p><div><pre class="programlisting">Using configuration from /usr/lib/ssl/openssl.cnf
<strong>Enter pass phrase for ./demoCA/private/cakey.pem:</strong>
Check that the request matches the signature
Signature ok
Certificate Details:
      Serial Number:
        bf:2f:58:47:b1:6d:31:4d
      Validity
        Not Before: Oct 10 21:34:28 2006 GMT
        Not After : Oct  9 21:34:28 2009 GMT
      Subject:
        countryName               = US
        stateOrProvinceName       = Illinois
        organizationName          = Example.Com
        commonName                = Matt Butcher
        emailAddress              = matt@example.com
      X509v3 extensions:
        X509v3 Basic Constraints: 
            CA:FALSE
          Netscape Comment: 
            OpenSSL Generated Certificate
          X509v3 Subject Key Identifier: 
    
07:92:9B:35:CB:B7:EE:92:A8:33:61:B0:DC:F7:88:E9:4F:06:9F:7F
    X509v3 Authority Key Identifier: 
    
keyid:07:92:9B:35:CB:B7:EE:92:A8:33:61:B0:DC:F7:88:E9:4F:06:9F:7F
    
Certificate is to be certified until 
    Oct 9 21:34:28 2009 GMT (1095 days)
    
Write out database with 1 new entries
Data Base Updated<a class="indexterm" id="id314"/>
</pre></div><p>We will be prompted to enter a pass phrase. This is the pass phrase we created first (when prompted to <strong>Enter PEM pass phrase</strong>). If we enter the pass phrase correctly, <code class="literal">CA.pl</code> will generate our new certificate and display its contents on the screen.</p><p>We have now created a Certificate Authority. Now we are ready to start generating a certificate to be used by SLAPD.</p><div><div><h3 class="title"><a id="note46"/>Note</h3><p>Due to a bug in some versions of <code class="literal">CA.pl</code>, you may have to <code class="literal">cd</code> into the <code class="literal">./demoCA</code> directory (the directory that <code class="literal">CA.pl -newca</code> created) and add a symbolic link to itself: <code class="literal">ln -s ./demoCA</code>. This is because <code class="literal">CA.pl</code> occasionally expects to find files in the current directory (<code class="literal">./</code>), which it assumes to be <code class="literal">demoCA/</code>, and sometimes it expects to find files in <code class="literal">./demoCA</code> (which, of course, is equivalent to <code class="literal">demoCA/demoCA/</code>). You can also fix this simply by editing the <code class="literal">dir=</code> line under <code class="literal">[CA_default]</code> in the <code class="literal">/etc/ssl/openssl.cnf</code> file, and setting it to an absolute path.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Creating a Certificate</h2></div></div></div><a class="indexterm" id="id315"/><p>Creating a certificate is a two-step process:</p><div><ol class="orderedlist arabic"><li class="listitem">We need to generate the Certificate Request.</li><li class="listitem">We need to sign the request with the CA's signature.</li></ol></div><p>Let's see these steps in detail.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec42"/>Creating a New Certificate Request</h3></div></div></div><a class="indexterm" id="id316"/><p>The first step in creating a valid SSL certificate is to create a Certificate Request. In the process, we will specify what information we want to show up on the certificate.</p><p>There are a few ways to generate Certificate Requests. For example, you can use the <code class="literal">openssl</code> command line tool and specifying a number of command line parameters. But, following our previous example, we will use <code class="literal">CA.pl</code> and let the application prompt us for information as is necessary.</p><p>To generate a new request we will run <code class="literal">CA.pl -newreq</code>. In the next example the highlighted lines are lines that require us to enter information:</p><div><pre class="programlisting">$ /usr/lib/ssl/misc/CA.pl -newreq
Generating a 1024 bit RSA private key
.....++++++
.....................++++++
unable to write 'random state'
writing new private key to 'newkey.pem'
<strong>Enter PEM pass phrase:</strong>
<strong>Verifying - Enter PEM pass phrase:</strong>
-----
You are about to be asked to enter information that will be 
    incorporated into your certificate request.
What you are about to enter is what is called a Distinguished Name or 
    a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
<strong>Country Name (2 letter code) [AU]:US</strong>
<strong>State or Province Name (full name) [Some-State]:Illinois</strong>
<strong>Locality Name (eg, city) []:Chicago</strong>
<strong>Organization Name (eg, company) [Internet Widgits]:Example.Com</strong>
<strong>Organizational Unit Name (eg, section) []:</strong>
<strong>Common Name (eg, YOUR name) []:example.com</strong>
<strong>Email Address []:matt@example.com</strong>

Please enter the following 'extra' attributes
to be sent with your certificate request
<strong>A challenge password []:</strong>
<strong>An optional company name []:</strong>
Request is in newreq.pem, private key is in newkey.pem</pre></div><p>This should look familiar. It is similar in most respects to the process of generating a Certificate Authority.</p><p>First, we will be prompted to enter a pass phrase. We will use this pass phrase in a few moments.</p><p>Next, we will be asked to supply information about the organization that this certificate will represent. As before the fields are Country Name, State/Province Name, Locality, Organization Name, Organizational Unit, Common Name (of the contact person), and the Email for the contact person. Again, as before, we entered the information for Example.Com.</p><p>This time, however, we set the Common Name field to be the domain name of the server that the certificate is for—<code class="literal">example.com</code>. It is very important that you use the correct domain name for the server. During the certificate negotiation process clients will check the Common Name field to see if it matches the domain name of the server. If the names do not match the user may get an error message, or the client application may simply terminate the connection.<a class="indexterm" id="id317"/>
</p><p>The extra <em>password</em> and <em>optional</em> <em>company</em> <em>name</em> are sometimes used in the certificate request process. Since we are doing the requesting and the signing ourselves we don't need to complete either of these fields.</p><p>Now we should have two files in the CA directory:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One called <code class="literal">newreq.pem</code>, which contains a base-64 encoded representation of our certificate request</li><li class="listitem" style="list-style-type: disc">One called <code class="literal">newkey.pem</code>, which contains the base-64 encoded private key</li></ul></div><p>We are now ready to move on to the second step.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec43"/>Signing the Certificate Request</h3></div></div></div><a class="indexterm" id="id318"/><p>The Certificate Request has all of the information required for a certificate, but it still lacks the digital signature of the CA. The next step, then, will be to use the CA we created previously to sign this new certificate. To do this, we will run <code class="literal">CA.pl -signreq</code>:</p><div><pre class="programlisting">$ /usr/lib/ssl/misc/CA.pl -signreq
Using configuration from /usr/lib/ssl/openssl.cnf
<strong>Enter pass phrase for ./demoCA/private/cakey.pem:</strong>
Check that the request matches the signature
Signature ok
Certificate Details:
      Serial Number:
        ba:49:df:f5:8e:7e:77:c2
      Validity
        Not Before: Oct 12 21:23:49 2006 GMT
        Not After : Oct 12 21:23:49 2007 GMT
      Subject:
        countryName               = US
        stateOrProvinceName       = Illinois
        localityName              = Chicago
        organizationName          = Example.Com
        commonName                = example.com
        emailAddress              = matt@example.com
      X509v3 extensions:
        X509v3 Basic Constraints: 
          CA:FALSE
        Netscape Comment: 
          OpenSSL Generated Certificate
        X509v3 Subject Key Identifier: 
    
47:DD:90:8F:79:90:2E:C0:CC:B3:95:62:35:C4:D8:6C:5D:A2:EE:88
     X509v3 Authority Key Identifier: 
                keyid:6B:FB:66:33:5D:DB:CC:40:42:D7:71:F7:F0:D0:7C:94:3E:8F:CD:58

Certificate is to be certified until 
    Oct 12 21:23:49 2007 GMT (365 days)
<strong>Sign the certificate? [y/n]:y</strong>

<strong>1 out of 1 certificate requests certified, commit? [y/n]y</strong>
Write out database with 1 new entries
Data Base Updated
Signed certificate is in newcert.pem<a class="indexterm" id="id319"/>
</pre></div><p>The <code class="literal">CA.pl -signcert</code> command looks for <code class="literal">newreq.pem</code> and then begins the signing process. First, we need to enter the pass phrase for the CA. If that is correct, then <code class="literal">CA.pl</code> will display the certificate in <code class="literal">newreq.pem</code> and ask if we want to sign it. Finally, it will ask us to commit these changes.</p><p>Once the changes are committed a new file will be created, named <code class="literal">newcert.pem</code>.</p><p>There are two important files that we now have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">newkey.pem</code>, which contains the private key</li><li class="listitem" style="list-style-type: disc"><code class="literal">newcert.pem</code>, which contains the signed certificate.</li></ul></div><p>We've just got a few loose ends to tie up, and then we can move on to configuring SLAPD to use SSL/TLS.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec44"/>Configuring and Installing the Certificates</h3></div></div></div><a class="indexterm" id="id320"/><a class="indexterm" id="id321"/><p>We have only three more steps to do, here. The first one has to do with the pass phrase we set on our certificate.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec17"/>Remove the Pass Phrase from the Key</h4></div></div></div><a class="indexterm" id="id322"/><p>Be very careful here! When generating our certificate request, we set a pass phrase on the certificate. This encrypted the <code class="literal">newkey.pem</code> file with a pass phrase.</p><p>If you use a key file that is encrypted with a pass phrase, then every time you use this certificate, you will have to enter a password. This means, in our case, that every time we start OpenLDAP, we will have to enter a pass phrase. Unless we have stringent security requirements (and are willing to put up with the hassle of typing the pass phrase every time we start or restart the server), we probably do not want the key file to be encrypted.</p><p>So, we will need to create an unencrypted version of the key file using the <code class="literal">openssl</code> command:</p><div><pre class="programlisting">
<strong>  $ openssl rsa &lt; newkey.pem &gt; clearkey.pem</strong>
</pre></div><p>This is what we get:</p><div><pre class="programlisting">Enter pass phrase:
writing RSA key</pre></div><p>In this example the command <code class="literal">openssl rsa</code> executes the OpenSSL RSA tool, which will decrypt the key. Using <code class="literal">&lt; newkey.pem</code>, we sent the file contents of <code class="literal">newkey.pem</code> into <code class="literal">openssl</code> to be decrypted. Then, using <code class="literal">&gt; clearkey.pem</code> we directed <code class="literal">openssl</code> to write the cleartext key file to the <code class="literal">clearkey.pem</code> file. In order to complete this operation, <code class="literal">openssl</code> prompts for the pass phrase. Now <code class="literal">clearkey.pem</code> has the unencrypted private key for our certificate.</p><div><div><h3 class="title"><a id="note47"/>Note</h3><p>The <code class="literal">clearkey.pem</code> file now contains an unencrypted private key. This file should be protected from misuse. You should set strict permissions on this file so that other users of the system cannot access it.</p></div></div><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>
<strong>The openssl Program</strong>
</p><p>The <code class="literal">openssl</code> program performs dozens of SSL-related functions, from generating certificates to emulating a network-based SSL client. Its syntax is notoriously difficult though. That is why we have been using the <code class="literal">CA.pl</code> wrapper script to perform common tasks. But some tasks can only be done with the <code class="literal">openssl</code> command. Should you need them though, <code class="literal">openssl</code> has excellent man pages: <code class="literal">man openssl</code>.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec18"/>Relocate the Certificates</h4></div></div></div><a class="indexterm" id="id323"/><p>The second task is to move our new certificate and key to a useful location on the server, and give the PEM files useful names as well. If this certificate is to be used by lots of different services, it might make sense to locate it in the shared directory. But for our cases we will only be using the SSL certificate for LDAP, so we can put the files in <code class="literal">/etc/ldap/</code> (or <code class="literal">/usr/local/etc/openldap/</code> if you built from source).</p><p>The two files with which we are concerned are <code class="literal">newcert.pem</code> and <code class="literal">clearkey.pem</code>. We need to rename and move those two keys:</p><div><pre class="programlisting">
<strong>  $ sudo mv cacert.pem /etc/ldap/example.com.cert.pem</strong>
<strong>  $ sudo mv clearkey.pem /etc/ldap/example.com.key.pem</strong>
</pre></div><p>Now, we need to set permissions and ownership on the certificate files. Since we did not add a pass phrase to the key, we should also make sure that only the OpenLDAP user can read the key file:</p><div><pre class="programlisting">
<strong>  $ sudo chown root:root /etc/ldap/example.com.*.pem</strong>
<strong>  $ sudo chmod 400 /etc/ldap/example.com.key.pem</strong>
</pre></div><p>The first line changes the owner and group of the two PEM files to the <code class="literal">root</code> user and the <code class="literal">root</code> group. The second line sets the mode so that only the owner can read the file, and no one else has any access.</p><a class="indexterm" id="id324"/><p>If you are running OpenLDAP as a user other than root (and it is a good idea to do so), then the files should be owned by that user instead of root; for example <code class="literal">chown oenldap example.com.*.pem</code>.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec19"/>Install the CA Certificate</h4></div></div></div><a class="indexterm" id="id325"/><p>The third task is to install the CA's public certificate so that other applications on the system can use that certificate to verify the authenticity of the certificate we just generated. First, we need to copy the CA certificate to the local certificate database for Ubuntu. In the process we will give it a user-friendly name:</p><div><pre class="programlisting">
<strong>  $ sudo cp cacert.pem /usr/share/ca-certificates/Example.Com-CA.crt</strong>
</pre></div><p>Then, edit the <code class="literal">/etc/ca-certificates.conf</code> file, and add <code class="literal">Example.Com.crt</code> at the end of the file.</p><p>Finally, run <code class="literal">update-ca-certificates</code>:</p><div><pre class="programlisting">$ sudo update-ca-certificates
Updating certificates in /etc/ssl/certs....done.</pre></div><p>The CA certificate has now been installed. The <code class="literal">/etc/ssl/certs</code> directory is now the authoritative source for CA certificates.</p><div><div><h3 class="title"><a id="note48"/>Note</h3><p>UNIX and Linux systems other than Ubuntu and Debian may not have the <code class="literal">update-ca-certificates</code> script. Consult the system documentation to find out how to update the certificate database on such systems.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec20"/>Optional: Clean Up</h4></div></div></div><p>If you want, you can do a little clean-up in the CA directory. Delete the encrypted key file and the certificate request file, both of which are in the <code class="literal">demoCA/</code> directory:</p><div><pre class="programlisting">
<strong>  $ rm newkey.pem newreq.pem</strong>
</pre></div><p>Also, make sure <code class="literal">clearkey.pem</code> is no longer present in the <code class="literal">demoCA/</code> directory.</p><p>Now we are ready to configure OpenLDAP to use our new certificates. First, we will configure StartTLS support, which is the easiest, then we will configure SSL/TLS support on the LDAPS port, port 636.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Configuring StartTLS</h2></div></div></div><a class="indexterm" id="id326"/><a class="indexterm" id="id327"/><p>In the previous sections we created our new certificate and key, and placed the two files in the <code class="literal">/etc/ldap</code> directory. In this section we will set up StartTLS (which we introduced earlier in this chapter in the StartTLS section). Setting up StartTLS requires only a few extra lines in the <code class="literal">slapd.conf</code> file.</p><p>Again, StartTLS is the standard way (according to RFC 4511) of providing SSL/TLS security to OpenLDAP. For security reasons support for StartTLS should be provided whenever practical.</p><p>In the <code class="literal">slapd.conf</code> file, just before the <code class="literal">BDB Database Configuration</code> section, insert the SSL/TLS options:</p><div><pre class="programlisting">###########
# SSL/TLS #
###########
TLSCACertificatePath    /etc/ssl/certs/
TLSCertificateFile      /etc/ldap/example.com.cert.pem
TLSCertificateKeyFile   /etc/ldap/example.com.key.pem</pre></div><p>Basically, there are only three directives we need to specify to get StartTLS working:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first directive, <code class="literal">TLSCACertificatePath</code>, tells SLAPD where to find all of the CA certificates that it will need for verifying certificates. The definitive location is, as we saw before, the <code class="literal">/etc/ssl/certs/</code> directory.</li><li class="listitem" style="list-style-type: disc">The second directive, <code class="literal">TLSCertificateFile</code>, specifies the location of the signed certificate.</li><li class="listitem" style="list-style-type: disc">The third directive, <code class="literal">TLSCertificateKeyFile</code>, specifies the location of the corresponding key file, which has the private encryption key for the certificate.</li></ul></div><div><div><h3 class="title"><a id="note49"/>Note</h3><p>There are a handful of other TLS-specific directives that allow you to provide detailed constraints on TLS connections (such as which suites of ciphers can be used, and whether the client needs to provide a certificate to the server). Complete documentation on these can be found in the TLS section of the <code class="literal">slapd.conf</code> man page: <code class="literal">man slapd.conf</code>.</p></div></div><p>That's all we need to get SLAPD to perform StartTLS. Restart SLAPD so that the changes take effect.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Configuring Client TLS</h2></div></div></div><a class="indexterm" id="id328"/><p>We do need to add a directive or two to <code class="literal">ldap.conf</code>—the configuration file that the OpenLDAP clients use. As with SLAPD, we need to direct the clients to the correct location of the new CA certificate so that they can verify the server certificate.</p><p>At the bottom of the <code class="literal">ldap.conf</code> file we can add the appropriate directive:</p><div><pre class="programlisting">TLS_CACERTDIR /etc/ssl/certs</pre></div><p>Clients will use this directive to locate the CA certificates for checking digital signatures on the certificates they get from servers. If you know that you are only going to use certificates signed by a specific CA, you can use the <code class="literal">TLS_CACERT</code> directive to point to a specific CA certificate file, instead of a directory containing one or more certificates.</p><p>By default, OpenLDAP clients always perform a check on the digital signatures. If a server sends a certificate that was signed by a CA other than those at <code class="literal">/etc/ssl/certs/</code> (or whatever directory <code class="literal">TLS_CACERTDIR</code> points to), then the client will close the connection and print an error message to the screen.</p><p>Sometimes though, the correct CA certificate is not available, and it is worthwhile to get the encryption support of TLS even if it is not possible to verify the identity of the server.</p><p>In such cases you may find it necessary to change the way OpenLDAP clients perform identification checks. For example, it might be desirable to try to verify the certificate, but to continue with the connection even if there is no appropriate CA locally. To accomplish this, use the following directive in <code class="literal">slapd.conf</code>:</p><div><pre class="programlisting">TLS_REQCERT allow</pre></div><p>In this case, if there is no CA certificate or if the certificate sent cannot be verified, the session will continue, rather than exiting with an error message. <code class="literal">TLS_REQCERT</code> has a few different levels of checking, ranging from <code class="literal">strict</code> (always verify) to <code class="literal">never</code> (do not even bother trying to verify certificates).</p><p>At this point, we can use <code class="literal">ldapsearch</code> to test a connection. To instruct a client to use StartTLS, we need to use the <code class="literal">-Z</code> flag. But if just <code class="literal">-Z</code> is specified, if the client fails TLS negotiation with the server, it will continue with the transaction in clear text. In other words, with <code class="literal">-Z</code>, TLS is preferred, but not required. To make TLS required, we will add an extra z to the flag, making it <code class="literal">-ZZ</code>:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -LLL -x -W -D 'cn=Manager,dc=example,dc=com' -H \ </strong>
<strong>               ldap://example.com -ZZ '(uid=manny)'</strong>
</pre></div><p>This should prompt for a password and then return one result:</p><div><pre class="programlisting">Enter LDAP Password: 
dn: uid=manny,ou=Users,dc=example,dc=com
sn: Kant
uid: immanuel
uid: manny
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
givenName: Manny
cn: Manny Kant</pre></div><p>If the result comes back like this, then TLS was successfully configured. But TLS can be difficult to get configured because it is strict by design. Small errors in configuration (like using a domain name that differs from the one in the CN field of the certificate) can prevent TLS from working. Consider this example:</p><div><pre class="programlisting">$ ldapsearch -LL -x -W -D 'cn=Manager,dc=example,dc=com' -H \ 
    ldap://localhost -ZZ '(uid=manny)'

ldap_start_tls: Connect error (-11)
    additional info: TLS: hostname does not match CN in peer 
    certificate<a class="indexterm" id="id329"/>
</pre></div><p>In this case, the host name specified on the command line (<code class="literal">localhost</code>) differed from the one in the CN field of the certificate (<code class="literal">example.com</code>). Even though, in this case, the two domain names are hosted on the same system, TLS will not accept the mismatch.</p><p>Other common errors in TLS are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reversing the values of the <code class="literal">TLSCertificateFile</code> and the <code class="literal">TLSCertificateKeyFile</code> directives</li><li class="listitem" style="list-style-type: disc">Forgetting to install the CA certificate (which results in an error indicating that the server certificate cannot be verified)</li><li class="listitem" style="list-style-type: disc">Forgetting to set the client CA path correctly in <code class="literal">ldap.conf</code></li><li class="listitem" style="list-style-type: disc">Setting the read/write permissions (or the ownership) on the key file (or the certificate file) in such a way that the SLAPD server cannot read it</li></ul></div><p>While OpenLDAP can be forgiving in many areas, TLS configuration is not one of them. It pays to take extra care when configuring TLS and SSL.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Configuring LDAPS</h2></div></div></div><a class="indexterm" id="id330"/><p>Now that we have configured TLS, we need to take only a few additional steps to enable SSL/TLS on its own port. The traditional port for running dedicated TLS/SSL-protected LDAP traffic is port 636, the LDAPS port.</p><p>Most of the time it is better to use StartTLS. However, network considerations (like clients that do not support StartTLS or policies dictating mandatory blocking on ports that allow non-encrypted text) might warrant using LDAPS.</p><p>Keep in mind that LDAPS and StartTLS can both be used for the same server. SLAPD can accept LDAPS traffic on a dedicated port, and continue to provide the StartTLS feature on an LDAP port.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>Like the StartTLS configuration, this configuration requires that the <code class="literal">slapd.conf</code> file have the <code class="literal">TLSCertificateFile</code>, <code class="literal">TLSCertificateKeyFile</code>, and <code class="literal">TLSCACertificateDir</code> directives set.</p></div></div><p>Getting SLAPD to listen on this port requires passing an additional parameter when starting <code class="literal">slapd</code>. In Ubuntu, as with other Debian-based distributions, configuration parameters can be set in the <code class="literal">/etc/defaults/slapd</code> file. In that file we just need to set <code class="literal">SLAPD_SERVICES</code>. When the start script is executed, SLAPD will start all of the services listed here.</p><div><pre class="programlisting">SLAPD_SERVICES="ldap:/// ldaps:///"</pre></div><p>The given code tells SLAPD to listen on all available IP addresses on both the default LDAP (port 389) and the default LDAPS (port 636). If we wanted SLAPD to only listen on one address for LDAP traffic, but all addresses for LDAPS traffic, we could replace the above with:</p><div><pre class="programlisting">SLAPD_SERVICES="ldap://127.0.0.1/ ldaps:///"</pre></div><p>Here, the <code class="literal">ldap://127.0.0.1/</code> tells SLAPD to only listen on the loopback address for LDAP traffic, while <code class="literal">ldaps:///</code> indicates that SLAPD should listen for LDAPS traffic on all of the IP addresses configured for this host. You will need to restart SLAPD in order for these changes to take effect.</p><p>Similarly, if you built from source and want to start <code class="literal">slapd</code> directly, the <code class="literal">-h</code> command line flag lets you specify which services to start:</p><div><pre class="programlisting">/usr/local/libexec/slapd -h "ldap:/// ldaps:///"</pre></div><p>That is all there is to configuring LDAPS. We can now test it with <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">
<strong>  ldapsearch -LL -x -W -D 'cn=Manager,dc=example,dc=com' -H \ </strong>
<strong>      ldaps://example.com '(uid=manny)'</strong>
</pre></div><p>There are two crucial differences between this <code class="literal">ldapsearch</code> and the ones we used when testing StartTLS: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The protocol for the URL specified after the <code class="literal">-H</code> flag is <code class="literal">ldaps://</code> rather than <code class="literal">ldap://</code>.</li><li class="listitem" style="list-style-type: disc">There is no <code class="literal">-Z</code> or <code class="literal">-ZZ</code> flag here. Those flags tell the client to send the StartTLS command, and SSL/TLS over a dedicated port do not recognize the StartTLS command.</li></ul></div><p>If you get an error doing the given search, but StartTLS is working properly, the first place to look is at the firewall settings. Typically, firewalls allow traffic on port 389, but block 636. It is also useful to make sure that the server is actually listening on port 636. You can check this from a shell prompt using <code class="literal">netstat –tcp -l</code>, which will print out a list of what ports are being used. If LDAPS (636) does not show up, then check <code class="literal">/etc/defaults/slapd</code> again to make sure that the <code class="literal">SLAPD_SERVICES</code> directive is set correctly.<a class="indexterm" id="id331"/>
</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec45"/>Debugging with the OpenSSL Client</h3></div></div></div><a class="indexterm" id="id332"/><p>In some cases it is useful to be able to connect to SLAPD over LDAPS and watch the certificate processing. The <code class="literal">openssl</code> program can do this with its built-in <code class="literal">s_client</code> client application:</p><div><pre class="programlisting">
<strong>  $ openssl s_client -connect example.com:636</strong>
</pre></div><p>The <code class="literal">-connect</code> parameter takes a host name followed by a colon and a port number. When this command is run, <code class="literal">openssl</code> will connect to a remote server using SSL, and perform the certificate negotiation. The entire negotiation process is written to the screen. If certificate negotiation succeeds, then <code class="literal">openssl</code> leaves the connection open, and you can type in raw protocol commands at the command line. To exit, just hit <em>CTRL</em>+<em>C</em>.</p><p>Now we have both StartTLS and TLS/SSL working. We have one more short item to cover in this section, and then we will move on to authentication.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Using Security Strength Factors</h2></div></div></div><a class="indexterm" id="id333"/><p>There are advantages to running StartTLS. It is simpler to configure, it is easier (in many respects) to debug, and complex transactions can switch back and forth from cleartext to encryption as needed.</p><p>But there is one clear drawback: we can use a standard firewall to block non-encrypted traffic when all clear text goes over one port and all encrypted traffic goes over another. But when both go over the same port, many firewalls can't do much to verify that the traffic is secure.</p><p>But OpenLDAP does provide some tools for implementing this sort of security in SLAPD, instead of in a firewall.</p><p>OpenLDAP can examine the integrity and encryption state of a connection and, based on those features, assign a <strong>Security Strength Factor (SSF)</strong> to that connection. An SSF is a numeric representation of the strength of the protective measures used.</p><p>Most of the SSF numbers simply reflect the key length of the encryption cipher. For example, since the maximum key length for <strong>DES</strong> is 56, when a connection is protected using DES, the SSF is 56. <strong>Triple-DES (3DES)</strong>, which is the cipher used by default in Ubuntu's OpenSSL configuration, has a key length of 112. Hence, its SSF is also 112. The <strong>AES</strong> cipher, which is strong and can be computed quickly, can use different key sizes. AES-128 uses a 128-bit key, while AES-256 uses a 256-bit key. In the case of AES then, the SSF will reflect the key size.</p><p>There are two special SSF numbers: 0 and 1. An SSF of 0 indicates (as might be expected) that no security measures have been implemented. An SSF of 1 indicates that only integrity checking on the connection is being done.</p><p>OpenLDAP can use SSF information to determine whether a client is allowed to connect to the directory. SSF information can also be used in ACLs and in SASL configuration, effectively allowing complex rules to be built as to what conditions a client connection must satisfy before getting access to perform certain operations on the directory.</p><p>We will look at SASL authentication and ACLs later in this chapter, but right now we will look at using SSFs in the <code class="literal">security</code> directive in <code class="literal">slapd.conf</code> as a way of specifying how secure a connection must be in order to access the database.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec46"/>The security Directive</h3></div></div></div><a class="indexterm" id="id334"/><p>The <code class="literal">security</code> directive can be used in two different contexts in <code class="literal">slapd.conf</code>. If it is put near the top of the file, before any backend databases are defined, then it is placed in the <em>global</em> context and will apply to all connections. On the other hand, if the security directive is placed within a backend definition, then it will only be applied to that particular database. For example, consider a case where there are two backends:</p><div><pre class="programlisting">include /etc/ldap/schema/core.schema

modulepath /usr/local/libexec/openldap
moduleload back_hdb
# Other configuration directives ...

# DB 1:
database hdb
suffix "ou=Users,dc=example,dc=com"
# More directives for DB 1...
# DB 2:
database bdb
suffix "ou=System,dc=example,dc=com"
# More directives for DB 2...</pre></div><p>This partial example of a <code class="literal">slapd.conf</code> file defines two directory backends. Now, if the <code class="literal">security</code> directive is used before the first database is defined (namely before the line that says <code class="literal">database hdb</code>), then it will be applied globally to all connections.</p><p>But if we wanted to allow non-encrypted connections to DB 2, but allow only well-encrypted connections to DB 1 (which houses all of our user entries), we could use separate <code class="literal">security</code> directives:</p><div><pre class="programlisting">include /etc/ldap/schema/core.schema

modulepath /usr/local/libexec/openldap
moduleload back_hdb
loglevel stats
# Other configuration directives ...

# DB 1:
database hdb
suffix "ou=Users,dc=example,dc=com"
<strong>security ssf=112</strong>
# More directives for DB 1...

# DB 2:
database bdb
suffix "ou=System,dc=example,dc=com"
<strong>security ssf=0</strong><a class="indexterm" id="id335"/>
# More directives for DB 2...</pre></div><p>Note the addition of the two highlighted lines—two separate <code class="literal">security</code> directives, one for each database backend.</p><p>Now, restarting the directory (note that the <code class="literal">loglevel</code> is set to <code class="literal">stats</code>), we can test out the security parameters with <code class="literal">ldapsearch</code>. First, we will try to search the <code class="literal">Users</code> OU with a non-TLS connection:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -W -D 'uid=matt,ou=Users,dc=example,dc=com' -b \ </strong>
<strong>               'ou=Users,dc=example,dc=com' '(uid=david)' uid</strong>
</pre></div><p>In the log we see entries like this:</p><div><pre class="programlisting">conn=0 fd=12 ACCEPT from IP=127.0.0.1:48758 (IP=0.0.0.0:389)
conn=0 op=0 BIND dn="uid=matt,ou=Users,dc=example,dc=com" method=128
conn=0 op=0 RESULT tag=97 err=13 text=confidentiality required
conn=0 fd=12 closed (connection lost)
connection_read(12): no connection!</pre></div><p>The third line indicates that the server returned error number 13: <code class="literal">confidentiality required</code>. This is because we did not do anything to protect the connection. Using simple authentication (which is not encrypted) and failing to use TLS/SSL resulted in the client connection having an effective SSF of 0.</p><p>Next, let's do the same search with TLS turned on:</p><div><pre class="programlisting">
<strong> $ ldapsearch -x -W -D 'uid=matt,ou=Users,dc=example,dc=com' -b \ </strong>
<strong>              'ou=Users,dc=example,dc=com' -Z '(uid=david)' uid</strong>
</pre></div><p>Note that in this example, the <code class="literal">-Z</code> flag is included to send the StartTLS command. Now, the server log says:</p><div><pre class="programlisting">conn=1 fd=12 ACCEPT from IP=127.0.0.1:44684 (IP=0.0.0.0:389)
conn=1 op=0 STARTTLS
conn=1 op=0 RESULT oid= err=0 text=
conn=1 fd=12 TLS established tls_ssf=256 ssf=256
conn=1 op=1 BIND dn="uid=matt,ou=Users,dc=example,dc=com" method=128
conn=1 op=1 BIND dn="uid=matt,ou=Users,dc=example,dc=com" mech=SIMPLE ssf=0
conn=1 op=1 RESULT tag=97 err=0 text=</pre></div><p>There are a few things to note about this result. On the second line, OpenLDAP reports that it is doing StartTLS. Two lines later it reports: <code class="literal">TLS established tls_ssf=256 ssf=256</code>. This line indicates that the TLS connection has an SSF of 256 <a class="indexterm" id="id336"/>(since the connection is using AES-256), and that the total SSF of the connection is 256.</p><p>If you look a few lines lower, on the second line that begins <code class="literal">BIND</code>, you will notice that there another SSF is reported: <code class="literal">ssf=0</code>. Why?</p><p>OpenLDAP measures SSF on various aspects of the connection. First, as we can see above, it checks the SSF of the network connection. TLS/SSL connections are assigned an SSF based on their cipher strength.</p><p>But during the bind phase when the client authenticates to the directory, OpenLDAP also measures the SSF of the authentication mechanism. The simple (<code class="literal">mech=SIMPLE</code>) authentication mechanism does not encrypt the password, and so it is always given an SSF of 0.</p><p>The total SSF for the connection, however, remains at 256, with the TLS SSF being 256 and the SASL SSF at 0.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec21"/>A Fine-Grained security Directive</h4></div></div></div><p>The <code class="literal">security</code> directive that we have looked at so far is basic. It simply requires that the overall SSF be 112 (3DES encryption) or greater, but we can make it more specific.</p><p>For example, we can simply require that any TLS connection have at least a 128 bit key:</p><div><pre class="programlisting">security tls=128</pre></div><p>This will require that all incoming connections use TLS with a strong (128 bit or greater) cipher.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>In some cases it is desirable to define which TLS/SSL ciphers or cipher families will be used. This cannot be done with the <code class="literal">security</code> directive. Instead, you will need to use the <code class="literal">TLSCipherSuite</code> directive, which will allow you to give a detailed specification for which ciphers are acceptable for TLS/SSL connections.</p></div></div><p>Or, if we only wanted to define a strong SSF for connections that try to perform a simple bind (as opposed to an SASL bind), then we can specify an SSF just for simple binding:</p><div><pre class="programlisting">security simple_bind=128</pre></div><p>This will require that some strong TLS cipher be used to protect the authentication information.<a class="indexterm" id="id337"/>
</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>If you plan to allow simple binding, and you are running on a non-secure network, you are strongly advised to configure TLS/SSL and require TLS encryption during the bind operation using the <code class="literal">security</code> directive.</p></div></div><p>You can also use the <code class="literal">update_ssf</code> keyword in the <code class="literal">security</code> directive to set the SSF necessary for updating operations. Thus you could specify that only low-grade encryption is needed for reading the directory, but high-grade encryption must be used for performing updates to directory information:</p><div><pre class="programlisting">security ssf=56 update_ssf=256</pre></div><p>In the coming section, we will look at SASL configuration. You can use the <code class="literal">security</code> directive to set SSF for SASL binding as well using the <code class="literal">sasl=</code> and <code class="literal">update_sasl=</code> phrases.</p><p>Finally, in rare cases where OpenLDAP is listening on a local socket (that is, <code class="literal">ldapi://</code>), you can use  <code class="literal">security transport=112</code> (or whatever cipher strength you desire) to ensure that traffic coming over that socket is encrypted.</p><p>At this point, we have completed our examination of SSL and TLS. Next, we will move on to the second of our three aspects of security: authentication.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Authenticating Users to the Directory</h1></div></div></div><a class="indexterm" id="id338"/><p>As we have seen earlier in the book, OpenLDAP supports two different methods of binding (or authenticating) to the directory. The first is to use simple binding. The second is to use SASL binding. In this part we will look at each of these two methods of authentication.</p><p>It is not necessary to choose one or the other. OpenLDAP can be configured to do both, at which point it is up to the client as to which method will be used. Simple binding is easier to configure (there is very little configuration that must be done). But SASL is more secure and more flexible, though these benefits come at the cost of added complexity.</p><p>The basics of the bind operation and the authentication process are covered early in Chapter 3. While we will review some of that materials here, you may find it useful to glance back at that section.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Simple Binding</h2></div></div></div><a class="indexterm" id="id339"/><a class="indexterm" id="id340"/><p>The first form of authentication we will look at is simple binding. It is simple not necessarily from the user's perspective, but it is definitely easier to configure, and the process of binding is easier on the server, too, since less processing is needed.</p><p>To perform a simple bind the server requires two pieces of information: a DN and a password. If both the DN and the password fields are empty then the server attempts to bind as the Anonymous user.</p><p>During a simple bind the client connects to the server and sends the DN and password information to the server, without adding any additional security. The password, for example, is not specially encrypted.</p><p>If the client is communicating over TLS/SSL, then the whole transaction will be encrypted, and so the password will be safe. If the client is not using TLS/SSL then the password will be sent over the network in cleartext. This, of course, is a security issue, and should be avoided (perhaps by using the <code class="literal">security</code> directive discussed in the previous section, or by using an SASL bind instead of a simple bind).</p><p>There are two common ways in which client applications attempt to perform a simple <a class="indexterm" id="id341"/>
<a class="indexterm" id="id342"/>bind. The first is sometimes called <strong>Fast Bind</strong>. In a Fast Bind, the client supplies a full DN (<code class="literal">uid=matt,ou=users,dc=example,dc=com</code>) and also a password (<code class="literal">myPassword</code>). It is faster than the common alternative (binding as anonymous and searching for the desired DN).</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>
<strong>Cyrus SASLAuthd</strong>, which provides SASL authentication services to other applications, is the application in which the term "Fast Bind" was first used. SASLAuthd is a useful tool for providing SASL authentication services. We will look at it again in the next section. Nowhere in the OpenLDAP documentation, is the term "Fast Bind" used.</p></div></div><p>The directory first performs, as the anonymous user, an <strong>auth</strong> access on the <code class="literal">userPassword</code> attribute of the DN that the client supplies. In an auth access the server compares the value of the supplied password to the value of the <code class="literal">userPassword</code> stored in the directory. If the <code class="literal">userPassword</code> value is hashed (with, for example, SSHA or SMD5), then SLAPD hashes the password that the user supplies, and then compares the hashes. If the values match, OpenLDAP binds the user and allows it to perform other LDAP operations.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>The OpenLDAP command-line clients, when used with the <code class="literal">-x</code> option, perform simple binding. The clients require that you specify the entire user DN and a password, and they then perform a Fast Bind.</p></div></div><p>That's a Fast Bind. But there is a second common method of doing a simple bind—a method designed to eliminate the requirement that the user know an entire DN.</p><a class="indexterm" id="id343"/><a class="indexterm" id="id344"/><p>In this second method (which is not, incidentally, called a "slow bind"), the client application requires that the user only know some particular unique identifier—usually the value of <code class="literal">uid</code> or <code class="literal">cn</code>. The client application then binds to the server as anonymous (or another pre-configured user) and performs a search for a DN that contains the matching attribute value. If it finds one (and only one) matching DN, then it re-binds, using the retrieved DN and the user-supplied password.</p><p>Usually, client applications that use simple bind will need a base DN. The second method of performing a simple bind requires one additional piece of information not required in a Fast Bind: a search filter. The filter is usually something like <code class="literal">(&amp;(uid=?)(objectclass=inetOrgPerson))</code>, where the question mark (<code class="literal">?</code>) is replaced by the user-supplied value.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec47"/>Using an Authentication User for Simple Binding</h3></div></div></div><a class="indexterm" id="id345"/><p>While it is more convenient for the user when only a user ID or a CN is required, the second method we have seen may raise an additional concern: the Anonymous user, in order to perform the search, must have <em>read</em> access to all user records in the directory. This means that anyone can connect to the directory (remember, Anonymous has no password) and perform searches.</p><p>In many cases this isn't a problem. Allowing someone to see a list of all the users in the directory may not be a security concern at all. But in other cases, such access would not be acceptable.</p><p>One way to work around this problem is to use a different user (rather than Anonymous) to perform the search for the user's DN. In the last chapter, we created just such an account. Here is the LDIF record we used:</p><div><pre class="programlisting"># Special Account for Authentication:
dn: uid=authenticate,ou=System,dc=example,dc=com
uid: authenticate
ou: System
description: Special account for authenticating users
userPassword: secret
objectClass: account
objectClass: simpleSecurityObject</pre></div><p>The purpose of this account is to log into the server and perform searches for DNs. In other words, it conducts the same job as the Anonymous user, but it adds a little more security, since clients that use the <code class="literal">uid=authenticate</code> account will have to have the appropriate password, too.</p><p>To make this clear let's look at the case where a client, configured to use the Authenticate account, binds a user that identifies himself as <code class="literal">matt</code> with the password <code class="literal">myPassword</code>.</p><p>Here's a step-by-step breakdown of what happens when doing a bind operation this way:</p><div><ol class="orderedlist arabic"><li class="listitem">Client connects to the server and starts a bind operation with the DN <code class="literal">uid=autenticate,ou=system,dc=example,dc=com</code> and the password <code class="literal">secret</code>.</li><li class="listitem">The server, as Anonymous, compares the Authenticate password, <code class="literal">secret</code>, with the value of the <code class="literal">userPassword</code> attribute for the <code class="literal">uid=autenticate,ou=system,dc=example,dc=com</code> record.</li><li class="listitem">If the above succeeds, then the client (now logged in as the Authenticate user) performs a search with the filter: <code class="literal">(&amp;(uid=matt)(objectclass=inetOrgPerson))</code>. Since <code class="literal">uid</code> is unique, the search should return either 0 or 1 record.<a class="indexterm" id="id346"/></li><li class="listitem">If one matching DN is found (in our case, it would be <code class="literal">uid=matt,ou=user,dc=example,dc=com</code>), then the client tries to re-bind as this DN, and using the password the user initially supplies to the client (<code class="literal">myPassword</code>).</li><li class="listitem">The server, as Anonymous, compares the user-supplied password, <code class="literal">myPassword</code>, with the value of the <code class="literal">userPassword</code> attribute of <code class="literal">uid=matt,ou=user,dc=example,dc=com</code>.</li><li class="listitem">If the password comparison succeeds then the client application can continue performing LDAP operations as <code class="literal">uid=matt,ou=user,dc=example,dc=com</code>.</li></ol></div><p>The process is lengthy and it requires that the client application be configured with bind DN and password information for the Authenticate user, but it adds an additional layer of security to an Anonymous bind and search.</p><p>In this section, we have looked at three different ways of performing a simple bind. Each of these methods is useful in particular circumstances, and when used in conjunction with SSL/TLS, simple binding does not pose a significant security threat when the password is transmitted across the network.</p><div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>
<strong>Simple Binding Directives in slapd.conf</strong>
</p><p>There are only a few directives in <code class="literal">slapd.conf</code> that have any bearing on simple binding. Simple binding is allowed by default. To prevent SLAPD from accepting simple bind operations, you can use the <code class="literal">require SASL</code> directive which will require that all bind operations are SASL bind operations. Additionally, the <code class="literal">security</code> directive provides the <code class="literal">simple_bind=</code> SSF check, which can be used to require a minimum SSF for simple bind operations. This is covered in more detail in the section entitled <em>The</em> <em>security</em> <em>Directive</em>.</p></div></div><p>Later in this book we will examine several third party applications that use simple binding when connecting to the directory.<a class="indexterm" id="id347"/>
</p><p>But there are times when it is desirable to have an even more secure authentication process, or when the bind-search-rebind method of simple binding is too much for the client to do. In such cases using SASL binding may be even better.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>SASL Binding</h2></div></div></div><a class="indexterm" id="id348"/><a class="indexterm" id="id349"/><p>SASL provides a second method of authenticating to the OpenLDAP directory. SASL works by supplanting the simple bind method outlined above with a more robust authentication process.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>The SASL standard is defined in RFC 2222 ( <a class="ulink" href="http://www.rfc-editor.org/rfc/rfc2222.txt">http://www.rfc-editor.org/rfc/rfc2222.txt</a>).</p></div></div><p>SASL supports a number of different kinds of underlying authentication mechanisms, ranging from login/password combinations to more complex configurations like <a class="indexterm" id="id350"/>
<strong>One-Time Passwords (OTP)</strong> and even <strong>Kerberos</strong> ticket-based authentication. <a class="indexterm" id="id351"/>
</p><p>While SASL provides dozens of different configuration options, we will cover only one. We will configure SASL for doing <strong>DIGEST-MD5</strong> authentication. It is slightly more difficult to set up than some SASL mechanisms, but does not require the detailed configuration involved in <strong>GSSAPI</strong> or Kerberos.</p><p>Later in this chapter, we will integrate our SASL work with our SSL/TLS work, and use the <strong>SASL EXTERNAL mechanism</strong> for authenticating to the directory with client SSL certificates.<a class="indexterm" id="id352"/>
</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>The Cyrus SASL documentation (at <code class="literal">/usr/share/doc/libsasl2</code> or available online at <a class="ulink" href="http://asg.web.cmu.edu/sasl/">http://asg.web.cmu.edu/sasl/</a>) provides information on implementing other mechanisms.</p></div></div><p>In DIGEST-MD5 authentication, the user's password will be encrypted by the SASL client, sent across the network in its encrypted form only, then decrypted by the server and compared to a cleartext version of the password.</p><p>The advantage to using DIGEST-MD5 is that the password is protected when transmitted over the network. The disadvantage, however, is that the passwords must be stored on the server in cleartext.</p><p>Contrast this with the way simple bind works. In a simple bind the password itself is not encrypted when crossing the network, but the copy of the password stored in the database is stored in an encrypted format (unless you configure OpenLDAP otherwise).</p><p>Keep in mind that when SSL/TLS is used, all data transmitted over the connection is encrypted, including passwords.</p><p>Configuring SASL is more complex than configuring simple bind operations. There are two parts to configuring SASL support:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuration of Cyrus SASL</li><li class="listitem" style="list-style-type: disc">Configuration of OpenLDAP</li></ul></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec48"/>Configuring Cyrus SASL</h3></div></div></div><a class="indexterm" id="id353"/><a class="indexterm" id="id354"/><p>When we installed OpenLDAP in Chapter 2, one of the packages we installed was Cyrus SASL (the library was named <code class="literal">libsasl2</code>). We will also need the SASL command-line tools, which are included in the <code class="literal">sasl2-bin</code> package:</p><div><pre class="programlisting">
<strong>  $ sudo apt-get install sasl2-bin</strong>
</pre></div><p>Included in this package are the <code class="literal">saslpasswd2</code> program and the SASL testing client and server applications.</p><p>Now we are ready to start configuring.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec22"/>The SASL Configuration File</h4></div></div></div><a class="indexterm" id="id355"/><p>The SASL library can be used by numerous applications, and each application can have its own SASL configuration file. SASL configuration files are stored in the <code class="literal">/usr/lib/sasl2</code> directory. In that directory, we will create a configuration file for OpenLDAP. The file, <code class="literal">slapd.conf</code>, looks like this:</p><div><pre class="programlisting"># SASL Configuration
pwcheck_method: auxprop
sasldb_path: /etc/sasldb2</pre></div><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Do not confuse this <code class="literal">slapd.conf</code>, located at <code class="literal">/usr/lib/sasl2</code> with the main <code class="literal">slapd.conf</code> file at <code class="literal">/etc/ldap/</code>. These are two different files.</p></div></div><p>As usual, lines that begin with the <code class="literal">pound sign (#)</code> are comments. The second line determines how SASL will try to check passwords. For example, SASL comes with a stand-alone server, <strong>saslauthd</strong>, which will handle password checking. In our case though, we want to use the <code class="literal">auxprop</code> plugin, which does the password checking itself, rather than querying the <code class="literal">saslauthd</code> server.</p><p>The last line tells SASL where the password database (which stores a cleartext version of all of the passwords) is located. The standard location for this database is <code class="literal">/etc/sasldb2</code>.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec23"/>Setting a User Password</h4></div></div></div><a class="indexterm" id="id356"/><p>As we get started, we will store the SASL password in the <code class="literal">/etc/sasldb2</code> database. To add a password to the database we use the <code class="literal">saslpasswd2</code> program:</p><div><pre class="programlisting">
<strong>  $ sudo saslpasswd2 -c -u example.com matt </strong>
</pre></div><p>Note that we have to run the above using <code class="literal">sudo</code> because the password file is owned by root. Both <code class="literal">sudo</code> and <code class="literal">saslpasswd2</code> will prompt you to enter a password.</p><p>The <code class="literal">-c</code> argument for <code class="literal">saslpasswd2</code> indicates that we want the user ID to be created if it does not already exist. <code class="literal">-u example.com</code> sets the <strong>SASL realm</strong>. SASL uses realms as a way to partition the authentication name space. Client applications typically provide SASL with three pieces of information: the username, the password, and the realm. By default, clients will send their domain name as the realm.</p><p>Using realms, it is possible to give the same user name different passwords for different applications or application contexts. For example, <code class="literal">matt</code> in realm <code class="literal">example.com</code> can have one password, while <code class="literal">matt</code> in realm <code class="literal">testing.example.com</code> can have a different password.</p><p>For our purposes we need only one realm, and we will name it <code class="literal">example.com</code>. When the given command is run it will prompt for a password for user <code class="literal">matt</code>, and then prompt for a password confirmation. If the passwords match, it will store the password in clear text in the SASL password database.</p><p>Now we are ready to configure OpenLDAP.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec49"/>Configuring SLAPD for SASL Support</h3></div></div></div><a class="indexterm" id="id357"/><a class="indexterm" id="id358"/><p>The OpenLDAP side of SASL configuration is done in the <code class="literal">slapd.conf</code> file for the server, and the <code class="literal">ldap.conf</code> file for the client. In this section, we will focus on the SLAPD server.</p><p>When OpenLDAP receives a SASL authentication request it receives four pieces of information from the client. The four fields of information it gets are: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Username: This field contains the ID that the user supplied when authenticating.</li><li class="listitem" style="list-style-type: disc">Realm: This field contains the SASL realm in which the user is authenticated.</li><li class="listitem" style="list-style-type: disc">SASL Mechanism: This field indicates which authentication system (mechanism) was used. Given our SASL configuration, this should be DIGEST-MD5.</li><li class="listitem" style="list-style-type: disc">Authentication Information: This field is always set to <code class="literal">auth</code> to indicate that the user needs authentication.</li></ul></div><p>All of this information is compacted into one DN-like string that looks like this:</p><div><pre class="programlisting">uid=matt,cn=example.com,cn=DIGEST-MD5,cn=auth</pre></div><p>The order of the fields above is the same as the order of the bulleted list: User-name, realm, SASL mechanism, and authentication information. Note however, that the realm is not required and might not always be present. If SASL does not use any realm information, the realm field will be omitted.</p><p>Of course, we do not have any records in our LDAP with DNs like the SASL string above. So, in order to correlate the authenticated SASL user with a user in the LDAP, we need to set up some method of converting the above DN-like string into a DN that is structured like the DNs in the directory. So we want to make the given string into something like this:</p><div><pre class="programlisting">uid=matt,ou=Users,dc=example,dc=com</pre></div><p>There are two ways of doing this mapping. We can either configure a simple string replacement rule to convert the SASL information string to a DN like the last one, or we could perform a search of the directory for an entry with a <code class="literal">uid</code> that is <code class="literal">matt</code>, and then, if a match is found, use that matching entry's DN.</p><p>Each of these two methods has its advantages and disadvantages. Using string replacement is faster, but it is less flexible, and it may not be sufficient for complex directory information trees. Using string replacement it may be necessary to use several <code class="literal">authz-regexp</code> directives in a row, each one with a different regular expression and replacement string.</p><p>Searching for the user on the other hand, can be much more flexible in a directory with lots of subtrees. But it will incur the overhead of doing an additional search of the LDAP tree, and it may require tweaking ACLs to allow pre-authentication searches.</p><p>Both methods use the same directive in <code class="literal">slapd.conf</code>: the <code class="literal">authz-regexp</code> directive. Let's look at an example of each method, beginning with the string replacement method.<a class="indexterm" id="id359"/>
</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec24"/>Using a Replacement String in authz-regexp</h4></div></div></div><a class="indexterm" id="id360"/><p>The <code class="literal">authz-regexp</code> directive takes two parameters: a regular expression for getting information out of the SASL DN-like string, and a replacement function (which is different depending on whether we do string replacement or a search).</p><p>For our regular expression we want to take the username from the SASL information and map it to the <code class="literal">uid</code> field in a DN. We don't really need any of the information in the other three SASL fields, so our regular expression is fairly simple:</p><div><pre class="programlisting">"^uid=([^,]+).*,cn=auth$"</pre></div><p>This rule starts at the beginning of the line (<code class="literal">^</code>) and looks for an entry that starts with <code class="literal">uid=</code>. The next part, <code class="literal">([^,]+)</code>, stores characters after <code class="literal">uid=</code> and before a comma (<code class="literal">,</code>) in a special variable called <code class="literal">$1</code>. The rule reads "match as many characters as possible (but at least one character) that are not commas and store them in the first variable (<code class="literal">$1</code>)."</p><p>After that, the rule (using <code class="literal">.*</code> to match anything) skips over the realm (if there is one) and the mechanism, and then looks for a match at the end of the line: <code class="literal">cn=auth$</code> (where the dollar sign (<code class="literal">$</code>) indicates a line ending).</p><p>Once the regular expression is run we should have a variable, <code class="literal">$1</code>, which contains the user's name. Now we can use that value in a replacement rule, setting the <code class="literal">uid</code> value to the value of <code class="literal">$1</code>. The entire <code class="literal">authz-regexp</code> line looks like this:</p><div><pre class="programlisting">authz-regexp "^uid=([^,]+).*,cn=auth$"
             "uid=$1,ou=Users,dc=example,dc=com"</pre></div><p>After the <code class="literal">authz-regexp</code> directive, I have inserted the regular expression we just looked at. After the regular expression comes the replacement rule, which instructs SLAPD to insert the value of <code class="literal">$1</code> in the <code class="literal">uid</code> field of this template DN.</p><p>The <code class="literal">authz-regexp</code> directive can go anywhere in the <code class="literal">slapd.conf</code> file before the first <code class="literal">database</code> directive.</p><p>Since <code class="literal">authz-regexp</code> is the only necessary directive for configuring SASL, we can now test SLAPD from the command line, without making any additional changes to <code class="literal">slapd.conf</code>:</p><div><pre class="programlisting">$ ldapsearch -LLL -U matt@example.com -v '(uid=matt)' uid
ldap_initialize( &lt;DEFAULT&gt; )
SASL/DIGEST-MD5 authentication started
<strong>Please enter your password: </strong>
SASL username: matt@example.com
SASL SSF: 128
SASL installing layers
filter: (uid=matt)
requesting: uid 
dn: uid=matt,ou=Users,dc=example,dc=com
uid: matt</pre></div><p>Previously, we have used the <code class="literal">-x</code> flag, combined with <code class="literal">-W</code> and <code class="literal">-D</code>, to do a simple bind with a full DN and a password.</p><p>With SASL however, we don't need the full DN. All we need is a shortened connection string. So, instead of using the <code class="literal">-x</code>, <code class="literal">-W</code>, and <code class="literal">-D</code> flags, we just use <code class="literal">-U matt@example.com</code>. The <code class="literal">-U</code> flag takes a SASL username and (optionally) a realm. The realm is appended to the username, separated by the <em>at</em> sign (<code class="literal">@</code>). So, in the given example, we are connecting with username <code class="literal">matt</code> and realm <code class="literal">example.com</code>.</p><p>Next, <code class="literal">ldapsearch</code> prompts for a password (see the highlighted line in the example). This is not our LDAP password, but our SASL password—the one in the account we created when we ran <code class="literal">saslpasswd2</code>.<a class="indexterm" id="id361"/>
</p><p>To review, what is happening in the previous command is this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The client is connecting to SLAPD requesting an SASL bind.</li><li class="listitem" style="list-style-type: disc">SLAPD uses the SASL subsystem (which checks the <code class="literal">/usr/lib/sasl/slapd.conf</code> file for settings) to tell the client how to authenticate. In this case, it tells the client to use DIGEST-MD5.</li><li class="listitem" style="list-style-type: disc">The client sends the authentication information to SLAPD.</li><li class="listitem" style="list-style-type: disc">SLAPD performs the translation specified in <code class="literal">authz-regexp</code>.</li><li class="listitem" style="list-style-type: disc">SLAPD then checks the client's response (using the SASL subsystem) against the information in <code class="literal">/etc/sasldb2</code>.</li><li class="listitem" style="list-style-type: disc">When the client authentication succeeds, OpenLDAP runs the search and returns the results to the client.</li></ul></div><p>Now we are ready to look at using <code class="literal">authz-regexp</code> to search the directory with a specific filter.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec25"/>Using a Search Filter in authz-regexp</h4></div></div></div><a class="indexterm" id="id362"/><p>In this case, we want to search the directory for an entry that matches the username (<code class="literal">uid</code>) received during the SASL bind. Recall that the SASL authentication information comes in a string that looks like this:</p><div><pre class="programlisting">uid=matt,cn=example.com,cn=DIGEST-MD5,cn=auth</pre></div><p>In the last case, we mapped the given  directly on to a DN of the form:</p><div><pre class="programlisting">uid=&lt;username&gt;,ou=users,dc=example,dc=com.</pre></div><p>But what do we do if we don't know, for example, if the user <code class="literal">matt</code> is in the Users OU or the System OU? A simple mapping function will not work. We need to search the directory. We will do this by changing the last argument in our <code class="literal">authz-regexp</code> directive.</p><p>Our new <code class="literal">authz-regexp</code> directive looks like this:</p><div><pre class="programlisting">authz-regexp "^uid=([^,]+).*,cn=auth$"
             "ldap:///dc=example,dc=com??sub?(uid=$1)"</pre></div><p>This regular expression is the same as the one in the previous example. But the second argument to <code class="literal">authz-regexp</code> is an LDAP URL.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>For an overview of writing and using LDAP URLs see <a class="link" href="apb.html" title="Appendix B. LDAP URLs">Appendix B</a>.</p></div></div><a class="indexterm" id="id363"/><p>This LDAP URL instructs SLAPD to search in the base <code class="literal">dc=example,dc=com</code> (using a subtree (<code class="literal">sub</code>) search) for an entry whose <code class="literal">uid</code> equals the value of <code class="literal">$1</code>, which gets replaced by the value retrieved from the regular expression in the first argument to <code class="literal">authz-regexp</code>. If the user <code class="literal">matt</code> attempts to authenticate, for example, the URL will look like this:</p><div><pre class="programlisting">ldap:///dc=example,dc=com??sub?(uid=matt)</pre></div><p>When SLAPD performs that search against our directory information tree, it will get a single record back—the record with the DN <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code>.</p><p>Here's an example using <code class="literal">ldapsearch</code>. It is the same example used in the previous section, and it should have the same results even though we are using the LDAP search method:</p><div><pre class="programlisting">$ ldapsearch -LLL -U matt@example.com -v '(uid=matt)' uid
ldap_initialize( &lt;DEFAULT&gt; )
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt@example.com
SASL SSF: 128
SASL installing layers
filter: (uid=matt)
requesting: uid 
dn: uid=matt,ou=Users,dc=example,dc=com
uid: matt</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec26"/>A Note on ACLs and Search Filters</h4></div></div></div><a class="indexterm" id="id364"/><p>When SLAPD reads the search filter, it performs a search of the directory. But the search is done as the Anonymous user. What this means is that we will need to make sure that the Anonymous user will need to have the requisite permissions to search the directory using the filter.</p><p>Given our last example, the Anonymous user will need to be able to search the <code class="literal">dc=example,dc=com</code> subtree for <code class="literal">uid</code> values. The ACLs that we created in Chapter 2 do not grant the Anonymous user any such permission. We will need to add one rule to our ACLs in order to allow the search to operate successfully:</p><div><pre class="programlisting">access to attrs=uid
       by anonymous read
       by users read</pre></div><p>This rule, which should appear at the top of the list of ACLs, grants read access to the <code class="literal">uid</code> attribute to <code class="literal">anonymous</code> and to any authenticated users on the system. The important part, in this example, is that Anonymous gets read access.</p><p>Keep in mind that by adding this rule, we are making it possible for unauthenticated users to see what user IDs exist in the database. Depending on the nature of your directory data, this may be a security issue. If this is a problem you can either use the string replacement method (remember, you can use several <code class="literal">authz-regexp</code> expressions in a row to handle more complex pattern matching), or you can try to reduce exposure to the <code class="literal">uid</code> field by building more restrictive ACLs</p><p>Later in this chapter, we will take a more detailed look at ACLs.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec27"/>Failure of Mapping</h4></div></div></div><a class="indexterm" id="id365"/><p>In some cases the mapping done by <code class="literal">authz-regexp</code> will fail. That is, SLAPD will search the directory (using the search filter) and not find any matches. The user, however, is authenticated, and SLAPD will not fail to bind.</p><p>Instead, what will happen is that the user will bind as the SASL DN. Thus, the effective DN may be something like:</p><div><pre class="programlisting">uid=matt,cn=example.com,cn=digest-md5,cn=auth</pre></div><p>It makes no difference that there is no actual record in the directory with that username. The client will still be able to access the directory.</p><p>But this DN is also subject to ACLs, so you can write access controls targeted at users who have authenticated through SASL but who do not have a DN corresponding to a record in the directory.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec28"/>Removing the Need to Specify the Realm</h4></div></div></div><a class="indexterm" id="id366"/><p>In our configuration all of the users are in the same realm, <code class="literal">example.com</code>. Rather than typing that the username and the realm be typed in every time, we can configure a default realm in <code class="literal">slapd.conf</code> by adding the following directive:</p><div><pre class="programlisting">sasl-realm  example.com</pre></div><p>If we restart the server with this new modification, we can now run an <code class="literal">ldapsearch</code> without having to specify the realm:</p><div><pre class="programlisting">$ ldapsearch -LLL -U matt -v '(uid=matt)' uid
ldap_initialize( &lt;DEFAULT&gt; )
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
filter: (uid=matt)
requesting: uid 
dn: uid=matt,ou=Users,dc=example,dc=com
uid: matt</pre></div><p>This time, passing <code class="literal">-U matt</code> was sufficient for authentication. SLAPD automatically inserted the default realm into the SASL information.<a class="indexterm" id="id367"/>
</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec29"/>Debugging the SASL Configuration</h4></div></div></div><a class="indexterm" id="id368"/><p>Getting the correct SASL configuration can be frustrating. One way of improving your ability to debug is to configure logging in such a way that you can see what is going on during a SASL transaction. The <code class="literal">trace</code> debugging level (<code class="literal">1</code>) can be used to watch what is happening in SASL. You can either set the debug level in <code class="literal">slapd.conf</code> to trace (or just the digit <code class="literal">1</code>), or you can run <code class="literal">slapd</code> in the foreground on the command line:</p><div><pre class="programlisting">$ sudo slapd -d trace
# some of the voluminous output removed...
slap_sasl_getdn: u:id converted to uid=matt,cn=DIGEST-MD5,cn=auth
&gt;&gt;&gt; dnNormalize: &lt;uid=matt,cn=DIGEST-MD5,cn=auth&gt;
&lt;&lt;&lt; dnNormalize: &lt;uid=matt,cn=digest-md5,cn=auth&gt;
==&gt;slap_sasl2dn: converting SASL name uid=matt,cn=digest-md5,cn=auth 
                 to a DN
slap_authz_regexp: converting SASL name 
                   uid=matt,cn=digest-md5,cn=auth
slap_authz_regexp: converted SASL name to 
                   uid=matt,ou=Users,dc=example,dc=com
slap_parseURI: parsing uid=matt,ou=Users,dc=example,dc=com
ldap_url_parse_ext(uid=matt,ou=Users,dc=example,dc=com)
&gt;&gt;&gt; dnNormalize: &lt;uid=matt,ou=Users,dc=example,dc=com&gt;
&lt;&lt;&lt; dnNormalize: &lt;uid=matt,ou=users,dc=example,dc=com&gt;
&lt;==slap_sasl2dn: Converted SASL name to 
                 uid=matt,ou=users,dc=example,dc=com
slap_sasl_getdn: dn:id converted to 
                 uid=matt,ou=users,dc=example,dc=com</pre></div><p>Following this log, we can see the initial SASL string, <code class="literal">uid=matt,cn=DIGEST-MD5,cn=auth</code>, and watch as it is normalized, run through the regular expression, and converted to <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>.</p><p>The <code class="literal">ldapwhoami</code> client and the <code class="literal">slapauth</code> utility are also useful when attempting to debug SASL. An example of using <code class="literal">ldapwhoami</code> to evaluate the results of <code class="literal">authz-regexp</code> is given in the next section.<a class="indexterm" id="id369"/>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Using Client SSL/TLS Certificates to Authenticate</h2></div></div></div><a class="indexterm" id="id370"/><a class="indexterm" id="id371"/><a class="indexterm" id="id372"/><p>SASL and SSL/TLS can be used in combination to perform <strong>SASL EXTERNAL authentication</strong>. In SASL EXTERNAL authentication the SASL module relies upon an external source, in this case a client's X.509 certificate, as a source of identity.</p><p>Using this configuration a client with an appropriately signed certificate can bind to SLAPD without having to enter a username and password, but in a way that is still secure.</p><p>How does this work? Just as it is possible to issue a server a certificate for SSL/TLS communication, it is also possible to issue one to a user or client. We have discussed already how a certificate provides, in a secure way, identity information about a server. A client certificate can serve the same purpose.</p><p>Authentication, using SASL EXTERNAL works like this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The client and server communicate with SSL/TLS protection, either using LDAPS or using StartTLS</li><li class="listitem" style="list-style-type: disc">When the server sends its certificate, it requests that the client also provide a certificate</li><li class="listitem" style="list-style-type: disc">The client sends its own certificate, which includes the following<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identity information</li><li class="listitem" style="list-style-type: disc">A public key</li><li class="listitem" style="list-style-type: disc">The signature of a certificate authority that the server will recognize</li></ul></div></li><li class="listitem" style="list-style-type: disc">The server, after verifying the certificate, passes the identity information on to SLAPD through the SASL subsystem</li><li class="listitem" style="list-style-type: disc">SLAPD then uses that information to bind</li></ul></div><p>Since the certificate sent by the client contains all of the information needed to verify the client's identity, no login/password combination is needed.</p><p>Configuring the SASL EXTERNAL mechanism requires the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new client certificate</li><li class="listitem">Configure the client to send the certificate</li><li class="listitem">Configure SLAPD to correctly handle client certificates</li><li class="listitem">Configure SLAPD to correctly translate the identity information provided in the client certificate</li></ol></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec50"/>Creating a New Client Certificate</h3></div></div></div><a class="indexterm" id="id373"/><p>Creating a new client certificate is not significantly different from creating a server certificate. We will use the same certificate authority that we created earlier in this chapter.</p><p>First, we need to create a new certificate request:</p><div><pre class="programlisting">$ /usr/lib/ssl/misc/CA.pl -newreq
Generating a 1024 bit RSA private key
............++++++
..++++++
unable to write 'random state'
writing new private key to 'newkey.pem'
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be 
    incorporated into your certificate request.
What you are about to enter is what is called a Distinguished 
    Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Illinois
Locality Name (eg, city) []:Chicago
Organization Name (eg, company) 
    [Internet Widgits Pty Ltd]:Example.Com
Organizational Unit Name (eg, section) []: 
Common Name (eg, YOUR name) []:matt
Email Address []:matt@example.com

Please enter the following 'extra' attributes
    to be sent with your certificate request
A challenge password []:
An optional company name []:
Request is in newreq.pem, private key is in newkey.pem</pre></div><p>This process is just like the one before, though the fields are completed specifically for the user who is represented by this certificate. For example, if we were generating this certificate for Barbara, we would complete the <strong>Common Name</strong> and <strong>Email Address</strong> fields with her information.</p><div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>
<strong>What should go in the Common Name field?</strong>
</p><p>Earlier we used the CN field to store a domain name. What should go in an individual's CN field? One option is to use the user's full name. A more pragmatic option is to use an identifier that is used in the user's LDAP DN (such as the value of the user's <code class="literal">uid</code> attribute). This makes mapping from a certificate to an LDAP record easier.</p></div></div><p>Now, we have the new request (<code class="literal">newreq.pem</code>) and key (<code class="literal">newkey.pem</code>). The next thing to do is sign the certificate with our CA's digital signature:</p><div><pre class="programlisting">$ /usr/lib/ssl/misc/CA.pl -signreq
Using configuration from /usr/lib/ssl/openssl.cnf
Enter pass phrase for ./demoCA/private/cakey.pem:
Check that the request matches the signature
Signature ok
Certificate Details:
    Serial Number:<a class="indexterm" id="id374"/>
      ba:49:df:f5:8e:7e:77:c6
    Validity
      Not Before: Jul  4 03:28:28 2007 GMT
      Not After : Jul  3 03:28:28 2008 GMT
    Subject:
      countryName               = US
      stateOrProvinceName       = Illinois
      localityName              = Chicago
      organizationName          = Example.Com
      commonName                = matt
      emailAddress              = matt@example.com
    X509v3 extensions:
      X509v3 Basic Constraints: 
        CA:FALSE
      Netscape Comment: 
        OpenSSL Generated Certificate
      X509v3 Subject Key Identifier: 
   
9A:97:8F:8C:95:1F:E0:6E:50:BD:DF:F4:C5:71:68:92:3F:A0:30:DD
      X509v3 Authority Key Identifier: 
   
keyid:6B:FB:66:33:5D:DB:32:40:42:D7:71:F7:F0:D0:7C:94:3E:8F:CD:58
   
Certificate is to be certified until 
    Jul 3 03:28:28 2008 GMT (365 days)
Sign the certificate? [y/n]:y
   
   
1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated
unable to write 'random state'
Signed certificate is in newcert.pem</pre></div><p>Now, we have the signed certificate stored in the file <code class="literal">newcert.pem</code>.</p><p>The next thing to do is to move these files to a location that will be convenient for the user. In this case, we will make a new directory in the user's home directory and move the files into that directory:<a class="indexterm" id="id375"/>
</p><div><pre class="programlisting">
<strong>  $ sudo mkdir /home/mbutcher/certs</strong>
<strong>  $ sudo mv new*.pem /home/mbutcher/certs</strong>
<strong>  $ sudo chown -R mbutcher:mbutcher /home/mbutcher/certs</strong>
</pre></div><p>In these three lines, we make a new directory for the certs. In this case, the new <code class="literal">certs/</code> directory is in the user's home directory.</p><p>Then we move the newly-created certificate files into the new directory. We could rename these files but for now the generic name will suffice.</p><p>Finally, we need to make sure that the user has access to his or her certificates. This is done with the <code class="literal">chown</code> command.</p><p>The certificates are ready to use.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec51"/>Configuring the Client</h3></div></div></div><a class="indexterm" id="id376"/><p>The next thing we need to do is configure the client to use the certificate and key. This is done by creating <code class="literal">.ldaprc</code> file in the user's home directory.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>A <strong>.ldaprc file</strong> is a "personal" version of an <code class="literal">ldap.conf</code> file. It supports all of the directives normally included in <code class="literal">ldap.conf</code>, plus a couple of special directives, like the <code class="literal">TLS_CERT</code> and <code class="literal">TLS_KEY</code> directives.</p></div></div><p>Since I am the user <code class="literal">mbutcher</code>, I will create this file in my own home directory:</p><div><pre class="programlisting">$ cd /home/mbutcher
$ touch .ldaprc</pre></div><p>Now we can edit the <code class="literal">.ldaprc</code> file. This file needs to indicate that the client is using the SASL EXTERNAL mechanism. Also, it must contain directives about the certificate and key files that we want to use. Additionally, it is not a bad idea to specify the location of the CA certificates (or even to the specific certificate for the CA that signed the server's certificate), though this is usually done at a global level with the <code class="literal">ldap.conf</code> file.</p><p>The <code class="literal">.ldaprc</code> file then, looks like this:</p><div><pre class="programlisting">SASL_MECH EXTERNAL
TLS_CERT /home/mbutcher/certs/newcert.pem
TLS_KEY /home/mbutcher/certs/newkey.pem
TLS_CACERT /etc/ssl/certs/Example.Com-CA.pem</pre></div><p>The first directive, <code class="literal">SASL_MECH</code>, indicates what SASL mechanism the client is using. In our case the client is using the <code class="literal">EXTERNAL</code> SASL mechanism.</p><p>The <code class="literal">TLS_CERT</code> directive points to the location of the client's signed X.509 certificate, and <a class="indexterm" id="id377"/>the <code class="literal">TLS_KEY</code> directive indicates the location of the client's private key file.</p><p>The <code class="literal">TLS_CACERT</code> directive points to the specific certificate used for signing the server's certificate. This will be used by the client libraries to verify the identity of the server during SSL/TLS negotiation.</p><p>At this point the client is ready. Now we need to configure SLAPD.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec52"/>Configuring the Server</h3></div></div></div><a class="indexterm" id="id378"/><p>SLAPD needs to do a few things in order to make the SASL EXTERNAL mechanism work:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It must request a certificate from the client (otherwise the client will not present one)</li><li class="listitem" style="list-style-type: disc">It needs to translate the identity information given in the client certificate into a DN that is meaningful in our environment</li></ul></div><p>To set the server to request a client certificate is a matter of adding one directive. In the global section of the <code class="literal">slapd.conf</code> file, before any database directive is specified, the <code class="literal">TLSVerifyClient</code> directive should be added:</p><div><pre class="programlisting">TLSCACertificateFile    /etc/ssl/certs/Example.Com-CA.pem
TLSCertificateFile      /etc/ldap/example.com.cert.pem
TLSCertificateKeyFile   /etc/ldap/example.com.key.pem
<strong>TLSVerifyClient         try</strong>
</pre></div><p>Only the highlighted line is new. The other lines we added earlier in the chapter.</p><p>
<code class="literal">TLSVerifyClient</code> determines whether SLAPD will take steps to request and verify client certificates. There are four possible values:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">never</code>: Never request a client certificate. This is the <em>default</em>. If no certificate is requested the client will not provide one. Hence SASL EXTERNAL authentication cannot be used when the <code class="literal">TLSVerifyClient</code> is set to <code class="literal">never</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allow</code>: This will cause SLAPD to request a certificate from the client but if the client does not provide one, or if the provided one is not good (for example if the signature cannot be verified), the session will continue.</li><li class="listitem" style="list-style-type: disc"><code class="literal">try</code>: In this case SLAPD will request a certificate from the client. If the client does not provide a certificate the session will continue. However, if the client provides a certificate that is bad, the session will terminate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">demand</code>: This will cause SLAPD to require a certificate from the client. If the client does not provide one, or if the provided one is not good, the session will terminate.</li></ul></div><p>In the last example we set <code class="literal">TLSVerifyClient</code> to <code class="literal">try</code>. This simply means that if the client submits a certificate, it must be a valid certificate (with a known CA signature) before SLAPD will allow the connection. But it will also allow clients to connect without supplying a certificate (though such clients will not be able to use SASL EXTERNAL authentication).</p><p>If we wanted to force clients to provide a certificate then we would use the <code class="literal">demand</code> keyword instead of <code class="literal">try</code>.<a class="indexterm" id="id379"/>
</p><p>At this point, we have SSL/TLS configured correctly. Now, we need to add one additional step: we need to map the identity provided by the certificate (which happens to be a DN) onto a DN for a directory user.</p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>Translating the certificate DN into another DN is not strictly necessary. A user can bind using a certificate DN even if it is not in the directory. ACLs can be written to target such DNs too.</p></div></div><p>The DN in the client certificate we create looks like this:</p><div><pre class="programlisting">dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,\
    st=illinois,c=us</pre></div><p>Note that this is one long line.</p><p>The DN contains the information we entered when running <code class="literal">CA.pl -newreq</code>. What we want to do is translate this DN into the DN of the corresponding LDAP record: <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>.</p><p>How is this translation done? Using the <code class="literal">authz-regexp</code> directive that we examined earlier in the section on SASL authentication.</p><p>There are two fields in the certificate's identity string that are particularly helpful in identifying the user: <code class="literal">email</code> and <code class="literal">cn</code>. Thus, a simple regular expression can capture these two fields:</p><div><pre class="programlisting">^email=([^,]+),cn=([^,]+).*,c=us$</pre></div><p>This will assign the email address to <code class="literal">$1</code>, and the CN to <code class="literal">$2</code>.</p><p>From here we could either specify an LDAP URL with a filter for looking up DNs by email address, or we could substitute the CN for the UID field used in the LDAP DN (since the CN maps cleanly onto UID).</p><a class="indexterm" id="id380"/><p>We will use this second method, and create <code class="literal">authz-regexp</code> that looks like this:</p><div><pre class="programlisting">authz-regexp "^email=([^,]+),cn=([^,]+).*,c=us$"
             "uid=$2,ou=Users,dc=example,dc=com"</pre></div><p>This directive maps the CN value of the certificate DN to the UID attribute in the LDAP authorization DN. Thus, when a client connects with a certificate with the DN <code class="literal">dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,c=us</code>, SLAPD will translate that into the DN <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>.</p><p>Now we are ready to test things out.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec53"/>Testing with ldapwhoami</h3></div></div></div><a class="indexterm" id="id381"/><p>The ideal client for testing this process is <code class="literal">ldapwhoami</code>. This will allow us to connect and bind with SASL EXTERNAL. In addition it will indicate whether or not <code class="literal">authz-regexp</code> mapped the certificate DN to our LDAP DN.</p><p>After restarting SLAPD to load the changes, we can test the server:</p><div><pre class="programlisting">$ ldapwhoami -ZZ -H 'ldap://example.com'
Enter PEM pass phrase:
SASL/EXTERNAL authentication started
SASL username: emailAddress=matt@example.com,CN=Matt, \O=Example.Com,L=Chicago,ST=Illinois,C=US
SASL SSF: 0
dn:uid=matt,ou=users,dc=example,dc=com
Result: Success (0)</pre></div><p>First, let's take a closer look at the command entered:</p><div><pre class="programlisting">ldapwhoami -ZZ -H 'ldap://example.com'</pre></div><p>The <code class="literal">-ZZ</code> flag requires that StartTLS negotiation be done successfully. Using only one <code class="literal">Z</code> will attempt StartTLS, but not close the connect if the negotiations fail. Using <code class="literal">-ZZ</code> is always a good idea when attempting authentication with the SASL EXTERNAL mechanism.</p><p>Next, the <code class="literal">-H 'ldap://example.com'</code> parameter provides the URL of the SLAPD server. Remember that for StartTLS negotiation to work, here, the domain in the LDAP URL must match the domain in the server's certificate.</p><p>What happens when this command is executed? First, the user is prompted for a pass phrase:</p><div><pre class="programlisting">Enter PEM pass phrase:</pre></div><p>This prompt is actually generated by the SSL/TLS subsystem (OpenSSL). Recall that the key that we generated is protected by a pass phrase. In order to read the key file, the OpenSSL subsystem requires the pass phrase.</p><p>But didn't I say that the SASL EXTERNAL method can obviate the need for entering a password? Yes, it can—but to do so, we would need to remove the passphrase from the key as we did when generating the server certificate:</p><div><pre class="programlisting">openssl rsa &lt; newkey.pem &gt; clearkey.pem</pre></div><p>Then the <code class="literal">TLS_KEY</code> directive in <code class="literal">.ldaprc</code> would need to be adjusted to point to the <code class="literal">clearkey.pem</code> file.<a class="indexterm" id="id382"/>
</p><p>Removing the pass phrase may be desirable in some circumstances, and undesirable in others. Keep in mind that removing the pass phrase from the key will make it easier for the certificate to be hijacked by someone else. A key without a pass phrase should be carefully protected by permissions and other means.</p><p>Once the user's pass phrase has been entered, SASL authentication begins:</p><div><pre class="programlisting">SASL/EXTERNAL authentication started
SASL username: emailAddress=matt@example.com,CN=Matt, \O=Example.Com,L=Chicago,ST=Illinois,C=US
SASL SSF: 0</pre></div><p>As can be seen here, the SASL EXTERNAL mechanism is used, and the SASL username is set to <code class="literal">emailAddress=matt@example.com,CN=Matt,O=Example.Com,L=Chicago,ST=Illinois,C=US</code>. Finally, the SASL security strength factor is set to 0 because no SASL security mechanism has been used. Instead, the security mechanisms are <em>external</em> to SASL. Since we are using SSL/TLS with an AES-256 encyrpted certificate, the overall SSF will still be 256.</p><p>One important detail to note is that SLAPD will normalize the DN. In normalized form the DN will look like this:</p><div><pre class="programlisting">email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,\
    c=us</pre></div><p>The <code class="literal">emailAddress</code> attribute has been converted to <code class="literal">email</code>, and all uppercase strings have been converted to lowercase. The <code class="literal">authz-regexp</code> that we looked at above operates on this normalized version of the DN.</p><p>Finally, the last few lines of output are the results of the LDAP Who Am I? operation:</p><div><pre class="programlisting">dn:uid=matt,ou=users,dc=example,dc=com
Result: Success (0)</pre></div><p>According to SLAPD, the client is currently performing directory operations with an effective DN of <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>. This means that our mapping was successful.</p><p>What would the output look like if the <code class="literal">authz-regexp</code> mapping was not successful? It would look something like this:</p><div><pre class="programlisting">$ ldapwhoami -ZZ -H 'ldap://example.com'
Enter PEM pass phrase:
SASL/EXTERNAL authentication started
SASL username: 
emailAddress=matt@example.com,CN=Matt,O=Example.Com,L=Chicago,
    ST=Illinois,C=US
SASL SSF: 0
<strong>dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,c=us</strong>
Result: Success (0)<a class="indexterm" id="id383"/>
</pre></div><p>The highlighted portion shows the result of the Who Am I? operation. The DN returned is simply the normalized form of the certificate DN—not the desired LDAP DN.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec54"/>Going Further with SASL</h3></div></div></div><a class="indexterm" id="id384"/><p>SASL is a flexible tool for handling authentication. Here we have looked at only two SASL mechanisms: DIGEST-MD5 and EXTERNAL. But there are many other possibilities. It can be used in conjunction with robust network authentication systems like Kerberos. It can take advantage of secure One Time Password systems, like Opiekeys. And it can be used as an interface to more standard password storage systems, like PAM (Pluggable Authentication Modules).</p><p>While such configurations are outside of the scope of this book, there are many resources available. The SASL documentation (installed locally on Ubuntu in <code class="literal">/usr/local/doc/libsasl/index.html</code>), and the OpenLDAP Administrator's Guide (<a class="ulink" href="http://openldap.org">http://openldap.org</a>), both provide more information about different SASL configurations.</p><p>Now we will move on from authentication to authorization, and turn our attention to ACLs.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Controlling Authorization with ACLs</h1></div></div></div><a class="indexterm" id="id385"/><p>We've looked at connection security and authentication. Now we are ready to look at the last aspect of security: authorization. What we are specifically interested in is controlling access to information in our directory tree. Who should be able to access a record? Under what conditions? And how much of that record should they be able to see? These are the sorts of questions that we will address in this section.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>The Basics of ACLs</h2></div></div></div><a class="indexterm" id="id386"/><p>The primary way that OpenLDAP controls access to directory data is through Access Control Lists (ACLs). When the SLAPD server processes a request from a client, it evaluates whether the client has permissions to access the information it has requested. To do this evaluation SLAPD sequentially evaluates each of the ACLs in the configuration files, applying the appropriate rules to the incoming request.</p><div><div><h3 class="title"><a id="note60"/>Note</h3><p>Previously in this chapter, we have looked at <em>authentication</em> using simple and SASL binding. ACLs provide <em>authorization</em> services, which determine what information a given DN has access to.</p></div></div><p>ACLs were introduced in Chapter 2 in the section entitled <em>ACLs</em>. This section will develop the basic examples discussed there.</p><p>An ACL is just a fancy configuration directive (the <code class="literal">access</code> directive) for SLAPD. Like certain other directives, the <code class="literal">access</code> directive can be used multiple times. There are two different places in the SLAPD configuration where ACLs can be placed. Firstly, they can be placed in the global configuration outside of a database section (that is, near the top of the configuration file). Rules that are placed at this level will apply globally to all backends. In the next chapter we will look at the case where a single directory has multiple backends.</p><p>Secondly, ACLs may be placed within a backend section (somewhere beneath a <code class="literal">database</code> directive). In this case, the ACLs will only be used when handling requests for information within database. In Chapter 2, we put our ACLs within the backend section, and we did not create any global <code class="literal">access</code> directives.</p><p>How does all of this work out in practice? When are global rules used, and when are backend-specific rules used? If a backend has no specific ACLs, then the global rules will apply. If a backend does have ACLs, then the global rules will only be applied if none of the backend-specific rules apply. If the request is for a record which is not stored in any backend, such as the Root DSE or the <code class="literal">cn=subschema</code> entry, then only the global rules will be applied.</p><p>Within their context ACLs are evaluated top-down, from the first directive in the configuration file to the last. So, when backend-specific rules are tested, SLAPD begins testing with the first rule on the list and continues sequentially until either a stopping rule matches or SLAPD reaches the end of the list.</p><p>In Chapter 2 we put the ACLs directly in the <code class="literal">slapd.conf</code> configuration file. In this section we will put them in their own file and use the <code class="literal">include</code> directive in <code class="literal">slapd.conf</code> to direct SLAPD to load the ACL file. This will allow us to separate the potentially lengthy ACLs from the rest of the configuration file.</p><p>Let's take a quick look at the format of an ACL, and then we will move on to some examples which will help clarify the intricacies of the ACL method.</p><p>An access directive looks like this:</p><p>
<code class="literal">access to</code> [<em>resources</em>] </p><p>             <code class="literal">by</code> [<em>who</em>] [<em>type</em> <em>of</em> <em>access</em> <em>granted</em>] [<em>control</em>]</p><p>             <code class="literal">by</code> [<em>who</em>] [<em>type</em> <em>of</em> <em>access</em> <em>granted</em>] [<em>control</em>]</p><div><pre class="programlisting"># More 'by' clauses, if necessary....<a class="indexterm" id="id387"/>
</pre></div><p>An <code class="literal">access</code> directive can have one <code class="literal">to</code> phrase, and any number of <code class="literal">by</code> phrases. We will take a look at the <code class="literal">access to</code> phrase first, then the <code class="literal">by</code> phrase.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Access to [resources]</h2></div></div></div><a class="indexterm" id="id388"/><p>In the <code class="literal">access to</code> part, an ACL specifies what is to be restricted in the directory tree by this rule. In the given rule we used <code class="literal">[resources]</code> as a placeholder for this section. An ACL can restrict by DN, by attribute, by filter, or by a combination of these. We will first look at restricting by DN.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec55"/>Access using DN</h3></div></div></div><a class="indexterm" id="id389"/><p>To restrict access to a particular DN, we would use something like this:</p><div><pre class="programlisting">access to dn="uid=matt,ou=Users,dc=example,dc=com"
       by * none</pre></div><div><div><h3 class="title"><a id="note61"/>Note</h3><p>The <code class="literal">by * none</code> phrase simply rejects access to anyone. We will cover this and other rules when we discuss the <code class="literal">by</code> phrase later in this chapter.</p></div></div><p>The rule would restrict access to that specific DN. Any time a request is received that needs access to the DN <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code>, SLAPD would evaluate this rule to determine whether that request is authorized to access this record.</p><p>Restricting access to a specific DN can be useful at times, but there are several other supported options to the DN access specifier that come in useful for more general rule-making.</p><p>It is possible to restrict access to subtrees of a DN, or even by DN patterns. For example, if we wanted to write a rule that restricted access to entries beneath the Users OU, we could use an <code class="literal">access</code> clause like this:</p><div><pre class="programlisting">access to dn.subtree="ou=Users,dc=example,dc=com"
       by * none<a class="indexterm" id="id390"/>
</pre></div><p>In this example the rule restricts access to the OU and any records subordinate to it. This is accomplished by using <code class="literal">dn.subtree</code> (or the synonym <code class="literal">dn.sub</code>). In our directory information tree there are a number of user records in the Users OU subtree. These records are children of the Users OU. The DN <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code>, for example, is in the subtree, and an attempt to access the record would trigger this rule.</p><p>Along with <code class="literal">dn.subtree</code>, there are three other keywords for adding structural restrictions to the DN access specifier:<a class="indexterm" id="id391"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dn.base</code>: Restrict access to this particular DN. This is the default, and <code class="literal">dn.exact</code> and <code class="literal">dn.baselevel</code> are synonyms of <code class="literal">dn.base</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dn.one</code>: Restrict access to any entries immediately below this DN. <code class="literal">dn.onelevel</code> is a synonym.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dn.children</code>: Restrict access to the children (subordinate) entries of this DN. This is similar to subtree, except that the given DN itself is not restricted by the rule.</li></ul></div><p>The <code class="literal">dn</code> clause accepts one other modifier that can be used to do sophisticated pattern matching: <code class="literal">dn.regex</code>. The <code class="literal">dn.regex</code> access specifier can process POSIX extended regular expressions. Here is an example of a simple regular expression in <code class="literal">dn.regex</code>:</p><div><pre class="programlisting">access to dn.regex="uid=[^,]+,ou=Users,dc=example,dc=com"
       by * none</pre></div><p>This example would restrict access to any DN with the pattern <code class="literal">uid=SOMETHING,ou=Users,dc=example,dc=com</code>, where <code class="literal">SOMETHING</code> can be any string that is at least one character long and has no commas (<code class="literal">,</code>) in it. Regular expressions are a powerful tool for writing ACLs. We will discuss them more in the section <em>Getting</em> <em>More</em> <em>from</em> <em>Regular</em> <em>Expressions</em> after we look at the <code class="literal">by</code> phrase.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec56"/>Access using attrs</h3></div></div></div><a class="indexterm" id="id392"/><p>In addition to restricting access to records by DN, we can also restrict access to one or more attributes within records. This is done using the <code class="literal">attrs</code> access specifier.</p><p>In the examples we've seen, when we restricted access we were restricting access at a record level. The <code class="literal">attrs</code> restriction works at a finer-grained level: it restricts access to particular attributes within records.</p><p>For example, consider a case where we want to limit access to the <code class="literal">homePhone</code> attribute of all records in our directory information tree. This can be done with the following access phrase:</p><div><pre class="programlisting">access to attrs=homePhone
       by * none</pre></div><p>The <code class="literal">attrs</code> specifier takes a list of one or more attributes. In the given example, we just restricted access to the <code class="literal">homePhone</code> attribute. If we wanted to block access to <code class="literal">homePostalAddress</code> as well, we could modify the <code class="literal">attrs</code> list accordingly:</p><div><pre class="programlisting">access to attrs=homePhone,homePostalAddress
       by * none</pre></div><p>Let's say that we wanted to restrict access to all of the attributes in the <code class="literal">organizationalPerson</code> object class. One way of doing this would be to create one long list: <code class="literal">attrs</code>=<code class="literal">title</code>, <code class="literal">x121Address</code>, <code class="literal">registeredAddress</code>, <code class="literal">destinationIndicator</code>,.... But such a method would be time-consuming, difficult to read, and clumsy.</p><p>Instead, there is a convenient shorthand notation for this:</p><div><pre class="programlisting">access to attrs=@organizationalPerson
       by * none<a class="indexterm" id="id393"/>
</pre></div><p>This notation should be used carefully, however. This code does not just restrict access to the attributes explicitly defined in <code class="literal">organizationalPerson</code>, but also all of the attributes already defined in the <code class="literal">person</code> object class. Why? Because the <code class="literal">organizationalPerson</code> object class is a subclass of <code class="literal">person</code>. Therefore, all of the attributes of <code class="literal">person</code> are attributes of <code class="literal">organizationalPerson</code>.</p><p>Sometimes it useful to restrict access to all attributes <em>not</em> required or allowed by a particular object class. For example, consider the case where the only attributes we want to restrict are those that are not specified in the <code class="literal">organizationalPerson</code> object class. We can do that by replacing the <em>at</em> sign (<code class="literal">@</code>) with an exclamation point (<code class="literal">!</code>):</p><div><pre class="programlisting">access to attrs=!organizationalPerson
       by * none</pre></div><p>This will restrict access to any attributes unless they are allowed or required by the <code class="literal">organizationalPerson</code> object class.</p><p>There are two special names that can be specified in the attributes list but that do not actually match an attribute. These two names are <code class="literal">entry</code> and <code class="literal">children</code>. So we have two cases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">attrs=entry</code> is specified, then the record itself is restricted.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">attrs=children</code>, then the records that are children of this record are restricted.</li></ul></div><p>These two key words are not particularly useful in cases where only an <code class="literal">attrs</code> specifier is used, but they can be much more useful when <code class="literal">attrs</code> and <code class="literal">dn</code> specifiers are used in conjunction.</p><p>Sometimes it is useful to restrict by the value of an attribute (rather than by an attribute name). For example, we may want to restrict access to any <code class="literal">givenName</code> attribute that has the value <code class="literal">Matt</code>. This sort of thing can be accomplished using the <code class="literal">val</code> (value) specifier:</p><div><pre class="programlisting">access to attrs=givenName val="Matt"
       by * none<a class="indexterm" id="id394"/>
</pre></div><p>Like the <code class="literal">dn</code> specifier, the <code class="literal">val</code> specifier has <code class="literal">regex</code>, <code class="literal">subtree</code>, <code class="literal">base</code>, <code class="literal">one</code>, <code class="literal">exact</code>, and <code class="literal">children</code> styles.<a class="indexterm" id="id395"/>
</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>When using the <code class="literal">val</code> specifier you can have no more than one attribute in the <code class="literal">attrs</code> list. The <code class="literal">val</code> specifier will not work on object class lists either.</p></div></div><p>With <code class="literal">val.regex</code> you can use regular expressions for matching. We can modify the last example to restrict access to any <code class="literal">givenName</code> that starts with the letter <code class="literal">M</code>:</p><div><pre class="programlisting">access to attrs=givenName val.regex="M.*"
       by * none</pre></div><p>In cases where the attribute value is a DN (like the <code class="literal">member</code> attribute for a <code class="literal">groupOfNames</code> object), the <code class="literal">regex</code>, <code class="literal">subtree</code>, <code class="literal">base</code>, <code class="literal">one</code>, and <code class="literal">children</code> styles can be used to restrict access based on the DN in the attribute value.</p><div><pre class="programlisting">access to attrs=member val.children="ou=Users,dc=example,dc=com"
       by * none</pre></div><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p><strong>Specifying an Alternate Matching Rule</strong></p><p>By default, the <code class="literal">val</code> comparison uses the equality matching rule. You can select a different matching rule however, by inserting a slash (<code class="literal">/</code>) after <code class="literal">val</code>, and then entering the name or OID of the matching rule:<code class="literal">access to attrs=givenName val/caseIgnoreMatch="matt"</code>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec57"/>Access using Filters</h3></div></div></div><a class="indexterm" id="id396"/><p>One of the lesser used but surprisingly powerful features of the <code class="literal">access</code> phrase is support for LDAP search filters as a means of restricting access to records. We looked at the LDAP filter syntax at the beginning of Chapter 3 when we discussed the search operation. Here we will use filters to restrict access to parts of a record.</p><p>Filters provide a way to support value matching for entire records (instead of just attribute values, as is done with <code class="literal">attrs</code>). For example, using filters we can restrict access to all records that contain the object class <code class="literal">simpleSecurityObject</code>:</p><div><pre class="programlisting">access to filter="(objectClass=simpleSecurityObject)"
       by * none</pre></div><p>This will restrict access to any record in the directory information tree that has the object class <code class="literal">simpleSecurityObject</code>. Any legal LDAP filter can be used in a filter specifier. For example, we could restrict access to all records that have the given name Matt, the given name Barbara, or the surname Kant:<a class="indexterm" id="id397"/>
</p><div><pre class="programlisting">access to 
    filter="(|(|(givenName=Matt)(givenName=Barbara))(sn=Kant))"
       by * none</pre></div><p>This code uses the "or" (disjunction) operator to indicate that if the request needs access to records that have given names with the values of Matt or Barbara, or if the request needs access to a record with the surname Kant, this rule should be applied.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec58"/>Combining Access Specifiers</h3></div></div></div><a class="indexterm" id="id398"/><p>We have looked at three different access specifiers: <code class="literal">dn</code>, <code class="literal">attrs</code>, and <code class="literal">filter</code>. And in the previous sections we have used each. Now we will combine them to create even more specific access rules.</p><p>The order of combination is as follows:</p><p>
<code class="literal">access to</code> [<em>dn</em>] [<em>filter</em>] [<em>attrs</em>] [<em>val</em>]</p><p>The <code class="literal">dn</code> and <code class="literal">filter</code> specifiers come first, as they both deal with records as a whole. Then <code class="literal">attrs</code> (and <code class="literal">val</code>), which function at the attribute level, come next. Let's say that we want to restrict access to records in the Users OU just in the cases where the record has an <code class="literal">employeeNumber</code> attribute. To do this we can use a combination of a DN specifier and a filter:</p><div><pre class="programlisting">access to dn.subtree="ou=Users,dc=example,dc=com"
    filter="(employeeNumber=*)"
       by * none</pre></div><p>This ACL will only restrict access when the request is for records in the <code class="literal">ou=Users,dc=example,dc=com</code> subtree and the <code class="literal">employeeNumber</code> field exists and has some value.</p><p>In a similar fashion, we can limit access to attributes for records in a certain subtree. For example, consider the case where we want to restrict access to the <code class="literal">description</code> attribute, but only for records that are in the the System OU. We can do this by combining the DN and attribute specifiers:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com" 
    attrs=description
       by * none</pre></div><p>By this rule, a client could access the record with DN <code class="literal">uid=authenticate,ou=System,dc=example,dc=com</code>, but it would not be able to access the <code class="literal">description</code> attribute of that record.</p><p>By carefully combining these access specifiers it is possible to articulate exact access restrictions. We will see some more in action as we continue on to the <code class="literal">by</code> phrase.<a class="indexterm" id="id399"/>
<a class="indexterm" id="id400"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>By [who] [type of access granted] [control]</h2></div></div></div><a class="indexterm" id="id401"/><a class="indexterm" id="id402"/><p>The <code class="literal">by</code> phrase contains three parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <strong>who field</strong> indicates what entities are allowed to access the resource identified in the access phrase</li><li class="listitem" style="list-style-type: disc">The <strong>access field</strong> (type of access granted) indicates what can be done with the resource</li><li class="listitem" style="list-style-type: disc">The third optional part, which is usually left off, is the <strong>control field</strong></li></ul></div><p>To get the gist of this distinction, consider the <code class="literal">by</code> phrase that we have been working with in the previous sections: <code class="literal">by * none</code>. In this <code class="literal">by</code> phrase, the <code class="literal">who</code> field is <code class="literal">*</code> (an asterisk character), and the access field is <code class="literal">none</code>. The control field is omitted in this example.</p><p>The <code class="literal">*</code> is the universal wildcard. It matches any entity, including anonymous and all DNs. The <code class="literal">none</code> access type indicates that no permissions at all should be granted to the entity identified in the <code class="literal">who</code> specifier. In other words, <code class="literal">by * none</code> means that no access should be granted to anyone.</p><div><div><h3 class="title"><a id="note63"/>Note</h3><p>The directory manager (<code class="literal">cn=Manager,dc=example,dc=com</code>), specified in the <code class="literal">slapd.conf</code> file with the <code class="literal">rootdn</code> directive, is an exception. It cannot be restricted by any access control. Thus, <code class="literal">by * none</code> does not apply to the manager.</p></div></div><p>We will explore the <code class="literal">who</code> field in detail, but before getting to that, let's examine the access field.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec59"/>The Access Field</h3></div></div></div><a class="indexterm" id="id403"/><p>There are six distinct privileges that a client can have, in regards to an entry or attribute. There is also a seventh privilege specifier that equates to the removal of all privileges:</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">w</code>: Writes access to a record or attribute.</li><li class="listitem"><code class="literal">r</code>: Reads access to a record or attribute.</li><li class="listitem"><code class="literal">s</code>: Searches access to a record or attribute.</li><li class="listitem"><code class="literal">c</code>: Accesses to run a comparison operation on a record or attribute.</li><li class="listitem"><code class="literal">x</code>: Accesses to perform a server-side authentication operation on a record or attribute.</li><li class="listitem"><code class="literal">d</code>: Accesses to information about whether or not a record or attribute exists ('d' stands for 'disclose').</li><li class="listitem"><code class="literal">0</code>: Does not allow access to the record or attribute. This is equivalent to <code class="literal">-wrscxd</code>.</li></ol></div><p>These seven privileges can be specified in a <code class="literal">by</code> clause. To set one or more of these access privileges, use the <code class="literal">=</code> (equals) sign.</p><p>For example, to allow the server to compare a record's <code class="literal">givenName</code> field to a <code class="literal">givenName</code> specified by a client, we could use the following ACL:</p><div><pre class="programlisting">access to attrs=givenName 
       by * =c</pre></div><p>This will allow any client to attempt a compare operation. But that is the only operation it will allow. By this rule, no one can read from or write to this attribute. How does this work out in practice? When we use the <code class="literal">ldapsearch</code> client to attempt to read the value of the <code class="literal">givenName</code> attribute, we do not get any information about the <code class="literal">givenName</code>:</p><div><pre class="programlisting">$ ldapsearch -LLL -U matt "(uid=matt)" givenName
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
<strong>dn: uid=matt,ou=Users,dc=example,dc=com</strong>
</pre></div><p>The only thing the server returns for our query is the DN of the record that matches the filter. No <code class="literal">givenName</code> attribute is returned.</p><p>However, if we use the <code class="literal">ldapcompare</code> client, we can ask the server to tell us whether or not the DN has a <code class="literal">givenName</code> field with the value 'Matt':</p><div><pre class="programlisting">
<strong>$ ldapcompare -U matt uid=matt,ou=Users,dc=example,dc=com \ </strong>
<strong>    "givenName: Matt"</strong>
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
<strong>TRUE</strong>
</pre></div><p>The <code class="literal">ldapcompare</code> client sends a DN and an attribute/value pair to the server, and asks the server to compare the supplied attribute value with the server's copy of the attribute value for the record with the given DN.</p><p>Here the <code class="literal">ldapcompare</code> client will request that the SLAPD server look up the record for <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> and check to see if the <code class="literal">givenName</code> attribute has the value 'Matt'. The server will answer <code class="literal">TRUE</code>, <code class="literal">FALSE</code>, or (if there is an error) <code class="literal">UNDEFINED</code>.<a class="indexterm" id="id404"/>
</p><p>In this case, the server responded <code class="literal">TRUE</code>. This indicates that the server performed the comparison, and the values matched. The combination of the <code class="literal">ldapsearch</code> and <code class="literal">ldapcompare</code> examples should illustrate how the ACL worked: while the server-side compare operation is permitted, the client does not have access to read the attribute value.</p><p>Multiple access privileges can be granted in one <code class="literal">by</code> phrase. To modify in order to allow reading (<code class="literal">r</code>), comparing (<code class="literal">c</code>), and disclosing (<code class="literal">d</code>) on the <code class="literal">givenName</code> attribute, we can use the following ACL:</p><div><pre class="programlisting">access to attrs=givenName 
       by * =rcd</pre></div><p>Now, both the <code class="literal">ldapsearch</code> and <code class="literal">ldapcompare</code> commands that we ran should succeed.</p><p>There are cases where permissions are inherited from other ACLs (we will look at some later). In such cases, we can selectively add or remove specific permissions by using <code class="literal">+</code> (plus sign) to add and <code class="literal">–</code> (minus sign) to remove.</p><p>For example, if we know that all the users already have compare (<code class="literal">c</code>) and disclose (<code class="literal">d</code>) on all the attributes, but we want to add <em>read</em> privileges just for the <code class="literal">givenName</code> attribute, we can use the following ACL:</p><div><pre class="programlisting">access to attrs=givenName 
       by * +r</pre></div><div><div><h3 class="title"><a id="note64"/>Note</h3><p>An access control that grants compare and disclose, and then continues processing might look something like this: <code class="literal">access to attrs=givenName,sn by * =cd break</code>. This uses the <code class="literal">break</code> control to instruct SLAPD to continue processing ACLs. If this rule appeared in the SLAPD configuration above the rule <code class="literal">access to attrs=giveName by * +r</code>, then a request to the <code class="literal">givenName</code> attribute would have the effective permissions <code class="literal">=rcd</code>.</p></div></div><p>Likewise, if we needed to remove the compare operation just for the <code class="literal">givenName</code> attribute, we could use a <code class="literal">by</code> clause like <code class="literal">by * -c</code>.</p><p>The <code class="literal">0</code> access privilege removes all privileges. It cannot be used with the <code class="literal">+</code> or <code class="literal">–</code> operators, it can only be used with the <code class="literal">=</code> operator. The following ACL removes all privileges for all users to the <code class="literal">givenName</code> attribute:</p><div><pre class="programlisting">access to attrs=givenName 
       by * =0</pre></div><p>This is the same as the <code class="literal">by</code> clause: <code class="literal">by * -wrscdx</code>.</p><p>These access controls are good for fine-grained control, but sometimes it is nice to have shortcuts. OpenLDAP has seven shortcuts that handle common configurations of access controls:<a class="indexterm" id="id405"/>
</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Keyword</p>
</th><th style="text-align: left" valign="bottom">
<p>Privileges</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">none</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">disclose</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">d</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">auth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">xd</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">compare</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">cxd</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">search</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">scxd</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">read</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">rscxd</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">write</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">wrscxd</code>
</p>
</td></tr></tbody></table></div><p>The <code class="literal">none</code> keyword we have seen before and it is the same as <code class="literal">=0</code>. Looking at the other keywords and their associated privilege, a pattern emerges: each keyword adds one new privilege, to the privileges of the previous keyword. Thus, <code class="literal">auth</code> has the <code class="literal">=d</code> privilege from <code class="literal">disclose</code>, plus the <code class="literal">x</code> privilege, and <code class="literal">compare</code> has <code class="literal">=xd</code> from <code class="literal">auth</code> and adds the <code class="literal">c</code> privilege. The <code class="literal">write</code> keyword at the bottom has all privileges.</p><p>Because this general accumulation of privileges captures the usual use cases while remaining more readable, keywords are used more frequently than privilege strings. In most of our examples from here on, we will use the keyword unless there is a specific reason to use the privilege string instead.</p><div><div><h3 class="title"><a id="note65"/>Note</h3><p>Of the seven keywords, <code class="literal">disclose</code>, <code class="literal">auth</code>, <code class="literal">compare</code>, <code class="literal">search</code>, <code class="literal">read</code>, and <code class="literal">write</code> can be prefixed with one of two prefixes: <code class="literal">self</code> and <code class="literal">realself</code>. The <code class="literal">self</code> prefix indicates that if the value in question refers to the user's DN, then the user may have certain privileges. Thus <code class="literal">selfwrite</code> indicates that the user has <code class="literal">=wrscxd</code> permissions if and only if the value of the attribute in question is the user's DN.</p><p>The <code class="literal">realself</code> prefix is similar, but it carries the additional stipulation that the DN not be proxied. These prefixes are particularly useful when dealing with groups and other membership-based records.</p><p>For example, the following ACL allows a user <code class="literal">write</code> access to the <code class="literal">uniqueMember</code> attribute only if the <code class="literal">uniqueMember</code> attribute contains that user's DN: <code class="literal">access to attrs=uniqueMember by users selfwrite</code>.</p></div></div><p>Now that we have covered the access field we will move on to the <code class="literal">who</code> field.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec60"/>The who Field</h3></div></div></div><a class="indexterm" id="id406"/><p>We have always used <code class="literal">*</code> in the <code class="literal">who</code> field. However, the <code class="literal">who</code> field is the richest of the ACL fields, providing twenty-three distinct forms, most of which can be used in combinations. In order to efficiently cover ground, we will cover the major forms on their own, and then group similar forms together and treat them as units.</p><p>The five most frequently used forms are <code class="literal">*</code>, <code class="literal">anonymous</code>, <code class="literal">self</code>, <code class="literal">users</code>, and <code class="literal">dn</code>.</p><div><div><div><div><h4 class="title"><a id="ch04lvl4sec30"/>The * and anonymous Specifiers</h4></div></div></div><a class="indexterm" id="id407"/><a class="indexterm" id="id408"/><p>The <code class="literal">*</code> specifier, as we have already seen, is a global match. It matches any client, including the anonymous user.</p><p>The <code class="literal">anonymous</code> specifier matches only clients that bind to the directory as the Anonymous user (see Chapter 3 for details on the Anonymous user). This refers, then, to clients that have not authenticated to the directory. Since the process of authentication requires that the client connect Anonymously, and then attempt to bind as a DN with a specific password, the anonymous user almost always needs permissions to perform an <code class="literal">auth</code> operation, in which the client sends the DN and password to the directory and asks the directory to verify that the information is correct. For that reason, you will likely need an ACL that looks like this:</p><div><pre class="programlisting">access to attrs=userPassword
       by anonymous auth</pre></div><p>This grants the Anonymous user the ability to do an auth operation. Note that every ACL ends with an implicit phrase: <code class="literal">by * none</code>. In other words, if permissions are not explicitly specified none are granted.</p><p>Note that the ACL above does not allow users to modify their own passwords. That's where the <code class="literal">self</code> specifier comes in.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec31"/>The self Specifier</h4></div></div></div><a class="indexterm" id="id409"/><p>The <code class="literal">self</code> specifier is used to specify access controls for a DN on its own record. Thus, we can use the <code class="literal">self</code> specifier to allow a user to modify her or his own <code class="literal">userPassword</code> value: </p><div><pre class="programlisting">access to attrs=userPassword
       by anonymous auth
       by self write</pre></div><p>If we log in as <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> and try to modify the <code class="literal">userPassword</code> value of our own record (<code class="literal">dn: uid=matt,ou=Users,dc=example,dc=com</code>), SLAPD will allow us to change the password. But it will not (according to the rule above) allow us to modify anyone else's <code class="literal">userPassword</code> value.</p><div><div><h3 class="title"><a id="note66"/>Note</h3><p>The <code class="literal">self</code> specifier can be further modified with a <code class="literal">level</code> style. The <code class="literal">level</code> style indicates whether (and how many) parent records or child records are to be treated as if they were part of <code class="literal">self</code>. The <code class="literal">level</code> style takes an integer index. Positive integers refer to parents, while negative integers refer to children.</p><p>Thus <code class="literal">access to</code> <code class="literal">ou</code> <code class="literal">by</code> <code class="literal">self.level{1}</code> <code class="literal">write</code> indicates that the current DN has write permissions to the <code class="literal">ou</code> of its parent. Likewise, <code class="literal">access</code> <code class="literal">to</code> <code class="literal">ou</code> <code class="literal">by</code> <code class="literal">self.level{-1}</code> <code class="literal">write</code> indicates that the current DN has write permission to the <code class="literal">ou</code> of any of its immediate children.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec32"/>The users Specifier</h4></div></div></div><a class="indexterm" id="id410"/><p>The <code class="literal">users</code> specifier refers to any authenticated client. The anonymous user is not included in <code class="literal">users</code> because it represents a client that has not authenticated.</p><p>This specifier comes in very handy when you need to allow anyone who has authenticated access to some resources. For example, in an enterprise directory we would likely want to allow all users the ability to see each other's names, telephone numbers, and email addresses:</p><div><pre class="programlisting">access to attrs=sn,givenName,displayName,telephoneNumber,mail
       by self write
       by users read</pre></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec33"/>The dn Specifier</h4></div></div></div><a class="indexterm" id="id411"/><p>The <code class="literal">dn</code> specifier performs similarly in the <code class="literal">by</code> phrase to the role it plays in the <code class="literal">access</code> <code class="literal">to</code> phrase. It specifies one or more DNs. The <code class="literal">dn</code> has the <code class="literal">regex</code>, <code class="literal">base</code>, <code class="literal">one</code>, <code class="literal">subtree</code>, and <code class="literal">children</code> modifiers, all of which perform the same way here as they did in the <code class="literal">access</code> <code class="literal">to</code> phrase. Here's an example using a few different DN patterns:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com" attrs=description
       by dn="uid=barbara,ou=Users,dc=example,dc=com" write
       by dn.children="ou=System,dc=example,dc=com" read
       by dn.regex="uid=[^,]+,ou=Users,dc=example,dc=com" read</pre></div><p>This rule restricts access to the description attributes of anything in the System OU subtree. The user <code class="literal">uid=barbara,ou=Users,dc=example,dc=com</code> has write permissions to the description, while any child users of the System OU have <em>read</em> permissions. Users with DNs of the form <code class="literal">uid=SOMETHING,ou=Users,dc=example,dc=com</code> also have <em>read</em> access to the description.</p><p>In addition to the regular DN modifiers, a <code class="literal">dn</code> in the <code class="literal">by</code> clause can also have a <code class="literal">level</code> modifier. Level allows the ACL author to specify exactly how many levels down a <code class="literal">by</code> phrase should go. Recall that the <code class="literal">dn.one</code> specifier indicates that any record directly below the specified DN is to be granted the specified permissions. For example <code class="literal">by</code> <code class="literal">dn.one="ou=Users,dc=example,dc=com"</code> <code class="literal">read</code> grants any direct descendant of the Users OU read permissions. So <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> would be granted read access, but <code class="literal">uid=jake,ou=Temp,ou=Users,dc=example,dc=com</code> would not be granted such access because he is two levels down. The <code class="literal">dn.level</code> specifier lets us arbitrarily specify how many levels to descend. For example, <code class="literal">by</code> <code class="literal">dn.level{2}="ou=Users,dc=example,dc=com"</code> <code class="literal">read</code> would allow both <code class="literal">matt</code> and <code class="literal">jake</code> read access.<a class="indexterm" id="id412"/>
</p><div><div><h3 class="title"><a id="note67"/>Note</h3><p><strong>Proxy Authentication and Real DNs</strong></p><p>If SLAPD is set up to allow Proxy Authentication, in which case one DN is used for authentication, and then another DN is used for performing other directory operations, it is sometimes useful to write ACLs based on the DN used for authentication (the real DN). The <code class="literal">realdn</code> specifier can be used for this. It functions just like the <code class="literal">dn</code> specifier, except that it operates on the real DN. Also, <code class="literal">realanonymous</code>, <code class="literal">realusers</code>, <code class="literal">realdnattr</code>, and <code class="literal">realself</code> can be used to restrict based on the real DN. See the <code class="literal">slapd.access</code> man page for more: <code class="literal">man</code> <code class="literal">slapd.access</code>.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec34"/>Groups and Members</h4></div></div></div><a class="indexterm" id="id413"/><a class="indexterm" id="id414"/><p>Sometimes it is useful to grant group members the access to an object. For example, if you have an Administrators group, you may wish to grant any member of that group write access to all of the records in the System OU.</p><p>One might expect that the way to set permissions for group members is simply to use the group as the value of a <code class="literal">dn</code> specifier in an ACL. However, that is not the case since the <code class="literal">dn</code> specifier refers to the group record as a whole, and has nothing at all to do with the members of the group, each of which has its own record elsewhere in the directory.</p><p>Instead, what we need is a way to search the member attributes of a particular group record, and then grant access to the DNs listed in the record. The group specifier provides exactly this sort of capability.</p><p>Group evaluation can be done with the <code class="literal">group</code> specifier. In its simplest form it is used like this:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com"
<strong>       by group="cn=Admins,ou=Groups,dc=example,dc=com" write</strong>
       by users read</pre></div><p>This ACL will grant members of the <code class="literal">cn=Admins,ou=Groups,dc=example,dc=com</code> group write access to anything in the System OU, while giving all other users read-only permissions.</p><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p><strong>Order Matters</strong></p><p>ACL by phrase are evaluated sequentially, and by default SLAPD will stop processing <code class="literal">by</code> phrases when it hits a match. In other words, if the by phrases in the above rule were reversed, members of LDAP Admins would never be given write permission because they would always match the <code class="literal">by</code> <code class="literal">users</code> <code class="literal">read</code> phrase. Evaluation of the ACL would stop before group membership was checked.</p></div></div><a class="indexterm" id="id415"/><p>But the ACL above will only work on groups whose object class is <code class="literal">groupOfNames</code>, and whose membership attribute is <code class="literal">member</code>. This is because groupOfNames is the default grouping object class, and member is the default membership attribute.</p><p>When we created our LDAP Admins group in Chapter 3, it was not <code class="literal">groupOfNames</code>, nor did it use the <code class="literal">member</code> attribute for membership. Our record looked like this:</p><div><pre class="programlisting">dn: cn=LDAP Admins,ou=Groups,dc=example,dc=com
cn: LDAP Admins
ou: Groups
description: Users who are LDAP administrators
uniqueMember: uid=barbara,ou=Users,dc=example,dc=com
uniqueMember: uid=matt,ou=Users,dc=example,dc=com
objectClass: groupOfUniqueNames</pre></div><a class="indexterm" id="id416"/><p>We used the <code class="literal">groupOfUniqueNames</code> object class and the <code class="literal">uniqueMember</code> membership attribute. In order to get the ACL to match these constraints we will need to specify the object class and membership attribute in the <code class="literal">group</code> specifier:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com"
<strong>       by group/groupOfUniqueNames/uniqueMember=</strong>
<strong>           "cn=LDAP Admins,ou=Groups,dc=example,dc=com" write</strong>
       by users read</pre></div><p>Note the change in the highlighted line. Using slashes (<code class="literal">/</code>) we have specified first the object class then the membership attribute that should be used to determine who what entries represent members. When this <code class="literal">by</code> phrase is evaluated, SLAPD will find the DN <code class="literal">cn=LDAP</code> <code class="literal">Admins,ou=Groups,dc=example,dc=com</code>, check to see if it has object class <code class="literal">groupOfUniqueMembers</code>, and then grant write permissions to a DN if it is specified in a uniqueMember attribute.</p><p>Using this expanded notation, you can use other membership-based records as groups. For example, you can use the <code class="literal">organizationalRole</code> object class with the <code class="literal">roleOccupant</code> membership attribute.</p><p>Like many other specifiers, the group specifier also supports regular expressions with the <code class="literal">regex</code> style. Thus, we could create a rule that would allow members of any group in OU Groups write access to the System OU by expanding our last example:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com"
<strong>       by group/groupOfUniqueNames/uniqueMember.regex=</strong>
<strong>           "cn=[^,]+,ou=Groups,dc=example,dc=com" write</strong>
       by users read</pre></div><a class="indexterm" id="id417"/><p>The second and third lines should be combined into one long line in <code class="literal">slapd.conf</code>. The regular expression in the group specifier would match any DN with a CN component at the beginning. For all such entries, if the object class is <code class="literal">groupOfUniqueMembers</code>, then the SLAPD will grant membership to a user who is a <code class="literal">uniqueMember</code> of one of those groups.<a class="indexterm" id="id418"/>
</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec35"/>Member-Based Record Access</h4></div></div></div><a class="indexterm" id="id419"/><p>What if a group member needs to modify the record of the group to whom she or he belongs? One way to allow this is with the <code class="literal">dnattr</code> specifier. The <code class="literal">dnattr</code> specifier grants access to a record only if the client's DN appears in a certain attribute of the record. For example, the following example allows a group member (<code class="literal">uniqueMember</code>) of a group (which is a <code class="literal">groupOfUniqueNames</code> object) access to the group record:</p><div><pre class="programlisting">access to dn.exact="cn=LDAP Admins,ou=Groups,dc=example,dc=com"
       by dnattr=uniqueMember write
       by users read</pre></div><p>The second line specifies that if the client's DN is in the list of values for the <code class="literal">uniqueMember</code> attribute, then that client should be given write access to the entire group record. Other users, according to the third line, will have read access.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec36"/>Network, Connections, and Security</h4></div></div></div><a class="indexterm" id="id420"/><a class="indexterm" id="id421"/><a class="indexterm" id="id422"/><p>SLAPD can use information about the client's connection (including network and security information) in access control lists. This feature provides an additional layer of network security that complements SSL/TLS and SASL.</p><p>The following are network or connection level specifiers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">peername</code>: This is used to specify a range of IP addresses (for <code class="literal">ldap://</code> and <code class="literal">ldaps://</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">sockname</code>: This is used to specify a socket file for an LDAPI listener (<code class="literal">ldapi://</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">domain</code>: This is used to specify a domain name for <code class="literal">ldap://</code> and <code class="literal">ldaps://</code> listeners.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sockurl</code>: This is used to specify a socket file in URL format (<code class="literal">ldapi://var/run/ldapi</code>) for an LDAPI listener.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ssf</code>: The overall security strength factor (SSF) of the connection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">transport_ssf</code>: The SSF for the underlying transport layer of the network.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tls_ssf</code>: The SSF for the SSL/TLS connection. This works with SSL/TLS connections on LDAPS listeners and Start TLS on LDAP listeners.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sasl_ssf</code>: The SSF of the SASL connection.</li></ul></div><p>The SSF specifiers (<code class="literal">ssf</code>, <code class="literal">transport_ssf</code>, <code class="literal">tls_ssf</code>, and <code class="literal">sasl_ssf</code>) perform the same checks as the SSF parameters to the SLAPD <code class="literal">security</code> directive (discussed in the first part of this chapter). In this case, however, SSFs may be used to selectively restrict (or grant) access to portions of the directory information tree. SSF specifiers require an integer value for the level of security desired. For example, using <code class="literal">ssf=256</code> will require that the overall SSF of a connection be 256. But <code class="literal">tls_ssf=56</code> will require that the SSF of the TLS/SSL layer be at least 56, regardless of what the SSF of the SASL configuration is. For more information on SSFs, see the section earlier in this chapter entitled <em>Using</em> <em>Security</em> <em>Strength</em> <em>Factors</em>.</p><p>For example, the following ACL will only grant <em>write</em> access to the specified DN when the client has connected with a strong SASL cipher:</p><div><pre class="programlisting">access to dn.subtree="ou=users,dc=example,dc=com"
<strong>       by self sasl_ssf=128 write</strong>
       by users read</pre></div><p>This rule allows users to modify their own records only if they have authenticated with SASL using a security mechanism with a strength of 128 (DIGEST-MD5) or more. All other users would only get read access.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p><strong>Combining Specifiers in a by Phrase</strong></p><a class="indexterm" id="id423"/><p>As the rule above illustrates, multiple specifiers can be used in a single by phrase. When this happens all specifiers must be matched before the indicated rights will be granted (or denied).</p></div></div><a class="indexterm" id="id424"/><p>The <code class="literal">peername</code> specifier is used for setting restrictions based on information about the IP connection. It can be used to complement other components in network security, like SSL/TLS. The <code class="literal">peername</code> specifier can take an IP address or a range of IP addresses (using subnet masks) and can also specify a source port.</p><p>The following rule grants write access to local connections, read access to connections on the local LAN (address from 10.40.0.0 through 10.40.0.255), and denies access to all other clients. Remember, every rule ends with an implicit <code class="literal">by</code> <code class="literal">*</code> <code class="literal">none</code>.</p><div><pre class="programlisting">access to *
       by peername.ip=127.0.0.1 write
       by peername.ip=10.40.0.0%255.255.255.0 read</pre></div><p>Note that the <code class="literal">peername</code> specifier requires the ip style for specifying an IP address. It also supports the <code class="literal">regex</code> style (<code class="literal">access</code> <code class="literal">to</code> <code class="literal">*</code> <code class="literal">by</code> <code class="literal">peername.regex="^IP=10\</code>.<code class="literal">40\</code>.<code class="literal">0\</code>.<code class="literal">[0-9]+:[0-9]+$"</code> <code class="literal">write</code>) and the <code class="literal">path</code> specifier to replicate the behavior of <code class="literal">sockname</code>.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>
<strong>Regular Expressions for IP Addresses</strong>
</p><a class="indexterm" id="id425"/><p>For an IP address, the format of the string used in regular expression evaluation is this: <code class="literal">IP=&lt;address&gt;:&lt;port&gt;</code>. If you are creating a precise regular expression make sure to deal with the <code class="literal">IP=</code> prefix and the port information. A regular expression like this will fail: <code class="literal">peername.regex="^10.40.12[0-9]$"</code>. Why? Because it is missing the <code class="literal">IP=</code> and port information.</p></div></div><p>A more useful version of the rule above would deny access to anything in the directory if it was not in the particular ranges, but would leave further access controls to rules appearing later in the ACL list. This can be done using the special <code class="literal">break</code> control described in the next section. We could also added SSF information, so connections coming over non-local connections must also use strong SSL/TLS encryption. Here is the rule:</p><div><pre class="programlisting">access to * 
       by peername.ip=127.0.0.1 break
       by peername.ip=10.40.0.0%255.255.255.0 tls_ssf=128 break</pre></div><p>The above rule might appear difficult to read, but here is what it does:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the connection is local (coming over 127.0.0.1 or <code class="literal">localhost</code>), then SLAPD allows further processing of the ACL list (that's what <code class="literal">break</code> does). Whether or not the user then gets access to resources is dependent on other rules.</li><li class="listitem" style="list-style-type: disc">If the connection comes from an address on the LAN and it is using strong SSL/TLS encryption, then SLAPD will continue processing the ACL list.</li><li class="listitem" style="list-style-type: disc">Under any other connecting circumstances the connection is rejected. For example, if a connection comes from the LAN but does not use sufficiently strong SSL/TLS, the connection will be closed. This behavior is caused by the implicit <code class="literal">by</code> <code class="literal">*</code> <code class="literal">none</code> phrase.</li></ul></div><p>For more on the <code class="literal">break</code> control, see the section called <em>The</em> <em>Control</em> <em>Field</em>.</p><p>Sometimes it is more useful to be able to specify which domain names (rather than which IP addresses) should be granted access. This can be done with the <code class="literal">domain</code> specifier:</p><div><pre class="programlisting">access to * 
       by domain.exact="main.example.com" write
       by domain.sub="example.com" read</pre></div><p>In the example above, the second line provides write access to any client connection coming from the domain name <code class="literal">main.example.com</code>. The third line grants read access to the domain <code class="literal">example.com</code>, and any subdomain of <code class="literal">example.com</code>. So, if a server with the domain name <code class="literal">test2.example.com</code> made a request, it would be granted access under the third rule. However, <code class="literal">testexample.com</code> would not match because it is not a subdomain of <code class="literal">example.com</code>—it is a different domain altogether.</p><p>When SLAPD encounters a domain specifier in an ACL, it takes the IP address of the client connection and does a reverse DNS lookup to get the host name. In light of this there are two things to keep in mind when using the domain specifier.</p><p>First, the name returned by a reverse DNS lookup may not be what you expect based on a forward DNS lookup. For example, doing a DNS lookup on <code class="literal">ldap.example.com</code> returns the address 10.40.0.23. However, doing a reverse DNS lookup on 10.40.0.23 returns <code class="literal">mercury.example.com</code>. Why?</p><p>It is because <code class="literal">ldap.example.com</code> is in DNS parlance, a <strong>CNAME record</strong>, and <code class="literal">mercury.example.com</code> is an <strong>A record</strong>. Practically speaking, what this means is that <code class="literal">ldap.example.com</code> is an alias to the server's real (<strong>canonical</strong>) name, which is <code class="literal">mercury.example.com</code>. The practical consequence is this: when you write an ACL using the <code class="literal">domain</code> specifier, make sure you use the A record domain name, not the CNAME record name. Otherwise, SLAPD will apply the rule to the wrong domain name.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p><strong>Looking up DNS Information</strong></p><p>There are many tools for looking up DNS information. Most Linux distributions, including Ubuntu Linux, provide the <code class="literal">host</code> and <code class="literal">dig</code> commands for command-line DNS lookups. The <code class="literal">host</code> command gives brief sentence-like information like this: <code class="literal">ldap.example.com</code> <code class="literal">is</code> <code class="literal">an</code> <code class="literal">alias</code> <code class="literal">for</code> <code class="literal">mercury.example.com</code>. The <code class="literal">dig</code> command, in contrast, gives detailed technical information.</p></div></div><p>The second thing to keep in mind when considering the domain specifier is that it is less reliable than using IP address information. DNS addresses can be spoofed, which means another server on the network can claim to be <code class="literal">ldap.example.com</code> and send traffic that looks, to SLAPD, like it is coming from the real <code class="literal">ldap.example.com</code>.</p><p>One way to diminish the risk of this is to use client-side SSL/TLS certificates and configure SLAPD to require that the client send a signed certificate to authenticate before it can perform any other directory operations. Unfortunately, client-side certificates cannot be selectively required through ACLs. Instead you will have to use the directive <code class="literal">TLSVerifyClient</code> <code class="literal">demand</code> in the <code class="literal">slapd.conf</code> file.</p><p>The <code class="literal">sockname</code> and <code class="literal">sockurl</code> specifiers are used for servers that run with UNIX local socket Inter Process Communication (IPC) instead of network sockets. These directives can be used to restrict local connections that use the IPC layer instead of connecting through the IP network.</p><div><div><h3 class="title"><a id="note68"/>Note</h3><p>It is uncommon to run LDAPI. Generally it is used only in situations where IP network connections cannot or should not be used. In typical cases, local clients connect to SLAPD over LDAP, using the URL <code class="literal">ldap://localhost/</code> rather than using LDAPI.</p></div></div><p>For example, we could use the following ACL to allow only local (LDAPI) connections to write to the record, while users who connected through a different mechanism could only read the record:</p><div><pre class="programlisting">access to dn.exact="uid=matt,ou=Users,dc=example,dc=com"	
       by sockurl="ldapi://var/run/ldapi" write
       by users read</pre></div><p>The second line indicates that only LDAPI connections that connect through a particular LDAPI socket file should gain write access to the DN. All other clients (<code class="literal">users</code>) will get read permissions.</p></div><div><div><div><div><h4 class="title"><a id="ch04lvl4sec37"/>Advanced Step: Using the set Specifier</h4></div></div></div><a class="indexterm" id="id426"/><p>In addition to the syntax we have examined just now, there is an experimental type of <code class="literal">by</code> phrase—the <strong>set</strong> syntax. The <code class="literal">set</code> syntax can be used to create a compact and powerful set of conditions for access. Since it allows Boolean operators, and has a method for accessing attribute values, a single rule in the <code class="literal">set</code> syntax can accomplish what would otherwise take tremendously complex ACLs.</p><p>The basic idea behind the <code class="literal">set</code> syntax is this. By using a rule composed of conditions joined by operators, SLAPD creates a set of objects which have access to the record in question. If the result of an evaluation of a <code class="literal">set</code> specifier is a set that contains one or more members, then the <code class="literal">by</code> phrase is considered a match and permissions are applied. If, on the other hand, the set is empty, then SLAPD will continue evaluating the <code class="literal">by</code> phrases for that rule to see if it can find another match.</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>The <code class="literal">set</code> specifier uses operations of the sort used in set theory. When using the set specifier you may find it helpful to think in terms of set theory, with sets (lists of items) and set operations, such as union (<code class="literal">&amp;</code>) and intersection (<code class="literal">|</code>).</p></div></div><p>Here is a simple ACL using a <code class="literal">set</code> specifier to replicate the behavior of the <code class="literal">group</code> specifier. It provides write access to records in the System OU only to clients in the LDAP Admins group. All others get read access only:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com"
<strong>       by set="[cn=ldap admins,ou=groups,dc=example,dc=com]/</strong>
<strong>           uniqueMember &amp; user" write</strong>
       by users none</pre></div><p>The second line, highlighted above, contains the <code class="literal">set</code> specifier, which contains a <code class="literal">set</code> statement. The text in the square brackets specifies a DN, which is the DN of the LDAP Admins group. To access the values of the <code class="literal">uniqueMember</code> attribute we append <code class="literal">/uniqueMember</code> to the DN. When SLAPD expands this, it will contain the set of all <code class="literal">uniqueMembers</code> in the LDAP <code class="literal">Admins</code> <code class="literal">group</code>. In set-theoretic notation (which is not used by OpenLDAP, but which is helpful to understand what is happening), the set of group members would look like this:</p><div><pre class="programlisting">{ uid=matt,ou=users,dc=example,dc=com ; 
    uid=barbara,ou=users,dc=example,dc=com }</pre></div><a class="indexterm" id="id427"/><p>There are two members (the two <code class="literal">uniqueMembers</code>) for the LDAP Admins group.</p><p>The <code class="literal">&amp;</code> (ampersand) operator performs a union operation on two sets. The <strong>user keyword</strong> expands to the set that contains one member: the DN of the current client. So, if I perform a search, binding as <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>, then the user set will contain one record:</p><div><pre class="programlisting">{ uid=matt,ou=users,dc=example,dc=com }</pre></div><p>When the <code class="literal">&amp;</code> operator is applied, it will generate the intersection of the two sets. That is, the resulting set will contain only members that are in both of the original sets. Since only the record for UID <code class="literal">matt</code> is in both, the resulting set will contain just the DN for <code class="literal">matt</code>:</p><div><pre class="programlisting">{ uid=matt,ou=users,dc=example,dc=com }</pre></div><p>The resulting set is not empty so it is considered a match. The result of the set evaluation, then, is that the <code class="literal">uid=matt,ou=users,dc=example,dc=com</code> will be granted access based on the <code class="literal">set</code> specifier.</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>Sets are case-sensitive, and always use the normalized DN form. What this means is that the DNs in sets should always be lowercase.</p></div></div><p>Consider a case though, when the user is not a member of the LDAP Admins group. If <code class="literal">uid=david,ou=users,dc=example,dc=com</code> binds, can he perform read and write operations? When the set specifier is run, the first of the two sets (group membership) will evaluate to the same thing it did above:</p><div><pre class="programlisting">{ uid=matt,ou=users,dc=example,dc=com ; 
    uid=barbara,ou=users,dc=example,dc=com }</pre></div><p>But the user keyword will expand to this:</p><div><pre class="programlisting">{ uid=david,ou=users,dc=example,dc=com }</pre></div><p>There are no items in the intersection of these two sets, so the resulting set, after the <code class="literal">&amp;</code> operator is applied, is an empty set:</p><div><pre class="programlisting">{ }</pre></div><p>There are no matches, so this <code class="literal">by</code> phrase fails to apply. The last line in our ACL (<code class="literal">by</code> <code class="literal">users</code> <code class="literal">none</code>) will then apply, and the <code class="literal">uid=david</code> will be given no access permissions.</p><a class="indexterm" id="id428"/><p>Let's look at another example. We will use the set specifier to implement a rule where, when a client DN tries to access a record DN, it is given write access only if the two DNs are the same, or else it is given read access if they are in the same OU. Otherwise, the client DN is denied access to the record DN. Here's the ACL:</p><div><pre class="programlisting">access to dn.subtree="dc=example,dc=com"
       by set="this &amp; user" write
       by set="this/ou &amp; user/ou" read</pre></div><p>The first line indicates that this rule will apply to the record <code class="literal">dc=example,dc=com</code> and everything under it.</p><p>The second line takes the intersection of the sets generated by two keywords: <code class="literal">this</code> and <code class="literal">user</code>. The <code class="literal">this</code> keyword expands to the set containing the DN of the requested record. The <code class="literal">user</code> keyword, as we saw, expands to the DN of the client.</p><p>So, if the client <code class="literal">uid=david,ou=users,dc=example,dc=com</code> requests access to its own record, the resulting set operation will be as follows:</p><div><pre class="programlisting">{ uid=david,ou=users,dc=exampls,dc=com } &amp; 
    { uid=david,ou=users,dc=example,dc=com }</pre></div><p>Since both sets contain the same member, the resulting set (the intersection of the two) is <code class="literal">{</code> <code class="literal">uid=david,ou=users,dc=example,dc=com</code> <code class="literal">}</code>. The end set is not empty, so the user will be granted write access.</p><p>Now let's look at the third line of the given ACL. This rule will return a non-empty set whenever the requested DN and the client DN both have the same value for the <code class="literal">ou</code> attribute. If <code class="literal">uid=david,ou=users,dc=example,dc=com</code> requests the record for <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>, then SLAPD will check the values of their respective OU attributes.</p><p>The set identified by <code class="literal">this/ou</code> will be expanded to contain the values of all of the OU attributes in the requested record (the record for <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>). This set is:</p><div><pre class="programlisting">{ 'Users' }</pre></div><p>Note that in this case the value is not a DN, but a string. Sets can perform matching operations on strings as well as DNs.</p><p>The set identified by <code class="literal">user/ou</code> will be expanded to contain the values of all of the OU attributes in the client's record. The record for <code class="literal">uid=david,ou=users,dc=example,dc=com</code> contains one value for the <code class="literal">ou</code> attribute, and the resulting set will contain that one attribute value:</p><div><pre class="programlisting">{ 'Users' }<a class="indexterm" id="id429"/>
</pre></div><p>SLAPD will compute the intersection of <code class="literal">{</code> <code class="literal">'Users'</code> <code class="literal">}</code> <code class="literal">&amp;</code> <code class="literal">{</code> <code class="literal">'Users'</code> }, which is <code class="literal">{</code> <code class="literal">'Users'</code> <code class="literal">}</code>. Since the set is not empty, <code class="literal">uid=david,ou=users,dc=example,dc=com</code> will be granted access to read the record of <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>.</p><p>The <code class="literal">set</code> specifier provides one way of granting access to a record <em>only</em> in the case that a record contains a certain attribute. If we only want to grant write access to records with the title attribute, we can use the following rule:</p><div><pre class="programlisting">access to dn.child="ou=Users,dc=example,dc=com"
       by set="this/title" write</pre></div><p>In this ACL, if the requested record has a single <code class="literal">title</code> attribute, then the result of the evaluation of the above rule will be a set containing one element. However, if the record attribute has no title attribute, then the resulting set will be empty, and write access will not be granted.</p><p>In our directory the record of <code class="literal">uid=matt,ou=users,dc=example,dc=com</code> has the following title attribute:</p><div><pre class="programlisting">title: Systems Integrator</pre></div><p>But the record <code class="literal">uid=barbara,ou=users,dc=example,dc=com</code> does not have a title attribute at all. So if the record for <code class="literal">uid=matt</code> was requested, then the resulting set, based on the above ACL, would be:</p><div><pre class="programlisting">{ 'Systems Integrator' }</pre></div><p>So if an authenticated user attempted to access the record for <code class="literal">uid=matt</code>, SLAPD would grant access. In contrast, the set for <code class="literal">uid=barbara</code> would be <code class="literal">{}</code>, the empty set. So a user trying to access the record having <code class="literal">uid=barbara</code> would be denied access.</p><p>Using a similar set specifier, we could grant access to a record depending not only on the existence of an attribute, but on its value too:</p><div><pre class="programlisting">access to dn.child="ou=Users,dc=example,dc=com"
       by set="this/objectclass &amp; [person]" write</pre></div><p>According to the above rule, write access will be granted for anything in the Users OU only if the entry has an <code class="literal">objectclass</code> attribute with the value <code class="literal">person</code>. Note that in this case the square brackets are used to define a string literal.</p><p>If a client were to access the record <code class="literal">uid=barbara,ou=users,dc=example,dc=com</code>, the first part of our <code class="literal">set</code> statement would evaluate to the following set:</p><div><pre class="programlisting">{ 'person' ; 'organizationalPerson' ; 'inetOrgPerson' }</pre></div><p>Those are the three object classes for the <code class="literal">uid=barbara</code> record. The other part, <code class="literal">[person]</code>, would be expanded to this set:</p><div><pre class="programlisting">{ 'person' }</pre></div><p>When the union is computed, the result would be the set <code class="literal">{'person'}</code> and so write access would be granted.<a class="indexterm" id="id430"/>
</p><p>These are just a few of the basic operations that can be done with the <code class="literal">set</code> specifier. Unfortunately, <code class="literal">set</code> is not documented in the <code class="literal">slapd.access</code> man page. However, there is a lengthy and informative article on using set in the OpenLDAP official FAQ-O-Matic: <a class="ulink" href="http://www.openldap.org/faq/data/cache/1133.html">http://www.openldap.org/faq/data/cache/1133.html</a>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec61"/>The control Field</h3></div></div></div><a class="indexterm" id="id431"/><p>The last field in the <code class="literal">by</code> phrase is the control field. There are only three possible values for the control field: <code class="literal">stop</code>, <code class="literal">break</code>, and <code class="literal">continue</code>. If no control field is specified, <code class="literal">stop</code> is assumed. For example, <code class="literal">by</code> <code class="literal">*</code> <code class="literal">none</code> is the same as <code class="literal">by</code> <code class="literal">*</code> <code class="literal">none</code> <code class="literal">stop</code>.</p><p>The first value, <code class="literal">stop</code>, indicates that if that particular by clause matches, no further checking of ACLs for matching should occur. Consider the following (admittedly contrived) case:</p><div><pre class="programlisting">access to attr=employeeNumber, employeeType, departmentNumber
       by users=cd
       by dn="uid=matt,ou=Users,dc=example,dc=com" +r

access to attr=employeeNumber
       by users +w</pre></div><p>If I bind as <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> and try to modify my <code class="literal">employeeNumber</code>, will I be allowed to? No, I will not.</p><p>The reason I will not be able to modify the record is because I will only have the permissions granted by the first <code class="literal">by</code> phrase: <code class="literal">by</code> <code class="literal">users</code> <code class="literal">=cd</code> (remember, <code class="literal">by</code> <code class="literal">users</code> <code class="literal">=cd</code> is the same as <code class="literal">by</code> <code class="literal">users=cd</code> <code class="literal">stop</code>). As soon as SLAPD sees that I match the first <code class="literal">by</code> phrase of the first ACL, it will stop testing ACLs. Thus it will never reach the rule that grants my DN <code class="literal">+r</code> access, nor will it reach the rule that grants all users <code class="literal">+w</code> to the <code class="literal">employeeNumber</code> attribute.</p><p>This is an example of the <code class="literal">stop</code> control, which is used implicitly by all three rules.</p><p>Now, if I wanted to make sure that after the first <code class="literal">by</code> phrase SLAPD continues to evaluate phrases within the ACL, I could re-write the ACLs using the <code class="literal">continue</code> control:</p><div><pre class="programlisting">access to attr=employeeNumber, employeeType, departmentNumber
       by users-=cd continue
       by dn="uid=matt,ou=Users,dc=example,dc=com" +r

access to attr=employeeNumber
       by users +w</pre></div><p>After running the same test on these rules, the DN <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> would have the permissions <code class="literal">=cdr</code>.</p><p>The <code class="literal">continue</code> control instructs SLAPD to continue processing all of the <code class="literal">by</code> phrases in the <em>current</em> <em>ACL</em>. Once it is done evaluating that ACL though, it will not continue to look for matches in other ACLs.</p><p>In order to tell SLAPD to look at different rules for matches, we would have to use the <code class="literal">break</code> control. When SLAPD encounters an applicable clause that ends with a <code class="literal">break</code> control, it stops processing the current ACL but continues looking at other ACLs to see if they apply. <a class="indexterm" id="id432"/>
</p><p>Thus, to get write permissions with our ACL we would want the following ACLs:</p><div><pre class="programlisting">access to attr=employeeNumber, employeeType, departmentNumber
       by users=cd continue
       by dn="uid=matt,ou=Users,dc=example,dc=com" +r break

access to attr=employeeNumber
       by users +w stop</pre></div><p>Now what will happen when the user with UID <code class="literal">matt</code> attempts accesses an <code class="literal">employeeNumber</code>? </p><p>First, the <code class="literal">by</code> phrase of the first ACL will be evaluated, and <code class="literal">matt</code> will be granted <code class="literal">=cd</code>. Because of the <code class="literal">continue</code> control, SLAPD will then examine the second <code class="literal">by</code> clause, which will also match for the user <code class="literal">matt</code>. Thus, <code class="literal">matt</code> will have <code class="literal">=rcd</code> when the processing of the first ACL completes.</p><p>Due to the <code class="literal">break</code> control the second ACL will also be evaluated, and <code class="literal">matt</code> will be granted <code class="literal">+w</code> as well, bringing his final permissions up to <code class="literal">=wrcd</code>.</p><p>Using the <code class="literal">continue</code> and <code class="literal">break</code> controls is one way to incrementally handle permissions. In complex configurations, judicious use of <code class="literal">continue</code> and <code class="literal">break</code> can make maintaining ACLs much easier, and can reduce the total number of ACLs.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Getting More from Regular Expressions</h2></div></div></div><a class="indexterm" id="id433"/><p>In the previous sections we have looked at using regular expressions in both the <code class="literal">access</code> <code class="literal">to</code> phrase and the <code class="literal">by</code> phrase. But we can use both in conjunction. We can store information about the matches identified in the <code class="literal">access</code> <code class="literal">to</code> phrase, and use that information later in the <code class="literal">by</code> phrases.</p><p>To temporarily store matching information in an <code class="literal">access</code> <code class="literal">to</code> phrase we can surround the regular expression with parentheses. Here's an example:</p><div><pre class="programlisting">access to dn.regex="ou=([^,]+),dc=example,dc=com"
       by dn.children,expand="ou=$1,dc=example,dc=com" read</pre></div><p>This ACL grants a client the DN access to read a record DN only if both the client DN and the record DN are in the same part of the directory tree (that is, if both are in the same OU).</p><p>In the first line of the given ACL we used parentheses to capture the match from the regular expression <code class="literal">[^,]+</code>, which will be the value of the <code class="literal">ou=</code> component of the DN. Again, <code class="literal">[^,]+</code> says "match all charcters  that are not '<code class="literal">,</code>'." </p><p>In the second line we used the <code class="literal">dn.children</code> specifier but supplemented it with an extra keyword: <code class="literal">expand</code>. The <code class="literal">expand</code> keyword tells SLAPD to substitute matches from the <code class="literal">access</code> <code class="literal">to</code> clause into this phrase.</p><p>Because of the <code class="literal">expand</code> keyword, the variable <code class="literal">$1</code> is substituted with the value of the match in the first line. Everything captured between '<code class="literal">(</code>' and '<code class="literal">)</code>' in the regular expression will be stored in <code class="literal">$1</code>.</p><p>Variable names are assigned in order. The first set of parenthesis in the regular <code class="literal">access</code> <code class="literal">to</code> phrase gets stored in <code class="literal">$1</code>. If a second set of parenthesis existed, the matching information inside of those would be stored in <code class="literal">$2</code> and so on for each additional set of parenthesis.</p><p>For example, we might want an ACL like this:</p><div><pre class="programlisting">access to dn.regex="uid=([^,]+),ou=([^,]+),dc=example,dc=com"
       by dn.children,expand="uid=$1,ou=$2,dc=example,dc=com" write</pre></div><p>This rule would grant a client DN access to read and write any entries subordinate to its own record but deny other uses the ability to even read those entries.</p><div><div><h3 class="title"><a id="note70"/>Note</h3><p>Address books are sometimes implemented in OpenLDAP by storing a user's addresses as subordinate entries to the user's own entry in the directory. There is an example of this in the OpenLDAP FAQ-O-Matic: <a class="ulink" href="http://www.openldap.org/faq/data/cache/1005.html">http://www.openldap.org/faq/data/cache/1005.html</a>
</p></div></div><p>Notice that the first line stores two variables. The UID goes in <code class="literal">$1</code> and the OU goes in <code class="literal">$2</code>. These are expanded in the second line.</p><p>It is also possible to use matches from the <code class="literal">access</code> <code class="literal">to</code> phrase in regular expressions in the <code class="literal">by</code> phrase:</p><div><pre class="programlisting">access to dn.regex="uid=[^,]+,ou=([^,]+),dc=example,dc=com"
       by dn.regex="uid=[^,]+,ou=$1,dc=example,dc=com" write</pre></div><p>In the first line only the results of the second regular expression are captured and stored in a variable. The second line also contains a regular expression, and it makes use of the <code class="literal">$1</code> variable to retrieve the value of the OU from the first line. Note that <code class="literal">dn.children,expand</code> was replaced with <code class="literal">dn.regex</code>. The <code class="literal">expand</code> keyword need not be added for regular expressions.</p><p>The rule grants write access to a client DN for any user record that is in the same OU of that directory tree.</p><p>We have looked at some simple, though useful, regular expressions in these ACLs. But much more complex regular expressions can be composed, making ACLs even more powerful. As you compose more advanced regular expressions you may find some other sources of information helpful. Along with the <code class="literal">slapd.access</code> man page, the POSIX extended regular expressions man page (<code class="literal">man</code> <code class="literal">regex</code>) may turn out to be useful as well.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Debugging ACLs</h2></div></div></div><a class="indexterm" id="id434"/><p>Debugging ACLs can be frustrating. They are complex, security sensitive, and require detailed testing. But there are three tools that make the debugging and testing process easier.</p><p>The first is just the <code class="literal">ldapsearch</code> command-line client. It can be used to carefully craft filters designed to test the processing of ACLs. The <code class="literal">ldapcompare</code> tool also comes in handy when you need to test comparison operations.</p><p>But it is also useful to make the most of LDAP's logging directives. The <code class="literal">trace</code> and <code class="literal">acl</code> debugging levels each provide detailed information about ACL processing. The <code class="literal">acl</code> level, for example, records each ACL evaluation. This can be very useful in determining what rules are run and when. We find the <code class="literal">trace</code> debugging level to be useful as well, as it provides information about how each evaluation was performed, including how regular expressions were expanded.</p><div><div><h3 class="title"><a id="tip31"/>Tip</h3><p>
<strong>Running SLAPD in the Foreground</strong>
</p><p>Sometimes it is easier to test ACLs by running SLAPD in the foreground, instead of as a daemon process, and printing debugging and logging information to standard out. For example, we can print ACL and trace debugging out this way: <code class="literal">slapd</code> <code class="literal">-d</code> <code class="literal">"acl,trace"</code>. Note that you will want to run this command as the appropriate user (such as <code class="literal">openldap</code>). To terminate the process use the <em>Ctrl</em>-<em>C</em> keyboard combination.</p></div></div><p>Finally, the <code class="literal">slapacl</code> command line utility provides a detail-oriented tool for evaluating ACLs directly. Since it does not connect to the SLAPD server over the LDAP protocol it allows more direct testing of just the ACLs.</p><p>For example, we can check whether or not a particular SASL user, <code class="literal">matt</code>, can access the record <code class="literal">cn=LDAP</code> <code class="literal">Admins,ou=Groups,dc=example,dc=com</code> and <em>read</em> the value of the <code class="literal">description</code> attribute:</p><div><pre class="programlisting">
<strong>  $ slapacl -U matt -b "cn=LDAP Admins,ou=Groups,dc=example,dc=com" \ </strong>
<strong>      "description/read"</strong>
</pre></div><p>The <code class="literal">-U</code> <code class="literal">matt</code> param specifies the SASL user name. The <code class="literal">-b</code> <code class="literal">"cn=LDAP</code> <code class="literal">Admins,ou=Groups,</code> <code class="literal">dc=example,dc=com"</code> param indicates which record we want to test against, and the last field, <code class="literal">"description/read"</code> indicates the attribute and the access level. This will simply return <code class="literal">ALLOWED</code> if the ACLs allow read access, or <code class="literal">DENIED</code> otherwise.</p><p>Likewise, we can test other LDAP operations. For example, we can test whether a user has permissions to <code class="literal">compare</code>:</p><div><pre class="programlisting">$ slapacl -U matt -b "uid=matt,ou=Users,dc=example,dc=com" 
    "uid/compare"
authcDN: "uid=matt,ou=users,dc=example,dc=com"
compare access to uid: ALLOWED</pre></div><p>In this example we have included the response. The first response line indicates how the SASL DN was resolved, and the second line indicates that compare access on <code class="literal">uid</code> was allowed.</p><p>The <code class="literal">slapacl</code> program essentially runs its own SLAPD and as such, it can be set to print complete processing logs to the screen. For example, to turn on trace debugging we can just add the <code class="literal">-d</code> <code class="literal">trace</code> param to the given command:</p><div><pre class="programlisting">$ slapacl -U matt -b "uid=matt,ou=Users,dc=example,dc=com" -d trace 
    "uid/compare"
slapacl init: initiated tool.
slap_sasl_init: initialized!
hdb_back_initialize: initialize HDB backend
hdb_back_initialize: Sleepycat Software: Berkeley DB 4.3.29: 
    (September  6, 2005)
bdb_db_init: Initializing HDB database
&gt;&gt;&gt; dnPrettyNormal: &lt;dc=example,dc=com&gt;
# LOTS of lines deleted...
&lt;&lt;&lt; dnPrettyNormal: &lt;uid=matt,ou=Users,dc=example,dc=com&gt;, 
    &lt;uid=matt,ou=users,dc=example,dc=com&gt;
entry_decode: ""
&lt;= entry_decode()
compare access to uid: ALLOWED
slapacl shutdown: initiated
====&gt; bdb_cache_release_all
slapacl destroy: freeing system resources.</pre></div><p>As you can see<code class="literal">slapacl</code> provides detailed evaluation information in this case.</p><p>Using the LDAP command-line clients, detailed logging, and the <code class="literal">slapacl</code> command, debugging and testing ACLs can be done effectively.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>A Practical Example</h2></div></div></div><a class="indexterm" id="id435"/><p>In this part of the chapter, we have taken a low-level look at ACLs in OpenLDAP. We have covered many of the details of the ACL system. Now it is time to implement what we have covered so far to create a generic set of ACLs for our directory information tree.</p><p>In Chapter 2 we created a bare-bones set of ACLs in our <code class="literal">slapd.conf</code> file. Here's what we created then:</p><div><pre class="programlisting">########
# ACLs #
########
access to attrs=userPassword
       by anonymous auth
       by self write
       by * none

access to *
       by self write
       by * none</pre></div><p>Now, we will create a new, more practical list of ACLs.</p><p>The first thing we will do is move the ACLs out of <code class="literal">slapd.conf</code> and into a separate file: <code class="literal">acl.conf</code>. This will keep the lengthy list of ACLs separate from the rest of our configuration. To do this we will replace the ACLs above with an <code class="literal">include</code> directive:</p><div><pre class="programlisting">########
# ACLs #
########
include /etc/ldap/acl.conf</pre></div><p>When SLAPD is started it will include the contents of <code class="literal">/etc/ldap/acl.conf</code> at the location where the <code class="literal">include</code> statement appears. Recall that ACLs are backend-specific. Each different database can have its own ACLs (and multiple databases can be defined in the same <code class="literal">slapd.conf</code> file). So it is important to put the <code class="literal">include</code> directive after the database <code class="literal">directive</code> in <code class="literal">slapd.conf</code>.</p><p>Now we will begin editing the <code class="literal">acl.conf</code> file. The rules that we will write will be simple, and designed for a directory where most of the directory users are allowed to view most of the information in the directory. A higher-security directory may have a far more complex list of ACLs.<a class="indexterm" id="id436"/>
</p><p>Since ACLs are evaluated in order from top to bottom we want to carefully craft our rules so that important restrictions are implemented right away.</p><p>If there are network-based access rules they should usually appear at the top of the ACL list so that they are evaluated first. For example, if we want to restrict access to the entire database if the host is not in our LAN, we would use the following rule:</p><div><pre class="programlisting">access to * 
       by peername.ip=127.0.0.1 none break
       by peername.ip=10.40.0.0%255.255.255.0 none break</pre></div><p>By this rule only access from the localhost (127.0.0.1) and from inside of our 10.40.0.0 subnet will be allowed to access the directory. Since the <code class="literal">break</code> control is specified, later rules may modify the <code class="literal">none</code> permission, granting clients more permissions. All other connections will be closed immediately.</p><p>Next, we want to grant members of the LDAP Admins group write access to everything in the <code class="literal">dc=example,dc=com</code> tree:</p><div><pre class="programlisting">access to dn.subtree="dc=example,dc=com"
       by group/groupOfUniqueNames/uniqueMember=
           "cn=LDAP Admins,ou=Groups,dc=example,dc=com" write
       by * none break</pre></div><p>This immediately grants write access to the members of the LDAP Admins group. For all other clients though, SLAPD will continue processing.</p><div><div><h3 class="title"><a id="note71"/>Note</h3><p>No ACLs need to be written for the directory manager, the DN specified in the <code class="literal">slapd.conf</code> directive <code class="literal">rootdn</code>. This DN always has full access to the directory information tree, and ACLs will have no effect on this user.</p></div></div><p>Next, we want to make sure that the <code class="literal">userPassword</code> field is available to the anonymous user for authentication purposes. We also want to allow users to be able to modify their own passwords, but otherwise we want <code class="literal">userPassword</code> unavailable for reading and writing by others. Note that by the previous rule the LDAP Admins will also be able to modify passwords for users.</p><div><pre class="programlisting">access to attrs=userPassword
       by anonymous auth
       by self write</pre></div><p>In some cases, other users may need <code class="literal">auth</code> access to the password as well, in which case you may need to add <code class="literal">by</code> <code class="literal">users</code> <code class="literal">auth</code> to the given list.</p><p>We also need to grant access to the <code class="literal">uid</code> attribute if we are using the <code class="literal">ldap://</code> URL form for SASL binding in the <code class="literal">authz-regexp</code> directive. This is because the filter in the LDAP URL is run as anonymous (see the discussion in the <em>Configuring</em> <em>SLAPD</em> <em>for</em> <em>SASL</em> <em>Support Subsection</em>).</p><p>Additionally, we don't want to let users try to modify their own <code class="literal">uid</code>, since <code class="literal">uid</code> is used in the DN:</p><div><pre class="programlisting">access to attrs=uid
        by anonymous read
        by users read</pre></div><p>Now Anonymous and all authenticated users will be able to access the <code class="literal">uid</code> attribute of any record in the directory to which they have access.</p><p>There are also a few other attributes we don't want users to be able to modify—even in their own records.</p><p>We don't want users to try to modify their OU attributes, since OU attributes are also used in DNs. We also don't want them to be able to modify their <code class="literal">employeeNumber</code> or their <code class="literal">employeeType</code>:<a class="indexterm" id="id437"/>
</p><div><pre class="programlisting">access to attrs=ou,employeeNumber,employeeType by users read</pre></div><p>We have a special account, <code class="literal">uid=Authenticate,ou=System,dc=example,dc=com</code>, which will be used on occasion to help with bind requests. This user should not have access to anything else other than what we specified:</p><div><pre class="programlisting">access to * 
       by dn.exact="uid=Authenticate,ou=System,dc=example,dc=com" 
           none
       by users none break</pre></div><p>Again, the last line instructs SLAPD to continue processing ACLs for users who aren't having the authentication account. This line will also stop the anonymous user from browsing the rest of the tree since the implicit rule at the end, <code class="literal">by</code> <code class="literal">*</code> <code class="literal">none</code>, will catch the anonymous user.</p><div><div><h3 class="title"><a id="note72"/>Note</h3><p>The <code class="literal">uid=Authenitcate</code> user was already granted, in an earlier rule, access to the <code class="literal">uid</code> attribute, which is the attribute that this account will use to search for user information needed to bind.</p></div></div><p>Let's say that we don't want regular users (DNs in the Users OU) to be able to access records in the System OU of our directory (which is typically used for system accounts). We can implement this with the following rule:</p><div><pre class="programlisting">access to dn.subtree="ou=System,dc=example,dc=com"
       by dn.subtree="ou=Users,dc=example,dc=com" none
       by users read</pre></div><p>This denies access to users in the Users OU, but allows other users (like System accounts) access to these records.</p><p>We also want to give every user the ability to read and write records below its own, but restrict others from accessing those records. This makes it possible for users to store their own information (like address books) inside of the directory:</p><div><pre class="programlisting">access to dn.regex="^.*,uid=([^,]+),ou=Users,dc=example,dc=com$"
       by dn.exact,expand="uid=$1,ou=Users,dc=example,dc=com write</pre></div><p>Finally, the last rule we want is a default rule. This rule should answer the question, "What do we want to happen when no other rules are matched?" We want users to be able to modify their own records and see the records of others:</p><div><pre class="programlisting">access to *<a class="indexterm" id="id438"/>
       by self write
       by users read</pre></div><p>Now our list of ACLs is complete. Altogether, this is what they look like:</p><div><pre class="programlisting">#################################################
# ACLs
# These are ACLs for the first database section
# of the slapd.conf file found in this directory
#################################################
##
## Restrict by IP address:
access to *
       by peername.ip=127.0.0.1 none break
       by peername.ip=10.40.0.0%255.255.255.0 none break

## Give Admins immediate write access:
access to dn.subtree="dc=example,dc=com"
       by group/groupOfUniqueNames/uniqueMember="cn=LDAP 
           Admins,ou=Groups,dc=example,dc=com" write
       by * none break

## Grant access to passwords for auth, but allow users to change 
## their own.
access to attrs=userPassword
       by anonymous auth
       by self write

## This rule is needed by authz-regexp
## (Note: Since uid is used in DN, user cannot change its own uid.)
access to attrs=uid
       by anonymous read
       by users read
## Don't let anyone modify OUs, employee num or employee type.
access to attrs=ou,employeeNumber,employeeType by users read

## Stop authentication account from reading anything else. This also 
## stops anonymous.
access to *
       by dn.exact="uid=Authenticate,ou=System,dc=example,dc=com" 
           none
       by users none break

## Prevent DNs in ou=Users from seeing system accounts
access to dn.subtree="ou=System,dc=example,dc=com"
       by dn.subtree="ou=Users,dc=example,dc=com" none
       by users read

## Allow user to add subentries beneath its own record.
access to dn.regex="^.*,uid=([^,]+),ou=Users,dc=example,dc=com$"
       by dn.exact,expand="uid=$1,ou=Users,dc=example,dc=com" write

## The default rule: Allow DNs to modify their own records. Give 
## read access to everyone else.
access to *<a class="indexterm" id="id439"/>
       by self write
       by users read</pre></div><p>While they certainly won't meet all needs, these rules provide a good starting point for balancing security and usability of the directory. Furthermore, they set the stage for some of the things we will be doing later in this book.</p><p>In later chapters of this book, the mentioned ACLs will be revisited and fine-tuned to allow additional features, like directory replication.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>The focus of this chapter has been OpenLDAP security, and we have covered a lot of ground. We began with connection-level security, where we configured SSL/TLS encryption for our directory server. We used StartTLS over the standard LDAP port, and also configured the older (LDAP v2) LDAPS protocol on port 636. Next, we looked at the process of authenticating to the LDAP. In that part we covered both simple binding and SASL binding. Finally, we took a detailed look at access control lists (ACLs), finishing the chapter with a basic set of ACLs.</p><p>In the next chapter we will look at advanced configuration of OpenLDAP's SLAPD server. We will configure our server to host multiple backend databases and we will use directory overlays to add powerful additional features to our SLAPD server.</p></div></body></html>