- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Managing Containers with Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 管理容器
- en: In this chapter, you will learn about one of the most well-known tools for creating
    and managing containers – **Docker**. The topics in this chapter will prepare
    you for the future of Linux, as it is the foundation of every modern cloud technology.
    If you wish to remain up to date in a constantly changing landscape, this chapter
    will be the essential starting point for your journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习创建和管理容器的最知名工具之一——**Docker**。本章的内容将为你准备 Linux 的未来，因为它是每种现代云技术的基础。如果你希望在不断变化的技术环境中保持更新，本章将是你旅程的关键起点。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将覆盖以下主要内容：
- en: Understanding Linux containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Linux 容器
- en: Working with Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker
- en: Working with **Dockerfiles**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **Dockerfile**
- en: Deploying a containerized application with Docker
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 部署容器化应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: No specific technical requirements are needed, just a working installation of
    Linux on your system. Both Ubuntu/Debian and Fedora/RHEL are equally suitable
    for this chapter’s exercises. We will use Debian GNU/Linux 12 for most of our
    examples, but where appropriate, we will discuss the specifics of Fedora Linux
    installation and use.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有特定的技术要求，只需在系统上安装一个正常工作的 Linux 系统。Ubuntu/Debian 和 Fedora/RHEL 都适合本章的练习。我们将使用
    Debian GNU/Linux 12 作为大多数示例，但在合适的地方，我们会讨论 Fedora Linux 安装和使用的具体细节。
- en: Understanding Linux containers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 容器
- en: 'As we have demonstrated in the previous chapter, there are two main types of
    virtualization: **virtual machine** (**VM**)**-based** and **container-based**.
    We discussed VM-based virtualization in the previous chapter, and now it is time
    to explain what containers are. At a very basic, conceptual level, containers
    are similar to VMs. They have similar purposes – allowing an isolated environment
    to run – but they are different in so many ways that they can hardly be called
    similar. Let’s compare these two concepts in more detail.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中演示的那样，虚拟化有两种主要类型：**虚拟机（VM）**-基础的和 **容器**-基础的。在上一章中，我们讨论了基于虚拟机的虚拟化，现在是时候解释容器是什么了。从基本的概念层面来看，容器与虚拟机类似。它们有相似的目的——提供一个隔离的环境来运行——但在许多方面，它们的不同之处让它们几乎无法被称为相似。让我们更详细地比较这两个概念。
- en: Comparing containers and VMs
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与虚拟机的比较
- en: As you already know, a VM emulates the machine’s hardware and uses it as if
    there were several machines available. By comparison, containers do not replicate
    the physical machine’s hardware; they do not emulate anything.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，虚拟机（VM）模拟了机器的硬件，并将其作为多个机器来使用。而容器则不复制物理机器的硬件，它们并不模拟任何东西。
- en: A container shares the base OS kernel with shared libraries and binaries needed
    for certain applications to run. The applications are contained inside the container,
    isolated from the rest of the system. They also share a network interface with
    the host to offer similar connectivity to a VM.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与操作系统内核共享基础操作系统，并共享特定应用程序运行所需的库和二进制文件。应用程序被包含在容器内，与系统的其他部分隔离开来。它们还与主机共享网络接口，以提供与虚拟机相似的连接性。
- en: 'Containers run on top of a **container engine**. Container engines offer OS-level
    virtualization, used to deploy and test applications by using only the requisite
    libraries and dependencies. This way, containers make sure that applications can
    run on any machine by providing the same expected behavior as intended by the
    developer. The following is a visual comparison between containers and VMs:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行在 **容器引擎** 上。容器引擎提供操作系统级别的虚拟化，用于部署和测试应用程序，仅使用所需的库和依赖项。通过这种方式，容器确保应用程序能够在任何机器上运行，并提供开发者预期的相同行为。以下是容器和虚拟机的视觉对比：
- en: '![Figure 12.1 – Containers versus VMs (general scheme)](img/B19682_12_1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 容器与虚拟机的对比（总体示意图）](img/B19682_12_1.jpg)'
- en: Figure 12.1 – Containers versus VMs (general scheme)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 容器与虚拟机的对比（总体示意图）
- en: As you can see, the containers only use the **userspace**, sharing the underlying
    OS-level architecture.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，容器仅使用 **用户空间**，共享底层的操作系统架构。
- en: Historically speaking, containerization has been around for some time now. With
    the Unix OS, **chroot** has been the tool used for containerization since 1982.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，容器化已经存在了一段时间。自 1982 年起，Unix 操作系统的 **chroot** 工具就被用于容器化。
- en: On Linux, some of the newest and most frequently used tools are **Linux containers**
    (**LXC**), with **LXD** as a newer and extended version of the former, introduced
    in 2008, and Docker, introduced in 2013\. Why this LXC/LXD nomenclature? Well,
    LXC was the first kid on the containers block, with LXD being a newer, redesigned
    version of it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，一些最新和最常用的工具是 **Linux 容器**（**LXC**），其中 **LXD** 是其更新版和扩展版，推出于 2008 年，而
    Docker 则于 2013 年发布。为什么是 LXC/LXD 命名法？因为 LXC 是容器领域中的“老大哥”，LXD 是其更新版和重新设计的版本。
- en: In the next section, we will dissect the underlying container technology.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将剖析底层容器技术。
- en: Understanding the underlying container technology
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解底层容器技术
- en: As mentioned earlier, LXC was one of the earliest forms of containers, introduced
    12 years ago. The newer form of containers, and the ones that changed the entire
    container landscape and started all the DevOps hype (more on this in [*Chapter
    14*](B19682_14.xhtml#_idTextAnchor299)), is called Docker. Containers do not abstract
    the hardware level as hypervisors do. They use a specific userspace interface
    that benefits from the kernel’s techniques to isolate specific resources. By using
    Linux containers, you can replicate a default Linux system without using a different
    kernel, as you would do by using a VM.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，LXC 是最早的容器形式之一，早在 12 年前就已推出。更新的容器形式，以及改变整个容器领域并引发 DevOps 热潮的容器（更多内容请参见
    [*第14章*](B19682_14.xhtml#_idTextAnchor299)），被称为 Docker。容器不像虚拟机监控器那样抽象硬件层。它们使用特定的用户空间接口，利用内核的技术来隔离特定的资源。通过使用
    Linux 容器，你可以在不使用不同内核的情况下复制一个默认的 Linux 系统，就像使用虚拟机一样。
- en: What made LXC appealing when it first appeared were the APIs it uses for multiple
    programming languages, including Python 3, Go, Ruby, and Haskell. So, even though
    LXC is no longer that popular, it is still worth knowing. Docker has taken the
    crown and center stage in container engine usage. We will not use LXC/LXD in our
    examples, but we will still discuss it for backward compatibility purposes. As
    of the time of writing this book, there are two supported versions of LXC, version
    4.0, with support until June 2025, and version 5.0, with support until June 2027.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 LXC 首次出现时，它吸引人的地方在于它支持多种编程语言的 API，包括 Python 3、Go、Ruby 和 Haskell。因此，尽管 LXC
    现在不再那么流行，但它仍然值得了解。Docker 已经接管了容器引擎的主导地位。我们在示例中不会使用 LXC/LXD，但我们仍会讨论它以确保向后兼容。截止到本书写作时，LXC
    支持两个版本，版本 4.0 支持到 2025 年 6 月，版本 5.0 支持到 2027 年 6 月。
- en: 'According to its developers, LXC uses features to create an isolated environment
    that is as close as possible to a default Linux installation. Among the kernel
    technologies that it uses, we could bring up the most important one, which is
    the backbone of any container inside Linux: kernel **namespaces** and **cgroups**.
    Besides those, there are still chroots and security profiles for both AppArmor
    and SELinux.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据开发者的说法，LXC 使用特性来创建一个尽可能接近默认 Linux 安装的隔离环境。在它使用的内核技术中，我们可以提到最重要的技术——即 Linux
    中任何容器的骨干：内核 **命名空间** 和 **cgroups**。除此之外，还有 chroot 和针对 AppArmor 和 SELinux 的安全配置文件。
- en: Let’s now explain these basic features that Linux containers use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们解释 Linux 容器所使用的这些基本特性。
- en: Linux namespaces
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 命名空间
- en: What are **Linux namespaces**? In a nutshell, namespaces are kernel global system
    resources responsible for the isolation that containers provide. Namespaces wrap
    a global system resource inside an abstraction layer. This process fools any app
    process that is running inside the namespace into believing that the resource
    it is using is its own. A namespace provides isolation at a logical level inside
    the kernel and also provides visibility for any running processes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 **Linux 命名空间**？简而言之，命名空间是内核全局系统资源，负责容器提供的隔离。命名空间将全局系统资源包装在一个抽象层内。这个过程使得运行在命名空间中的应用进程误以为它正在使用的资源是属于它自己的。命名空间在内核内提供逻辑层级的隔离，同时也为正在运行的进程提供可见性。
- en: To better understand how namespaces work, think of any user on a Linux system
    and how it can view different system resources and processes. As a user, you can
    see the global system resources, the running processes, other users, and kernel
    modules, for example. This amount of transparency could be harmful when wanting
    to use containers as virtualized environments at the OS level. As it cannot provide
    the encapsulation and emulation level of a VM, the container engine must overcome
    this somehow, and the kernel’s low-level mechanisms of virtualization of the environment
    come in the form of namespaces and cgroups.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解命名空间的工作原理，可以想象Linux系统中的任何用户以及他们如何查看不同的系统资源和进程。作为一个用户，你可以看到全局系统资源、正在运行的进程、其他用户和内核模块等。这样的透明度在将容器用作操作系统级虚拟化环境时可能是有害的。由于容器无法提供虚拟机的封装和仿真级别，容器引擎必须以某种方式克服这一点，内核的低级虚拟化机制以命名空间和cgroups的形式存在。
- en: 'There are several types of namespaces inside the Linux kernel, and we will
    describe them briefly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中有几种类型的命名空间，下面简要描述它们：
- en: '**Mount**: They restrict visibility for available filesystem mount points within
    a single namespace so that processes from that namespace have visibility of the
    filesystem list; processes can have their own root filesystem and different private
    or shared mounts'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**：它们限制单个命名空间内可用文件系统挂载点的可见性，以便该命名空间中的进程可以看到文件系统列表；进程可以拥有自己的根文件系统和不同的私有或共享挂载。'
- en: '**Unix Time Sharing** (**UTS**): This isolates the system’s hostname and domain
    name'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix时间共享**（**UTS**）：它隔离系统的主机名和域名。'
- en: '**Interprocess Communication** (**IPC**): This allows processes to have their
    own IPC shared memory, queues, and semaphores'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）：这允许进程拥有自己的IPC共享内存、队列和信号量。'
- en: '**Process Identification**: This allows mapping of **process IDs** (**PIDs**)
    with the possibility of a process with PID 1 (the root of the process tree) to
    spin off a new tree with its own root process; processes inside a PID namespace
    only see the processes inside the same PID namespace'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程标识**：这允许将**进程ID**（**PIDs**）映射，其中PID为1的进程（进程树的根）可以分出一个新的树，具有自己的根进程；PID命名空间中的进程只能看到同一PID命名空间中的进程。'
- en: '**Network**: Abstraction at the network protocol level; processes inside a
    network namespace have a private network stack with private network interfaces,
    routing tables, sockets, and iptables rules'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：在网络协议层面的抽象；网络命名空间中的进程拥有独立的网络栈、私有网络接口、路由表、套接字和iptables规则。'
- en: '**User**: This allows mapping of UID and GID, including root UID 0 as a non-privileged
    user'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：这允许映射UID和GID，包括将UID为0的root视为非特权用户。'
- en: '**cgroup**: A cgroup namespace process can see filesystem paths relative to
    the root of the namespace'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cgroup**：cgroup命名空间中的进程可以看到相对于命名空间根的文件系统路径。'
- en: 'The namespaces can be viewed by using the `lsns` command in Linux. The following
    is an excerpt from the command’s output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Linux中的`lsns`命令查看命名空间。以下是该命令输出的摘录：
- en: '![Figure 12.2 – Using lsns to view the available namespaces](img/B19682_12_2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 使用lsns查看可用的命名空间](img/B19682_12_2.jpg)'
- en: Figure 12.2 – Using lsns to view the available namespaces
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 使用lsns查看可用的命名空间
- en: In the following section, we will break down cgroups as the second major building
    block of containers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将详细介绍cgroups，它是容器的第二个主要构建模块。
- en: Linux cgroups
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux cgroups
- en: What are cgroups? Their name comes from **control groups**, and they are kernel
    features that restrict and manage resource allocation to processes. Cgroups control
    how memory, CPU, I/O, and network are used. They provide a mechanism that determines
    specific sets of tasks that limit how many resources a process can use. They are
    based on the concept of **hierarchies**. Every child group will inherit the attributes
    of its parent group, and multiple cgroups hierarchies can exist at the same time
    in one system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是cgroups？它们的名字来源于**控制组**，是内核功能，用于限制和管理进程的资源分配。Cgroups控制内存、CPU、I/O和网络的使用。它们提供了一种机制，确定特定的任务集，限制进程可以使用的资源量。它们基于**层次结构**的概念。每个子组都会继承其父组的属性，并且一个系统中可以同时存在多个cgroups层次结构。
- en: Cgroups and namespaces combined are creating the isolation that containers are
    built upon. By using cgroups and namespaces, resources are allocated and managed
    for each container separately. Compared to VMs, containers are lightweight and
    run as isolated entities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Cgroups和命名空间的结合创造了容器所依赖的隔离。通过使用cgroups和命名空间，可以为每个容器分别分配和管理资源。与虚拟机相比，容器更轻量且以隔离实体的形式运行。
- en: As stated earlier, there are two types of containers used, LXC and Docker. As
    we have already discussed LXC, let us see in the following section what Docker
    is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用的容器有两种类型，LXC和Docker。我们已经讨论过LXC，接下来我们将介绍Docker是什么。
- en: Understanding Docker
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Docker
- en: Docker, similar to LXC/LXD, is based, among other technologies, on kernel namespaces
    and cgroups. Docker is a platform that is used for developing and shipping applications.
    The Docker platform provides the underlying infrastructure for containers to operate
    securely. Docker containers are lightweight entities that run directly on the
    host’s kernel. The platform offers features such as tools to create and manage
    isolated, containerized applications. Thus, the container is the base unit used
    for application development, testing, and distribution. When apps are production-ready
    and fit for deployment, they can be shipped as containers or as orchestrated services
    (we will discuss orchestration in [*Chapter 16*](B19682_16.xhtml#_idTextAnchor342),
    *Deploying Applications**with Kubernetes*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，类似于LXC/LXD，基于多种技术，其中包括内核命名空间和cgroups。Docker是一个用于开发和部署应用程序的平台。Docker平台为容器提供了安全运行的基础设施。Docker容器是轻量级实体，直接在主机的内核上运行。该平台提供了创建和管理隔离的容器化应用程序的工具等功能。因此，容器是应用开发、测试和分发的基本单元。当应用程序准备好投入生产并适合部署时，可以将其作为容器或编排服务进行发布（我们将在[*第16章*](B19682_16.xhtml#_idTextAnchor342)中讨论编排，*使用Kubernetes部署应用程序*）。
- en: 'In the following diagram, we will show you how the Docker architecture works:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图示中，我们将展示Docker架构如何工作：
- en: '![Figure 12.3 – Docker architecture](img/B19682_12_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – Docker架构](img/B19682_12_3.jpg)'
- en: Figure 12.3 – Docker architecture
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – Docker架构
- en: 'Let’s explain the preceding diagram. Docker uses both namespaces and cgroups
    available in the Linux kernel, and is split into two major components:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下前面的图示。Docker使用Linux内核中提供的命名空间和cgroups，并分为两个主要组件：
- en: '`runc` and `containerd` to *Cloud Native Computing Foundation* so that more
    organizations would be able to contribute to both. The following is a diagram
    showing the details of the Docker architecture, with the core components, the
    Docker engine and the container runtime, being shown in detail:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`runc`和`containerd`移交给*Cloud Native Computing Foundation*，使得更多的组织能够参与其中。以下是展示Docker架构细节的图示，核心组件——Docker引擎和容器运行时——在图中有详细展示：
- en: '![Figure 12.4 – Docker architecture details](img/B19682_12_4.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – Docker架构细节](img/B19682_12_4.jpg)'
- en: Figure 12.4 – Docker architecture details
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – Docker架构细节
- en: 'The **Docker engine**: This engine is what is split into the **dockerd** daemon,
    the **API** interface, and the **command-line interface** (**CLI**). The Docker
    engine comprises the API interface and the dockerd daemon, while the container
    runtime has two main components – the **containerd** daemon and **runc** for namespaces
    and cgroups management. Besides the components listed in the previous point, a
    number of other components are used to run and deploy Docker containers. Docker
    has a client-server architecture and the workflow involves a **host**, or server
    daemon, a **client**, and a **registry**. The host consists of images and containers
    (downloaded from the registry), and the client provides the commands needed to
    manage containers.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker引擎**：该引擎分为**dockerd**守护进程、**API**接口和**命令行接口**（**CLI**）。Docker引擎包含API接口和dockerd守护进程，而容器运行时有两个主要组件——用于命名空间和cgroups管理的**containerd**守护进程和**runc**。除了前述组件，Docker还使用许多其他组件来运行和部署Docker容器。Docker采用客户端-服务器架构，工作流程涉及一个**主机**（即服务器守护进程）、一个**客户端**和一个**注册中心**。主机包含镜像和容器（从注册中心下载），客户端提供管理容器所需的命令。'
- en: 'The workflow of these components is as follows:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些组件的工作流程如下：
- en: The dockerd daemon listens for API requests to manage services and objects (such
    as images, containers, networks, and volumes).
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: dockerd守护进程监听API请求以管理服务和对象（如镜像、容器、网络和卷）。
- en: The client is the way for users to interact with the daemon through the API.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是用户通过API与守护进程交互的方式。
- en: The registries store images, and Docker Hub is a public registry for anyone
    to use freely. In addition to this, there are private registries that can be used.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像存储库用于存储镜像，Docker Hub 是一个公共的注册中心，任何人都可以自由使用。除此之外，还有可以使用的私有注册中心。
- en: 'The following is a graphical representation of Docker’s workflow, showing the
    client component, the API, and the daemon:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是 Docker 工作流的图示，展示了客户端组件、API 和守护进程：
- en: '![Figure 12.5 – Docker workflow](img/B19682_12_5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – Docker 工作流](img/B19682_12_5.jpg)'
- en: Figure 12.5 – Docker workflow
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – Docker 工作流
- en: Docker may seem difficult, even disarming, to a beginner. All the different
    components that work together, all those new typologies, and specific workflows
    are complicated. Do you feel like you know how Docker works just after reading
    this section? Of course not. The process of learning Docker has just begun. Having
    a strong foundation on which to build your Docker knowledge is extremely important.
    This is why, in the next section, we will show you how to use Docker.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 对初学者来说可能看起来很难，甚至让人感到束手无策。所有这些相互配合的不同组件、各种新的类型以及特定的工作流程都非常复杂。你读完这一部分后就能理解
    Docker 是如何工作的了吗？当然不能。学习 Docker 的过程才刚刚开始。拥有一个坚实的基础以构建你的 Docker 知识是至关重要的。这就是为什么在接下来的部分，我们将向你展示如何使用
    Docker。
- en: Working with Docker
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker
- en: We will use Debian GNU/Linux 12 for this section’s exercises, installed on a
    VM with 2 vCPUs and 2 GB of RAM as a host. But before we start installing Docker,
    let’s go into a little detail about how Docker, as an entity, operates, to help
    us identify which version to choose for our use case.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的练习将使用安装在一台具有 2 个虚拟 CPU 和 2 GB 内存的虚拟机上的 Debian GNU/Linux 12。但在开始安装 Docker
    之前，我们先详细了解一下 Docker 作为一个实体是如何运作的，以帮助我们确定选择哪个版本适合我们的使用场景。
- en: Which Docker version to choose?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择哪个 Docker 版本？
- en: In order for the business to be viable, the corporation behind Docker (the Docker
    corporation) offers a series of products, all revolving around their primary product,
    Docker. In the past, it had two different products available, the Docker **Community
    Edition** (**CE**) and the Docker **Enterprise Edition** (**EE**). Out of these
    two, only the EE version was responsible for the revenue of Docker.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保业务的可行性，Docker 背后的公司（即 Docker 公司）提供了一系列围绕其主要产品 Docker 的产品。过去，它有两个不同的产品版本，分别是
    Docker **Community Edition**（**CE**）和 Docker **Enterprise Edition**（**EE**）。在这两者中，只有
    EE 版本负责 Docker 的收入。
- en: 'Recently, the portfolio evolved to different products and offerings, such as
    **Docker Personal**, **Docker Pro**, **Docker Team**, and **Docker Business**.
    Among those, only Docker Personal is free to use; the other three products are
    subscription-based. Docker Personal is suitable for individual developers, education,
    and open source communities, but has some limitations (which can be seen here:
    [https://www.docker.com/products/personal/](https://www.docker.com/products/personal/)).
    Using Docker Personal implies the existence of a Docker user account, and it includes
    Docker Desktop for Linux (and all other major platforms) and Docker Engine for
    servers.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Docker 产品组合发展出了不同的产品和服务，如**Docker Personal**、**Docker Pro**、**Docker Team**
    和 **Docker Business**。其中，只有 Docker Personal 可以免费使用；其他三个产品则是基于订阅的。Docker Personal
    适合个人开发者、教育和开源社区使用，但有一些限制（可以在这里查看：[https://www.docker.com/products/personal/](https://www.docker.com/products/personal/)）。使用
    Docker Personal 意味着需要拥有一个 Docker 用户账户，并且它包括适用于 Linux（以及所有其他主要平台）的 Docker Desktop
    和服务器端的 Docker Engine。
- en: On the server side, Docker Engine is available for `.deb` and `.rpm` package
    formats and is available for Ubuntu, Debian, Fedora, and CentOS. For our examples,
    we will use Docker Personal. We will show you how to install Docker in the next
    section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，Docker Engine 提供了 `.deb` 和 `.rpm` 包格式，适用于 Ubuntu、Debian、Fedora 和 CentOS。在我们的示例中，我们将使用
    Docker Personal。在接下来的部分，我们将展示如何安装 Docker。
- en: Installing Docker
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'Depending on the version of your preferred Linux distribution that you choose,
    the package available inside the official repository may be out of date. Nevertheless,
    you have two options: one is to use the official package from our Linux distribution’s
    own repository, and the other is to download the latest available version from
    the official Docker website.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的 Linux 发行版版本，官方仓库中的包可能会过时。不过，你有两个选择：一个是使用我们 Linux 发行版自带的官方包，另一个是从 Docker
    官方网站下载最新版本。
- en: As we are using a fresh system, with no prior Docker installation, we will not
    need to worry about older versions of the software and possible incompatibilities
    with the new versions. We will use Docker’s `apt` repository, which will ensure
    that our package versions will always be up to date. Remember that we are using
    a Debian host.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是全新的系统，且没有之前安装 Docker，因此无需担心旧版本软件和新版本可能存在的不兼容问题。我们将使用 Docker 的 `apt`
    仓库，这样可以确保我们的软件包版本始终是最新的。请记住，我们使用的是 Debian 主机。
- en: 'The procedure to install Docker is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 的过程如下：
- en: 'First, add the requisite certificates for the Docker repository using the following
    commands:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令添加 Docker 仓库所需的证书：
- en: '[PRE0]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to use the official Docker repository, you will need to add the Docker
    GPG key. For this, use the following commands:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用官方 Docker 仓库，您需要添加 Docker 的 GPG 密钥。为此，使用以下命令：
- en: '[PRE1]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set up the repository needed to install the version of Docker we want:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置安装我们想要的 Docker 版本所需的仓库：
- en: '[PRE2]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next logical step is to update the repository list. When you do this, you
    should see the official Docker repository. Use the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新仓库列表。更新后，您应该看到官方 Docker 仓库。使用以下命令：
- en: '[PRE3]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Install the Docker packages. In our case, we will install the latest packages
    available using the following command:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker 软件包。对于我们的情况，我们将使用以下命令安装可用的最新软件包：
- en: '[PRE4]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify that you installed the packages from the official Docker repository
    and not the ones from the Debian repositories, run the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证您是否从官方 Docker 仓库而非 Debian 仓库安装了软件包，请运行以下命令：
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the output shows the source from the [docker.com](http://docker.com) website,
    this means that the source repository is the official Docker one:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果输出显示源来自 [docker.com](http://docker.com) 网站，这意味着源仓库是官方的 Docker 仓库：
- en: '![Figure 12.6 – Verifying the source repository](img/B19682_12_6.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 验证源仓库](img/B19682_12_6.jpg)'
- en: Figure 12.6 – Verifying the source repository
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 验证源仓库
- en: 'Check the status of the Docker daemon. It should be started right after installation:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Docker 守护进程的状态。它应该在安装完成后立即启动：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: tail /etc/group
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: tail /etc/group
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: sudo usermod -aG docker ${USER}
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo usermod -aG docker ${USER}
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After you add the user, log out and back in again and check whether you were
    added to the new group with the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用户后，请注销并重新登录，然后使用以下命令检查您是否已被添加到新组中：
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You have completed the installation of Docker. Now you can enable the Docker
    daemon to begin at system startup:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已完成 Docker 的安装。现在可以启用 Docker 守护进程，使其在系统启动时自动启动：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Installing Docker is only the first step. Now let’s explore what we can do with
    it. In the following section, you will learn about the commands available in Docker.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Docker 只是第一步。接下来让我们探索一下我们可以用它做什么。在接下来的部分，您将了解 Docker 中可用的命令。
- en: Using some Docker commands
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用一些 Docker 命令
- en: 'Working with Docker means using its CLI. It has a significant number of sub-commands
    available. If you want to see them all, you should run the `docker -–help` command.
    There are two main command groups shown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 就是要使用它的命令行接口（CLI）。它有大量可用的子命令。如果您想查看所有命令，应该运行`docker --help`命令。显示的命令分为两大类：
- en: The first group shows the management commands
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一组显示了管理命令
- en: The second group shows the regular commands
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二组显示了常规命令
- en: We will not discuss all the commands in this section. We will only focus on
    the ones that you will need to get started with Docker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中我们不会讨论所有命令，我们将只关注一些您入门 Docker 所需的命令。
- en: 'Before learning anything about the commands, let’s first perform a test to
    see whether the installation is working. We will use the `docker run` command
    to check whether we can access Docker Hub and run containers. Our testing command
    will be the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习任何命令之前，我们先做一个测试，看看安装是否成功。我们将使用 `docker run` 命令检查是否能够访问 Docker Hub 并运行容器。我们的测试命令如下：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This command downloads an image from Docker Hub and runs it as a container.
    The following is a screenshot of the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从 Docker Hub 下载一个镜像并将其作为容器运行。以下是输出的截图：
- en: '![Figure 12.7 – Running the first docker run command](img/B19682_12_7.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – 运行第一个 docker run 命令](img/B19682_12_7.jpg)'
- en: Figure 12.7 – Running the first docker run command
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – 运行第一个 `docker run` 命令
- en: The preceding screenshot is self-explanatory and a nice touch from the Docker
    team. It explains what the command did in the background using clear and easy-to-understand
    language. By running the `docker run` command, you both learn about the workflow
    and the success of the installation. Also, it is one of the basic Docker commands
    that you will use relatively often.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图不言自明，这是 Docker 团队做得非常好的一个方面。它使用清晰易懂的语言解释了命令在后台执行的操作。通过运行 `docker run` 命令，你不仅了解了工作流，还能验证安装是否成功。同时，这也是你将经常使用的基本
    Docker 命令之一。
- en: 'Let’s now dig deeper and search for other images available on Docker Hub. Let’s
    search for an Ubuntu image to run containers on. To search for the image, we will
    use the `docker` `search` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地挖掘，搜索 Docker Hub 上可用的其他镜像。我们来搜索一个可以用来运行容器的 Ubuntu 镜像。为了搜索该镜像，我们将使用
    `docker` `search` 命令：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the command should list all the Ubuntu images available inside
    Docker Hub:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令的输出应列出 Docker Hub 中所有可用的 Ubuntu 镜像：
- en: '![Figure 12.8 – Searching for the Ubuntu image](img/B19682_12_8.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 搜索 Ubuntu 镜像](img/B19682_12_8.jpg)'
- en: Figure 12.8 – Searching for the Ubuntu image
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 搜索 Ubuntu 镜像
- en: 'As you can see, the output has five columns:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输出有五列：
- en: '**NAME**: The first column shows the image’s name'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAME**：第一列显示镜像的名称'
- en: '**DESCRIPTION**: The second column shows the description, which is a short
    text providing information about a specific image'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DESCRIPTION**：第二列显示镜像的描述，即简短的文本信息，介绍特定镜像的内容'
- en: '**STARS**: The third column shows the number of stars it has (representing
    popularity based on user opinion)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**STARS**：第三列显示该镜像的星级数（基于用户评价的流行程度）'
- en: '**OFFICIAL**: The fourth column shows whether that image is an official one
    supported by the company behind the distribution/software'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OFFICIAL**：第四列显示该镜像是否为公司支持的官方镜像'
- en: '**AUTOMATED**: The fifth column shows whether the image has automated scripts'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AUTOMATED**：第五列显示该镜像是否包含自动化脚本'
- en: 'Once you find the image you are looking for, you can download it onto your
    system using the `docker pull` command. Let us download the first image from the
    list shown in the preceding screenshot, the one called `ubuntu`. We will use the
    following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到你需要的镜像，可以使用 `docker pull` 命令将其下载到你的系统上。让我们从前面截图中显示的列表中下载第一个镜像，即 `ubuntu`。我们将使用以下命令：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this command, the `ubuntu` image is downloaded locally onto your computer.
    Now, containers can be run using this image. To list the images that are already
    available on your computer, run the `docker` `images` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，`ubuntu` 镜像将被下载到你本地计算机上。现在，可以使用此镜像来运行容器。要列出已经在计算机上可用的镜像，可以运行 `docker`
    `images` 命令：
- en: '![Figure 12.9 – Running the docker images command](img/B19682_12_9.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 运行 docker images 命令](img/B19682_12_9.jpg)'
- en: Figure 12.9 – Running the docker images command
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 运行 docker images 命令
- en: Please note the small size of the Ubuntu Docker image. You may be wondering
    why it is so small. This is because Docker images contain only the base and minimum
    packages needed to run. This makes the container running on the image extremely
    efficient in resource usage.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 Ubuntu Docker 镜像的体积较小。你可能会想，为什么它这么小？这是因为 Docker 镜像仅包含运行所需的基础和最小软件包。这使得基于该镜像运行的容器在资源使用上非常高效。
- en: The few commands we showed you in this section are the most basic ones needed
    to start using Docker. Now that you know how to download an image, let’s show
    you how to manage Docker containers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的几个命令是使用 Docker 所需的最基础命令。现在你已经知道如何下载镜像，让我们来看看如何管理 Docker 容器。
- en: Managing Docker containers
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Docker 容器
- en: In this section, we will learn how to run, list, start, stop, and remove Docker
    containers, and also how to manage networking.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何运行、列出、启动、停止和删除 Docker 容器，并且如何管理网络。
- en: Running containers
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行容器
- en: 'We will use the Ubuntu image that we just downloaded. To run it, we will use
    the `docker run` command with two arguments, `-i` for interactive output and `-t`
    for starting a pseudo TTY, which will give us interactive access to the shell:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用刚刚下载的 Ubuntu 镜像。为了运行它，我们将使用带有两个参数的 `docker run` 命令，`-i` 表示交互式输出，`-t` 表示启动伪
    TTY，这将为我们提供交互式访问 shell：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will notice that your command prompt will change. Now it will contain the
    container ID. The user, by default, is the root user. Basically, you are now inside
    an Ubuntu image, so you can use it exactly as you would use any Ubuntu command
    line. You can update the repository, install the requisite applications, remove
    unnecessary apps, and so on. Any changes that you make to the container image
    stay inside the container. To exit the container, simply type `exit`. Now, we
    will show you how to list containers, but before we do that, we should ask you
    not to close the terminal in which the Ubuntu-based container is currently running.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到命令提示符会发生变化。现在它会包含容器的ID。默认情况下，用户是root用户。基本上，你现在处于一个Ubuntu镜像中，因此你可以像使用任何Ubuntu命令行一样使用它。你可以更新仓库，安装所需的应用程序，删除不必要的应用程序，等等。你对容器镜像所做的任何更改都会保留在容器内部。要退出容器，只需输入`exit`。现在，我们将向你展示如何列出容器，但在此之前，我们建议你不要关闭当前运行Ubuntu容器的终端。
- en: Listing containers
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出容器
- en: You can open a new terminal on your system and check to see how many Docker
    containers are actively running, using the `docker` `ps` command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在系统中打开一个新的终端，并使用`docker` `ps`命令检查当前活跃的Docker容器数量。
- en: In the command’s output, you will see the ID of the container that is running
    in the other terminal. There are also details about the command that runs inside
    the container and the creation time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的输出中，你将看到正在另一个终端中运行的容器的ID。还会有关于容器内运行的命令和创建时间的详细信息。
- en: 'There are a couple of arguments that you can use with the `docker` `ps` command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` `ps`命令有几个参数可以使用：'
- en: If you want to see all active and inactive containers, use the `docker ps -``a`
    command
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想查看所有活动和非活动的容器，可以使用`docker ps -a`命令。
- en: If you want to see the latest created container, use the `docker ps -``l` command
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想查看最近创建的容器，可以使用`docker ps -l`命令。
- en: 'The following is the output of all three variants of the `docker` `ps` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是三种变体的`docker` `ps`命令的输出：
- en: '![Figure 12.10 – Listing containers with the docker ps command](img/B19682_12_10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 使用docker ps命令列出容器](img/B19682_12_10.jpg)'
- en: Figure 12.10 – Listing containers with the docker ps command
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 使用docker ps命令列出容器
- en: In the output, you will also see names assigned to containers, such as `amazing_hopper`
    or `recursing_murdock`. Those are random names automatically given to containers
    by the daemon. Now, we will learn how to start, stop, and remove running containers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你还会看到容器的名称，如`amazing_hopper`或`recursing_murdock`。这些是守护进程自动分配给容器的随机名称。现在，我们将学习如何启动、停止和删除正在运行的容器。
- en: Starting, stopping, and removing running containers
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动、停止和删除运行中的容器
- en: When managing containers, such as starting and stopping, you can refer to them
    by using the container ID or the name assigned by Docker. Let’s now show you how
    to start, stop, and remove a container.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理容器时（例如启动和停止容器），你可以通过容器的ID或Docker分配的名称来引用它们。现在，让我们展示如何启动、停止和删除容器。
- en: 'To start a Docker container, use the `docker start` command, followed by the
    name or ID of the container. Here is an example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动Docker容器，使用`docker start`命令，然后输入容器的名称或ID。以下是一个例子：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To stop a container, use the `docker stop` command, followed by the name of
    the ID of the container. Here is an example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止容器，使用`docker stop`命令，然后输入容器的名称或ID。以下是一个例子：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, the Ubuntu container, named `amazing_hopper`, is already running,
    so the `start` command will not do anything. But the `stop` command will stop
    the container. After stopping, if you run the `docker ps` command, there will
    be no more containers in the list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，名为`amazing_hopper`的Ubuntu容器已经在运行，因此`start`命令不会做任何事情。但`stop`命令会停止容器。停止后，如果你运行`docker
    ps`命令，容器列表中将不再显示任何容器。
- en: 'Let’s take a look at the output of both these commands:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个命令的输出：
- en: '![Figure 12.11 – Starting and stopping containers](img/B19682_12_11.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 启动和停止容器](img/B19682_12_11.jpg)'
- en: Figure 12.11 – Starting and stopping containers
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 启动和停止容器
- en: 'To remove a container, you can use the `docker rm` command. For example, if
    we would like to remove the initial `hello-world` container (also called `recursing_murdock`
    in our case), we will use the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除一个容器，可以使用`docker rm`命令。例如，如果我们想删除初始的`hello-world`容器（在我们的案例中也叫做`recursing_murdock`），我们将使用以下命令：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once you remove the container, any changes that you made and you did not save
    (commit) will be lost. Let us show you how to commit changes you made in a container
    to the Docker image. This means that you will save a specific state of a container
    as a new Docker image.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦删除容器，所有未保存（提交）的更改将会丢失。让我们向你展示如何将容器中所做的更改提交到 Docker 镜像。这意味着你将保存容器的特定状态为新的 Docker
    镜像。
- en: Important note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please take into consideration that removing a container will not erase the
    existing image downloaded from Docker Hub.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，删除容器不会删除从 Docker Hub 下载的现有镜像。
- en: Let’s say that you would like to develop, test, and deploy a Python application
    on Ubuntu. The default Docker image of Ubuntu doesn’t have Python installed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在 Ubuntu 上开发、测试和部署一个 Python 应用程序。Ubuntu 的默认 Docker 镜像没有安装 Python。
- en: Next, we will show you how to troubleshoot Docker networking and how to commit
    a new image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向你展示如何排查 Docker 网络问题以及如何提交新镜像。
- en: Docker networking and committing a new image
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 网络与提交新镜像
- en: 'The scenario for this section’s exercise is that you would like to modify the
    existing Ubuntu image by installing the Python packages that you need for your
    application. To do this, we follow these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节练习的场景是，你希望通过安装你应用程序所需的 Python 包来修改现有的 Ubuntu 镜像。为此，我们按以下步骤操作：
- en: 'First, we start the container and check to see whether Python is installed
    or not:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们启动容器并检查是否安装了 Python：
- en: '![Figure 12.12 – Checking for Python inside the container](img/B19682_12_12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 在容器内检查 Python](img/B19682_12_12.jpg)'
- en: Figure 12.12 – Checking for Python inside the container
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 在容器内检查 Python
- en: 'We check for both Python 2 and Python 3, but neither version is installed on
    the image. As we want to use the latest version of the programming language, we
    will use the following command to install Python 3 support (running as root):'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查了 Python 2 和 Python 3，但镜像中都没有安装任何版本。由于我们想使用最新版本的编程语言，我们将使用以下命令来安装 Python
    3 支持（以 root 身份运行）：
- en: '[PRE18]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In doing so, you will get in contact with Docker networking for the first time,
    as the container needs to reach out to the official Ubuntu repositories in order
    to download and install the packages you need. It might be the case for you, too,
    as it was in ours, that when trying to install Python, you will be greeted with
    an error, such as the one shown in the following screenshot:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做，你将第一次接触 Docker 网络，因为容器需要连接到官方 Ubuntu 软件源，以便下载和安装你所需要的包。对你来说，也可能出现与我们类似的情况：当尝试安装
    Python 时，你会遇到如下截图中的错误：
- en: '![Figure 12.13 – Error while trying to install Python](img/B19682_12_13.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 尝试安装 Python 时的错误](img/B19682_12_13.jpg)'
- en: Figure 12.13 – Error while trying to install Python
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 尝试安装 Python 时的错误
- en: 'This error shows that the package named `python3` cannot be located, meaning
    that our container does not have access to the repositories. A quick thought would
    be that there is something wrong with Docker’s networking. In order to troubleshoot
    this, we have a useful command called `docker network`. It is used to manage network
    connections for the Docker container. In our case, the fault for the error message
    could be a missing connection between the container and the network. In this case,
    we can investigate first with the `docker network` `ls` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误显示包名为 `python3` 的软件包无法找到，这意味着我们的容器无法访问到软件源。一个快速的想法是可能 Docker 的网络出现了问题。为了解决这个问题，我们有一个有用的命令叫做
    `docker network`。它用于管理 Docker 容器的网络连接。在我们的例子中，错误消息的原因可能是容器与网络之间缺少连接。在这种情况下，我们可以首先使用
    `docker network` 的 `ls` 命令进行排查：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will show all the active networks that are used by Docker. In
    our case, when running the preceding command, we can see that there are three
    available networks for Docker, each with a network ID and a name assigned to it:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示 Docker 正在使用的所有活动网络。在我们的例子中，当运行前述命令时，我们可以看到 Docker 有三个可用的网络，每个网络都有一个网络
    ID 和分配给它的名称：
- en: '![Figure 12.14 – Showing the available networks](img/B19682_12_14.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 显示可用的网络](img/B19682_12_14.jpg)'
- en: Figure 12.14 – Showing the available networks
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 显示可用的网络
- en: Important note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The issue described in this example may not appear in your case. However, it
    is a good exercise to show you how to use the `docker network` command in action.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中描述的问题可能不会出现在你的情况中。然而，这是一个很好的练习，可以向你展示如何在实际操作中使用 `docker network` 命令。
- en: 'Before starting to solve our issue, let us see once again what the containers
    are that are running and what their given names are. As we started the new container
    once again, it should have another ID and name. We will use the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始解决问题之前，让我们再一次查看正在运行的容器以及它们的名称。由于我们重新启动了新的容器，它应该有另一个 ID 和名称。我们将使用以下命令：
- en: '[PRE20]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: docker network connect bridge [container_name]
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker network connect bridge [container_name]
- en: '[PRE21]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Running the command will not show any kind of output, but we will test the
    result by running the command to update the repositories inside the container
    to see that it works:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行该命令不会显示任何输出，但我们将通过运行该命令来更新容器内的仓库，以验证它是否有效：
- en: '[PRE22]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the command shows that the repositories are accessible from our
    container, meaning that we can now install Python. The following screenshot shows
    an excerpt of the output:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令的输出显示，仓库可以从我们的容器访问，这意味着我们现在可以安装 Python。以下截图显示了输出的摘录：
- en: '![Figure 12.15 – Proof that the network connection is working](img/B19682_12_15.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 网络连接正常工作的证明](img/B19682_12_15.jpg)'
- en: Figure 12.15 – Proof that the network connection is working
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 网络连接正常工作的证明
- en: By connecting a container to a network, it will be able to communicate with
    other containers on the same network too.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将容器连接到网络，它将能够与同一网络上的其他容器进行通信。
- en: 'Now, before going further with our Python installation, we would like to show
    you that there is a command that we can use to automatically connect a container
    to a network when starting the container:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在进一步进行 Python 安装之前，我们想向您展示一个命令，您可以使用它在启动容器时自动将容器连接到网络：
- en: '[PRE23]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let us proceed with our initial Python installation. We can once again
    run the following command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行 Python 的初步安装。我们可以再次运行以下命令：
- en: '[PRE24]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This time, the command will not give any errors and it will proceed with the
    installation. The following is an excerpt from the command’s output:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，命令不会再出现任何错误，它将继续进行安装。以下是命令输出的摘录：
- en: '![Figure 12.16 – Installing Python packages inside a Docker container](img/B19682_12_16.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – 在 Docker 容器内安装 Python 包](img/B19682_12_16.jpg)'
- en: Figure 12.16 – Installing Python packages inside a Docker container
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – 在 Docker 容器内安装 Python 包
- en: 'Now, with Python 3 installed and the necessary modifications made to the image
    used inside the container, we can save the instance of the container to a new
    Docker image. For this, we will use the following command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，安装了 Python 3 并对容器内使用的镜像进行了必要的修改后，我们可以将容器的实例保存为一个新的 Docker 镜像。为此，我们将使用以下命令：
- en: '[PRE25]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 12.17 – A new image committed locally](img/B19682_12_17.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – 本地提交的新图像](img/B19682_12_17.jpg)'
- en: Figure 12.17 – A new image committed locally
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – 本地提交的新图像
- en: As shown in the preceding screenshot, we first used the `docker ps` command
    to see the ID of the container we are running, then we used the `docker commit`
    command (with the options described earlier) to save the new image locally. Notice
    the increased size of the image we just saved. Installing Python 3 more than doubled
    the size of the initial Ubuntu image. The last command used was `docker images`,
    to see the existing images, including the one we just created (`ubuntu-python3`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们首先使用 `docker ps` 命令查看正在运行的容器的 ID，然后使用 `docker commit` 命令（配合前述选项）将新镜像保存在本地。请注意，我们刚保存的镜像大小有所增加。安装
    Python 3 使得最初的 Ubuntu 镜像大小增加了一倍多。最后使用的命令是 `docker images`，查看现有镜像，包括我们刚创建的镜像（`ubuntu-python3`）。
- en: By now, you have learned how to use extremely basic Docker commands for opening,
    running, and saving containers. In the next section, we will introduce you to
    Dockerfiles and the process of building container images.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经学会了如何使用非常基本的 Docker 命令来打开、运行和保存容器。在下一节中，我们将向您介绍 Dockerfile 及构建容器镜像的过程。
- en: Working with Dockerfiles
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dockerfile
- en: 'Before starting to work with Dockerfiles, let’s see what a Dockerfile is. It
    is a text file that consists of instructions defined by the user for Docker to
    execute, and respecting some basic structure, such as the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Dockerfile 之前，让我们看看什么是 Dockerfile。它是一个文本文件，其中包含用户为 Docker 执行的指令，并遵循一些基本结构，如下所示：
- en: '[PRE26]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Dockerfile is mainly used for creating new container images. This file
    is used by Docker to automatically build images based on the information the user
    provides inside the file. There are some keywords that define a Dockerfile. Those
    keywords, which are referred to as instructions, are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 主要用于创建新的容器镜像。Docker 会根据用户在文件中提供的信息自动构建镜像。Dockerfile 中有一些定义关键字，这些关键字被称为指令，如下所示：
- en: '`FROM`: This must be the first instruction inside a Dockerfile as it tells
    Docker what the image is that you build upon'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：此指令必须是 Dockerfile 中的第一个指令，因为它告诉 Docker 你基于哪个镜像来构建。'
- en: '`LABEL`: This instruction adds some more information, such as a description,
    or anything that could help describe the new image you are creating; the use of
    such instructions needs to be limited'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`：此指令添加更多信息，如描述或其他能够帮助描述你创建的新镜像的内容；此类指令的使用应加以限制。'
- en: '`RUN`: This is the instruction that offers direct interaction with the image,
    the place where commands or scripts to be run inside the image are written'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：这是与镜像进行直接交互的指令，编写在镜像内部运行的命令或脚本的位置。'
- en: '`ADD`: This instruction is used to transfer files inside the image; it copies
    files or directories to the filesystem of the image'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：此指令用于将文件传输到镜像内部；它将文件或目录复制到镜像的文件系统中。'
- en: '`COPY`: This instruction is similar to `ADD`, as it is also used to copy files
    or directories from one source to the image’s filesystem'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：此指令类似于 `ADD`，也用于将文件或目录从源位置复制到镜像的文件系统中。'
- en: '`CMD`: This instruction can occur only once in a Dockerfile, as it provides
    defaults for an image that is executed'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：此指令在 Dockerfile 中只能出现一次，因为它为执行镜像时提供默认设置。'
- en: '`USER`: This instruction is used to set a username that will be used when a
    command is executed; it can be used on the `RUN` or `CMD` instructions'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`：此指令用于设置在执行命令时所使用的用户名；它可以在 `RUN` 或 `CMD` 指令中使用。'
- en: '`WORKDIR`: This instruction will set the default working directory for other
    instructions inside a Dockerfile, such as `RUN`, `CMD`, `COPY`, `ADD`, or `ENTRYPOINT`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：此指令将为 Dockerfile 中的其他指令（如`RUN`、`CMD`、`COPY`、`ADD` 或 `ENTRYPOINT`）设置默认工作目录。'
- en: '`ENTRYPOINT`: This instruction is used to configure containers that will run
    as executables'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`：此指令用于配置作为可执行文件运行的容器。'
- en: The instructions listed here are just the ones that are usually used in a Dockerfile,
    but they do not represent all the instructions available. You can visit [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    for a complete listing of all the instructions available for a Dockerfile. In
    the next section, we will show you how to build a container image using a Dockerfile.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的指令只是 Dockerfile 中通常使用的指令，并不代表所有可用的指令。你可以访问 [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
    获取所有可用 Dockerfile 指令的完整列表。在下一节中，我们将展示如何使用 Dockerfile 构建容器镜像。
- en: Building container images from Dockerfiles
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Dockerfile 构建容器镜像
- en: 'In this section, we will create a Dockerfile that will be used for building
    a new Docker container image. Let us present the scenario on which our exercise
    is built. Similar to the exercise used in the *Docker networking and committing
    a new image* section, we will prepare an image for the Python programming environment.
    In order to create the new Docker image, we will first need to create the Dockerfile.
    The following are the steps to take:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个用于构建新 Docker 容器镜像的 Dockerfile。让我们展示一下构建此练习的场景。与 *Docker 网络和提交新镜像*
    部分中的练习类似，我们将为 Python 编程环境准备一个镜像。为了创建新的 Docker 镜像，我们首先需要创建 Dockerfile。以下是操作步骤：
- en: 'Create a new directory inside your home directory using the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在主目录内创建一个新目录：
- en: '[PRE27]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new file inside the new directory:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录内创建一个新文件：
- en: '[PRE28]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![Figure 12.18 – Creating the Dockerfile](img/B19682_12_18.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.18 – 创建 Dockerfile](img/B19682_12_18.jpg)'
- en: Figure 12.18 – Creating the Dockerfile
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – 创建 Dockerfile
- en: 'Now that the Dockerfile is created, we will run the `docker build` command
    to create the new Docker image. The command we used is as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在 Dockerfile 已创建，我们将运行 `docker build` 命令来创建新的 Docker 镜像。我们使用的命令如下：
- en: '[PRE29]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Figure 12.19 – Building a new custom image from a Dockerfile](img/B19682_12_19.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.19 – 从 Dockerfile 构建新自定义镜像](img/B19682_12_19.jpg)'
- en: Figure 12.19 – Building a new custom image from a Dockerfile
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19 – 从 Dockerfile 构建新自定义镜像
- en: We can verify if the image was created by using the `docker images` command.
    As shown in the preceding screenshot, the new `pydeb` image was successfully created.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `docker images` 命令验证镜像是否已创建。正如前面的截图所示，新的 `pydeb` 镜像已成功创建。
- en: 'We can use the new image and create a new container with the following command:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用新的镜像并通过以下命令创建一个新的容器：
- en: '[PRE30]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To verify the container running, open a new terminal window and run the `docker
    ps` command, as shown in the following screenshot:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证容器是否在运行，打开一个新的终端窗口并运行 `docker ps` 命令，如下所示：
- en: '![Figure 12.20 – New container based on our custom image](img/B19682_12_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.20 – 基于我们自定义镜像的新容器](img/B19682_12_20.jpg)'
- en: Figure 12.20 – New container based on our custom image
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.20 – 基于我们自定义镜像的新容器
- en: By now, you already know enough about Docker to feel comfortable using it in
    production. In the next section, we will show you how to use Docker to deploy
    a very basic application. We will make it so simple that the app to deploy will
    be a basic static presentation website.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经对 Docker 有了足够的了解，足以在生产环境中自如地使用它。在接下来的章节中，我们将向你展示如何使用 Docker 部署一个非常基础的应用程序。我们将它做得非常简单，部署的应用将是一个基础的静态展示网站。
- en: Deploying a containerized application with Docker
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 部署容器化应用程序
- en: So far, we have shown you how to use Docker and how to manage containers. Docker
    is so much more than that, but this is enough to get you started and make you
    want to learn more. Docker is a great tool for developers as it offers a streamlined
    way to deploy applications by removing the necessity to replicate development
    environments. In the next section, we will show you how to deploy a simple website
    using Docker.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向你展示了如何使用 Docker 以及如何管理容器。Docker 的功能远不止这些，但这些足以让你入门，并激发你进一步学习的兴趣。Docker
    对开发者来说是一个极好的工具，因为它提供了一种简化的方式来部署应用程序，省去了复制开发环境的必要。在接下来的章节中，我们将展示如何使用 Docker 部署一个简单的网站。
- en: Deploying a website using Docker
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker 部署网站
- en: 'To deploy a website using Docker, follow these steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker 部署网站，请按照以下步骤操作：
- en: 'We will use a free website template randomly downloaded from the internet (the
    download link is [https://www.free-css.com/free-css-templates/page262/focus)](https://www.free-css.com/free-css-templates/page262/focus)).
    We will copy the download location from the website and download the file inside
    our home directory using the `wget` utility:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个从互联网上随机下载的免费网页模板（下载链接是 [https://www.free-css.com/free-css-templates/page262/focus)](https://www.free-css.com/free-css-templates/page262/focus)）。我们将从网站复制下载位置，并使用
    `wget` 工具将文件下载到我们的主目录中：
- en: '[PRE31]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'docker_webapp inside the ~/my_docker_images directory created in the previous
    section, and move the extracted file inside of it. Therefore, the new location
    in our case will be the following:'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 docker_webapp 放入前一章节中创建的 ~/my_docker_images 目录中，并将提取的文件移动到其中。因此，在我们的案例中，新的位置将是：
- en: '[PRE32]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![Figure 12.21 – Contents of a new Dockerfile](img/B19682_12_21.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.21 – 新 Dockerfile 的内容](img/B19682_12_21.jpg)'
- en: Figure 12.21 – Contents of a new Dockerfile
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.21 – 新 Dockerfile 的内容
- en: 'The file is simple and has only two lines:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 文件很简单，只有两行：
- en: The first line, using the `FROM` keyword, specifies the base image that we will
    use, which will be the official NGINX image available on Docker Hub. As you will
    see in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), NGINX is a widely used
    type of web server.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行，使用 `FROM` 关键字，指定了我们将使用的基础镜像，它将是 Docker Hub 上提供的官方 NGINX 镜像。正如你将在 [*第 13
    章*](B19682_13.xhtml#_idTextAnchor276) 中看到的那样，NGINX 是一种广泛使用的网页服务器类型。
- en: The second line, using the `COPY` keyword, specifies the location where the
    contents of our present working directory will be copied inside the new container.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行，使用 `COPY` 关键字，指定了当前工作目录中的内容将被复制到新容器中的位置。
- en: 'The following action builds the Docker image using the `docker` `build` command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下操作使用 `docker` `build` 命令构建 Docker 镜像：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The new image was created, so we can now check for it using the `docker images`
    command. In our case, the output is as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的镜像已创建，因此我们现在可以使用 `docker images` 命令检查它。在我们的情况下，输出如下：
- en: '![Figure 12.22 – The new webapp Docker image was created](img/B19682_12_22.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.22 – 新的 webapp Docker 镜像已创建](img/B19682_12_22.jpg)'
- en: Figure 12.22 – The new webapp Docker image was created
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.22 – 新的 webapp Docker 镜像已创建
- en: 'As the output shows, the new image called `webapp` was created, and we can
    start a new container using it. As we will need to access the container from the
    outside, we will need to open specific ports, and we will do that using the `-p`
    parameter inside the `docker run` command. We can either specify a single port
    or a range of ports. When specifying ports, we will give the ports for the container
    and for the host, too. We will use the `-d` parameter to detach the container
    and run it in the background. The command is as follows:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如输出所示，新的镜像`webapp`已被创建，我们可以使用它启动一个新的容器。由于我们需要从外部访问该容器，因此我们需要打开特定的端口，这可以通过在`docker
    run`命令中使用`-p`参数来实现。我们可以指定单个端口或端口范围。在指定端口时，我们将同时为容器和主机指定端口。我们将使用`-d`参数来分离容器并在后台运行它。命令如下：
- en: '[PRE35]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 12.23 – The output of the docker run command](img/B19682_12_23.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23 – `docker run`命令的输出](img/B19682_12_23.jpg)'
- en: Figure 12.23 – The output of the docker run command
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.23 – `docker run`命令的输出
- en: We are exposing host port `8080` to port `80` on the container. We could have
    used both ports `80`, but on the host, it might be occupied by other services.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主机端口`8080`暴露到容器的端口`80`。我们本可以使用`80`端口，但在主机上，这个端口可能被其他服务占用。
- en: 'You can now access the new containerized application by going to your web browser
    and typing the local IP address and port `8080` into the address bar. As we are
    using a VM and not the host, we will point to the VM’s IP address, in our case
    `192.168.122.48`, followed by the `8080` port. In the next screenshot, you will
    see our Docker-deployed website:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以通过访问网页浏览器并在地址栏中输入本地IP地址和端口`8080`来访问新的容器化应用。由于我们使用的是虚拟机而不是主机，我们将指向虚拟机的IP地址，在我们的案例中是`192.168.122.48`，后面跟着`8080`端口。在下一个截图中，你将看到我们通过Docker部署的网站：
- en: "![Figure 12.24 – Running the \uFEFFweb app in our web browser](img/B19682_12_24.jpg)"
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.24 – 在我们的网页浏览器中运行Web应用](img/B19682_12_24.jpg)'
- en: Figure 12.24 – Running the web app in our web browser
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.24 – 在我们的网页浏览器中运行Web应用
- en: As you can see in the preceding image, the website is accessible from localhost.
    For deploying a website on a virtual private server, please visit [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的图片中看到的，网站可以通过localhost访问。要在虚拟私人服务器上部署网站，请访问[*第13章*](B19682_13.xhtml#_idTextAnchor276)。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we emphasized the importance of containerization. We showed
    you what containers are, how they work, and why they are so important. Containers
    are the foundation of the modern DevOps revolution, and you are now ready to use
    them. We also taught you about Docker, the basic commands for sleek use. You are
    now ready to start the cloud journey. Virtualization and container technologies
    are at the heart of cloud and server technologies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了容器化的重要性。我们向你展示了容器是什么，它们如何工作，以及它们为什么如此重要。容器是现代DevOps革命的基础，而你现在已经准备好使用它们了。我们还向你介绍了Docker及其基本命令，以便你能高效地使用它。现在，你已经准备好开始云计算之旅。虚拟化和容器技术是云计算和服务器技术的核心。
- en: In the next chapter, we will show you how to install and configure different
    Linux-based servers, such as web servers, DNS servers, DHCP servers, and mail
    servers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向你展示如何安装和配置不同的基于Linux的服务器，如Web服务器、DNS服务器、DHCP服务器和邮件服务器。
- en: Questions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here’s a brief quiz about some of the essential concepts that were covered
    in this chapter:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简短的小测验，涵盖了本章中讨论的一些基本概念：
- en: What is the major difference between containers and VMs?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器和虚拟机之间的主要区别是什么？
- en: '**Hint**: Revisit *Figure 12**.1*.'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**提示**：重新查看*图 12.1*。'
- en: How does container technology work?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器技术是如何工作的？
- en: What are the two major components of Docker architecture?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker架构的两个主要组件是什么？
- en: Which Docker command shows the running containers?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Docker命令显示正在运行的容器？
- en: Which command is used for container network management?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于容器网络管理？
- en: '`docker network` command’s help.'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`docker network`命令的帮助。'
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following Packt titles:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章所涉及主题的更多信息，你可以参考以下Packt出版的书籍：
- en: '*Docker Quick Start Guide*, Earl Waud'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docker快速入门指南*，Earl Waud'
- en: '*Mastering Docker – Fourth Edition*, Russ McKendrick'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入掌握Docker（第四版）*，Russ McKendrick'
- en: '*Containerization with LXC*, Konstantin Ivanov'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用LXC进行容器化*，Konstantin Ivanov'
- en: '*A Developer’s Essential Guide to Docker Compose*, Emmanouil Gkatziouras'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发者的Docker Compose必备指南*，Emmanouil Gkatziouras'
