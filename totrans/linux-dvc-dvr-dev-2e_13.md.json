["```\nstruct task_struct{\n    […]\n    struct mm_struct *mm, *active_mm;\n    […]\n}\n```", "```\nstruct mm_struct {\n    struct vm_area_struct *mmap;\n    unsigned long mmap_base;\n    unsigned long task_size;\n    unsigned long highest_vm_end;\n    pgd_t * pgd;\n    atomic_t mm_users;\n    atomic_t mm_count;\n    atomic_long_t nr_ptes;\n#if CONFIG_PGTABLE_LEVELS > 2\n    atomic_long_t nr_pmds;\n#endif\n    int map_count;\n    spinlock_t page_table_lock;\n    unsigned long total_vm;\n    unsigned long locked_vm;\n    unsigned long pinned_vm;\n    unsigned long data_vm;\n    unsigned long exec_vm;\n    unsigned long stack_vm;\n    unsigned long start_code, end_code, start_data, end_data;\n    unsigned long start_brk, brk, start_stack;\n    unsigned long arg_start, arg_end, env_start, env_end;\n    /* ref to file /proc/<pid>/exe symlink points to */\n    struct file __rcu *exe_file;\n};\n```", "```\nstruct vm_area_struct {\n    unsigned long vm_start; \n    unsigned long vm_end;\n    struct vm_area_struct *vm_next, *vm_prev;\n    struct mm_struct *vm_mm;\n    pgprot_t vm_page_prot;\n    unsigned long vm_flags;\n    unsigned long vm_pgoff;\n    struct file * vm_file;\n    [...]\n}\n```", "```\nextern struct vm_area_struct * find_vma(\n           struct mm_struct * mm, unsigned long addr);\n```", "```\nstruct vm_area_struct *vma =\n                     find_vma(task->mm, 0x603000);\nif (vma == NULL) /* Not found ? */\n    return -EFAULT;\n/* Beyond the end of returned VMA ? */\nif (0x13000 >= vma->vm_end)\n    return -EFAULT;\n```", "```\n# cat /proc/1073/maps \n00400000-00403000 r-xp 00000000 b3:04 6438             /usr/sbin/net-listener\n00602000-00603000 rw-p 00002000 b3:04 6438             /usr/sbin/net-listener\n00603000-00624000 rw-p 00000000 00:00 0                [heap]\n7f0eebe4d000-7f0eebe54000 r-xp 00000000 b3:04 11717    /usr/lib/libffi.so.6.0.4\n7f0eebe54000-7f0eec054000 ---p 00007000 b3:04 11717    /usr/lib/libffi.so.6.0.4\n7f0eec054000-7f0eec055000 rw-p 00007000 b3:04 11717    /usr/lib/libffi.so.6.0.4\n7f0eec055000-7f0eec069000 r-xp 00000000 b3:04 21629    /lib/libresolv-2.22.so\n7f0eec069000-7f0eec268000 ---p 00014000 b3:04 21629    /lib/libresolv-2.22.so\n[...]\n7f0eee1e7000-7f0eee1e8000 rw-s 00000000 00:12 12532    /dev/shm/sem.thk-mcp-231016-sema\n[...]\n```", "```\n#ifdef CONFIG_ARM64_64K_PAGES\n#define PAGE_SHIFT        16\n#elif defined(CONFIG_ARM64_16K_PAGES)\n#define PAGE_SHIFT       14\n#else\n#define PAGE_SHIFT        12\n#endif\n#define PAGE_SIZE        (_AC(1, UL) << PAGE_SHIFT)\n```", "```\nstruct page *alloc_pages(gfp_t mask, unsigned int order)\n```", "```\n#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0)\n```", "```\nvoid __free_pages(struct page *page, unsigned int order);\n```", "```\nunsigned long __get_free_pages(gfp_t mask,\n                               unsigned int order);\nunsigned long get_zeroed_page(gfp_t mask);\n```", "```\nfree_pages(unsigned long addr, unsigned int order);\n```", "```\nstruct page *virt_to_page(void *kaddr);\nvoid *page_to_virt(struct page *pg)\n```", "```\nvoid *page_address(const struct page *page)\n```", "```\nvoid *kmalloc(size_t size, int flags);\n```", "```\nvoid *devm_kmalloc(struct device *dev, size_t size,\n                   gfp_t gfp);\n```", "```\nsize_t ksize(const void *objp);\n```", "```\nvoid kfree(const void *ptr)\n```", "```\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\nstatic void *ptr; \nstatic int alloc_init(void) \n{\n    size_t size = 1024; /* allocate 1024 bytes */ \n    ptr = kmalloc(size,GFP_KERNEL); \n    if(!ptr) {\n        /* handle error */\n        pr_err(\"memory allocation failed\\n\"); \n        return -ENOMEM; \n    } else {\n        pr_info(\"Memory allocated successfully\\n\"); \n    }\n    return 0;\n}\nstatic void alloc_exit(void)\n{\n    kfree(ptr); \n    pr_info(\"Memory freed\\n\"); \n}\nmodule_init(alloc_init); \nmodule_exit(alloc_exit);\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu\");\n```", "```\nvoid kzalloc(size_t size, gfp_t flags);\nvoid kzfree(const void *p);\nvoid *kcalloc(size_t n, size_t size, gfp_t flags);\nvoid *krealloc(const void *p, size_t new_size,\n                gfp_t flags);\n```", "```\n#include <linux/vmalloc.h>\n```", "```\nvoid *vmalloc(unsigned long size);\nvoid *vzalloc(unsigned long size);\nvoid vfree(void *addr);\n```", "```\n#include<linux/init.h>\n#include<linux/module.h>\n#include <linux/vmalloc.h>\nStatic void *ptr;\nstatic int alloc_init(void)\n{\n    unsigned long size = 8192; /* 2 x 4KB */\n    ptr = vmalloc(size);\n    if(!ptr)\n    {\n        /* handle error */\n        pr_err(\"memory allocation failed\\n\");\n        return -ENOMEM;\n    } else {\n        pr_info(\"Memory allocated successfully\\n\");\n    }\n    return 0;\n}\nstatic void my_vmalloc_exit(void)\n{\n    vfree(ptr);\n    pr_info(\"Memory freed\\n\");\n}\nmodule_init(my_vmalloc_init);\nmodule_exit(my_vmalloc_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"john Madieu, john.madieu@gmail.com\");\n```", "```\nstruct ressource *request_region(unsigned long start,\n                         unsigned long len, char *name);\nvoid release_region(unsigned long start,\n                         unsigned long len);\n```", "```\nu8 inb(unsigned long addr)\nu16 inw(unsigned long addr)\nu32 inl(unsigned long addr)\n```", "```\nvoid outb(u8 b, unsigned long addr)\nvoid outw(u16 b, unsigned long addr)\nvoid outl(u32 b, unsigned long addr)\n```", "```\nstruct ressource* request_mem_region(unsigned long start,\n                           unsigned long len, char *name)\nvoid release_mem_region(unsigned long start, \n                        unsigned long len)\n```", "```\nstruct ressource* devm_request_region(\n               struct device *dev, resource_size_t start,\n               resource_size_t n, const char *name);\n```", "```\nvoid __iomem *ioremap(unsigned long phys_addr,\n                      unsigned long size);\nvoid iounmap(void __iomem *addr);\n```", "```\nvoid __iomem *devm_ioremap(struct device *dev,\n                           resource_size_t offset,\n                           resource_size_t size);\n```", "```\nunsigned int ioread8(void __iomem *addr);\nunsigned int ioread16(void __iomem *addr);\nunsigned int ioread32(void __iomem *addr);\nvoid iowrite8(u8 value, void __iomem *addr);\nvoid iowrite16(u16 value, void __iomem *addr);\nvoid iowrite32(u32 value, void __iomem *addr);\n```", "```\nvoid *kmap(struct page *page);\n```", "```\nvoid kunmap(struct page *page);\n```", "```\nvoid *kmap(struct page *page)\n{\n    BUG_ON(in_interrupt());\n    if (!PageHighMem(page))\n        return page_address(page);\n    return kmap_high(page);\n}\n```", "```\nint remap_pfn_range(struct vm_area_struct *vma,\n                    unsigned long addr,\n                    unsigned long pfn,\n                    unsigned long size, pgprot_t flags);\n```", "```\n            unsigned long pfn =\n              virt_to_phys((void *)kmalloc_area)>>PAGE_SHIFT; \n        ```", "```\n            unsigned long pfn = page_to_pfn(page)\n        ```", "```\n            unsigned long pfn = vmalloc_to_pfn(vmalloc_area);\n        ```", "```\nunsigned long pos\nunsigned long off = vma->vm_pgoff;\n/*compute the initial PFN according to the memory area */\n[...]\n/* Then compute the final position */\npos = pfn + off\n[...]\nreturn remap_pfn_range(vma, vma->vm_start,\n        pos, vma->vm_end - vma->vm_start, \n         vma->vm_page_prot);\n```", "```\nwhile (length > 0) {\n    pfn = vmalloc_to_pfn(vmalloc_area_ptr);\n    if ((ret = remap_pfn_range(vma, start, pfn, \n      PAGE_SIZE, PAGE_SHARED)) < 0) {\n        return ret;\n    }\n    start += PAGE_SIZE;\n    vmalloc_area_ptr += PAGE_SIZE;\n    length -= PAGE_SIZE;\n}\n```", "```\nint io_remap_page_range(struct vm_area_struct *vma,\n                     unsigned long start,\n                     unsigned long phys_pfn,\n                     unsigned long size, pgprot_t flags);\n```", "```\nint vm_iomap_memory(struct vm_area_struct *vma,\n                    phys_addr_t start, unsigned long len)\n```", "```\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n```", "```\nint mmap (void *addr, size_t len, int prot,\n           int flags, int fd, ff_t offset);\n```", "```\nint (*mmap)(struct file *filp,\n             struct vm_area_struct *vma);\n```", "```\n    unsigned long offset = vma->vm_pgoff << PAGE_SHIFT; \n    if (offset >= buffer_size)\n            return -EINVAL;\n    ```", "```\n    unsigned long size = vma->vm_end - vma->vm_start;\n    if (buffer_size < (size + offset))\n        return -EINVAL;\n    ```", "```\n    unsigned long pfn;    \n    pfn = virt_to_phys(buffer + offset) >> PAGE_SHIFT;\n    ```", "```\n    if (remap_pfn_range(vma, vma->vm_start, pfn,\n                       size, vma->vm_page_prot)) {\n        return -EAGAIN;\n    }\n    return 0;\n    ```", "```\n    static const struct file_operations my_fops = {\n        .owner = THIS_MODULE,\n        [...]\n        .mmap = my_mmap,\n        [...]\n    };\n    ```"]