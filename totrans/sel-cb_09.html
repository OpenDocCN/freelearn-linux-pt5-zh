<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Aligning SELinux with DAC</h1></div></div></div><p>In this chapter, our focus will be on the following set of recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assigning a different root location to regular services</li><li class="listitem" style="list-style-type: disc">Using a different root location for SELinux-aware applications</li><li class="listitem" style="list-style-type: disc">Sharing user content with file ACLs</li><li class="listitem" style="list-style-type: disc">Enabling polyinstantiated directories</li><li class="listitem" style="list-style-type: disc">Configuring capabilities instead of setuid binaries</li><li class="listitem" style="list-style-type: disc">Using group membership for role-based access</li><li class="listitem" style="list-style-type: disc">Backing up and restoring files</li><li class="listitem" style="list-style-type: disc">Governing application network access</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Introduction</h1></div></div></div><p>SELinux is <a id="id580" class="indexterm"/>an access control mechanism that works alongside the regular access controls that Linux provides. Making sure that these various access control systems play nicely together is important as both have their merits and uses.</p><p>Regular DAC security services on Linux are already quite powerful and are being extended with almost every Linux release. Namespaces, extended access controls, additional <strong>chroot</strong> restrictions, and <a id="id581" class="indexterm"/>other services are added to the Linux ecosystem to support the hardening of Linux systems further.</p><p>In this process of hardening systems, SELinux is just another layer of defense. Putting all efforts only on SELinux would be a major mistake to make, as SELinux has its downsides as well. By properly enabling the Linux DAC controls and tweaking SELinux so that it plays nicely together with these controls, a Linux system can be made much more resilient against vulnerabilities and attacks.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Assigning a different root location to regular services</h1></div></div></div><p>A different root location, also known as a<strong> </strong>chroot, is an important feature of Linux systems meant to disallow direct access to file <a id="id582" class="indexterm"/>resources outside a specified directory location. The environment that is accessible from a chroot is called a <strong>jail</strong> or <strong>chroot jail</strong>. Applications<a id="id583" class="indexterm"/> in a chroot jail are launched with a different root, wherein only those<a id="id584" class="indexterm"/> files that are needed for the application to work are hosted.</p><p>Although it is commonly seen as a security feature, this was not the intention of a chroot. However, with the proper approach, chroots can enhance the secure setup of an application.</p><p>For instance, in case of a vulnerability, a successful exploit might only be able to access the files available in the chroot. Other sensitive files, such as authentication-related files or other service configurations, are not reachable from within the chroot (assuming the exploited application does not have the privileges to break out of a chroot jail).</p><p>The steps to set up a chroot environment for any service are similar, but the end result of a chroot is never the same: different files need to be available in a chroot depending on the application that is being restricted.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec188"/>Getting ready</h2></div></div></div><p>Find the application that needs to be restricted. Such applications have to be end services, in the sense that there is little to no interaction between the application and other applications or services. Otherwise, all those other applications and services would need to be available in the same chroot as well.</p><p>Usually, the primary targets are those services that are very popular in use on the Internet. Exploits for these services are usually more actively searched and developed for, and when a vulnerability is found and an exploit has been developed, malicious users or groups quickly scan the Internet for vulnerable versions to attack.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec189"/>How to do it…</h2></div></div></div><p>The next set of steps shows how to set up a chroot environment and inform SELinux about the chroot. We use the BIND DNS server as our example service and <code class="literal">/var/chroot/</code> as the chroot location:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the chroot location and add in the necessary subdirectories:<div><pre class="programlisting">
<strong>~# mkdir -p /var/chroot/dev</strong>
<strong>~# mkdir -p /var/chroot/etc/bind</strong>
<strong>~# mkdir -p /var/chroot/var/bind/{sec,pri,dyn}</strong>
<strong>~# mkdir -p /var/chroot/var/{log,run}</strong>
<strong>~# chown root:named /var/chroot</strong>
<strong>~# chmod 750 /var/chroot</strong>
<strong>~# chown -R named:named /var/chroot/var/*</strong>
</pre></div></li><li class="listitem">Copy <a id="id585" class="indexterm"/>all the files that the application needs:<div><pre class="programlisting">
<strong>~# cp /etc/named.conf /var/chroot/etc/</strong>
<strong>~# cp /etc/localtime /var/chroot/etc/</strong>
<strong>~# cp -a /var/named/* /var/chroot/var/named/</strong>
</pre></div></li><li class="listitem">Create the device files that the application needs:<div><pre class="programlisting">
<strong>~# mknod /var/chroot/dev/null c 1 3</strong>
<strong>~# mknod /var/chroot/dev/random c 1 8</strong>
<strong>~# chmod 666 /var/chroot/dev/*</strong>
</pre></div></li><li class="listitem">As the BIND service knows about chroots, we do not need to copy its binaries and libraries to the chroot location. However, not all services support chroots out of the box. When this is the case, we need to copy the binaries and libraries as well.</li><li class="listitem">Now, relabel the files in the chroot so that they get the proper SELinux labels:<div><pre class="programlisting">
<strong>~# setfiles -r /var/chroot/ /etc/selinux/mcs/contexts/files/file_contexts /var/chroot/</strong>
</pre></div></li><li class="listitem">Launch the application with the proper options to enable the chroot support. Some Linux distributions already support chroot information for the BIND service. In general, it requires the <code class="literal">named</code> application to be launched with the <code class="literal">-t /var/chroot/</code> option. If the application does not support chroots out of the box, use the <code class="literal">chroot</code> command itself:<div><pre class="programlisting">
<strong>~# chroot /var/chroot/ su - named -c /usr/sbin/named</strong>
</pre></div></li><li class="listitem">If the application supports chroots out of the box, it might require the <code class="literal">chroot</code> capability. This is supported through the <code class="literal">sys_chroot</code> permission, granted through the following SELinux policy interface:<div><pre class="programlisting">corecmd_exec_chroot(named_t)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec190"/>How it works…</h2></div></div></div><p>Setting up a chroot environment is usually a trial-and-error approach; although, for more popular services, many tutorials exist on the Internet that make setting up chroots a lot easier.</p><p>The basic <a id="id586" class="indexterm"/>approach to use is four-fold:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the chroot location and directory structure.</li><li class="listitem">Install the necessary files and, if necessary, application binaries and libraries.</li><li class="listitem">Update the SELinux labels of the resources.</li><li class="listitem">Call the chroot binary or use the built-in <code class="literal">chroot</code> capabilities of the application.</li></ol></div><p>When <a id="id587" class="indexterm"/>creating a chroot location, we need to make sure that the structure is similar to a real root location (that is, the <code class="literal">/</code> location); as for the application, it will see the filesystem as if this chroot location is the entire filesystem.</p><p>Which files to install is a different matter though, and having online resources to inform us what to do is a great help. But if these online resources are missing, then we can still find out which files are needed.</p><p>For instance, we can use the <code class="literal">ldd</code> or <code class="literal">scanelf</code> application:</p><div><pre class="programlisting">
<strong>~# ldd /usr/sbin/named</strong>
<strong>  linux-vdso.so.1</strong>
<strong>  liblwres.so.90 =&gt; /usr/lib64/liblwres.so.90</strong>
<strong>  libdns.so.100 =&gt; /usr/lib64/libdns.so.100</strong>
<strong>  libbind9.so.90 =&gt; /usr/lib64/libbind9.so.90</strong>
<strong>  libisccfg.so.90 =&gt; /usr/lib64/libisccfg.so.90</strong>
<strong>  libisccc.so.90 =&gt; /usr/lib64/libisccc.so.90</strong>
<strong>  libisc.so.95 =&gt; /usr/lib64/libisc.so.95</strong>
<strong>  libc.so.6 =&gt; /lib64/libc.so.6</strong>
<strong>  /lib64/ld-linux-x86-64.so.2</strong>
</pre></div><p>But in general, it is the trial-and-error approach that works the easiest. Just launch the application in the chroot, register its errors, and resolve them.</p><p>For SELinux, the important bit here is that the chroot should be labeled correctly. Consider <code class="literal">/var/chroot/etc/named.conf</code>, for instance. The SELinux policy will assume that this file is labeled <code class="literal">named_conf_t</code>. However, the location itself (<code class="literal">/var/chroot/etc/named.conf</code>) implies <code class="literal">var_t</code>, as <code class="literal">/var/</code> is <code class="literal">var_t</code> and there are no definitions for any of our defined location's subdirectories or files within.</p><p>The <code class="literal">setfiles</code> command allows <a id="id588" class="indexterm"/>us to relabel a location with a different root location, resulting in <code class="literal">/var/chroot/etc/named.conf</code> being labeled as if it was <code class="literal">/etc/named.conf</code>. However, take care that a system relabeling operation is followed by the <code class="literal">setfiles</code> command again as the SELinux configuration is not aware of this change in labeling.</p><p>Finally, the application itself needs to be launched inside the chroot or through its built-in chroot support. Applications that support chroots themselves can be tuned through their configuration files and start up options to make sure that they run in a chroot environment. If that isn't possible, then the application should be started using an <code class="literal">init</code> script that calls the <code class="literal">chroot</code> command, most likely together with the <code class="literal">su</code> application to allow switching to a different user.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec191"/>There's more...</h2></div></div></div><p>A <a id="id589" class="indexterm"/>chroot is a relatively primitive yet powerful method for reducing the impact of an exploit. However, methods exist to escape a chroot. Luckily, there are some kernel patches that improve the security of chroots tremendously. A <a id="id590" class="indexterm"/>popular<a id="id591" class="indexterm"/> update is the one maintained by the <strong>grsecurity</strong> team (<a class="ulink" href="http://www.grsecurity.net">http://www.grsecurity.net</a>).</p><p>With <a id="id592" class="indexterm"/>grsecurity's chroot restrictions, the kernel can be configured with the following options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Disallow mounts and remounts of filesystems initiated from within the chroot</li><li class="listitem" style="list-style-type: disc">Disallow chrooting from within the chroot</li><li class="listitem" style="list-style-type: disc">Disallow the <code class="literal">pivot_root</code> call from within the chroot</li><li class="listitem" style="list-style-type: disc">Force the current working directory of chrooted applications to be the root directory of the chroot</li><li class="listitem" style="list-style-type: disc">Disallow the <code class="literal">setuid</code> and <code class="literal">setgid chmod</code> operations from within the chroot</li><li class="listitem" style="list-style-type: disc">Disallow changing directories through open file descriptors pointing outside the chroot</li><li class="listitem" style="list-style-type: disc">Disallow attaching to shared memory created outside the chroot</li><li class="listitem" style="list-style-type: disc">Disallow access to Unix domain sockets created outside the chroot</li><li class="listitem" style="list-style-type: disc">Disallow sending signals to processes outside the chroot</li></ul></div><p>Besides these options, there are many, many more options. Such options make chroot jails much more security-oriented than originally intended and make for a very powerful mitigation against exploits.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec192"/>See also</h2></div></div></div><p>There are many resources available about chroot jails and BIND chroots in particular:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building <a id="id593" class="indexterm"/>and configuring BIND 9<a id="id594" class="indexterm"/> in a chroot jail available at <a class="ulink" href="http://www.unixwiz.net/techtips/bind9-chroot.html">http://www.unixwiz.net/techtips/bind9-chroot.html</a> goes in great detail and has pointers to various other BIND-related resources</li><li class="listitem" style="list-style-type: disc">On the <a id="id595" class="indexterm"/>same site, best practices for Unix <code class="literal">chroot()</code> operations can be found: <a class="ulink" href="http://www.unixwiz.net/techtips/chroot-practices.html">http://www.unixwiz.net/techtips/chroot-practices.html</a></li><li class="listitem" style="list-style-type: disc">The <a id="id596" class="indexterm"/>Jailkit project (<a class="ulink" href="http://olivier.sessink.nl/jailkit/">http://olivier.sessink.nl/jailkit/</a>) provides a set of utilities to manage chroot jails</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Using a different root location for SELinux-aware applications</h1></div></div></div><p>SELinux-aware applications have more requirements when they run inside a chroot location. They <a id="id597" class="indexterm"/>require access to the SELinux <a id="id598" class="indexterm"/>subsystem (from within the chroot) and possibly SELinux configuration entries. This includes PAM-enabled services, as user logins on these services might require access to the SELinux user configuration files (such as the <code class="literal">seusers</code> file and default contexts).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec193"/>How to do it…</h2></div></div></div><p>First, create the regular chroot location as we saw earlier. To update the system to support SELinux-aware applications inside the chroot, complete the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Mount the SELinux filesystem inside the chroot at <code class="literal">/sys/fs/selinux/</code> so that the application can query the SELinux policy:<div><pre class="programlisting">
<strong>~# mkdir -p /var/chroot/sys/fs/selinux</strong>
<strong>~# mount -t selinuxfs none /var/chroot/sys/fs/selinux</strong>
</pre></div></li><li class="listitem">Optionally, create the <code class="literal">/var/chroot/etc/selinux/</code> location and copy the current definition inside it:<div><pre class="programlisting">
<strong>~# cp -a /etc/selinux/ /var/chroot/etc/</strong>
</pre></div></li><li class="listitem">Update the <code class="literal">seusers</code> file (in <code class="literal">/var/chroot/etc/selinux/mcs/</code>) to only contain the SELinux user mapping(s) needed inside the chroot.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec194"/>How it works…</h2></div></div></div><p>Applications that are SELinux-aware usually require access to the SELinux filesystem (<code class="literal">/sys/fs/selinux/</code>) and a kernel-provided pseudo filesystem needed in order to interact with the SELinux subsystem. This should be seen as a more dangerous situation, as this usually has the application run as a more privileged user and with access to a system resource that is not protected by the chroot anymore. This reduces the effectiveness of a chroot jail as a security measure.</p><p>If applications do not support chroots themselves internally, then we will have to expose the <code class="literal">/sys/fs/selinux/</code> filesystems to the application that is chrooted. If the application supports chroot out of the box, it might only call the chroot after consulting SELinux (that is, from the nonchrooted parent) and run the worker or user processes inside a chroot. This is the case with chrooted SFTP users supported through OpenSSH.</p><p>It might also be sufficient to mount the SELinux filesystem on <code class="literal">/selinux/</code> (a deprecated but still a supported location for the SELinux filesystem) inside the chroot. That way, no fake <code class="literal">/sys/fs/</code> location needs to be created:</p><div><pre class="programlisting">
<strong>~# mount -t selinuxfs none /var/chroot/selinux</strong>
</pre></div><p>The <code class="literal">/etc/selinux/</code> location is not always needed, so it shouldn't be made accessible inside the chroot by default. SELinux-aware applications that use SELinux user and role transitions <a id="id599" class="indexterm"/>or that actively modify file <a id="id600" class="indexterm"/>contexts will need to be able to read the files inside <code class="literal">/etc/selinux/</code> though.</p><p>Depending on the reason of the chroot jail, it might be possible as well to use a read-only bind-mount of the <code class="literal">/etc/selinux/</code> location:</p><div><pre class="programlisting">
<strong>~# mount -o bind /etc/selinux /var/chroot/etc/selinux</strong>
<strong>~# mount -o remount,ro /var/chroot/etc/selinux</strong>
</pre></div><p>The remount afterwards is needed to mark it as read-only. A bind-mount, by itself, doesn't allow additional mount options to be passed, so we cannot immediately mount with the <code class="literal">ro</code> mount option. Of course, it is no longer possible/needed to modify the <code class="literal">seusers</code> file with a read-only bind-mount.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec195"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detailed <a id="id601" class="indexterm"/>guides on SFTP chroots can be found at <a class="ulink" href="https://wiki.archlinux.org/index.php/SFTP_chroot">https://wiki.archlinux.org/index.php/SFTP_chroot</a> and <a class="ulink" href="http://en.wikibooks.org/wiki/OpenSSH/Cookbook/SFTP">http://en.wikibooks.org/wiki/OpenSSH/Cookbook/SFTP</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Sharing user content with file ACLs</h1></div></div></div><p>Access <a id="id602" class="indexterm"/>control lists allow for more fine-grained <a id="id603" class="indexterm"/>access controls on files. Instead of using a common group ownership, access to files can be individually granted to users or groups.</p><p>However, the access controls that SELinux enables should also be tailored to this situation. Features such as the user-based access control constraints in SELinux might prevent sharing user content altogether, regardless of the ACLs set on the file.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec196"/>How to do it…</h2></div></div></div><p>Assuming that a user wants to allow read and read-write accesses to a set of files and directories, the following set of steps can be used:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an accessible location outside the user's home directory:<div><pre class="programlisting">
<strong>~# mkdir -p /home/share/</strong>
<strong>~# chmod 1777 /home/share/</strong>
</pre></div></li><li class="listitem">Create an SELinux file type that can be used for sharing resources:<div><pre class="programlisting">type user_share_t;
files_type(user_share_t)</pre></div></li><li class="listitem">Create an interface allowing users to administer the resource:<div><pre class="programlisting">interface(`userdom_admin_user_share','
  gen_require(`
    type user_share_t;
  ')
  admin_pattern($1, user_share_t)
 ')</pre></div></li><li class="listitem">Assign<a id="id604" class="indexterm"/> this type to the new location:<div><pre class="programlisting">
<strong>~# semanage fcontext -a -t user_share_t "/home/share(/.*)?"</strong>
<strong>~# restorecon -R /home/share/</strong>
</pre></div></li><li class="listitem">Assign<a id="id605" class="indexterm"/> the interface to the user domain(s) that will participate in the shared development of this resource:<div><pre class="programlisting">userdom_admin_user_share(user_t)</pre></div></li><li class="listitem">Move the files that need to be shared outside the user's home directory, as the SELinux context of the home directory will not allow sharing resources within.<div><pre class="programlisting">
<strong>~$ cp -r sharedfiles/ /home/share &amp;&amp; rm -r sharedfiles/</strong>
</pre></div></li><li class="listitem">Assign the ACL that allows the (limited set of) users proper access:<div><pre class="programlisting">
<strong>~$ setfacl -R -m u:user1:rX /home/share/sharedfiles</strong>
<strong>~$ setfacl -R -m u:user2:rwX /home/share/sharedfiles</strong>
<strong>~$ setfacl -m "default:u:user2:rwX" /home/share/sharedfiles</strong>
<strong>~$ setfacl -m "default:u:user0:rwX" /home/share/sharedfiles</strong>
<strong>~$ setfacl -m "default:u:user1:rX" /home/share/sharedfiles</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec197"/>How it works…</h2></div></div></div><p>The file-level access controls can be perfectly used together with the SELinux access controls. However, special care needs to be taken that both control mechanisms (file ACLs and the SELinux policy) don't interfere with each other. SELinux might disallow accesses expected to work (for instance, due to SELinux constraints rather than type enforcement settings), but also file access controls need to be properly managed in order to keep the behavior on the system consistent.</p><p>In the recipes, the files that are shared are moved outside the user's home directory. This is mostly because of SELinux' UBAC feature, which disallows different SELinux users to access each others' regular resources (such as those labeled as <code class="literal">user_home_t</code> but also <code class="literal">user_home_dir_t</code>). As <code class="literal">user_home_dir_t</code> isn't accessible by other SELinux users under the UBAC constraints, users mapped to a different SELinux user will not be able to enter and search through the sharing user's home directory, regardless of ACLs being installed.</p><p>Not all systems have UBAC enabled, or the sharing might be within a single SELinux user, so this approach is not always necessary. Still, using a different location allows for better management. Consider the case where the first user exits the company, but his team <a id="id606" class="indexterm"/>wants to continue accessing and managing <a id="id607" class="indexterm"/>the shared resources. They would disappear if the user home directory is removed.</p><p>With the files moved to a different location, the next step is to label the files with a file type that all users can access, but which isn't restricted by the UBAC feature. File types that have the <code class="literal">ubac_constrained_type</code> attribute set cannot be used for sharing, so a new file type is created that is labeled as a regular file. The user domains are then granted administrative rights on this type (allowing them not only to manage the files, but also to relabel files to or from the <code class="literal">user_share_t</code> type). This ensures that SELinux doesn't prevent access to the shared resources, while still preventing unauthorized domains to access the resources.</p><p>It might also be sufficient to pick a file type that is already accessible by users, such as the <code class="literal">nfs_t</code> type (if the SELinux Boolean, <code class="literal">use_nfs_home_dirs</code>, is set). However, assigning a type that is functionally used for different reasons (<code class="literal">nfs_t</code> is for NFS-mounted filesystems) might open up access to these resources from other domains as well. As such, administrators need to carefully consider the reasons for and the consequences of each choice.</p><p>After labeling the <code class="literal">/home/share/</code> location with the <code class="literal">user_share_t</code> type, the original user copies the resources to the new location and removes them from the current one. This approach (copy and remove) is used to ensure that resources inherit the label of the target location (<code class="literal">user_share_t</code>) instead of keeping the labels associated with the original file location (<code class="literal">user_home_t</code>), as would be the case with a move (<code class="literal">mv</code>) command. In more recent <code class="literal">coreutils</code> packages, support for <code class="literal">mv -Z</code> is made available, which allows you to move the resources directly while still giving the resources a proper context.</p><p>A third approach for the user would be to move the resources first and then relabel them:</p><div><pre class="programlisting">
<strong>~$ mv sharedfiles/ /home/share/</strong>
<strong>~$ chcon -R -t user_share_t /home/share/sharedfiles/</strong>
</pre></div><p>Finally, with all SELinux rules and support in place, the file access controls are enabled on the shared resources, and a default ACL is enabled so that write operations by other users will automatically inherit the proper ACL on the written resource as well, making sure that all users cooperating on the shared resource don't need to continuously set ACLs on the files.</p><p>Without the default ACLs, other users might create files inside <code class="literal">sharedfiles/</code> that have no ACLs set, disallowing other users to access the resources. </p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec198"/>There's more...</h2></div></div></div><p>Another approach that could be taken is to use the <code class="literal">setgid</code> group ownership. For instance, if all users that participate in the shared files access are in a <code class="literal">shrgrp</code> group, then the <a id="id608" class="indexterm"/>following will automatically have all files <a id="id609" class="indexterm"/>created inside the mentioned directory have the <code class="literal">shrgrp</code> group ownership defined as well:</p><div><pre class="programlisting">
<strong>~$ chgrp -R shrgrp /home/share/sharedfiles/</strong>
<strong>~$ find /home/share/sharedfiles/ -type d -exec chmod g+s '{}' \;</strong>
</pre></div><p>This does require the users to have a proper <code class="literal">umask</code> setting (such as <code class="literal">007</code> or less) so that the group permission on the newly created resource allows read and write accesses for group members.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Enabling polyinstantiated directories</h1></div></div></div><p>On <a id="id610" class="indexterm"/>Linux and Unix systems, the <code class="literal">/tmp/</code> and <code class="literal">/var/tmp/</code> locations are world writable. They are used to provide a common location for temporary files and are protected through the sticky bit so that users cannot remove files they don't own from the directory, even though the directory is world writable.</p><p>But despite this measure, there is a history of attacks against the <code class="literal">/tmp/</code> and <code class="literal">/var/tmp/</code> locations, such as race conditions with symbolic links and information leakage through (temporary or not) world or group-readable files generated within.</p><p>Polyinstantiated directories provide a neat solution to this problem: users get their own, private <code class="literal">/tmp/</code> and <code class="literal">/var/tmp/</code> instance. These directory instances are created upon login on a different location, but then made visible (mounted) on the <code class="literal">/tmp/</code> and <code class="literal">/var/tmp/</code> locations for that specific user session. This mount is local to the user session through the use of Linux namespaces—other users have their own view on the mounts, and for administrators, polyinstantiation is not enabled, so they keep a global view on the system.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec199"/>How to do it…</h2></div></div></div><p>To enable polyinstantiation of <code class="literal">/tmp/</code> and <code class="literal">/var/tmp/</code>, the following steps should be followed:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">/tmp-inst/</code> and <code class="literal">/var/tmp/tmp-inst/</code> locations:<div><pre class="programlisting">
<strong>~# mkdir /tmp-inst/ /var/tmp/tmp-inst/</strong>
<strong>~# chmod 000 /tmp-inst/ /var/tmp/tmp-inst/</strong>
</pre></div></li><li class="listitem">Set the label for these locations as <code class="literal">tmp_t</code>:<div><pre class="programlisting">
<strong>~# semanage fcontext -a -t tmp_t -f d /tmp-inst</strong>
<strong>~# semanage fcontext -a -t tmp_t -f d /var/tmp/tmp-inst</strong>
</pre></div></li><li class="listitem">Edit <code class="literal">/etc/security/namespace.conf</code> and add in the following definitions:<div><pre class="programlisting">/tmp  /tmp-inst/    level  root,adm
/var/tmp  /var/tmp/tmp-inst/  level  root,adm</pre></div></li><li class="listitem">Edit the PAM configuration file used by logins, such as <code class="literal">system-login</code>, and add the following line to the session group after the <code class="literal">pam_selinux.so</code> one:<div><pre class="programlisting">session  required  pam_namespace.so</pre></div></li><li class="listitem">Enable the <code class="literal">allow_polyinstantiation</code> SELinux Boolean:<div><pre class="programlisting">
<strong>~# setsebool -P allow_polyinstantiation on</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec200"/>How it works…</h2></div></div></div><p>The <a id="id611" class="indexterm"/>system preparation for polyinstantiated directories requires that the directories themselves are available and have the proper permissions set. When the parent directory, such as <code class="literal">/tmp/</code>, is a tmpfs mount, then we cannot have the polyinstantiated directories made available inside of it (such as <code class="literal">/tmp/tmp-inst/</code>), as that directory would be missing after a reboot (unless it is added through the <code class="literal">init</code> scripts); hence the setup of <code class="literal">/tmp-inst/</code> as a separate location. Of course, administrators can still opt to have this location itself as a tmpfs mount—the important thing is that the directory must exist and have the proper permissions (which is represented by the <code class="literal">000</code> permission set).</p><p>In the example, <code class="literal">/var/tmp/</code> is assumed not to be a tmpfs mount, so we can define the polyinstantiated directories inside of it.</p><p>The configuration file for polyinstantiated directories is the <code class="literal">namespace.conf</code> file under <code class="literal">/etc/security/</code>. In it, the mount-point is mentioned together with the directory in which the polyinstantiated directories are created:</p><div><pre class="programlisting">/tmp  /tmp-inst/  level  root,adm</pre></div><p>The third column defines the method for polyinstantiation. On non-SELinux systems, the most common <a id="id612" class="indexterm"/>method used is the <code class="literal">user</code> method, which creates directories based on the username. On SELinux-enabled systems, the method must be either <code class="literal">level</code> or <code class="literal">context</code>.</p><p>In case <a id="id613" class="indexterm"/>of the <code class="literal">level</code> method, the directories are created based on the username and MLS level of the user session. The <code class="literal">context</code> method has directories created <a id="id614" class="indexterm"/>based on the username and security context. This allows for hiding temporary data based on the role of the user, so accidental data leakage is less likely to occur.</p><p>Administrators can access the polyinstantiated directories as they are excluded from the polyinstantiation: the excluded list of users is configured as the fourth column in the <code class="literal">namespace.conf</code> file. Administrators can still see the directories that are created dynamically:</p><div><pre class="programlisting">
<strong>~# ls -l /tmp-inst/</strong>
<strong>drwxrwxrwt. 2 root root 4096 Jun 22 12:31 system_u:object_r:tmp_t:s0_user1</strong>
<strong>drwxrwxrwt. 2 root root 4096 Jun 22 12:30 system_u:object_r:tmp_t:s0_user2</strong>
</pre></div><p>Next, the PAM configuration file(s) are modified to enable the <code class="literal">pam_namespace.so</code> library. To find the PAM configuration files that need to be edited, look for the PAM configuration files that call <code class="literal">pam_selinux.so</code>:</p><div><pre class="programlisting">
<strong>~# cd /etc/pam.d</strong>
<strong>~# grep -l pam_selinux.so *</strong>
<strong>system-login</strong>
</pre></div><p>In this <a id="id615" class="indexterm"/>example, the <code class="literal">system-login</code> PAM configuration file is the only file calling <code class="literal">pam_selinux.so</code>, so the <code class="literal">pam_namespace.so</code> line is added to this file. The line must be added after the <code class="literal">pam_selinux.so</code> call as the <code class="literal">pam_namespace.so</code> file uses the context of the user to decide how to call the instantiated directory. If <code class="literal">pam_selinux.so</code> has not been called yet, then this information is not available and the logon will fail.</p><p>Finally, the SELinux Boolean, <code class="literal">allow_polyinstantiation</code>, is enabled so that the proper domains have the privilege to create (and change the contexts of) the proper directories, to use namespaces, to check user context, and more.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec201"/>There's more...</h2></div></div></div><p>Administrators can go further than just having the directories created when needed. During the setup of polyinstantiated directories, a script called <code class="literal">namespace.init</code>, which is available at <code class="literal">/etc/security/</code> is called to further handle the creation and modification of those directories.</p><p>This<a id="id616" class="indexterm"/> script can be adjusted to copy files towards the instantiated directory (the file usually contains this logic already for polyinstantiated home directories) or do other changes, allowing to further tune the setup for a user session.</p><p>The <code class="literal">systemd init</code> system also has support for polyinstantiated <code class="literal">/tmp/</code> directories through the <code class="literal">PrivateTmp</code> directive, which provides a private <code class="literal">/tmp/</code> directory for a service rather than end users.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Configuring capabilities instead of setuid binaries</h1></div></div></div><p>Linux <a id="id617" class="indexterm"/>capabilities allow for course-grained kernel security <a id="id618" class="indexterm"/>authorizations on the user and application levels. Before capabilities existed, administrators could only grant additional privileges to users through <code class="literal">setuid</code> applications: applications which, when executed, inherit the privileges of the owner of the application (usually, <code class="literal">root</code>). With capabilities, the set of privileges can be restricted further.</p><p>For instance, the <code class="literal">ping</code> application can be granted the <code class="literal">cap_net_raw</code> capability, so it does not need to be <code class="literal">setuid</code> anymore. Depending on the setup, either users need to be granted the possible use of the capability (if the application has the proper flag set) or the capability is granted immediately (regardless of user settings).</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec202"/>How to do it…</h2></div></div></div><p>To use capabilities with SELinux, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Enable the capabilities that are needed for an application on the application binary:<div><pre class="programlisting">
<strong>~# setcap cap_net_raw+ei /bin/ping</strong>
</pre></div></li><li class="listitem">For the users that are allowed to use the <code class="literal">net_raw</code> capability, add the proper configurations in <code class="literal">/etc/security/capability.conf</code> (one line per user):<div><pre class="programlisting">cap_net_raw   user1</pre></div></li><li class="listitem">SELinux domains that will use the capability need to be granted the use of it. For common applications, this is usually already in place.<div><pre class="programlisting">allow ping_t self:capability net_raw;</pre></div></li><li class="listitem">SELinux domains that are allowed to modify the capability set assigned to their process(es) must have the <code class="literal">setcap</code> privilege set:<div><pre class="programlisting">allow local_login_t self:process setcap;</pre></div></li><li class="listitem">Edit the PAM configuration file(s) for the services through which the capabilities are allowed, and add the following line to the <code class="literal">auth</code> configuration block:<div><pre class="programlisting">auth  required  pam_cap.so</pre></div></li><li class="listitem">If capabilities need to be tracked/audited, SELinux's <code class="literal">auditallow</code> statement can be used:<div><pre class="programlisting">auditallow domain self:capability net_raw;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec203"/>How it works…</h2></div></div></div><p>The capabilities that a process is currently allowed to use are called the permitted capabilities. The capabilities that are active are the effective capabilities. A third set of capabilities are inheritable capabilities.</p><p>In the <a id="id619" class="indexterm"/>example, we enabled the <code class="literal">cap_net_raw</code> capability<a id="id620" class="indexterm"/> for the <code class="literal">ping</code> application and marked the capability as effective if it is inherited. In other words, it is not enabled (permitted) by default. If we want to enable the <code class="literal">cap_net_raw</code> capability immediately, we would use the effective and permitted set:</p><div><pre class="programlisting">
<strong>~# setcap cap_net_raw+ep /bin/ping</strong>
</pre></div><p>Applications that are capability-aware do not need to have the <code class="literal">effective</code> bit set. They will enable (and drop) the capabilities as they are needed through the proper system calls (which is why the <code class="literal">setcap</code> permission is needed for these domains). If <code class="literal">ping</code> was capability-aware, then the following would be sufficient for our example:</p><div><pre class="programlisting">
<strong>~# setcap cap_net_raw+i /bin/ping</strong>
</pre></div><p>Next, the users that are allowed the <code class="literal">cap_net_raw</code> capability (through the selected set of applications) need to be granted the <code class="literal">cap_net_raw</code> capability in their inherited capability set. This is done through the <code class="literal">capability.conf</code> file in <code class="literal">/etc/security/</code> and by calling the <code class="literal">pam_cap.so</code> module from within the proper PAM configuration files. The use of PAM configuration files also allows us to differentiate capabilities based on the service through which a user logs on.</p><p>To check the currently enabled capabilities, users can execute the <code class="literal">capsh</code> application:</p><div><pre class="programlisting">
<strong>~$ /sbin/capsh --print | grep ^Current</strong>
<strong>Current: cap_net_raw+i</strong>
</pre></div><p>To see the capabilities on a file, the <code class="literal">getcap</code> application can be used:</p><div><pre class="programlisting">
<strong>~$ getcap /bin/ping</strong>
<strong>/bin/ping = cap_net_raw+ei</strong>
</pre></div><p>Finally, auditing the use of capabilities through the <code class="literal">auditallow</code> statement tells us when (and by whom) a <a id="id621" class="indexterm"/>capability was used, although the same <a id="id622" class="indexterm"/>can be accomplished without an SELinux policy using the Linux audit subsystem, auditing for the <code class="literal">setcap</code> system call.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec204"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Capabilities are well explained in <a id="id623" class="indexterm"/>Chris Friedhoff's <strong>POSIX Capabilities &amp; File POSIX Capabilities</strong> page (<a class="ulink" href="http://www.friedhoff.org/posixfilecaps.html">http://www.friedhoff.org/posixfilecaps.html</a>)</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Using group membership for role-based access</h1></div></div></div><p>In<a id="id624" class="indexterm"/> larger environments, access controls<a id="id625" class="indexterm"/> are usually granted based on group membership. Group membership is easier to manage than individual permissions: just adding or removing users from a group automatically grants or revokes permissions, and administrators can easily find out which permission(s) a user will have based on the group membership.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec205"/>How to do it…</h2></div></div></div><p>In order to use group membership as a high-level method for assigning permissions, administrators need to take care of the following aspects:</p><div><ol class="orderedlist arabic"><li class="listitem">Add user(s) to the groups they should belong to:<div><pre class="programlisting">
<strong>~# gpasswd -a user1 dba</strong>
<strong>~# gpasswd -a user1 dev</strong>
</pre></div></li><li class="listitem">Assign the proper SELinux user to the group:<div><pre class="programlisting">
<strong>~# semanage login -s dbadm_u %dba</strong>
</pre></div></li><li class="listitem">Restrict binaries and libraries that should only be called by a specific group:<div><pre class="programlisting">
<strong>~# chgrp -R dev /usr/lib/gcc /usr/x86_64-pc-linux-gnu/gcc-bin</strong>
<strong>~# chmod -R o-rx /usr/lib/gcc /usr/x86_64-pc-linux-gnu/gcc-bin</strong>
</pre></div></li><li class="listitem">Use group notation inside the <code class="literal">sudoers</code> file to grant specific privileges to group members:<div><pre class="programlisting">%dba  ALL=(ALL)  TYPE=dbadm_t ROLE=dbadm_r NOPASSWD: initdb</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec206"/>How it works…</h2></div></div></div><p>Using groups makes permission handling much easier. In the end, this allows administrators to just handle group membership for users and automatically assign privileges based on the groups.</p><p>We can grant groups an SELinux user, and through the group membership decide which SELinux user a regular user is logged into. Of course, users can belong to multiple groups. For SELinux, it is the order of the <code class="literal">seusers</code> file that decides which of the following mappings are used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SELinux user mappings for individual users take precedence over group mappings</li><li class="listitem" style="list-style-type: disc">The first group mapping in the <code class="literal">seusers</code> file that uses a group that the Linux user is a member of decides the SELinux user mapping if no individual SELinux user mappings exist for this user</li></ul></div><p>As such, if a user is a member of two groups (say, <code class="literal">dba</code> and <code class="literal">web</code>) and there are mappings to both <code class="literal">dbadm_u</code> (for the <code class="literal">dba</code> group) and <code class="literal">webadm_u</code> (for the <code class="literal">web</code> group), then the first mapping in the <code class="literal">seusers</code> file will decide what the user's SELinux user will be.</p><p>In order to override this, either add the user individually or create another group (say, <code class="literal">dbaweb</code>), grant the user this group as well, and put that group mapping at the beginning of the list in the <code class="literal">seusers</code> file.</p><p>When<a id="id626" class="indexterm"/> only a specific user group is <a id="id627" class="indexterm"/>allowed access to an application, but that application does not use any specific SELinux domains, then it might be more flexible for administrators to use the Linux DAC permissions to restrict access to the application. By only allowing a specific group (<code class="literal">dev</code>, in our example), read and execute rights on the application and application libraries, we can restrict access easily.</p><p>Another approach is to label the files with new SELinux types and grant the proper domains access to those types. However, this might lead to a large set of domains needing access to the types (and so requires massive policy development effort), whereas the Linux DAC approach is easily implemented.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Backing up and restoring files</h1></div></div></div><p>An important aspect to the availability of a system and the security of a service is to provide <a id="id628" class="indexterm"/>backup and restore services. For many, having a copy of the files <a id="id629" class="indexterm"/>available might seem sufficient as a backup approach. However, backups should contain more than just the content of a file.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec207"/>How to do it…</h2></div></div></div><p>When <a id="id630" class="indexterm"/>selecting a backup solution, make sure to check for the following:</p><div><ol class="orderedlist arabic"><li class="listitem">A selection of the extended attributes of the files should be backed up as well (and not only the <code class="literal">security.selinux</code> one).</li><li class="listitem">When files are restored onto their original location, the SELinux context should be restored with it as well. If the backup solution doesn't support SELinux contexts, the <code class="literal">restorecon</code> command should be invoked afterwards against the restored file(s).</li><li class="listitem">When files are restored into a temporary area, the SELinux context should not be restored. Instead, the administrator should put the file back in place and restore the context afterwards.</li><li class="listitem">The SELinux configuration in <code class="literal">/etc/selinux/</code> should definitely be backed up, even if no full system backups are used. Whenever the policy or file context definitions are altered, these should be backed up as well whenever files are backed up.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec208"/>How it works…</h2></div></div></div><p>File labels are stored as the <code class="literal">security.selinux</code> extended attribute. As the functioning of a policy is based on the labels of all objects involved, not backing up and restoring the file labels might jeopardize the functioning of the system after a restore operation.</p><p>When <a id="id631" class="indexterm"/>the backup solution does not support extended attributes, it is<a id="id632" class="indexterm"/> important that all labels are properly set through the <code class="literal">semanage fcontext</code> command. This is the only way to make sure that, after a restore, the<a id="id633" class="indexterm"/> admin can run <code class="literal">restorecon</code> against the restored files in<a id="id634" class="indexterm"/> order to reset the file labels:</p><div><pre class="programlisting">
<strong>~# tar xvf /path/to/last_backup.tar.gz etc/named.conf</strong>
<strong>~# restorecon /etc/named.conf</strong>
</pre></div><p>However, it is seriously recommended to select a backup solution that supports extended attributes as many other Linux-related settings are stored as extended attributes. The file ACLs, for instance, are stored as extended attributes as well:</p><div><pre class="programlisting">
<strong>~$ getfattr -m . -d named.conf</strong>
<strong># file: named.conf</strong>
<strong>security.selinux="system_u:object_r:named_conf_t:s0"</strong>
<strong>system.posix_acl_access=0sAgAAAAEABgD/////AgAGAOo…</strong>
</pre></div><p>Other examples of extended attributes that can be used on a system are PaX markings (<code class="literal">user.pax.flags</code>), IMA and EVM hashes (<code class="literal">security.ima</code> and <code class="literal">security.evm</code>), and capabilities (<code class="literal">security.capability</code>). But herein lies the problem as well: some attributes shouldn't (or cannot) be restored. The IMA and EVM attributes, for instance, are handled by the Linux kernel and cannot be manipulated by user utilities.</p><p>Alongside <a id="id635" class="indexterm"/>the file labels, backing up and restoring the SELinux <a id="id636" class="indexterm"/>policy should be integrated as well, especially on a system <a id="id637" class="indexterm"/>with a modified SELinux policy. If a policy is different after a restore, then types might be missing and labels might become invalid.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Governing application network access</h1></div></div></div><p>On Linux systems, <code class="literal">iptables</code> (and more recently, <code class="literal">nftables</code>) is the de facto host-based firewall <a id="id638" class="indexterm"/>technology. Administrators will undoubtedly use it to prevent access to a service from unauthorized systems. We can also use <code class="literal">iptables</code> to identify and label network packets, allowing only authorized applications (domains) to send or receive those network packets.</p><p>By default, the SELinux policy supports client and server packets and allows the usual domains access to their client and/or server packets. For instance, the web server domains (such as <code class="literal">httpd_t</code>) will have the privileges to send and receive <code class="literal">http_server_packet_t</code> packets:</p><div><pre class="programlisting">allow httpd_t http_server_packet_t:packet { send recv };</pre></div><p>This is provided through the <code class="literal">corenet_sendrecv_http_server_packets</code> interface. Enabling packet labeling is simply done using <code class="literal">iptables</code> as will be shown through this recipe. But to properly govern network access, custom packet types will need to be created to ensure that no default allowed access is used.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec209"/>How to do it…</h2></div></div></div><p>To only allow authorized domains access to particular network packets (datagrams and data streams), use the following approach:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the flow that needs to be allowed. For instance, we might only want DNS requests from <code class="literal">10.11.12.0/24</code> to be accepted by the <code class="literal">dnsmasq_t</code> domain, and requests from <code class="literal">10.13.14.0/24</code> to be accepted by the <code class="literal">named_t</code> domain.</li><li class="listitem">Create two new packet types:<div><pre class="programlisting">type dnsmasq_server_packet_t;
corenet_server_packet(dnsmasq_server_packet_t)
 
type named_server_packet_t;
corenet_server_packet(named_server_packet_t)</pre></div></li><li class="listitem">Allow the domains send and receive privileges for these packets:<div><pre class="programlisting">allow dnsmasq_t dnsmasq_server_packet_t:packet { send recv };
allow named_t named_server_packet_t:packet { send recv };</pre></div></li><li class="listitem">Label the incoming traffic accordingly:<div><pre class="programlisting">
<strong>~# iptables -t mangle -A INPUT -p tcp -s 10.11.12.0/24 --dport 53 -j SECMARK --selctx "system_u:object_r:dnsmasq_server_packet_t:s0"</strong>
<strong>~# iptables -t mangle -A INPUT -p udp  -s 10.11.12.0/24 --dport 53 -j SECMARK --selctx "system_u:object_r:dnsmasq_server_packet_t:s0"</strong>
<strong>~# iptables -t mangle -A INPUT -p tcp -s 10.13.14.0/24 --dport 53 -j SECMARK --selctx "system_u:object_r:named_server_packet_t:s0"</strong>
<strong>~# iptables -t mangle -A INPUT -p udp -s 10.13.14.0/24 --dport 53 -j SECMARK --selctx "system_u:object_r:named_server_packet_t:s0"</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec210"/>How it works…</h2></div></div></div><p>By using custom network packet labels, access from or to specific applications can be governed using an SELinux policy. Even though multiple applications can accept incoming DNS requests, this recipe shows how to ensure that only one application can deal with requests that have passed a certain filter.</p><p>Whenever<a id="id639" class="indexterm"/> a SECMARK label is enabled with <code class="literal">iptables</code>, the Linux kernel will automatically enable SECMARK labeling on all packets. Packets that are not marked specifically by the administrator will be marked with the <code class="literal">unlabeled_t</code> type. Some domains are allowed to handle the <code class="literal">unlabeled_t</code> packets through the <code class="literal">corenet_sendrecv_unlabeled_packets</code> interface (or the <code class="literal">kernel_sendrecv_unlabeled_packets</code> interface). However, if that is not the case, then those domains will not be able to handle network traffic anymore.</p><p>As such, it is advised to use the standard labeling for other incoming (and outgoing) traffic. To identify which incoming traffic should be labeled, we can leverage assistance from the <code class="literal">netstat</code> output:</p><div><pre class="programlisting">
<strong>~# netstat -naptZ | awk '/LISTEN/ {print $4,$6,$7,$8}'</strong>
<strong>0.0.0.0:13500 LISTEN 6489/mysqld system_u:system_r:mysqld_t:s0</strong>
<strong>0.0.0.0:80 LISTEN 23303/httpd system_u:system_r:httpd_t:s0</strong>
<strong>10.11.12.122:53 LISTEN 4432/dnsmasq system_u:system_r:dnsmasq_t:s0</strong>
<strong>10.13.14.42:53 LISTEN 5423/named system_u:system_r:named_t:s0</strong>
</pre></div><p>Based on this output, labeling the appropriate traffic as <code class="literal">mysqld_server_packet_t</code> and <code class="literal">http_server_packet_t</code> will allow those domains to access their incoming network traffic.</p><p>By creating additional types for <code class="literal">dnsmasq_t</code> and <code class="literal">named_t</code>, those applications can only handle requests associated with those packet types. If an administrator changes the configuration of one of these DNS servers, then the network packet labeling will still ensure that DNS requests from the previously identified network segments cannot be used by the wrong DNS server, even though the flow is allowed firewall-wise.</p><p>With <code class="literal">sesearch</code>, interrogating the policy to see which applications (domains) are able to send and receive certain packets is easy:</p><div><pre class="programlisting">
<strong>~# sesearch -t dns_server_packet_t -ACTS</strong>
<strong>Found 10 semantic av rules:</strong>
<strong>   allow nova_network_t dns_server_packet_t : packet { send recv } ;</strong>
<strong>   allow corenet_unconfined_type packet_type : packet { send recv relabelto flow_in flow_out forward_in forward_out } ;</strong>
<strong>   allow named_t dns_server_packet_t : packet { send recv } ;</strong>
<strong>   allow vmware_host_t server_packet_type : packet { send recv } ;</strong>
<strong>   allow dnsmasq_t dns_server_packet_t : packet { send recv } ;</strong>
<strong>   allow kernel_t packet_type : packet send ;</strong>
<strong>   allow iptables_t packet_type : packet relabelto ;</strong>
<strong>ET allow squid_t packet_type : packet { send recv } ; [ squid_connect_any ]</strong>
<strong>DT allow icecast_t packet_type : packet { send recv } ; [ icecast_connect_any ]</strong>
<strong>DT allow git_session_t server_packet_type : packet { send recv } ; [ git_session_bind_all_unreserved_ports ]</strong>
</pre></div><p>The same <a id="id640" class="indexterm"/>approach can be taken from a client level. A mail server might need to connect to other mail servers, which means that the outgoing data can be labeled as <code class="literal">mail_client_packet_t</code> (if we use the default traffic). However, if we want to make sure only the mail server can connect to other mail servers (and no other domains that also have privileges to send and receive the <code class="literal">mail_client_packet_t</code> packets), then a new packet type can be used.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec211"/>See also</h2></div></div></div><p>For more<a id="id641" class="indexterm"/> information about SECMARK labeling, read up on the following resources:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.selinuxproject.org/page/NB_Networking">http://www.selinuxproject.org/page/NB_Networking</a></li><li class="listitem" style="list-style-type: disc">Paul Moore's <strong>Transitioning to Secmark</strong> at <a class="ulink" href="http://paulmoore.livejournal.com/4281.html">http://paulmoore.livejournal.com/4281.html</a></li><li class="listitem" style="list-style-type: disc">James Morris's <strong>New Secmark-based network controls for SELinux</strong> at <a class="ulink" href="http://james-morris.livejournal.com/11010.html">http://james-morris.livejournal.com/11010.html</a></li></ul></div></div></div></body></html>