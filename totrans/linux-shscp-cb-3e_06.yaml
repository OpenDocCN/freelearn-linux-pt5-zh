- en: Repository Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning a remote git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and committing changes with git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and merging branches with git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing a branch to a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the latest sources for the current branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the status of a git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing git history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing message ethics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fossil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new fossil repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloning a remote fossil repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a fossil project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and Committing Changes with Fossil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using branches and forks with fossil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your work with fossil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating your local fossil repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the status of a fossil repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing fossil history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more time you spend developing applications the more you come to appreciate
    software that tracks your revision history. A revision control system lets you
    create a sandbox for new approaches to problems, maintain multiple branches of
    released code, and provide a development history in the event of intellectual
    property disputes. Linux and Unix support many source code control systems ranging
    from the early and primitive SCCS and RCS to concurrent systems such as **CVS**
    and **SVN** and the modern distributed development systems such as **GIT** and
    **FOSSIL**.
  prefs: []
  type: TYPE_NORMAL
- en: The big advantage of Git and Fossil over older systems such as CVS and SVN is
    that a developer can use them without being connected to a network. Older systems
    such as CVS and RCS worked fine when you were at the office, but you could not
    check the new code or examine the old code while working remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Git and Fossil are two different revision control systems with some similarities
    and some differences. Both support the distributed development model of revision
    control. Git provides source code control and has a number of add-on applications
    for more information while Fossil is a single executable that provides revision
    control, trouble tickets, a Wiki, web pages and technical notes.
  prefs: []
  type: TYPE_NORMAL
- en: Git is used for the Linux kernel development and has been adopted by many open
    source developers. Fossil was designed for the SQLite development team and is
    also widely used in both the open source and closed source communities.
  prefs: []
  type: TYPE_NORMAL
- en: Git is included with most Linux distributions. If it's not available on your
    system, you can install it with either yum (Redhat or SuSE) or apt-get (Debian
    or Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fossil is available as source or executable from [http://www.fossil-scm.org](http://www.fossil-scm.org).
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Git**'
  prefs: []
  type: TYPE_NORMAL
- en: The git system uses the `git` command with many subcommands to perform individual
    actions. We'll discuss git clone, git commit, git branch, and others.
  prefs: []
  type: TYPE_NORMAL
- en: To use git you need a code repository. You can either create one yourself (for
    your projects) or clone a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are working on your own project, you will want to create your own repository.
    You can create the repository on your local system, or on a remote site such as
    GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All projects in git need a master folder that holds the rest of the project
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git init` command creates the `.git` subfolder within your current working
    directory and initializes the files that configure `git`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git init` command initializes a `git` repository for local use. If you
    want to allow remote users access this repository, you need to enable that with
    the `update-server-info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Cloning a remote git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you intend to access someone else's project, either to contribute new code
    or just to use the project, you'll need to clone the code to your system.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be online to clone a repository. Once you've copied the files to
    your system, you can commit new code, backtrack to older revisions, and so on.
    You can't send any new code changes upstream to the site you cloned from until
    you are online again.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git clone` command copies files from the remote site to your local system.
    The remote site might be an anonymous repository such as GitHub, or a system where
    you need to log in with an account name and perhaps password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone from a known remote site such as GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone from a login/password protected site (perhaps your own server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Adding and committing changes with git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With distributed version control systems such as git, you do most of your work
    with your local copy of the repository. You can add new code, change code, test,
    revise, and finally commit the fully tested code. This encourages frequent small
    commits on your local repository and one large commit when the code is stable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git add` command adds a change in your working code to the staging area.
    It does not change the repository, it just marks this change as one to be included
    with the next commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Doing a `git add` after every edit session is a good policy if you want to be
    certain you don't accidently leave out a change when you commit your changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add new files to your repository with the git add command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can add multiple files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git commit` command commits the changes to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git commit` command will open the editor defined in your **EDITOR** shell
    variable and pre-populate like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After you enter a comment your changes will be saved in your local copy of the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: This does not push your changes to the main repository (perhaps `github`), but
    other developers can **pull** the new code from your repository if they have an
    account on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can shorten the add/commit events with the `-a` and `-m` arguments to commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a`: This adds the new code before committing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m`: This defines a message without going into the editor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating and merging branches with git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are maintaining an application you may need to return to an earlier branch
    to test. For instance, the bug you're fixing may have been around, but unreported,
    for a long time. You'll want to find when the bug was introduced to track down
    the code that introduced it. (Refer to `git bisect` in the *Finding bugs* recipe
    in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: When you add new features, you should create a new branch to identify your changes.
    The project maintainer can then merge the new branch into the master branch after
    the new code is tested and validated. You can change and create new branches with
    the git's `checkout` subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `git init` or `git clone` to create the project on your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To change to a previously defined branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The checkout subcommand examines the `.git` folder on your system and restores
    the snapshot associated with the desired branch.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you cannot change to an existing branch if you have uncommitted changes
    in your current workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new branch when you have uncommitted changes in the current
    workspaces. To create a new branch, use git checkout''s `-b` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This defines your current working branch to be `MyBranchName`. It sets a pointer
    to match `MyBranchName` to the previous branch. As you add and commit changes,
    the pointer will diverge further from the initial branch.
  prefs: []
  type: TYPE_NORMAL
- en: When you've tested the code in your new branch, you can merge the changes back
    into the branch you started from.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can view the branches with the `git branch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The current branch is highlighted with an asterisk (`*`).
  prefs: []
  type: TYPE_NORMAL
- en: Merging branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After you've edited, added, tested, and committed, you'll want to merge your
    changes back into the initial branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you''ve created a new branch and added and committed your changes, change
    back to the original branch and use the `git merge` command to merge the changes
    in your new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first `git checkout` command retrieves the snapshot for the starting branch.
    The second `git checkout` command marks your current working code as also being
    a new branch.
  prefs: []
  type: TYPE_NORMAL
- en: The `git commit` command (or commands) move the snapshot pointer for the new
    branch further and further away from the original branch. The third `git checkout`
    command restores your code to the initial state before you made your edits and
    commits.
  prefs: []
  type: TYPE_NORMAL
- en: The `git merge` command moves the snapshot pointer for the initial branch to
    the snapshot of the branch you are merging.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you merge a branch, you may not need it any longer. The `-d` option will
    delete the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sharing your work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git lets you work without connecting to the Internet. Eventually, you'll want
    to share your work.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to do this, creating a patch or pushing your new code to
    the master repository.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making a patch...**'
  prefs: []
  type: TYPE_NORMAL
- en: A patch file is a description of the changes that have been committed. Another
    developer can apply your patch files to their code to use your new code.
  prefs: []
  type: TYPE_NORMAL
- en: The format-patch command will collect your changes and create one or more patch
    files. The patch files will be named with a number, a description and `.patch`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The format-patch command requires an identifier to tell Git what the first patch
    should be. Git will create as many patch files as it needs to change code from
    what it was then to what it should be.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to identify the starting snapshot. One common use for
    a set of patches is to submit the changes you've made to a given branch to the
    package maintainer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you've created a new branch off the master for a new feature.
    When you've completed your testing, you may send a set of patch files to the project
    maintainer so they can validate your work and merge the new feature into the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `format-patch` sub-command with the name of a parent branch will generate
    the patch file to create your current branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Another common identifier is a git snapshot **SHA1**. Each git snapshot is identified
    by an SHA1 string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view a log of all the commits in your repository with the `git log`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git format-patch` command with an SHA1 identifier looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a unique leading segment of the SHA1 identifier or the full, long
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also identify a snapshot by its distance from your current location
    with a `-#` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will make a patch file for the most recent change to the master
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will make a patch file for the two most recent changes to the
    `bleedingEdge` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Applying a patch**'
  prefs: []
  type: TYPE_NORMAL
- en: The `git apply` command applies a patch to your working code set. You'll have
    to check out the appropriate snapshot before running this command.
  prefs: []
  type: TYPE_NORMAL
- en: You can test that the patch is valid with the `--check` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your environment is correct for this patch, there will be no return. If
    you don''t have the correct branch checked out, the patch `-check` command will
    generate an error condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `--check` option does not generate an error message, use the `git
    apply` command to apply the patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Pushing a branch to a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eventually, you'll want to share your new code with everyone, not just send
    patches to individuals.
  prefs: []
  type: TYPE_NORMAL
- en: The `git push` command will push a branch to the master.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a unique branch, it can always be pushed to the master repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve modified an existing branch, you may receive an error message as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remote: error`: Refusing to update checked out branch: `refs/heads/master`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote: error`: By default, updating the current branch in a non-bare repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, you need to push your changes to a new branch on the remote site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to alert the package maintainer to merge this branch into
    the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving the latest sources for the current branch. If there are multiple
    developers on a project, you'll need to synchronize with the remote repository
    occasionally to retrieve data that's been pushed by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: The `get fetch` and `git pull` commands will download data from the remote site
    to your local repository.
  prefs: []
  type: TYPE_NORMAL
- en: Update your repository without changing the working code.
  prefs: []
  type: TYPE_NORMAL
- en: The `git fetch` and `git pull` command will download new code but not modify
    your working code set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The site you cloned your repository from is named origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch from another developer''s repository, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Update your repository and the working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git pull` command performs a fetch and then merges the changes into your
    current code. This will fail if there are conflicts you need to resolve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Checking the status of a git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a concentrated development and debugging session you are likely to forget
    all the changes you've made.  The `>git status` command will remind you.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git status` command reports the current status of your project. It will
    tell you what branch you are on, whether you have uncommitted changes and whether
    you are out of sync with the origin repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe shows `git status` output when a change has been added and
    committed and one file was modified but not yet committed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line indicates that there has been a commit that hasn''t been pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines in this format report on files that have been modified, but not yet committed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the identity used for this commit is wrong, you can fix it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Viewing git history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start working on a project, you should review what's been done. You
    may need to review what's been done recently to keep up with other developer's
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The `git log` command generates a report to help you keep up with a project's
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git log` command generates a report of SHA1 IDs, the author who committed
    that snapshot, the date it was committed, and the log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finding bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even the best testing groups let bugs slip out into the field. When that happens,
    it's up to the developers to figure out what the bug is and how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Git has tools to help.
  prefs: []
  type: TYPE_NORMAL
- en: Nobody deliberately creates bugs, so the problem is probably caused by fixing
    an old bug or adding a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: If you can isolate the code that causes the issue, use the `git blame` command
    to find who committed the code that caused the problem and what the commit SHA
    code was.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git blame` command returns a list of commit hash codes, author, date,
    and the first line of the commit message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a test that indicates the problem, but don't know the line of code
    that's at issue, you can use the `git bisect` command to find the commit that
    introduced the problem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git bisect` command requires two identifiers, one for the last known good
    code and one for the bad release. The bisect command will identify a revision
    midway between the good and bad for you to test.
  prefs: []
  type: TYPE_NORMAL
- en: After you test the code, you reset the good or bad pointer. If the test worked,
    reset the good pointer, if the test failed, reset the bad pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git will then check out a new snapshot midway between the new good and bad
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git bisect` command identifies the version of your code midway between
    a known good and known bad version. You can now build and test that version. After
    testing, rerun `git bisect` to declare that branch as good or bad. After the branch
    is declared, `git bisect` will identify a new version, halfway between the new
    good and bad markers.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git supports tagging specific snapshots with a mnemonic string and an additional
    message. You can use the tags to make the development tree clearer with information
    such as *Merged in new memory management* or to mark specific snapshots along
    a branch. For example, you can use a tag to mark **release-1.0** and **release-1.1**
    along the **release-1** branch.
  prefs: []
  type: TYPE_NORMAL
- en: Git supports both lightweight tags (just tagging a snapshot) and tags with associated
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git tags are local only. `git push` will not push your tags by default. To
    send tags to the origin repository, you must include the -tags option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `git tag` command has options to add, delete, and list tags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git tag` command with no argument will list the visible tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a tag on your current checkout by adding a tag name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a tag to a previous commit by appending an SHA-1 identifier to
    the git tag command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-a` option will attach annotation to a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define the message on the command line with the `-m` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The message will be displayed when you use the `git show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-d` option will delete a tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Committing message ethics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The commit message is free form text. It can be whatever you think is useful.
    However, there are comment conventions used in the Git community.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use 72 characters or less on each line. Use blank lines to separate paragraphs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line should be 50 characters or less and summarize why this commit
    was made. It should be specific enough that someone reading just this line will
    understand what happened.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don''t write `Fix bug` or even `Fix bugzilla bug #1234`, write `Remove silly
    messages that appear each April 1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following paragraphs describe details that will be important to someone
    following up on your work. Mention any global state variables your code uses,
    side effects, and so on. If there is a description of the problem you fixed, include
    the URL for the bug report or feature request.
  prefs: []
  type: TYPE_NORMAL
- en: Using fossil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fossil application is another distributed version control system. Like Git,
    it maintains a record of changes regardless of whether the developer has access
    to the master repository site. Unlike Git, fossil supports an auto-sync mode that
    will automatically push commits to the remote repository if it's accessible. If
    the remote site is not available at commit time, fossil saves the changes until
    the remote site becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Fossil differs from Git in several respects. The fossil repository is implemented
    in a single SQLite database instead of a set of folders as Git is implemented.
    The fossil application includes several other tools such as a web interface, a
    trouble-ticket system, and a wiki, while Git uses add-on applications to provide
    these services.
  prefs: []
  type: TYPE_NORMAL
- en: Like Git, the main interface to fossil is the `fossil` command with subcommands
    to perform specific actions like creating a new repository, cloning an existing
    repository, adding, committing files, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fossil includes a help facility. The fossil help command will generate a list
    of supported commands, and `fossil help CMDNAME` will display a help page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fossil may not be installed on your system, and is not maintained by all repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The definitive site for fossil is [h t t p ://w w w . f o s s i l - s c m .
    o r g](http://www.fossil-scm.org) .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download a copy of the fossil executable for your platform from [http://www.fossil-scm.org](http://www.fossil-scm.org)
    and move it to your `bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new fossil repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fossil is easy to set up and use for your own projects as well as existing projects
    that you join.
  prefs: []
  type: TYPE_NORMAL
- en: The `fossil new` and `fossil init` commands are identical. You can use either
    depending on your preference.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fossil new` and `fossil init` commands create an empty fossil repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fossil init` and fossil new commands are the same. They create a new empty
    repository database with the name you request. The `.fossil` suffix is not required,
    but it's a common convention.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us look at some more recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Web interface to fossil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fossil web server provides either local or remote access to many features
    of the fossil system including configuration, trouble ticket management, a wiki,
    graphs of the commit history, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The `fossil ui` command starts an http server and attempts to connect your local
    browser to the fossil server. By default, this interface connects you to the UI
    and you can perform any required task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Making a repository available to remote users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fossil server command starts a fossil server that allows a remote user to
    clone your repository. By default, fossil allows anyone to clone a project. Disable
    the checkin, checkout, clone, and download zip capabilities on the `Admin/Users/Nobody`
    and `Admin/Users/Anonymous` pages to restrict access to only registered users.
  prefs: []
  type: TYPE_NORMAL
- en: The web interface for configuration is supported when running fossil server,
    but instead of being the default, you must log in using the credentials provided
    when you created the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fossil server can be started with a full path to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The fossil server can be started from a folder with the fossil repository without
    defining the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Cloning a remote fossil repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because the fossil repository is contained in a single file, you can clone it
    simply by copying that file. You can send a fossil repository to another developer
    as an e-mail attachment, put it on a website, or copy it to a USB memory stick.
  prefs: []
  type: TYPE_NORMAL
- en: The fossil scrub command removes user and password information that the web
    server may require from the database. This step is recommended before you distribute
    copies of your repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can clone fossil from a site running fossil in the server mode with the
    fossil clone command. The fossil clone command distributes the version history,
    but not the users and password information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fossil clone command copies the repository from the site you''ve specified
    to a local file with a name you provide (in the example: `projectName.fossil`).'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a fossil project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fossil open command extracts the files from a repository. It's usually simplest
    to create a subfolder under the folder with the fossil repository to hold the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Download the fossil repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a new folder for your working directory and change to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the repository in your working folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fossil open command extracts all the folders, subfolders, and files that
    have been checked into the fossil repository.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use fossil open to extract specific revisions of the code in the repository.
    This example shows how to check out the 1.0 release to fix an old bug. Make a
    new folder for your working directory and change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the repository in your working folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Adding and committing changes with fossil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've created a repository, you want to add and edit files. The fossil
    add command adds a new file to a repository and the fossil commit command commits
    changes to the repository. This is different from Git in which the `add` command
    marks changes to be added and the commit command actually does the commit.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next examples show how fossil behaves if you have not defined the `EDITOR`
    or `VISUAL` shell variables. If `EDITOR` or `VISUAL` are defined, fossil will
    use that editor instead of prompting you on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you edit a file you only need to commit. By default, the commit will remember
    all your changes to the local repository. If auto-sync is enabled, the commit
    will also be pushed to the remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Using branches and forks with fossil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, a development tree is a straight line with one revision following
    directly from the previous. In reality, developers frequently work from a stable
    code base and make changes that are then merged back into the mainline development.
  prefs: []
  type: TYPE_NORMAL
- en: The fossil system distinguishes temporary divergences from the mainline code
    (for example, a bug fix in your repository) from permanent divergences (like the
    1.x release that gets only bug fixes, while new features go into 2.x).
  prefs: []
  type: TYPE_NORMAL
- en: The convention in fossil is to refer to intentional divergences as branches
    and unintentional divergences as forks. For example, you might create a branch
    for a new code you are developing, while trying to commit a change to a file after
    someone else has committed a change to that file would cause a fork unless you
    first update and resolve collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Branches can be temporary or permanent. A temporary branch might be one you
    create while developing a new feature. A permanent branch is when you make a release
    that is intended to diverge from the mainline code.
  prefs: []
  type: TYPE_NORMAL
- en: Both temporary and permanent branches are managed with tags and properties.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a fossil repository with fossil `init` or fossil new, it assigns
    the tag `trunk` to the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The fossil branch command manages branches. There are subcommands to create
    new branches, list branches, and close branches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in working with branches is to create one. The fossil branch
    new command creates a new branch. It can either create a branch based on your
    current checkout of the project, or you can create a branch at an earlier state
    of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fossil branch new command will create a new branch from a given checkin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `Basis-Id` is an identifier to tell fossil what code snapshot to branch
    from. There are several ways to define the `Basis-Id`. The most common of these
    are discussed in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that you need to perform a checkout to update your working folder to the
    new branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NewBranchName` is the name for your new branch. A convention is to name branches
    in a way that describes the modification being made. Branch names such as `localtime_fixes`
    or `bug_1234_fix` are common.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Basis-Id` is a string that identifies the node where the branch diverges.
    This can be the name of a branch if you are diverging from the head of a given
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands show how to create a branch from the tip of a trunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The fossil commit command allows you to specify a new branch name at commit
    time with the `--branch` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Merging forks and branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Branches and forks can both be merged back into their parent branch. The forks
    are considered temporary and should be merged as soon as the modifications are
    approved. Branches are considered permanent, but even these may be merged back
    into the mainline code.
  prefs: []
  type: TYPE_NORMAL
- en: The fossil merge command will merge a temporary fork into another branch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a temporary fork and merge it back into an existing branch, you must
    first check out the branch you intend to work on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can edit and test. When you''re satisfied with the new code, commit
    the new code onto a new branch. The `--branch` option creates a new branch if
    necessary and sets your current branch to the new `branch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After the code has been tested and verified, you can merge it back into the
    appropriate branch by performing a checkout of the branch you want to merge into,
    then invoke the fossil merge command to schedule the merge, and finally commit
    the merge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Fossil and Git behave slightly differently in this respect. The `git merge`
    command updates the repository, while the fossil merge command doesn't modify
    the repository until the merge is committed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sharing your work with fossil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use multiple platforms for development, or if you work on someone else's
    project, you need to synchronize your local repository with the remote, master
    repository. Fossil has several ways to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default fossil runs in the `autosync` mode. In this mode, your commits are
    immediately propagated to the remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `autosync` setting can be enabled and disabled with the fossil setting
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When `autosync` is disabled (fossil is running in manual merge mode), you must
    use the fossil push command to send changes in your local repository to the remote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `push` command pushes all changes in your local repository to the remote
    repository. It does not modify any checked out code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your local fossil repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flip side of pushing your work to the remote repository is updating your
    local repository. You'll need to do this if you do some development on your laptop
    while the main repository is on your companies server, or if you are working on
    a project with multiple people and you need to keep up to date on their new features.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fossil server does not push updates to remote repositories automatically.
    The `fossil pull` command will pull updates to your repository. It updates the
    repository, but does not change your working code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fossil checkout` command will update your working code if there were changes
    in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine the pull and checkout subcommands with the `fossil update`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Checking the status of a fossil repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you start any new development, you should compare the state of your local
    repository to the master repository. You don't want to waste time writing code
    that conflicts with code that's been accepted.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fossil status` command will report the current status of your project,
    whether you have uncommitted edits and whether your working code is at the tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If there has been a commit made to the branch you''re working on since your
    last checkout, the status will include a line resembling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that there is a commit after your code. You will have to do a
    `fossil update` to bring your working copy of the code into sync before you can
    commit to the head of the branch. This may require you to fix conflicts by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Note that fossil can only report the data in your local repository. If commits
    have been made but not pushed to the server and pulled into your local repository,
    they won't be displayed. You should invoke `fossil sync` before `fossil status`
    to confirm that your repository has all the latest information.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing fossil history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fossil server` and `fossil ui` commands start fossil's web server and let
    you view the history of check-ins and navigate through code via your favorite
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: The timeline tab provides a tree-structured view of the branches, commits, and
    merges. The web interface supports viewing the source code associated with the
    commits and performing diffs between different versions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start fossil in the UI mode. It will try to find your browser and open the
    main page. If that fails, you can point your browser to fossil:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/image_06_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding bugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fossil provides tools to help locate the commit where a bug was introduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tools** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `fossil diff` | This displays the difference between two revisions of a file
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fossil blame` | This generates a report showing the commit information for
    each line in a file |'
  prefs: []
  type: TYPE_TB
- en: '| `fossil bisect` | This uses binary search to step between good and bad versions
    of an application |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fossil diff` command has several options. When looking for the code that
    introduced a problem, we generally want to perform a diff on two versions of a
    file. The `-from` and `-to` options to `fossil diff` perform this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`ID-1` and `ID-2` are identifiers used in the repository. They may be SHA-1
    hashes, tags or dates, and so on. The `FILENAME` is the file that was committed
    to fossil.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to find the difference between two revisions of `main.tcl` use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The differences between two revisions are useful, but it's more useful to see
    the entire file annotated to show when lines were added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fossil blame` command generates an annotated listing of a file showing
    when lines were added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: When you know that there's a problem in one version but not in another, you
    need to center in on the version where the problem was introduced.
  prefs: []
  type: TYPE_NORMAL
- en: The `fossil bisect` command provides support for this. It lets you define a
    good and bad version of the code and automatically checks out the version between
    those to be tested. You can then mark this version as good or bad and fossil will
    repeat the process. Fossil bisect also generates reports showing how many versions
    have been tested and how many need to be tested.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fossil bisect reset` command initializes the good and bad pointers. The
    `fossil bisect good` and `fossil bisect bad` commands mark versions as good or
    bad and check out the version of the code that''s midway between the good and
    bad version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: After testing the `f64ca` version of the code, you can mark it good or bad and
    `fossil bisect` will check out the next version for testing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fossil bisect status` command generates a report of the available versions
    and marks the tested versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Tagging snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every node in the fossil graph can have one or more tags attached to it. Tags
    can identify releases, branches, or just particular milestones that you may want
    to refer to. For example, you may want a release-1 branch with tags for release-1.0,
    release-1.1, and so on. A tag can be used with checkout or merge instead of using
    the SHA1 identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Tags are implemented with the fossil tag command. Fossil supports several subcommands
    to add, cancel, find, and list tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fossil tag add` command creates a new tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TagName` is whatever you want to call the branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifier is an identifier for the node to be tagged. The identifier can be
    one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A branch name**: Tag the most recent commit on this branch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**An SHA1 identifier**: Tag the commit with this SHA1 identifier'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A datestamp (YYYY-MM-DD)**: Tag the commit just previous to this datestamp'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A timestamp (YYYY-MM-DD HH:MM:SS)**: Tag the commit just previous to this
    timestamp'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tag can be used as an identifier to create a fork or branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'A tag can create a branch with a commit and the `-branch` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
