["```\n/* mandatory, the core */\n#include <linux/iio/iio.h>\n/* mandatory since sysfs is used */\n#include <linux/iio/sysfs.h>\n/* Optional. Advanced feature, to manage iio events */\n#include <linux/iio/events.h> \n/* mandatory for triggered buffers */\n#include <linux/iio/buffer.h>\n/* rarely used. Only if the driver implements a trigger */\n#include <linux/iio/trigger.h>\n```", "```\nstruct iio_dev {\n    [...]\n    int             modes;\n    int             currentmode;\n    struct device   dev;\n    struct iio_buffer           *buffer;\n    int                         scan_bytes;\n    const unsigned long         *available_scan_masks;\n    const unsigned long         *active_scan_mask;\n    bool                        scan_timestamp;\n    struct iio_trigger          *trig;\n    struct iio_poll_func        *pollfunc;\n    struct iio_chan_spec const  *channels;\n    int                         num_channels;\n    const char                  *name;\n    const struct iio_info       *info;\n    const struct iio_buffer_setup_ops   *setup_ops;\n    struct cdev                 chrdev;\n};\n```", "```\n    /*\n     * Bitmasks 0x7 (0b111) and 0 (0b000) are allowed.\n     * It means one can enable none or all of them.\n     * You can't for example enable only channel X and Y\n     */\n    static const unsigned long my_scan_masks[] = {0x7, 0};\n    indio_dev->available_scan_masks = my_scan_masks;\n    ```", "```\n    struct iio_buffer_setup_ops {\n        int (* preenable) (struct iio_dev *);\n        int (* postenable) (struct iio_dev *);\n        int (* predisable) (struct iio_dev *);\n        int (* postdisable) (struct iio_dev *);\n        bool (* validate_scan_mask) (\n                         struct iio_dev *indio_dev,\n                         const unsigned long *scan_mask);\n    };\n    ```", "```\nstruct iio_dev *devm_iio_device_alloc(struct device *dev,\n                                       int sizeof_priv)\n```", "```\nint devm_iio_device_register(struct device *dev,\n                             struct iio_dev *indio_dev);\n```", "```\nstatic int ad7476_probe(struct spi_device *spi)\n{\n    struct ad7476_state *st;\n    struct iio_dev *indio_dev;\n    int ret;\n    indio_dev = devm_iio_device_alloc(&spi->dev, \n                                        sizeof(*st));\n    if (!indio_dev)\n         return -ENOMEM;\n    /* st is given the address of reserved memory for\n    * private data \n    */\n    st = iio_priv(indio_dev);\n    [...]\n    /* iio device setup */\n    indio_dev->name = spi_get_device_id(spi)->name;\n    indio_dev->modes = INDIO_DIRECT_MODE;\n    indio_dev->num_channels = 2;\n    [...]\n    return devm_iio_device_register(&spi->dev, indio_dev);\n}\n```", "```\nvoid iio_device_unregister(struct iio_dev *indio_dev)\n```", "```\nstruct my_private_data *the_data = iio_priv(indio_dev);\n```", "```\nstruct iio_info {\n    const struct attribute_group  *attrs;\n    int (*read_raw)(struct iio_dev *indio_dev,\n            struct iio_chan_spec const *chan,\n            int *val, int *val2, long mask);\n    int (*write_raw)(struct iio_dev *indio_dev,\n             struct iio_chan_spec const *chan,\n             int val, int val2, long mask);\n    [...]\n};\n```", "```\nstatic const struct iio_info iio_dummy_info = {\n    .read_raw = &iio_dummy_read_raw,\n    .write_raw = &iio_dummy_write_raw,\n    [...]\n};\n/*\n * Provide device type specific interface functions and\n * constant data.\n */\nindio_dev->info = &iio_dummy_info;\n```", "```\nstruct iio_chan_spec {\n    enum iio_chan_type    type;\n    int               channel;\n    int               channel2;\n    unsigned long     address;\n    int               scan_index;\n    struct {\n        char sign;\n        u8   realbits;\n        u8   storagebits;\n        u8   shift;\n        u8   repeat;\n        enum iio_endian endianness;\n    } scan_type;\n    long              info_mask_separate;\n    long              info_mask_shared_by_type;\n    long              info_mask_shared_by_dir;\n    long              info_mask_shared_by_all;\n    const struct iio_event_spec *event_spec;\n    unsigned int      num_event_specs;\n    const struct iio_chan_spec_ext_info *ext_info;\n    const char        *extend_name;\n    const char        *datasheet_name;\n    unsigned          modified:1;\n    unsigned          indexed:1;\n    unsigned          output:1;\n    unsigned          differential:1;\n};\n```", "```\nenum iio_chan_info_enum {\n    IIO_CHAN_INFO_RAW = 0,\n    IIO_CHAN_INFO_PROCESSED,\n    IIO_CHAN_INFO_SCALE,\n    IIO_CHAN_INFO_OFFSET,\n    IIO_CHAN_INFO_CALIBSCALE,\n    [...]\n    IIO_CHAN_INFO_SAMP_FREQ,\n    IIO_CHAN_INFO_FREQUENCY,\n    IIO_CHAN_INFO_PHASE,\n    IIO_CHAN_INFO_HARDWAREGAIN,\n    IIO_CHAN_INFO_HYSTERESIS,\n    [...]\n};\n```", "```\niio_chan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |\n                    BIT(IIO_CHAN_INFO_PROCESSED);\n```", "```\n    static const char * const iio_direction[] = {\n        [0] = \"in\",\n        [1] = \"out\",\n    };\n    ```", "```\n    static const char * const iio_chan_type_name_spec[] = {\n        [IIO_VOLTAGE] = \"voltage\",\n        [IIO_CURRENT] = \"current\",\n        [IIO_POWER] = \"power\",\n        [IIO_ACCEL] = \"accel\",\n        [...]\n        [IIO_UVINDEX] = \"uvindex\",\n        [IIO_ELECTRICALCONDUCTIVITY] =\n                      \"electricalconductivity\",\n        [IIO_COUNT] = \"count\",\n        [IIO_INDEX] = \"index\",\n        [IIO_GRAVITY] = \"gravity\",\n    };\n    ```", "```\n    static const char * const iio_modifier_names[] = {\n        [IIO_MOD_X] = \"x\",\n        [IIO_MOD_Y] = \"y\",\n        [IIO_MOD_Z] = \"z\",\n        [IIO_MOD_X_AND_Y] = \"x&y\",\n        [IIO_MOD_X_AND_Z] = \"x&z\",\n        [IIO_MOD_Y_AND_Z] = \"y&z\",\n        [...]\n        [IIO_MOD_CO2] = \"co2\",\n        [IIO_MOD_VOC] = \"voc\",\n    };\n    ```", "```\n    /* relies on pairs of these shared then separate */\n    static const char * const iio_chan_info_postfix[] = {\n         [IIO_CHAN_INFO_RAW] = \"raw\",\n         [IIO_CHAN_INFO_PROCESSED] = \"input\",\n         [IIO_CHAN_INFO_SCALE] = \"scale\",\n         [IIO_CHAN_INFO_CALIBBIAS] = \"calibbias\",\n         [...]\n         [IIO_CHAN_INFO_SAMP_FREQ] = \"sampling_frequency\",\n         [IIO_CHAN_INFO_FREQUENCY] = \"frequency\",\n         [...]\n    };\n    ```", "```\nstatic const struct iio_chan_spec adc_channels[] = {\n        {\n             .type = IIO_VOLTAGE,\n             .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n        },\n}\n```", "```\nstatic const struct iio_chan_spec adc_channels[] = {\n    {\n        .type = IIO_VOLTAGE,\n        .indexed = 1,\n        .channel = 0,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n    },\n    {\n        .type = IIO_VOLTAGE,\n        .indexed = 1,\n        .channel = 1,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n    },\n    {\n        .type = IIO_VOLTAGE,\n        .indexed = 1,\n        .channel = 2,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n    },\n    {\n        .type = IIO_VOLTAGE,\n        .indexed = 1,\n        .channel = 3,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n    },\n}\n```", "```\n/sys/bus/iio/iio:deviceX/in_voltage0_raw\n/sys/bus/iio/iio:deviceX/in_voltage1_raw\n/sys/bus/iio/iio:deviceX/in_voltage2_raw\n/sys/bus/iio/iio:deviceX/in_voltage3_raw\n```", "```\nstatic const struct iio_chan_spec mylight_channels[] = {\n    {\n        .type = IIO_INTENSITY,\n        .modified = 1,\n        .channel2 = IIO_MOD_LIGHT_IR,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n    },\n    {\n        .type = IIO_INTENSITY,\n        .modified = 1,\n        .channel2 = IIO_MOD_LIGHT_BOTH,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),\n        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n    },\n    {\n        .type = IIO_LIGHT,\n        .info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),\n        .info_mask_shared = BIT(IIO_CHAN_INFO_SAMP_FREQ),\n    },\n}\n```", "```\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/iio/iio.h>\n```", "```\n#define FAKE_VOLTAGE_CHANNEL(num)                \\\n  {                                              \\\n     .type = IIO_VOLTAGE,                        \\\n     .indexed = 1,                               \\\n     .channel = (num),                           \\\n     .address = (num),                           \\\n     .info_mask_separate = BIT(IIO_CHAN_INFO_RAW),        \\\n     .info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE) \\\n  }\n```", "```\nstruct my_private_data {\n    int foo;\n    int bar;\n    struct mutex lock;\n};\n```", "```\nstatic int fake_read_raw(struct iio_dev *indio_dev,\n    struct iio_chan_spec const *channel, int *val,\n    int *val2, long mask)\n{\n    return 0;\n}\nstatic int fake_write_raw(struct iio_dev *indio_dev,\n                     struct iio_chan_spec const *chan,\n                     int val, int val2, long mask)\n{\n    return 0;\n}\n```", "```\nstatic const struct iio_chan_spec fake_channels[] = {\n     FAKE_VOLTAGE_CHANNEL(0),\n     FAKE_VOLTAGE_CHANNEL(1),\n     FAKE_VOLTAGE_CHANNEL(2),\n     FAKE_VOLTAGE_CHANNEL(3),\n};\nstatic const struct iio_info fake_iio_info = {\n     .read_raw  = fake_read_raw,\n     .write_raw = fake_write_raw,\n     .driver_module = THIS_MODULE,\n};\n```", "```\nstatic const struct of_device_id iio_dummy_ids[] = {\n    { .compatible = \"packt,iio-dummy-random\", },\n    { /* sentinel */ }\n};\nstatic int my_pdrv_probe (struct platform_device *pdev)\n{\n     struct iio_dev *indio_dev;\n     struct my_private_data *data;\n     indio_dev = devm_iio_device_alloc(&pdev->dev,\n                                      sizeof(*data));\n     if (!indio_dev) {\n        dev_err(&pdev->dev, \"iio allocation failed!\\n\");\n        return -ENOMEM;\n     }\n    data = iio_priv(indio_dev);\n    mutex_init(&data->lock);\n    indio_dev->dev.parent = &pdev->dev;\n    indio_dev->info = &fake_iio_info;\n    indio_dev->name = KBUILD_MODNAME;\n    indio_dev->modes = INDIO_DIRECT_MODE;\n    indio_dev->channels = fake_channels;\n    indio_dev->num_channels = ARRAY_SIZE(fake_channels);\n    indio_dev->available_scan_masks = 0xF;\n    devm_iio_device_register(&pdev->dev, indio_dev);\n    platform_set_drvdata(pdev, indio_dev);\n    return 0;\n}\n```", "```\nstatic struct platform_driver my_iio_pdrv = {\n    .probe      = my_pdrv_probe,\n    .driver     = {\n        .name     = \"iio-dummy-random\",\n        .of_match_table = of_match_ptr(iio_dummy_ids),  \n        .owner    = THIS_MODULE,\n    },\n};\nmodule_platform_driver(my_iio_pdrv);\nMODULE_AUTHOR(\"John Madieu <john.madieu@labcsmart.com>\");\nMODULE_LICENSE(\"GPL\");\n```", "```\n~# ls -l /sys/bus/iio/devices/\nlrwxrwxrwx    1 root     root             0 Jul 31 20:26 iio:device0 -> ../../../devices/platform/iio-dummy-random.0/iio:device0\nlrwxrwxrwx    1 root     root             0 Jul 31 20:23 iio_sysfs_trigger -> ../../../devices/iio_sysfs_trigger\n\n~# ls /sys/bus/iio/devices/iio\\:device0/\ndev                              in_voltage2_raw        name                uevent\nin_voltage0_raw        in_voltage3_raw        power\nin_voltage1_raw        in_voltage_scale        subsystem\n~# cat /sys/bus/iio/devices/iio:device0/name \niio_dummy_random\n```", "```\n    const struct iio_buffer_setup_ops sensor_buffer_setup_ops = {\n      .preenable    = my_sensor_buffer_preenable,\n      .postenable   = my_sensor_buffer_postenable,\n      .postdisable  = my_sensor_buffer_postdisable,\n      .predisable   = my_sensor_buffer_predisable,\n    };\n    ```", "```\n    irqreturn_t sensor_iio_pollfunc(int irq, void *p)\n    {\n        pf->timestamp = iio_get_time_ns(\n                           (struct indio_dev *)p);\n        return IRQ_WAKE_THREAD;\n    }\n    ```", "```\n    irqreturn_t sensor_trigger_handler(int irq, void *p)\n    {\n        u16 buf[8];\n        int bit, i = 0;\n        struct iio_poll_func *pf = p;\n        struct iio_dev *indio_dev = pf->indio_dev;\n        /* one can use lock here to protect the buffer */\n        /* mutex_lock(&my_mutex); */\n        /* read data for each active channel */\n        for_each_set_bit(bit, indio_dev->active_scan_mask,\n                         indio_dev->masklength)\n            buf[i++] = sensor_get_data(bit);\n        /*\n         * If iio_dev.scan_timestamp = true, the capture \n         * timestamp will be pushed and stored too, \n         * as the last element in the sample data buffer \n         * before pushing it to the device buffers.\n         */\n        iio_push_to_buffers_with_timestamp(indio_dev, buf,\n                                            timestamp);\n        /* Please unlock any lock */\n        /* mutex_unlock(&my_mutex); */\n        /* Notify trigger */\n        iio_trigger_notify_done(indio_dev->trig);\n        return IRQ_HANDLED;\n    }\n    ```", "```\n    iio_triggered_buffer_setup(\n        indio_dev, sensor_iio_pollfunc,\n        sensor_trigger_handler,\n        sensor_buffer_setup_ops);\n    ```", "```\nstatic int my_read_raw(struct iio_dev *indio_dev,\n               const struct iio_chan_spec *chan,\n               int *val, int *val2, long mask)\n{\n    [...]\n    switch (mask) {\n    case IIO_CHAN_INFO_RAW:\n        if (iio_buffer_enabled(indio_dev))\n            return -EBUSY;\n    [...]    \n}\n```", "```\nstatic bool iio_buffer_enabled(struct iio_dev *indio_dev)\n{\n   return indio_dev->currentmode\n       & (INDIO_BUFFER_TRIGGERED | INDIO_BUFFER_HARDWARE |\n           INDIO_BUFFER_SOFTWARE);\n} \n```", "```\n    echo 2 > remove_trigger\n    ```", "```\n# set trigger2 as current trigger for device0\necho sysfstrig2 > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n```", "```\necho \"\" > iio:device0/trigger/current_trigger\n```", "```\nstatic struct resource iio_irq_trigger_resources[] = {\n    [0] = {\n        .start = IRQ_NR_FOR_YOUR_IRQ,\n        .flags = IORESOURCE_IRQ | IORESOURCE_IRQ_LOWEDGE,\n    },\n};\nstatic struct platform_device iio_irq_trigger = {\n    .name = \"iio_interrupt_trigger\",\n    .num_resources = ARRAY_SIZE(iio_irq_trigger_resources),\n    .resource = iio_irq_trigger_resources,\n};\nplatform_device_register(&iio_irq_trigger);\n```", "```\n$ cd /sys/bus/iio/devices/trigger0/\n$ cat name\n    irqtrig85\n```", "```\necho \"irqtrig85\" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n```", "```\nmylabel: my_trigger@0{\n    compatible = \"iio_interrupt_trigger\";\n    interrupt-parent = <&gpio4>;\n    interrupts = <30 0x0>;\n};\n```", "```\n$ mkdir /config\n$ mount -t configfs none /config\n```", "```\n# create a hrtimer trigger\n$ mkdir /config/iio/triggers/hrtimer/my_trigger_name\n# remove the trigger\n$ rmdir /config/iio/triggers/hrtimer/my_trigger_name\n```", "```\n   7   6   5   4   3   2   1   0\n +---+---+---+---+---+---+---+---+\n |D3 |D2 |D1 |D0 | X | X | X | X | (LOW byte, address 0x06)\n +---+---+---+---+---+---+---+---+\n   7   6   5   4   3   2   1   0\n +---+---+---+---+---+---+---+---+\n |D11|D10|D9 |D8 |D7 |D6 |D5 |D4 |(HIGH byte, address 0x07)\n +---+---+---+---+---+---+---+---+\n```", "```\n$ cat  /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_y_type\nle:s12/16>>4\n```", "```\nstruct iio_chan_spec {\n    [...]\n    struct {\n        char sign; /* either u or s as explained above */\n        u8 realbits;\n        u8 storagebits;\n        u8 shift;\n        u8 repeat;\n        enum iio_endian endianness;\n    } scan_type;\n    [...]\n};\n```", "```\nstruct struct iio_chan_spec accel_channels[] = {\n    {\n        .type = IIO_ACCEL,\n        .modified = 1,\n        .channel2 = IIO_MOD_X,\n        /* other stuff here */\n        .scan_index = 0,\n        .scan_type = {\n            .sign = 's',\n            .realbits = 12,\n            .storagebits = 16,\n            .shift = 4,\n            .endianness = IIO_LE,\n            },\n    }\n    /* similar for Y (with channel2 = IIO_MOD_Y, \n     * scan_index = 1) and Z (with channel2 \n     * = IIO_MOD_Z, scan_index = 2) axis \n     */\n}\n```", "```\n#define BMA220_DATA_SHIFT        2\n#define BMA220_DEVICE_NAME       \"bma220\"\n#define BMA220_SCALE_AVAILABLE   \"0.623 1.248 2.491 4.983\"\n#define BMA220_ACCEL_CHANNEL(index, reg, axis) {    \\ \n    .type = IIO_ACCEL,                            \\\n    .address = reg,                               \\\n    .modified = 1,                                \\\n    .channel2 = IIO_MOD_##axis,                   \\\n    .info_mask_separate = BIT(IIO_CHAN_INFO_RAW), \\\n    .info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),\\\n    .scan_index = index,                          \\\n    .scan_type = {                                \\\n         .sign = 's',                             \\\n         .realbits = 6,                           \\\n         .storagebits = 8,                        \\\n         .shift = BMA220_DATA_SHIFT,              \\\n         .endianness = IIO_CPU,                   \\\n    },                                            \\\n}\nstatic const struct iio_chan_spec bma220_channels[] = {\n    BMA220_ACCEL_CHANNEL(0, BMA220_REG_ACCEL_X, X),\n    BMA220_ACCEL_CHANNEL(1, BMA220_REG_ACCEL_Y, Y),\n    BMA220_ACCEL_CHANNEL(2, BMA220_REG_ACCEL_Z, Z),\n};\n```", "```\njma@jma:~$ ls -l /sys/bus/iio/devices/iio:device0/\n(...)\n# without modifier, a channel name would have in_accel_raw (bad)\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_scale\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_x_raw\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_y_raw\n-rw-r--r-- 1 root root 4096 jul 20 14:13 in_accel_z_raw\n(...)\n```", "```\n$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_accel_x_type\nle:s6/8>>2\n```", "```\nstatic irqreturn_t bma220_trigger_handler(int irq, void *p)\n{\n    int ret;\n    struct iio_poll_func *pf = p;\n    struct iio_dev *indio_dev = pf->indio_dev;\n    struct bma220_data *data = iio_priv(indio_dev);\n    struct spi_device *spi = data->spi_device;\n    mutex_lock(&data->lock);\n    data->tx_buf[0] =\n                BMA220_REG_ACCEL_X | BMA220_READ_MASK;\n    ret = spi_write_then_read(spi, data->tx_buf,\n                       1, data->buffer,\n             ARRAY_SIZE(bma220_channels) - 1);\n    if (ret < 0)\n         goto err;\n    iio_push_to_buffers_with_timestamp(indio_dev,\n                           data->buffer, pf->timestamp);\nerr:\n    mutex_unlock(&data->lock);\n    iio_trigger_notify_done(indio_dev->trig);\n    return IRQ_HANDLED;\n}\n```", "```\nstatic int bma220_read_raw(struct iio_dev *indio_dev,\n            struct iio_chan_spec const *chan,\n            int *val, int *val2, long mask)\n{\n    int ret;\n    u8 range_idx;\n    struct bma220_data *data = iio_priv(indio_dev);\n    switch (mask) {\n     case IIO_CHAN_INFO_RAW:\n           /* do not process single-channel read \n            * if buffer mode is enabled\n            */\n           if (iio_buffer_enabled(indio_dev))\n                  return -EBUSY;\n           /* Else we read the channel */\n            ret = bma220_read_reg(data->spi_device,\n                                    chan->address);\n            if (ret < 0)\n                     return -EINVAL;\n             *val = sign_extend32(ret >> BMA220_DATA_SHIFT, \n                                   5);\n             return IIO_VAL_INT;\n     case IIO_CHAN_INFO_SCALE:\n             ret = bma220_read_reg(data->spi_device,\n                                    BMA220_REG_RANGE);\n            if (ret < 0)\n                     return ret;\n             range_idx = ret & BMA220_RANGE_MASK;\n             *val = bma220_scale_table[range_idx][0];\n             *val2 = bma220_scale_table[range_idx][1];\n             return IIO_VAL_INT_PLUS_MICRO;\n    }\n    return -EINVAL;\n}\n```", "```\nstatic int bma220_write_raw(struct iio_dev *indio_dev,\n                  struct iio_chan_spec const *chan,\n                  int val, int val2, long mask)\n{\n     int i;\n     int ret;\n     int index = -1;\n     struct bma220_data *data = iio_priv(indio_dev);\n     switch (mask) {\n     case IIO_CHAN_INFO_SCALE:\n      for (i = 0; i < ARRAY_SIZE(bma220_scale_table); i++)\n      if (val == bma220_scale_table[i][0] &&\n             val2 == bma220_scale_table[i][1]) {\n                 index = i;\n                 break;\n             }\n      if (index < 0)\n        return -EINVAL;\n      mutex_lock(&data->lock);\n      data->tx_buf[0] = BMA220_REG_RANGE;\n      data->tx_buf[1] = index;\n      ret = spi_write(data->spi_device, data->tx_buf,\n            sizeof(data->tx_buf));\n      if (ret < 0)\n           dev_err(&data->spi_device->dev,\n               \"failed to set measurement range\\n\");\n       mutex_unlock(&data->lock);\n      return 0;\n    }\n    return -EINVAL;\n}\n```", "```\nstatic const struct iio_info bma220_info = {\n    .driver_module    = THIS_MODULE,\n    .read_raw         = bma220_read_raw,\n    .write_raw      = bma220_write_raw, \n      /* Only if your needed */\n};\n```", "```\n/*\n * We only provide two mask possibilities, \n * allowing to select none or all channels.\n */\nstatic const unsigned long bma220_accel_scan_masks[] = {\n    BIT(AXIS_X) | BIT(AXIS_Y) | BIT(AXIS_Z),\n    0\n};\nstatic int bma220_probe(struct spi_device *spi)\n{\n    int ret;\n    struct iio_dev *indio_dev;\n    struct bma220_data *data;\n    indio_dev = devm_iio_device_alloc(&spi->dev,\n                                        sizeof(*data));\n    if (!indio_dev) {\n        dev_err(&spi->dev, \"iio allocation failed!\\n\");\n         return -ENOMEM;\n    }\n    data = iio_priv(indio_dev);\n    data->spi_device = spi;\n    spi_set_drvdata(spi, indio_dev);\n    mutex_init(&data->lock);\n     indio_dev->dev.parent = &spi->dev;\n     indio_dev->info = &bma220_info;\n     indio_dev->name = BMA220_DEVICE_NAME;\n     indio_dev->modes = INDIO_DIRECT_MODE;\n     indio_dev->channels = bma220_channels;\n     indio_dev->num_channels = ARRAY_SIZE(bma220_channels);\n     indio_dev->available_scan_masks =\n                                 bma220_accel_scan_masks;\n    ret = bma220_init(data->spi_device);\n    if (ret < 0)\n        return ret;\n    /* this will enable trigger buffer \n     * support for the device */\n    ret = iio_triggered_buffer_setup(indio_dev,\n                            iio_pollfunc_store_time,\n                            bma220_trigger_handler, NULL);\n    if (ret < 0) {\n        dev_err(&spi->dev,\n                    \"iio triggered buffer setup failed\\n\");\n        goto err_suspend;\n    }\n    ret = devm_iio_device_register(&spi->dev, indio_dev);\n    if (ret < 0) {\n        dev_err(&spi->dev, \"iio_device_register \n                              failed\\n\");\n        iio_triggered_buffer_cleanup(indio_dev);\n        goto err_suspend;\n    }\n     return 0;\nerr_suspend:\n    return bma220_deinit(spi);\n}\n```", "```\n# cd /sys/bus/iio/devices/iio:device0\n# cat in_voltage3_raw\n6646 \n# cat in_voltage_scale\n0.305175781\n```", "```\n    echo 0 > /sys/devices/iio_sysfs_trigger/add_trigger\n    ```", "```\n    echo sysfstrig0 >\n    /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n    ```", "```\ncat /sys/bus/iio/devices/trigger0/name > /sys/bus/iio/devices/iio:device0/trigger/current_trigger. \n```", "```\ncat /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n```", "```\n    echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en\n    echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en\n    echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en\n    echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage7_en\n    ```", "```\n    echo 100 > /sys/bus/iio/devices/iio:device0/buffer/length\n    ```", "```\n    echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable\n    ```", "```\n    echo 1 > /sys/bus/iio/devices/trigger0/trigger_now\n    ```", "```\n    echo 0 > /sys/bus/iio/devices/iio:device0/buffer/enable\n    ```", "```\n    echo \"\" > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n    ```", "```\n    cat /dev/iio\\:device0 | xxd –\n    ```", "```\n    mkdir /sys/kernel/config/iio/triggers/hrtimer/trigger0\n    ```", "```\n    echo 50 > /sys/bus/iio/devices/trigger0/sampling_frequency\n    ```", "```\n    echo trigger0 > /sys/bus/iio/devices/iio:device0/trigger/current_trigger\n    ```", "```\n    # echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage4_en\n    # echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage5_en\n    # echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage6_en\n    # echo 1 > /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage7_en\n    ```", "```\n    echo 1 > /sys/bus/iio/devices/iio:device0/buffer/enable\n    ```", "```\n# cat /dev/iio:device0 | xxd -\n0000000: 0188 1a30 0000 0000 8312 68a8 c24f 5a14  ...0......h..OZ.\n0000010: 0188 1a30 0000 0000 192d 98a9 c24f 5a14  ...0.....-...OZ.\n[...]\n```", "```\n$ cat /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage_type\nbe:s14/16>>2\n```", "```\nadc: max1139@35 {\n    compatible = \"maxim,max1139\";\n    reg = <0x35>;\n    #io-channel-cells = <1>;\n};\n```", "```\ndevice {\n    io-channels = <&adc 1>, <&ref 0>;\n    io-channel-names = \"vcc\", \"vdd\";\n};\n```", "```\nsome_consumer {\n    compatible = \"some-consumer\";\n    io-channels = <&adc 10>, <&adc 11>;\n    io-channel-names = \"adc1\", \"adc2\";\n};\n```", "```\nstruct iio_channel *devm_iio_channel_get(\n       struct device *dev, const char *consumer_channel);\nstruct iio_channel * devm_iio_channel_get_all(\n                                      struct device *dev);\nint iio_get_channel_type(struct iio_channel *channel,\n                     enum iio_chan_type *type);\nint iio_read_channel_processed(struct iio_channel *chan,\n                               int *val);\nint iio_read_channel_raw(struct iio_channel *chan,\n                         int *val);\n```", "```\n    iio-hwmon {\n        compatible = \"iio-hwmon\";\n        io-channels = <&adc 0>, <&adc 1>, <&adc 2>,\n        <&adc 3>, <&adc 4>, <&adc 5>,\n        <&adc 6>, <&adc 7>, <&adc 8>,\n        <&adc 9>;\n    };\n    ```", "```\n    struct iio_channel *channels;\n    struct device *dev = &pdev->dev;\n    int num_adc_channels;\n    channels = devm_iio_channel_get_all(dev);\n    if (IS_ERR(channels)) {\n        if (PTR_ERR(channels) == -ENODEV)\n            return -EPROBE_DEFER;\n            return PTR_ERR(channels);\n    }\n    num_adc_channels = 0;\n    /* count how many attributes we have */\n    while (channels[num_adc_channels].indio_dev)\n            num_adc_channels++;\n    if (num_adc_channels !=\n        EXPECTED_ADC_CHAN_COUNT) {\n            dev_err(dev,\n               \"Inadequate ADC channels specified\\n\");\n           return -EINVAL;\n    }\n```", "```\nstruct iio_channel {\n    struct iio_dev *indio_dev;\n    const struct iio_chan_spec *channel;\n    void *data;\n};\n```", "```\niio_create_local_context()\niio_create_network_context()\niio_create_context_from_uri()\niio_context_clone(const struct iio_context *ctx)\n```", "```\n    struct iio_context * local_ctx;\n    local_ctx = iio_create_local_context();\n    ```", "```\n    struct iio_context * network_ctx;\n    network_ctx =\n          iio_create_network_context(\"192.168.100.15\");\n    ```", "```\n    struct iio_context * usb_ctx;\n    usb_ctx = iio_create_context_from_uri(\"usb:3.80.5\");\n    ```", "```\n    struct iio_context * serial_ctx;\n    serial_ctx = iio_create_context_from_uri(\n                       \"serial:/dev/ttyUSB0,115200,8n1\"); \n    ```", "```\nint i;\nssize_t nb_ctx;\nconst char *uri;\nstruct iio_context *ctx = NULL;\n#ifdef CHECK_REMOTE\nstruct iio_context_info **info;\nstruct iio_scan_context *scan_ctx =\n                  iio_create_scan_context(\"usb:ip:\", 0);\nif (!scan_ctx) {\n    printf(\"Unable to create scan context!\\n\");\n    return NULL;\n}\nnb_ctx = iio_scan_context_get_info_list(scan_ctx, &info);\nif (nb_ctx < 0) {\n    printf(\"Unable to scan!\\n\");\n    iio_scan_context_destroy(scan_ctx);\n    return NULL;\n}\nfor (i = 0; i < nb_ctx; i++) {\n    uri = iio_context_info_get_uri(info[0]);\n    if (strcmp (\"usb:\", uri) == 0) {\n        ctx = iio_create_context_from_uri(uri);\n        break;\n    }\n    if (strcmp (\"ip:\", uri) == 0) { \n        ctx = \n            iio_create_context_from_uri(\"ip:192.168.3.18\");\n        break;\n    }\n}\niio_context_info_list_free(info);\niio_scan_context_destroy(scan_ctx);\n#endif\nif (!ctx) {\n    printf(\"creating local context\\n\");\n    ctx = iio_create_local_context();\n    if (!ctx) {\n       printf(\"unable to create local context\\n\");\n       goto err_free_info_list;\n    }\n}\nreturn ctx;\n```", "```\nint iio_context_get_version (\n       const struct iio_context * ctx,\n       unsigned int *major, unsigned int *minor,\n       char git_tag[8])\nconst char * iio_context_get_name(\n                      const struct iio_context *ctx)\nconst char * iio_context_get_description(\n                      const struct iio_context *ctx)\n```", "```\nunsigned int major, minor;\nchar git_tag[8];\nstruct iio_context *ctx;\n[...] /* the context must be created */\niio_context_get_version(ctx, &major, &minor, git_tag);\nprintf(\"Backend version: %u.%u (git tag: %s)\\n\",\n           major, minor, git_tag);\nprintf(\"Backend description string: %s\\n\",\n           iio_context_get_description(ctx));\n```", "```\nunsigned int iio_context_get_devices_count(\n                            const struct iio_context *ctx)\nstruct iio_device * iio_context_get_device(\n         const struct iio_context *ctx, unsigned int index)\nstruct iio_device * iio_context_find_device(\n         const struct iio_context *ctx, const char *name)\n```", "```\nroot:/sys/bus/iio/devices/iio:device1> cat name\nad9361-phy\n```", "```\nstruct iio_context * local_ctx;\nlocal_ctx = iio_create_local_context();\nint i;\nfor (i = 0; i < iio_context_get_devices_count(local_ctx);\n     ++i) {\n    struct iio_device *dev =\n           iio_context_get_device(local_ctx, i);\n    const char *name = iio_device_get_name(dev);\n    printf(\"\\t%s: %s\\r\\n\", iio_device_get_id(dev), name );\n}\niio_context_destroy(ctx);\n```", "```\nunsigned int iio_device_get_channels_count(\n                              const struct iio_device *dev)\nstruct iio_channel* iio_device_get_channel(\n         const struct iio_device *dev, unsigned int index)\nstruct iio_channel* iio_device_find_channel(\n                            const struct iio_device *dev,\n                            const char *name, bool output)\n```", "```\nstruct iio_context * local_ctx;\nstruct iio_channel *chan;\nlocal_ctx = iio_create_local_context();\nint i, j;\nfor (i = 0; i < iio_context_get_devices_count(local_ctx);\n       ++i) {\n    struct iio_device *dev = \n           iio_context_get_device(local_ctx, i);\n    printf(\"Device %d\\n\", i);\n    for (j = 0; j < iio_device_get_channels_count(dev);\n            ++j) {\n        chan = iio_device_get_channel(dev, j);\n        const char *name = iio_channel_get_name(ch) ? :\n                              iio_channel_get_id(ch);\n        printf(\"\\tchannel %d: %s\\n\", j, name);\n    }\n}\n```", "```\nbool iio_channel_is_output(const struct iio_channel *chn); \nconst char* iio_channel_get_id(\n                            const struct iio_channel *chn);\nenum iio_modifier iio_channel_get_modifier(\n                            const struct iio_channel *chn);\nenum iio_chan_type iio_channel_get_type(\n                            const struct iio_channel *chn);\nconst char* iio_channel_get_name(\n                            const struct iio_channel *chn);\n```", "```\nstruct iio_device* iio_context_find_device(\n          const struct iio_context *ctx, const char *name) \n```", "```\nint iio_device_set_trigger(const struct iio_device *dev,\n                          const struct iio_device *trig)\n```", "```\nstruct iio_context *ctx;\nstruct iio_device *trigger, *dev;\n[...]\nctx = iio_create_local_context();\n/* at least 2 iio_device must exist:\n * a trigger and a device */\nif (!(iio_context_get_devices_count(ctx) > 1))\n    return -1;\ntrigger = iio_context_find_device(ctx, \"hrtimer-1\");\nif (!trigger) {\n    printf(\"no trigger found\\n\");\n    return -1;\n}\ndev = iio_context_find_device(ctx, \"iio-device-dummy\");\nif (!dev) {\n    printf(\"unable to find the IIO device\\n\");\n    return -1;\n}\nprintf(\"Enabling IIO buffer trigger\\n\");\niio_device_set_trigger(dev, trigger);\n[...]\n/* When done with the trigger */\niio_device_set_trigger(dev, NULL);\n```", "```\nvoid iio_channel_enable(struct iio_channel * chn)\nbool iio_channel_is_enabled(struct iio_channel * chn)\n```", "```\nvoid iio_channel_disable(struct iio_channel * chn)\n```", "```\nstruct iio_buffer * iio_device_create_buffer(\n        const struct iio_device *dev,\n        size_t samples_count, bool cyclic)\n```", "```\nvoid  iio_buffer_destroy(struct iio_buffer *buf)\n```", "```\nssize_t iio_buffer_refill (struct iio_buffer *buf)\n```", "```\nint iio_device_set_kernel_buffers_count(\n                const struct iio_device *dev,\n                unsigned int nb_buffers)\n```", "```\nvoid iio_buffer_destroy(struct iio_buffer *buf) \nvoid* iio_buffer_end(const struct iio_buffer *cbuf)  \nvoid* iio_buffer_start(const struct iio_buffer *buf) \nptrdiff_t iio_buffer_step(const struct iio_buffer *buf)\nvoid* iio_buffer_first(const struct iio_buffer *buf,\n                         const struct iio_channel *chn)\nssize_t iio_buffer_foreach_sample(struct iio_buffer *buf,\n          ssize_t(*callback)(const struct iio_channel *chn,\n                         void *src, size_t bytes, void *d),\n          void *data)\n```", "```\nfor (void *ptr = iio_buffer_first(buffer, chan);\n           ptr < iio_buffer_end(buffer);\n           ptr += iio_buffer_step(buffer)) {\n[...]\n}\n```", "```\nconst struct iio_data_format *fmt;\nunsigned int i, repeat;\nstruct iio_channel *channels[8] = {0};\nptrdiff_t p_inc;\nchar *p_dat;\n[...]\nIIOC_DBG(\"Enter buffer refill loop.\\n\");\nwhile (true) {\n    nbytes = iio_buffer_refill(buf);\n    p_inc = iio_buffer_step(buf);\n    p_end = iio_buffer_end(buf);\n    for (i = 0; i < channel_count; ++i) {\n        fmt = iio_channel_get_data_format(channels[i]);\n        repeat = fmt->repeat ? : 1;\n        for (p_dat = iio_buffer_first(rxbuf, channels[i]);\n                     p_dat < p_end; p_dat += p_inc) {\n            for (j = 0; j < repeat; ++j) {\n                if (fmt->length/8 == sizeof(int16_t))\n                    printf(\"Read 16bit value: \" \"%\" PRIi16, \n                            ((int16_t *)p_dat)[j]);\n                else if (fmt->length/8 == sizeof(int64_t))\n                    printf(\"Read 64bit value: \" \"%\" PRIi64,\n                           ((int64_t *)p_dat)[j]);\n            }\n        }\n    }\n    printf(\"\\n\");\n}\n```", "```\nssize_t iio_buffer_foreach_sample(struct iio_buffer *buf,\n            ssize_t(*)(const struct iio_channel *chn,\n                void *src, size_t bytes, void *d) callback,\n            void *data)\n```", "```\nssize_t sample_cb(const struct iio_channel *chn,\n              void *src, size_t bytes, __notused void *d)\n```", "```\nstatic ssize_t sample_cb(const struct iio_channel *chn,\n              void *src, size_t bytes, __notused void *d)\n{\n    const struct iio_data_format *fmt = \n                         iio_channel_get_data_format(chn);\n    unsigned int j, repeat = fmt->repeat ? : 1;\n    printf(\"%s \", iio_channel_get_id(chn));\n    for (j = 0; j < repeat; ++j) {\n        if (bytes == sizeof(int16_t))\n            printf(\"Read 16bit value: \" \"%\" PRIi16,\n                   ((int16_t *)src)[j]);\n        else if (bytes == sizeof(int64_t))\n            printf(\"Read 64bit value: \" \"%\" PRIi64, \n                   ((int64_t *)src)[j]);\n    }\n    return bytes * repeat;\n}\n```", "```\nint ret;\n[...]\nIIOC_DBG(\"Enter buffer refill loop.\\n\");\nwhile (true) {\n    nbytes = iio_buffer_refill(buf);\n    ret = iio_buffer_foreach_sample(buf, sample_cb, NULL);\n    if (ret < 0) {\n        char text[256];\n        iio_strerror(-ret, buf, sizeof(text));\n        printf(\"%s (%d) while processing buffer\\n\",\n                text, ret);\n    }\n    printf(\"\\n\");\n}\n```", "```\nsize_t iio_channel_read_raw(const struct iio_channel *chn,\n        struct iio_buffer *buffer, void *dst, size_t len) \nsize_t iio_channel_read(onst struct iio_channel *chn,\n        struct iio_buffer *buffer, void *dst, size_t len)\nsize_t iio_channel_write_raw(const struct iio_channel *chn,\n        struct iio_buffer * buffer, const void *src,\n        size_t len)\nsize_t iio_channel_write(const struct iio_channel *chn,\n        struct iio_buffer *buffer, const void *src,\n        size_t len)\n```", "```\n#define CBUF_LENGTH 2048 /* the number of sample we need */\n[...]\nconst struct iio_data_format *fmt;\nunsigned int i, repeat;\nstruct iio_channel *chan[8] = {0};\n[...]\nIIOC_DBG(\"Enter buffer refill loop.\\n\");\nwhile (true) {\n    nbytes = iio_buffer_refill(buf);\n    for (i = 0; i < channel_count; ++i) {\n        uint8_t *c_buf;\n        size_t sample, bytes;\n        fmt = iio_channel_get_data_format(chan[i]);\n        repeat = fmt->repeat ? : 1;\n        size_t sample_size = fmt->length / 8 * repeat;\n        c_buf = malloc(sample_size * CBUF_LENGTH);\n        if (!c_buf) {\n            printf(\"No memory space for c_buf\\n\");\n            return -1;\n        }\n        if (buffer_read_method == CHANNEL_READ_RAW)\n            bytes = iio_channel_read_raw(chan[i], buf,\n                     c_buf, sample_size * CBUF_LENGTH);\n        else\n            bytes = iio_channel_read(chan[i], buf, c_buf,\n                     sample_size * CBUF_LENGTH);\n        printf(\"%s \", iio_channel_get_id(chan[i]));\n        for (sample = 0; sample < bytes / sample_size;\n               ++sample) {\n            for (j = 0; j < repeat; ++j) {\n               if (fmt->length / 8 == sizeof(int16_t))\n                   printf(\"%\" PRIi16 \" \",\n                           ((int16_t *)buf)[sample+j]);\n               else if (fmt->length / 8 == sizeof(int64_t))\n                   printf(\"%\" PRId64 \" \",\n                          ((int64_t *)buf)[sample+j]);\n            }\n        }\n        free(c_buf);\n    }\n    printf(\"\\n\");\n}\n```"]