- en: Administration Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information about processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's what – which, whereis, whatis, and file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing processes, and sending and responding to signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending messages to user terminals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/proc` filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering system information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling with a `cron`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database styles and uses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and reading SQLite databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and reading a MySQL database from Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User administration scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk image resizing and format conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking screenshots from the terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing multiple terminals from one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing multiple terminals from one GNU/Linux ecosystem consists of the network,
    each set of hardware, the OS Kernel that allocates resources, interface modules,
    system utilities, and user programs. An administrator needs to monitor the entire
    system to keep everything running smoothly. Linux administration tools range from
    all-in-one GUI applications to command-line tools designed for scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information about processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term **process** in this case means the running instance of a program. Many
    processes run simultaneously on a computer. Each process is assigned a unique
    identification number, called a **process ID** (**PID**). Multiple instances of
    the same program with the same name can run at the same time, but they will each
    have different PIDs and attributes. Process attributes include the user who owns
    the process, the amount of memory used by the program, the CPU time used by the
    program, and so on. This recipe shows how to gather information about processes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Important commands related to process management are `top`, `ps`, and `pgrep`.
    These tools are available in all Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ps` reports information about active processes. It provides information about
    which user owns the process, when the process started, the command path used to
    execute the process, the PID, the terminal it is attached to (**TTY**, for **TeleTYpe**),
    the memory used by the process, the CPU time used by the process, and so on. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Be default, `ps` will display the processes initiated from the current terminal
    (TTY). The first column shows the PID, the second column refers to the terminal
    (TTY), the third column indicates how much time has elapsed since the process
    started, and finally we have CMD (the command).
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command report can be modified with command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-f (full)` option displays more columns of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `-e` (every) and `-ax` (all) options provide a report on every process that
    is running on the system.
  prefs: []
  type: TYPE_NORMAL
- en: The `-x` argument (along with `-a`) specifies the removal of the default TTY
    restriction imparted by `ps`. Usually, if you use `ps` without arguments, it'll
    only print processes attached to the current terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands `ps -e`, `ps -ef`, `ps -ax`, and `ps -axf` generate reports on
    all processes and provide more information than `ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-e` option generates a long report. This example filters the output with
    `head` to display the first five entries.
  prefs: []
  type: TYPE_NORMAL
- en: The `-o PARAMETER1`, `PARAMETER2` option specifies the data to be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters for `-o` are delimited with a comma (`,`). There is no space between
    the comma operator and the next parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `-o` option can be combined with the `-e` (every) option (`-eo`) to list
    every process running in the system. However, when you use filters similar to
    the ones that restrict `ps` to the specified users along with `-o`, `-e` is not
    used. The -e option overrules the filter and displays all the processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `comm` stands for COMMAND and `pcpu` represents the percentage
    of CPU usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following parameters for the `-o` option are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `pcpu` | Percentage of CPU |'
  prefs: []
  type: TYPE_TB
- en: '| `pid` | Process ID |'
  prefs: []
  type: TYPE_TB
- en: '| `ppid` | Parent process ID |'
  prefs: []
  type: TYPE_TB
- en: '| `pmem` | Percentage of memory |'
  prefs: []
  type: TYPE_TB
- en: '| `comm` | Executable filename |'
  prefs: []
  type: TYPE_TB
- en: '| `cmd` | A simple command |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | The user who started the process |'
  prefs: []
  type: TYPE_TB
- en: '| `nice` | The priority (niceness) |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Cumulative CPU time |'
  prefs: []
  type: TYPE_TB
- en: '| `etime` | Elapsed time since the process started |'
  prefs: []
  type: TYPE_TB
- en: '| `tty` | The associated TTY device |'
  prefs: []
  type: TYPE_TB
- en: '| `euid` | The effective user |'
  prefs: []
  type: TYPE_TB
- en: '| `stat` | Process state |'
  prefs: []
  type: TYPE_TB
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command, `grep`, and other tools can be combined to produce custom
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: Showing environment variables for a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some processes are dependent on their environment variable definitions. Knowing
    the environment variables and values can help you debug or customize a process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ps` command does not normally show the environment information of a command.
    The `e` output modifier at the end of the command adds this information to the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of environment information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Environment information helps trace problems using the `apt-get` package manager.
    If you use an HTTP proxy to connect to the Internet, you may need to set environment
    variables using `http_proxy=host:port`. If this is not set, the `apt-get` command
    will not select the proxy and hence returns an error. Knowing that `http_proxy`
    is not set makes the problem obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a scheduling tool, such as `cron` (discussed later in this chapter), is
    used to run an application, the expected environment variables may not be set.
    This `crontab` entry will not open a GUI-windowed application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It fails because GUI applications require the `DISPLAY` environment variable.
    To determine the required environment variables, run `windowapp` manually and
    then `ps -C windowapp -eo cmd e`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you''ve identified the required environment variables, define them before
    the command name in `crontab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: OR
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The definition `DISPLAY=:0` was obtained from the `ps` output.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tree view of processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ps` command can report a process PID, but tracking from a child to the
    ultimate parent is tedious. Adding `f` to the end of the `ps` command creates
    a tree view of the processes, showing the parent-child relationship between tasks.
    The next example shows an `ssh` session invoked from a bash shell running inside
    `xterm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sorting ps output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the `ps` command output is unsorted. The -sort parameter forces
    `ps` to sort the output. The ascending or descending order can be specified by
    adding the `+` (ascending) or `-` (descending) prefix to the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to list the top five CPU-consuming processes, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This displays the top five processes, sorted in descending order by percentage
    of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grep` command can filter the `ps` output. To report only those Bash processes
    that are currently running, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Filters with ps for real user or ID, effective user or ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command can group processes based on the real and effective usernames
    or IDs specified. The `ps` command filters the output by checking whether each
    entry belongs to a specific effective user or a real user from the list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Specify an effective user's list with `-u EUSER1`, `EUSER2`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify a real user's list with `-U RUSER1`, `RUSER2`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` may be used with `-e` as `-eo` but when filters are applied, `-e` should
    not be used. It overrides the filter options.
  prefs: []
  type: TYPE_NORMAL
- en: TTY filter for ps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ps` output can be selected by specifying the TTY to which the process
    is attached. Use the `-t` option to specify the TTY list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Information about process threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-L` option to `ps` will display information about process threads. This
    option adds an LWP column to the thread ID. Adding the `-f` option to `-L` (`-Lf`)
    adds two columns: NLWP, the thread count, and LWP, the thread ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists five processes with a maximum number of threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the output width and columns to be displayed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ps` command supports many options to select fields in order to display
    and control how they are displayed. Here are some of the more common options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `-f` | This specifies a full format. It includes the starting time of the
    parent PID user ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` userList | This selects processes owned by the users in the list. By
    default, it selects the current user. |'
  prefs: []
  type: TYPE_TB
- en: '| `-l` | Long listing. It displays the user ID, parent PID, size, and more.
    |'
  prefs: []
  type: TYPE_TB
- en: What's what – which, whereis, whatis, and file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be several files with the same name. Knowing which executable is being
    invoked and whether a file is compiled code or a script is useful information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `which`, `whereis`, `file`, and `whatis` commands report information about
    files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: '`which`: The which command reports the location of a command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We often use commands without knowing the directory where the executable file
    is stored. Depending on how your `PATH` variable is defined, you may use a command
    from `/bin`, `/usr/local/bin`, or `/opt/PACKAGENAME/bin`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we type a command, the terminal looks for the command in a set of directories
    and executes the first executable file it finds. The directories to search are
    specified in the `PATH` environment variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add directories to be searched and export the new `PATH`. To add `/opt/bin`
    to `PATH`, use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**whereis**: `whereis` is similar to the which command. It not only returns
    the path of the command, but also prints the location of the man page (if available)
    and the path for the source code of the command (if available):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**whatis**: The `whatis` command outputs a one-line description of the command
    given as the argument. It parses information from the `man` page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `file` command reports a file type. Its syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The reported file type may comprise a few words or a long description:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: apropos
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to search for a command that is related to the topic. The
    `apropos` command will search the man pages for a keyword. Here''s the code to
    do this: **Apropos topic**'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the process ID from the given command names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose several instances of a command are being executed. In such a scenario,
    we need the PID of each process. Both the `ps` and `pgrep` command return this
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the following is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When `=` is appended to `pid`, it removes the header PID from the output of
    `ps`. To remove headers from a column, append `=` to the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command lists the process IDs of Bash processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pgrep` command also returns a list of process IDs for a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`pgrep` requires only a portion of the command name as its input argument to
    extract a Bash command; `pgrep ash` or `pgrep bas` will also work, for example.
    But `ps` requires you to type the exact command. `pgrep` supports these output-filtering
    options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-d` option specifies an output delimiter other than the default new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-u` option filters for a list of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `root` and `slynux` are users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-c` option returns the count of matching processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Determining how busy a system is
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Systems are either unused or overloaded. The `load average` value describes
    the total load on the running system. It describes the average number of runnable
    processes, processes with all resources except CPU time slices, on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Load average is reported by the uptime and top commands. It is reported with
    three values. The first value indicates the average in 1 minute, the second indicates
    the average in 5 minutes, and the third indicates the average in 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is reported by uptime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The top command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `top` command displays a list of the top CPU-consuming processes
    as well as basic system statistics, including the number of tasks in the process
    list, CPU cores, and memory usage. The output is updated every few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command displays several parameters along with the top CPU-consuming processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Scheduling with a cron* recipe in this chapter explains how to schedule
    tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Killing processes, and sending and responding to signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may need to kill processes (if they go rogue and start consuming too many
    resources) if you need to reduce system load, or before rebooting. Signals are
    an inter-process communication mechanism that interrupts a running process and
    forces it to perform some action. These actions include forcing a process to terminate
    in either a controlled or immediate manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals send an interrupt to a running program. When a process receives a signal,
    it responds by executing a signal handler. Compiled applications generate signals
    with the `kill` system call. A signal can be generated from the command line (or
    shell script) with the `kill` command. The `trap` command can be used in a script
    to handle received signals.
  prefs: []
  type: TYPE_NORMAL
- en: Each signal is identified by a name and an integer value. The `SIGKILL (9)`
    signal terminates a process immediately. The keystroke events *Ctrl* + *C* and
    *Ctrl* + *Z* send signals to abort or put the task in the background.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kill `-l` command will list the available signals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminate the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `kill` command issues a `SIGTERM` signal by default. The process ID list
    is specified with spaces for delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-s` option specifies the signal to be sent to the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SIGNAL` argument is either a signal name or a signal number. There are
    many signals available for different purposes. The most common ones are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP 1`: Hangup detection on the death of the controlling process or terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT 2`: This is the signal emitted when *Ctrl* + *C* is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL 9`: This is the signal used to forcibly kill the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM 15`: This is the signal used to terminate a process by default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTSTP 20`: This is the signal emitted when *Ctrl* + *Z* is pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We frequently use force kill for processes. Use this with caution. This is
    an immediate action, and it will not save data or perform a normal cleanup operation.
    The `SIGTERM` signal should be tried first; `SIGKILL` should be saved for extreme
    measures:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this to perform the cleanup operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports other commands to signal or terminate processes.
  prefs: []
  type: TYPE_NORMAL
- en: The kill family of commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `kill` command takes the process ID as the argument. The `killall` command
    terminates the process by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-s` option specifies the signal to send. By default, `killall` sends a
    `SIGTERM` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-9` option forcibly kills a process by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of the preceding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-u` owner specifies the process''s user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-I` option makes `killall run` in interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pkill` command is similar to the `kill` command, but by default it accepts
    a process name instead of a process ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`SIGNAL` is the signal number. The `SIGNAL` name is not supported with `pkill`.
    The `pkill` command provides many of the same options as the `kill` command. Check
    the `pkill` man pages for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and responding to signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well-behaved programs save data and shut down cleanly when they receive a `SIGTERM`
    signal. The `trap` command assigns a signal handler to signals in a script. Once
    a function is assigned to a signal using the `trap` command, when a script receives
    a signal, this function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`SIGNAL LIST` is space-delimited. It can include both signal numbers and signal
    names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shell script responds to the `SIGINT` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Run this script in a terminal. When the script is running, pressing *Ctrl* +
    *C* it will show the message by executing the signal handler associated with it.
    *Ctrl* + *C* corresponds to a `SIGINT` signal.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is used to keep the process running forever without being terminated.
    This is done so the script can respond to signals. The loop to keep a process
    alive infinitely is often called the **event loop**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the process ID of the script is given, the `kill` command can send a signal
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The process ID of the preceding script will be printed when it is executed;
    alternatively, you can find it with the `ps` command.
  prefs: []
  type: TYPE_NORMAL
- en: If no signal handlers are specified for signals, a script will call the default
    signal handlers assigned by the operating system. Generally, pressing *Ctrl* +
    *C* will terminate a program, as the default handler provided by the operating
    system will terminate the process. The custom handler defined here overrides the
    default handler.
  prefs: []
  type: TYPE_NORMAL
- en: We can define signal handlers for any signals available (`kill -l`) with the
    `trap` command. A single signal handler can process multiple signals.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages to user terminals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports three applications to display messages on another user's screen.
    The `write` command sends a message to a user, the `talk` command lets two users
    have a conversation, and the `wall` command sends a message to all users.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing something potentially disruptive (say, rebooting the server), the
    system administrator should send a message to the terminal of every user on the
    system or network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `write` and `wall` commands are part of most Linux distributions. If a user
    is logged in multiple times, you may need to specify the terminal you wish to
    send a message to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine a user''s terminals with the `who` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The second column (`pts/#`) is the user's terminal identifier.
  prefs: []
  type: TYPE_NORMAL
- en: The `write` and `wall` programs work on a single system. The `talk` program
    can connect users across a network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The talk program is not commonly installed. Both the talk program and talk
    server must be installed and running on any machine where talk is used. Install
    the talk application as `talk` and `talkd` on Debian-based systems or as `talk`
    and `talk-server` on Red Hat-based systems. You will probably need to edit `/etc/xinet.d/talk`
    and `/etc/xinet.d/ntalk` to set the `disable` field to `no`. Once you do this,
    restart `xinet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending one message to one user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The write command will send a message to a single user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can redirect a message from a file or an echo or write interactively. An
    interactive write is terminated with Ctrl-D.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message can be directed to a specific session by appending the pseudo terminal
    identifier to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Holding a conversation with another user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The talk command opens an interactive conversation between two users. The syntax
    for this is `$ talk user@host`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command initiates a conversation with user2 on their workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'After typing the talk command, your terminal session is cleared and split into
    two windows. In one of the windows, you''ll see text like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The person you''re trying to talk to will see a message like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When they invoke talk, their terminal session will also be cleared and split.
    What you type will appear in one window on their screen and what they type will
    appear on yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Sending a message to all users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **wall** (WriteALL) command broadcasts a message to all the users and terminal
    sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The message header shows who sent the message: which user and which host.'
  prefs: []
  type: TYPE_NORMAL
- en: The write, talk, and wall commands only deliver messages between users when
    the write message option is enabled. Messages from the root are displayed regardless
    of the write message option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The message option is usually enabled. The `mesg` command will enable or disable
    the receiving of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The /proc filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`/proc` is an in-memory pseudo filesystem that provides user-space access to
    many of the Linux kernel''s internal data structures. Most pseudo files are read-only,
    but some, such as `/proc/sys/net/ipv4/forward` (described in [Chapter 8](5ba784d5-fa8b-4840-b4c5-cac906e484f9.xhtml),
    *The Old-Boy Network*), can be used to fine-tune your system''s behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/proc` directory contains several files and directories. You can view most
    files in `/proc` and their subdirectories with `cat`, `less`, or `more`. They
    are displayed as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Every process running on a system has a directory in `/proc`, named according
    to the process's PID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose Bash is running with PID `4295` (`pgrep bash`); in this case, `/proc/4295`
    will exist. This folder will contain information about the process. The files
    under `/proc/PID` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`environ`: This contains the environment variables associated with the process.
    `cat /proc/4295/environ` will display the environment variables passed to the
    process `4295`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cwd`: This is a `symlink` to the process''s working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exe`: This is a `symlink` to the process''s executable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`fd`: This is the directory consisting of entries on file descriptors used
    by the process. The values 0, 1, and 2 are stdin, stdout, and stderr, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io`: This file displays the number of characters read or written by the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering system information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Describing a computer system requires many sets of data. This data includes
    network information, the hostname, kernel version, Linux distribution name, CPU
    description, memory allocation, disk partitions, and more. This information can
    be retrieved from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hostname` and `uname` commands print the hostname of the current system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, they print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-a` option to `uname` prints details about the Linux kernel version, hardware
    architecture, and more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-r` option limits the report to the kernel release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-m` option prints the machine type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/proc/` directory holds information about the system, modules, and running
    processes. `/proc/cpuinfo` contains CPU details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If the processor has multiple cores, these lines will be repeated n times.
    To extract only one item of information, use `sed`. The fifth line contains the
    processor name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`/proc/meminfo` contains information about the memory and current RAM usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of `meminfo` shows the system''s total RAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '`/proc/partitions` describes the disk partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fdisk` program edits a disk''s partition table and also reports the current
    partition table. Run this command as  `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lshw` and `dmidecode` applications generate long and complete reports
    about your system. The report includes information about the motherboard, BIOS,
    CPU, memory slots, interface slots, disks, and more. These must be run as root.
    `dmidecode` is commonly available, but you may need to install `lshw`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling with a cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GNU/Linux system supports several utilities for scheduling tasks. The `cron`
    utility is the most widely supported. It allows you to schedule tasks to be run
    in the background at regular intervals. The `cron` utility uses a table (crontab)
    with a list of scripts or commands to be executed and the time when they are to
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Cron is used to schedule system housekeeping tasks, such as performing backups,
    synchronizing the system clocking with `ntpdate`, and removing temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: A regular user might use `cron` to schedule Internet downloads to happen late
    at night when their ISP allows drop caps and the available bandwidth is higher.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cron` scheduling utility comes with all GNU/Linux distributions. It scans
    the `cron` tables to determine whether a command is due to be run. Each user has
    their own `cron` table, which is a plain text file. The `crontab` command manipulates
    the `cron` table.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `crontab` entry specifies the time to execute a command and the command to
    be executed. Each line in the `cron` table defines a single command. The command
    can either be a script or a binary application. When `cron` runs a task, it runs
    as the user who created the entry, but it does not source the user's `.bashrc`.
    If the task requires environment variables, they must be defined in the `crontab`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each cron table line consists of six space-delimited fields in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Minute` (0 - 59)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hour` (0 - 23)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Day` (1 - 31)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Month` (1 - 12)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Weekday` (0 - 6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND` (the script or command to be executed at the specified time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first five fields specify the time when an instance of the command is to
    be executed. Multiple values are delimited by commas (no spaces). A star signifies
    that any time or any day will match. A division sign schedules the event to trigger
    every /Y interval *(*/5* in minutes means every five minutes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the `test.sh` script at the 2^(nd) minute of all hours on all days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute **test.sh** on the 5^(th), 6^(th), and 7^(th) hours on all days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `script.sh` every other hour on Sundays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Shut down the computer at 2 a.m. every day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `crontab` command can be used interactively or with prewritten files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `-e` option with `crontab` to edit the `cron` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When `crontab -e` is entered, the default text editor (usually `vi`) is opened
    and the user can type the `cron` jobs and save them. The `cron` jobs will be scheduled
    and executed at specified time intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `crontab` command can be invoked from a script to replace the current crontab
    with a new one. Here''s how you do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a text file (for example, `task.cron`) with the `cron` job in it and
    then run `crontab` with this filename as the command argument:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, specify the `cron` job as an inline function without creating
    a separate file. For example, refer to the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `cron` job needs to be written between `crontab<<EOF` and `EOF`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An asterisk (`*`) specifies that the command should be executed at every instance
    during the given time period. A `*` in the `Hour` field in the `cron` job will
    cause the command to be executed every hour. To execute the command at multiple
    instances of a time period, specify the time intervals separated by a comma in
    this time field. For example, to run the command at the 5^(th) and 10^(th) minute,
    enter `5,10` in the `Minute` field. A slash (divide by) symbol will cause the
    command to run as per a division of the time. For example 0-30/6 in the Minutes
    field will run a command every 5 minutes during the first half of each hour. The
    string `*/12` in the Hours field will run a command every other hour.
  prefs: []
  type: TYPE_NORMAL
- en: Cron jobs are executed as the user who created `crontab`. If you need to execute
    commands that require higher privileges, such as shutting down the computer, run
    the `crontab` command as root.
  prefs: []
  type: TYPE_NORMAL
- en: The commands specified in a cron job are written with the full path to the command.
    This is because cron does not source your `.bashrc`, so the environment in which
    a cron job is executed is different from the bash shell we execute on a terminal.
    Hence, the `PATH` environment variable may not be set. If your command requires
    certain environment variables, you must explicitly set them.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `crontab` command has more options.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many commands require environment variables to be set properly for execution.
    The cron command sets the SHELL variable to `"/bin/sh``"` and also sets `LOGNAME`
    and `HOME` from the values in `/etc/passwd`. If other variables are required,
    they can be defined in the `crontab`. These can be defined for all tasks or individually
    for a single task.
  prefs: []
  type: TYPE_NORMAL
- en: If the `MAILTO` environment variable is defined, `cron` will send the output
    of the command to that user via an e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: The `crontab` defines environment variables by inserting a line with a variable
    assignment statement in the user's `cron` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `crontab` defines an `http_proxy` environment variable to use
    a proxy server for Internet interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This format is supported by `vixie-cron`, used in Debian, Ubunto, and CentOS
    distributions. For other distributions, environment variables can be defined on
    a per-command basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Running commands at system start-up/boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running specific commands when the system starts (or boots) is a common requirement.
    Some `cron` implementations support a `@reboot` time field to run a job during
    the reboot process. Note that this feature is not supported by all `cron` implementations
    and only root is allowed to use this feature on some systems. Now check out the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This will run the command as your user at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the cron table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-l` option to crontab will list the current user''s crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the `-u` option will specify a user''s crontab to view. You must be
    logged in as root to use the `-u` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Removing the cron table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-r` option will remove the current user''s cron table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-u` option specifies the crontab to remove. You must be a root user to
    remove another user''s crontab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Database styles and uses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports many styles of databases, ranging from simple text files (`/etc/passwd`)
    to low level B-Tree databases (Berkely DB and bdb), lightweight SQL (sqlite),
    and fully featured relational database servers, such as Postgres, Oracle, and
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: One rule of thumb for selecting a database style is to use the least complex
    system that works for your application. A text file and `grep` is sufficient for
    a small database when the fields are known and fixed.
  prefs: []
  type: TYPE_NORMAL
- en: Some applications require references. For example, a database of books and authors
    should be created with two tables, one for books and one for the authors, to avoid
    duplicating the author information for each book.
  prefs: []
  type: TYPE_NORMAL
- en: If the table is read more often than it's modified, then SQLite is a good choice.
    This database engine does not require a server, which makes it portable and easy
    to embed in another application (as Firefox does).
  prefs: []
  type: TYPE_NORMAL
- en: If the database is modified frequently by multiple tasks (for example, a webstore's
    inventory system), then one of the RDBMS systems, such as Postgres, Oracle, or
    MySQL, is appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create a text-based database with standard shell tools. SqlLite is commonly
    installed by default; the executable is `sqlite3`. You'll need to install MySQL,
    Oracle, and Postgres. The next section will explain how to install MySQL. You
    can download Oracle from www.oracle.com. Postgres is usually available with your
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A text file database can be built with common shell tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an address list, create a file with one line per address and fields
    separated by a known character. In this case, the character is a tilde (`~`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a function to find lines that match a pattern and translate each line
    into a human-friendly format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'When in use, this would resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SQLite, Postgres, Oracle, and MySQL database applications provide a more
    powerful database paradigm known as relational databases. A relational database
    stores relations between tables, for example, the relation between a book and
    its author.
  prefs: []
  type: TYPE_NORMAL
- en: A common way to interact with a relational database is using SQL. This language
    is supported by SQLite, Postgres, Oracle, MySQL, and other database engines.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is a rich language. You can read books devoted to it. Luckily, you just
    need a few commands to use SQL effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tables are defined with the `CREATE TABLE` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line creates a table of books and authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Inserting a row into an SQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The insert command will insert a row of data into the database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command inserts the book you''re currently reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Selecting rows from a SQL database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The select command will select all the rows that match a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will select book titles that include the word Shell from the book
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Writing and reading SQLite databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a lightweight database engine that is used in applications ranging
    from Android apps and Firefox to US Navy inventory systems. Because of the range
    of use, there are more applications running SQLite than any other database.
  prefs: []
  type: TYPE_NORMAL
- en: A SQLite database is a single file that is accessed by one or more database
    engines. The database engine is a C library that can be linked to an application;
    it is loaded as a library to a scripting language, such as TCL, Python, or Perl,
    or run as a standalone program.
  prefs: []
  type: TYPE_NORMAL
- en: The standalone application sqlite3 is the easiest to use within a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sqlite3` executable may not be installed in your installation. If it is
    not, it can be installed by loading the `sqlite3` package with your package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian and Ubuntu, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'For Red Hat, SuSE, Fedora, and Centos, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sqlite3` command is an interactive database engine that connects to a SQLite
    database and supports the process of creating tables, inserting data, querying
    tables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `sqlite3` command is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `databaseName` file exists, `sqlite3` will open it. If the file does
    not exist, `sqlite3` will create an empty database. In this recipe, we will create
    a table, insert one row, and retrieve that entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sqlite3` application creates an empty database named `books.db` and displays
    the `sqlite> prompt` to accept SQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CREATE TABLE` command creates a table with two fields: title and author.'
  prefs: []
  type: TYPE_NORMAL
- en: The `INSERT` command inserts one book into the database. Strings in SQL are
    delimited with single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: The `SELECT` command retrieves the rows that match the test. The percentage
    symbol (`%`) is the SQL wildcard, similar to a star (`*`) in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A shell script can use `sqlite3` to access a database and provide a simple
    user interface. The next script implements the previous address database with
    `sqlite` instead of a flat text file. It provides three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: This is to create the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`: This is to add a new row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: This is to select rows that match a query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In use, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script implements this database application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This script uses the case statement to select the SQL command string. The other
    command-line arguments are replaced with this string and the string is sent to
    `sqlite3` to be evaluated. The `$1`, `$2`, `$3`, and `$4` are the first, second,
    third, and fourth arguments, respectively, to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Writing and reading a MySQL database from Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL is a widely used database management system. In 2009, Oracle acquired
    SUN and with that the MySQL database. The MariaDB package is a fork of the MySQL
    package that is independent of Oracle. MariaDB can access MySQL databases, but
    MySQL engines cannot always access MariaDB databases.
  prefs: []
  type: TYPE_NORMAL
- en: Both MySQL and MariaDB have interfaces for many languages, including PHP, Python,
    C++, Tcl, and more. All of them use the `mysql` command to provide an interactive
    session in order to access a database. This is the easiest way for a shell script
    to interact with a MySQL database. These examples should work with either MySQL
    or MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: A bash script can convert a text or **Comma-Separated Values** (**CSV**) file
    into MySQL tables and rows. For example, we can read all the e-mail addresses
    stored in a guestbook program's database by running a query from the shell script.
  prefs: []
  type: TYPE_NORMAL
- en: The next set of scripts demonstrates how to insert the contents of the file
    into a database table of students and generate a report while ranking each student
    within the department.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL and MariaDB are not always present in the base Linux distribution. They
    can be installed as either `mysql-server` and `mysql-client` or the `mariadb-server`
    package. The MariaDB distribution uses MySQL as a command and is sometimes installed
    when the MySQL package is requested.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports a username and password for authentication. You will be prompted
    for a password during the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `mysql` command to create a new database on a fresh installation. After
    you create the database with the `CREATE DATABASE` command, you can select it
    for use with the use command. Once a database is selected, standard SQL commands
    can be used to create tables and insert data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `quit` command or Ctrl-D will terminate a `mysql` interactive session.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe consists of three scripts: one to create a database and table,
    one to insert student data, and one to read and display data from the table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the database and table script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This script inserts data in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The last script queries the database and generates a report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The data for the input CSV file (`studentdata.csv`) will resemble this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the scripts in the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first script, `create_db.sh`, creates a database called `students` and a
    table named `students` inside it. The `mysql` command is used for MySQL manipulations.
    The `mysql` command specifies the username with `-u` and the password with `-pPASSWORD`.
    The variables `USER` and `PASS` are used to store the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: The other command argument for the `mysql` command is the database name. If
    a database name is specified as an argument to the `mysql` command, it will use
    that database; otherwise, we have to explicitly define the database to be used
    with the **use** `database_name` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `mysql` command accepts the queries to be executed through standard input
    (`stdin`). A convenient way of supplying multiple lines through `stdin` is using
    the `<<EOF` method. The text that appears between `<<EOF` and `EOF` is passed
    to `mysql` as standard input.
  prefs: []
  type: TYPE_NORMAL
- en: The `CREATE DATABASE` and `CREATE TABLE` commands redirect `stderr` to `/dev/null`
    to prevent the display of error messages. The script checks the exit status for
    the `mysql` command stored in `$?` to determine whether a failure has occurred;
    it assumes that a failure occurs because a table or database already exists. If
    the database or table already exists, a message is displayed to notify the user;
    otherwise, the database and table are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `write_to_db.sh` script accepts the filename of the student data CSV file.
    It reads each line of the CSV file in the `while` loop. On each iteration, a line
    from the CSV file is read and reformatted into a SQL command. The script stores
    the data from the comma-separated line in an array. Array assignment is done in
    this form: `array=(val1 val2 val3)`. Here, the space character is the **Internal****Field****Separator**
    (**IFS**). This data has comma-separated values. By changing the IFS to a comma,
    we can easily assign values to the array (`IFS=,`).'
  prefs: []
  type: TYPE_NORMAL
- en: The data elements in the comma-separated line are `id`, `name`, `mark`, and
    `department`. The `id` and `mark` values are integers, while `name` and `dept`
    are strings that must be quoted.
  prefs: []
  type: TYPE_NORMAL
- en: The name could contain space characters that would conflict with the IFS. The
    script replaces the space in the name with a character (`#`) and restores it after
    formulating the query.
  prefs: []
  type: TYPE_NORMAL
- en: To quote the strings, the values in the array are reassigned with a prefix and
    suffixed with `\"`. The `tr` command substitutes each space in the name with `#`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the query is formed by replacing the space character with a comma and
    replacing `#` with a space. Then, SQL's `INSERT` command is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third script, `read_db.sh`, generates a list of students for each department
    ordered by rank. The first query finds distinct names of departments. We use a
    `while` loop to iterate through each department and run the query to display student
    details in the order of highest marks obtained. `SET @i=0` is an SQL construct
    to set this: `i=0`. On each row, it is incremented and displayed as the rank of
    the student.'
  prefs: []
  type: TYPE_NORMAL
- en: User administration scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU/Linux is a multiuser operating system that allows many users to log in and
    perform activities at the same time. Administration tasks involving user management
    include setting the default shell for the user, adding a user to a group, disabling
    a shell account, adding new users, removing users, setting a password, setting
    an expiry date for a user account, and so on. This recipe demonstrates a user
    management tool to handle these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script performs common user management tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `user_adm.sh` script performs several common user management tasks. The
    `usage()` text explains how to use the script when the user provides incorrect
    parameters or includes the `-usage` parameter. A case statement parses command
    arguments and executes the appropriate commands.
  prefs: []
  type: TYPE_NORMAL
- en: The valid command options for the `user_adm.sh` script are: `-adduser`, `-deluser`,
    `-shell`, `-disable`, `-enable`, `-expiry`, `-passwd`, `-newgroup`, `-delgroup`,
    `-addgroup`, `-details`, and `-usage`. When the `*)` case is matched, it means
    no option was recognized; hence, `usage()` is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Run this script as the root. It confirms the user ID (the root's user ID is
    `0`) before the arguments are examined.
  prefs: []
  type: TYPE_NORMAL
- en: When an argument is matched, the `[ $# -ne 3 ] &&` test usage checks the number
    of arguments. If the number of command arguments does not match the required number,
    the `usage()` function is invoked and the script exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'These options are supported by the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-useradd`: The `useradd` command creates a new user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` option creates the home directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-deluser`: The `deluser` command removes the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The `--remove-all-files` option removes all the files associated with the user,
    including the `home` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-shell`: The `chsh` command changes the default shell of the user:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`-disable` and `-enable`: The `usermod` command manipulates several attributes
    related to user accounts. `usermod -L USER` locks the user account and `usermod
    -U USER` unlocks the user account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-expiry`: The `change` command manipulates user account expiry information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'These options are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m MIN_DAYS`: This sets the minimum number of days between password changes
    to `MIN_DAYS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-M MAX_DAYS`: This sets the maximum number of days during which a password
    is valid'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-W WARN_DAYS`: This sets the number of days to provide a warning before a
    password change is required'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-passwd`: The `passwd` command changes a user''s password:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will prompt to enter a new password:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-newgroup` and `-addgroup`: The `addgroup` command adds a new user group to
    the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'If you include a username, it will add this user to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delgroup` command removes a user group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '`-details`: The `finger USER` command displays user information, including
    the home directory, last login time, default shell, and so on. The `chage -l`
    command displays the user account expiry information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bulk image resizing and format conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of us download photos from our phones and cameras. Before we e-mail an image
    or post it to the Web, we may need to resize it or perhaps change the format.
    We can use scripts to modify these image files in bulk. This recipe describes
    recipes for image management.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `convert` command from the **ImageMagick** suite contains tools for manipulating
    images. It supports many image formats and conversion options. Most GNU/Linux
    distributions don't include ImageMagick by default. You need to manually install
    the package. For more information, point your web browser at [www.imagemagick.org](http://www.imagemagick.org).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The convert program will convert a file from one image format to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We can resize an image by specifying the scale percentage or the width and
    height of the output image. To resize an image by specifying `WIDTH` or `HEIGHT`,
    use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If either `WIDTH` or `HEIGHT` is missing, then whatever is missing will be
    automatically calculated to preserve the image aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'To resize the image by specifying the percentage scale factor, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'This script will perform a set of operations on all the images in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example scales the images in the `sample_dir` directory to `20%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'To scale images to a width of `1024`, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'To scale and convert files into a specified destination directory, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding `image_help.sh` script accepts these arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-source`: This specifies the source directory of the images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-dest`: This specifies the destination directory of the converted image files.
    If `-dest` is not specified, the destination directory will be the same as the
    source directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ext`: This specifies the target file format for conversions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-percent`: This specifies the percentage of scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-scale`: This specifies the scaled width and height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the `-percent` and `-scale` parameters may not appear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script starts by checking the number of command arguments. Either four,
    six, or eight parameters are valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command line is parsed with a `while` loop and the case statement and values
    are assigned to appropriate variables. `$#` is a special variable that contains
    the number of arguments. The `shift` command shifts the command arguments one
    position to the left. With this, every time the shifting happens, we can access
    the next command argument as `$1` rather than using `$1`, `$2`, `$3`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The case statement is like a switch statement in the C programming language.
    When a case is matched, the corresponding statements are executed. Each match
    statement is terminated with `;;`. Once all the parameters are parsed into the
    variables `percent`, `scale`, `source_dir`, `ext`, and `dest_dir`, a `for` loop
    iterates through each file in the source directory and the file is converted.
  prefs: []
  type: TYPE_NORMAL
- en: Several tests are done within the `for` loop to fine-tune the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: If the variable `ext` is defined (if `-ext` is given in the command argument),
    the extension of the destination file is changed from `source_file.extension`
    to `source_file.$ext`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `-dest` parameter is provided, the destination file path is modified
    by replacing the directory in the source path with the destination directory.
  prefs: []
  type: TYPE_NORMAL
- en: If -scale or -percent are specified, the resize parameter (`-resize widthx`
    or `-resize perc%`) is added to the command.
  prefs: []
  type: TYPE_NORMAL
- en: After the parameters are evaluated, the `convert` command is executed with proper
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Slicing filenames based on extensions* recipe in [Chapter 2](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml),
    *Have a Good Command*, explains how to extract a portion of the filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking screenshots from the terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As GUI applications proliferate, it becomes important to take screenshots, both
    to document your actions and to report unexpected results. Linux supports several
    tools for grabbing screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will describe the **xwd** application and a tool from ImageMagick,
    which was used in the previous recipe. The xwd application is usually installed
    with the base GUI. You can install ImageMagick using your package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The xwd program extracts visual information from a window, converts it into
    X Window Dump format, and prints the data to `stdout`. This output can be redirected
    to a file, and the file can be converted into GIF, PNG, or JPEG format, as shown
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'When xwd is invoked, it changes your cursor to a crosshair. When you move this
    crosshair to an X Window and click on it, the window is grabbed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'ImageMagick''s `import` command supports more options for taking screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To take a screenshot of the whole screen, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'You can manually select a region and take a screenshot of it using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'To take a screenshot of a specific window, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The `xwininfo` command will return a window ID. Run the command and click on
    the window you want. Then, pass this `window_id` value to the `-window` option
    of `import`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple terminals from one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH sessions, Konsoles, and xterms are heavyweight solutions for applications
    you want to run for a long time, but they perform a check infrequently (such as
    monitoring log files or disk usage).
  prefs: []
  type: TYPE_NORMAL
- en: The GNU screen utility creates multiple virtual screens in a terminal session.
    The tasks you start in a virtual screen continue to run when the screen is hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve this, we will use a utility called **GNU screen**. If the screen
    is not installed on your distribution by default, install it using the package
    manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the screen utility has created a new window, all the keystrokes go to the
    task running in that window, except Control-A (*Ctrl*-*A*), which marks the start
    of a screen command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating screen windows**: To create a new screen, run the command screen
    from your shell. You will see a welcome message with information about the screen.
    Press Space or Return to return to the shell prompt. To create a new virtual terminal,
    press *Ctrl* + *A* and then *C* (these are case-sensitive) or type screen again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Viewing a list of open windows**: While running the screen, pressing *Ctrl*+*A*
    followed by a quote (`"`) will list your terminal sessions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Switching between windows**: The keystrokes *Ctrl* + *A* and *Ctrl* + *N*
    display the next window and *Ctrl* + *A* and *Ctrl* + *P* the previous window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Attaching to and detaching screens**: The screen command supports saving
    and loading screen sessions, called detaching and attaching in screen terminology.
    To detach from the current screen session, press *Ctrl* + *A* and *Ctrl* + *D*.
    To attach to an existing screen when starting the screen, use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the screen to attach the last screen session. If you have more than
    one detached session, the screen will output a list; then use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Here, `PID` is the PID of the screen session you want to attach.
  prefs: []
  type: TYPE_NORMAL
