<html><head></head><body>
		<div id="_idContainer069">
			<h1 id="_idParaDest-240"><em class="italic"><a id="_idTextAnchor242"/>Chapter 16</em>: Getting the Most Out of the Pin Controller and GPIO Subsystems</h1>
			<p><strong class="bold">System-on-chips</strong> (<strong class="bold">SoCs</strong>) are <a id="_idIndexMarker1356"/>becoming more and more complex and feature-rich. These features are mostly exposed through electrical lines originating from the SoC and are called pins. Most of these pins are routed to or multiplexed with several functional blocks (for instance, UART, SPI, RGMI, <strong class="bold">General-Purpose Input Output</strong> (<strong class="bold">GPIO</strong>), and so on), and the underlying device responsible for configuring these pins and switching between operating modes (switching between functional blocks) is called<a id="_idIndexMarker1357"/> the <strong class="bold">pin controller</strong>.</p>
			<p>One mode in which such pins can be configured is <strong class="bold">GPIO</strong>. Then comes the Linux GPIO subsystem, which enables drivers to read signals on GPIO configured pins as high or low and to drive the signal high/low on GPIO configured pins. On the other hand, the <strong class="bold">pin control</strong> (abbreviated <strong class="bold">pinctrl</strong>) subsystem<a id="_idIndexMarker1358"/> enables multiplexing of some pin/pin groups for different functions, and the capability to configure the electrical properties of pins, such as slew rate, pull up/down resistor, hysteresis, and so on.</p>
			<p>To summarize, the pin controller mainly does two things: pin multiplexing, that is, reusing the same pin for different purposes, and pin configuration, that is, configuring electronic properties of pins. Then, the GPIO subsystem allows driving pins, provided these pins are configured to work in GPIO mode by the pin controller.</p>
			<p>In this chapter, pin controller and GPIO subsystems will be introduced via the following topics:</p>
			<ul>
				<li>Introduction to some hardware terms</li>
				<li>Introduction to the pin control subsystem</li>
				<li>Dealing with the GPIO controller interface</li>
				<li>Getting the most out of the GPIO consumer interface</li>
				<li>Learning how not to write GPIO client drivers</li>
			</ul>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor243"/>Introduction to some hardware terms</h1>
			<p>The Linux kernel GPIO subsystem is not just about GPIO toggling. It is tightly coupled to the pin controller subsystem; they share some terms and concepts that we need to introduce:</p>
			<ul>
				<li><strong class="bold">Pin</strong> and <strong class="bold">pad</strong>: A pin<a id="_idIndexMarker1359"/> is a physical input or output wire/line that transports an electrical signal from or to a component. In schematics, the term "pin" is widely used. Contact pads, on<a id="_idIndexMarker1360"/> the other hand, are the contact surface areas of a printed circuit board or an integrated circuit. As a result, a pin comes from a pad, and a <a id="_idIndexMarker1361"/>pin is a pad by default.</li>
				<li><strong class="bold">GPIO</strong>: Most MCUs and CPUs can share one pad among several functional blocks. This is accomplished by multiplexing the input and output signals of the pad. The different modes the pin/pad can operate in are known<a id="_idIndexMarker1362"/> as <strong class="bold">ALT modes</strong> (or alternate modes), and it is common for CPUs to support up to eight settings (or modes) per pad. GPIO<a id="_idIndexMarker1363"/> is one of these modes. It allows changing the pin direction and reading its value when it is configured as input or setting its value when it is configured as output. Other modes are ADC, UART Tx, UART Rx, SPI MOSI, SPI MISO, PWM, and so on.</li>
				<li><strong class="bold">Pin controller</strong>: This is <a id="_idIndexMarker1364"/>the underlying device or controller (or rather, a group of registers) allowing you to perform <strong class="bold">pin multiplexing</strong> (also <a id="_idIndexMarker1365"/>referred to as <strong class="bold">pinmux</strong> or <strong class="bold">pinmuxing</strong>) to reuse the same pin for different purposes. Apart from pinmuxing, it allows pin configuration, that is, configuring electronic properties of pins. The following are some of these properties:<ul><li><strong class="bold">Biasing</strong>, that is, setting the<a id="_idIndexMarker1366"/> initial operating conditions, for example, grounding the pins or connecting them to Vdd. This is not to be confused with pull up and pull down, which is another property.</li><li><strong class="bold">Pin debounce</strong>, which is the<a id="_idIndexMarker1367"/> time after which a state should be considered valid. This, for example, prevents multiple key pushes on keypads attached to GPIO lines.</li><li><strong class="bold">Slew rate</strong>, which <a id="_idIndexMarker1368"/>determines how fast the pin toggles between the two logic states. It allows us to control the rise and fall time for the output signals. A trade-off has to be found because rapidly changing states consume more power and generate spikes, thus low slew rates are preferred, except for quick control signals such as parallel interfaces: EIM, EB&amp;, SPI, or SDRAM, which need fast toggling.</li><li>Pull Up/Down resistors</li></ul></li>
				<li><strong class="bold">GPIO controller</strong>: This is the device allowing you to drive pins when they are put in GPIO<a id="_idIndexMarker1369"/> mode. It allows changing the GPIO direction and value. </li>
			</ul>
			<p>Following the previous definitions, certain general rules have been established for writing pin<a id="_idIndexMarker1370"/> controllers <a id="_idIndexMarker1371"/>or GPIO controller drivers, and they are as follows:</p>
			<ul>
				<li>If your GPIO/pin controller can only do simple GPIO, implement just <strong class="source-inline">struct gpio_chip</strong> in <strong class="source-inline">drivers/gpio/gpio-foo.c</strong> and leave it there. Do not use the generic or old-style number-based GPIO.</li>
				<li>Keep your GPIO/pin controller in <strong class="source-inline">drivers/gpio</strong> if it can generate interrupts in addition to GPIO capabilities; simply fill in <strong class="source-inline">struct irq_chip</strong> and register it with the IRQ subsystem.</li>
				<li>Implement composite pin controller drivers in <strong class="source-inline">drivers/pinctrl/pinctrl-foo.c</strong> if this controller supports pinmuxing, advanced pin driver strength, complicated biasing, and so on. </li>
				<li>Maintain the <strong class="source-inline">struct gpio_chip</strong>, <strong class="source-inline">struct irq_chip</strong>, and <strong class="source-inline">struct pinctrl_desc</strong> interfaces.</li>
			</ul>
			<p>Now that we are familiar with the terms related to the underlying hardware devices, let's introduce the Linux implementation, starting with the pin control subsystem. </p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor244"/>Introduction to the pin control subsystem</h1>
			<p>The pin controller<a id="_idIndexMarker1372"/> allows gathering pins, the modes these pins should operate in, and their configurations. The driver is responsible for providing the appropriate set of callbacks according to the features that are to be implemented, provided the underlying hardware supports these features.</p>
			<p>The pin controller descriptor data structure<a id="_idIndexMarker1373"/> is defined as follows:</p>
			<p class="source-code">struct pinctrl_desc {</p>
			<p class="source-code">     const char *name;</p>
			<p class="source-code">     const struct pinctrl_pin_desc *pins;</p>
			<p class="source-code">     unsigned int npins;</p>
			<p class="source-code">     const struct pinctrl_ops *pctlops;</p>
			<p class="source-code">     const struct pinmux_ops *pmxops;</p>
			<p class="source-code">     const struct pinconf_ops *confops;</p>
			<p class="source-code">     struct module *owner;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>In that <a id="_idIndexMarker1374"/>pin controller data structure, only relevant elements have been listed, and the following are their meanings:</p>
			<ul>
				<li><strong class="source-inline">name</strong> is the name of the pin controller.</li>
				<li><strong class="source-inline">pins</strong>: An array of pin descriptors that describe all the pins that this controller can handle. It has to be noted that the controller side represents each pin/pad as an instance of <strong class="source-inline">struct pinctrl_pin_desc</strong>, defined as follows:<p class="source-code">struct pinctrl_pin_desc {</p><p class="source-code">     unsigned number;</p><p class="source-code">     const char *name;</p><p class="source-code">[...]</p><p class="source-code">};</p></li>
			</ul>
			<p>In the preceding data structure, <strong class="source-inline">number</strong> represents the unique pin number from the global pin number space of the pin controller, and <strong class="source-inline">name</strong> is the name of this pin.</p>
			<ul>
				<li><strong class="source-inline">npins</strong>: The number of descriptors in the <strong class="source-inline">pins</strong> array, usually obtained using <strong class="source-inline">ARRAY_SIZE()</strong> in the <strong class="source-inline">pins</strong> field.</li>
				<li><strong class="source-inline">pctlops</strong> stores the pin control operation table, to support global concepts such as the grouping of pins. This is optional.</li>
				<li><strong class="source-inline">pmxops</strong> represents <a id="_idIndexMarker1375"/>the <strong class="bold">pinmux</strong> operations table if you support pinmuxing in your driver.</li>
				<li><strong class="source-inline">confops</strong>: The pin configuration operations table if you support pin configuration in your driver.</li>
			</ul>
			<p>Once the appropriate callbacks are defined and this data structure has been initialized, it can be passed to <strong class="source-inline">devm_pinctrl_register()</strong>, defined as the following:</p>
			<p class="source-code">struct pinctrl_dev *devm_pinctrl_register(</p>
			<p class="source-code">                      struct device *dev,</p>
			<p class="source-code">                      struct pinctrl_desc *pctldesc,</p>
			<p class="source-code">                      void *driver_data);</p>
			<p>The preceding function will register the pin controller with the system, returning in the meantime a pointer to an instance of <strong class="source-inline">struct pinctrl_dev</strong>, representing the pin controller device, passed as a parameter to most (if not all) of the callback operations exposed by the pin controller driver. On error, the function returns an error pointer, which can be handled with <strong class="source-inline">PTR_ERR</strong>.</p>
			<p>The controller's control, multiplexing, and configuration operation tables are to be set up according to the features supported by the underlying hardware. Their respective data structures are defined in the header files that must also be included in the driver, as follows:</p>
			<p class="source-code">#include &lt;linux/pinctrl/pinconf.h&gt;</p>
			<p class="source-code">#include &lt;linux/pinctrl/pinconf-generic.h&gt;</p>
			<p class="source-code">#include &lt;linux/pinctrl/pinctrl.h&gt;</p>
			<p class="source-code">#include &lt;linux/pinctrl/pinmux.h&gt;</p>
			<p>When it comes to the pin control consumer interface, the following header must be used instead:</p>
			<p class="source-code">#include &lt;linux/pinctrl/consumer.h&gt;</p>
			<p>Before being accessed by<a id="_idIndexMarker1376"/> consumer drivers, pins must be assigned to the devices that need to control them. The recommended way to assign pins to devices is from<a id="_idIndexMarker1377"/> the <strong class="bold">device tree</strong> (<strong class="bold">DT</strong>). How pins groups are assigned in the DT closely depends on the platform, thus the pin controller driver and its binding. </p>
			<p>Every pin control state is assigned a contiguous integer ID that starts at 0. A <strong class="source-inline">name</strong> property list can be used to map strings on top of these IDs to ensure that the same name always points to the same ID. It goes without saying that the set of states that must be defined in each device's DT node is determined by the binding of this device. This binding also determines whether to define the set of state IDs that must be provided, or whether to define the set of state names that must be provided. In any case, two properties can be used to assign a pin configuration node to a device:</p>
			<ul>
				<li><strong class="source-inline">pinctrl-&lt;ID&gt;</strong>: This allows you to provide the list of pin configurations needed for particular states of the device. It is a list of <strong class="source-inline">phandles</strong> identified by <strong class="source-inline">&lt;ID&gt;</strong>, each of which points to a pin configuration node. These referenced pin configuration nodes must be child nodes of (or nested in) the pin controller node they belong to. This property can accept multiple entries so that multiple groups of pins may be configured and used for a particular device state, allowing in the meantime to specify pins from different pin controllers.</li>
				<li><strong class="source-inline">pinctrl-names</strong>: This allows giving names to <strong class="source-inline">pinctrl-&lt;ID&gt;</strong> properties according to the state of the device owning the group(s) of pins. List entry 0 defines the name for the state whose ID is 0, list entry 1 for state ID 1, and so on. State ID 0 is commonly given the name <strong class="source-inline">default</strong>. A list of standardized states can be found in <strong class="source-inline">include/linux/pinctrl/pinctrl-state.h</strong>. However, clients or consumer drivers are free to implement any state they need, provided this state is documented in the device binding description.</li>
			</ul>
			<p>Here is an excerpt of the <a id="_idIndexMarker1378"/>DT, showing some device nodes, along with their pin control nodes. Let's name this excerpt <strong class="source-inline">pinctrl-excerpt</strong>:</p>
			<p class="source-code">&amp;usdhc4 {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">     pinctrl-0 = &lt;&amp;pinctrl_usdhc4_1&gt;;</p>
			<p class="source-code">     pinctrl-names = "default";</p>
			<p class="source-code">};</p>
			<p class="source-code">gpio-keys {</p>
			<p class="source-code">    compatible = "gpio-keys";</p>
			<p class="source-code">    pinctrl-names = "default";</p>
			<p class="source-code">    pinctrl-0 = &lt;&amp;pinctrl_io_foo &amp;pinctrl_io_bar&gt;;</p>
			<p class="source-code">};</p>
			<p class="source-code">iomuxc@020e0000 { /* Pin controller node */</p>
			<p class="source-code">    compatible = "fsl,imx6q-iomuxc";</p>
			<p class="source-code">    reg = &lt;0x020e0000 0x4000&gt;;</p>
			<p class="source-code">    /* shared pinctrl settings */</p>
			<p class="source-code">    usdhc4 { /* first node describing the function */</p>
			<p class="source-code">        pinctrl_usdhc4_1: usdhc4grp-1 { /* second node */</p>
			<p class="source-code">            fsl,pins = &lt;</p>
			<p class="source-code">                MX6QDL_PAD_SD4_CMD__SD4_CMD    0x17059</p>
			<p class="source-code">                MX6QDL_PAD_SD4_CLK__SD4_CLK    0x10059</p>
			<p class="source-code">                MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059</p>
			<p class="source-code">                MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059</p>
			<p class="source-code">                MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059</p>
			<p class="source-code">                MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059</p>
			<p class="source-code">                [...]</p>
			<p class="source-code">            &gt;;</p>
			<p class="source-code">        };</p>
			<p class="source-code">    };</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    uart3 {</p>
			<p class="source-code">        pinctrl_uart3_1: uart3grp-1 {</p>
			<p class="source-code">            fsl,pins = &lt;</p>
			<p class="source-code">                MX6QDL_PAD_EIM_D24__UART3_TX_DATA 0x1b0b1</p>
			<p class="source-code">                MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1</p>
			<p class="source-code">            &gt;;</p>
			<p class="source-code">        };</p>
			<p class="source-code">    };</p>
			<p class="source-code">    // GPIOs (Inputs)</p>
			<p class="source-code">   gpios {</p>
			<p class="source-code">        pinctrl_io_foo: pinctrl_io_foo {</p>
			<p class="source-code">           fsl,pins = &lt;</p>
			<p class="source-code">              MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09  0x1f059</p>
			<p class="source-code">              MX6QDL_PAD_DISP0_DAT13__GPIO5_IO07  0x1f059</p>
			<p class="source-code">           &gt;;</p>
			<p class="source-code">        };</p>
			<p class="source-code">        pinctrl_io_bar: pinctrl_io_bar {</p>
			<p class="source-code">           fsl,pins = &lt;</p>
			<p class="source-code">              MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05  0x1f059</p>
			<p class="source-code">              MX6QDL_PAD_DISP0_DAT9__GPIO4_IO30   0x1f059</p>
			<p class="source-code">              MX6QDL_PAD_DISP0_DAT7__GPIO4_IO28   0x1f059</p>
			<p class="source-code">           &gt;;</p>
			<p class="source-code">        };</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>In the preceding example, a <a id="_idIndexMarker1379"/>pin configuration is given in the form <strong class="source-inline">&lt;PIN_FUNCTION&gt; &lt;PIN_SETTING&gt;</strong>, where <strong class="source-inline">&lt;PIN_FUNCTION&gt;</strong> can be seen as the pin function or pin mode, and <strong class="source-inline">&lt;PIN_SETTING&gt;</strong> represents the pin's electrical properties:</p>
			<p class="source-code">MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09 0x80000000</p>
			<p>In the excerpt, <strong class="source-inline">MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09</strong> represents the pin function/mode, which is GPIO in this case, and <strong class="source-inline">0x80000000</strong> represents the pin settings or electrical properties.</p>
			<p>Let's consider another example as follows:</p>
			<p class="source-code">MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1</p>
			<p>In that excerpt, <strong class="source-inline">MX6QDL_PAD_EIM_D25__UART3_RX_DATA</strong> represents the pin function, which is the RX line of UART3, and <strong class="source-inline">0x1b0b1</strong> represents its electrical settings.</p>
			<p>The pin function is a macro whose value is meaningful for the pin controller driver only. These are generally defined in header files located in <strong class="source-inline">arch/&lt;arch&gt;/boot/dts/</strong>. If you use an UDOO quad, for example, which has an i.MX6 quad core (32-bit ARM), the pin function header would be <strong class="source-inline">arch/arm/boot/dts/imx6q-pinfunc.h</strong>. The following is the macro corresponding to the fifth line of the GPIO5 controller:</p>
			<p class="source-code">#define MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05 0x19c 0x4b0 0x000 0x5 0x0</p>
			<p><strong class="source-inline">&lt;PIN_SETTING&gt;</strong> can be used to set up things such as pull-ups, pull-downs, keepers, drive strength, and so on. How it should be specified depends on the pin controller binding, and the meaning of its value depends on the SoC datasheet, generally in the IOMUX section. On i.MX6 IOMUXC, only the lower 17 bits are used for this purpose.</p>
			<p>Back to <strong class="source-inline">pinctrl-excerpt</strong>, prior to <a id="_idIndexMarker1380"/>selecting a pin group and applying its configuration, the driver must first obtain a handle to this group of pins using the <strong class="source-inline">devm_inctrl_get()</strong> function and then select the appropriate state using <strong class="source-inline">pinctrl_lookup_state()</strong> before finally applying the corresponding configuration state to hardware thanks to <strong class="source-inline">pinctrl_select_state()</strong>.</p>
			<p>The following is an example that shows how to grab a pin control group and apply its default configuration:</p>
			<p class="source-code">#include &lt;linux/pinctrl/consumer.h&gt;</p>
			<p class="source-code">int ret;</p>
			<p class="source-code">struct pinctrl_state *s;</p>
			<p class="source-code">struct pinctrl *p;</p>
			<p class="source-code">foo_probe()</p>
			<p class="source-code">{</p>
			<p class="source-code">    p = devm_pinctrl_get(dev);</p>
			<p class="source-code">    if (IS_ERR(p))</p>
			<p class="source-code">        return PTR_ERR(p);</p>
			<p class="source-code">    s = pinctrl_lookup_state(p, name);</p>
			<p class="source-code">    if (IS_ERR(s))</p>
			<p class="source-code">        return PTR_ERR(s);</p>
			<p class="source-code">    ret = pinctrl_select_state(p, s);</p>
			<p class="source-code">    if (ret &lt; 0) // on error</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">}</p>
			<p>Like other resources (such as memory regions, clocks, and so on), it is a good practice to grab pins and apply their configuration from within the <strong class="source-inline">probe()</strong> function. However, this operation is so common that it has been integrated into the Linux device core as a step while probing devices. Thus, when<a id="_idIndexMarker1381"/> a device is being probed, the device core will do the following:</p>
			<ul>
				<li>Grab the pins assigned to the device that is just about to probe using <strong class="source-inline">devm_pinctrl_get()</strong>.</li>
				<li>Look for the default pin state (<strong class="source-inline">PINCTRL_STATE_DEFAULT</strong>) using <strong class="source-inline">pinctrl_lookup_state()</strong>.</li>
				<li>Look in the meantime for an init (which means during the device initialization) pin state (<strong class="source-inline">PINCTRL_STATE_INIT</strong>) using the same API.</li>
				<li>Apply the init pin state if any, otherwise apply the default pin state.</li>
				<li>If power management is enabled, look for the optional sleep (<strong class="source-inline">PINCTRL_STATE_SLEEP</strong>) and idle (<strong class="source-inline">PINCTRL_STATE_IDLE</strong>) pin states for later use, during power management related operations.</li>
			</ul>
			<p>See the <strong class="source-inline">pinctrl_bind_pins()</strong> function (defined in <strong class="source-inline">drivers/base/pinctrl.c</strong>), and the <strong class="source-inline">really_probe()</strong> function (defined in <strong class="source-inline">drivers/base/dd.c</strong>), which calls the former. These functions will help you understand how pins are bound to the device on its probing path.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">pinctrl_select_state()</strong> internally calls <strong class="source-inline">pinmux_enable_setting()</strong>, which in turn calls <strong class="source-inline">pin_request()</strong> on each pin in the pin control (group of pins) node.</p>
			<p>The <strong class="source-inline">pinctrl_put()</strong> function <a id="_idIndexMarker1382"/>can be used to release a pin control that has been requested using the non-managed API, that is, <strong class="source-inline">pinctrl_get()</strong>. That said, you can use <strong class="source-inline">devm_pinctrl_get_select()</strong>, given the name of the state to select, in order to configure pinmux in a single shot. This function is defined in <strong class="source-inline">include/linux/pinctrl/consumer.h</strong> as follows:</p>
			<p class="source-code">static struct pinctrl *devm_pinctrl_get_select(</p>
			<p class="source-code">                  struct device *dev, const char *name)</p>
			<p>In the previous prototype, <strong class="source-inline">name</strong> is the name of the state as written in the <strong class="source-inline">pinctrl-name</strong> property. If the name of the state is <strong class="source-inline">default</strong>, the helper <strong class="source-inline">devm_pinctr_get_select_default()</strong> can be used, which is a wrapper around <strong class="source-inline">devm_pinctl_get_select()</strong> as follows:</p>
			<p class="source-code">static struct pinctrl * pinctrl_get_select_default(</p>
			<p class="source-code">                                      struct device *dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">   return pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);</p>
			<p class="source-code">}</p>
			<p>Now that we are familiar with the pin control subsystem (with both controller and consumer interfaces), we can learn how to deal with GPIO controllers, knowing that GPIO is an operating mode that a pin can work in.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor245"/>Dealing with the GPIO controller interface</h1>
			<p>The GPIO controller interface is<a id="_idIndexMarker1383"/> designed around a single data structure, <strong class="source-inline">struct gpio_chip</strong>. This data structure provides a set of functions, among which are methods to establish GPIO direction (input and output), methods used to access GPIO values (get and set), methods to map a given GPIO to IRQ and return the associated Linux interrupt number, and the <strong class="source-inline">debugfs</strong> dump method (showing extra state like pull-up config). Apart from these functions, that data structure provides a flag to determine the nature of the controller, that is, to allow checking whether this controller's accessors may sleep or not. Still from within this data structure, the driver can set the GPIO base number, from which GPIO numbering should start.</p>
			<p>Back to the code, a GPIO <a id="_idIndexMarker1384"/>controller is represented as an instance of <strong class="source-inline">struct gpio_chip</strong>, defined in <strong class="source-inline">&lt;linux/gpio/driver.h&gt;</strong> as follows:</p>
			<p class="source-code">struct gpio_chip {</p>
			<p class="source-code">     const char       *label;</p>
			<p class="source-code">     struct gpio_device    *gpiodev;</p>
			<p class="source-code">     struct device         *parent;</p>
			<p class="source-code">     struct module         *owner;</p>
			<p class="source-code">     int        (*request)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     void       (*free)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     int       (*get_direction)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     int       (*direction_input)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     int       (*direction_output)(struct gpio_chip *gc,</p>
			<p class="source-code">                      unsigned int offset, int value);</p>
			<p class="source-code">     int       (*get)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     int       (*get_multiple)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned long *mask,</p>
			<p class="source-code">                           unsigned long *bits);</p>
			<p class="source-code">     void       (*set)(struct gpio_chip *gc,</p>
			<p class="source-code">                      unsigned int offset, int value);</p>
			<p class="source-code">     void       (*set_multiple)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned long *mask,</p>
			<p class="source-code">                           unsigned long *bits);</p>
			<p class="source-code">     int        (*set_config)(struct gpio_chip *gc,</p>
			<p class="source-code">                            unsigned int offset,</p>
			<p class="source-code">                            unsigned long config);</p>
			<p class="source-code">     int        (*to_irq)(struct gpio_chip *gc,</p>
			<p class="source-code">                           unsigned int offset);</p>
			<p class="source-code">     int       (*init_valid_mask)(struct gpio_chip *gc,</p>
			<p class="source-code">                              unsigned long *valid_mask,</p>
			<p class="source-code">                              unsigned int ngpios);</p>
			<p class="source-code">     int       (*add_pin_ranges)(struct gpio_chip *gc);</p>
			<p class="source-code">     int        base;</p>
			<p class="source-code">     u16        ngpio;</p>
			<p class="source-code">     const char *const *names;</p>
			<p class="source-code">     bool       can_sleep;</p>
			<p class="source-code">#if IS_ENABLED(CONFIG_GPIO_GENERIC)</p>
			<p class="source-code">     unsigned long (*read_reg)(void __iomem *reg);</p>
			<p class="source-code">     void (*write_reg)(void __iomem *reg, unsigned long data);</p>
			<p class="source-code">     bool be_bits;</p>
			<p class="source-code">     void __iomem *reg_dat;</p>
			<p class="source-code">     void __iomem *reg_set;</p>
			<p class="source-code">     void __iomem *reg_clr;</p>
			<p class="source-code">     void __iomem *reg_dir_out;</p>
			<p class="source-code">     void __iomem *reg_dir_in;</p>
			<p class="source-code">     bool bgpio_dir_unreadable;</p>
			<p class="source-code">     int bgpio_bits;</p>
			<p class="source-code">     spinlock_t bgpio_lock;</p>
			<p class="source-code">     unsigned long bgpio_data;</p>
			<p class="source-code">     unsigned long bgpio_dir;</p>
			<p class="source-code">#endif /* CONFIG_GPIO_GENERIC */</p>
			<p class="source-code">#ifdef CONFIG_GPIOLIB_IRQCHIP</p>
			<p class="source-code">     struct gpio_irq_chip irq;</p>
			<p class="source-code">#endif /* CONFIG_GPIOLIB_IRQCHIP */</p>
			<p class="source-code">     unsigned long *valid_mask;</p>
			<p class="source-code">#if defined(CONFIG_OF_GPIO)</p>
			<p class="source-code">     struct device_node *of_node;</p>
			<p class="source-code">     unsigned int of_gpio_n_cells;</p>
			<p class="source-code">     int (*of_xlate)(struct gpio_chip *gc,</p>
			<p class="source-code">                const struct of_phandle_args *gpiospec,</p>
			<p class="source-code">                u32 *flags);</p>
			<p class="source-code">#endif /* CONFIG_OF_GPIO */</p>
			<p class="source-code">};</p>
			<p>The following are the meanings of<a id="_idIndexMarker1385"/> each element in the structure:</p>
			<ul>
				<li><strong class="source-inline">label</strong>: This is the GPIO controller's functional name. It could be a part number or the name of the SoC IP block implementing it.</li>
				<li><strong class="source-inline">gpiodev</strong>: This is the internal state container of the GPIO controller. It is also the structure through which the character device associated with this GPIO controller will be exposed.</li>
				<li><strong class="source-inline">request</strong> is an optional hook for chip-specific activation. If provided, it is executed prior to allocating GPIO whenever you call <strong class="source-inline">gpio_request()</strong> or <strong class="source-inline">gpiod_get()</strong>.</li>
				<li><strong class="source-inline">free</strong> is an optional hook for chip-specific deactivation. If provided, it is executed before the GPIO is deallocated whenever you call <strong class="source-inline">gpiod_put()</strong> or <strong class="source-inline">gpio_free()</strong>.</li>
				<li><strong class="source-inline">get_direction</strong> is executed whenever you need to know the direction of the GPIO offset. The return value should be <strong class="source-inline">0</strong> to mean out, and <strong class="source-inline">1</strong> to mean in (the same as <strong class="source-inline">GPIOF_DIR_XXX</strong>) or a negative error.</li>
				<li><strong class="source-inline">direction_input</strong> configures the signal offset as input, or returns an error.</li>
				<li><strong class="source-inline">get</strong> returns the value of the GPIO offset; for output signals, this returns either the value actually sensed or zero.</li>
				<li><strong class="source-inline">set</strong> assigns an output value to the GPIO offset.</li>
				<li><strong class="source-inline">set_multiple</strong> is called when you need to assign output values for multiple signals defined by <strong class="source-inline">mask</strong>. If not provided, the kernel will install a generic hook that will walk through mask bits and execute <strong class="source-inline">chip-&gt;set(i)</strong> on each bit set. See here how you can implement this function:<p class="source-code"> static void gpio_chip_set_multiple(</p><p class="source-code">                    struct gpio_chip *chip,</p><p class="source-code">                    unsigned long *mask,</p><p class="source-code">                    unsigned long *bits)</p><p class="source-code">{</p><p class="source-code">    if (chip-&gt;set_multiple) {</p><p class="source-code">        chip-&gt;set_multiple(chip, mask, bits);</p><p class="source-code">    } else {</p><p class="source-code">        unsigned int i;</p><p class="source-code">        /*</p><p class="source-code">         * set outputs if the corresponding</p><p class="source-code">         * mask bit is set</p><p class="source-code">         */</p><p class="source-code">        for_each_set_bit(i, mask, chip-&gt;ngpio)</p><p class="source-code">            chip-&gt;set(chip, i, test_bit(i, bits));</p><p class="source-code">        }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">set_debounce</strong> if supported by the controller, this hook is an optional callback provided to set the debounce time for the specified GPIO.</li>
				<li><strong class="source-inline">to_irq</strong> is an optional <a id="_idIndexMarker1386"/>hook to provide GPIO to IRQ mapping. This is called whenever you want to execute the <strong class="source-inline">gpio_to_irq()</strong> or <strong class="source-inline">gpiod_to_irq()</strong> function. This implementation may not sleep.</li>
				<li><strong class="source-inline">base</strong> indicates the first GPIO number handled by this chip; or, if negative during registration, the kernel will automatically (dynamically) assign one.</li>
				<li><strong class="source-inline">ngpio</strong> is the number of GPIOs this controller provides, starting from base to (<strong class="source-inline">base</strong> + <strong class="source-inline">ngpio - 1</strong>).</li>
				<li><strong class="source-inline">names</strong>, if not <strong class="source-inline">NULL</strong>, must be a list (an array) of strings to use as alternative names for the GPIOs in this chip. The array must be <strong class="source-inline">ngpio</strong> sized, and any GPIO that does not need an alias may have its entry set to <strong class="source-inline">NULL</strong> in the array.</li>
				<li><strong class="source-inline">can_sleep</strong> is a Boolean flag to be set if <strong class="source-inline">get()</strong>/<strong class="source-inline">set()</strong> methods may sleep. It is the case for GPIO controllers (also known as GPIO expanders) sitting on buses such as I2C or SPI, whose accesses may lead to sleep. This means that if the chip supports IRQs, these IRQs must be threaded because the chip access may sleep when, for example, reading out the IRQ status registers. For a GPIO controller mapped to memory (part of SoC), this can be set to <strong class="source-inline">false</strong>.</li>
				<li>Elements that are conditioned by the enabling of <strong class="source-inline">CONFIG_GPIO_GENERIC</strong> are related to a generic memory-mapped GPIO controller, with a standard register set.</li>
				<li><strong class="source-inline">irq</strong>: The IRQ chip of<a id="_idIndexMarker1387"/> this GPIO controller if the controller can map GPIOs to IRQs. In such cases, this field must be set up before the GPIO chip is registered.</li>
				<li><strong class="source-inline">valid_mask</strong>: If not <strong class="source-inline">NULL</strong>, this element contains a bitmask of GPIOs that are valid to be used from the chip.</li>
				<li><strong class="source-inline">of_node</strong> is a pointer to the device tree node representing this GPIO controller.</li>
				<li><strong class="source-inline">of_gpio_n_cells</strong> is the number of cells used to form the GPIO specifier.</li>
				<li><strong class="source-inline">of_xlate</strong> is a callback to translate a device tree GPIO specifier into a chip relative GPIO number and flags. This hook is invoked when a GPIO line from this controller is specified in the device tree and must be parsed. If not provided, the GPIO core will set it to <strong class="source-inline">of_gpio_simple_xlate()</strong> by default, which is a generic GPIO core helper that supports two cell specifiers. The first cell identifies the GPIO number, and the second one, the GPIO flags. Additionally, when setting the default callback, <strong class="source-inline">of_gpio_n_cells</strong> will be set to <strong class="source-inline">2</strong>. If the GPIO controller needs one or more than two cell specifiers, you'll have to implement the corresponding translation callback.</li>
			</ul>
			<p>Each GPIO controller exposes a number of signals that are identified in function calls by offset values in the range of <strong class="source-inline">0</strong> to (<strong class="source-inline">ngpio - 1</strong>). When those GPIO lines are referenced through calls such as <strong class="source-inline">gpio_get_value(gpio)</strong>, the offset is determined by subtracting <strong class="source-inline">base</strong> from the GPIO number and passed to the underlying driver function (<strong class="source-inline">gpio_chip-&gt;get()</strong> for example). The<a id="_idIndexMarker1388"/> controller driver should then have the logic to map this offset to the control/status register associated with the GPIO.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor246"/>Writing a GPIO controller driver</h2>
			<p>A GPIO controller needs <a id="_idIndexMarker1389"/>nothing but the set of callbacks that correspond to the features it supports. After every callback of interest has been defined and other fields set, the driver should call <strong class="source-inline">devm_gpiochip_add_data()</strong> on the configured <strong class="source-inline">struct gpio_chip</strong> structure in order to register the controller with the kernel. You have probably guessed that you'd better use the managed API (the <strong class="source-inline">devm_</strong> prefix) since it takes care of chip removal when necessary and releasing resources. If, however, you used the classical method, you will have to use <strong class="source-inline">gpiochip_remove()</strong> to remove the chip if necessary: </p>
			<p class="source-code">int gpiochip_add_data(struct gpio_chip *gc, void *data)</p>
			<p class="source-code">int devm_gpiochip_add_data(struct device *dev,</p>
			<p class="source-code">                        struct gpio_chip *gc, void *data)</p>
			<p>In the preceding prototypes, <strong class="source-inline">gc</strong> is the chip to register and <strong class="source-inline">data</strong> is the driver's private data associated with this chip. They both return a negative error code if the chip can't be registered, such as because <strong class="source-inline">gc-&gt;base</strong> is invalid or already associated with a different chip. Otherwise, they return zero as a success code.</p>
			<p>There are, however, pin controllers that are tightly coupled to the GPIO chip, and both are implemented in the same driver, much of which being in <strong class="source-inline">drivers/pinctrl/pinctrl-*.c</strong>. In such drivers, when <strong class="source-inline">gpiochip_add_data()</strong> is invoked, for device-tree-supported systems, the GPIO core will check the pin control's device node for the <strong class="source-inline">gpio-ranges</strong> property. If it is present, it will take care of adding the pin ranges for the driver. </p>
			<p>However, the driver must call <strong class="source-inline">gpiochip_add_pin_range()</strong> in order to be compatible with older, existing device tree files that don't set the <strong class="source-inline">gpio-ranges</strong> attribute or systems that use ACPI. The following is an example:</p>
			<p class="source-code">if (!of_find_property(np, "gpio-ranges", NULL)) {</p>
			<p class="source-code">     ret = gpiochip_add_pin_range(chip,</p>
			<p class="source-code">                   dev_name(hw-&gt;dev), 0, 0, chip-&gt;ngpio);</p>
			<p class="source-code">     if (ret &lt; 0) {</p>
			<p class="source-code">           gpiochip_remove(chip);</p>
			<p class="source-code">           return ret;</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>Once more, it must be<a id="_idIndexMarker1390"/> noted that the preceding is used just for backward compatibility for these old <strong class="source-inline">pinctrl</strong> nodes without the <strong class="source-inline">gpio-ranges</strong> property. Otherwise, calling <strong class="source-inline">gpiochip_add_pin_range()</strong> directly from a device tree-supported pin controller driver is deprecated. Please see <em class="italic">Section 2.1</em> of <strong class="source-inline">Documentation/devicetree/bindings/gpio/gpio.txt</strong> on how to bind pin controller and GPIO drivers via the <strong class="source-inline">gpio-ranges</strong> property.</p>
			<p>We can see how easy it is to write a GPIO controller driver. In the book sources repository, you will find a working GPIO controller driver, for the MCP23016 I2C I/O expander from microchip, whose datasheet is available at <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf">http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf</a>.</p>
			<p>To write such drivers, the following header should be included:</p>
			<p class="source-code">#include &lt;linux/gpio.h&gt; </p>
			<p>Following is an excerpt from the driver we have written for our controller:</p>
			<p class="source-code">#define GPIO_NUM 16</p>
			<p class="source-code">struct mcp23016 {</p>
			<p class="source-code">    struct i2c_client *client;</p>
			<p class="source-code">    struct gpio_chip gpiochip;</p>
			<p class="source-code">    struct mutex lock;</p>
			<p class="source-code">};</p>
			<p class="source-code">static int mcp23016_probe(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">  struct mcp23016 *mcp;</p>
			<p class="source-code">  </p>
			<p class="source-code">  if (!i2c_check_functionality(client-&gt;adapter,</p>
			<p class="source-code">      I2C_FUNC_SMBUS_BYTE_DATA))</p>
			<p class="source-code">    return -EIO;</p>
			<p class="source-code">  mcp = devm_kzalloc(&amp;client-&gt;dev, sizeof(*mcp),</p>
			<p class="source-code">                      GFP_KERNEL);</p>
			<p class="source-code">  if (!mcp)</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">  mcp-&gt;gpiochip.label = client-&gt;name;</p>
			<p class="source-code">  mcp-&gt;gpiochip.base = -1;</p>
			<p class="source-code">  mcp-&gt;gpiochip.dev = &amp;client-&gt;dev;</p>
			<p class="source-code">  mcp-&gt;gpiochip.owner = THIS_MODULE;</p>
			<p class="source-code">  mcp-&gt;gpiochip.ngpio = GPIO_NUM; /* 16 */</p>
			<p class="source-code">  /* may not be accessed from atomic context */</p>
			<p class="source-code">  mcp-&gt;gpiochip.can_sleep = 1; </p>
			<p class="source-code">  mcp-&gt;gpiochip.get = mcp23016_get_value;</p>
			<p class="source-code">  mcp-&gt;gpiochip.set = mcp23016_set_value;</p>
			<p class="source-code">  mcp-&gt;gpiochip.direction_output =</p>
			<p class="source-code">                          mcp23016_direction_output;</p>
			<p class="source-code">  mcp-&gt;gpiochip.direction_input =</p>
			<p class="source-code">                          mcp23016_direction_input;</p>
			<p class="source-code">  mcp-&gt;client = client;</p>
			<p class="source-code">  i2c_set_clientdata(client, mcp);</p>
			<p class="source-code">  return devm_gpiochip_add_data(&amp;client-&gt;dev,</p>
			<p class="source-code">                                &amp;mcp-&gt;gpiochip, mcp);</p>
			<p class="source-code">}</p>
			<p>In the preceding excerpt, the <a id="_idIndexMarker1391"/>GPIO chip data structure has been set up before being passed to <strong class="source-inline">devm_gpiochip_get_data()</strong>, which is called to register the GPIO controller with the system. As a result, a GPIO character device node will appear under <strong class="source-inline">/dev</strong>.</p>
			<h3>IRQ chip enabled GPIO controllers</h3>
			<p>IRQ chip support can be <a id="_idIndexMarker1392"/>enabled in a GPIO controller by setting up the <strong class="source-inline">struct gpio_irq_chip</strong> structure embedded into this GPIO controller data structure. This <strong class="source-inline">struct gpio_irq_chip</strong> structure is used to group all fields related to interrupt handling in a GPIO chip and is defined as follows:</p>
			<p class="source-code">struct gpio_irq_chip {</p>
			<p class="source-code">     struct irq_chip *chip;</p>
			<p class="source-code">     struct irq_domain *domain;</p>
			<p class="source-code">     const struct irq_domain_ops *domain_ops;</p>
			<p class="source-code">     irq_flow_handler_t handler;</p>
			<p class="source-code">     unsigned int default_type;</p>
			<p class="source-code">     irq_flow_handler_t parent_handler;</p>
			<p class="source-code">     union {</p>
			<p class="source-code">          void *parent_handler_data;</p>
			<p class="source-code">          void **parent_handler_data_array;</p>
			<p class="source-code">     };</p>
			<p class="source-code">     unsigned int num_parents;</p>
			<p class="source-code">     unsigned int *parents;</p>
			<p class="source-code">     unsigned int *map;</p>
			<p class="source-code">     bool threaded;</p>
			<p class="source-code">     bool per_parent_data;</p>
			<p class="source-code">     int (*init_hw)(struct gpio_chip *gc);</p>
			<p class="source-code">     void (*init_valid_mask)(struct gpio_chip *gc,</p>
			<p class="source-code">                      unsigned long *valid_mask,</p>
			<p class="source-code">                      unsigned int ngpios);</p>
			<p class="source-code">     unsigned long *valid_mask;</p>
			<p class="source-code">     unsigned int first;</p>
			<p class="source-code">     void       (*irq_enable)(struct irq_data *data);</p>
			<p class="source-code">     void       (*irq_disable)(struct irq_data *data);</p>
			<p class="source-code">     void       (*irq_unmask)(struct irq_data *data);</p>
			<p class="source-code">     void       (*irq_mask)(struct irq_data *data);</p>
			<p class="source-code">};</p>
			<p>There are architectures that may be multiple interrupt controllers involved in delivering an interrupt from the device to the target CPU. This feature is enabled in the kernel by setting the <strong class="source-inline">CONFIG_IRQ_DOMAIN_HIERARCHY</strong> config option.</p>
			<p>In the previous data<a id="_idIndexMarker1393"/> structure, some elements have been omitted. These are elements conditioned by <strong class="source-inline">CONFIG_IRQ_DOMAIN_HIERARCHY</strong>, that is, IRQ domain hierarchy related fields, which we won't discuss in this chapter. For the remaining elements, the following are their definitions:</p>
			<ul>
				<li><strong class="source-inline">chip</strong> is the IRQ chip implementation.</li>
				<li><strong class="source-inline">domain</strong> is the IRQ interrupt translation domain associated with <strong class="source-inline">chip</strong>; it is responsible for mapping between the GPIO hardware IRQ number and Linux IRQ number.</li>
				<li><strong class="source-inline">domain_ops</strong> represents the set of interrupt domain operations associated with the IRQ domain.</li>
				<li><strong class="source-inline">handler</strong> is the high-level interrupt flow handler (typically a predefined IRQ core function) for GPIO IRQs. There is a note on this field later in the section.</li>
				<li><strong class="source-inline">default_type</strong> is the default IRQ triggering type applied during GPIO driver initialization.</li>
				<li><strong class="source-inline">parent_handler</strong> is the interrupt handler for the GPIO chip's parent interrupts. It may be <strong class="source-inline">NULL</strong> if the parent interrupts are nested rather than chained. Moreover, setting this element to <strong class="source-inline">NULL</strong> will allow handling the parent IRQ in the driver. <strong class="source-inline">gpio_chip.can_sleep</strong> cannot be set to <strong class="source-inline">true</strong> if this handler is supplied because you cannot have chained interrupts on a chip that may sleep.</li>
				<li><strong class="source-inline">parent_handler_data</strong> and <strong class="source-inline">parent_handler_data_array</strong> are data associated with, and passed to, the handler for the parent interrupt. This can either be a single pointer if <strong class="source-inline">per_parent_data</strong> is <strong class="source-inline">false</strong>, or an array of <strong class="source-inline">num_parents</strong> pointers otherwise. If <strong class="source-inline">per_parent_data</strong> is <strong class="source-inline">true</strong>, <strong class="source-inline">parent_handler_data_array</strong> cannot be <strong class="source-inline">NULL</strong>.</li>
				<li><strong class="source-inline">num_parents</strong> is the number of interrupt parents for the GPIO chip.</li>
				<li><strong class="source-inline">parents</strong> is a list of interrupt parents of the GPIO chip. Because the driver owns this list, the core will only refer to it, not edit it.</li>
				<li><strong class="source-inline">map</strong> is a list of interrupt parents for each line of the GPIO chip.</li>
				<li><strong class="source-inline">threaded</strong> indicates whether the interrupt handling is threaded (uses nested threads).</li>
				<li><strong class="source-inline">per_parent_data</strong> tells whether <strong class="source-inline">parent_handler_data_array</strong> describes a <strong class="source-inline">num_parents</strong> sized array to be used as parent data.</li>
				<li><strong class="source-inline">init_hw</strong> is an optional<a id="_idIndexMarker1394"/> routine for initializing hardware before an IRQ chip will be added. This is extremely beneficial when a driver has to clear IRQ-related registers in order to avoid unwanted events.</li>
				<li><strong class="source-inline">init_valid_mask</strong> is an optional callback that can be used to initialize <strong class="source-inline">valid_mask</strong>, which is used if not all GPIO lines are valid interrupts. There might be lines that just cannot fire interrupts, and this callback, when defined, is passed a bitmap in <strong class="source-inline">valid_mask</strong>, which will have <strong class="source-inline">ngpios</strong> bits from <strong class="source-inline">0..(ngpios-1)</strong> set to <strong class="source-inline">1</strong> as valid. The callback can then directly set some bits to <strong class="source-inline">0</strong> if they cannot be used for interrupts.</li>
				<li><strong class="source-inline">valid_mask</strong>, if not <strong class="source-inline">NULL</strong>, contains a bitmask of GPIOs that are valid for inclusion in the IRQ domain of the chip.</li>
				<li><strong class="source-inline">first</strong> is necessary in the case of static IRQ allocation. If set, <strong class="source-inline">irq_domain_add_simple()</strong> will allocate (starting from this value) and map all IRQs during initialization.</li>
				<li><strong class="source-inline">irq_enable</strong>, <strong class="source-inline">irq_disable</strong>, <strong class="source-inline">irq_unmask</strong>, and <strong class="source-inline">irq_mask</strong> respectively store old <strong class="source-inline">irq_chip.irq_enable</strong>, <strong class="source-inline">irq_chip.irq_disable</strong>, <strong class="source-inline">irq_chip.irq_unmask</strong>, and <strong class="source-inline">irq_chip.irq_mask</strong> callbacks. See <a href="B17934_13_Epub.xhtml#_idTextAnchor194"><em class="italic">Chapter 13</em></a>, <em class="italic">Demystifying the Kernel IRQ Framework</em>, for a detailed explanation.</li>
			</ul>
			<p>Under the premise that your interrupts are 1-to-1 mapped to the GPIO line index, <strong class="source-inline">gpiolib</strong> will handle a significant portion of overhead code. In this 1-to-1 mapping, GPIO line offset 0 maps to<a id="_idIndexMarker1395"/> hardware IRQ 0, GPIO line offset <strong class="source-inline">1</strong> maps to hardware IRQ <strong class="source-inline">1</strong>, and so on until GPIO line offset <strong class="source-inline">ngpio-1</strong>, which maps to hardware IRQ <strong class="source-inline">ngpio-1</strong>. The bitmask <strong class="source-inline">valid_mask</strong> and the flag <strong class="source-inline">need_valid_mask</strong> in <strong class="source-inline">gpio_irq_chip</strong> can be used to mask off some lines as invalid for associating with IRQs, provided some GPIO lines do not have corresponding IRQs.</p>
			<p>We can divide GPIO IRQ chips into two broad categories:</p>
			<ul>
				<li><strong class="bold">Cascaded interrupt chips</strong>: This<a id="_idIndexMarker1396"/> indicates that the GPIO chip has a single common interrupt output line that is triggered by any enabled GPIO line on that chip. The interrupt output line is subsequently routed to a parent interrupt controller one level up, which in the simplest case is the system's primary interrupt controller. An IRQ chip implements this by inspecting bits inside the GPIO controller to determine which line fired it. To figure this out, the IRQ chip part of the driver will need to inspect registers, and it will almost certainly need to acknowledge that it is handling the interrupt by clearing some bits (sometimes implicitly, by simply reading a status register), as well as setting up configurations such as edge sensitivity (rising or falling edge or a high/low level interrupt, for example). </li>
				<li><strong class="bold">Hierarchical interrupt chips</strong>: This <a id="_idIndexMarker1397"/>means that each GPIO line is connected to a parent interrupt controller one level up by a dedicated IRQ line. It is not necessary to query the GPIO hardware to determine which line has fired, but you might need to acknowledge the interrupt and configure edge sensitivity.</li>
			</ul>
			<p>Cascaded GPIO IRQ chips usually fall in one of three categories:</p>
			<ul>
				<li><strong class="bold">Chained cascaded GPIO IRQ chips</strong>: These <a id="_idIndexMarker1398"/>are the types that are usually seen on SoCs. This means that the GPIOs have a fast IRQ flow handler that is called in a chain from the parent IRQ handler, which is usually the system interrupt controller. This means that the parent IRQ chip will immediately call the GPIO IRQ chip handler while holding the IRQs disabled. In its interrupt handler, the GPIO IRQ chip will then call something similar to this:<p class="source-code">  static irqreturn_t foo_gpio_irq(int irq, void *data)</p><p class="source-code">      chained_irq_enter(...);</p><p class="source-code">      generic_handle_irq(...);</p><p class="source-code">      chained_irq_exit(...);</p></li>
			</ul>
			<p>Because<a id="_idIndexMarker1399"/> everything happens directly in the callback, chained GPIO IRQ chips cannot set the <strong class="source-inline">.can_sleep</strong> flag on <strong class="source-inline">struct gpio_chip</strong> to <strong class="source-inline">true</strong>. In this case, no slow bus traffic like I2C can be used.</p>
			<ul>
				<li><strong class="bold">Generic chained GPIO IRQ chips</strong>: These <a id="_idIndexMarker1400"/>are the same as <strong class="source-inline">CHAINED GPIO IRQCHIPS</strong>, but they don't use chained IRQ handlers. GPIO IRQs are instead dispatched via a generic IRQ handler, which is specified using <strong class="source-inline">request_irq()</strong>. In this IRQ handler, the GPIO IRQ chip will then end up calling something similar to the following sequence:<p class="source-code">static irqreturn_t gpio_rcar_irq_handler(int irq,</p><p class="source-code">                                    void *dev_id)</p><p class="source-code">    /* go through the entire GPIOs and handle</p><p class="source-code">     * all interrupts</p><p class="source-code">     */</p><p class="source-code">    for each detected GPIO IRQ</p><p class="source-code">        generic_handle_irq(...);</p></li>
				<li><strong class="bold">Nested thread GPIO IRQ chips</strong>: Off-chip<a id="_idIndexMarker1401"/> GPIO expanders and any other GPIO IRQ chip sitting on a sleeping bus, such as I2C or SPI, fall under this category.</li>
			</ul>
			<p>Of course, such drivers who require sluggish bus traffic to read out IRQ status and other information, traffic which may result in further IRQs, cannot be accommodated in a rapid IRQ handler with IRQs disabled. Instead, they must create a thread and then mask the parent IRQ line until the interrupt is handled by the driver. This driver's distinguishing feature is that it calls something like the following in its<a id="_idIndexMarker1402"/> interrupt handler:</p>
			<p class="source-code">static irqreturn_t pcf857x_irq(int irq,</p>
			<p class="source-code">                               void *data)</p>
			<p class="source-code">{</p>
			<p class="source-code">     struct pcf857x *gpio = data;</p>
			<p class="source-code">     unsigned long change, i, status;</p>
			<p class="source-code">     status = gpio-&gt;read(gpio-&gt;client);</p>
			<p class="source-code">     mutex_lock(&amp;gpio-&gt;lock);</p>
			<p class="source-code">     change = (gpio-&gt;status ^ status) &amp;</p>
			<p class="source-code">              gpio-&gt;irq_enabled;</p>
			<p class="source-code">     gpio-&gt;status = status;</p>
			<p class="source-code">     mutex_unlock(&amp;gpio-&gt;lock);</p>
			<p class="source-code">     for_each_set_bit(i, &amp;change, gpio-&gt;chip.ngpio)</p>
			<p class="source-code">      child_irq = irq_find_mapping(</p>
			<p class="source-code">                     gpio-&gt;chip.irq.domain, i);</p>
			<p class="source-code">        handle_nested_irq(child_irq);</p>
			<p class="source-code">     return IRQ_HANDLED;</p>
			<p class="source-code">}</p>
			<p>Threaded GPIO IRQ chips are distinguished by the fact that they set the <strong class="source-inline">.can_sleep</strong> flag on <strong class="source-inline">struct gpio_chip</strong> to <strong class="source-inline">true</strong>, indicating that the chip can sleep when <a id="_idIndexMarker1403"/>accessing the GPIOs.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is worth recalling that <strong class="source-inline">gpio_irq_chip.handler</strong> is the interrupt flow handler. It is the high-level IRQ-events handler, the one that calls the underlying handlers registered by client drivers using <strong class="source-inline">request_irq()</strong> or <strong class="source-inline">request_threaded_irq()</strong>. Its value depends on the IRQ being edge- or level-triggered. It is most often a predefined IRQ core function, one between <strong class="source-inline">handle_simple_irq</strong>, <strong class="source-inline">handle_edge_irq</strong>, and <strong class="source-inline">handle_level_irq</strong>. These are all kernel helper functions that do some operations before and after calling the real IRQ handler.</p>
			<p class="callout">When the parent IRQ handler calls <strong class="source-inline">generic_handle_irq()</strong> or <strong class="source-inline">handle_nested_irq()</strong>, the IRQ core will look for the IRQ descriptor structure (Linux's view of an interrupt) corresponding to the Linux IRQ number passed as an argument (<strong class="source-inline">struct irq_desc *desc = irq_to_desc(irq)</strong>) and calling <strong class="source-inline">generic_handle_irq_desc()</strong> on this descriptor, which will result in <strong class="source-inline">desc-&gt;handle_irq(desc)</strong>. You should note that <strong class="source-inline">desc-&gt;handle_irq</strong> corresponds to the high-level IRQ handler supplied earlier, which has been assigned to the IRQ descriptor using <strong class="source-inline">irq_set_chip_and_handler()</strong> during the mapping of this IRQ. Guess what, the mapping of these GPIO IRQs is done in <strong class="source-inline">gpiochip_irq_map</strong>, which is the <strong class="source-inline">.map</strong> callback of the default IRQ domain operation table (<strong class="source-inline">gpiochip_domain_ops</strong>) assigned by the GPIO core to the GPIO IRQ chip if not provided by the driver.</p>
			<p class="callout">To summarize, <strong class="source-inline">desc-&gt;handle_irq = gpio_irq_chip.handler</strong>, which may be <strong class="source-inline">handle_level_irq</strong>, <strong class="source-inline">handle_simple_irq</strong>, <strong class="source-inline">handle_edge_irq</strong>, or (rarely) a driver-provided function.</p>
			<h4>Example of adding IRQ chip support in a GPIO chip</h4>
			<p>In this section, we will <a id="_idIndexMarker1404"/>demonstrate how to add the support of an IRQ chip into a GPIO controller driver. To do that, we will update our initial driver, more precisely, the probe method, as well as implementing an interrupt handler, which will hold the IRQ handling logic.</p>
			<p>Let's consider the following figure:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B17934_16_001.jpg" alt="Figure 16.1 – Multiplexing IRQs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – Multiplexing IRQs</p>
			<p>In the previous figure, let's consider that we have configured <strong class="source-inline">io_0</strong> and <strong class="source-inline">io_1</strong> as interrupt lines (this is what <strong class="source-inline">DeviceA</strong> and <strong class="source-inline">deviceB</strong> see). </p>
			<p>Whether an interrupt happens on <strong class="source-inline">io_0</strong> or <strong class="source-inline">io_1</strong>, the same parent interrupt line will be raised on the GPIO <a id="_idIndexMarker1405"/>chip. At this step, the GPIO chip driver must figure out, by reading the GPIO status register of the GPIO controller, which GPIO line (<strong class="source-inline">io_0</strong> or <strong class="source-inline">io_1</strong>) has really fired the interrupt. This is how, in the case of the MCP23016 chip, a single interrupt line (the parent actually) can be a multiplex for 16 GPIO interrupts.</p>
			<p>Now let's update the initial GPIO controller driver. It must be noted that because the device sits on a slow bus, we have no choice but to implement nested (threaded) interrupt flow handling.</p>
			<p>We start by defining our IRQ chip data structure, with a set of callbacks that can be used by the IRQ core. The following is an excerpt:</p>
			<p class="source-code">static struct irq_chip mcp23016_irq_chip = {</p>
			<p class="source-code">     .name = "gpio-mcp23016",</p>
			<p class="source-code">     .irq_mask = mcp23016_irq_mask,</p>
			<p class="source-code">     .irq_unmask = mcp23016_irq_unmask,</p>
			<p class="source-code">     .irq_set_type = mcp23016_irq_set_type,</p>
			<p class="source-code">};</p>
			<p>In the preceding, the callbacks that have been defined depend on the need. In our case, we have only implemented interrupt (un)masking related callbacks, as well as the callback allowing you to set the IRQ type. To see the full description of a <strong class="source-inline">struct irq_chip</strong> structure, you can refer to <a href="B17934_13_Epub.xhtml#_idTextAnchor194"><em class="italic">Chapter 13</em></a>, <em class="italic">Demystifying the Kernel IRQ Framework</em>.</p>
			<p>Now that the IRQ<a id="_idIndexMarker1406"/> chip data structure has been set up, we can modify the probe method as follows:</p>
			<p class="source-code">static int mcp23016_probe(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct gpio_irq_chip *girq;</p>
			<p class="source-code">    struct irq_chip *irqc;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    girq = &amp;mcp-&gt;gpiochip.irq;</p>
			<p class="source-code">    girq-&gt;chip = &amp;mcp23016_irq_chip;</p>
			<p class="source-code">    /* This will let us handling the parent IRQ in the driver */</p>
			<p class="source-code">    girq-&gt;parent_handler = NULL;</p>
			<p class="source-code">    girq-&gt;num_parents = 0;</p>
			<p class="source-code">    girq-&gt;parents = NULL;</p>
			<p class="source-code">    girq-&gt;default_type = IRQ_TYPE_NONE;</p>
			<p class="source-code">    girq-&gt;handler = handle_level_irq;</p>
			<p class="source-code">    girq-&gt;threaded = true;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    /*</p>
			<p class="source-code">     * Directly request the irq here instead of passing</p>
			<p class="source-code">     * a flow-handler.</p>
			<p class="source-code">     */</p>
			<p class="source-code">    err = devm_request_threaded_irq(</p>
			<p class="source-code">                      &amp;client-&gt;dev,</p>
			<p class="source-code">                      client-&gt;irq,</p>
			<p class="source-code">                      NULL, mcp23016_irq,</p>
			<p class="source-code">                      IRQF_TRIGGER_RISING | IRQF_ONESHOT,</p>
			<p class="source-code">                      dev_name(&amp;i2c-&gt;dev), mcp);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    </p>
			<p class="source-code">    return devm_gpiochip_add_data(&amp;client-&gt;dev,</p>
			<p class="source-code">                                &amp;mcp-&gt;gpiochip, mcp);</p>
			<p class="source-code">}</p>
			<p>In the previous probe <a id="_idIndexMarker1407"/>method update, we first initialized the <strong class="source-inline">struct gpio_irq_chip</strong> data structure embedded into <strong class="source-inline">struct gpio_chip</strong>, and then we registered an IRQ handler, which will act as the parent IRQ handler, responsible for enquiring the underlying GPIO chip for any IRQ-enabled GPIOs that have changed, and then running their IRQ handlers, if any.</p>
			<p>Finally, the following is our IRQ handler, which must have been implemented before the <strong class="source-inline">probe</strong> function:</p>
			<p class="source-code">static irqreturn_t mcp23016_irq(int irq, void *data)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct mcp23016 *mcp = data;</p>
			<p class="source-code">    unsigned long status, changes, child_irq, i;</p>
			<p class="source-code">    status = read_gpio_status(mcp);</p>
			<p class="source-code">    mutex_lock(&amp;mcp-&gt;lock);</p>
			<p class="source-code">    change = mcp-&gt;status ^ status;</p>
			<p class="source-code">    mcp-&gt;status = status;</p>
			<p class="source-code">    mutex_unlock(&amp;mcp-&gt;lock);</p>
			<p class="source-code">    /* Do some stuff, may be adapting "change" according to level */</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    for_each_set_bit(i, &amp;change, mcp-&gt;gpiochip.ngpio) {</p>
			<p class="source-code">        child_irq =</p>
			<p class="source-code">           irq_find_mapping(mcp-&gt;gpiochip.irq.domain, i);</p>
			<p class="source-code">        handle_nested_irq(child_irq);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return IRQ_HANDLED;</p>
			<p class="source-code">}</p>
			<p>In our interrupt handler, we <a id="_idIndexMarker1408"/>simply read the current GPIO, and we compare it with the old status to determine GPIOs that have changes. All the tricks are handled by <strong class="source-inline">handle_nested_irq()</strong>, which is explained in <a href="B17934_13_Epub.xhtml#_idTextAnchor194"><em class="italic">Chapter 13</em></a>, <em class="italic">Demystifying the Kernel IRQ Framework</em>, as well.</p>
			<p>Now that we are done and are familiar with the implementation of IRQ chips in GPIO controller drivers, we can learn about the binding of these GPIO controllers, which will allow declaring the GPIO chip hardware in the device tree in a way the driver understands.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor247"/>GPIO controller bindings</h2>
			<p>The device tree is the de facto <a id="_idIndexMarker1409"/>standard to declare and describe devices on embedded platforms, especially on ARM architectures. It this then recommended for new drivers to provide the associated device bindings.</p>
			<p>Back to GPIO controllers, there are mandatory properties that need to be provided:</p>
			<ul>
				<li><strong class="source-inline">compatible</strong>: This is the list of strings to match the driver(s) that will handle this device.</li>
				<li><strong class="source-inline">gpio-controller</strong>: This is a property that indicates to the device tree core that this node represents a GPIO controller.</li>
				<li><strong class="source-inline">gpio-cells</strong>: Tells how many cells are used to describe a GPIO specifier. It should correspond to <strong class="source-inline">gpio_chip.of_gpio_n_cells</strong>, or to a value that <strong class="source-inline">gpio_chip.of_xlate</strong> can deal with. It is typically <strong class="source-inline">&lt;2&gt;</strong> for a less complex controller, with the first cell identifying the GPIO number, and the second defining the flags. </li>
			</ul>
			<p>There are additional mandatory properties to define if the GPIO controller has IRQ chip support, that is, if this controller allows mapping its GPIO lines to IRQs. With such GPIO controllers, the following mandatory properties must be provided:</p>
			<ul>
				<li><strong class="source-inline">interrupt-controller</strong>: Some controllers provide IRQs mapped to the GPIOs. In that case, the property <strong class="source-inline">#interrupt-cells</strong> should be set too and usually you use <strong class="source-inline">2</strong>, but it depends on your needs. The first cell is the pin number, and the second represents the interrupt flags.</li>
				<li><strong class="source-inline">#interrupt-cells</strong>: This must be defined as a value supported by the <strong class="source-inline">xlate</strong> hook of the IRQ domain, that is, <strong class="source-inline">irq_domain_ops.xlate</strong>. It is common for this hook to be set with <strong class="source-inline">irq_domain_xlate_twocell</strong>, which is a generic kernel IRQ core helper able to handle a two-cell specifier.</li>
			</ul>
			<p>From the properties listed, we can declare our GPIO controller under its bus node, as follows:</p>
			<p class="source-code">&amp;i2c1</p>
			<p class="source-code">    expander: mcp23016@20 {</p>
			<p class="source-code">        compatible = "microchip,mcp23016";</p>
			<p class="source-code">        reg = &lt;0x20&gt;;</p>
			<p class="source-code">        gpio-controller;</p>
			<p class="source-code">        #gpio-cells = &lt;2&gt;;</p>
			<p class="source-code">        interrupt-controller;</p>
			<p class="source-code">        #interrupt-cells = &lt;2&gt;;</p>
			<p class="source-code">        interrupt-parent = &lt;&amp;gpio4&gt;;</p>
			<p class="source-code">        interrupts = &lt;29 IRQ_TYPE_EDGE_FALLING&gt;;</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>This is all for the <a id="_idIndexMarker1410"/>controller side. In order to demonstrate how clients can consume resources provided by the MCP23016, let's consider the following scenario: we have two devices, device A, named <strong class="source-inline">foo</strong>, and device B, named <strong class="source-inline">bar</strong>. The <strong class="source-inline">bar</strong> device consumes two GPIO lines from our controller (they will be used in output mode), and the <strong class="source-inline">foo</strong> device would like to map a GPIO to IRQ. This configuration could be declared in the device tree as follows:</p>
			<p class="source-code">parent_node {</p>
			<p class="source-code">    compatible = "simple-bus";</p>
			<p class="source-code">    foo_device: foo_device@1c {</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">        reg = &lt;0x1c&gt;;</p>
			<p class="source-code">        interrupt-parent = &lt;&amp;expander&gt;;</p>
			<p class="source-code">        interrupts = &lt;2 IRQ_TYPE_EDGE_RISING&gt;;</p>
			<p class="source-code">    };</p>
			<p class="source-code">    bar_device {</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">        reset-gpios = &lt;&amp;expander 8 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">        power-gpios = &lt;&amp;expander 12 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">        [...]</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>In the preceding<a id="_idIndexMarker1411"/> excerpt, <strong class="source-inline">parent_node</strong> is given <strong class="source-inline">simple-bus</strong> as a <strong class="source-inline">compatible</strong> string in order to instruct the device tree core and the platform core to instantiate two platform devices, which correspond to our nodes. In that excerpt, we have also demonstrated how GPIOs, as well as IRQs from our controller, are specified. The number of cells used for each property matches the declaration in the controller binding.</p>
			<h3>GPIO- and pin-controller interaction</h3>
			<p>These two subsystems are closely related. A pin controller can route some or all of the GPIOs provided by a GPIO controller<a id="_idIndexMarker1412"/> to pins on the package. This allows those pins to be muxed (also known as pinmuxing) between GPIO and other functions.</p>
			<p>It may then be useful to know which GPIOs correspond to which pins on which pin controllers. The <strong class="source-inline">gpio-ranges</strong> property, which will be described below, represents this correspondence with a discrete set of ranges that map pins from the pin controller local number space to pins in the GPIO controller local number space.</p>
			<p>The <strong class="source-inline">gpio-ranges</strong> format is the following:</p>
			<p class="source-code">&lt;[pin controller phandle], [GPIO controller offset], [pin controller offset], [number of pins]&gt;;</p>
			<p>The GPIO controller offset refers to the GPIO controller node containing the range definition. The bindings defined in <strong class="source-inline">Documentation/pinctrl/pinctrl-bindings.txt</strong> must be followed by the pin controller node referenced by <strong class="source-inline">phandle</strong>.</p>
			<p>Each offset is a number between 0 and N. It is possible to stack any number of ranges with just one pin-to-GPIO line mapping if the ranges are concocted, but in practice, these ranges are generally gathered together as discrete sets.</p>
			<p>The following is an example:</p>
			<p class="source-code">gpio-ranges = &lt;&amp;foo 0 20 10&gt;, &lt;&amp;bar 10 50 20&gt;;</p>
			<p>This means the following:</p>
			<ul>
				<li>Ten pins (<strong class="source-inline">20..29</strong>) on pin controller <strong class="source-inline">foo</strong> are mapped to GPIO lines <strong class="source-inline">0..9</strong>.</li>
				<li>Twenty pins ( <strong class="source-inline">50..69</strong> ) on pin controller <strong class="source-inline">bar</strong> are mapped to GPIO lines <strong class="source-inline">10..29</strong>.</li>
			</ul>
			<p>It must be noted that GPIOs have a global number space and the pin controller has a local number space, so we need to define a way to cross-reference them.</p>
			<p>We want to map PIN <strong class="source-inline">GPIO_5_29</strong> with PIN number <strong class="source-inline">89</strong> in the pin controller number space. The following is the device tree property to define the mapping between the GPIO and<a id="_idIndexMarker1413"/> pin control subsystem:</p>
			<p class="source-code">&amp;gpio5 {</p>
			<p class="source-code">    gpio-ranges = &lt;&amp;pinctrl 29 89 1&gt; ;</p>
			<p class="source-code">}</p>
			<p>In the previous excerpt, 1 GPIO line from the 29th GPIO line of GPIO bank5 will be mapped to pin ranges from 89 on pin controller <strong class="source-inline">pinctrl</strong>.</p>
			<p>To illustrate this on a real platform, let's consider the i.MX6 SoC, which has 32 GPIOs per bank. The following is an excerpt from the pin controller node of i.MX6 SoCs, declared in <strong class="source-inline">arch/arm/boot/dts/imx6qdl.dtsi</strong>, and whose driver is <strong class="source-inline">drivers/pinctrl/freescale/pinctrl-imx6dl.c</strong>:</p>
			<p class="source-code">iomuxc: pinctrl@20e0000 {</p>
			<p class="source-code">    compatible = "fsl,imx6dl-iomuxc", "fsl,imx6q-iomuxc";</p>
			<p class="source-code">    reg = &lt;0x20e0000 0x4000&gt;;</p>
			<p class="source-code">};</p>
			<p>Now that the pin controller<a id="_idIndexMarker1414"/> has been declared, a GPIO controller (bank3) is declared in the same base device tree, <strong class="source-inline">arch/arm/boot/dts/imx6qdl.dtsi</strong>, as follows:</p>
			<p class="source-code">gpio3: gpio@20a4000 {</p>
			<p class="source-code">    compatible = "fsl,imx6q-gpio", "fsl,imx35-gpio";</p>
			<p class="source-code">    reg = &lt;0x020a4000 0x4000&gt;;</p>
			<p class="source-code">    interrupts = &lt;0 70 IRQ_TYPE_LEVEL_HIGH&gt;,</p>
			<p class="source-code">                 &lt;0 71 IRQ_TYPE_LEVEL_HIGH&gt;;</p>
			<p class="source-code">    gpio-controller;</p>
			<p class="source-code">    #gpio-cells = &lt;2&gt;;</p>
			<p class="source-code">    interrupt-controller;</p>
			<p class="source-code">    #interrupt-cells = &lt;2&gt;;</p>
			<p class="source-code">};</p>
			<p>For information, the driver of this GPIO controller is <strong class="source-inline">drivers/gpio/gpio-mxc.c</strong>. After the GPIO controller node has been declared in the base device tree, this same GPIO controller node is overridden in a SoC-specific base device tree, <strong class="source-inline">arch/arm/boot/dts/imx6q.dtsi</strong>, as follows:</p>
			<p class="source-code">&amp;gpio3 {</p>
			<p class="source-code">     gpio-ranges = &lt;&amp;iomuxc 0 69 16&gt;, &lt;&amp;iomuxc 16 36 8&gt;,</p>
			<p class="source-code">                  &lt;&amp;iomuxc 24 45 8&gt;;</p>
			<p class="source-code">};</p>
			<p>The preceding override of the GPIO controller node<a id="_idIndexMarker1415"/> means the following:</p>
			<ul>
				<li><strong class="source-inline">&lt;&amp;iomuxc 0 69 16&gt;</strong> means that 16 pins, from pin 69 (to 84) on pin controller <strong class="source-inline">iomuxc</strong>, are mapped to GPIO lines starting from index 0 (to 15). </li>
				<li><strong class="source-inline">&lt;&amp;iomuxc 16 36 8&gt;</strong> means that 8 pins, from pin 36 (to 43) on pin controller <strong class="source-inline">iomuxc</strong>, are mapped to GPIO lines starting from index 16 (to 23).</li>
				<li><strong class="source-inline">&lt;&amp;iomuxc 24 45 8&gt;</strong> means that 8 pins, from pin 45 (to 52) on pin controller <strong class="source-inline">iomuxc</strong>, are mapped to GPIO lines starting from index 24 (to 31).</li>
			</ul>
			<p>As expected, we have a 32-line GPIO bank, <strong class="source-inline">16 + 8 + 8</strong>.</p>
			<p>As of now, we are able to both understand existing and instantiate new GPIO controllers from the device tree that interact with one or more pin controllers. As the last step in this GPIO controller binding learning curve, let's learn how to hog GPIOs in order to avoid writing a particular driver (or prevent existing ones) to control them. </p>
			<h3>Pin hogging</h3>
			<p>The GPIO chip can <a id="_idIndexMarker1416"/>contain GPIO hog definitions. GPIO hogging is a mechanism providing automatic GPIO requests and configuration as part of the GPIO controller's driver probe function. This means that as soon as the pin control device is registered, the GPIO core will attempt to call <strong class="source-inline">devm_pinctrl_get()</strong>, <strong class="source-inline">lookup_state()</strong>, and <strong class="source-inline">select_state()</strong> on it.</p>
			<p>The following are properties required for each GPIO hog definition, which is represented as a child node of the GPIO controller:</p>
			<ul>
				<li><strong class="source-inline">gpio-hog</strong>: A property that indicates whether or not this child node represents a GPIO hog.</li>
				<li><strong class="source-inline">gpios</strong>: Contains the GPIO information (ID, flags, ...) for each GPIO to affect. Will contain an integer multiple of the number of cells specified in its parent node (GPIO controller node).</li>
				<li>Only one of the following properties can be specified, scanned in the order they are listed. This means that when multiple properties are present, they will be searched in the order they are presented here, with the first match being considered as the intended configuration:<ul><li><strong class="source-inline">input</strong>: A property that specifies that the GPIO direction should be set to input.</li><li><strong class="source-inline">output-low</strong>: A property that specifies that the GPIO should be configured as output, with an initial low state value.</li><li><strong class="source-inline">output-high</strong>: A property that specifies that the GPIO direction should be set to output with an initial high value.</li></ul></li>
			</ul>
			<p>An optional property is <strong class="source-inline">line-name</strong>: the GPIO label name. If it's not present, the node name is used.</p>
			<p>The following is an excerpt, where we <a id="_idIndexMarker1417"/>first declare (as GPIO) the pins we are interested in in the pin controller node:</p>
			<p class="source-code">&amp;iomuxc {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    pinctrl_gpio3_hog: gpio3hoggrp {</p>
			<p class="source-code">        fsl,pins = &lt;</p>
			<p class="source-code">            MX6QDL_PAD_EIM_D19__GPIO3_IO19      0x1b0b0</p>
			<p class="source-code">            MX6QDL_PAD_EIM_D20__GPIO3_IO20      0x1b0b0</p>
			<p class="source-code">            MX6QDL_PAD_EIM_D22__GPIO3_IO22      0x1b0b0</p>
			<p class="source-code">            MX6QDL_PAD_EIM_D23__GPIO3_IO23      0x1b0b0</p>
			<p class="source-code">        &gt;;</p>
			<p class="source-code">    };</p>
			<p class="source-code">[...]</p>
			<p class="source-code">}</p>
			<p>After the pins of interest are declared, we can hog each GPIO under the node of the GPIO controller this GPIO belongs to, as follows:</p>
			<p class="source-code">&amp;gpio3 {</p>
			<p class="source-code">    pinctrl-names = "default";</p>
			<p class="source-code">    pinctrl-0 = &lt;&amp;pinctrl_gpio3_hog&gt;;</p>
			<p class="source-code">    usb-emulation-hog {</p>
			<p class="source-code">        gpio-hog;</p>
			<p class="source-code">        gpios = &lt;19 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">        output-low;</p>
			<p class="source-code">        line-name = "usb-emulation";</p>
			<p class="source-code">    };</p>
			<p class="source-code">    usb-mode1-hog {</p>
			<p class="source-code">        gpio-hog;</p>
			<p class="source-code">        gpios = &lt;20 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">        output-high;</p>
			<p class="source-code">        line-name = "usb-mode1";</p>
			<p class="source-code">    };</p>
			<p class="source-code">    usb-pwr-hog {</p>
			<p class="source-code">        gpio-hog;</p>
			<p class="source-code">        gpios = &lt;22 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">        output-high;</p>
			<p class="source-code">       line-name = "usb-pwr-ctrl-en-n";</p>
			<p class="source-code">    };</p>
			<p class="source-code">    usb-mode2-hog {</p>
			<p class="source-code">        gpio-hog;</p>
			<p class="source-code">        gpios = &lt;23 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">        output-high;</p>
			<p class="source-code">        line-name = "usb-mode2";</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>It must be noted that<a id="_idIndexMarker1418"/> hogging pins should be used for those pins that are not controlled by any particular driver.</p>
			<p>GPIO hogging was the last part on the GPIO controller side. Now that controllers have no more secrets for us, let's switch to the consumer interface.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor248"/>Getting the most out of the GPIO consumer interface</h1>
			<p>The GPIO is a feature, or a <a id="_idIndexMarker1419"/>mode in which a pin can operate, in terms of hardware. It is nothing more than a digital line that may be used as an input or output and has just two values (or states): 1 for high or 0 for low. The kernel's GPIO subsystem includes all of the functions you'll need to set up and manage GPIO lines from within your driver.</p>
			<p>Before using a GPIO from within the driver, it must first be claimed by the kernel. It's a means to take control of a GPIO and prohibit other drivers from using it, as well as preventing the controller driver from being unloaded.</p>
			<p>After claiming control of the GPIO, you can do the following:</p>
			<ul>
				<li>Set the direction and, if needed, set the GPIO configuration.</li>
				<li>If it's being used as an output, start toggling its output state (driving the line high or low).</li>
				<li>If used as input, set the debounce-interval if needed and read the state. For a GPIO line mapped to an IRQ, configure at what edge/level the interrupt should be triggered, and register a handler that will be run when the interrupt occurs.</li>
			</ul>
			<p>In the Linux kernel, there are two different ways to deal with GPIOs:</p>
			<ul>
				<li>The legacy and deprecated integer-based interface, which uses integers to represent GPIOs.</li>
				<li>The new descriptor-based interface, where a GPIO is represented and described by an opaque structure, with a dedicated API. This is the recommended way to go.</li>
			</ul>
			<p>While we will discuss the two approaches in this chapter, let's start with the legacy interface.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor249"/>Integer-based GPIO interface – now deprecated</h2>
			<p>The integer-based interface <a id="_idIndexMarker1420"/>is the most known usage of GPIOs in Linux systems, either in the kernel or in the user space. In this mode, the GPIO is identified by an integer, which is used for every operation that needs to be performed on this GPIO. The following is the header that contains the legacy GPIO access function:</p>
			<p class="source-code">#include &lt;linux/gpio.h&gt;</p>
			<p>The integer-based interface relies on a set of functions, defined as follows:</p>
			<p class="source-code">bool gpio_is_valid(int number);</p>
			<p class="source-code">int  gpio_request(unsigned gpio, const char *label);</p>
			<p class="source-code">int  gpio_get_value_cansleep(unsigned gpio);</p>
			<p class="source-code">int  gpio_direction_input(unsigned gpio);</p>
			<p class="source-code">int  gpio_direction_output(unsigned gpio, int value);</p>
			<p class="source-code">void gpio_set_value(unsigned int gpio, int value);</p>
			<p class="source-code">int  gpio_get_value(unsigned gpio);</p>
			<p class="source-code">void gpio_set_value_cansleep(unsigned gpio, int value);</p>
			<p class="source-code">int gpio_get_value_cansleep(unsigned gpio);</p>
			<p class="source-code">void gpio_free(unsigned int gpio);</p>
			<p>All the preceding functions are mapped to a set of callbacks provided by the GPIO controller through its <strong class="source-inline">struct gpio_chip</strong> structure, thanks to which it exposes a generic set of callback functions.</p>
			<p>In all these functions, <strong class="source-inline">gpio</strong> represents the GPIO number we are interested in. Before using a GPIO, client drivers must call <strong class="source-inline">gpio_request()</strong> in order to take ownership of the line and, very importantly, to prevent this GPIO controller driver from being unloaded. In the same function, <strong class="source-inline">label</strong> is the label used by the kernel for labeling/describing the GPIO in sysfs as we can see in <strong class="source-inline">/sys/kernel/debug/gpio</strong>. <strong class="source-inline">gpio_request</strong><strong class="source-inline">()</strong> returns <strong class="source-inline">0</strong> on success, and a negative error code on error. If in doubt, before requesting the GPIO, you can use the <strong class="source-inline">gpio_is_valid()</strong> function to check whether the specified GPIO number is valid on the system prior to it being requested.</p>
			<p>Once a driver owes the GPIO, it can change its direction, depending on the need, whether it should be an input or output, using the <strong class="source-inline">gpio_direction_input()</strong> or <strong class="source-inline">gpio_direction_output()</strong> functions. In these functions, <strong class="source-inline">gpio</strong> is the GPIO number the driver needs to set the direction, which should have already been requested. There is a second parameter when it comes to configuring the GPIO as output, <strong class="source-inline">value</strong>, which is the initial state the GPIO should be in once the output direction is effective. Here again, in both functions, the return value is <strong class="source-inline">0</strong> on success or a negative error code on failure. Internally, these functions are mapped to lower-level callback functions exported by the driver of the GPIO chip that provides the GPIO line <strong class="source-inline">gpio</strong>.</p>
			<p>Some GPIO controllers <a id="_idIndexMarker1421"/>allow you to adjust the GPIO debounce-interval (this is only useful when the GPIO line is configured as input). This parameter can be set using <strong class="source-inline">gpio_set_debounce()</strong>. In this function, the <strong class="source-inline">debounce</strong> argument is the debounce time in milliseconds.</p>
			<p>As it is a good practice to grab and configure resources in the driver's probing method, GPIO lines must respect this rule.</p>
			<p>It has to be noticed that GPIO management (either configuration or getting/setting values) is not context agnostic; that is, there are memory-mapped GPIO controllers that can be accessed from any context (process and atomic contexts). On the other hand, there are GPIOs provided by discrete chips sitting on slow buses (such as I2C or SPI) that can sleep (because sending/receiving commands on such buses requires waiting to get to the head of a queue to transmit a command and get its response). Such GPIOs must be manipulated from a process context exclusively. A well-designed controller driver must be able to inform clients whether calls to its GPIO driving methods may sleep or not. This can be checked with the <strong class="source-inline">gpio_cansleep()</strong> function. This function returns <strong class="source-inline">true</strong> for GPIO lines whose controller sits on a slow bus, and <strong class="source-inline">false</strong> for GPIOs that belong to a memory-mapped controller.</p>
			<p>Now that the GPIOs are requested and configured, we can set/get their values using the appropriate APIs. Here again, the APIs to use are context-dependent. For memory-mapped GPIO controllers, their GPIO lines can be accessed using <strong class="source-inline">gpio_get_value()</strong> or <strong class="source-inline">gpio_set_value()</strong>. The first function returns a value that represents the GPIO state, and the second one will set the value of the GPIO, which should have been configured as an output using <strong class="source-inline">gpio_direction_output()</strong>. <strong class="source-inline">value</strong> can be considered as Boolean for both functions, with zero indicating a low level and a non-zero value indicating a high level.</p>
			<p>In case of doubt about the kind of GPIO controller from where the GPIO originates, the driver should use the context agnostic APIs, <strong class="source-inline">gpio_get_value_cansleep()</strong> and <strong class="source-inline">gpio_set_value_cansleep()</strong>. These APIs are safe to use in threaded contexts but also work in an<a id="_idIndexMarker1422"/> atomic context.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The legacy (that is, integer-based) interface supports specifying GPIOs from the device tree, in which case the APIs to be used to grab those GPIOs will be <strong class="source-inline">of_get_gpio()</strong>, <strong class="source-inline">of_get_named_gpio()</strong>, or similar APIs. These are mentioned here for studying purposes and won't be discussed in this chapter.</p>
			<h3>GPIO mapped to IRQ</h3>
			<p>There are GPIO controllers that allow their GPIO lines to be mapped to IRQs. These IRQs can be either edge- or level-triggered. The configuration depends on the needs. The GPIO controller is responsible for providing the mapping between the GPIO and its IRQ.</p>
			<p>If the IRQ has been <a id="_idIndexMarker1423"/>specified in the device tree and the underlying device is an I2C or SPI device, the consumer driver must just request the IRQ normally, since upon the device tree parsing, the GPIO mapped to IRQ specified in the device tree will be translated by the device tree core and assigned to your device structure, that is, <strong class="source-inline">i2c_client.irq</strong> or <strong class="source-inline">spi_device.irq</strong>. This is the case in <strong class="source-inline">foo_device</strong> from the example we have seen in the <em class="italic">GPIO controller bindings</em> section. For another device type, you'll have to call <strong class="source-inline">irq_of_parse_and_map()</strong> or a similar API.</p>
			<p>If, however, the driver is given a GPIO (from module parameters, for example) or specified from the device tree without being mapped to IRQ there, the driver must use <strong class="source-inline">gpio_to_irq()</strong> to map the given GPIO number to its IRQ number:</p>
			<p class="source-code">int gpio_to_irq(unsigned gpio)</p>
			<p>This function returns the corresponding Linux IRQ number, which can be passed to <strong class="source-inline">request_irq()</strong> (or the threaded counterpart, <strong class="source-inline">request_threaded_irq()</strong>) to register a handler for this IRQ:</p>
			<p class="source-code">int request_threaded_irq (unsigned int irq,</p>
			<p class="source-code">                   irq_handler_t handler,</p>
			<p class="source-code">                   irq_handler_t thread_fn,</p>
			<p class="source-code">                   unsigned long irqflags,</p>
			<p class="source-code">                   const char *devname,</p>
			<p class="source-code">                   void *dev_id); </p>
			<p class="source-code">int request_any_context_irq (unsigned int irq,</p>
			<p class="source-code">                       irq_handler_t handler,</p>
			<p class="source-code">                       unsigned long flags,</p>
			<p class="source-code">                       const char * name,</p>
			<p class="source-code">                       void * dev_id);</p>
			<p><strong class="source-inline">request_any_context_irq()</strong> is smart enough to identify the underlying context supported by the IRQ chip integrated into the GPIO controller. If this controller's accessors can sleep, <strong class="source-inline">request_any_context_irq()</strong> will request a threaded IRQ, otherwise, it will request an<a id="_idIndexMarker1424"/> atomic-context IRQ.</p>
			<p>The following is a short example demonstrating what we have discussed so far:</p>
			<p class="source-code">static irqreturn_t my_interrupt_handler(int irq,</p>
			<p class="source-code">                                        void *dev_id)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return IRQ_HANDLED;</p>
			<p class="source-code">}</p>
			<p class="source-code">static int foo_probe(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    struct device_node *np = client-&gt;dev.of_node;</p>
			<p class="source-code">    int gpio_int = of_get_gpio(np, 0);</p>
			<p class="source-code">    int irq_num = gpio_to_irq(gpio_int);</p>
			<p class="source-code">    int error =</p>
			<p class="source-code">        devm_request_threaded_irq(&amp;client-&gt;dev, irq_num,</p>
			<p class="source-code">               NULL, my_interrupt_handler,</p>
			<p class="source-code">               IRQF_TRIGGER_RISING | IRQF_ONESHOT,</p>
			<p class="source-code">               input_dev-&gt;name, my_data_struct);</p>
			<p class="source-code">    if (error) {</p>
			<p class="source-code">        dev_err(&amp;client-&gt;dev, "irq %d requested failed,</p>
			<p class="source-code">                 %d\n", client-&gt;irq, error);</p>
			<p class="source-code">        return error;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the previous excerpt, we have demonstrated how to use a legacy integer-based interface to grab a GPIO specified in the device tree, as well as the old API to translate this GPIO into a valid Linux<a id="_idIndexMarker1425"/> IRQ number. These were the main points to highlight.</p>
			<p>Though deprecated, we briefly introduced the legacy GPIO APIs. As is recommended, in the next section, we will deal with the new descriptor-based GPIO interface.</p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor250"/>Descriptor-based GPIO interface: the new and recommended way</h2>
			<p>With the new<a id="_idIndexMarker1426"/> descriptor-based GPIO interface, the subsystem has been oriented to the producer/consumer. The header required for the descriptor-based GPIO interface is the following:</p>
			<p class="source-code">#include &lt;linux/gpio/consumer.h&gt;</p>
			<p>With the descriptor-based interface, a GPIO is described and characterized by a coherent data structure, <strong class="source-inline">struct gpio_desc</strong>, which is defined as follows:</p>
			<p class="source-code">struct gpio_desc {</p>
			<p class="source-code">     struct gpio_chip *chip;</p>
			<p class="source-code">     unsigned long    flags;</p>
			<p class="source-code">     const char       *label;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">chip</strong> is the controller providing this GPIO line; <strong class="source-inline">flags</strong> are the flags characterizing the GPIO and <strong class="source-inline">label</strong> is the name describing the GPIO.</p>
			<p>Prior to requesting and acquiring ownership of GPIOs with the descriptor-based interface, these GPIOs must have been specified or mapped somewhere. It means they should be allocated to a driver, whereas with the legacy integer-based interface, a driver could just obtain a number from anywhere and request it as GPIO. Since descriptor-based GPIOs are represented by an opaque structure, such a method is not possible anymore.</p>
			<p>With the new<a id="_idIndexMarker1427"/> interface, GPIOs must exclusively be mapped to names or indexes, specifying at the same time the GPIO chips providing the GPIOs of interest. This gives us three ways to specify and assign GPIOs to drivers:</p>
			<ul>
				<li><strong class="bold">Platform data mapping</strong>: In<a id="_idIndexMarker1428"/> such cases, for example, the mapping is done in the board file.</li>
				<li><strong class="bold">Device tree</strong>: The <a id="_idIndexMarker1429"/>mapping is done in the device tree. This is the mapping we will discuss in this book.</li>
				<li><strong class="bold">Advanced Configuration and Power Interface mapping (ACPI)</strong>: This is ACPI-style mapping. On <a id="_idIndexMarker1430"/>x86-based systems, this is the most common configuration.</li>
			</ul>
			<p>Now that we are done with the GPIO descriptor interface introduction, let's learn how it is mapped and assigned to devices.</p>
			<h3>GPIO descriptor mapping in the device tree and its APIs</h3>
			<p>GPIO descriptor<a id="_idIndexMarker1431"/> mappings are defined in the device tree node of the consumer device. The GPIO descriptor mapping property must be named <strong class="source-inline">&lt;name&gt;-gpios</strong> or <strong class="source-inline">&lt;name&gt;-gpio</strong>, where <strong class="source-inline">&lt;name&gt;</strong> is meaningful enough to describe the function for which the GPIO(s) will be used. This is mandatory.</p>
			<p>The reason is that descriptor-based GPIO lookup relies on the <strong class="source-inline">gpio_suffixes[]</strong> variable, a <strong class="source-inline">gpiolib</strong> variable defined in <strong class="source-inline">drivers/gpio/gpiolib.h</strong> as follows:</p>
			<p class="source-code">static const char * const gpio_suffixes[] =</p>
			<p class="source-code">                          { "gpios", "gpio" };</p>
			<p>This variable is <a id="_idIndexMarker1432"/>used in both device tree lookup and ACPI-based lookup. To see how it works, let's see how it is used in <strong class="source-inline">of_find_gpio()</strong>, the device tree's low-level GPIO lookup function defined as follows:</p>
			<p class="source-code">static struct gpio_desc *of_find_gpio(</p>
			<p class="source-code">                           struct device *dev,</p>
			<p class="source-code">                           const char *con_id,</p>
			<p class="source-code">                           unsigned int idx,</p>
			<p class="source-code">                           enum gpio_lookup_flags *flags)</p>
			<p class="source-code">{</p>
			<p class="source-code">    /* 32 is max size of property name */</p>
			<p class="source-code">    char prop_name[32];</p>
			<p class="source-code">    enum of_gpio_flags of_flags;</p>
			<p class="source-code">    struct gpio_desc *desc;</p>
			<p class="source-code">    unsigned int i;</p>
			<p class="source-code">    /* Try GPIO property "foo-gpios" and "foo-gpio" */</p>
			<p class="source-code">    for (i = 0; i &lt; ARRAY_SIZE(gpio_suffixes); i++) {</p>
			<p class="source-code">        if (con_id)</p>
			<p class="source-code">            snprintf(prop_name, sizeof(prop_name),</p>
			<p class="source-code">                      "%s-%s", con_id,</p>
			<p class="source-code">                      gpio_suffixes[i]);</p>
			<p class="source-code">        else</p>
			<p class="source-code">            snprintf(prop_name, sizeof(prop_name), "%s",</p>
			<p class="source-code">                       gpio_suffixes[i]);</p>
			<p class="source-code">        desc = of_get_named_gpiod_flags(dev-&gt;of_node,</p>
			<p class="source-code">                                      prop_name, idx,</p>
			<p class="source-code">                                      &amp;of_flags);</p>
			<p class="source-code">        if (!IS_ERR(desc) || PTR_ERR(desc) != -ENOENT)</p>
			<p class="source-code">            break;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">}</p>
			<p>Now let's consider the <a id="_idIndexMarker1433"/>following node, which is an excerpt of <strong class="source-inline">Documentation/gpio/board.txt</strong>:</p>
			<p class="source-code">foo_device {</p>
			<p class="source-code">    compatible = "acme,foo";</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    led-gpios = &lt;&amp;gpio 15 GPIO_ACTIVE_HIGH&gt;, /* red */</p>
			<p class="source-code">                &lt;&amp;gpio 16 GPIO_ACTIVE_HIGH&gt;, /* green */</p>
			<p class="source-code">                &lt;&amp;gpio 17 GPIO_ACTIVE_HIGH&gt;; /* blue */</p>
			<p class="source-code">    power-gpio = &lt;&amp;gpio 1 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">    reset-gpio = &lt;&amp;gpio 1 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">};</p>
			<p>This is what a mapping should look like, with meaningful names, corresponding to the functions assigned to the GPIOs. This excerpt will be used as the basis for the rest of this section to demonstrate the use of the descriptor-based GPIO interface.</p>
			<p>Now that the GPIOs have<a id="_idIndexMarker1434"/> been specified in the device tree, the first thing to be done is to allocate GPIO descriptors and take the ownership of these GPIOs. This can be done using <strong class="source-inline">gpiod_get()</strong>, <strong class="source-inline">gpiod_getindex()</strong>, or <strong class="source-inline">gpiod_get_optional()</strong>, defined as follows:</p>
			<p class="source-code">struct gpio_desc *gpiod_get_index(struct device *dev,</p>
			<p class="source-code">                                 const char *con_id,</p>
			<p class="source-code">                                 unsigned int idx,</p>
			<p class="source-code">                                 enum gpiod_flags flags)</p>
			<p class="source-code">struct gpio_desc *gpiod_get(struct device *dev,</p>
			<p class="source-code">                            const char *con_id,</p>
			<p class="source-code">                            enum gpiod_flags flags)</p>
			<p class="source-code">struct gpio_desc *gpiod_get_optional(struct device *dev,</p>
			<p class="source-code">                                     const char *con_id,</p>
			<p class="source-code">                                     enum gpiod_flags flags);</p>
			<p>It must be noted that we can also use the device-managed variant of these APIs, defined as follows:</p>
			<p class="source-code">struct gpio_desc *devm_gpiod_get_index(</p>
			<p class="source-code">                                struct device *dev,</p>
			<p class="source-code">                                const char *con_id,</p>
			<p class="source-code">                                unsigned int idx,</p>
			<p class="source-code">                                enum gpiod_flags flags);</p>
			<p class="source-code">struct gpio_desc *devm_gpiod_get(struct device *dev,</p>
			<p class="source-code">                               const char *con_id,</p>
			<p class="source-code">                               enum gpiod_flags flags);</p>
			<p class="source-code">struct gpio_desc *devm_gpiod_get_optional(</p>
			<p class="source-code">                                struct device *dev,</p>
			<p class="source-code">                                const char *con_id,</p>
			<p class="source-code">                                enum gpiod_flags flags);</p>
			<p>Both non <strong class="source-inline">_optional</strong> functions will return <strong class="source-inline">-ENOENT</strong> if no GPIO with the given function is assigned or a negative error if another error occurred. On success, the GPIO descriptor corresponding to the GPIO is returned. The first method returns the GPIO descriptor structure for the GPIO at a particular index (useful when the specifier is a list of GPIOs), whereas the second function<a id="_idIndexMarker1435"/> always returns the GPIO at index <strong class="source-inline">0</strong> (single GPIO mapping). The <strong class="source-inline">_optional</strong> variant is useful for drivers that need to deal with optional GPIOs; it's the same as <strong class="source-inline">gpiod_get()</strong>, except that it returns <strong class="source-inline">NULL</strong> when no GPIO has been assigned to the device (that is, specified in the device tree).</p>
			<p>In parameters, <strong class="source-inline">dev</strong> is the device to which the GPIO descriptor will belong. It is the underlying <strong class="source-inline">device</strong> structure the driver is responsible for; for example, <strong class="source-inline">i2c_client.dev</strong>, <strong class="source-inline">spi_device.dev</strong>, or <strong class="source-inline">platform_device.dev</strong>. <strong class="source-inline">con_id</strong> is the function of the GPIO within the consumer interface. It corresponds to the <strong class="source-inline">&lt;name&gt;</strong> prefix of the GPIO specifier property name in the device tree. <strong class="source-inline">idx</strong> is the index (starting from <strong class="source-inline">0</strong>) of the GPIO in case the specifier contains a list of GPIOs. <strong class="source-inline">flags</strong> is an optional parameter that determines the GPIO initialization flags, to configure the direction and/or the initial output value. It is an instance of <strong class="source-inline">enum gpiod_flags</strong>, defined in <strong class="source-inline">include/linux/gpio/consumer.h</strong> as follows:</p>
			<p class="source-code">enum gpiod_flags {</p>
			<p class="source-code">    GPIOD_ASIS  = 0,</p>
			<p class="source-code">    GPIOD_IN = GPIOD_FLAGS_BIT_DIR_SET,</p>
			<p class="source-code">    GPIOD_OUT_LOW = GPIOD_FLAGS_BIT_DIR_SET |</p>
			<p class="source-code">                    GPIOD_FLAGS_BIT_DIR_OUT,</p>
			<p class="source-code">    GPIOD_OUT_HIGH = GPIOD_FLAGS_BIT_DIR_SET |</p>
			<p class="source-code">                     GPIOD_FLAGS_BIT_DIR_OUT |</p>
			<p class="source-code">                     GPIOD_FLAGS_BIT_DIR_VAL,</p>
			<p class="source-code">};</p>
			<p>Let's demonstrate in the following how these APIs can be used in drivers:</p>
			<p class="source-code">struct gpio_desc *red, *green, *blue, *power;</p>
			<p class="source-code">red = gpiod_get_index(dev, "led", 0, GPIOD_OUT_HIGH);</p>
			<p class="source-code">green = gpiod_get_index(dev, "led", 1, GPIOD_OUT_HIGH);</p>
			<p class="source-code">blue = gpiod_get_index(dev, "led", 2, GPIOD_OUT_HIGH);</p>
			<p class="source-code">power = gpiod_get(dev, "power", GPIOD_OUT_HIGH);</p>
			<p>For the sake of readability, the<a id="_idIndexMarker1436"/> preceding code does not perform error checking. The LED GPIOs will be active-high, but the power GPIO will be active-low (that is, <strong class="source-inline">gpiod_is_active_low(power)</strong> returns <strong class="source-inline">true</strong> in this case).</p>
			<p>Since the <strong class="source-inline">flags</strong> argument is optional, there might be situations where either the initial flags are not specified or when the initial function of the GPIO needs to be changed. To address this, drivers can use <strong class="source-inline">gpiod_direction_input()</strong> or <strong class="source-inline">gpiod_direction_output()</strong> to change the GPIO direction. These APIs are defined as follows:</p>
			<p class="source-code">int gpiod_direction_input(struct gpio_desc *desc);</p>
			<p class="source-code">int gpiod_direction_output(struct gpio_desc *desc,</p>
			<p class="source-code">                           int value);</p>
			<p>In the preceding APIs, <strong class="source-inline">desc</strong> is the GPIO descriptor of the GPIO of interest, and <strong class="source-inline">value</strong> is the initial value to apply to this GPIO when it is configured as output.</p>
			<p>It must be noted that the same attention must be paid as with the integer-based interface. In other words, the driver must take care of whether the underlying GPIO chip is memory-mapped (and thus can be accessed in any context) or sits on a slow bus (which would require accessing the chip in process or threaded context exclusively). This can be achieved using the <strong class="source-inline">gpiod_cansleep()</strong> function, defined as follows:</p>
			<p class="source-code">int gpiod_cansleep(const struct gpio_desc *desc);</p>
			<p>This function returns <strong class="source-inline">true</strong> if the underlying hardware can put the caller to sleep while it is accessed. In such cases, drivers should use dedicated APIs.</p>
			<p>The following are APIs<a id="_idIndexMarker1437"/> to get or set the GPIO value on a controller that sits on a slow bus, that is, a GPIO descriptor for which <strong class="source-inline">gpiod_cansleep()</strong> returned <strong class="source-inline">true</strong>:</p>
			<p class="source-code">int gpiod_get_value_cansleep(const struct gpio_desc *desc);</p>
			<p class="source-code">void gpiod_set_value_cansleep(struct gpio_desc *desc,</p>
			<p class="source-code">                              int value);</p>
			<p>If the underlying chip is memory mapped, the following APIs can be used instead:</p>
			<p class="source-code">int gpiod_get_value(const struct gpio_desc *desc);</p>
			<p class="source-code">void gpiod_set_value(struct gpio_desc *desc, int value);</p>
			<p>The context must be considered only if the driver is intended to access the GPIO(s) from within an interrupt handler or from within any other atomic context. Otherwise, you can just use the normal APIs, that is, the ones without the <strong class="source-inline">_cansleep</strong> suffix.</p>
			<p><strong class="source-inline">gpiod_to_irq()</strong> can be used to get the IRQ number that corresponds to a GPIO descriptor mapped to IRQ:</p>
			<p class="source-code">int gpiod_to_irq(const struct gpio_desc *desc);</p>
			<p>The resulting IRQ number can be used with the <strong class="source-inline">request_irq()</strong> function (or the threaded variant <strong class="source-inline">request_threaded_irq()</strong>). If the driver does not need to bother with the context supported by the underlying hardware chip, <strong class="source-inline">request_any_context_irq()</strong> can be used instead. That said, the driver can use the device managed variant of these functions, that is, <strong class="source-inline">devm_request_irq()</strong>, <strong class="source-inline">devm_request_threaded_irq()</strong>, or <strong class="source-inline">devm_request_any_context_irq()</strong>.</p>
			<p>If for any reason the module needs to switch back and forth between the descriptor-based interface and the legacy integer-based interface, the APIs <strong class="source-inline">desc_to_gpio()</strong> and <strong class="source-inline">gpio_to_desc()</strong> can be used for translations. They are defined as follows:</p>
			<p class="source-code">/* Convert between the old gpio_ and new gpiod_ interfaces */</p>
			<p class="source-code">struct gpio_desc *gpio_to_desc(unsigned gpio);</p>
			<p class="source-code">int desc_to_gpio(const struct gpio_desc *desc);</p>
			<p>In the preceding, <strong class="source-inline">gpio_to_desc()</strong> takes a legacy GPIO number in the parameter and returns the associated GPIO descriptor, while <strong class="source-inline">desc_to_gpio()</strong> does the opposite.</p>
			<p>The advantage of using the device-managed APIs is that drivers need not care about releasing the GPIO at all, since it will be handled by the GPIO core. If, however, non-managed APIs were used to request a GPIO descriptor, this descriptor must explicitly be released with <strong class="source-inline">gpiod_put()</strong>, defined as follows:</p>
			<p class="source-code">void gpiod_put(struct gpio_desc *desc);</p>
			<p>Now that we are done<a id="_idIndexMarker1438"/> with the consumer side's descriptor-based APIs, let's summarize what we have learned in a concrete example, from the mapping from the device tree to the consumer code based on consumer APIs.</p>
			<h3>Putting it all together</h3>
			<p>The following driver summarizes the concepts introduced in the descriptor-based interface. In this example, we need four GPIOs split as follows: two for LEDs (red and green, which are then configured as output) and two for buttons (thus configured as input). The logic to implement is that pushing button 1 toggles both LEDs only when button 2 is pushed as well.</p>
			<p>To achieve that, let's consider the following mapping in the device tree:</p>
			<p class="source-code">foo_device {</p>
			<p class="source-code">    compatible = "packt,gpio-descriptor-sample";</p>
			<p class="source-code">    led-gpios = &lt;&amp;gpio2 15 GPIO_ACTIVE_HIGH&gt;, // red </p>
			<p class="source-code">                &lt;&amp;gpio2 16 GPIO_ACTIVE_HIGH&gt;, // green </p>
			<p class="source-code">    btn1-gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">    btn2-gpios = &lt;&amp;gpio2 31 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">};</p>
			<p>Now that the GPIOs have been mapped in the device tree, let's write the platform driver that will leverage these GPIOs:</p>
			<p class="source-code">#include &lt;linux/init.h&gt;</p>
			<p class="source-code">#include &lt;linux/module.h&gt;</p>
			<p class="source-code">#include &lt;linux/kernel.h&gt;</p>
			<p class="source-code">#include &lt;linux/platform_device.h&gt; /* platform devices */</p>
			<p class="source-code">#include &lt;linux/gpio/consumer.h&gt;   /* GPIO Descriptor */</p>
			<p class="source-code">#include &lt;linux/interrupt.h&gt;       /* IRQ */</p>
			<p class="source-code">#include &lt;linux/of.h&gt;              /* Device Tree */</p>
			<p class="source-code">static struct gpio_desc *red, *green, *btn1, *btn2;</p>
			<p class="source-code">static unsigned int irq, led_state = 0;</p>
			<p class="source-code">static irq_handler_t btn1_irq_handler(unsigned int irq,</p>
			<p class="source-code">                                      void *dev_id)</p>
			<p class="source-code">{</p>
			<p class="source-code">    unsigned int btn2_state;</p>
			<p class="source-code">    btn2_state = gpiod_get_value(btn2);</p>
			<p class="source-code">    if (btn2_state) {</p>
			<p class="source-code">        led_state = 1 – led_state;</p>
			<p class="source-code">        gpiod_set_value(red, led_state);</p>
			<p class="source-code">        gpiod_set_value(green, led_state);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    pr_info("btn1 interrupt: Interrupt! btn2 state is %d)\n",</p>
			<p class="source-code">            led_state);</p>
			<p class="source-code">    return IRQ_HANDLED;</p>
			<p class="source-code">}</p>
			<p>In the preceding, we have started with the IRQ handler. The toggling logic is implemented by <strong class="source-inline">led_state = 1 – led_state</strong>.  Next, we implement the driver's <strong class="source-inline">probe</strong> method, as follows:</p>
			<p class="source-code">static int my_pdrv_probe (struct platform_device *pdev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int retval;</p>
			<p class="source-code">    struct device *dev = &amp;pdev-&gt;dev;</p>
			<p class="source-code">    red = devm_gpiod_get_index(dev, "led", 0,</p>
			<p class="source-code">                               GPIOD_OUT_LOW);</p>
			<p class="source-code">    green = devm_gpiod_get_index(dev, "led", 1,</p>
			<p class="source-code">                                 GPIOD_OUT_LOW);</p>
			<p class="source-code">    /* Configure GPIO Buttons as input */</p>
			<p class="source-code">    btn1 = devm_gpiod_get(dev, "led", 0, GPIOD_IN);</p>
			<p class="source-code">    btn2 = devm_gpiod_get(dev, "led", 1, GPIOD_IN);</p>
			<p class="source-code">    irq = gpiod_to_irq(btn1);</p>
			<p class="source-code">    retval = devm_request_threaded_irq(dev, irq, NULL,</p>
			<p class="source-code">                         btn1_pushed_irq_handler,</p>
			<p class="source-code">                         IRQF_TRIGGER_LOW | IRQF_ONESHOT,</p>
			<p class="source-code">                         "gpio-descriptor-sample", NULL);</p>
			<p class="source-code">    pr_info("Hello! device probed!\n");</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>The preceding probe method is quite simple. We first start requesting the GPIOs, then we translate the button 1 GPIO line into a valid IRQ number, and then we register a handler for this IRQ. You should pay attention to the fact that we have exclusively used device-managed APIs in that method.</p>
			<p>Finally, we set up a device ID table before filling and registering our platform device driver, as follows:</p>
			<p class="source-code">static const struct of_device_id gpiod_dt_ids[] = {</p>
			<p class="source-code">    { .compatible = "packt,gpio-descriptor-sample", },</p>
			<p class="source-code">    { /* sentinel */ }</p>
			<p class="source-code">};</p>
			<p class="source-code">static struct platform_driver mypdrv = {</p>
			<p class="source-code">    .probe      = my_pdrv_probe,</p>
			<p class="source-code">    .driver     = {</p>
			<p class="source-code">        .name     = "gpio_descriptor_sample",</p>
			<p class="source-code">        .of_match_table = of_match_ptr(gpiod_dt_ids),  </p>
			<p class="source-code">        .owner    = THIS_MODULE,</p>
			<p class="source-code">    },</p>
			<p class="source-code">};</p>
			<p class="source-code">module_platform_driver(mypdrv);</p>
			<p class="source-code">MODULE_AUTHOR("John Madieu &lt;john.madieu@labcsmart.com&gt;");</p>
			<p class="source-code">MODULE_LICENSE("GPL");</p>
			<p>We may wonder why neither GPIO descriptors nor interrupts were released. This is because we exclusively used device-managed APIs in the <strong class="source-inline">probe</strong> function. Thanks to these, we do not need to release anything explicitly, thus we can get rid of the <strong class="source-inline">remove</strong> method of the platform driver.</p>
			<p>If we use non-managed APIs, the <strong class="source-inline">remove</strong> method could look like the following:</p>
			<p class="source-code">static void my_pdrv_remove(struct platform_device *pdev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    free_irq(irq, NULL);</p>
			<p class="source-code">    gpiod_put(red);</p>
			<p class="source-code">    gpiod_put(green);</p>
			<p class="source-code">    gpiod_put(btn1);</p>
			<p class="source-code">    gpiod_put(btn2);</p>
			<p class="source-code">    pr_info("good bye reader!\n");</p>
			<p class="source-code">}</p>
			<p class="source-code">static struct platform_driver mypdrv = {</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    .remove     = my_pdrv_remove,</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">};</p>
			<p>In the preceding, we can notice the use of regular <strong class="source-inline">gpiod_put()</strong> and <strong class="source-inline">free_irq()</strong> APIs to release GPIO descriptors and the IRQ line.</p>
			<p>In this section, we have done with the kernel side of GPIO management, both on the controller and client sides. As we have learned all through this book, there are situations where we might want to avoid writing specific kernel code. Regarding GPIOs, the next section will teach us how not to write GPIO client drivers to control these GPIOs.</p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor251"/>Learning how not to write GPIO client drivers</h1>
			<p>There are situations where writing user space code would achieve the same goals as writing kernel drivers. Moreover, the GPIO framework is one of the most used frameworks in the user space. It then goes without saying that there are several possibilities to deal with it in the user space, some of which we will introduce in this chapter.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor252"/>Goodbye to the legacy GPIO sysfs interface</h2>
			<p>Sysfs has ruled<a id="_idIndexMarker1439"/> GPIO management from the user space for quite a long time now. Though it is scheduled for removal, the sysfs GPIO interface still has a few days ahead of it. <strong class="source-inline">CONFIG_GPIO_SYSFS</strong> can still enable it, but its use is discouraged, and it will be removed from mainline Linux. This interface allows managing and controlling GPIOs through a set of files. It is located at <strong class="source-inline">/sys/class/gpio/</strong>, and the following are the common directory paths and attributes that are involved:</p>
			<ul>
				<li><strong class="source-inline">/sys/class/gpio/</strong>: This is where it all starts. There are two special files in this directory, <strong class="source-inline">export</strong> and <strong class="source-inline">unexport</strong>, and as many directories as there are GPIO controllers registered with the system:<ul><li><strong class="source-inline">export</strong>: By writing the number of a GPIO to this file, we ask the kernel to export control of that GPIO to the user space. For example, typing <strong class="source-inline">echo 21 &gt; export</strong> will create a <strong class="source-inline">gpio21</strong> node (resulting in a subdirectory of the same name) for GPIO <strong class="source-inline">#21</strong>, if this GPIO is not already requested by the kernel code.</li><li><strong class="source-inline">unexport</strong>: The effect of exporting to the user space is reversed by writing the same GPIO number to this file. For example, the <strong class="source-inline">gpio21</strong> node exported using the <strong class="source-inline">export</strong> file will be removed by typing <strong class="source-inline">echo 21 &gt; unexport</strong>.</li></ul></li>
			</ul>
			<p>On successful <strong class="source-inline">gpio_chip</strong> registration, a directory entry with a path such as <strong class="source-inline">/sys/class/gpio/gpiochipX/</strong> will be created, where <strong class="source-inline">X</strong> is the GPIO controller base (the controller providing GPIOs starting at <strong class="source-inline">#X</strong>), having the following attributes:</p>
			<ul>
				<li><strong class="source-inline">base</strong>, whose value is the same as <strong class="source-inline">X</strong>, and which corresponds to <strong class="source-inline">gpio_chip.base</strong> (if assigned statically), and being the first GPIO managed by this chip.</li>
				<li><strong class="source-inline">label</strong>, which is provided for diagnostics (not always unique).</li>
				<li><strong class="source-inline">ngpio</strong>, which tells us how many GPIOs this controller provides (<strong class="source-inline">N</strong> to<strong class="source-inline"> N + ngpio - 1</strong>). This is the same as defined in <strong class="source-inline">gpio_chip.ngpios</strong>.</li>
			</ul>
			<ul>
				<li><strong class="source-inline">/sys/class/gpio/gpioN/</strong>: This directory corresponds to the GPIO line <strong class="source-inline">N</strong>, exported either using the <strong class="source-inline">export</strong> file or directly from the kernel. <strong class="source-inline">/sys/class/gpio/gpio42/</strong> (for GPIO <strong class="source-inline">#42</strong>) is an example. The following read/write attributes are contained in such directories:<ul><li><strong class="source-inline">direction</strong>: Use<a id="_idIndexMarker1440"/> this file to get/set GPIO direction. Acceptable values are either <strong class="source-inline">in</strong> or <strong class="source-inline">out</strong> strings. This attribute will normally be written and writing the <strong class="source-inline">out</strong> value will initialize the GPIO value as <strong class="source-inline">low</strong> by default. To ensure glitch-free operation, values low and high may be written to configure the GPIO as an output with that initial value. If, however, the GPIO has been exported from the kernel (see the <strong class="source-inline">gpiod_export()</strong> or <strong class="source-inline">gpio_export()</strong> functions), then this attribute will be missing, disabling at the same time direction change.</li><li><strong class="source-inline">value</strong>: This attribute can be used to get or set the state of the GPIO line based on its direction, input, or output. If the GPIO is configured as an output, any non-zero value written will set the output high, while writing <strong class="source-inline">0</strong> will set this output low. If the pin can be set up as an interrupt-generating line and is set to do so, then the <strong class="source-inline">poll()</strong> system function can be used on that file and will return when an interrupt occurs. Setting the events <strong class="source-inline">POLLPRI</strong> and <strong class="source-inline">POLLERR</strong> is required when using <strong class="source-inline">poll()</strong>. If, however, <strong class="source-inline">select()</strong> is used instead, the file descriptor should be set in <strong class="source-inline">exceptfds</strong>. After <strong class="source-inline">poll()</strong> returns, the user code should either <strong class="source-inline">lseek()</strong> to the beginning of the sysfs file and read the new value or close the file and re-open it to read the value. It is the same principle as we discussed for the pollable sysfs attribute.</li><li><strong class="source-inline">edge</strong> determines the signal edge that will let the <strong class="source-inline">poll()</strong> or <strong class="source-inline">select()</strong> functions return. <strong class="source-inline">none</strong>, <strong class="source-inline">rising</strong>, <strong class="source-inline">failing</strong>, or <strong class="source-inline">both</strong> are acceptable values. This readable and writable file exists only if the GPIO can be configured as an interrupt generating input pin.</li><li><strong class="source-inline">active_low</strong>: When it is read, this attribute either returns <strong class="source-inline">0</strong> (for <strong class="source-inline">false</strong>) or <strong class="source-inline">1</strong> (meaning <strong class="source-inline">true</strong>). Writing any nonzero value will invert the <strong class="source-inline">value</strong> attribute for both reading and writing. Existing and subsequent <strong class="source-inline">poll()</strong>/<strong class="source-inline">select()</strong> support configuration through the <strong class="source-inline">edge</strong> attribute for rising and falling edges will follow this setting.</li></ul></li>
			</ul>
			<p>The following is a short sequence of <a id="_idIndexMarker1441"/>commands demonstrating the use of the sysfs interface to drive GPIOs from the user space:</p>
			<p class="source-code"># echo 24 &gt; /sys/class/gpio/export</p>
			<p class="source-code"># echo out &gt; /sys/class/gpio/gpio24/direction</p>
			<p class="source-code"># echo 1 &gt; /sys/class/gpio/gpio24/value</p>
			<p class="source-code"># echo 0 &gt; /sys/class/gpio/gpio24/value</p>
			<p class="source-code"># echo high &gt; /sys/class/gpio/gpio24/direction # shorthand for out/1</p>
			<p class="source-code"># echo low &gt; /sys/class/gpio/gpio24/direction # shorthand for out/0</p>
			<p>Let's not spend more time on this legacy interface. Without delay, let's switch to what kernel developers have provided as a new GPIO management interface from the user space, the <strong class="source-inline">Libgpiod</strong> library.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor253"/>Welcome to the Libgpiod GPIO library</h2>
			<p>The Kernel Linux GPIO user<a id="_idIndexMarker1442"/> space sysfs is deprecated and has been discontinued. That said, it was suffering from many ailments, some of which are as follows:</p>
			<ul>
				<li>State not tied to processes.</li>
				<li>A lack of concurrent access management to sysfs attributes.</li>
				<li>A lack of support for bulk GPIO operations, that is, performing operations on a set of GPIOs with a single command (in a single shot).</li>
				<li>A lot of operations were needed just to set a GPIO value (opening and writing into the export file, opening and writing into the direction file, opening and writing into the value file).</li>
				<li>Unreliable polling – user code had to poll on <strong class="source-inline">/sys/class/gpio/gpioX/</strong>value, and on each event, it was necessary to <strong class="source-inline">close/re-open</strong> or <strong class="source-inline">lseek</strong> in the file before re-reading the new value. This could lead to events being lost.</li>
				<li>It was not possible to set GPIO electrical properties.</li>
				<li>If the process crashed, the GPIOs remained exported; there was no context concept.</li>
			</ul>
			<p>To address the limits of the sysfs <a id="_idIndexMarker1443"/>interface, a new GPIO interface has been developed, the descriptor-based GPIO interface. It comes with GPIO character devices – a new user API, merged in Linux v4.8. This new interface has introduced the following improvements:</p>
			<ul>
				<li>One device file per GPIO chip: <strong class="source-inline">/dev/gpiochip0</strong>, <strong class="source-inline">/dev/gpiochip1</strong>, <strong class="source-inline">/dev/gpiochipX</strong> ….</li>
				<li>It's similar to other kernel interfaces: <strong class="source-inline">open()</strong> + <strong class="source-inline">ioctl()</strong> + <strong class="source-inline">poll()</strong> + <strong class="source-inline">read()</strong> + <strong class="source-inline">close()</strong>.</li>
				<li>It's possible to request multiple lines at once (for reading/setting values) using bulk-related APIs.</li>
				<li>It's possible to find GPIO lines and chips by name, which is much more reliable.</li>
				<li>Open source and open-drain flags, user/consumer strings, and uevents.</li>
				<li>Reliable polling, preventing the loss of events.</li>
			</ul>
			<p><strong class="source-inline">Libgpiod</strong> is shipped with a C API allowing you to get the most out of any GPIO chip registered on the system. That said, the C++ and Python languages are supported as well. The API is well documented, and too extensive to fully cover here. The basic use cases usually follow these steps:</p>
			<ol>
				<li>Open the desired GPIO chip character device by calling one of the <strong class="source-inline">gpiod_chip_open*</strong> functions, such as <strong class="source-inline">gpiod_chip_open_by_name()</strong> or <strong class="source-inline">gpiod_chip_open_lookup()</strong>. This returns a pointer to <strong class="source-inline">struct gpiod_chip</strong>, which is used by subsequent API calls.</li>
				<li>Retrieve the handle to the <a id="_idIndexMarker1444"/>desired GPIO line by calling <strong class="source-inline">gpiod_chip_get_line()</strong>, which will return a pointer to an instance of <strong class="source-inline">struct gpiod_line</strong>. While the previous API returns the handle to a single GPIO line, the function <strong class="source-inline">gpiod_chip_get_lines()</strong> can be used if several GPIO lines are needed in a single shot. <strong class="source-inline">gpiod_chip_get_lines()</strong> will return a pointer to an instance of <strong class="source-inline">struct gpiod_line_bulk</strong>, which can be used later for bulk operations. The other API that can return a set of GPIO handles is <strong class="source-inline">gpiod_chip_get_all_lines()</strong>, which returns all the lines of a given GPIO  chip in <strong class="source-inline">struct gpiod_line_bulk</strong>. When you have such a set of GPIO objects, you can request a GPIO line at a specific index local to this bulk object by using the <strong class="source-inline">gpiod_line_bulk_get_line()</strong> API. </li>
				<li>Request the use of the line as an input or output by calling <strong class="source-inline">gpiod_line_request_input()</strong> or <strong class="source-inline">gpiod_line_request_output()</strong>. For bulk operations on a set of GPIO lines, <strong class="source-inline">gpiod_line_request_bulk_input()</strong> or <strong class="source-inline">gpiod_line_request_bulk_output()</strong> can be used instead.</li>
				<li>Read the value of input GPIO lines by calling <strong class="source-inline">gpiod_line_get_value()</strong> for a single GPIO or <strong class="source-inline">gpiod_line_get_value_bulk()</strong> in the case of a set of GPIOs. For output GPIO lines, the level can be set by calling <strong class="source-inline">gpiod_line_set_value()</strong> for a single GPIO line or <strong class="source-inline">gpiod_line_set_value_bulk()</strong> on a set of output GPIOs.</li>
				<li>When done, release the lines by calling <strong class="source-inline">gpiod_line_release()</strong> or <strong class="source-inline">gpiod_line_release_bulk()</strong>.</li>
				<li>Once all the GPIO lines have been released, the associated chips can be released using <strong class="source-inline">gpiod_chip_close()</strong> on each.</li>
			</ol>
			<p><strong class="source-inline">gpiod_line_release()</strong> is to be called once done with a GPIO line. The GPIO line to release is passed as a parameter. If it is, however, a set of GPIOs that needs to be released, <strong class="source-inline">gpiod_line_release_bulk()</strong> should be used instead. It has to be noted that if the lines were not previously requested together (were not requested with <strong class="source-inline">gpiod_line_request_bulk()</strong>), the behavior of <strong class="source-inline">gpiod_line_release_bulk()</strong> is undefined.</p>
			<p>There are sanity APIs it might worth mentioning, which are defined as follows:</p>
			<p class="source-code">bool gpiod_line_is_free(struct gpiod_line *line);</p>
			<p class="source-code">bool gpiod_line_is_requested(struct gpiod_line *line);</p>
			<p>In the preceding<a id="_idIndexMarker1445"/> APIs, <strong class="source-inline">gpiod_line_is_requested()</strong> can be used to check if the calling user owns this GPIO line. This function returns <strong class="source-inline">true</strong> if <strong class="source-inline">line</strong> was already requested, or <strong class="source-inline">false</strong> otherwise. It is different from <strong class="source-inline">gpiod_line_is_free()</strong>, which is used to check if the calling user has neither requested ownership <strong class="source-inline">line</strong> nor set up any event notifications on it. It returns <strong class="source-inline">true</strong> if <strong class="source-inline">line</strong> is free, and <strong class="source-inline">false</strong> otherwise.</p>
			<p>Other APIs are available for more advanced functions such as configuring pin modes for pullup or pulldown resistors or registering a callback function to be called when an event occurs, such as the level of an input pin changing, as we will see in the next section.</p>
			<h3>Event- (interrupt-) driven GPIO</h3>
			<p>Interrupt-driven GPIO<a id="_idIndexMarker1446"/> handling consists of grabbing one (<strong class="source-inline">struct gpiod_line</strong>) or more (<strong class="source-inline">struct gpiod_line_bulk</strong>) GPIO handles and listening for events on these GPIO lines, either infinitely or in a timed manner.</p>
			<p>A GPIO line event is abstracted by a <strong class="source-inline">struct gpiod_line_event</strong> object, defined as follows:</p>
			<p class="source-code">struct gpiod_line_event {</p>
			<p class="source-code">    struct timespec ts;</p>
			<p class="source-code">    int event_type;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">ts</strong> is the time specifier data structure to represent the wait event timeout, and <strong class="source-inline">event_type</strong> is the type of event, which can be either <strong class="source-inline">GPIOD_LINE_EVENT_RISING_EDGE</strong> or <strong class="source-inline">GPIOD_LINE_EVENT_FALLING_EDGE</strong>, respectively for a rising edge event or a falling edge event.</p>
			<p>After <a id="_idIndexMarker1447"/>the GPIO handle(s) has been obtained using <strong class="source-inline">gpiod_chip_get_line()</strong> or <strong class="source-inline">gpiod_chip_get_lines()</strong> or <strong class="source-inline">gpiod_chip_get_all_lines()</strong>, the user code should request events of interest on these GPIO handles using one of the following APIs:</p>
			<p class="source-code">int gpiod_line_request_rising_edge_events(</p>
			<p class="source-code">                          struct gpiod_line *line,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p class="source-code">int gpiod_line_request_bulk_rising_edge_events(</p>
			<p class="source-code">                          struct gpiod_line_bulk *bulk,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p class="source-code">int gpiod_line_request_falling_edge_events(</p>
			<p class="source-code">                          struct gpiod_line *line,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p class="source-code">int gpiod_line_request_bulk_falling_edge_events(</p>
			<p class="source-code">                          struct gpiod_line_bulk *bulk,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p class="source-code">int gpiod_line_request_both_edges_events(</p>
			<p class="source-code">                          struct gpiod_line *line,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p class="source-code">int gpiod_line_request_bulk_both_edges_events(</p>
			<p class="source-code">                          struct gpiod_line_bulk *bulk,</p>
			<p class="source-code">                          const char *consumer);</p>
			<p>The preceding APIs request either rising edge, falling edge, or both edge events, respectively on a single GPIO line or on a set of GPIO (the bulk-related API).</p>
			<p>After the events have been requested, the user code can wait on the GPIO lines of interest, waiting for the requested events to occur using one of the following APIs:</p>
			<p class="source-code">int gpiod_line_event_wait(struct gpiod_line *line,</p>
			<p class="source-code">                  const struct timespec *timeout);</p>
			<p class="source-code">int gpiod_line_event_wait_bulk(</p>
			<p class="source-code">                  struct gpiod_line_bulk *bulk,</p>
			<p class="source-code">                  const struct timespec *timeout,</p>
			<p class="source-code">                  struct gpiod_line_bulk *event_bulk);</p>
			<p>In the preceding, <strong class="source-inline">gpiod_line_event_wait()</strong> waits for event(s) on a single GPIO line, while <strong class="source-inline">gpiod_line_event_wait_bulk()</strong> will wait on a set of GPIOs. In parameters, <strong class="source-inline">line</strong> is the GPIO line on which to wait events in the case of single GPIO monitoring, while <strong class="source-inline">bulk</strong> is the set of<a id="_idIndexMarker1448"/> GPIO lines in the case of bulk monitoring. Finally, <strong class="source-inline">event_bulk</strong> is an output parameter, holding the set of GPIO lines on which the GPIO events of interest have occurred. These are all blocking APIs, which will continue execution flow only after the events of interest have occurred or after a timeout.</p>
			<p>Once the blocking function returns, <strong class="source-inline">gpiod_line_event_read()</strong> must be used to read the events that occurred on the GPIO line(s) returned by the previously mentioned monitoring functions. This API has the following prototype:</p>
			<p class="source-code">int gpiod_line_event_read(struct gpiod_line *line,</p>
			<p class="source-code">                         struct gpiod_line_event *event);</p>
			<p>On error, this API returns <strong class="source-inline">-1</strong>, otherwise, it returns <strong class="source-inline">0</strong>. In parameters, <strong class="source-inline">line</strong> is the GPIO line to read the events on, and <strong class="source-inline">event</strong> is an output parameter, the event buffer to which the event data will be copied.</p>
			<p>The following is an example of requesting an event and reading and processing that event:</p>
			<p class="source-code">char *chipname = "gpiochip0";</p>
			<p class="source-code">int ret;</p>
			<p class="source-code">struct gpiod_chip *chip;</p>
			<p class="source-code">struct gpiod_line *input_line;</p>
			<p class="source-code">struct gpiod_line_event event;</p>
			<p class="source-code">unsigned int line_num = 25;  /* GPIO Pin #25 */</p>
			<p class="source-code">chip = gpiod_chip_open_by_name(chipname);</p>
			<p class="source-code">if (!chip) {</p>
			<p class="source-code">     perror("Open chip failed\n");</p>
			<p class="source-code">     return -1;</p>
			<p class="source-code">}</p>
			<p class="source-code">input_line = gpiod_chip_get_line(chip, line_num);</p>
			<p class="source-code">if (!input_line) {</p>
			<p class="source-code">     perror("Get line failed\n");</p>
			<p class="source-code">     ret = -1;</p>
			<p class="source-code">     goto close_chip;</p>
			<p class="source-code">}</p>
			<p class="source-code">ret = gpiod_line_request_rising_edge_events(input_line,</p>
			<p class="source-code">                                            "gpio-test");</p>
			<p class="source-code">if (ret &lt; 0) {</p>
			<p class="source-code">     perror("Request event notification failed\n");</p>
			<p class="source-code">     ret = -1;</p>
			<p class="source-code">     goto release_line;</p>
			<p class="source-code">}</p>
			<p class="source-code">while (1) {</p>
			<p class="source-code">  gpiod_line_event_wait(input_line, NULL); /* blocking */</p>
			<p class="source-code">  if (gpiod_line_event_read(input_line, &amp;event) != 0)</p>
			<p class="source-code">        continue;</p>
			<p class="source-code"> </p>
			<p class="source-code">    /* should always be a rising event in our example */</p>
			<p class="source-code">    if (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)</p>
			<p class="source-code">        continue;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p class="source-code">release_line:</p>
			<p class="source-code">     gpiod_line_release(input_line);</p>
			<p class="source-code">close_chip:</p>
			<p class="source-code">     gpiod_chip_close(chip);</p>
			<p class="source-code">     return ret;</p>
			<p>In the preceding snippet, we first look up the GPIO chip by its name and use the returned GPIO chip handle to grab a <a id="_idIndexMarker1449"/>handle on GPIO line #25. Next, we request a rising events notification (interrupt-driven) on the GPIO line. After that, we loop on waiting for events to happen, read which event it was, and validate that it's a rising event.</p>
			<p>Apart from the previous code example, let's now imagine a much complex example, where we monitor five GPIO lines, and let's start by feeding the required headers:</p>
			<p class="source-code">// file event-bulk.c</p>
			<p class="source-code">#include &lt;gpiod.h&gt;</p>
			<p class="source-code">#include &lt;error.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;string.h&gt;</p>
			<p class="source-code">#include &lt;unistd.h&gt;</p>
			<p class="source-code">#include &lt;sys/time.h&gt;</p>
			<p>Then, let's provide the static variables we will use in the program:</p>
			<p class="source-code">static struct gpiod_chip *chip;</p>
			<p class="source-code">static struct gpiod_line_bulk gpio_lines;</p>
			<p class="source-code">static struct gpiod_line_bulk gpio_events;</p>
			<p class="source-code">/* use GPIOs #4, #7, #9, #15, and #31 as input */</p>
			<p class="source-code">static unsigned int gpio_offsets[] = {4, 7, 9, 15, 31};</p>
			<p>In the previous <a id="_idIndexMarker1450"/>snippet, <strong class="source-inline">chip</strong> will hold the handle to the GPIO chip that we are interested in. <strong class="source-inline">gpio_lines</strong> will hold the handles of the event-driven GPIO lines, that is, the GPIO lines to be monitored. Finally, <strong class="source-inline">gpio_events</strong> will be given to the library so that upon monitoring, it is filled with the handles of GPIO lines on which events have occurred.</p>
			<p>Finally, let's start implementing our <strong class="source-inline">main</strong> method:</p>
			<p class="source-code">int main(int argc, char *argv[])</p>
			<p class="source-code">{</p>
			<p class="source-code">    int err;</p>
			<p class="source-code">    int values[5] = {-1};</p>
			<p class="source-code">    struct timespec timeout;</p>
			<p class="source-code">    chip = gpiod_chip_open("/dev/gpiochip0");</p>
			<p class="source-code">    if (!chip) {</p>
			<p class="source-code">        perror("gpiod_chip_open");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    }</p>
			<p>In the previous snippet, we have simply opened the GPIO chip device and kept a pointer to it. Next, we will have to grab <a id="_idIndexMarker1451"/>handles of the GPIO lines of interest and store them in <strong class="source-inline">gpio_lines</strong>:</p>
			<p class="source-code">    err = gpiod_chip_get_lines(chip, gpio_offsets, 5,</p>
			<p class="source-code">                               &amp;gpio_lines);</p>
			<p class="source-code">    if (err) {</p>
			<p class="source-code">        perror("gpiod_chip_get_lines");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    }</p>
			<p>Then, we use these GPIO line handles to request event monitoring on their underlying GPIO lines. Because we are interested in more than one GPIO, we use the <strong class="source-inline">bulk</strong> API variant, as follows:</p>
			<p class="source-code">    err = gpiod_line_request_bulk_rising_edge_events(</p>
			<p class="source-code">                    &amp;gpio_lines, "rising edge example");</p>
			<p class="source-code">    if(err) {</p>
			<p class="source-code">        perror(</p>
			<p class="source-code">           "gpiod_line_request_bulk_rising_edge_events");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    }</p>
			<p>In the previous snippet, <strong class="source-inline">gpiod_line_request_bulk_rising_edge_events()</strong> will request rising edge event notifications. Now that we have requested event-driven monitoring for our GPIO, we can call the blocking monitoring API on these GPIO lines, as follows:</p>
			<p class="source-code">    /* Timeout of 60 seconds, pass in NULL to wait forever */</p>
			<p class="source-code">    timeout.tv_sec = 60;</p>
			<p class="source-code">    timeout.tv_nsec = 0;</p>
			<p class="source-code">    printf("waiting for rising edge event \n");</p>
			<p class="source-code">marker1:</p>
			<p class="source-code">    err = gpiod_line_event_wait_bulk(&amp;gpio_lines,</p>
			<p class="source-code">                                     &amp;timeout, &amp;gpio_events);</p>
			<p class="source-code">    if (err == -1) {</p>
			<p class="source-code">        perror("gpiod_line_event_wait_bulk");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    } else if (err == 0) {</p>
			<p class="source-code">        fprintf(stderr, "wait timed out\n");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    }</p>
			<p>In the previous excerpt, since we need time-bounded event polling, we set up a <strong class="source-inline">struct timespec</strong> data structure with the desired timeout and we pass it to <strong class="source-inline">gpiod_line_event_wait_bulk()</strong>.</p>
			<p>That said, reaching this<a id="_idIndexMarker1452"/> step (passing the polling function) would mean that either the blocking monitoring API has timed out or that an event occurred on at least one of the GPIO lines that are monitored. The GPIO handles on which events occurred are stored in <strong class="source-inline">gpio_events</strong>, which is an output argument, and the list of monitored GPIO lines is passed in <strong class="source-inline">gpio_lines</strong>. It must be noted that both <strong class="source-inline">gpio_lines</strong> and <strong class="source-inline">gpio_events</strong> are bulk GPIO data structures.</p>
			<p>If ever we are interested in reading the values of the GPIO lines on which events have occurred, we could do the following:</p>
			<p class="source-code">    err = gpiod_line_get_value_bulk(&amp;gpio_events, values);</p>
			<p class="source-code">    if(err) {</p>
			<p class="source-code">        perror("gpiod_line_get_value_bulk");</p>
			<p class="source-code">        goto cleanup;</p>
			<p class="source-code">    }</p>
			<p>If instead of reading the values of<a id="_idIndexMarker1453"/> GPIO lines on which events occurred we needed to read the value of all the monitored GPIO lines, we would have replaced <strong class="source-inline">gpio_events</strong> with <strong class="source-inline">gpio_lines</strong> in the previous code.</p>
			<p>Next, if we are interested in the type of event that occurred on each GPIO line in <strong class="source-inline">gpio_events</strong>, we can do the following:</p>
			<p class="source-code">    for (int i = 0;</p>
			<p class="source-code">         i &lt; gpiod_line_bulk_num_lines(&amp;gpio_events);</p>
			<p class="source-code">         i++) {</p>
			<p class="source-code">        struct gpiod_line* line;</p>
			<p class="source-code">        struct gpiod_line_event event;</p>
			<p class="source-code">        line = gpiod_line_bulk_get_line(&amp;gpio_events, i);</p>
			<p class="source-code">        if(!line) {</p>
			<p class="source-code">           fprintf(stderr, "unable to get line %d\n", i);</p>
			<p class="source-code">           continue;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        if (gpiod_line_event_read(line, &amp;event) != 0)</p>
			<p class="source-code">            continue;</p>
			<p class="source-code">        printf("line %s, %d\n", gpiod_line_name(line),</p>
			<p class="source-code">           gpiod_line_offset(line));</p>
			<p class="source-code">    }</p>
			<p class="source-code">marker2:</p>
			<p>In the preceding code, we iterate over each GPIO line in <strong class="source-inline">gpio_events</strong>, which represents the list of GPIO lines on which events have occurred. <strong class="source-inline">gpiod_line_bulk_num_lines()</strong> retrieves the number of GPIO lines held by the line bulk object, and <strong class="source-inline">gpiod_line_bulk_get_line()</strong> retrieves the line handle from a line bulk object at the given offset, local to this line bulk object. You should, however, note that to achieve the same goal, we could have used the <strong class="source-inline">gpiod_line_bulk_foreach_line()</strong> macro.</p>
			<p>Then, on each <a id="_idIndexMarker1454"/>GPIO line in the line bulk object, we invoke <strong class="source-inline">gpiod_line_event_read()</strong>, <strong class="source-inline">gpiod_line_name()</strong>, and <strong class="source-inline">gpiod_line_offset()</strong>. The first function will retrieve the event data structure corresponding to the event that occurred on that line. We could have then checked that the event type that occurred (especially when monitoring for both event types) is what we expected using something such as <strong class="source-inline">if (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)</strong>, for example. The second function is a helper that will retrieve the GPIO line name, while the third one, <strong class="source-inline">gpiod_line_offset()</strong>, will retrieve the GPIO line offset, global to the running system.</p>
			<p>If we were interested in monitoring these GPIO lines infinitely or for a certain number of rounds, we could have wrapped the code between the <strong class="source-inline">marker1</strong> and <strong class="source-inline">marker2</strong> labels into a <strong class="source-inline">while()</strong> or a <strong class="source-inline">for()</strong> loop. </p>
			<p>At the end of the execution flow, we do some cleaning, like the following:</p>
			<p class="source-code">cleanup:</p>
			<p class="source-code">    gpiod_line_release_bulk(&amp;gpio_lines);</p>
			<p class="source-code">    gpiod_chip_close(chip);</p>
			<p class="source-code">    return EXIT_SUCCESS;</p>
			<p class="source-code">}</p>
			<p>The previous cleaning code snippet first releases all the GPIO lines that we have requested, and then closes the associated GPIO chip.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It must be noted that bulk GPIO monitoring must be done on a per GPIO chip basis. That is, it is not recommended to embed GPIO lines from different GPIO chips in the same line bulk object.</p>
			<p>Now that we are done with API usage and have demonstrated it in a practical example, we can switch to command-line tools shipped with the <strong class="source-inline">libgpiod</strong> library.</p>
			<h3>Command-line tools</h3>
			<p>If you simply need to perform simple GPIO operations, the <strong class="source-inline">Gpiod</strong> library includes a collection of command-line tools that are particularly handy for interactively exploring GPIO functions and can be used in shell scripts to avoid the need to write C or C++ code. There are the following commands available:</p>
			<ul>
				<li><strong class="source-inline">gpiodetect</strong>: Displays<a id="_idIndexMarker1455"/> the list of all GPIO chips on the system, together with their names, labels, and the number of GPIO lines.</li>
				<li><strong class="source-inline">gpioinfo</strong>: Displays<a id="_idIndexMarker1456"/> the names, consumers, direction, active status, and other flags for all lines of the selected GPIO chips. <strong class="source-inline">gpioinfo gpiochip6</strong> is an example. If no GPIO chip is given, the command will iterate through all GPIO chips on the system and list their associated lines.</li>
				<li><strong class="source-inline">gpioget</strong>: Gets the <a id="_idIndexMarker1457"/>values of GPIO lines specified.</li>
				<li><strong class="source-inline">gpioset</strong>: Sets<a id="_idIndexMarker1458"/> the values of specified GPIO lines, and potentially keeps them exported until a timeout, user input, or signal occurs.</li>
				<li><strong class="source-inline">gpiofind</strong>: Given a<a id="_idIndexMarker1459"/> line name, this command finds the associated GPIO chip name and line offset.</li>
				<li><strong class="source-inline">gpiomon</strong>: Monitors <a id="_idIndexMarker1460"/>GPIOs by waiting for events on these lines. This command allows you to specify which events to watch and how many of them should be processed before exiting or whether the events should be reported to the console.</li>
			</ul>
			<p>Now that we have listed the available command-line tools, we can go on to learn about another mechanism offered by the GPIO subsystem, and that can be leveraged from the user space, thanks to which we can use the aforementioned tools.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor254"/>The GPIO aggregator</h2>
			<p>GPIO access control now uses permissions on <strong class="source-inline">/dev/gpiochip*</strong> with the new interface. The typical Unix filesystem permissions enable all-or-nothing access control to these character devices. Compared to the earlier <strong class="source-inline">/sys/class/gpio</strong> interface, this new interface provides a number of advantages, which we listed at the beginning of the <em class="italic">Welcome to the Libgpiod GPIO library </em>section. One disadvantage, however, is that it creates one device file per GPIO chip, implying that access privileges are defined on a per GPIO chip basis, rather than per GPIO line.</p>
			<p>As a result, the <strong class="bold">GPIO aggregator</strong> feature <a id="_idIndexMarker1461"/>has been introduced and merged into version 5.8 of the Linux kernel. It allows you to combine a number of GPIOs into a virtual GPIO chip, which appears as an extra <strong class="source-inline">/dev/gpiochip*</strong> device.</p>
			<p>This feature is handy for designating a set of GPIOs to a certain user and implementing access control. Furthermore, exporting GPIOs to a virtual machine is simplified and hardened because the virtual machine can just grab the entire GPIO controller and no longer has to worry about which GPIOs to grab and which not to, decreasing the attack surface. <strong class="source-inline">Documentation/admin-guide/gpio/gpio-aggregator.rst</strong> is where you'll find its documentation.</p>
			<p>To have GPIO aggregator support in your kernel, you must have <strong class="source-inline">CONFIG_GPIO_AGGREGATOR=y</strong> in your kernel configuration. This feature can be configured either via sysfs or the device tree, as we will see in the next sections.</p>
			<h3>Aggregating GPIOs using sysfs</h3>
			<p>Aggregated GPIO<a id="_idIndexMarker1462"/> controllers are instantiated and destroyed by writing <a id="_idIndexMarker1463"/>to write-only attribute files in sysfs, mainly from the <strong class="source-inline">/sys/bus/platform/drivers/gpio-aggregator/</strong> directory.</p>
			<p>This directory contains the followings attributes:</p>
			<ul>
				<li><strong class="source-inline">new_device</strong>: Used to ask the kernel to instantiate an aggregated GPIO controller by writing a string describing the GPIOs to aggregate. The <strong class="source-inline">new_device</strong> file understands the format <strong class="source-inline">[&lt;gpioA&gt;] [&lt;gpiochipB&gt; &lt;offsets&gt;] ...</strong>:<ul><li><strong class="source-inline">&lt;gpioA&gt;</strong> is a GPIO line name.</li><li><strong class="source-inline">&lt;gpiochipB&gt;</strong> is a GPIO chip label.</li><li><strong class="source-inline">&lt;offsets&gt;</strong> is a comma-separated list of GPIO offsets and/or GPIO offset ranges denoted by dashes.</li></ul></li>
				<li><strong class="source-inline">delete_device</strong>: Used to ask the kernel to destroy an aggregated GPIO controller after use.</li>
			</ul>
			<p>The following is an example<a id="_idIndexMarker1464"/> that instantiated a new GPIO aggregator by <a id="_idIndexMarker1465"/>aggregating GPIO line 19 of <strong class="source-inline">e6052000.gpio</strong> and GPIO lines 20-21 of <strong class="source-inline">e6050000.gpio</strong> into a new <strong class="source-inline">gpio_chip</strong>:</p>
			<p class="source-code"># echo 'e6052000.gpio 19 e6050000.gpio 20-21' &gt; /sys/bus/platform/drivers/gpio-aggregator/new_device</p>
			<p class="source-code"># gpioinfo gpio-aggregator.0</p>
			<p class="source-code">     gpiochip12 - 3 lines:</p>
			<p class="source-code">     line 0: unnamed unused input active-high</p>
			<p class="source-code">     line 1: unnamed unused input active-high</p>
			<p class="source-code">     line 2: unnamed unused input active-high</p>
			<p class="source-code"># chown geert /dev/gpiochip12</p>
			<p>After use, the previously created aggregated GPIO controller can be destroyed using the following command, assuming it is named <strong class="source-inline">gpio-aggregator.0</strong>:</p>
			<p class="source-code">$ echo gpio-aggregator.0 &gt; delete_device</p>
			<p>From the previous example, the GPIO chip that resulted from the aggregation was <strong class="source-inline">gpiochip12</strong>, having three GPIO lines. Instead of <strong class="source-inline">gpioinfo gpio-aggregator.0</strong>, we could have used <strong class="source-inline">gpioinfo gpiochip12</strong>.</p>
			<h3>Aggregating GPIOs from the device tree</h3>
			<p>The device tree<a id="_idIndexMarker1466"/> can also be used to aggregate GPIOs. To do so, simply<a id="_idIndexMarker1467"/> define a node with <strong class="source-inline">gpio-aggregator</strong> as a compatible string and set the <strong class="source-inline">gpios</strong> property to the list of GPIOs that you want to be part of the new GPIO chip. A unique feature of this technique is that, like any other GPIO controller, the GPIO lines can be named and subsequently queried by user-space applications using the <strong class="source-inline">libgpiod</strong> library.</p>
			<p>In the following, we will demonstrate the use of the GPIO aggregator with several GPIO lines from the device tree. First, we enumerate the pins we need to use GPIOs in our new GPIO chip. We do this under the pin controller node as follows:</p>
			<p class="source-code">&amp;iomuxc {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">   aggregator {</p>
			<p class="source-code">      pinctrl_aggregator_pins: aggretatorgrp {</p>
			<p class="source-code">         fsl,pins = &lt;</p>
			<p class="source-code">           MX6QDL_PAD_EIM_D30__GPIO3_IO30      0x80000000  </p>
			<p class="source-code">           MX6QDL_PAD_EIM_D23__GPIO3_IO23      0x80000000 </p>
			<p class="source-code">           MX6QDL_PAD_ENET_TXD1__GPIO1_IO29    0x80000000</p>
			<p class="source-code">           MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24   0x80000000</p>
			<p class="source-code">           MX6QDL_PAD_EIM_D25__GPIO3_IO25      0x80000000</p>
			<p class="source-code">           MX6QDL_PAD_EIM_LBA__GPIO2_IO27      0x80000000</p>
			<p class="source-code">           MX6QDL_PAD_EIM_EB2__GPIO2_IO30      0x80000000</p>
			<p class="source-code">           MX6QDL_PAD_SD3_DAT4__GPIO7_IO01     0x80000000</p>
			<p class="source-code">         &gt;;</p>
			<p class="source-code">      };</p>
			<p class="source-code">   };</p>
			<p class="source-code">}</p>
			<p>Now that our pins have been configured, we can declare our GPIO aggregator as follows:</p>
			<p class="source-code">gpio-aggregator {</p>
			<p class="source-code">    pinctrl-names = "default";</p>
			<p class="source-code">    pinctrl-0 = &lt;&amp;pinctrl_aggregator_pins&gt;;</p>
			<p class="source-code">    compatible = "gpio-aggregator";</p>
			<p class="source-code">    gpios = &lt;&amp;gpio3 30 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio3 23 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio1 29 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio1 25 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio3 25 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio2 27 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio2 30 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">            &lt;&amp;gpio7 1 GPIO_ACTIVE_HIGH&gt;;</p>
			<p class="source-code">    gpio-line-names = "line_a", "line_b", "line_c",</p>
			<p class="source-code">            "line_d", "line_e", "line_f", "line_g",</p>
			<p class="source-code">            "line_h";</p>
			<p class="source-code">};</p>
			<p>In this example, <strong class="source-inline">pinctrl_aggregator_pins</strong> is the GPIO pin node, which must have been<a id="_idIndexMarker1468"/> instantiated under the pin controller node. <strong class="source-inline">gpios</strong> contains <a id="_idIndexMarker1469"/>the list of GPIO lines the new GPIO chip must be made of. At the end, the meaning of <strong class="source-inline">gpio-line-names</strong> is line 30 of GPIO controller <strong class="source-inline">gpio3</strong> is used and is named <strong class="source-inline">line_a</strong>, line 23 of GPIO controller <strong class="source-inline">gpio3</strong> is used and is named <strong class="source-inline">line_b</strong>, line 29 of GPIO controller <strong class="source-inline">gpio1</strong> is used and named <strong class="source-inline">line_c</strong>, and so on up to line 1 of GPIO controller <strong class="source-inline">gpio7</strong>, which is named <strong class="source-inline">line_h</strong>.</p>
			<p>From the user space, we can see the GPIO chip and its aggregated lines:</p>
			<p class="source-code"># gpioinfo</p>
			<p class="source-code">[...]</p>
			<p class="source-code">gpiochip9 - 8 lines:</p>
			<p class="source-code">    line 0: "line_a" unused input active-high</p>
			<p class="source-code">    line 1: "line_b" unused input active-high</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    line 7: "line_g" unused input active-high</p>
			<p class="source-code">[...]</p>
			<p>We can search <a id="_idIndexMarker1470"/>a GPIO chip and a line number by the line<a id="_idIndexMarker1471"/> name:</p>
			<p class="source-code"># gpiofind 'line_b'</p>
			<p class="source-code">gpiochip9 1</p>
			<p>We can access a GPIO line by its name:</p>
			<p class="source-code"># gpioget $(gpiofind 'line_b')</p>
			<p class="source-code">1</p>
			<p class="source-code">#</p>
			<p class="source-code"># gpioset $(gpiofind 'line_h')=1</p>
			<p class="source-code"># gpioset $(gpiofind 'line_h')=0</p>
			<p>We can change the GPIO chip device file ownership to allow user or group to access the attached lines:</p>
			<p class="source-code"># chown $user:$group /dev/gpiochip9</p>
			<p class="source-code"># chmod 660 /dev/gpiochip9</p>
			<p>The GPIO chip created by the aggregator can be retrieved from sysfs in <strong class="source-inline">/sys/bus/platform/devices/gpio-aggregator/</strong>.</p>
			<h3>Aggregating GPIOs using a generic GPIO driver</h3>
			<p>Without a particular in-kernel driver, the GPIO aggregator can be used as a generic driver for a simple GPIO-operated device described in the device tree. Modifying the <strong class="source-inline">gpio-aggregator</strong> driver or writing to the <strong class="source-inline">driver_override</strong> file in sysfs are both options for binding a device to the GPIO aggregator.</p>
			<p>Before we go <a id="_idIndexMarker1472"/>further, let's talk about the <strong class="source-inline">driver_override</strong> file; this file is more precisely located in <strong class="source-inline">/sys/bus/platform/devices/.../driver_override</strong>. This file specifies the driver for a device, which will override the standard device tree, ACPI, ID table, and name matching, as we have seen in <a href="B17934_06_Epub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Introduction to Devices, Drivers, and Platform Abstraction</em>. It has to be noted that only a driver whose name matches the value written to <strong class="source-inline">driver_override</strong> will be able to bind to the device. The override is set by writing a string to the <strong class="source-inline">driver_override</strong> file (<strong class="source-inline">echo vfio-platform &gt; driver_override</strong>), and it can be cleared by writing an empty string to the file (<strong class="source-inline">echo &gt; driver_override</strong>). This reverts the device to its default binding of matching rules. It must, however, be noted that writing to driver override does not unbind the device from its existing driver or attempt to load the supplied driver automatically. The device will not bind to any driver if no driver with a matching name is currently loaded in the kernel. Devices can also use a <strong class="source-inline">driver_override</strong> name such as <strong class="source-inline">none</strong> to opt out of driver binding. There is no support for parsing delimiters, and only a single driver can be given in the override.</p>
			<p>For example, given a <strong class="source-inline">door</strong> device, which is a GPIO-operated device described in the device tree, use its own compatible value as follows:</p>
			<p class="source-code">door {</p>
			<p class="source-code">     compatible = "myvendor,mydoor";</p>
			<p class="source-code">     gpios = &lt;&amp;gpio2 19 GPIO_ACTIVE_HIGH&gt;,</p>
			<p class="source-code">           &lt;&amp;gpio2 20 GPIO_ACTIVE_LOW&gt;;</p>
			<p class="source-code">     gpio-line-names = "open", "lock";</p>
			<p class="source-code">};</p>
			<p>It can be bound to the GPIO aggregator with either of the following methods:</p>
			<ul>
				<li>Adding its compatible value to <strong class="source-inline">gpio_aggregator_dt_ids[]</strong> in <strong class="source-inline">drivers/gpio/gpio-aggregator.c</strong></li>
				<li>Binding manually using <strong class="source-inline">driver_override</strong></li>
			</ul>
			<p>The first method is quite straightforward:</p>
			<p class="source-code">$ echo gpio-aggregator &gt; /sys/bus/platform/devices/door/driver_override</p>
			<p class="source-code">$ echo door &gt; /sys/bus/platform/drivers/gpio-aggregator/bind</p>
			<p>In the previous<a id="_idIndexMarker1473"/> commands, we have written the driver's name (<strong class="source-inline">gpio-aggregator</strong> in this case) in the <strong class="source-inline">driver_override</strong> file present in the device directory, <strong class="source-inline">/sys/bus/platform/devices/&lt;device-name&gt;/</strong>. After that, we have bound the device to the driver by writing the device name in the <strong class="source-inline">bind</strong> file present in the driver's directory, <strong class="source-inline">/sys/bus/&lt;bus-name&gt;/drivers/&lt;driver-name&gt;/</strong>. It has to be noted that <strong class="source-inline">&lt;bus-name&gt;</strong> corresponds to the bus framework the driver belongs to. It could be <strong class="source-inline">i2c</strong>, <strong class="source-inline">spi</strong>, <strong class="source-inline">platform</strong>, <strong class="source-inline">pci</strong>, <strong class="source-inline">isa</strong>, <strong class="source-inline">usb</strong>, and so on.</p>
			<p>After the binding, a new GPIO chip, <strong class="source-inline">door</strong>, will be created. Its information can then be carried out as follows:</p>
			<p class="source-code">$ gpioinfo door</p>
			<p class="source-code">gpiochip12 - 2 lines:</p>
			<p class="source-code">     line   0:       "open"       unused   input  active-high</p>
			<p class="source-code">     line   1:       "lock"       unused   input  active-high</p>
			<p>Next, the library APIs can be used on this GPIO chip like any other normal (non-virtual) GPIO chip.</p>
			<p>We are now done with GPIO aggregation from the user space in particular, and with GPIO management from the user space in general. We have learned how to create virtual GPIO chips to isolate a set of GPIOs, and we have learned how to use the GPIO library to drive these GPIOs.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor255"/>Summary</h1>
			<p>In this chapter, we introduced the pin control framework and described its interaction with the GPIO subsystem. We learned how to deal with GPIOs, either as a controller or consumer, from both the kernel and the user space. Though the legacy integer-based interface is deprecated, it was introduced because it is still widely used. Additionally, we introduced some advanced topics such as IRQ chip support in the GPIO chip and the mapping of GPIOs to IRQs. We ended this chapter by learning how to deal with GPIOs from the user space, by writing C code or by using dedicated command-line tools provided by the standard Linux GPIO library, <strong class="source-inline">libgpiod</strong>.</p>
			<p>In the next chapter, we deal with input devices, which can be implemented using GPIOs.</p>
		</div>
	</body></html>