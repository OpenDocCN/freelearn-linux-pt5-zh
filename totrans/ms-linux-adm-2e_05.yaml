- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Processes, Daemons, and Signals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux is a multitasking operating system. Multiple programs or tasks can run
    in parallel, each with its own identity, scheduling, memory space, permissions,
    and system resources. **Processes** encapsulate the execution context of any such
    program. Understanding how processes work and communicate with each other is an
    important skill for any seasoned Linux system administrator and developer to have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores the basic concepts behind Linux processes. We’ll look
    at different types of processes, such as **foreground** and **background** processes,
    with special emphasis being placed on **daemons** as a particular type of background
    process. We’ll closely study the anatomy of a process and various inter-process
    communication mechanisms in Linux – **signals** in particular. Along the way,
    we’ll learn about some of the essential command-line utilities for managing processes
    and daemons and working with signals. We will also introduce you to **scripts**
    for the first time in this book, which are described in detail later in [*Chapter
    8*](B19682_08.xhtml#_idTextAnchor164), *Linux Shell Scripting*. If you feel like
    you need more information when dealing with the scripts in this chapter, take
    a look at [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164) in advance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introducing processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with processes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with daemons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring inter-process communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: As we navigate through the content, we will occasionally reference signals *before*
    their formal introduction in the second half of this chapter. In Linux, signals
    are almost exclusively used in association with processes, hence our approach
    of becoming familiar with processes first. Yet, leaving the signals out from some
    of the process’ internals would do a disservice to understanding how processes
    work. Where signals are mentioned, we’ll point to the related section for further
    reference. We hope that this approach provides you with a better grasp of the
    overall picture and the inner workings of processes and daemons.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we start, let’s look at the essential requisites for our study.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice makes perfect. Running the commands and examples in this chapter by
    hand would go a long way toward you learning about processes. As with any chapter
    in this book, we recommend that you have a working Linux distribution installed
    on a VM or PC desktop platform. We’ll be using Ubuntu or Fedora, but most of the
    commands and examples would be similar on any other Linux platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Introducing processes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **process** represents the running instance of a program. In general, a program
    is a combination of instructions and data, compiled as an executable unit. When
    a program runs, a process is created. In other words, a process is simply a program
    in action. Processes execute specific tasks, and sometimes, they are also referred
    to as **jobs** (or **tasks**).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to create or start a process. In Linux, every command starts
    a process. A command could be a user-initiated task in a Terminal session, a script,
    or a program (executable) that’s invoked manually or automatically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the way a process is created and interacts with the system (or user)
    determines its process type. Let’s take a closer look at the different types of
    processes in Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Understanding process types
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At a high level, there are two major types of processes in Linux:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '**Foreground** (*interactive*)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background** (*non-interactive* or *automated*)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive processes assume some kind of user interaction during the lifetime
    of the process. Non-interactive processes are unattended, which means that they
    are either automatically started (for example, on system boot) or are scheduled
    to run at a particular time and date via job schedulers (for example, using the
    `at` and `cron` command-line utilities).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Our approach to exploring process types mainly pivots around the preceding classification.
    There are various other views or taxonomies surrounding process definitions, but
    they could ultimately be reduced to either foreground or background processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: For example, batch processes and daemons are essentially background processes.
    Batch processes are automated in the sense that they are not user-generated but
    invoked by a scheduled task instead. Daemons are background processes that are
    usually started during system boot and run indefinitely.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the concept of parent and child processes. A parent process may
    create other subordinate child processes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We’ll elaborate on these types (and beyond) in the following sections. Let’s
    start with the pivotal ones – foreground and background processes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Foreground processes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`stdout` or `stderr`) or accept user input. The lifetime of a foreground process
    is tightly coupled to the Terminal session (parent process). If the user who launched
    the foreground process exits the Terminal while the process is still running,
    the process will be abruptly terminated (via a `SIGHUP` signal sent by the parent
    process; see *Signals* in the *Exploring inter-process communication* section
    for more details).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a foreground process is invocating the system reference
    manual (`man`) for an arbitrary Linux command (for example, `ps`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `ps` command displays information about active processes. You will learn
    more about process management tools and command-line utilities in the *Working
    with* *processes* section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Once a foreground process has been initiated, the user prompt is captured and
    controlled by the spawned process interface. The user can no longer interact with
    the initial command prompt until the interactive process relinquishes control
    to the Terminal session.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example of a foreground process, this time invoking a
    long-lived task. The following command (one-liner) runs an infinite loop while
    displaying an arbitrary message every few seconds:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So long as the command runs without being interrupted, the user won’t have
    an interactive prompt in the Terminal. Using *Ctrl* + *C* would stop (interrupt)
    the execution of the related foreground process and yield a responsive command
    prompt:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_05_01_B19682.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A long-lived foreground process
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: When you press *Ctrl* + *C* while a foreground process is running, a `SIGINT`
    signal is sent to the running process by the current (parent) Terminal session,
    and the foreground process is interrupted. For more information, see the *Signals*
    section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: If we want to maintain an interactive command prompt in the Terminal session
    while running a specific command or script, we should use a background process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Background processes
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Background processes** – also referred to as **non-interactive** or **automatic
    processes** – run independently of a Terminal session, without expecting any user
    interaction. A user may invoke multiple background processes within the same Terminal
    session without waiting on any of them to complete or exit.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Background processes are usually long-lived tasks that don’t require direct
    user supervision. The related process may still display its output in the Terminal
    console, but such background tasks typically write their results to different
    files instead (such as log files).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest invocation of a background process appends an ampersand (`&`)
    to the end of the related command. Building on our previous example (in the *Foreground
    processes* section), the following command creates a background process that runs
    an infinite loop, echoing an arbitrary message every few seconds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the ampersand (`&`) at the end of the command. By default, a background
    process would still direct the output (`stdout` and `stderr`) to the console when
    invoked with the ampersand (`&`), as shown previously. However, the Terminal session
    remains interactive. In the following figure, we are using the `echo` command
    while the previous process is still running:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Running a background process](img/Figure_05_02_B19682.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Running a background process
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, the background process is given a `983`.
    While the process is running, we can still control the Terminal session and run
    a different command, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Eventually, we can force the process to terminate with the `kill` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command *kills* our background process (with PID `983`). The corresponding
    signal that’s sent by the parent Terminal session to terminate this process is
    `SIGKILL` (see the *Signals* section for more information) through the `-9` argument
    in our command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Both foreground and background processes are typically under the direct control
    of a user. In other words, these processes are created or started manually as
    a result of a command or script invocation. There are some exceptions to this
    rule, particularly when it comes to batch processes, which are launched automatically
    via scheduled jobs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前台和后台进程通常都在用户的直接控制下。换句话说，这些进程是通过命令或脚本的调用手动创建或启动的。虽然如此，也有一些例外，特别是在批处理进程的情况下，这些进程会通过计划任务自动启动。
- en: There’s also a select category of background processes that are automatically
    started during system boot and terminated at shutdown without user supervision.
    These background processes are also known as daemons.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一类选择性的后台进程，它们会在系统启动时自动启动，并在关机时终止，无需用户干预。这些后台进程也被称为守护进程。
- en: Introducing daemons
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍守护进程
- en: A`root` or other) and runs with the related privileges.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `root` 用户（或其他）以相关的权限运行。
- en: 'Daemons usually serve client requests or communicate with other foreground
    or background processes. Here are some common examples of daemons, all of which
    are generally available on most Linux platforms:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程通常用于服务客户端请求或与其他前台或后台进程进行通信。以下是一些常见的守护进程示例，它们通常在大多数 Linux 平台上可用：
- en: '`systemd`: The parent of all processes (formerly known as `init`)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`：所有进程的父进程（以前称为 `init`）'
- en: '`crond`: A job scheduler that runs tasks in the background'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crond`：一个在后台运行任务的作业调度器'
- en: '`ftpd`: An FTP server that handles client FTP requests'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ftpd`：一个处理客户端 FTP 请求的 FTP 服务器'
- en: '`httpd`: A web server (Apache) that handles client HTTP requests'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd`：一个处理客户端 HTTP 请求的 Web 服务器（Apache）'
- en: '`sshd`: A Secure Shell server that handles SSH client requests'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sshd`：一个处理 SSH 客户端请求的安全外壳服务器'
- en: Typically, system daemons in Linux are named with `d` at the end, denoting a
    daemon process. Daemons are controlled by shell scripts usually stored in the
    `/etc/init.d/` or `/lib/systemd/` system directory, depending on the Linux platform.
    Ubuntu, for example, stores daemon script files in `/etc/init.d/`, while Fedora
    stores them in `/lib/systemd/`. The location of these daemon files depends on
    the platform implementation of `init`, a system-wide service manager for all Linux
    processes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Linux 系统中的守护进程名称以 `d` 结尾，表示它是一个守护进程。守护进程由通常存储在 `/etc/init.d/` 或 `/lib/systemd/`
    系统目录中的 Shell 脚本控制，这取决于 Linux 平台。例如，Ubuntu 将守护进程脚本文件存储在 `/etc/init.d/` 中，而 Fedora
    将它们存储在 `/lib/systemd/` 中。这些守护进程文件的位置取决于 `init` 的平台实现，它是一个针对所有 Linux 进程的系统级服务管理器。
- en: The Linux init-style startup process generally invokes these shell scripts at
    system boot. But the same scripts can also be invoked via service control commands,
    usually run by privileged system users, to manage the lifetime of specific daemons.
    In other words, a privileged user or system administrator can *stop* or *start*
    a particular daemon through the command-line interface. Such commands would immediately
    return the user’s control to the Terminal while performing the related action
    in the background.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 的 `init` 风格启动过程通常会在系统启动时调用这些 Shell 脚本。但是，通常通过服务控制命令也可以调用这些脚本，这些命令通常由拥有特权的系统用户执行，以管理特定守护进程的生命周期。换句话说，特权用户或系统管理员可以通过命令行界面来*停止*或*启动*某个特定的守护进程。此类命令会在执行相关操作的同时立即将用户的控制权交还给终端，并在后台执行相关任务。
- en: Let’s take a closer look at the `init` process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解 `init` 进程。
- en: The init process
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`init` 进程'
- en: Throughout this chapter, we’ll refer to `init` as the *generic* system initialization
    engine and service manager on Linux platforms. Over the years, Linux distributions
    have evolved and gone through various `init` system implementations, such as `SysV`,
    `upstart`, `OpenRC`, `systemd`, and `runit`. There’s an ongoing debate in the
    Linux community about the supremacy or advantages of one over the other. For now,
    we will simply regard `init` as a system process, and we will briefly look at
    its relationship with other processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将 `init` 称为 Linux 平台上的*通用*系统初始化引擎和服务管理器。多年来，Linux 发行版经历了各种 `init` 系统实现的演变，比如
    `SysV`、`upstart`、`OpenRC`、`systemd` 和 `runit`。Linux 社区关于这些实现的优劣存在持续的辩论。现在，我们将
    `init` 简单地看作一个系统进程，并简要了解它与其他进程的关系。
- en: '`init` (or `systemd`, and others) is essentially a system daemon, and it’s
    among the first process to start when Linux boots up. The related daemon process
    continues to run in the background until the system is shut down. `init` is the
    root (parent) process of all other processes in Linux, in the overall process
    hierarchy tree. In other words, it is a direct or indirect ancestor of all the
    processes in the system.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, the `pstree` command displays the whole process tree, and it shows
    the `init` process at its root – in our case, `systemd` (on Ubuntu or Fedora).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – init (systemd), the parent of all processes](img/Figure_05_03_B19682.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – init (systemd), the parent of all processes
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The `pstree` command’s output illustrates a hierarchy tree representation of
    the processes, where some appear as parent processes while others appear as child
    processes. Let’s look at the parent and child process types and some of the dynamics
    between them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Parent and child processes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `SIGHUP` signal that’s invoked by the parent process upon termination (for
    example, via the `nohup` command). See the *Signals* section for more information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, all processes except the `init` process (with its variations) are
    children of a specific process. Terminating a child process won’t stop the related
    parent process from running. A good practice for terminating a parent process
    when the child is done processing is to exit from the parent process itself after
    the child process completes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: There are cases when processes run unattended, based on a specific schedule.
    Running a process without user interaction is known as batch processing. We’ll
    look at batch processes next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Batch processes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `at` and `cron`. While `cron` is better suited to scheduled task management
    complexities, `at` is a more lightweight utility, better suited for one-off jobs.
    A detailed study of these commands is beyond the scope of this chapter. You may
    refer to the related system reference manuals for more information (`man at` and
    `man cron`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We’ll conclude our study of process types with orphan and zombie processes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Orphan and zombie processes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a child process is terminated, the related parent process is notified with
    a `SIGCHILD` signal. The parent can go on running other tasks or may choose to
    spawn another child process. However, there may be instances when the parent process
    is terminated before a related child process completes execution (or exits). In
    this case, the child process becomes an `init` process – the parent of all processes
    – automatically becomes the new parent of the orphan process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`ps` command).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the zombie and orphan processes is that a zombie
    process is dead (terminated), while an orphan process is still running.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: As we differentiate between various process types and their behavior, a significant
    part of the related information is reflected in the composition or data structure
    of the process itself. In the next section, we’ll take a closer look at the makeup
    of a process, which is mostly echoed through the `ps` command-line utility – an
    ordinary yet very useful process explorer on Linux systems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们区分不同的进程类型及其行为时，相关信息的一个重要部分反映在进程本身的组成或数据结构中。在下一节中，我们将更深入地了解进程的构成，这主要通过 `ps`
    命令行工具来体现——这是 Linux 系统上一个普通但非常有用的进程查看器。
- en: The anatomy of a process
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程的结构
- en: 'In this section, we will explore some of the common attributes of a Linux process
    through the lens of the `ps` and `top` command-line utilities. We hope that taking
    a practical approach based on these tools will help you gain a better understanding
    of process internals, at least from a Linux administrator’s perspective. Let’s
    start by taking a brief look at these commands. The `ps` command displays a current
    snapshot of the system processes. This command has the following syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将通过 `ps` 和 `top` 命令行工具，探讨 Linux 进程的一些常见属性。我们希望通过这些工具的实际应用，帮助你更好地理解进程的内部机制，至少从
    Linux 管理员的角度来看。我们先简单了解一下这些命令。`ps` 命令显示系统进程的当前快照。此命令的语法如下：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command displays the processes owned by the current Terminal
    session:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示当前终端会话拥有的进程：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令输出可以在下面的截图中看到：
- en: '![Figure 5.4 – Displaying processes owned by the current shell](img/Figure_05_04_B19682.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 显示当前 shell 拥有的进程](img/Figure_05_04_B19682.jpg)'
- en: Figure 5.4 – Displaying processes owned by the current shell
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 显示当前 shell 拥有的进程
- en: 'Let’s look at each field in the top (header) row of the output and explain
    their meaning in the context of our relevant process – that is, the `bash` Terminal
    session:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看输出的顶部（标题）行中的每个字段，并解释它们在我们相关进程——也就是 `bash` 终端会话中的含义：
- en: '`PID`: Each process in Linux has a `PID` value automatically assigned by the
    kernel when the process is created. The `PID` value is a positive integer and
    is always guaranteed to be unique.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID`：在 Linux 中，每个进程都有一个由内核自动分配的 `PID` 值。`PID` 值是一个正整数，并且始终保证是唯一的。'
- en: In our case, the relevant process is `bash` (the current shell), with a PID
    of `171233`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，相关的进程是 `bash`（当前 shell），其 PID 为 `171233`。
- en: '`TTY`: `TTY` attribute denotes the type of Terminal the process interacts with.
    In our example, the `bash` process representing the Terminal session has `pts/0`
    as its TTY type. `pts` stands for `/0` indicates the ordinal sequence of the related
    Terminal session. For example, an additional SSH session would have `pts/1`, and
    so on.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TTY`：`TTY` 属性表示进程与之交互的终端类型。在我们的示例中，代表终端会话的 `bash` 进程的 `TTY` 类型是 `pts/0`。`pts`
    代表 `/0` 表示相关终端会话的序列号。例如，额外的 SSH 会话将会有 `pts/1`，依此类推。'
- en: '`TIME`: The `TIME` field represents the cumulative CPU utilization (or time)
    spent by the process (in `[DD-]hh:mm:ss` format). Why is it zero (`00:00:00`)
    for the `bash` process in our example? We may have run multiple commands in our
    Terminal session, yet the CPU utilization could still be zero. That’s because
    the CPU utilization measures (and accumulates) the time spent for each command,
    and not the parent Terminal session overall. If the commands complete within a
    fraction of a second, they will not amount to a significant CPU utilization being
    shown in the `TIME` field.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`：`TIME` 字段表示该进程所消耗的累计 CPU 使用时间（以 `[DD-]hh:mm:ss` 格式显示）。为什么在我们的示例中，`bash`
    进程的 `TIME` 是零（`00:00:00`）？我们可能在终端会话中运行了多个命令，但 CPU 使用时间仍然为零。这是因为 CPU 使用时间是针对每个命令所消耗的时间进行测量（并累积），而不是针对整个父终端会话。如果命令在几分之一秒内完成，那么它们所消耗的
    CPU 时间不会在 `TIME` 字段中显示出显著的数值。'
- en: '`CMD`: The `CMD` field stands for command and indicates the name or full path
    of the command (including the arguments) that created the process. For well-known
    system commands (for example, `bash`), `CMD` displays the command’s name, including
    its arguments.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：`CMD` 字段代表命令，指示创建该进程的命令的名称或完整路径（包括参数）。对于常见的系统命令（例如，`bash`），`CMD` 会显示命令名称，包括其参数。'
- en: 'The process attributes we’ve explored thus far represent a relatively simple
    view of Linux processes. There are situations when we may need more information.
    For example, the following command provides additional details about the processes
    running in the current Terminal session:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `-l` option parameter invokes the so-called *long format* for the `ps`
    output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A more detailed view of processes](img/Figure_05_05_B19682.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – A more detailed view of processes
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are just a few of the more relevant output fields of the `ps` command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`F`: Process flags (for example, `0` – none, `1` – forked, and `4` – superuser
    privileges)'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: Process status code (for example, `R` – running, `S` – interruptible sleep,
    and so on)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UID`: The username or owner of the process (the user ID)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PID`: The process ID'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PPID`: The process ID of the parent process'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRI`: The priority of the process (a higher number means lower priority)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SZ`: The virtual memory usage'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more such attributes and exploring them all is beyond the scope
    of this book. For additional information, refer to the `ps` system reference manual
    (`man ps`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` command examples we’ve used so far have only displayed the processes
    that are owned by the current Terminal session. This approach, we thought, would
    add less complexity to analyzing process attributes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `ps`, another command that’s used is `top`, and it provides a live
    (real-time) view of all the running processes in a system. Its syntax is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Many of the process output fields displayed by the `ps` command are also reflected
    in the `top` command, albeit some of them with slightly different notations. Let’s
    look at the `top` command and the meaning of the output fields that are displayed.
    The following command displays a real-time view of running processes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A real-time view of the current processes](img/Figure_05_06_B19682.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A real-time view of the current processes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the output fields, briefly explained:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`USER`: The username or owner of the process'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PR`: The priority of the process (a lower number means higher priority)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NI`: The nice value of the process (a sort of dynamic/adaptive priority)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VIRT`: The virtual memory size (in KB) – the total memory used by the process'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RES`: The resident memory size (in KB) – the physical (non-swapped) memory
    used by the process'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHR`: The shared memory size (in KB) – a subset of the process memory shared
    with other processes'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: The process’ status (for example, `R` – running, `S` – interruptible sleep,
    `I` – idle, and so on)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%CPU`: CPU usage (percentage)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%MEM`: `RES` memory usage (percentage)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND`: Command name or command line'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these fields (and many more) are explained in detail in the `top` system
    reference manual (`man top`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Every day, Linux administration tasks frequently use process-related queries
    based on the preceding presented fields. The *Working with processes* section
    will explore some of the more common usages of the `ps` and `top` commands, and
    beyond.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: An essential aspect of a process’s lifetime is the `ps` and `top` commands provide
    information about the status of the process via the `S` field. Let’s take a closer
    look at these states.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Process states
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During its lifetime, a process may change states according to circumstances.
    According to the `S` (status) field of the `ps` and `top` commands, a Linux process
    can have any of the following states:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`D`: Uninterruptible sleep'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I`: Idle'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R`: Running'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S`: Sleeping (interruptible sleep)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T`: Stopped by a job control signal'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: Stopped by the debugger during a trace'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z`: Zombie'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At a high level, any of these states can be identified with the following process
    states:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`R` state) or is an idle process (the `I` state). In Linux, an idle process
    is a specific task that’s assigned to every processor (CPU) in the system and
    is scheduled to run only when there’s no other process running on the related
    CPU. The time that’s spent on idle tasks accounts for the idle time that’s reported
    by the `top` command.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S` state) and uninterruptible sleep (the `D` state). Interruptible sleep can
    be disturbed by specific process signals, yielding further process execution.
    On the other hand, uninterruptible sleep is a state where the process is blocked
    in a system call (possibly waiting on some hardware conditions), and it cannot
    be interrupted.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T` state) or a debugging signal (the `t` state).'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z` state) – it’s terminated without being reaped by its parent. A zombie process
    is essentially a dead reference for an already terminated process in the system’s
    process table. This will be discussed in more detail in the *Orphan and zombie*
    *processes* section.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To conclude our analysis of process states, let’s look at the lifetime of a
    Linux process. Usually, a process starts with a running state (`R`) and terminates
    once its parent has reaped it from the zombie state (`Z`). The following diagram
    provides an abbreviated view of the process states and the possible transitions
    between them:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The lifetime of a Linux process](img/Figure_05_07_B19682.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The lifetime of a Linux process
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced processes and provided you with a preliminary idea
    of their type and structure, we’re ready to interact with them. In the following
    sections, we will explore some standard command-line utilities for working with
    processes and daemons. Most of these tools operate with input and output data,
    which we covered in the *Anatomy of a process* section. We’ll look at working
    with processes next.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Working with processes
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section serves as a practical guide to managing processes via resourceful
    command-line utilities that are used in everyday Linux administration tasks. Some
    of these tools were mentioned in previous sections (for example, `ps` and `top`)
    when we covered specific process internals. Here, we will summon most of the knowledge
    we’ve gathered so far and take it for a real-world spin by covering some hands-on
    examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the `ps` command – the Linux process explorer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Using the ps command
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We described the `ps` command and its syntax in the *Anatomy of a process*
    section. The following command displays a selection of the current processes running
    in the system:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `-e` option (or `-A`) selects *all* the processes in the system. The `head`
    pipe invocation displays only the first few lines (10 by default):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Displaying the first few processes](img/Figure_05_08_B19682.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Displaying the first few processes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The preceding information may not always be particularly useful. Perhaps we’d
    like to know more about each process, beyond just the `PID` or `CMD` fields in
    the `ps` command’s output. (We described some of these process attributes in the
    *Anatomy of a* *process* section).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists the processes owned by the current user more elaborately:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-f` option specifies the full-format listing, which displays more detailed
    information for each process. The `-U $(whoami)` option parameter specifies the
    current user (`packt`) as the real user (owner) of the processes we’d like to
    retrieve. In other words, we want to list all the processes we own:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Displaying the processes owned by the current user](img/Figure_05_09_B19682.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Displaying the processes owned by the current user
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'There are situations when we may look for a specific process, either for monitoring
    purposes or to act upon them. Let’s take a previous example, where we showcased
    a long-lived process and wrapped the related command into a simple script. The
    command is a simple `while` loop that runs indefinitely:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using an editor of our preference (for example, `nano`), we can create a script
    file (for example, `test.sh`) with the following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – A simple test script running indefinitely](img/Figure_05_10_B19682.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – A simple test script running indefinitely
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make the test script executable and run it as a background process:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note the ampersand (`&`) at the end of the command, which invokes the background
    process:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Running a script as a background process](img/Figure_05_11_B19682.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Running a script as a background process
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The background process running our script has a process ID (`PID`) of `1094`.
    Suppose we want to find our process by its name (`test.sh`). For this, we can
    use the `ps` command with a `grep` pipe:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 5.12 – Finding a process by name using the ps command](img/Figure_05_12_B19682.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Finding a process by name using the ps command
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The preceding output shows that our process has a `PID` value of `1094` and
    a `CMD` value of `/bin/bash ./test.sh`. The `CMD` field contains the full command
    invocation of our script, including the command-line parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We should note that the first line of the `test.sh` script contains `#!/bin/bash`,
    which prompts the OS to invoke `bash` for the script’s execution. This line is
    also known as the `CMD` field, the command in our case is `/bin/bash` (according
    to the shebang invocation), and the related command-line parameter is the `test.sh`
    script. In other words, `bash` executes the `test.sh` script.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the preceding `ps` command also includes our `ps | grep` command’s
    invocation, which is somewhat irrelevant. A refined version of the same command
    is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Finding a process by name using the ps command (refined)](img/Figure_05_13_B19682.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Finding a process by name using the ps command (refined)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The `grep -v grep` pipe filters out the unwanted `grep` invocation from the
    `ps` command’s results.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to find a process based on a process ID (`PID`), we can invoke the
    `ps` command with the `-p|--pid` option parameter. For example, the following
    command displays detailed information about our process with `PID` set to `1094`
    (running the `test.sh` script):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Finding a process by PID using the ps command](img/Figure_05_14_B19682.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Finding a process by PID using the ps command
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` option displays the detailed (*long-format*) process information.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous other use cases for the `ps` command, and exploring them
    all is well beyond the scope of this book. The invocations we’ve enumerated here
    should provide a basic exploratory guideline for you. For more information, please
    refer to the `ps` system reference manual (`man ps`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Using the pstree command
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pstree` shows the running processes in a hierarchical, tree-like view. In
    some respects, `pstree` acts as a visualizer of the `ps` command. The root of
    the `pstree` command’s output is either the `init` process or the process with
    the `PID` value specified in the command. The syntax of the `pstree` command is
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following command displays the process tree of our current Terminal session:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The process tree of the current Terminal session](img/Figure_05_15_B19682.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The process tree of the current Terminal session
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding command, `echo $$` provides the `PID` value of the current
    Terminal session. `$$` is a Bash built-in variable that contains the `PID` value
    of the shell that is running. The `PID` value is wrapped as the argument for the
    `pstree` command. To show the related PIDs, we can invoke the `pstree` command
    with the `-``p|--show-pids` option:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The process tree (along with its PIDs) of the current Terminal
    session](img/Figure_05_16_B19682.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – The process tree (along with its PIDs) of the current Terminal
    session
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command shows the processes owned by the current user:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – The process tree owned by the current user](img/Figure_05_17_B19682.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – The process tree owned by the current user
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `pstree` command, please refer to the related
    system reference manual (`man pstree`).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Using the top command
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to monitoring processes in real time, the `top` utility is among
    the most common tool to be used by Linux administrators. The related command-line
    syntax is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following command displays all the processes currently running in the system,
    along with real-time updates (on memory, CPU usage, and so on):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Pressing *Q* will exit the `top` command. By default, the `top` command sorts
    the output by CPU usage (shown in the `%``CPU` field/column).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We can also choose to sort the output of the `top` command by a different field.
    While `top` is running, press *Shift* + *F* (`F`) to invoke interactive mode.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Using the arrow keys, we can select the desired field to sort by (for example,
    `%MEM`), then press *S* to set the new field, followed by *Q* to exit interactive
    mode. The alternative to interactive mode sorting is invoking the `-o` option
    parameter of the `top` command, which specifies the sorting field.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command lists the top 10 processes, sorted by CPU
    usage:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, the following command lists the top 10 processes, sorted by CPU
    and memory usage:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `-b` option parameter specifies the batch mode operation (instead of the
    default interactive mode). The `-o +%MEM` option parameter indicates the additional
    (`+`) sorting field (`%MEM`) in tandem with the default `%CPU` field. The `head
    -n 17` pipe selects the first 17 lines of the output, accounting for the seven-line
    header of the `top` command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The top 10 processes sorted by CPU and memory usage](img/Figure_05_18_B19682.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The top 10 processes sorted by CPU and memory usage
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists the top five processes by CPU usage, owned by the
    current user (`packt`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-u $(whoami)` option parameter specifies the current user for the `top`
    command.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `top` command, we can also monitor specific processes using the `-p`
    PID option parameter. For example, the following command monitors our test process
    (with PID `243436`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Monitoring a specific PID with the top command](img/Figure_05_19_B19682.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Monitoring a specific PID with the top command
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We may choose to *kill* the process by pressing *K* while using the `top` command.
    We’ll get prompted for this by the PID of the process we want to terminate:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Killing a process with the top command](img/Figure_05_20_B19682.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Killing a process with the top command
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The `top` utility can be used in many creative ways. We hope that the examples
    we’ve provided in this section have inspired you to explore further use cases
    based on specific needs. For more information, please refer to the system reference
    manual for the `top` command (`man top`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Using the kill and killall commands
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `kill` command to terminate processes. The command’s syntax is as
    follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `kill` command sends a *signal* to a process, attempting to stop its execution.
    When no signal is specified, `SIGTERM` (`15`) is sent. A signal can either be
    specified by the signal’s name without the `SIG` prefix (for example, `KILL` for
    `SIGKILL`) or by value (for example, `9` for `SIGKILL`).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill -l` and `kill -L` commands provide a full list of signals that can
    be used in Linux:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – The Linux signals](img/Figure_05_21_B19682.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – The Linux signals
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Each signal has a numeric value, as shown in the preceding output. For example,
    `SIGKILL` equals `9`. The following command will kill our test process (with PID
    `243436`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following command will also do the same as the preceding command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In some scenarios, we may want to kill multiple processes in one go. The `killall`
    command comes to the rescue here. The syntax for the `killall` command is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`killall` sends a signal to all the processes running any of the commands specified.
    When no signal is specified, `SIGTERM` (`15`) is sent. A signal can either be
    specified by the signal name without the `SIG` prefix (for example, `TERM` for
    `SIGTERM`) or by value (for example, `15` for `SIGTERM`).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command terminates all the processes running the
    `test.sh` script:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Terminating multiple processes with killall](img/Figure_05_22_B19682.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Terminating multiple processes with killall
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Killing a process will usually remove the related reference from the system
    process table. The terminated process won’t show up anymore in the output of `ps`,
    `top`, or similar commands.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `kill` and `killall` commands, please refer to
    the related system reference manuals (`man kill` and `man killall`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Using the pgrep and pkill commands
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pgrep` and `pkill` are pattern-based lookup commands for exploring and terminating
    running processes. They have the following syntax:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`pgrep` iterates through the current processes and lists the PIDs that match
    the selection pattern or criteria. Similarly, `pkill` terminates the processes
    that match the selection criteria.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command looks for our test process (`test.sh`) and displays the
    `PID` value if the related process is found. Start the process again before using
    the following command as we killed it in the previous section. This will lead
    to a different `PID` value:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Looking for a PID based on name using pgrep](img/Figure_05_23_B19682.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Looking for a PID based on name using pgrep
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-f|--full` option enforces a full name match of the process we’re looking
    for. We may use `pgrep` in tandem with the `ps` command to get more detailed information
    about the process, like so:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Chaining pgrep and ps for more information](img/Figure_05_24_B19682.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Chaining pgrep and ps for more information
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding one-liner, we piped the output of the `pgrep` command (with
    PID `243436`) to the `ps` command, which has been invoked with the `-f` (long-format)
    and `-p|--pid` options. The `-p` option parameter gets the piped PID value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The `xargs` command takes the input from the `pgrep` command and converts it
    into an argument for the `ps` command. Thus, when piping from `pgrep` to `ps`,
    the output of the first command was automatically converted as the argument for
    the second command. By default, `xargs` reads the standard input.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'To terminate our `test.sh` process, we simply invoke the `pkill` command, as
    follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding command will *silently* kill the related process, based on the
    full name lookup enforced by the -`f|--full` option. To get some feedback from
    the action of the `pkill` command, we need to invoke the `-e|--echo` option, like
    so:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output of the preceding command can be seen in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Killing a process by name using pkill](img/Figure_05_25_B19682.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Killing a process by name using pkill
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: For more information, please refer to the `pgrep` and `pkill` system reference
    manuals (`man pgrep` and `man pkill`).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: This section covered some command-line utilities that are frequently used in
    everyday Linux administration tasks involving processes. Keep in mind that in
    Linux, most of the time, there are many ways to accomplish a specific task. We
    hope that the examples in this section will help you come up with creative methods
    and techniques for working with processes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at some common ways of interacting with daemons.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Working with daemons
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted in the introductory sections, daemons are a special breed of background
    process. Consequently, the vast majority of methods and techniques for working
    with processes also apply to daemons. However, there are specific commands that
    strictly operate on daemons when it comes to managing (or controlling) the lifetime
    of the related processes.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the *Introducing daemons* section, daemon processes are controlled
    by shell scripts, usually stored in the `/etc/init.d/` or `/lib/systemd/` system
    directories, depending on the Linux platform. On legacy Linux systems (for example,
    RHEL 6) and Ubuntu (even in the latest distros), the daemon script files are stored
    in `/etc/init.d/`. On RHEL 7/Ubuntu 18.04 and newer platforms, they are typically
    stored in `/lib/systemd/`. Feel free to do a listing of those two directories
    to see the contents.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The location of the daemon files and the daemon command-line utilities largely
    depends on the `init` initialization system and service manager. In *The init
    process* section, we briefly mentioned a variety of `init` systems across Linux
    distributions. To illustrate the use of daemon control commands, we will explore
    the `init` system called `systemd`, which is extensively used across various Linux
    platforms.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Working with systemd daemons
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `init` system’s essential requirement is to initialize and orchestrate the
    launch and startup dependencies of various processes when the Linux kernel is
    booted. These processes are also known as `init` engine also controls the services
    and daemons while the system is running.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Over the last few years, most Linux platforms have transitioned to `systemd`
    as their default `init` engine. Due to its extensive adoption, being familiar
    with `systemd` and its related command-line tools is of paramount importance.
    With that in mind, this section’s primary focus is on `systemctl` – the central
    command-line utility for managing `systemd` daemons.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `systemctl` command is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The actions that are invoked by the `systemctl` command are directed at units,
    which are system resources that are managed by `systemd`. Several unit types are
    defined in `systemd` (for example, service, mount, socket, and so on). Each of
    these units has a corresponding file. These file types are inferred from the suffix
    of the related filename; for example, `httpd.service` is the service unit file
    of the Apache web service (daemon). For a comprehensive list of `systemd` units
    and detailed descriptions of them, please refer to the `systemd.unit` system reference
    manual (`man systemd.unit`).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command enables a daemon (for example, `httpd`, the web server)
    to start at boot:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Typically, invoking `systemctl` commands requires superuser privileges. We
    should note that `systemctl` does not require the `.service` suffix when we’re
    targeting service units. The following invocation is also acceptable:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The command to disable the `httpd` service from starting at boot is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To query the status of the `httpd` service, we can run the following command:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, we can check the status of the `httpd` service with the following
    command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following commands stop or start the `httpd` service:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information on `systemctl`, please refer to the related system reference
    manual (`man systemctl`). For more information about `systemd` internals, please
    refer to the corresponding reference manual (`man systemd`).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Working with processes and daemons is a constant theme of everyday Linux administration
    tasks. Mastering the related command-line utilities is an essential skill for
    any seasoned user. Yet, a running process or daemon should also be considered
    in relationships with other processes or daemons running either locally or on
    remote systems. The way processes communicate with each other could be a slight
    mystery to some. We will address this in the next section, in which we will explain
    how inter-process communication works.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Explaining inter-process communication
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inter-process communication** (**IPC**) is a way of interacting between processes
    using a shared mechanism or interface. In this section, we will take a short theoretical
    approach to exploring various communication mechanisms between processes. For
    more details on this matter and some of the mechanisms used, head to [*Chapter
    8*](B19682_08.xhtml#_idTextAnchor164), *Linux* *Shell Scripting*.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux processes can typically share data and synchronize their actions via
    the following interfaces:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared storage** (**files**): In its simplest form, the shared storage of
    an IPC mechanism can be a simple file that’s been saved to disk. The producer
    then writes to a file while the consumer reads from the same file. In this simple
    use case, the obvious challenge is the integrity of the read/write operations
    due to possible race conditions between the underlying operations. To avoid race
    conditions, the file must be locked during write operations to prevent overlapping
    I/O with another read or write action. To keep things simple, we’re not going
    to resolve this problem in our naive examples, but we thought it’s worth calling
    it out.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev/shm` temporary file storage system, which uses the system’s RAM as its
    backing store (that is, RAM disk).'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `/dev/shm` being used as shared memory, we can reuse our producer-consumer
    model from the example in the previous point on *Shared storage*, where we simply
    point the storage file to `/dev/shm/storage`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The shared memory and shared storage IPC models may not perform well with large
    amounts of data, especially massive data streams. The alternative would be to
    use IPC channels, which can be enabled through the pipe, message queue, or socket
    communication layers.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Named and unnamed pipes**: **Unnamed** or **anonymous pipes**, also known
    as **regular pipes**, feed the output of a process to the input of another one.
    Using our producer-consumer model, the simplest way to illustrate an unnamed pipe
    as an IPC mechanism between the two processes would be to do the following:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The key element of the preceding code is the pipe (`|`) symbol. The left-hand
    side of the pipe produces an output that’s fed directly to the right-hand side
    of the pipe for consumption.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '**Named pipes**, also known as **First-In, First-Outs** (**FIFOs**), are similar
    to traditional (unnamed) pipes but substantially different in terms of their semantics.
    An unnamed pipe only persists for as long as the related process is running. However,
    a named pipe has backing storage and will last as long as the system is up, regardless
    of the running status of the processes attached to the related IPC channel. Typically,
    a named pipe acts as a file, and it can be deleted when it’s no longer being used.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '**Message queues**: A message queue is an asynchronous communication mechanism
    that’s typically used in a distributed system architecture. Messages are written
    and stored in a queue until they are processed and eventually deleted. A message
    is written (published) by a producer and is processed only once, typically by
    a single consumer. At a very high level, a message has a sequence, a payload,
    and a type. Message queues can regulate the retrieval (order) of messages (for
    example, based on priority or type):'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_05_26_B19682.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – Message queue (simplified view)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: A detailed analysis of message queues or a mock implementation thereof is far
    from trivial, and it’s beyond this chapter’s scope. There are numerous open source
    message queue implementations available for most Linux platforms (RabbitMQ, ActiveMQ,
    ZeroMQ, MQTT, and so on).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: IPC mechanisms based on message queues and pipes are unidirectional. One process
    writes the data; another one reads it. There are bidirectional implementations
    of named pipes, but the complexities involved would negatively impact the underlying
    communication layer. For bidirectional communication, you can think of using socket-based
    IPC channels (detailed in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), *Linux*
    *Shell Scripting*).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**Sockets**: There are two types of IPC socket-based facilities:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPC sockets**: Also known as Unix domain sockets, IPC sockets use a local
    file as a socket address and enable bidirectional communication between processes
    on the same host.'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network sockets**: **Transport Control Protocol** (**TCP**) and **User Datagram
    Protocol** (**UDP**) sockets. They extend the IPC data connectivity layer beyond
    the local machine via TCP/UDP networking.'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the obvious implementation differences, the IPC socket’s and network
    socket’s data communication channels behave the same.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Both sockets are configured as streams, support bidirectional communication,
    and emulate a client/server pattern. The socket’s communication channel is active
    until it’s closed on either end, thereby breaking the IPC connection.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '**Signals**: In Linux, a signal is a one-way asynchronous notification mechanism
    that’s used in response to a specific condition. A signal can act in any of the
    following directions:'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the Linux kernel to an arbitrary process
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From process to process
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From a process to itself
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We mentioned at the beginning of this section that signals are yet another IPC
    mechanism. Indeed, they are a somewhat limited form of IPC in the sense that through
    signals, processes can coordinate synchronization with each other. But signals
    don’t carry any data payloads. They simply notify processes about events, and
    processes may choose to take specific actions in response to these events.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will detail working with signals in Linux.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Working with signals
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signals typically alert a Linux process about a specific event, such as a segmentation
    fault (`SIGSEGV`) that’s raised by the kernel or execution being interrupted (`SIGINT`)
    by the user pressing *Ctrl* + *C*. In Linux, processes are controlled via signals.
    The Linux kernel defines a few dozen signals. Each signal has a corresponding
    non-zero positive integer value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command lists all the signals that have been registered in a
    Linux system:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The output of the preceding command can be seen back in *Figure 5**.21*. From
    the output, `SIGHUP`, for example, has a signal value of `1`, and it’s invoked
    by a Terminal session to all its child processes when it exits. `SIGKILL` has
    a signal value of `9` and is most commonly used for terminating processes. Processes
    can typically control how signals are handled, except for `SIGKILL` (`9`) and
    `SIGSTOP` (`19`), which always end or stop a process, respectively.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes handle signals in either of the following fashions:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Perform the default action implied by the signal; for example, stop, terminate,
    core-dump a process, or do nothing.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a custom action (except for `SIGKILL` and `SIGSTOP`). In this case,
    the process catches the signal and handles it in a specific way.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a program implements a custom handler for a signal, it usually defines
    a signal handler function that alters the execution of the process, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: When the signal is received, the process’ execution is interrupted at the current
    instruction
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process’ execution immediately jumps to the signal-handler function
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal handler function runs
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the signal handler function exits, the process resumes execution, starting
    from the previously interrupted instruction
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s some brief terminology related to signals:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: A signal is raised by the process that generates it
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signal is caught by the process that handles it
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signal is ignored if the process has a corresponding **no-operation** or **no-op**
    (**NOOP**) handler
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A signal is handled if the process implements a specific action when the signal
    is caught
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of all the signals, `SIGKILL` and `SIGSTOP` are the only ones that cannot
    be caught or ignored.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore a few use cases for handling signals:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: When the kernel raises a `SIGKILL`, `SIGFPE` (floating-point exception), `SIGSEGV`
    (segmentation fault), `SIGTERM`, or similar signals, typically, the process that
    receives the signal immediately terminates execution and may generate a core dump
    – the image of the process that’s used for debugging purposes.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a user types *Ctrl* + *C* – otherwise known as an `SIGINT` signal is sent
    to the process. The process will terminate unless the underlying program implements
    a special handler for `SIGINT`.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `kill` command, we can send a signal to any process based on its
    PID. The following command sends a `SIGHUP` signal to a Terminal session with
    a PID of `3741`:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding command, we can either specify the signal value (for example,
    `1` for `SIGHUP`) or just the signal name without the `SIG` prefix (for example,
    `HUP` for `SIGHUP`).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'With `killall`, we can signal that multiple processes are running a specific
    command (for example, `test.sh`). The following command terminates all processes
    running the `test.sh` script and outputs the result to the console (via the `-``e`
    option):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The output of this command can be seen in *Figure 5**.22*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Linux processes and signals are a vast domain. The information we’ve provided
    here is far from a comprehensive guide on the topic. We hope that this short spin
    and hands-on approach to presenting some common use cases has inspired you to
    take on and possibly master more challenging issues.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed study of Linux processes and daemons could be a major undertaking.
    Where worthy volumes on the topic have admirably succeeded, a relatively brief
    chapter may pale in comparison. Yet in this chapter, we tried to put on a real-world,
    down-to-earth, practical coat on everything we’ve considered to make up for our
    possible shortcomings in the abstract or scholarly realm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we hope you are comfortable working with processes and daemons.
    The skills you’ve gathered so far should include a relatively good grasp of process
    types and internals, with a reasonable understanding of process attributes and
    states. Special attention has been paid to inter-process communication mechanisms,
    and signals in particular. For each of these topics, we will take a more detailed
    approach in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164). For now, we consider
    the information we’ve provided to be sufficient for understanding how inter-process
    communication works.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will take our journey further into working with Linux disks
    and filesystems. We’ll explore the Linux storage, disk partitioning, and **Logical
    Volume Management** (**LVM**) concepts. Rest assured that everything we’ve learned
    so far will be immediately put to good use in the chapters that follow.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you managed to skim through some parts of this chapter, you might want to
    recap a few essential details about Linux processes and daemons:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Think of a few process types. How would they compare to each other?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think of the anatomy of a process. Can you come up with a few essential process
    attributes (or fields in the `ps` command-line output) that you may look for when
    inspecting processes?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: What would be relevant for you, except CPU, RAM, or disk usage, for
    example?'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of a few process states and some of the dynamics or possible transitions
    between them?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are looking for a process that takes up most of the CPU on your system,
    how would you proceed?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you write a simple script and make it a long-lived background process?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Take a peek at [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), where
    we will teach you how to create and use shell scripts.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate at least four process signals that you can think of. When or how would
    those signals be invoked?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kill -l` command. For more information, read the manual.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Think of a couple of IPC mechanisms. Try to come up with some pros and cons
    for them.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: The information in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164)
    could help you.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, you can refer
    to the following Packt titles:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Administration Best Practices*, by Scott Alan Miller'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Service Management Made Easy with systemd*, by Donald A. Tevault'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 2:Advanced Linux Administration
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this second part, you will learn about advanced Linux system administration
    tasks, including working with disks and configuring networking, hardening Linux
    security, and system-specific troubleshooting and diagnostics.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19682_06.xhtml#_idTextAnchor124), *Working with Disks and Filesystems*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19682_07.xhtml#_idTextAnchor139), *Networking with Linux*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), *Linux Shell Scripting*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19682_09.xhtml#_idTextAnchor194), *Securing Linux*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19682_10.xhtml#_idTextAnchor212), *Disaster Recovery, Diagnostics,
    and Troubleshooting*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
