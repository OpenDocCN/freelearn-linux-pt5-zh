- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Securing** a Linux machine is usually a balancing act. The endgame is essentially
    protecting data from unwanted access. While there are many ways to achieve this
    goal, we should adopt the methods that yield maximum protection, along with the
    most efficient system administration. Gauging the attack and vulnerability surfaces,
    both internal and external, is always a good start. The rest of the work is building
    fences and putting on armor—not too high and not too heavy. The outer fence is
    a **network firewall**. Internally, at the system level, we build **application
    security policies**. This chapter introduces both, albeit the art of the balancing
    act is left to you.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this chapter, we’ll look at **access control mechanisms**
    (**ACMs**) and the related security modules—**Security-Enhanced Linux** (**SELinux**)
    and **AppArmor**. In the second part, we will explore packet filtering frameworks
    and firewall solutions.
  prefs: []
  type: TYPE_NORMAL
- en: After completing this chapter, you will have become acquainted with the tools
    for designing and managing application security frameworks and firewalls—a first
    solid step to securing a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief overview of the topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux security—An overview of the ACMs available in the Linux
    kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing SELinux—An in-depth look at the Linux kernel security framework
    for managing access control policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing AppArmor—A relatively new security module that controls application
    capabilities based on security profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with firewalls—A comprehensive overview of firewall modules, including
    `iptables`, `nftables`, `firewalld`, and the `ufw`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers a relatively vast array of topics, some of which will be
    covered with extensive command-line operations. We recommend that you use both
    a Fedora and an Ubuntu platform with Terminal or SSH access. Direct console access
    to the systems is highly preferable due to the possibly disruptive way of altering
    firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One significant consideration for securing a computer system or network is
    the means for system administrators to control how users and processes can access
    various resources, such as files, devices, and interfaces, across systems. The
    Linux kernel provides a handful of such mechanisms, collectively referred to as
    ACMs. Let’s describe them briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discretionary access control** (**DAC**) is the typical ACM related to filesystem
    objects, including files, directories, and devices. Such access is at the discretion
    of the object’s owner when managing permissions. DAC controls access to *objects*
    based on the identity of users and groups (*subjects*). Depending on a subject’s
    access permissions, they could also pass permissions to other subjects —an administrator
    managing regular users, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access control lists** (**ACLs**) provide control over which subjects (such
    as users and groups) have access to specific filesystem objects (such as files
    and directories).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mandatory access control** (**MAC**) provides different access control levels
    to subjects over the objects they own. Unlike DAC, where users have full control
    over the filesystem objects they own, MAC adds additional labels, or categories,
    to all filesystem objects. Consequently, subjects must have the appropriate access
    to these categories to interact with the objects labeled as such. MAC is enforced
    by *SELinux* on **Red Hat Enterprise Linux** (**RHEL**)/Fedora and *AppArmor*
    on Ubuntu/Debian/openSUSE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Role-based access control** (**RBAC**) is an alternative to the permission-based
    access control of filesystem objects. Instead of permissions, a system administrator
    assigns *roles* that have access to a specific filesystem object. Roles could
    be based on some business or functional criteria and may have different access
    levels to objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In contrast to DAC or MAC, where subjects have access to objects based strictly
    on the permissions involved, the RBAC model represents a logical abstraction over
    MAC or DAC, where the subjects must be members of a specific group or role before
    interacting with objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Multi-level security** (**MLS**) is a specific MAC scheme where the *subjects*
    are processes and the *objects* are files, sockets, and other similar system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-category security** (**MCS**) is an improved version of SELinux that
    allows users to label files with *categories*. MCS reuses much of the MLS framework
    in SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping up our brief discussion on ACMs, we should note that we covered some
    of the internals of DAC and ACL in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing Users and Groups*, particularly in the *Managing* *permissions* section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll turn our attention to SELinux—a first-class citizen for MAC implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SELinux** is a security framework in the Linux kernel for managing the access
    control policies of system resources. It supports a combination of the MAC, RBAC,
    and MLS models that were described in the previous section. SELinux is a set of
    kernel-space security modules and user-space command-line utilities, and it provides
    a mechanism for system administrators to have control over *who* can access *what*
    on the system. SELinux is designed to also protect a system against possible misconfigurations
    and potentially compromised processes.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux was introduced by the **National Security Agency** (**NSA**) as a collection
    of **Linux Security Modules** (**LSM**) with kernel updates. SELinux was eventually
    released to the open source community in 2000 and became part of Linux starting
    with the 2.6 kernel series in 2003.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does SELinux work? We’ll look at this in the next section. We will use
    Fedora 37 Server Edition for all our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SELinux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SELinux uses **security policies** to define various access control levels for
    applications, processes, and files on a system. A security policy is a set of
    rules describing what can or cannot be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux operates with **subjects** and **objects**. When a specific application
    or process (the *subject*) requests access to a file (the *object*), SELinux checks
    the required permissions involved in the request and enforces the related access
    control. The permissions for subjects and objects are stored in a lookup table
    known as the **Access Vector Cache** (**AVC**). The AVC is generated based on
    the **SELinux** **policy database**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical SELinux policy consists of the following resources (files), each
    reflecting a specific aspect of the security policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type enforcement**: Actions that have been granted or denied for the policy
    (such as read or write access to a file)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: The application interface the policy interacts with (such as
    logging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File contexts**: The system resources associated with the policy (such as
    log files)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These policy files are compiled together using SELinux build tools to produce
    a specific **security policy**. The policy is loaded into the kernel, added to
    the SELinux policy database, and made active without a system reboot.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating SELinux policies, we usually test them in *permissive* mode first,
    where violations are logged but still allowed. When violations occur, the `audit2allow`
    utility in the SELinux toolset comes to the rescue. We use the log traces produced
    by `audit2allow` to create additional rules required by the policy to account
    for legitimate access permissions. SELinux violations are logged in `/var/log/messages`
    and are prefixed with `avc: denied`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we learn how to create and manage a SELinux security policy, let’s look
    at some higher-level operations for managing and controlling SELinux in everyday
    administration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SELinux modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SELinux is either *enabled* or *disabled* in a system. When enabled, it operates
    in either of the following modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enforcing`: SELinux effectively monitors and controls security policies. In
    RHEL/Fedora, this mode is enabled by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permissive`: Security policies are actively monitored without enforcing access
    control. Policy violations are logged in `/var/log/messages`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When SELinux is disabled, security policies are neither monitored nor enforced.
    The following command retrieves the current status of SELinux on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Getting the current status of SELinux](img/B19682_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Getting the current status of SELinux
  prefs: []
  type: TYPE_NORMAL
- en: 'When SELinux is enabled, the following command retrieves the current mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In `permissive` mode, we get the `enforcing` output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change from `enforcing` to `permissive` mode, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getenforce` command will display `permissive` in this case. To switch
    back into `enforcing` mode, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The SELinux mode can also be set by editing the `SELINUX` value in `/etc/selinux/config`.
    Possible values are documented in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Manually editing the SELinux configuration file requires a system reboot for
    changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With SELinux enabled, a system administrator may choose between the following
    SELinux policy levels by modifying the `SELINUXTYPE` value in `/etc/selinux/config`:
    `targeted`, `minimum`, and `mls`. The corresponding values are documented in the
    configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The default SELinux policy setting is `targeted`, and it’s generally recommended
    not to change this setting, except for `mls`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `targeted` policy in place, only processes that are specifically configured
    to use SELinux security policies can run in a *confined* (or restricted) domain.
    Such processes usually include system daemons (such as `dhcpd` and `sshd`) and
    well-known server applications (such as Apache and PostgreSQL). All other (non-targeted)
    processes run unrestricted and are usually labeled with the `unconfined_t` domain
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To completely disable SELinux, we can edit the `/etc/selinux/config` file using
    a text editor of our choice (such as `sudo nano /etc/selinux/config`) and make
    the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can run the following command to change the SELinux mode
    from `enforcing` to `disabled`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the current configuration with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With SELinux disabled, we get the following output (excerpt):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Disabling SELinux](img/B19682_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Disabling SELinux
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to reboot the system for changes to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s examine how access control decisions are made by introducing **SELinux
    contexts**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SELinux contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With SELinux enabled, processes and files are labeled with a **context** containing
    additional SELinux-specific information, such as *user*, *role*, *type*, and *level*
    (optional). The context data serves for SELinux access control decisions.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux adds the `-Z` option to the `ls`, `ps`, and other commands, thus displaying
    the security context of filesystem objects, processes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an arbitrary file and examine the related SELinux context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Displaying the SELinux context of a file](img/B19682_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Displaying the SELinux context of a file
  prefs: []
  type: TYPE_NORMAL
- en: 'The SELinux context has the following format—a sequence of four fields, separated
    by a colon (`:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at the SELinux context fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`semanage` utility is available with the `policycoreutils` package, which you
    may need to install on your system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command yields the following output. The output may differ slightly from
    system to system:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Displaying the SELinux user mappings](img/B19682_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Displaying the SELinux user mappings
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `semanage` command-line utility, you may refer to
    the related system reference (`man semanage`, `man semanage-login`).
  prefs: []
  type: TYPE_NORMAL
- en: '**SELinux roles**: SELinux roles are part of the RBAC security model, and they
    are essentially RBAC attributes. In the SELinux context hierarchy, users are authorized
    for roles, and roles are authorized for types or domains. In the SELinux context
    terminology, **types** refer to filesystem object types and **domains** refer
    to process types (see more under *SELinux type* in this list).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take Linux processes, for example. The SELinux role serves as an intermediary
    access layer between domains and SELinux users. An *accessible* role determines
    which domain (that is, processes) can be accessed through that role. Ultimately,
    this mechanism controls which object types can be accessed by the process, thus
    minimizing the surface for privilege escalation attacks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SELinux type**: The SELinux type is an attribute of SELinux *type enforcement*—a
    MAC security construct. For SELinux types, we refer to domains as process types
    and types as filesystem object types. SELinux security policies control how specific
    types can access each other—either with domain-to-type access or domain-to-domain
    interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unclassified`, `confidential`, `secret`, and `top-secret` and are expressed
    as a `low-high` if the levels differ or just `low` if the levels are identical.
    For example, a level of `s0-s0` is the same as `s0`. Each level represents a *sensitivity-category*
    pair, with categories being optional. When a category is specified, the level
    is defined as `sensitivity:category-set`; otherwise, it’s defined as `sensitivity`
    only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are now familiar with SELinux contexts. We’ll see them in action, starting
    with the SELinux contexts for users, next.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux contexts for users
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following command displays the SELinux context associated with the current
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Displaying the current user’s SELinux context](img/B19682_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Displaying the current user’s SELinux context
  prefs: []
  type: TYPE_NORMAL
- en: 'In RHEL/Fedora, Linux users are `unconfined` (unrestricted) by default, with
    the following context fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unconfined_u`: User identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unconfined_r`: Role'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unconfined_t`: Domain affinity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s0-s0`: MLS range (the equivalent of `s0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c0.c1023`: Category set, representing all categories (from `c0` to `c1023`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll examine the SELinux context for processes.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux contexts for processes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following command displays the SELinux context for current SSH processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The command yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Displaying the SELinux context for SSH-related processes](img/B19682_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Displaying the SELinux context for SSH-related processes
  prefs: []
  type: TYPE_NORMAL
- en: From the output, we can infer that the first line refers to the `sshd` server
    process, which is running with the `system_u` user identity, `system_r` role,
    and `sshd_t` domain affinity. The second line refers to the current user’s SSH
    session, hence the `unconfined` context. System daemons are usually associated
    with the `system_u` user and `system_r` role.
  prefs: []
  type: TYPE_NORMAL
- en: Before concluding this section on SELinux contexts, we’ll examine the relatively
    common scenario of SELinux domain transitions, which is where a process in one
    domain accesses an object (or process) in a different domain.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux domain transitions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Assuming an SELinux-secured process in one domain requests access to an object
    (or another process) in a different domain, SELinux **domain transitions** come
    into play. Unless there’s a specific security policy allowing the related domain
    transition, SELinux would deny access.
  prefs: []
  type: TYPE_NORMAL
- en: An SELinux-protected process transitioning from one domain into another invokes
    the `entrypoint` type of the new domain. SELinux evaluates the related entrypoint
    permission and decides if the soliciting process can enter the new domain.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate a domain transition scenario, we will take the simple case of
    using the `passwd` utility when users change their password. The related operation
    involves the interaction between the `passwd` process and the `/etc/shadow` (and
    possibly `/etc/gshadow`) file(s). When the user enters (and reenters) the password,
    `passwd` would hash and store the user’s password in `/etc/shadow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the SELinux domain affinities involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Comparing the domain affinity context](img/B19682_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Comparing the domain affinity context
  prefs: []
  type: TYPE_NORMAL
- en: The `passwd` utility is labeled with the `passwd_exec_t` type, while `/etc/shadow`
    is labeled with `shadow_t`. There must be a specific security policy chain that
    allows the related domain to transition from `passwd_exec_t` to `shadow_t`; otherwise,
    `passwd` will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s validate our assumption. We’ll use the `sesearch` tool to query for our
    assumed security policy. The command utility is not installed by default on Fedora,
    so you will have to install the `setools-console` package first. Use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the package is installed, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief explanation of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sesearch`: Searches the SELinux policy database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s passwd_t`: Finds policy rules with `passwd_t` as their source type or role'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t shadow_t`: Finds policy rules with `shadow_t` as their target type or role'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p write`: Finds policy rules with `write` permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--allow`: Finds policy rules that allow the queried permissions (specified
    with `-p`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Querying SELinux policies](img/B19682_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Querying SELinux policies
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the `append create` permissions, as we correctly assumed.
  prefs: []
  type: TYPE_NORMAL
- en: How did we pick the `passwd_t` source type instead of `passwd_exec_t`? By definition,
    the *domain* type corresponding to the *executable file* type, `passwd_exec_t`,
    is `passwd_t`. If we were not sure about *who* has write permissions to the `shadow_t`
    file types, we could have simply excluded the source type (`-s passwd_t`) in the
    `sesearch` query and parsed the output (for example, using `grep passwd`).
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `sesearch` tool is very convenient when we’re querying security
    policies. There are a handful of similar tools for troubleshooting or managing
    the SELinux configuration and policies. One of the most notable SELinux command-line
    utilities is `semanage` for managing SELinux policies. We’ll examine this in the
    *Managing SELinux policies* section. But first, let’s look at the necessary steps
    for creating an SELinux security policy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an SELinux security policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For the examples in this section, we will use a program developed in the C
    programming language. This means that we will have to compile it, which is different
    than what we did in the previous chapter. In order to be able to compile C code,
    we will need to have the `gcc` on our Fedora system with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s assume that we have a daemon called `packtd` and that we need to
    secure it to access `/var/log/messages`. For illustration purposes, the daemon
    has a straightforward implementation: periodically open the `/var/log/messages`
    file for writing. Use your favorite text editor (such as `nano`) to add the following
    content (C code) to a file. Let’s name the file `packtd.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – A simple daemon periodically checking logs](img/B19682_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – A simple daemon periodically checking logs
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compile and build `packtd.c` to generate the related binary executable
    (`packtd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of the command used to compile the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Compiling the C source code](img/B19682_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Compiling the C source code
  prefs: []
  type: TYPE_NORMAL
- en: Now that the source code has been compiled, we are ready to proceed with the
    steps for creating the `packtd` daemon and the required SELinux security policy.
    This exercise is equally useful for SELinux administration and for creating a
    `systemd` daemon. Please refer to [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104)
    if you need to refresh your memory on daemons. Now, let’s discuss the steps for
    creating a daemon and a security policy.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the daemon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we must create a `systemd` unit file for the `packtd` daemon. You may
    use your favorite text editor (such as `nano`) to create the related file. We
    will call this file `packtd.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The packtd daemon file](img/B19682_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – The packtd daemon file
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the files we created to their respective locations, such as `/usr/local/bin`
    for `packtd` and `/usr/lib/systemd/system/` for `packtd.service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are ready to start our `packtd` daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make sure the `packtd` daemon is not confined or restricted yet by SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `-Z` option parameter of `ps` retrieves the SELinux context for processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of all these commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Running status and confinement status of the packtd daemon](img/B19682_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Running status and confinement status of the packtd daemon
  prefs: []
  type: TYPE_NORMAL
- en: The `unconfined_service_t` security attribute suggests that `packtd` is not
    restricted by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will generate security policy files for the `packtd` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Generating policy files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To build a security policy for `packtd`, we need to generate the related policy
    files. The SELinux tool for building security policies is `sepolicy`. Also, packaging
    the final security policy binary requires the `rpm-build` utility. These command-line
    utilities may not be available by default on your system, so you may have to install
    the related packages using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the next command to generate policy files for `packtd` (no superuser
    privileges required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Generating policy files with sepolicy](img/B19682_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Generating policy files with sepolicy
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment and look over the preceding screenshot. You will see that *five
    new files* have been created in your home directory. Keep this in mind, as we
    will use them during our setup process. Next, we need to rebuild the system policy
    so that it includes the custom `packtd` policy module.
  prefs: []
  type: TYPE_NORMAL
- en: Building the security policy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To build the security policy, we will now use the `packtd.sh` build script
    that was created in the previous step (see *Figure 9**.13* for details). The following
    command requires superuser privileges since it installs the newly created policy
    on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The build takes a relatively long time to complete and yields the following
    output (excerpt):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Building the security policy for packtd](img/B19682_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Building the security policy for packtd
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the build script reinstates the default *SELinux* security
    context for `packtd` using the `restorecon` command (highlighted in the previous
    output). Now that we’ve built the security policy, we’re ready to verify the related
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the security policy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, we need to restart the `packtd` daemon to account for the policy change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `packtd` process should now reflect the new SELinux security context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows a new label (`packtd_t`) for our security context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – The new security policy for packtd](img/B19682_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – The new security policy for packtd
  prefs: []
  type: TYPE_NORMAL
- en: 'Since SELinux now controls our `packtd` daemon, we should see the related audit
    traces in `/var/log/messages`, where SELinux logs the system’s activity. Let’s
    look at the audit logs for any permission issues. The following command fetches
    the most recent events for `AVC` message types using the `ausearch` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will immediately notice that `packtd` has no read/write access to `/var/log/messages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – No read/write access for packtd](img/B19682_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – No read/write access for packtd
  prefs: []
  type: TYPE_NORMAL
- en: 'To further inquire about the permissions needed by `packtd`, we will feed the
    output of `ausearch` into `audit2allow`, a tool for generating the required security
    policy stubs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output provides the code macro we’re looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Querying the missing permissions for packtd](img/B19682_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Querying the missing permissions for packtd
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-R` (`--reference`) option of `audit2allow` invokes a stub generation
    task, which could sometimes yield inaccurate or incomplete results. In such cases,
    it may take a few iterations to update, rebuild, and verify the related security
    policies. Let’s proceed with the required changes, as suggested in the output
    shown in the preceding screenshot. We’ll edit the *type enforcement* file (`packtd.te`)
    generated previously and add the lines (copy/paste) exactly, as indicated by the
    output of `audit2allow`. The contents of the file are shown in the following screenshot
    (excerpt). The lines to be added by us are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Editing the packtd.te file](img/B19682_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Editing the packtd.te file
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving the file, we need to rebuild the security policy, restart the
    `packtd` daemon, and verify the audit logs. We’re reiterating the last three steps
    in our overall procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the SELinux audit should come out clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – No more permission issues for packtd](img/B19682_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – No more permission issues for packtd
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it may take a little while for `ausearch` to refresh its `recent`
    buffer. Alternatively, we can specify a starting timestamp to analyze from, such
    as after we’ve updated the security policy, using a relatively recent timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve created our own SELinux security policy, let’s understand how
    it can be managed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing SELinux policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SELinux provides several utilities for managing security policies and modules,
    some of which will be briefly described in the *Troubleshooting SELinux issues*
    section. Examining each of these tools is beyond the scope of this chapter, but
    we’ll take `semanage` for a quick spin to reflect on some use cases involving
    security policy management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of the `semanage` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`TARGET` usually denotes a specific namespace for policy definitions (for example,
    `login`, `user`, `port`, `fcontext`, `boolean`, `permissive`, and so on). Let’s
    look at a few examples to get an idea of how `semanage` works.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling secure binding on custom ports
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s assume we want to enable SELinux for a custom SSH port instead of the
    default `22`. We can retrieve the current security records (labels) on the SSH
    port with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For a default configuration, we will get the output shown in *line 2* in *Figure
    9**.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to enable SSH on a different port (such as `2222`), first, we need
    to configure the related service (`sshd`) to listen on a different port (shown
    in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276)). We won’t go into those details
    here. Here, we need to enable the secure binding on the new port with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief explanation of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-a` (`--add`): Adds a new record (label) for the given type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t ssh_port_t`: The SELinux type of the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p tcp`: The network protocol associated with the port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a result of the previous command and the output for the default configuration,
    the new security policy for the `ssh_port_t` type looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Querying and changing the SELinux security label for the SSH
    port](img/B19682_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Querying and changing the SELinux security label for the SSH port
  prefs: []
  type: TYPE_NORMAL
- en: 'We could arguably delete the old security label (for port `22`), but that won’t
    really matter if we disable port `22`. If we want to delete a port security record,
    we can do so with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `-d` (`--delete`) option to remove the related security label.
    To view the local customization for our `semanage port` policies, we can invoke
    the `-C` (`--``locallist`) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: For more information on `semanage port`, you may refer to the related system
    reference (`man semanage port`). Next, we’ll look at how to modify security permissions
    for specific server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying security permissions for targeted services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`semanage` uses the `boolean` namespace to toggle specific features of targeted
    services on and off. A targeted service is a daemon with built-in SELinux protection.
    In the following example, we want to enable FTP over HTTP connections. By default,
    this security feature of Apache (`httpd`) is turned off. Installation of the `httpd`
    server is shown in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276). Let’s query
    the related `httpd` security policies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Querying httpd policies related to FTP](img/B19682_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Querying httpd policies related to FTP
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the related feature—`httpd_enable_ftp_server`—is turned `off`
    by default. The `current` and `persisted` states are currently off: `(off, off)`.
    We can enable it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the local customizations of the `semanage boolean` policies, we can
    invoke the `-C` (`--``locallist`) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The new configuration now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Enabling the security policy for FTP over HTTP](img/B19682_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Enabling the security policy for FTP over HTTP
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `-m` (`--modify`) option with the `semanage
    boolean` command to toggle the `httpd_enable_ftp_server` feature.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `semanage boolean`, you may refer to the related system
    reference (`man semanage boolean`). Now, let’s learn how to modify the security
    context of specific server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying security contexts for targeted services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we want to secure SSH keys stored in a custom location on the
    local system. Since we’re targeting a filesystem-related security policy, we will
    use the `fcontext` (file context) namespace with `semanage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command queries the file context security settings for `sshd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a relevant excerpt from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – The security context of SSH keys](img/B19682_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – The security context of SSH keys
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command also adds the `/etc/ssh/keys/` path to the secure locations
    associated with the `sshd_key_t` context type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `''/etc/ssh/keys(/.*)?''` regular expression matches any files in the `/etc/ssh/keys/`
    directory, including subdirectories at any nested level. To view the local customizations
    of the `semanage fcontext` policies, we can invoke the `-C` (`--``locallist`)
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 9.24 – The modified security context of our SSH keys](img/B19682_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – The modified security context of our SSH keys
  prefs: []
  type: TYPE_NORMAL
- en: 'We should also initialize the filesystem security context of the `/etc/ssh/keys`
    directory (if we’ve already created it; otherwise, we would get an error message):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`restorecon` is an SELinux utility for restoring the default security context
    to a filesystem object. The `-r` (or `-R`) option specifies a recursive action
    on the related path.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `semanage fcontext`, you may refer to the related system
    reference (`man semanage fcontext`). Next, we’ll look at enabling the `permissive`
    mode of specific server applications.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling permissive mode for targeted services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier in this chapter, we created a custom daemon (`packtd`) with its security
    policy. See the related topic in the *Creating an SELinux security policy* section
    earlier in this chapter. During the entire process, we were able to run and test
    with `packtd` without having the daemon shut down by SELinux due to non-compliance.
    Our Linux system runs SELinux in `enforcing` mode (by default) and is not permissive.
    See the *Understanding SELinux modes* section for more information on `enforcing`
    and `permissive` modes.
  prefs: []
  type: TYPE_NORMAL
- en: By default, SELinux is permissive to any *untargeted* type in the system. By
    *untargeted*, we mean a domain (type) that hasn’t been forced into a restrictive
    (or confined) mode yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we built the security policy for our `packtd` daemon, we let the related
    SELinux build tools generate the default type enforcement file (`packt.te`) and
    other resources for our domain. A quick look at the `packt.te` file shows that
    our `packtd_t` type is `permissive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the relevant excerpt from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – The packtd_t domain is permissive](img/B19682_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – The packtd_t domain is permissive
  prefs: []
  type: TYPE_NORMAL
- en: So, the `packtd_t` domain is permissive by nature. The only way to confine `packtd`
    is to remove the `permissive` line from the `packtd.te` file and rebuild the related
    security policy. We will leave that as an exercise for you. The case we wanted
    to make here was to present a possibly misbehaving—in our case, `permissive`—domain
    that we can *catch* by managing `permissive` types with the `semanage` `permissive`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage `permissive` mode for individual targets, we can use the `semanage`
    command with our `permissive` namespace. The following command lists all the domains
    (types) currently in `permissive` mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we have the built-in `packtd_t` domain, which is `permissive`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Displaying permissive types](img/B19682_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Displaying permissive types
  prefs: []
  type: TYPE_NORMAL
- en: In general, it is unlikely that a default SELinux configuration would have any
    `permissive` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `semanage permissive` command to temporarily place a restricted
    domain into `permissive` mode while testing or troubleshooting a specific functionality.
    For example, the following command sets the Apache (`httpd`) daemon in `permissive`
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we query for `permissive` types, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Customized permissive types](img/B19682_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – Customized permissive types
  prefs: []
  type: TYPE_NORMAL
- en: Domains or types that are made permissive with the `semanage permissive` command
    will show up as `Customized` `Permissive Types`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To revert the `httpd_t` domain to the confined (restricted) state, we can invoke
    the `semanage permissive` command with the `-d` (`--``delete`) option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Reverting permissive types](img/B19682_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Reverting permissive types
  prefs: []
  type: TYPE_NORMAL
- en: Note that we cannot confine built-in `permissive` types with the `semanage`
    command. As we mentioned previously, the `packtd_t` domain is permissive by nature
    and cannot be restricted.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a basic understanding of SELinux security policy internals.
    Next, we’ll turn to some higher-level operations for managing and controlling
    SELinux in everyday administration tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting SELinux issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even during our relatively brief journey of exploring SELinux, we used a handful
    of tools and means to inspect some internal workings of security policies and
    access control between subjects (users and processes) and objects (files). SELinux’s
    problems usually come down to action being denied, either between specific subjects
    or between a subject and some objects. SELinux-related issues are not always obvious
    or easy to troubleshoot, but knowing about the tools that can help is already
    a good start for tackling these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of these tools, briefly explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/var/log/messages`: The log file containing SELinux access control traces
    and policy violations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audit2allow`: Generates SELinux policy rules from the log traces corresponding
    to denied operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`audit2why`: Provides user-friendly translations of SELinux audit messages
    of policy violations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ausearch`: Queries `/var/log/messages` for policy violations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -Z`: Lists filesystem objects with their corresponding SELinux context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps -Z`: Lists processes with their corresponding SELinux context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restorecon`: Restores the default SELinux context for filesystem objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seinfo`: Provides general information about SELinux security policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage`: Manages and provides insight into SELinux policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semodule`: Manages SELinux policy modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sepolicy`: Inspects SELinux policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sesearch`: Queries the SELinux policy database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most of these tools, there is a corresponding system reference (such as
    `man sesearch`) that provides detailed information about using the tool. Beyond
    these tools, you can also explore the vast documentation SELinux has to offer.
    Here’s how.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing SELinux documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SELinux has extensive documentation, available as an RHEL/Fedora installable
    package or online at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/using_selinux/index)
    (for RHEL 9).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command installs the SELinux documentation on RHEL 9 systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can browse a particular SELinux topic with (for example) the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: SELinux is among the most established and highly customizable security frameworks
    in the Linux kernel. However, its relatively vast domain and inherent complexity
    may appear overwhelming to many. Sometimes, even for seasoned system administrators,
    the choice of a Linux distribution could hang in the balance based on the underlying
    security module. SELinux is mostly available on RHEL/Fedora platforms, but it
    is also available as an option on **SUSE Linux Enterprise** (**SLE**). Google’s
    Android also has SELinux available, and Debian also has it as an available option.
    Another relatively lighter and more efficient security framework is **AppArmor**,
    and it is available by default on Ubuntu, Debian, and openSUSE. Let us explore
    it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AppArmor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AppArmor** is a Linux security module based on the MAC model that confines
    applications to a limited set of resources. AppArmor uses an access control mechanism
    based on security profiles that have been loaded into the Linux kernel. Each profile
    contains a collection of rules for accessing various system resources. AppArmor
    can be configured to either enforce access control or just complain about access
    control violations.'
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor proactively protects applications and operating system resources from
    internal and external threats, including zero-day attacks, by preventing both
    known and unknown vulnerabilities from being exploited.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor has been built into the mainline Linux kernel since version 2.6.36
    and is currently shipped with Ubuntu, Debian, openSUSE, and similar distributions.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections. we’ll use an Ubuntu Server 22.04 LTS environment
    to showcase a few practical examples with AppArmor. Most of the related command-line
    utilities will work the same on any platform with AppArmor installed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with AppArmor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AppArmor command-line utilities usually require superuser privileges. The following
    command checks the current status of AppArmor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an excerpt from the command’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Getting the status of AppArmor](img/B19682_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Getting the status of AppArmor
  prefs: []
  type: TYPE_NORMAL
- en: The `aa-status` (or `apparmor_status`) command provides a full list of the currently
    loaded AppArmor profiles (not shown in the preceding excerpt). We’ll examine AppArmor
    profiles next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing AppArmor profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With AppArmor, processes are confined (or restricted) by profiles. AppArmor
    profiles are loaded upon system start and run either in `enforce` mode or `complain`
    mode. Let’s explore these modes in some detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enforce` mode: AppArmor prevents applications running in `enforce` mode from
    performing restricted actions. Access violations are signaled with log entries
    in `syslog`. Ubuntu, by default, loads the application profiles in `enforce` mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complain` mode: Applications running in `complain` mode can take restricted
    actions, while AppArmor creates a log entry for the related violation. `complain`
    mode is ideal for testing AppArmor profiles. Potential errors or access violations
    can be caught and fixed before switching the profiles to `enforce` mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these introductory notes in mind, let’s create a simple application with
    an AppArmor profile.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a profile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we’ll create a simple application guarded by AppArmor. We hope
    this exercise will help you get a reasonable idea of the inner workings of AppArmor.
    Let’s name this application `appackt`. We’ll make it a simple script that creates
    a file, writes to it, and then deletes the file. The goal is to have AppArmor
    prevent our app from accessing any other paths in the local system. To try to
    make some sense of this, think of it as trivial log recycling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `appackt` script, and please pardon the thrifty implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.30 – The appackt script](img/B19682_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30 – The appackt script
  prefs: []
  type: TYPE_NORMAL
- en: 'We are assuming that the `log` directory already exists at the same location
    as the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.31 – The output of the appackt script](img/B19682_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31 – The output of the appackt script
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s work on guarding and enforcing our script with AppArmor. Before
    we start, we need to install the `apparmor-utils` package—the **AppArmor toolset**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use a couple of tools to help create the profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aa-genprof`: Generates an AppArmor security profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aa-logprof`: Updates an AppArmor security profile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `aa-genprof` to monitor our application at runtime and have AppArmor
    learn about it. In the process, we’ll be prompted to acknowledge and choose the
    behavior that’s required in specific circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Once the profile has been created, we’ll use the `aa-logprof` utility to make
    further adjustments while testing in `complain` mode, should any violations occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with `aa-genprof`. We need two terminals: one for the `aa-genprof`
    monitoring session (in *Terminal 1*) and the other for running our script (in
    *Terminal 2*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with *Terminal 1* and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a first prompt waiting for us. Next, while the prompt in *Terminal
    1* is waiting, we will switch to *Terminal 2* and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must go back to *Terminal 1* and answer the prompts sent by `aa-genprof`,
    as follows (output detailed in *Figure 9**.32*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`S` `(S)can`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/bin/touch`, `/usr/bin/date`, `/usr/bin/cat`, and `/usr/bin/rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This prompt requests execute permissions for all the processes running our app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Answer*: `I` `(I)nherit`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`/dev/tty`, `/home/packt/log/appackt`, and `/etc/ld.so.cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This prompt requests read/write permissions for the app to control different
    files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Answer*: `A` (`A)llow`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`S` (`S)ave`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Running aa-genprof and setting the profile](img/B19682_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32 – Running aa-genprof and setting the profile
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have finished scanning with `aa-genprof`, and we can answer
    the last prompt with `F` `(F)inish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Finishing the scanning](img/B19682_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33 – Finishing the scanning
  prefs: []
  type: TYPE_NORMAL
- en: Our app (`appackt`) is now enforced by AppArmor in `enforce` mode (by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of the steps, we only need one terminal window. Let’s run the
    `aa-logprof` command to further tune our `appackt` security profile if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We’ll get several prompts again, similar to the previous ones, asking for further
    permissions needed by our script or by other applications. The prompts alternate
    between `Inherit` and `Allow` answers, where appropriate. We won’t go into the
    details here as it is beyond the scope of this book. By now, you should have a
    general idea about these prompts and their meaning. It’s always recommended, though,
    to ponder upon the permissions asked and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We may have to run the `aa-logprof` command a couple of times because, with
    each iteration, new permissions will be discovered and addressed, depending on
    the child processes that are spawned by our script, and so on. Eventually, the
    `appackt` script will run successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the iterative process described previously, we may end up with a few
    unknown or orphaned entries in the AppArmor database, which are artifacts of our
    previous attempts to secure our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Remnants of the iterative process](img/B19682_09_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34 – Remnants of the iterative process
  prefs: []
  type: TYPE_NORMAL
- en: 'They will all be named according to the path of our application (`/home/packt/appackt`).
    We can clean up these entries with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now verify that our app is indeed guarded with AppArmor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The relevant excerpt from the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – appackt in complain mode](img/B19682_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35 – appackt in complain mode
  prefs: []
  type: TYPE_NORMAL
- en: Our application (`/home/packt/appackt`) is shown, as expected, in `enforce`
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to validate that our app complies with the security policies
    enforced by AppArmor. Let’s edit the `appackt` script and change the `LOG_FILE`
    path in *line 6* of *Figure 9**.35* to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: mkdir logs
  prefs: []
  type: TYPE_NORMAL
- en: ./appackt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: sudo aa-enforce /home/packt/appackt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: sudo aa-status
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: sudo aa-complain /home/packt/appackt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: sudo ln -s /etc/apparmor.d/home.packt.appackt /etc/apparmor.d/disable/
  prefs: []
  type: TYPE_NORMAL
- en: sudo apparmor_parser -R /etc/apparmor.d/home.packt.appackt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: sudo rm /etc/apparmor.d/disable/home.packt.appackt
  prefs: []
  type: TYPE_NORMAL
- en: sudo apparmor_parser -r /etc/apparmor.d/home.packt.appackt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: sudo systemctl stop firewalld
  prefs: []
  type: TYPE_NORMAL
- en: sudo systemctl disable firewalld
  prefs: []
  type: TYPE_NORMAL
- en: sudo systemctl mask firewalld
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: sudo dnf install iptables-services
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: sudo iptables -L [CHAIN] [-t TABLE]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: sudo iptables -L
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: sudo iptables -L INPUT -t nat
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: sudo iptables -F INPUT
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sudo iptables -F FORWARD
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'iptables command with the -v (--verbose) option.The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo iptables -P INPUT DROP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sudo iptables -P FORWARD DROP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: -P (--policy) option parameter sets the policy for a specific chain (such as
    INPUT) to the given target (for example, DROP). The DROP target makes the system
    gracefully ignore all packets.At this point, if we were to save our firewall configuration,
    the system wouldn’t accept any incoming or outgoing packets. So, we should be
    careful not to inadvertently drop our access to the system if we use SSH or don’t
    have direct console access.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo iptables -A INPUT -p tcp --dport 22 -m state \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --state NEW,ESTABLISHED -s 192.168.0.0/24 -j ACCEPT
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sudo iptables -A OUTPUT -p tcp --sport 22 -m state \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '-A INPUT: Specifies the chain (for example, INPUT) to append the rule to'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo iptables -A INPUT -p tcp --dport 443 -m state \
  prefs: []
  type: TYPE_NORMAL
- en: --state NEW,ESTABLISHED -j ACCEPT
  prefs: []
  type: TYPE_NORMAL
- en: sudo iptables -A OUTPUT -p tcp --sport 443 -m state \
  prefs: []
  type: TYPE_NORMAL
- en: --state ESTABLISHED,RELATED -j ACCEPT
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
  prefs: []
  type: TYPE_NORMAL
- en: 'iptables option parameters, please refer to the following system reference
    manuals:*   `iptables` (`man iptables`)*   `iptables-extensions` (`man iptables-extensions`)
    `iptables` configuration, we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '-f (--file) option parameter specifies the file to save (back up) the iptables
    configuration in. We can restore the saved iptables configuration later with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: sudo yum install -y nftables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: sudo systemctl stop iptables
  prefs: []
  type: TYPE_NORMAL
- en: sudo systemctl disable iptables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: sudo systemctl enable nftables
  prefs: []
  type: TYPE_NORMAL
- en: sudo systemctl start nftables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: sudo systemctl status nftables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: sudo cat /etc/sysconfig/nftables.conf
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: sudo nft list ruleset
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: sudo nft flush ruleset
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'sudo nft add table inet packt_chain within packt_table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'sudo nft add rule inet packt_table packt_chain tcp dport {ping):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will reject everything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s have a look at our new configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48 – A simple firewall configuration with nftables](img/B19682_09_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.48 – A simple firewall configuration with nftables
  prefs: []
  type: TYPE_NORMAL
- en: 'The output suggests the following settings for our input chain (`packt_chain`):'
  prefs: []
  type: TYPE_NORMAL
- en: Allow TCP traffic on destination ports `22`, `80`, and `443` (`tcp dport { 22,
    80, 443 }` `accept`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow `ping` requests (`ip protocol` `icmp accept`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reject everything else (`meta nfproto` `ipv4 reject`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we will save the current configuration to `/etc/nftables/packt.nft`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will point the current `nftables` configuration to `/etc/nftables/packt.nft`
    in the `/etc/sysconfig/nftables.conf` file by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `vim` (or your editor of choice) to make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `nftables.conf` file now contains the reference to our `packt.nft`
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.49 – Including the new configuration in nftables.conf](img/B19682_09_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.49 – Including the new configuration in nftables.conf
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command reloads the new `nftables` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: After this exercise, you can quickly write a script for configuring `nftables`
    using the output of the `nft list ruleset` command. As a matter of fact, we just
    did that with the `/etc/nftables/packt.nft` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we will conclude our examination of packet filtering frameworks and
    the related command-line utilities. They enable power users to have granular control
    over every functional aspect of underlying network chains and rules. Yet, some
    Linux administrators may find the use of such tools overwhelming and turn to relatively
    simpler firewall management utilities instead. So, next, we’ll look at a couple
    of native Linux firewall management tools that provide a more streamlined and
    user-friendly command-line interface for configuring and managing firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Using firewall managers
  prefs: []
  type: TYPE_NORMAL
- en: '**Firewall managers** are command-line utilities with a relatively easy-to-use
    configuration interface of firewall security rules. Generally, these tools require
    superuser privileges, and they are a significant asset for Linux system administrators.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, we’ll present two of the most common firewall managers
    that are widely used across modern-day Linux distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld`: On RHEL/Fedora platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ufw`: On Ubuntu/Debian platforms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall managers are similar to other network security tools (such as `iptables`,
    Netfilter, and `nftables`), with the main difference being that they offer a more
    streamlined user experience for firewall security. An essential benefit of using
    a firewall manager is the convenience of not having to restart network daemons
    when you’re operating various security configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with `firewalld`, the default firewall manager for RHEL/Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: Using firewalld
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` is the default firewall management utility for a variety of Linux
    distributions, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: RHEL 7 (and newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: openSUSE 15 (and newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora 18 (and newer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On RHEL, if `firewalld` is not present, we can install it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also have to enable the `firewalld` daemon at startup with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the same system you used to execute previous examples with `iptables`
    and `nftables`, remember that we had to disable `firewalld` at the beginning on
    our Fedora distribution. Now, it is time to re-enable it. We will use the following
    commands to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.50 – Re-enabling firewalld](img/B19682_09_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.50 – Re-enabling firewalld
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` has a set of command-line utilities for different tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firewall-cmd`: The primary command-line tool of `firewalld`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-offline-cmd`: Used for configuring `firewalld` while it’s offline
    (not running)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-config`: A graphical user interface tool for configuring `firewalld`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firewall-applet`: A system-tray app for providing essential information about
    `firewalld` (such as running status, connections, and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will look at a few practical examples of using the `firewall-cmd`
    utility. For any of the other utilities, you may refer to the related system reference
    manual (such as `man firewall-config`) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` (and `firewalld-cmd`, for that matter) operates with a few key
    concepts related to monitoring and controlling network packets: *zones*, *rules*,
    and *targets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding firewalld zones
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` configuration. A network packet monitored by `firewalld` belongs
    to a zone if it matches the network interface or IP address/netmask source associated
    with the zone. The following command lists the names of the predefined zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For detailed information about all the zones that have currently been configured,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an excerpt of the related output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.51 – Listing firewalld zones](img/B19682_09_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.51 – Listing firewalld zones
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output illustrates the default (active) zone in Fedora 37 Server
    Edition with its own attributes, some of which will be explained next. Zones associated
    with an interface and a source are known as **active zones**. The following command
    retrieves the active zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, in our case, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.52 – The firewalld active zones](img/B19682_09_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.52 – The firewalld active zones
  prefs: []
  type: TYPE_NORMAL
- en: '**Interfaces** represent the network adapters that are attached to the localhost.
    Active interfaces are assigned to either the default zone or a user-defined zone.
    An interface cannot be assigned to multiple zones.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sources** are incoming IP addresses or address ranges, and they can also
    be assigned to zones. A single source or multiple overlapping IP address ranges
    cannot be assigned to more than one zone. Doing so would result in undefined behavior,
    as it would be unclear which rule takes precedence for the related zone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `firewalld` assigns all network interfaces to the `public` zone
    without associating any sources with it. Also, by default, `public` is the only
    active zone and thus the default zone. The following command displays the default
    zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The default output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.53 – Displaying the default zone in firewalld](img/B19682_09_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.53 – Displaying the default zone in firewalld
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a source for a zone is optional. Consequently, for every data packet,
    there will be a zone with a matching network interface. However, there won’t necessarily
    be a zone with a matching source. This paradigm would play an essential role in
    the order in which the matching rules are evaluated. We’ll discuss the related
    topic in the *Understanding rule precedence* section. But first, let’s get acquainted
    with `firewalld` rules.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding firewalld rules
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` configuration represent the configuration settings for controlling
    the data packets associated with a specific zone. Usually, a rule would decide
    whether a packet is accepted or rejected, based on some predefined criteria.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to block `ping` requests (ICMP protocol) for the `FedoraServer`
    zone, we can add the following `rich-rule` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the `FedoraServer` zone information with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rich-rule` attribute reflects the updated configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.54 – Getting the FedoraServer zone configuration with firewalld](img/B19682_09_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.54 – Getting the FedoraServer zone configuration with firewalld
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our host won’t respond anymore to `ping` (ICMP) requests. We
    can remove the `rich-rule` attribute we just added with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can enable ICMP access with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Please note that changes that are made without the `--permanent` option of the
    `firewall-cmd` utility are transient and won’t persist after a system or `firewalld`
    restart.
  prefs: []
  type: TYPE_NORMAL
- en: When no rich rules are defined or matched for a zone, `firewalld` uses the zone’s
    target to control the packet’s behavior. Let’s look at targets next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding firewalld targets
  prefs: []
  type: TYPE_NORMAL
- en: 'When a packet matches a specific zone, `firewalld` controls the packet’s behavior
    based on the corresponding zone’s rich rules. If there are no rich rules defined,
    or none of the rich rules matches the data packet, the packet’s behavior is ultimately
    determined by the **target** associated with the zone. Possible target values
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ACCEPT`: Accepts the packet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REJECT`: Rejects the packet and responds with a reject reply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DROP`: Drops the packet without a reply'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: Defers to the default behavior of `firewalld`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zones, rules, and targets are key configuration elements used by `firewalld`
    when analyzing and handling data packets. Packets are matched using zones and
    then acted upon using either rules or targets. Due to the dual nature of zones—based
    on network interfaces and IP address/range sources—`firewalld` follows a specific
    order (or precedence) when calculating the matching criteria. We’ll look at this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding rule precedence
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define the terminology first. We’ll refer to the zones associated with
    interfaces as **interface zones**. The zones associated with sources are known
    as **source zones**. Since zones can have both interfaces and sources assigned
    to them, a zone can act as either an interface zone, a source zone, or both.
  prefs: []
  type: TYPE_NORMAL
- en: '`firewalld` handles a data packet in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks the corresponding source zone. There will be, at most, one such zone
    (since sources can only be associated with a single zone). If there is a match,
    the packet is handled according to the rules or target associated with the zone.
    Otherwise, data packet analysis follows as the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It checks the corresponding interface zone. Exactly one such zone would (always)
    exist. If we have a match, the packet is handled according to the zone’s rules
    or target. Otherwise, the packet validation follows as the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s assume the default target of `firewalld`—it accepts ICMP packets and
    rejects everything else. The key takeaway from the preceding validation workflow
    is that source zones have precedence over interface zones. A typical design pattern
    for multi-zone `firewalld` configurations defines the following zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privileged source zone**: Elevated system access from select IP addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restrictive interface zone**: Limited access for everyone else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore some more potentially useful examples using the `firewall-cmd`
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command displays services enabled in the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command enables HTTPS access (port `443`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a user-defined service or port (for example, `8443`), we can run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lists the open ports in the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoking the `firewall-cmd` command without the `--permanent` option results
    in transient changes that won’t persist after a system (or `firewalld`) restart.
    To reload the previously saved (permanent) configuration of `firewalld`, we can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: For more information on `firewalld`, refer to the related system reference (`man
    firewalld`) or [https://www.firewalld.org](https://www.firewalld.org).
  prefs: []
  type: TYPE_NORMAL
- en: Using ufw
  prefs: []
  type: TYPE_NORMAL
- en: '`ufw` is the default firewall manager in Ubuntu. `ufw` provides a relatively
    simple management framework for `iptables` and Netfilter and an easy-to-use command-line
    interface for manipulating the firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a few examples of using `ufw`. Please note that the `ufw` command-line
    utility needs superuser privileges. The following command reports the status of
    `ufw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `ufw` is `inactive` (disabled). We can enable `ufw` with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Always be careful when you enable the firewall or perform any changes that
    may affect your access to the system. By default, when enabled, `ufw` will block
    all incoming access except `ping` (ICMP) requests. If you’re logged in with SSH,
    you may get a prompt warning you that the SSH connection could be lost while trying
    to enable `ufw`. To play it safe, you may want to abort the preceding operation
    by pressing `n` (No) and enabling SSH access in the firewall first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: If SSH access is already enabled, the output suggests that the related security
    rule will not be added. If not, the rule will be added.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you can safely enable `ufw` without fearing that your current
    or existing SSH connections will be dropped. Upon enabling `ufw`, we get the same
    prompt as before, but this time, we can press `y` (Yes).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check upon a detailed status of the firewall, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for running all these commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.55 – Enabling ufw, allowing ssh, and detailed status of ufw](img/B19682_09_55.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.55 – Enabling ufw, allowing ssh, and detailed status of ufw
  prefs: []
  type: TYPE_NORMAL
- en: It’s always recommended to check your firewall settings to ensure that inadvertent
    access to the system is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list the current application security profiles with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: In our case, only OpenSSH is available, activated when we allowed SSH connections
    earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Let us add other services, such as HTTP (port `80`) and HTTPS (port `443`),
    used by Apache and `nginx`. This can be achieved in several different ways. We
    can either use port numbers (`80`, `443`), we can use service names as an alternate
    way (`http`, `https`), or we can specify web server names directly (`Apache Full`,
    `Nginx Full`). Details are shown in *Figure 9**.56*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a specific service’s access (such as HTTP), we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that a new rule has been added. A subsequent detailed status
    check would show that access to port `80/tcp` has been denied. Yet, the resulting
    status is somewhat convoluted. In the following screenshot, we can see the output
    of adding and removing the commands that were just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.56 – Adding and denying rules in ufw](img/B19682_09_56.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.56 – Adding and denying rules in ufw
  prefs: []
  type: TYPE_NORMAL
- en: 'To reinstate the rules in the right order, let’s get a numbered output of the
    rule list first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The output yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.57 – Numbered list of rules in ufw](img/B19682_09_57.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.57 – Numbered list of rules in ufw
  prefs: []
  type: TYPE_NORMAL
- en: The order of the rules is suggested by sequence numbers. Always put more specific
    (restrictive) rules first. As rules are being added or changed, you may need to
    delete old entries or rearrange their order to ensure that the rules are appropriately
    placed and evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could use the `insert` option to add a specific rule at a
    given position. For example, the following command places the `80/tcp DENY` rule
    in the second position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at a few more examples of using `ufw`. The following command enables
    SSH access (port `22`) for all protocols (`any`) from a specific source address
    range (`192.168.0.0/24`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command enables `ufw` logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding log traces are usually in `/var/log/syslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable `ufw` logging, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command reverts `ufw` to the system’s defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command results in removing all rules and disabling `ufw`.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about `ufw`, you may wish to explore the *UFW Community
    Help* wiki at [https://help.ubuntu.com/community/UFW](https://help.ubuntu.com/community/UFW)
    or the related system reference (`man ufw`).
  prefs: []
  type: TYPE_NORMAL
- en: The use of firewall management tools such as `ufw` and `firewalld` may have
    more appeal to some Linux administrators, compared with lower-level packet filtering
    utilities (for example, Netfilter, `iptables`, and `nftables`). One of the arguments
    for choosing one tool over the other, besides platform considerations, is related
    to scripting and automation capabilities. Some power users may consider the `nft`
    command-line utility the tool of choice for designing their firewall rules, due
    to the granular control provided by `nftables`. Other users may be inclined to
    use `iptables`, especially on older legacy platforms. In the end, it’s a matter
    of choice or preference, as all of these tools are capable of configuring and
    managing a firewall to roughly the same extent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s wrap up our chapter with some final considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: The relatively vast content of this chapter may appear overwhelming. A key takeaway
    should be the focus on the frameworks (modules). If we’re discussing firewalls,
    we should look at packet filtering frameworks such as `iptables`, Netfilter, and
    `nftables`. For access control, we have security modules such as SELinux and AppArmor.
    We covered some of the pros and cons of each. The pivoting choice, possibly deciding
    the Linux distro, is between AppArmor and SELinux. One is perhaps swifter than
    the other, with the related administration effort hanging in the balance. For
    example, choosing AppArmor would narrow down the major Linux distributions to
    Ubuntu, Debian, and openSUSE. The distro choice, in turn, would further dictate
    the available firewall management solutions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering the application security frameworks and firewall management tools
    will help you keep your systems safe with minimal effort. As with any typical
    Linux system administration task, there are many ways of securing your system.
    We hope that you will build upon the exploratory knowledge and tools presented
    in this chapter to make a balanced decision regarding keeping your systems secure.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will add a further notch to the safety and protection of your
    system by introducing **disaster recovery** (**DR**), diagnostics, and troubleshooting
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief quiz about some of the essential concepts that were covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate at least a couple of ACMs that are used in Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: DAC, ACL, MAC, RBAC, MLS, MCS'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enumerate the fields of the SELinux security context.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: user, role, type, level'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is a domain in SELinux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Type assigned to a process'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Can you think of a significant difference between SELinux and AppArmor in terms
    of enforcing security policies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: SELinux uses policies based on file labels, while AppArmor uses security
    policies based on paths.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do we toggle an AppArmor application profile between the `enforce` and `complain`
    modes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`aa-enforce` and `aa-complain`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How many chains can you think of in the Linux kernel networking stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: *Figure 9**.41* could help you.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the default firewall management solution in RHEL/Fedora? How about Ubuntu?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`firewalld` (Fedora) and `ufw` (Ubuntu)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the following Packt books for more information about the topics
    that were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Mastering Linux Security and Hardening – Second Edition* by Donald A. Tevault,
    Packt Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical Linux Security Cookbook – Second Edition* by Tajinder Kalsi, Packt
    Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
