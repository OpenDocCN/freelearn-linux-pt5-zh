# Security Monitoring and Logging

In this chapter, we will discuss the following recipes:

*   Viewing and managing log files using Logcheck
*   Monitoring a network using Nmap
*   Using Glances for system monitoring
*   Monitoring logs using MultiTail
*   Using System tools – whowatch
*   Using System tools – `stat`
*   Using System tools – `lsof`
*   Using System tools – `Strace`
*   Real-time IP LAN monitoring using IPTraf
*   Network security monitoring using Suricata
*   Network monitoring using OpenNMS

# Viewing and managing log files using Logcheck

As an administrator, while checking for malicious activity on the system or any software issue, log files play a very important role. However, with the increasing number of software, the number of log files being created has also increased. This makes it very difficult for an administrator to analyze log files properly.

In such scenarios, Logcheck is a really nice tool that's available to help administrators in analyzing and scanning log files. Logcheck scans the logs for interesting lines as per its documentation.

These interesting lines"mainly refer to the security issues detected by the tool.

# Getting ready

No specific requirements are needed to use Logcheck on a Linux system.

# How to do it...

In this section, we will see how to install and configure Logcheck so that we can use it, as per our requirements:

1.  The first step is to install the package using the following command:

![](img/ec34075f-dbce-4d07-9ae7-7bbeb3474819.png)

2.  During installation, a window will open showing information about selecting the mail server configuration type, as shown in the following screenshot:

![](img/0661a50a-5b4e-4415-9ac3-a387afd551d4.png)

Press Ok to continue.

3.  In the next window, select Internet Site and then select Ok to continue:

![](img/3a68831d-8294-404f-ba00-8b1464640ec0.png)

4.  After the installation has completed, we need to make changes in the configuration file `/etc/logcheck/logcheck.conf`.
5.  The first thing we can edit in the configuration file is the format of the date/time stamp which is used in the subject of the mail sent by Logcheck:

![](img/8cf16d52-1583-42dd-8cf4-b6e2c2487e57.png)

6.  Next, we can change the value for the REPORTLEVEL variable to control the level of filtering of the logs, as per our requirements. We have three options available, and by default, the value is set to server:

![](img/888b18db-c351-43da-b582-5fb4462cc716.png)

The workstation value filters most of the messages and is less verbose. The paranoid value is useful for systems that have high security, are running as less services as possible, and are more verbose.

1.  After this, we will change the value for the variable `SENDMAILTO` and provide our email address so that we can receive the logs on our email ID:

![](img/d6a38165-6927-46ee-8053-6c4150a5f4bc.png)

8.  The mail generated by Logcheck uses different subject lines for different events. If we wish to modify these subject lines, we can edit the value for the variables, like so:

![](img/0db3f411-8d98-4b75-bfef-7c0447b03396.png)

9.  Logcheck, by default, uses the `/etc/logcheck/logcheck.logfiles` file for maintaining a list of log files to be monitored. If we wish to use any other file to define the list, and if it is in another location, we can edit the `RULEDIR` variable to define the new path:

![](img/8b3f6034-c05d-4a9a-bd8e-46554ef0aeb0.png)

10.  If we want Logcheck to monitor any particular file apart from what is already defined in the `/etc/logcheck/logcheck.logfiles` file, we can add the following entry in it:

![](img/2e5d4184-f14b-4538-89b0-ce58b1d1ffa5.png)

In the preceding file, we have added the following line: `/var/log/boot.log`.

# How it works...

We first install the Logcheck package and, after the installation, we edit its configuration file, `/etc/logcheck/logcheck.conf`.

In the configuration file, we change the format of the date/time stamp for logs and we also edit the level of filtering done by Logcheck by modifying the `REPORTLEVEL` variable.

Next, we edit the `SENDMAILTO` variable and enter our email ID to receive the logs on our email.

Using the `etc/logcheck/logcheck.logfiles` file, we define the logs to be monitored by Logcheck.

# Monitoring the network using Nmap

For any network, big or small, network monitoring and security is a very essential task. Regular monitoring of the network is important to protect the systems from attacks and also keeps viruses and malware out of the network.

**Nmap**, short for **Network Mapper**, is a free and open source tool for network monitoring and is the most versatile tool for system/network administrators. Nmap can be used to perform security scans, explore the network, find open ports on the remote system, and perform network audits.

# Getting ready

To show you the workings of `nmap`, we need a minimum of two systems forming a small network. On one system, we will install the `nmap` package, while the other system will be used as a host to scan.

1.  To install `nmap`, if it is not already installed, run the following command:

![](img/62785653-0a51-40f8-b28c-77727a5251c0.png)

2.  If we want to check the version of Nmap, we can use the following command:

![](img/9e9a66e1-4743-4828-99c9-d50995e84a50.png)

# How to do it...

In this section, we will see how we can use Nmap for performing different types of scans using the following steps:

1.  Once `nmap` is installed, we can get more information about the options which can be used with `nmap` by just typing `nmap` and pressing *Enter*. This will display the following output, which shows all of the options supported by `nmap`:

![](img/4c8ec117-a8dd-425d-94bb-a268964dcbb2.png)

2.  Let's begin by scanning the live hosts in our network by using Nmap. To do so, run the following command:

![](img/7a041d60-a394-4d02-899e-134cff923686.png)

In the preceding output, we can see the hosts which are up.

3.  Now, let's perform a simple scan using the IP address of the system we want to scan. The command to perform a simple scan is as follows:

![](img/0bbd5d3d-1519-4915-998e-c95126c3190a.png)

In the preceding example, the IP address of the system we are scanning is `192.168.43.100`. In the result of the scan, we can see that the target system is running various services.

4.  Nmap can also be used to scan our own system. For doing so, we can run the following command:

```
      nmap localhost
```

5.  If we want to scan more than one system in the same command, we can do so using the following command:

```
      nmap 192.168.43.100 192.168.43.102

```

6.  If we want to limit our scan to a particular port only, we can tell `nmap` to scan that port only by using the `-p` option, as follows:

![](img/90a45137-c996-47b7-9bd0-e91138fbfc9a.png)

In the preceding example, we are scanning for port `22` and `80`, the default ports for the SSH service and the HTTP (web server) service. As we can see in the preceding results, the remote system is running SSH as well as a web server.

7.  While performing a scan of the target system, determining the operating system on that system is very important as many exploits are available for specific OS platforms. To know the OS of the target system, we can use the `-O` option, as follows:

```
    nmap -O 192.168.43.100
```

![](img/d3c9f8c3-da95-43a3-a462-8bb94d057bbd.png)

The result shown in the preceding screenshot tells us that the target system is running a Linux based operating system with kernel version 2.6.

8.  We have seen that, by using the `-p` option, we can check which particular port is open. Now, let's suppose the target system has port 22 open, which means that SSH is running on that system. If we want to check the version of the SSH service on the remote system, we can use the `-sV` option, as follows:

![](img/a93338f7-16f6-451f-83f6-520296383fbb.png)

9.  We can save the output of the Nmap scan for future analysis in various formats supported by nmap. Let's use the `-oN` option to save the output in normal format:

![](img/cdeabd24-2c6e-46be-b93d-9dfd065f24c4.png)

10.  We can see that the output file has been created in our current directory:

![](img/f2dcf7c5-9762-41ce-999e-3314ac2bd22c.png)

If we check the content of the file, we will see the same output which nmap displayed on the screen when running the following command:

![](img/e8a02237-0f24-4765-b315-bbe0c47c1aff.png)

# How it works...

When Nmap is simply run on an IP address, it does a basic scan and tells us the ports that are open on the target system. By knowing the open ports, we can identify the services running on the system. In the same way, nmap is used to scan the local system by providing the IP address of the local system.

Nmap can also be used to scan multiple IP addresses at the same time, by simply mentioning the IP addresses one after the other, in the same command. Also, Nmap is used to check which systems are up and running in the network.

It is also used to scan for a particular port using the `-p` option, and if the `-O` option is used, it does a fingerprinting of the target system to display which operating system is running on it.

Nmap is also used for doing other tasks, like identifying the software version of the services running on the target system.

# Using Glances for system monitoring

For an administrator, system monitoring is all about monitoring the performance of the system by checking the processes and services running on it. But with limited space on the screen, it sometimes becomes difficult to have all the information. In such situations, we would such as to have a tool that can show us the maximum information about the system, like CPU, disk I/O, memory, network, and so on, in a limited screen space.

Even though we have individual tools for monitoring all of the information, with Glances, an administrator can see the maximum amount of information in a minimal space. It can adapt the information dynamically, as per the size of the Terminal window. Glances can highlight programs which are using the maximum amount of system resources.

# Getting ready

If you are installing Glances on Ubuntu, then it is recommended to use Ubuntu 13.04 or above. For other versions of Linux, you should use the latest version. For our example, we are using Kali Linux 2.0.

# How to do it...

To understand the working of Glances, we will follow these steps:

1.  The first step is obviously to install the package using the following command:

```
    apt-get install glances
```

2.  After the installation has completed, we have to edit the `/etc/default/glances` file and change the value of the `RUN` to `true`, as shown in the following screenshot:

![](img/63c61102-9969-4a17-85a6-5ab789346c70.png)

Doing this will automatically run Glances during system startup.

3.  To manually start the tool, simply run the `glances` command. You will get the following output window:

![](img/8651e89f-bf8f-445e-88e6-e9b07850fa77.png)

In the preceding window, we can see different colors for the text displayed. The meaning of these color codes in Glances is defined as follows:

*   **Green**: This means all is `OK`
*   **Blue**: This color says `CAREFUL`, attention is needed
*   **Violet**: This color signifies `WARNING`
*   **Red**: This says something is `CRITICAL`

Refer to the graphics bundle for the color image codes.

4.  The color codes work on the basis of the default thresholds defined in the configuration file of Glances. We can change these threshold values by editing the `/etc/glances/glances.conf` file:

![](img/f8128058-df7c-4e10-b608-0a533b0538f1.png)

5.  By default, Glances refreshes the value at a time interval of 1 second. We can change this value when running Glances by using the `-t` option followed by the time in seconds, as follows:

```
    glances -t 5
```

6.  At times, we may not be able to physically access our system, but we still want to monitor the performance of the system. Glances can help us do this remotely. For this, we first need to enable the client/server mode of Glances on our system by using the `-s` option and also bind it to the IP address of the system using the `-B` option, as follows:

![](img/6ef67109-5021-4adc-83a9-132cb5582d27.png)

Now, the Glances server is running on the system whose IP address is `192.168.1.102` and, by default, it runs on port `61209`. If prompted for a password when enabling the client/server mode, define any password of your choice.

On the remote system where you want to access Glances, run the following command:

```
    glances -c -P 192.168.1.102
```

Once we run this command, we will get the following window, which says on the top-left `Connected to Kali - IP 192.168.1.102/24`, telling us that we are now accessing Glances remotely:

![](img/92d91f3b-bf5f-41bd-b8f3-30d81b43bb3b.png)

For this command to work on the remote system, it is necessary to have Glances installed on this remote system as well.

# How it works...

After the installation of Glances, we enable its auto run during system startup.

We run it by using the `glances` command, and we modify the threshold value for the color codes by editing the `/etc/glances/glances.conf` file.

By using the `-t` option, we modify the refresh time interval, and by using the `-s` option, we enable the client/server mode of Glances which is then accessed remotely on another system by using the `-c` option and the IP address of the system on which Glances is running.

# Monitoring logs using MultiTail

For any system administrator, monitoring the log files is a very tedious task, and if we have to refer more than one log file at the same time to troubleshoot any issue, it becomes even more difficult to keep switching between logs.

For such situations, we can use the MultiTail tool, which we can use to display multiple log files in a single window or shell, and it will show us the last few lines of the log file in real-time.

# Getting ready

To use MultiTail, we don't have to set up anything in particular on our Linux system. Only the MultiTail package needs to be installed. This can be done using the following command:

```
    apt-get install multitail
```

![](img/749f7716-4c38-4d40-970d-9cb00abfeec4.png)

# How to do it...

Once the MultiTail tool has been installed, we can start using it as per our requirements using the following commands in this recipe:

1.  If we want to view two log files using `multitail`, we will run the following command:

```
    multitail /var/log/syslog /var/log/boot.log
```

![](img/86a17d2a-9a33-4ca0-aaa0-dda4109d67b6.png)

We can see that the screen has been split into two parts, each displaying the content of the individual log files.

2.  If we want to scroll through the two files which are open, just press *B*, and a menu will pop up, as follows. From this list, we can select the file we want to monitor in detail:

![](img/4a484deb-de63-418d-84e9-48bf7e19d49f.png)

In the new window that opens up, press `gg/G` to move to the top or bottom of the scroll window. To exit from the scroll window, press *Q*.

3.  If we want to view three log files in 2 columns, we can use the following command:

```
    multitail -s 2 /var/log/boot.log /var/log/syslog /var/log/auth.log
```

![](img/e283d50d-554b-4606-8953-574dedbdab49.png)

The preceding screenshot shows the three log files in two columns.

4.  MultiTail allows us to customize the color for individual log files as we open them while merging both of them in the same window. This can be done by using the following command:

```
    multitail -ci yellow /var/log/auth.log -ci blue -I /var/log/boot.log 
```

![](img/6f236ae3-a278-40b9-82f7-499d3e35f28c.png)

# How it works...

When we provide the names of two log files to MultiTail on the command line, it opens the two files in the same screen by splitting it into two parts.

For viewing more than two log files using MultiTail, we specify the number of columns in which the screen should be split by using the `-s` option followed the number of the column.

MultiTail also allows us to view multiple log files in the same screen without splitting the screen by differentiating the files on the basis of color. The color can be customized by using the `-ci` option.

# Using system tools – whowatch

While keeping a watch on the network, the administrator would also like to keep a watch on the users who are currently logged on to the system and also what each user is doing on the machine.

Whowatch is the perfect tool for such tasks. It uses a simple text-based interface which is easy to use and can display information about the user's username, processes, and so on, and also the type of connection , such as SSH and telnet.

# Getting ready

Since Whowatch doesn't come as a pre-installed package in Linux, we have to install it to use it. The command to install whowatch is as follows:

```
    apt-get install whowatch
```

![](img/7467a2f4-61e4-413d-8348-9f5b92f6910d.png)

# How to do it...

For utilizing the Whowatch tool to its maximum benefit, we have to understand the details of the tool properly:

1.  To start using the tool, just enter the `whowatch` command, and a screen will appear as follows:

![](img/ab6a5af5-3553-4e20-8a8b-2650e0f734af.png)

The preceding screen lists all the user accounts that are logged in.

2.  From this list, we can select any user account, and when we press *Enter*, we can view information about all the programs that the user is running:

![](img/fe0439e3-f5a8-4c62-b23f-4503c651cb53.png)

On the same screen, we have more options at the bottom, using which we can get more information about the user and also the programs that have been run by the user:

![](img/1bfe3a25-ce40-451b-b4bc-d5991d6b1a53.png)

3.  On the main screen of Whowatch, we can see a menu at the bottom, as follows:

![](img/390d4ff4-ca58-47ea-a020-435a908ef8e6.png)

In the preceding screenshot, we can see that we have to use the *F9* key to access the Menu options.

4.  Once we press *F9*, we will see a menu on the top of the screen. Use the arrow keys on the keyboard to move through the menu. When we select the Process tab, we get a submenu, which gives us the option to give a KILL signal to the running processes. Similarly, we can see more options in the same submenu:

![](img/8eb0e2cf-95b5-406c-8167-0f94f77a1718.png)

5.  When we move to the View tab, we get the following options:

![](img/6d3d3d6c-2c78-409b-8d43-e7007312b7a7.png)

6.  The last tab is Help, under which we have the Keys option:

![](img/08dcb2dc-9da8-49e8-bc38-64cf8a756e98.png)

7.  When we press Keys, it will open up a new window and show details about the keys to be used for different tasks, as shown in the following screenshot:

![](img/444bbcb0-4318-4f2d-8406-bae3c1d4c17f.png)

8.  Press *s* to get more information about the system:

![](img/277db706-696a-410c-a702-bc2cc998b49a.png)

9.  If we press *t*, we get a list of all the processes on the system in a tree structure, which we can see in the following screenshot:

![](img/23d504fa-8a40-4b0e-a940-896d5891d3fd.png)

# How it works

Whowatch is started by simply typing `whowatch` on the command line. When it starts, it shows a list of users who are logged in. Just press *Enter* on any username to get information about all the programs running under that user.

To access more options in Whowatch, we can enter the Main menu by pressing the *F9* key. We then get various tabs, such as Process, View, Users, Help, and so on.

The Process tab gives us options to manage processes, while the View tab gives us the option to search and view the processes. The Help tab has options to see the keys which can be used in Whowatch as shortcuts.

We use different keys to access system information and get a list of all of the processes.

# Using system tools – stat

While working on Linux, the most commonly used command is `ls`, which gives a listing of the files in the specified directory. However, it shows only a little information about the files.

Instead, if we use the `stat` command, we can get more information about the files/directories when compared to using `ls`. Because `stat` is able to get information about a file from its inode, it is able to give more information about the files.

# Getting ready

Since `stat` is an built-in command of Linux, nothing else needs to be installed so that we can use it.

# How to do it...

This section will explain about the options and usage of the `stat`" command. By using `stat`, we can get a detailed status of a particular file or file system.

1.  Suppose we have a file called `example.txt`. When we do a long-listing of this file using the `ls -l` command, we get information about the file which includes information about when the file was last modified.

However, when we use the `stat` command to check details about the same file, it shows extra information about the file and the difference, as shown in the following screenshot:

![](img/f6463ca8-0ec2-49bb-a992-25aa66dc5774.png)

In the preceding output, we can see that the `Modify` and `Change` time are the same, but the access time has changed. It also shows the permissions in both the octal and rwx formats. Many other details are also shown.

2.  Now, let's rename the file to `sample.txt`. After this, if we check the details of the `sample.txt` file using `stat`, we can see that the `Change` time has been updated:

![](img/b49b5d6b-8cf4-483e-8976-c043fa5d4451.png)

3.  Now, let's suppose we have three files called `sample.txt`, `sample1.txt`, and `sample2.txt`. If we want to check the details of each of these three files, either we can use stat individually with each file or we can use wildcards with `stat` to show the details of all the three files in a group, as follows:

![](img/d276a919-bf24-433d-a370-71f263c1534c.png)

4.  We can use the `stat` command to check details about the directories also, as follows:

![](img/d0fb872e-8831-43c6-8b7b-8f339a9e299c.png)

In the case of the directory, we can see extra details about the number of links.

5.  If we use the `stat` command for any directory of Linux, such as `/etc/`, we can see that we get a big value for the number of links, as follows:

![](img/26714133-41be-4d2f-8f3e-707a9a910508.png)

6.  If we want to see details about a file system, we can't use `ls` for this. However, `stat` works on the file system as well. We get the same kind of details for a file system, as we get for files:

![](img/a6ba87ad-dfac-4b64-b021-cfee840ca97f.png)

7.  If we use the `-f` option with the `stat` command while checking the details of the file system, it will display the status of the file system:

![](img/2391e046-830c-4af2-bd5c-5f2a2e690198.png)

# How it works...

We can use the stat command to get detailed information about a file. When a file is renamed, stat tells us the time of the change. It also gives information about multiple files at the same time using wildcards with the command.

Stat works on directories and file systems as well. In the case of a file system, stat can display its status using the `-f` option.

# Using System tools – lsof

At times, we face situations where we are unable to unmount a disk as it says that the files are being used, but we are unable to understand which file it is referring to. In such situations, we can check which files are open by which process is running on the system.

This can be done using the `lsof` command, which means List Open Files. Since Linux considers everything, including directories, devices, sockets, and so on as files, we can use `lsof` to easily identify all of the files that are open.

# Getting ready

To use the `lsof` command, it is recommended to be logged in from a root account or else use `sudo` from a non-root account so that the output of the `lsof` command is not limited.

# How to do it...

In this section, we will explore different options that can be used with the `lsof` command to understand how it works:

1.  If we just run lsof, it will list all of the open files that belong to any active process on the system. If the output is long, we can use the `less` command to scroll through the output:

```
    lsof | less
```

![](img/65b40779-62fb-4795-bfc2-6b32eafab85b.png)

The output which is displayed in the preceding screenshot is shown in columns such as Command, PID, User, FD, Type, Device, and so on, for a better understanding about the files.

The FD column has information about the file's description, such as the **Current Working Directory** (**CWD**), **Root Directory** (**RTD**), **Program Text** (**TXT**), and so on. If the FD column contains information like `0u`, `1u`, and so on, the number signifies the actual file descriptor and the alphabet signifies the different modes (read access, write access, and read/write access).

1.  To check the list of all open files for a particular user, we can use the `-u` option followed by the username, as follows:

```
    lsof -u tajinder
```

![](img/bc7870f9-ddb5-4bcf-ba71-8facf8fad543.png)

2.  Using lsof, we can check if there are any processes running on a particular port. To do so, we have to use the `-i` option and run the following command:

```
    lsof -i TCP:22
```

![](img/baa59780-5858-491c-979a-09f5fb7945a9.png)

In the preceding example, we have checked for the list of running processes on port `22`, and we can see that the SSH process is running.

1.  If we want to check the exact number of open files on the system, we can run the following command:

![](img/15c15170-ab09-4d19-b439-867d3e492fce.png)

In the preceding example, we can see that we have lots of open files— `5,220` to be specific.

1.  To check which user is looking at what files and which commands are being run by the user, we can use the following command:

```
    lsof -i -u tajinder
```

![](img/0c070a25-f1c2-4e19-9641-285c260dfa9d.png)

We have many more options while using `lsof`, which can be explored by referring to the main page of the `lsof` command.

# How it works...

Simply running the `lsof` commands gives us a list of all the open files on the system. By using the `-u` option and specifying the username, we get a list of open files for a particular user.

When we use the `-i` option and specify a port number, we get information about any process running on that port.

When we use both the `-i` and `-u` options with a particular username, we get information about the files and commands being accessed by that user.

# Using System tools – strace

When running any command or program on our Linux machine, we might wonder what the background working of it is. For this, we have a very useful tool in Linux called `strace`.

It's a command-line tool which can be also used as a diagnostic or debugging tool. Strace monitors the interaction between the processes, and the Linux kernel and is helpful when we would like to debug the execution of any program.

# Getting ready

This tool is available for all Linux-based systems by default. Hence, nothing else needs to be configured to start using `strace`.

# How to do it...

Let's see how strace can be used in various ways to trace the execution of any program, from start to end:

1.  To trace the execution of any executable command in Linux, simply run the `strace` command followed by the executable command. If we use `strace` for the `ls` command, we get the following output:

![](img/0cadc136-188a-4aeb-9b8c-0d4a6b6d48d1.png)

2.  In the preceding screenshot, the output displayed has been truncated. If we check the last few lines of the output, we can see that the write system calls where the listing of the current directory is displayed:

![](img/1db52f0e-6e30-454a-8477-b0b9a1efb3ff.png)

3.  To check the listing, we can run `ls` alone in the same directory, and we will see the same listing as we saw in the previous screenshot:

![](img/e4a6afaf-fa16-40a2-88fc-853b197b390c.png)

4.  If we want to have a statistical summary of the strace command displayed in a neat manner, we can use `-c` option, as follows:

```
    strace -c ls
```

![](img/11d12a1f-644b-4b24-911e-933dc352991f.png)

5.  We can also display the timestamp at the start of each output line by using the `-t` option, as follows:

![](img/ff16445a-6018-4d89-9d90-ad6a16a05a18.png)

6.  The default strace command displays all the system calls made by the executable program. If we wish to show only a specific call, we can use the `-e` option. So, if we want to see the open system call of the `ls` command, we have to run the following command:

```
    strace -e open ls
```

![](img/bc0c4e01-fe7d-4052-a764-796a7f209733.png)

7.  If we wish to save the output of the strace command in a file for viewing it later, we can do so by using the `-o` option, as follows:

```
    strace -o output.txt ls
```

![](img/993c2e7b-b29b-46c8-898a-2147d202f9d0.png)

Here, `output.txt` is the name of the file which will be created to save the output of the `strace` command.

8.  If we want to use `strace` on any process which is currently running, we can do so by using the process ID of the process. In our example, we are using the process of Firefox process , whose ID is `16301`.

We can run the following command and also save the output of the command in the `firefox_output.txt` file using the `-o` option:

![](img/19d967a6-7df5-4470-bfae-969f42d0d9d5.png)

9.  We can then check the content of the output file by using the `tail` command or any text editor of our choice.

# How it works

When the `strace` command is used on any other Linux command or program, it traces its interaction with the Linux kernel.

When the `-c` option is used with `strace`, we get a statistical summary, and if the`-t` option is used, we get a timestamp preceding each output line.

Using the `-e` option, we can see a specific call of program execution, like open system calls. By using the `-o` option, we write the output of the strace command to a file.

# Real time IP LAN monitoring using IPTraf

IPTraf is a tool used for network monitoring. It allows us to analyse the incoming and outgoing network traffic of our Linux server. IPTraf can also be used to analyse the traffic over the LAN, or find the bandwidth's utilization.

# Getting ready

IPTraf is a part of the Linux distribution and can be installed using the default repositories of Linux. If we are using an Ubuntu system, you can use `apt-get` to install the IPTraf package, as follows:

```
 apt-get install iptraf
```

**![](img/fb75eb41-da7f-48d4-8a4d-b66c4c408ffe.png)**

# How to do it...

Using `Iptraf` is very simple. Once installed, it can be launched from the terminal just by running a simple command. Let's explore how the tool works:

1.  To start `Iptraf`, just type the following command in the Terminal:

```
Iptraf    
```

2.  This will launch an ASCII-based menu interface. Press any key to continue.

3.  In the next screen, we will get a menu system with different options to choose from, as follows:

![](img/107ec998-9ff3-4a67-9ee8-84405666afb8.png)

4.  We will choose the first option, IP traffic monitor, and press *Enter*. This will ask us to select the interface on which we want to listen for the traffic:

![](img/651aace3-7918-47f8-a15d-42b905a423f8.png)

We will choose `eth0` in the preceding list and press *Enter*.

5.  IPTraf will now show us all the TCP and UDP connections happening on the `eth0` interface. The upper part of the window shows the TCP connections and the lower part shows the UDP packets:

![](img/dea38f2e-9d0d-46e7-abde-cd8e272c2451.png)

6.  Press *X* to come back to the previous menu. Let's select the Statistical breakdowns option from the menu and press *Enter*:

![](img/a333f084-d172-4474-a52c-3f68b9c5136d.png)

7.  This function allows us to sort the packets by TCP/UDP ports. We can also sort packets by size:

![](img/9dfbe0ff-2b40-4822-a33a-a2aa681f42eb.png)

8.  Exit to the main menu, choose the Configure option, and press *Enter*. Here, we configure how our tool should work. We can enable or disable settings like Reverse DNS Lookups, Service names, promiscuous mode and so on:

![](img/25f32fdb-2792-4378-8032-272a365d1013.png)

In the preceding screenshot, we have enabled Reverse DNS lookups.

9.  After enabling Reverse DNS lookups when we monitor the traffic, we can see that the output contains the DNS names instead of just the IP addresses:

![](img/e58f3153-d919-4218-b98c-b9c6d0233101.png)

10.  If we want to save the history of network monitoring, we can enable Logging in the Configure menu:

![](img/f617b487-1415-463f-b6ab-c7eb92a8b29c.png)

11.  Once Logging is enabled, the tool will ask us to specify a path of the file to which to write the log. We can specify a path or use the default path:

![](img/53dc3f12-9f8e-4f40-9961-9474c43990a2.png)

12.  In the main menu, we have the option to view Detailed interface statistics. Select this option and start monitoring:

![](img/1fde6eea-5898-4563-82f5-27424da4e56e.png)

13.  We can now see complete details about the traffic on the selected interface, eth0, as follows:

![](img/cbe508af-0e5e-4bcb-a696-184f9a698f49.png)

# How it works...

IPTraf is an easy to use tool for monitoring network traffic on an interface. We can configure the tool as per our requirements and even save the traffic log in a file for further analysis.

# Network security monitoring using Suricata

If we want to use a network intrusion detection system on Linux, we can use Suricata, which is a free and open source tool. It can be used to inspect network traffic using its rules and signature language. Suricata can handle multiple gigabits of traffic and display it on screen. It can also send alerts through emails.

# Getting ready

Before starting with the installation and configuration of Suricata, we will need to install a few of its dependency packages. We can install all the required dependencies using the following command:

```
apt-get install libpcre3-dbg libpcre3-dev autoconf automake libtool libpcap-dev libnet1-dev libyaml-dev libjansson4 libcap-ng-dev libmagic-dev libjansson-dev zlib1g-dev 
```

The default working of Suricata is as an Intrusion Detection system. If we wish to use it as an Intrusion Prevention system, we will need some extra packages, which can be installed using the following commands:

```
apt-get install libnetfilter-queue-dev libnetfilter-queue1 libnfnetlink-dev 
```

Once we are done with the installation of the packages, we can download the latest stable version of Suricata from its official website. We can either visit the website using the browser and download the file, or use the following command to download it directly from the Terminal:

![](img/dba903cf-25a9-4f62-948b-052978fee051.png)

# How to do it...

Once we have completed the installation of the dependency packages and downloaded the source file for Suricate, we can begin the installation and configuration part. Let's explore these steps now:

1.  After downloading the source, open the directory where the downloaded file has been saved and then extract the download file using the following command:

![](img/6bace521-95cd-4aab-8301-680908339191.png)

2.  Once the extraction is complete, change the directory to `suricata-4.0.5`, as follows:

![](img/5bd33cc4-eb44-4a29-8ae2-a55a5adef1e6.png)

3.  Now, we will build Suricata with IPS capabilities using the following command:

![](img/0e6049a3-f097-4d72-a77f-e183ccff7acf.png)

4.  Once the build is complete, we will begin with the installation process. First we run the `make` command:

![](img/72f8c8ab-5f19-4b40-af14-0c875526707b.png)

5.  Once the preceding command completes, we can run the next command, which is `make install`:

![](img/377fc88f-e588-4544-a8fe-bb2b298db1c2.png)

6.  Our next step will be to install the default configuration file of Suricata using the following command:

![](img/5ba11896-844b-409d-a786-ea97db32e6e5.png)

7.  Until now, the default installation of Suricata has been completed. However, without rules, the tool is useless. Therefore, we will install the IDS rule set of Suricata by running the following command inside its source directory, which we extracted earlier:

![](img/d99511f9-1bf0-47e1-aab7-2234b82fbcef.png)

8.  We can check for all the installed rule sets by listing the files inside the `/etc/suricata/rules` directory:

![](img/50d7859d-ee4c-4b95-b8bf-3440d4e39a03.png)

9.  Now, let's configure the tools for our use by editing the `/etc/suricata/suricata.yaml` configuration file. Edit the `HOME_NET` variable and add the details as per our infrastructure requirements. I have added the IP address of the Ubuntu server on which our tool is installed. By doing this change, Suricata will alert us to any attack to `HOME_NET`, which refers to our Ubuntu server:

![](img/3a2a5b24-5c9a-4205-ae54-cfaa55d41afc.png)

10.  Now, we will create a test rule set for testing Suricata. To do this, we will create a file called `for_test.rules` inside the `/etc/suricata/rules` directory, and we will add the following lines inside:

![](img/c8e79e49-58e6-4041-a2f8-2adb54d573c8.png)

11.  The next step is to define the path of the rule file, created in the preceding step, in the `suricata.yaml` configuration file:

![](img/0b72acc1-8c0d-459a-9fe8-9cdd3e17cec0.png)

We have added `for_test.rules` under the `rule-files` section.

12.  Once everything is set, it is recommended to turn off the packet offload feature on the NIC, on which Suricata is listening. To do this, we can run the following command:

```
ethtool -K ens33 gro off
```

13.  Finally, we will start Suricata in live mode using the following command:

![](img/951284e4-dfae-49d8-8b33-84af4ea6e893.png)

Our IDS is now up and listening on the `ens33` interface,

14.  Now, let's test if everything is working fine. We will try to ping our Ubuntu server on which Suricata is running.
15.  Now, let's check the logs on our Suricata server using the following command:

![](img/c0e1ef19-4378-452a-b5ce-c9251fbffe38.png)

If Suricata is working properly, we will get an output like the one shown in the preceding screenshot.

# Network monitoring using OpenNMS

When we want to monitor unlimited devices in our network at a single instance, we can use OpenNMS. It's an open source and free network monitoring web application system and helps in detecting and monitoring services or nodes automatically in the network. More devices or nodes can also be added to OpenNMS easily.

# Getting ready

To configure OpenNMS, we will be using the Ubuntu server, which has been updated to the latest stable version. Once we are done with updating the server, we need to make a few configurations to get our system ready for installing and configuring OpenNMS:

1.  To begin, we will edit the `/etc/hosts` file to set a proper and fully qualified domain name for our server:

![](img/a9c5b4bd-2215-4dbb-9763-21ef08c6be1c.png)

Here, we have added `example.OpenNMS.local` as the domain name for our server.

2.  Next, we edit `/etc/hostname` and update the same domain name:

![](img/7c456183-90fd-4ab9-b7af-1c9fe0511c87.png)

3.  OpenNMS uses PostgreSQL for its database purposes. Hence, we will install PostgreSQL using the following command:

![](img/d2a8db93-8262-457c-9dfe-99e20e5bd50d.png)

4.  Once the installation completes, we will allow user access to the database for our root account by editing the `/etc/postgresql/9.5/main/pg_hba.conf` file:

![](img/5b866c62-fe00-483a-b95f-2f09e8d0cca5.png)

Once done with these changes, save and close the file.

5.  Now, restart PostgreSQL and enable it so that it can start on boot. Use the following command to do this:

![](img/c54bba10-e396-42e5-811c-0da4b9f9c9e8.png)

6.  Our next step is to install Java. For this, we will first add PPA to the `apt` source list, as follows:

![](img/a294dcee-3d25-4b11-b96a-82ee51d7844f.png)

7.  Then, we will update the repository by running the `apt-get update` command. Once done, we will begin the installation of Java using the following command:

![](img/77a86e0c-8535-46b0-87f1-6877fbc55ba9.png)

8.  Once installation completes, we can check the version of Java using following command:

![](img/c6d639e6-eaf0-4194-9769-025a36017727.png)

Now, we have our system ready to begin with the installation and configuration of OpenNMS.

# How to do it...

Once we are done with the prerequisites mentioned in the preceding *Getting ready* section, we can now begin with the installation and configuration of OpenNMS:

1.  OpenNMS is not available in the default repository of Ubuntu. Hence, we have to add the repository of OpenNMS in the `/etc/apt/sources.list.d` directory. To do this, we can run the following command:

```
nano /etc/apt/sources.list.d/opennms.list
```

2.  Add the following lines in the `/etc/apt/sources.list.d/opennms.list` directory:

![](img/5bbb777d-2e7a-4037-86ce-e6d55040b9f4.png)

Once done, we will save and close the file.

3.  Now, we will add the OpenNMS key by running the following command:

![](img/94f1cf59-f49a-4da5-8fd9-c05781b53446.png)

4.  Next, update the repository using the `apt-get update` command:

![](img/523dad7c-b31a-4cf1-9ab8-a08878975244.png)

5.  We can now install OpenNMS using the following command:

![](img/22bc248e-14c9-48eb-9f6e-396d5d2c9704.png)

6.  When the installation completes, we will see the following screen:

![](img/c2776670-1eaa-49c4-b247-285b0a0a351f.png)

7.  As mentioned previously, we will now run the command to create a database for OpenNMS, as follows:

![](img/b3164d77-d9ea-4643-8bd3-8a02172a4d48.png)

The following is the output, which is truncated:

![](img/a08142df-c86b-4c37-9ed7-74ec11dea556.png)

8.  Let's restart OpenNMS now:

![](img/d43199c6-44a3-4fcb-9285-69196636ba19.png)

9.  Let's enable the UFW firewall, if it is not already enabled, to allow the port for OpenNMS:

![](img/684d2886-7dbb-49c5-b6dc-92e92babd207.png)

Our UFW firewall is now enabled on our server.

10.  As OpenNMS runs on port `8980`, we will not allow this port through the UFW firewall by using the following command:

![](img/16914c7a-c82d-4b2a-9714-39e203374fa7.png)

11.  When we check the status of UFW, we can see that the rule has been added for port `8980`:

![](img/a26951f0-cc0c-456c-abd0-d0e6b780a707.png)

12.  Now, open the browser and access OpenNMS by typing the URL `http://<IP Address>:8980`. We should get the following screen:

![](img/3f186ced-714b-475f-9548-723c54e2be8d.png)

Login with the default username, `admin`, and default password, `admin`, to start using OpenNMS.

13.  Once logged in, we will get the following screen:

![](img/9bb3539c-69dc-4de9-bb64-ded105314ab9.png)

14.  We can add a new server node for monitoring in OpenNMS by clicking on Admin on the top-right and then choosing Quick-Add note from the drop-down menu.

15.  We will get the following screen so that we can add the new server node. Enter the necessary details to complete the process:

![](img/c40aa8b1-5470-4289-82e7-517ca6a5e8e3.png)

16.  Once we are done with adding the node, we can click on Info and then Nodes. You can find out the newly added node by referring to the label. Here, we can see the node's status, notifications, and events information.

# How it works

OpenNMS is used for monitoring multiple servers and nodes in a network.

To install and configure OpenNMS, we need to first install PostgreSQL and Java. We also have to make changes in the `/etc/hosts` and `/etc/hostname` files to set up a fully qualified domain name so that we can use OpenNMS properly in the network.

Once these changes are done, we will install and configure OpenNMS for use.