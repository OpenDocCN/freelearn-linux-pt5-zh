<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Creating a Server Policy"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating a Server Policy</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the service</li><li class="listitem" style="list-style-type: disc">Choosing resource types wisely</li><li class="listitem" style="list-style-type: disc">Differentiating policies based on use cases</li><li class="listitem" style="list-style-type: disc">Creating resource-access interfaces</li><li class="listitem" style="list-style-type: disc">Creating exec, run, and transition interfaces</li><li class="listitem" style="list-style-type: disc">Creating a stream-connect interface</li><li class="listitem" style="list-style-type: disc">Creating the administrative interface</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Introduction</h1></div></div></div><p>Desktop application policies protect a user from vulnerabilities within the application or from unwanted behavior exerted by the application. On a server, however, the impact can be much larger. Server policies are used to protect the entire system from unwanted behavior, abusive access by users, or exploited vulnerabilities within the application.</p><p>Services also have a long lifetime. Unlike desktop applications, which usually start up and shut down together with the users' daily work cycle, services tend to run nonstop, 24/7. This not only provides a larger time window to try and exploit these services, but also happens in the background with services that the administrator might not be actively watching.</p></div></div>
<div class="section" title="Understanding the service"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Understanding the service</h1></div></div></div><p>The first <a id="id332" class="indexterm"/>aspect of designing server policies is to understand the service at hand. Each service has its own internal architecture, and understanding how the various processes and resources interact with each other is extremely important.</p><p>Only when the internal architecture is fully understood will we be able to create a properly functioning policy. Otherwise, we risk that the policy will be too broad (too many access rights) or too restricted. Unlike applications, which are usually easy to test from an end user point of view, services often have activities that are much harder to test (or even consider).</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec111"/>How to do it…</h2></div></div></div><p>Just like with desktop applications, understanding the application behavior is of key importance to create good SELinux policies. Research into and analysis of the behavior can be done by<a id="id333" class="indexterm"/> performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Research the service at large by looking for online architecture drawings or architecture documentation.</li><li class="listitem">Try to explore the service in a sandbox environment.</li><li class="listitem">Follow some tutorials for the service with relation to both administration tasks as well as end user tasks.</li><li class="listitem">Structurally document how the service should be used.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec112"/>How it works…</h2></div></div></div><p>Understanding a service means to get some degree of experience with the administration of the service. Trying to create a server policy for a specific database technology, but not knowing how this database technology works, will be almost impossible.</p><div class="section" title="Online research"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec29"/>Online research</h3></div></div></div><p>Most <a id="id334" class="indexterm"/>services have well documented architectural information available online. By using an Internet search engine, we can easily come <a id="id335" class="indexterm"/>to the architecture information for a particular service.</p><p>While developing service policies, it is considered a best practice that the types and domains are named similar to the functional services that are used. For instance, in a Postfix architecture, functional services such as <code class="literal">pickup</code>, <code class="literal">cleanup</code>, <code class="literal">smtpd</code>, <code class="literal">qmgr</code>, and many more are basic services that a Postfix administrator has to deal with. In SELinux policies, we should try to have the domains labeled similarly (so the domain will be labeled <code class="literal">postfix_qmgr_t</code> for the <code class="literal">qmgr</code> service, <code class="literal">postfix_spool_maildrop_t</code> for the <code class="literal">maildrop</code> queue, and so on).</p></div><div class="section" title="Sandbox environment"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec30"/>Sandbox environment</h3></div></div></div><p>Being <a id="id336" class="indexterm"/>able to play around with a service in a sandbox<a id="id337" class="indexterm"/> environment allows us to see the interactions at hand. It also allows us to follow online tutorials or administration guides to get to know the service.</p><p>There are many technologies available nowadays to play around with technologies. Virtualization allows users to run complete systems in an isolated environment and has led to the creation of virtual appliances.</p><p>Virtual<a id="id338" class="indexterm"/> appliances are virtual images that can be easily installed<a id="id339" class="indexterm"/> in a virtualized environment. However, a pure virtualization still requires users to install an operating system, install the service, and configure it before really starting to use it; virtual appliances provide preconfigured systems that host one or more services out of the box.</p><p>Next to virtualization, containers are also starting to play a large role. Unlike virtualization, software running inside containers is isolated from other software but is still part of the operating system itself.</p></div><div class="section" title="The structural documentation"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec31"/>The structural documentation</h3></div></div></div><p>After <a id="id340" class="indexterm"/>having a thorough read through the architecture <a id="id341" class="indexterm"/>of the application and perhaps even playing around with the software, we might need to document the architecture of the service further in order to deduce the right SELinux types and resources, as well as interfaces and roles related to the service.</p><p>In order not to forget anything important, the logical architecture of a service can be documented <a id="id342" class="indexterm"/>using the <span class="strong"><strong>FAMOUS</strong></span> abbreviation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Feeds</strong></span>: This tell<a id="id343" class="indexterm"/>s us which external resources <a id="id344" class="indexterm"/>provide input to the service in a more-or-less batch-oriented approach as well as which external resources the service interacts with.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Administration</strong></span>: This informs us <a id="id345" class="indexterm"/>how the service is administered (command-line interfaces, user<a id="id346" class="indexterm"/> interfaces, or other applications).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Monitoring</strong></span>: This <a id="id347" class="indexterm"/>informs us <a id="id348" class="indexterm"/>about logfiles used or commands that are supported to verify the state of the service.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Operations</strong></span>: This <a id="id349" class="indexterm"/>documents the <a id="id350" class="indexterm"/>day-to-day runtime behavior of all the processes (and the flows, using the CRUD method—Create, Read, Update, Delete). This is usually the architecture information found earlier during the online research phase.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Users and rights</strong></span>: This documents how<a id="id351" class="indexterm"/> users are defined and managed in the service. This also <a id="id352" class="indexterm"/>documents which authentication or authorization backends are used, how different roles within the service behave, and so forth.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Security-related features</strong></span>: These tell us about security-related features such as <a id="id353" class="indexterm"/>application-based <a id="id354" class="indexterm"/>access controls, firewall requirements (which in our case are important for the policy network rules), and so forth.</li></ul></div><p>With this information at hand, we can have a clear overview of how the service behaves. For instance, a high-level view of the PostgreSQL database service looks like the following diagram:</p><div class="mediaobject"><img src="graphics/9669OS_05_02.jpg" alt="The structural documentation"/></div><p>Such a<a id="id355" class="indexterm"/> drawing helps us to identify types later on, both for<a id="id356" class="indexterm"/> the processes as well as the resources involved. Any interactions with the service provided by third-party services is shown as well, as these interactions will result in privileges that need to be assigned to the other processes (that is, interfaces in the SELinux policy).</p><p>It is not easy to document how a service works without understanding the service at hand. Because of the complexity of the service, it is a good practice to get experts or developers of the service together and guide us in understanding the service. These developers and engineers can later be used to challenge the SELinux policy that is being written.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec113"/>See also</h2></div></div></div><p>A <a id="id357" class="indexterm"/>nonexhaustive list of open source virtual appliance providers is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Artica (<a class="ulink" href="http://www.artica.fr">http://www.artica.fr</a>) for <a id="id358" class="indexterm"/>proxy, mail, and NAS appliances.</li><li class="listitem" style="list-style-type: disc">Turnkey Linux (<a class="ulink" href="http://www.turnkeylinux.org/">http://www.turnkeylinux.org/</a>) offers more than a hundred <a id="id359" class="indexterm"/>ready-to-use solutions.</li><li class="listitem" style="list-style-type: disc">Vagrant (<a class="ulink" href="http://www.vagrantup.com/">http://www.vagrantup.com/</a>) is a management platform for virtual <a id="id360" class="indexterm"/>systems, and has a large community of Vagrant boxes that provide virtual appliance-like setups for many free software services.</li><li class="listitem" style="list-style-type: disc">Docker (<a class="ulink" href="https://www.docker.io/">https://www.docker.io/</a>) is not a true virtualization setup, but rather a <a id="id361" class="indexterm"/>container-based approach. From the Docker Index (<a class="ulink" href="https://index.docker.io/">https://index.docker.io/</a>), many containers can be freely downloaded.</li></ul></div><p>Many <a id="id362" class="indexterm"/>commercial technologies also provide development <a id="id363" class="indexterm"/>virtual machines to deploy. Virtualization technology providers such as VMware® have solution-exchange communities, where virtual images for various technologies are freely available.</p></div></div>
<div class="section" title="Choosing resource types wisely"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Choosing resource types wisely</h1></div></div></div><p>Services<a id="id364" class="indexterm"/> interact with resources, and the label that we assign to the resources is used by the fine-grained access controls assigned to these resources. End user files (for users that have a Linux account on the system) are labeled as <code class="literal">user_home_t</code>, which suffices for most uses. However, when we deal with services, the choice of the resource label defines if and how other applications can access those resources and is much more fine-grained than what we currently use for end user files.</p><p>There are some best practices concerning resource type selection within SELinux policies, which we will now look into.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec114"/>How to do it…</h2></div></div></div><p>The service resource types need to be carefully chosen. Their naming implies the functional use of the resource, which already pushes the development of the policy in a certain structure. The types and their affiliated permissions can be developed by completing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Look for the processes that will run within their own specific domain and create the domain types. For each domain, look for the entry files of that domain and create an <code class="literal">_exec_t</code> type. Mark the type as either an init daemon type (when the service is launched through a service script) or a D-Bus daemon (when the service is launched through the D-Bus service). For instance, for the BIND service:<div class="informalexample"><pre class="programlisting">type named_t;
type named_exec_t;
init_daemon_domain(named_t, named_exec_t)</pre></div></li><li class="listitem">Look for all sets of logical resources that are used by the application. These are often files specific to the service architecture (such as database files for a database service), but shouldn't be limited to files only.</li><li class="listitem">Create specific types for these resources. For instance, for the Qemu virtual guest images:<div class="informalexample"><pre class="programlisting">type qemu_image_t;
files_type(qemu_image_t)</pre></div></li><li class="listitem">Grant <a id="id365" class="indexterm"/>the domains the proper access to these resources. For instance, the <code class="literal">qemu</code> process (running as <code class="literal">qemu_t</code>) will need manage rights on the images:<div class="informalexample"><pre class="programlisting">manage_files_pattern(qemu_t, qemu_image_t, qemu_image_t)</pre></div></li><li class="listitem">Go through the infrastructural resources (PID files, logfiles, and configuration files) and label these accordingly. For instance, for the <code class="literal">named</code> variable, the runtime data will be named as follows:<div class="informalexample"><pre class="programlisting">type named_var_run_t;
files_pid_file(named_var_run_t)</pre></div></li><li class="listitem">Grant the domains the proper access to these resources, and if possible, enable a proper file transition:<div class="informalexample"><pre class="programlisting">allow named_t named_var_run_t:file manage_files_perms;
allow named_t named_var_run_t:sock_file manage_sock_file_perms;
files_pid_filetrans(named_t, named_var_run_t, { file sock_file });</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec115"/>How it works…</h2></div></div></div><p>An application policy always provides a common set of privileges. It starts with proper domain definitions (showing how the policy will be structured) and is followed by the resource access patterns. Resources can be functional in nature (specific to the application that is being investigated for the policy) or more infrastructural (such as logfiles and configuration files).</p><div class="section" title="Domain definitions"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec32"/>Domain definitions</h3></div></div></div><p>Service domains<a id="id366" class="indexterm"/> are used to identify long-running <a id="id367" class="indexterm"/>processes that have a similar functional scope. An example could be the BIND named process (which is defined as <code class="literal">named_t</code>) or the Apache <code class="literal">httpd</code> processes (which are all running as <code class="literal">httpd_t</code>).</p><p>These service domains are usually launched from an <code class="literal">init</code> script, which results in the use of the <code class="literal">init_daemon_domain</code> interface. If a service is launched by D-Bus, then the interface to use is <code class="literal">dbus_system_domain</code>. Of course, multiple interfaces can be used: the PPP daemon, for instance, supports both <code class="literal">init</code> scripts and D-Bus.</p><p>If a service daemon is launched by another daemon instead, then it is sufficient to mark the process domain as a domain type and the executable type as the entry point:</p><div class="informalexample"><pre class="programlisting">type postfix_bounce_t;
type postfix_bounce_exec_t;
domain_type(postfix_bounce_t)
domain_entry_file(postfix_bounce_t, postfix_bounce_exec_t)</pre></div><p>In this case, we need to provide the parent domain (in our case, <code class="literal">postfix_master_t</code>) the rights to execute (<code class="literal">postfix_bounce_exec_t</code>) and transition (to <code class="literal">postfix_bounce_t</code>):</p><div class="informalexample"><pre class="programlisting">domtrans_pattern(postfix_master_t, postfix_bounce_exec_t, postfix_bounce_t)</pre></div></div><div class="section" title="Logical resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec33"/>Logical resources</h3></div></div></div><p>The <a id="id368" class="indexterm"/>logical resources are the files that are specific to <a id="id369" class="indexterm"/>the applications' functional design. For instance, a virtualization layer such as Qemu will have a logical resource for the image files (<code class="literal">qemu_image_t</code>). The logical resources for a web server have already been discussed in an earlier chapter (such as <code class="literal">httpd_sys_content_t</code> for standard system read-only web content).</p><p>Such resources are declared as regular file resources and the proper permissions are granted to the various domains. Further down the document, when privileges for the <code class="literal">qemu_t</code> domain are summed up, the <code class="literal">manage_files_pattern</code> line can be added to allow the <code class="literal">qemu_t</code> domain to manage the images.</p><p>By making separate labels for each of the logical resources, we can create interfaces for other processes that might need to interact with these resources without having to grant those applications too many privileges.</p><p>Think of a backup application, such as Amanda. The actual backup data itself (<code class="literal">amanda_data_t</code>) should only be accessible by the Amanda application. Other service administrators on the same system should not have access to these files—backups can contain sensitive information, so only the backup tool itself should have access to this data. Even the backup administrators, who need to manage the backup infrastructure, might not need direct access to this data.</p></div><div class="section" title="Infrastructural resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec34"/>Infrastructural resources</h3></div></div></div><p>Infrastructural<a id="id370" class="indexterm"/> resources are file types that are<a id="id371" class="indexterm"/> often set for applications.</p><p>Logfiles are marked through the <code class="literal">logging_log_file</code> interface and usually end with the <code class="literal">_log_t</code> suffix, such as <code class="literal">amanda_log_t</code>. By marking it as a logfile, domains that are assigned an operation concerning all logfiles (such as <code class="literal">logging_read_all_logs</code>) automatically have these privileges on the newly defined type. Often, a file transition is set so that files created in <code class="literal">/var/log/</code> automatically get the right type. This is done through the <code class="literal">logging_log_filetrans</code> interface:</p><div class="informalexample"><pre class="programlisting">type amanda_log_t;
logging_log_file(amanda_log_t)
# Directories created by amanda_t domain in /var/log (var_log_t) get the amanda_log_t type:
logging_log_filetrans(amanda_t, amanda_log_t, dir)</pre></div><p>Configuration files are marked as regular files (through <code class="literal">files_type</code>) and end with either <code class="literal">_conf_t</code> or <code class="literal">_etc_t</code>. Some policy developers like to use <code class="literal">_conf_t</code> for real configuration files and <code class="literal">_etc_t</code> for other miscellaneous files in the <code class="literal">/etc/</code> directory structure that are not direct configuration files. In most cases though, this is only for semantic reasons as all related domains need the same set of privileges on both types.</p><p>Temporary files are marked through the <code class="literal">files_tmp_file</code> interface and end with the <code class="literal">_tmp_t</code> suffix. A file transition is almost always put in place to ensure that the temporary files are properly labeled:</p><div class="informalexample"><pre class="programlisting">type amanda_tmp_t;
files_tmp_file(amanda_tmp_t)
# All files, directories and symbolic links created by amanda_t in a tmp_t location should get the amanda_tmp_t label:
files_tmp_filetrans(amanda_t, amanda_tmp_t, { dir lnk_file file })</pre></div><p>PID files and other generic run files are usually labeled ending with <code class="literal">_var_run_t</code> and are marked as a PID file through the <code class="literal">files_pid_file</code> interface. As with logfiles, a file transition is usually put in place as well:</p><div class="informalexample"><pre class="programlisting">type amanda_var_run_t;
files_pid_file(amanda_var_run_t)
# Files and sockets created in /var/run should become amanda_var_run_t:
files_pid_filetrans(amanda_t, amanda_var_run_t, { file sock_file })</pre></div><p>Other variable data that is not given a logical resource name is often labeled ending with <code class="literal">_var_lib_t</code>. Such files are marked as regular files (using <code class="literal">file_type</code>) and a file transition can be defined using <code class="literal">files_var_lib_filetrans</code>.</p></div></div></div>
<div class="section" title="Differentiating policies based on use cases"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Differentiating policies based on use cases</h1></div></div></div><p>As services <a id="id372" class="indexterm"/>mature, they often gain more <a id="id373" class="indexterm"/>features, which might not always be necessary. For instance, daemons that are able to optionally connect to various network resources depending on their configuration should not be allowed by the SELinux policy to always connect to various network resources.</p><p>To govern these features, SELinux policy developers include Booleans to selectively toggle policies based on the administrator's requirements.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec116"/>How to do it…</h2></div></div></div><p>Booleans allow policy developers to create policy rules that only participate in access control when the administrator has elected to use them. For services in particular, this is often used to optionally allow privileges based on the use case of the service and is implemented as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Identify the policy blocks that should be marked as optional, depending on the configuration. For instance, this could be a set of policy rules that allow PostgreSQL to connect to other PostgreSQL databases:<div class="informalexample"><pre class="programlisting">corenet_tcp_connect_postgresql_port(postgresql_t)
corenet_sendrecv_postgresql_client_packets(postgresql_t)</pre></div></li><li class="listitem">For each block, create a well-chosen SELinux Boolean that administrators can easily identify as the right Boolean to toggle for their specific use case. For instance, we can create a <code class="literal">postgresql_connect_db</code> Boolean:<div class="informalexample"><pre class="programlisting">## &lt;desc&gt;
##   &lt;p&gt;
##     Determine if the PostgreSQL daemons can connect to other databases.
##   &lt;/p&gt;
## &lt;/desc&gt;
gen_tunable(postgresql_connect_db, false)</pre></div></li><li class="listitem">Surround the policy blocks that need to be toggled with a <code class="literal">tunable_policy</code> statement for the chosen SELinux Boolean, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>tunable_policy(`postgresql_connect_db',`</strong></span>
  corenet_tcp_connect_postgresql_port(postgresql_t)
  corenet_sendrecv_postgresql_client_packets(postgresql_t)
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec117"/>How it works…</h2></div></div></div><p>Although we shouldn't over-tune policies by generating dozens of Booleans, isolating functionality that is often abused in exploits is a good practice.</p><p>Consider a database engine. Databases can have features that allow them to connect to other databases (for instance, to set up database links or support some kind of cluster), but in many situations, these features are not needed. If a database is compromised (through SQL injection, for instance), it is better to make sure that this database cannot access other databases (so the compromised database is sufficiently contained).</p><p>The configuration that toggles this behavior in a PostgreSQL setup could be named <code class="literal">postgresql_connect_db</code> (for database-specific connections) or <code class="literal">postgresql_connect_all_ports</code> (for any target connection) and developed as shown in the previous example (the example includes the in-line comment documentation that would be used if the policy is meant to become part of the distribution policy or reference policy project).</p><p>Accessing <a id="id374" class="indexterm"/>other resources on the network is <a id="id375" class="indexterm"/>a common feature that, if it is not part of the standard behavior of the application, should be considered for making optional.</p><p>There are many other use cases that should be considered. Here is a nonexhaustive list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An application that can optionally execute system scripts or user-provided scripts should be governed through an <code class="literal">_exec_scripts</code> or <code class="literal">_exec_user_scripts</code> Boolean.</li><li class="listitem" style="list-style-type: disc">Allowed domain transitions to higher-privileged domains or increased privileges due to some functionality is usually governed through <code class="literal">_use_*</code> Booleans. For instance, a domain optionally supporting Java can have a <code class="literal">_use_java</code> Boolean.</li><li class="listitem" style="list-style-type: disc">Access to specific filesystems or devices is also governed through <code class="literal">_use_*</code> Booleans, such as <code class="literal">_use_cifs</code> (for SMB-CIFS filesystems) or <code class="literal">_use_nfs</code>.</li><li class="listitem" style="list-style-type: disc">Functional support (such as Nginx support for various protocols) can be made optional through <code class="literal">_enable_*</code> Booleans, such as <code class="literal">nginx_enable_imap_server</code> or <code class="literal">nginx_enable_pop3_server</code>.</li></ul></div></div></div>
<div class="section" title="Creating resource-access interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Creating resource-access interfaces</h1></div></div></div><p>With all the <a id="id376" class="indexterm"/>resources defined, we now need to ensure that other domains can use those resources as needed. As we've seen, resources can be functional in nature (specific to a service) or more infrastructural (such as logfiles).</p><p>Access to resources is provided through SELinux policy rules that need to be provided through access interfaces. These interfaces are then used by third-party SELinux policy modules to document and allow access to the resource types. Without the access interfaces, the resource types we define are not easily accessible by other policy developers.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec118"/>How to do it…</h2></div></div></div><p>To create resource-access interfaces, add the proper interface definition in the module's <code class="literal">.if</code> file. For instance, to create a set of resource interfaces to access ClamAV's configuration files, follow the next set of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For<a id="id377" class="indexterm"/> each resource, create an overview of the privileges that will be needed. For file class resources, these are often search, read, write, and manage privileges. In case of logfiles, some applications only need append privileges (which ensures that they cannot modify existing data, only add data to it).</li><li class="listitem">Create the interface in the module's <code class="literal">.if</code> file and ensure that it is properly documented, as shown in the following code:<div class="informalexample"><pre class="programlisting">##########################################
## &lt;summary&gt;
##   Read clamav configuration files
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain allowed access
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`clamav_read_config','
  gen_require(`
    type clamd_etc_t;
  ')
  files_search_etc($1)
  allow $1 clamd_etc_t:file read_file_perms;
')</pre></div></li><li class="listitem">Consider creating a <code class="literal">dontaudit</code> interface as well to assign to SELinux domains that might attempt to perform this action while not needing the privilege:<div class="informalexample"><pre class="programlisting">########################################
## &lt;summary&gt;
##   Do not audit attempts to read the clamd configuration files
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain not to audit
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`clamav_dontaudit_read_config',`
  gen_require(`
    type clamd_etc_t;
  ')
  dontaudit $1 clamd_etc_t:file read;
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec119"/>How it works…</h2></div></div></div><p>The <a id="id378" class="indexterm"/>resource-access interfaces are needed to allow interaction with the SELinux types managed through the SELinux module. The build environment does not have a default set of privilege interfaces that are generated out of the box, so we need to create these interfaces ourselves.</p><p>One might be tempted to only create the resource interfaces that are known to be used in the immediate future. However, it is recommended to create the proper interfaces for all resources and each individually with a coherent set of supported privileges. This is because we never know how the resources will be used by others, and by not creating the proper resources, we are forcing other developers to create their own <code class="literal">my*</code> modules to provide interfaces.</p><p>By covering most access patterns towards the resources, we provide a nice set of interfaces that other developers can use while keeping the interfaces all bound to a single module.</p><p>Even the <code class="literal">dontaudit</code> related interfaces will play an important role for the users of the SELinux policy. When policy developers commit policy improvements to repositories, they usually do not <code class="literal">dontaudit</code> unless they are 100 percent convinced that these will hide cosmetic denials and thus can be ignored. As a result, default SELinux system deployments will have quite a few denials in the audit logs that need to be looked into by the system administrator.</p><p>If the administrator doesn't believe that the denials need to be enabled, then they will need to be able to <code class="literal">dontaudit</code> them. Although the administrator can create the proper interfaces themselves, it is much easier if the <code class="literal">dontaudit</code> interface definitions are already provided.</p></div></div>
<div class="section" title="Creating exec, run, and transition interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Creating exec, run, and transition interfaces</h1></div></div></div><p>Service <a id="id379" class="indexterm"/>domains usually have a few binaries that are executed by <a id="id380" class="indexterm"/>user domains or through other service or application <a id="id381" class="indexterm"/>domains. Each case of these executions need to be properly investigated to see if a domain transition is needed (that is, a specific domain needs to be created for that execution environment) or if the command can run within the privileges of the caller domain.</p><p>From an interface point of view, this is provided through the <code class="literal">_exec</code>, <code class="literal">_run</code>, and <code class="literal">_domtrans</code> interfaces.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec120"/>How to do it…</h2></div></div></div><p>Execution-related interfaces allow for other policy modules to define the interaction with this application. This interaction can be a regular execution, but can also contain a domain transition to switch the application domain to the newly defined one. The set of execution interfaces are created as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For each execution where the application itself needs to run in the caller domain (so no transition has to occur), create an <code class="literal">_exec</code> interface as follows:<div class="informalexample"><pre class="programlisting">#######################################
## &lt;summary&gt;
##   Execute wm in the caller domain
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain allowed access
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`wm_exec',`
  gen_require(`
    type wm_exec_t;
  ')
  corecmd_search_bin($1)
  can_exec($1, wm_exec_t)
')</pre></div></li><li class="listitem">For each execution by a domain that is in the same role as the service (usually, <code class="literal">system_r</code>) and where a transition has to occur, create a <code class="literal">_domtrans</code> interface as follows:<div class="informalexample"><pre class="programlisting">##########################################
## &lt;summary&gt;
##   Execute vlock in the vlock domain
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain allowed to transition
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`vlock_domtrans',`
  gen_require(`
    type vlock_t, vlock_exec_t;
  ')
  corecmd_search_bin($1)
  domtrans_pattern($1, vlock_exec_t, vlock_t)
')</pre></div></li><li class="listitem">For each <a id="id382" class="indexterm"/>execution by a domain that might not have <a id="id383" class="indexterm"/>standard access to the application <a id="id384" class="indexterm"/>domain, and where a domain transition has to occur, create a <code class="literal">_run</code> interface as follows:<div class="informalexample"><pre class="programlisting">#########################################
## &lt;summary&gt;
##   Execute vlock in the vlock domain and allow the specific role the vlock domain
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain allowed to transition
##   &lt;/summary&gt;
## &lt;/param&gt;
## &lt;param name="role"&gt;
##   &lt;summary&gt;
##   Role allowed to access the vlock domain
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`vlock_run',`
  gen_require(`
    attribute_role vlock_roles;
  ')
  vlock_domtrans($1)
  roleattribute $2 vlock_roles;
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec121"/>How it works…</h2></div></div></div><p>The use of <code class="literal">_exec</code>, <code class="literal">_run</code>, and <code class="literal">_domtrans</code> are standard interface patterns in policy development. The <code class="literal">_role</code> interface that we created during desktop application policy development not only includes domain transition and role support, but also resource accesses related to the user domain interacting with the desktop application domain.</p><p>In the <code class="literal">_run</code> interface, the<a id="id385" class="indexterm"/> only set of privileges that is provided is to transition to the right domain and assign the domain to the right role (as part of SELinux role-based access control). It is common practice that the order of the parameters of a <code class="literal">_run</code> interface are the domain first and then the role—unlike the <code class="literal">_role</code> interfaces, where the role comes first and then the domain.</p><p>In a <code class="literal">_domtrans</code> interface, only<a id="id386" class="indexterm"/> the domain transition is enabled. Usually, the <code class="literal">_run</code> interfaces call the <code class="literal">_domtrans</code> interface so that both interfaces are defined and the right one for the job is called by the caller SELinux policy module. But unlike the <code class="literal">_run</code> interfaces, the <code class="literal">_domtrans</code> interfaces do not extend roles and are usually called by other modules for <a id="id387" class="indexterm"/>service domain interaction.</p><p>For<a id="id388" class="indexterm"/> instance, the <code class="literal">procmail_t</code> domain (for the procmail daemon) might<a id="id389" class="indexterm"/> call the <code class="literal">clamscan</code> application (part of the ClamAV setup) needing to transition to <code class="literal">clamscan_t</code>. It does so through the <code class="literal">clamav_domtrans_clamscan</code> interface:</p><div class="informalexample"><pre class="programlisting">optional_policy(`
  clamav_domtrans_clamscan(procmail_t)
')</pre></div><p>Finally, the <code class="literal">_exec</code> interface<a id="id390" class="indexterm"/> allows a domain to execute a binary without any transition. This interface is needed when a binary is labeled as a specific executable type (not <code class="literal">bin_t</code> or <code class="literal">shell_exec_t</code>) as most domains then do not have the privilege to access this file at all, let alone execute it. For instance, the Postfix <code class="literal">local</code> daemon might call the <code class="literal">clamscan</code> executable but does not need to transition, resulting in the following call:</p><div class="informalexample"><pre class="programlisting">optional_policy(`
  clamav_exec_clamscan(procmail_local_t)
')</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec122"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assigning the newly created interfaces to roles is covered in <a class="link" href="ch06.html" title="Chapter 6. Setting Up Separate Roles">Chapter 6</a>, <span class="emphasis"><em>Setting Up Separate Roles</em></span></li></ul></div></div></div>
<div class="section" title="Creating a stream-connect interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Creating a stream-connect interface</h1></div></div></div><p>Be it <a id="id391" class="indexterm"/>through the specific executable types or by the generic <code class="literal">bin_t</code> labeled commands, executions that remain in the caller domain might still require additional privileges to be assigned to the caller domain. These additional privileges could be reading of configuration files or interacting with the main domain through Unix domain sockets or TCP/UDP sockets.</p><p>In this recipe, we'll set up a stream-connect interface (as the other privilege enhancements are already covered through the regular resource-access interfaces or network-access interfaces).</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec123"/>How to do it…</h2></div></div></div><p>Interaction with an application socket can be done either through a socket file or through a named Unix domain socket. This is application-specific, so consulting the application documentation might be necessary up front.</p><div class="section" title="For a Unix domain socket with a socket file"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec35"/>For a Unix domain socket with a socket file</h3></div></div></div><p>If <a id="id392" class="indexterm"/>the stream connection is <a id="id393" class="indexterm"/>through a Unix domain socket with a socket file, the interaction with an application socket can be done by completing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Identify and register the proper types in the <code class="literal">.te</code> file. Socket files usually have the <code class="literal">_var_run_t</code> suffix as they reside in <code class="literal">/var/run/</code>.</li><li class="listitem">Create a stream-connect interface that calls <code class="literal">stream_connect_pattern</code> as follows:<div class="informalexample"><pre class="programlisting">interface(`ldap_stream_connect',`
  gen_require(`
    type slapd_t, slapd_var_run_t;
  ')
  files_search_pids($1)
  stream_connect_pattern($1, slapd_var_run_t, slapd_var_run_t, slapd_t)
')</pre></div></li></ol></div></div><div class="section" title="For an abstract Unix domain socket"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec36"/>For an abstract Unix domain socket</h3></div></div></div><p>If the<a id="id394" class="indexterm"/> stream connection <a id="id395" class="indexterm"/>is through an abstract Unix domain socket (so no socket files are involved), create a stream-connect interface that only provides the <code class="literal">connectto</code> privilege, as follows:</p><div class="informalexample"><pre class="programlisting">interface(`init_stream_connect',`
  gen_require(`
    type init_t;
  ')
  allow $1 init_t:unix_stream_connect connectto;
')</pre></div></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec124"/>How it works…</h2></div></div></div><p>Daemons often provide methods to interact with them. Many services support Unix domain socket-based communication between a client application (which usually runs within the privileges of the caller domain) and the daemon itself.</p><p>In such cases, the daemon itself creates a socket file (usually in <code class="literal">/var/run/</code>) as some sort of access point (applications can also use abstract namespaces, where no socket file is needed anymore) and the caller domain is allowed to write to this socket and through it connect<a id="id396" class="indexterm"/> to the Unix<a id="id397" class="indexterm"/> domain socket held by the daemon. The set of privileges is provided by the <code class="literal">stream_connect_pattern</code> definition and can be visually represented as follows:</p><div class="mediaobject"><img src="graphics/9669OS_05_01.jpg" alt="How it works…"/></div><p>The most important privilege here is the <code class="literal">connectto</code> privilege between the caller domain and the daemon domain. In case of abstract Unix domain sockets, no socket file is used at all and only the <code class="literal">connectto</code> privilege is needed.</p><p>These privileges are then written in the following domain-specific interface that calls the <code class="literal">stream_connect_pattern</code> definition, which provides the proper privileges in one go:</p><div class="informalexample"><pre class="programlisting">~$ seshowdef stream_connect_pattern
define(`stream_connect_pattern',`
  allow $1 $2:dir search_dir_perms;
  allow $1 $3:sock_file write_sock_file_perms;
  allow $1 $4:unix_stream_socket connectto;
')</pre></div><p>If <a id="id398" class="indexterm"/>stream-connection-oriented <a id="id399" class="indexterm"/>applications are used whose binaries are not labeled as <code class="literal">bin_t</code>, then a <code class="literal">_stream_connect</code> interface call is usually seen together with an <code class="literal">_exec</code> interface call.</p></div></div>
<div class="section" title="Creating the administrative interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Creating the administrative interface</h1></div></div></div><p>To end <a id="id400" class="indexterm"/>the SELinux module development for services, we need to create proper role-based interfaces. Whereas the <code class="literal">_role</code> interface is usually for nonprivileged user roles, an <code class="literal">_admin</code> interface is used to provide all the necessary privileges to fully administer a service.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec125"/>How to do it…</h2></div></div></div><p>An administrative interface which we can later assign to the user and role that will administer the environment is created with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a specific <code class="literal">init</code> script type for the <code class="literal">init</code> scripts of the daemon. For instance, for the <code class="literal">virtd</code> daemon inside <code class="literal">virt.te</code>, the following policy rules create the proper <code class="literal">init</code> script type:<div class="informalexample"><pre class="programlisting">type virtd_initrc_exec_t;
init_script_file(virtd_initrc_exec_t)</pre></div></li><li class="listitem">Make sure that this <code class="literal">init</code> script is labeled correctly through the <code class="literal">.fc</code> file:<div class="informalexample"><pre class="programlisting">/etc/rc\.d/init\.d/libvirtd  --  gen_context(system_u:object_r:virtd_initrc_exec_t,s0)</pre></div></li><li class="listitem">Start with a skeleton <code class="literal">_admin</code> interface:<div class="informalexample"><pre class="programlisting">##########################################
## &lt;summary&gt;
##   All rules related to administer a virt environment
## &lt;/summary&gt;
## &lt;param name="domain"&gt;
##   &lt;summary&gt;
##   Domain allowed access
##   &lt;/summary&gt;
## &lt;/param&gt;
## &lt;param name="role"&gt;
##   &lt;summary&gt;
##   Role allowed access
##   &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`virt_admin',`
  gen_require(`
    …
')</pre></div></li><li class="listitem">Identify all the resources that an administrator would need access to. Keep in mind that administrators might need to directly modify files that are otherwise managed through the service-related commands—do not take away this right from administrators. A common pattern to use here is <code class="literal">admin_pattern</code>. Add in the proper rights in the interface (and do not forget to update the <code class="literal">gen_require</code> block at the beginning). Consider the following example:<div class="informalexample"><pre class="programlisting">files_search_tmp($1)
admin_pattern($1, virt_tmp_t)</pre></div></li><li class="listitem">Look <a id="id401" class="indexterm"/>through the administration guides for other operations that administrators might need with regards to processes. Perhaps there are certain signals that could be allowed to be sent to the daemons:<div class="informalexample"><pre class="programlisting"># Allow the admin to run strace or other tracing tools against the daemons
allow $1 virtd_t:process { ptrace signal_perms };
# Allow admins to view all information related to the processes
ps_process_pattern($1, virtd_t)</pre></div></li><li class="listitem">Allow the administrator to run the <code class="literal">init</code> script(s):<div class="informalexample"><pre class="programlisting">init_labeled_script_domtrans($1, virtd_initrc_exec_t)
domain_system_change_exemption($1)
role_transition $2 virtd_initrc_exec_t system_r;
allow $2 system_r;</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec126"/>How it works…</h2></div></div></div><p>The <code class="literal">_admin</code> interface is<a id="id402" class="indexterm"/> meant to contain all the privileges needed for an (otherwise) unprivileged user to administer a service. In essence, this unprivileged user will become privileged for this particular service, gaining just those rights that the user needs in order to manage the service, but nothing more.</p><p>We start by defining a particular <code class="literal">init</code> script type for the service. By default, the <code class="literal">init</code> scripts are labeled <code class="literal">initrc_exec_t</code> and only the system administrator is allowed to execute them. As we do not want to give a specific service administrator the privileges to execute any <code class="literal">init</code> script, we create a specific script type (<code class="literal">_initrc_exec_t</code>) and then allow the user, through the <code class="literal">_admin</code> interface, to execute that particular script type.</p><p>The latter, however, is more than just creating execute rights (which is done through the <code class="literal">init_labeled_script_domtrans</code> call). Executing the script also means that the script itself has to run in the <code class="literal">system_r</code> role. If we do not enforce this, then the script would (attempt to) run in the role of the caller domain (such as <code class="literal">virtadm_r</code>) and fail, as the <code class="literal">initrc_t</code> domain (the type used for the <code class="literal">init</code> scripts) is not allowed for the <code class="literal">virtadm_r</code> role.</p><p>Transitioning a role upon executing a file is done through the <code class="literal">role_transition</code> directive. In our example, we configure that the user role (such as <code class="literal">virtadm_r</code>) transitions to the <code class="literal">system_r</code> role upon executing <code class="literal">virtd_initrc_exec_t</code>:</p><div class="informalexample"><pre class="programlisting">role_transition $2 virtd_initrc_exec_t system_r;</pre></div><p>We need<a id="id403" class="indexterm"/> to allow the <code class="literal">system_r</code> role for the given user role as well, which is done through the <code class="literal">allow $2 system_r</code> call. But even that is not sufficient.</p><p>SELinux has a constraint in place that prevents transitions to <code class="literal">system_r</code>, as the <code class="literal">system_r</code> role is used for all system services and, as such, is a highly privileged role. The constraint is defined so that only specific domains can trigger a transition to <code class="literal">system_r</code>. With the <code class="literal">domain_system_change_exemption</code> call, we mark the user domain as one of these domains.</p><p>Besides the <code class="literal">init</code> script-related permissions, most <code class="literal">_admin</code> interfaces provide administrative rights to almost all resources provided by the module. To simplify policy development, the <code class="literal">admin_pattern</code> call is used. This pattern not only provides manage rights (read, write, execute, delete, and so on) on the resources, but also relabel rights, allowing the administrator to relabel files and directories as the resource types used in the module (or vice versa, relabel from those types to other types the administrator has relabel privileges to).</p><p>With these relabel rights, administrators can call <code class="literal">restorecon</code> against files to label them correctly (if properly defined in the SELinux policy) or use <code class="literal">chcon</code> to specifically set a label.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec127"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating new administrative roles is covered in <a class="link" href="ch06.html" title="Chapter 6. Setting Up Separate Roles">Chapter 6</a>, <span class="emphasis"><em>Setting Up Separate Roles</em></span></li></ul></div></div></div></body></html>