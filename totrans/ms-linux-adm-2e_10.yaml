- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disaster Recovery, Diagnostics, and Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to do a system backup and restore in a disaster
    recovery scenario, and how to **diagnose** and **troubleshoot** a common array
    of problems. These are skills that each Linux system administrator needs to have
    if they wish to be prepared for worst-case scenarios such as power outages, theft,
    or hardware failure. The world’s IT backbone runs on Linux and we need to be prepared
    for anything that life throws at us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning for disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backing up and restoring the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing common Linux diagnostic tools for troubleshooting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No special technical requirements are needed for this chapter, just a working
    installation of Linux on your system or even two different working systems on
    your local network for some of the examples used. Ubuntu and Fedora are equally
    suitable for this chapter’s exercises, but in this chapter, we’ll be using Ubuntu
    22.04.2 LTS Server and Desktop editions.
  prefs: []
  type: TYPE_NORMAL
- en: Planning for disaster recovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing risks is an important asset for every business or individual. The responsibility
    of this is tremendous for everyone involved in system administration. For all
    businesses, managing risks should be part of a wider **risk management strategy**.
    There are various types of risks in IT, starting from natural hazards directly
    impacting data centers or business locations, all the way up to cyber security
    threats. IT’s footprint inside a company has exponentially grown in the last decade.
    Nowadays, there is no activity that does not involve some sort of IT operations
    being behind it, be it inside small businesses, big corporations, government agencies,
    or the health and education public sectors, just to give a few examples. Each
    activity is unique in its own way, so it needs a specific type of assessment.
    Unfortunately, with regard to the information security field, risk management
    has largely evolved into a one-size-fits-all practice, based on checklists that
    should be implemented by IT management. Let’s begin with a brief introduction
    to risk management before moving on to learning how we can assess risk.
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to risk management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is **risk management**? In a nutshell, it is comprised of specific operations
    that are set to mitigate any possible threat that could impact the overall continuity
    of a business. The risk management process is crucial for every IT department.
  prefs: []
  type: TYPE_NORMAL
- en: Risk management frameworks initially arose in the United States due to the **Federal
    Information Systems Modernization Act** (**FISMA**) laws, which started in 2002\.
    This was the time when the United States **National Institute of Standards and
    Technology** (**NIST**) began to create new standards and methods for cyber security
    assessments among all US government agencies. Therefore, security certifications
    and compliances are of utmost importance for every Linux distribution provider
    that sees itself as a worthy competitor in the corporate and governmental space.
    Similar to the US certification bodies discussed previously, there are other agencies
    in the UK and Russia that develop specific security certifications. In this respect,
    all major Linux distributions from Red Hat, SUSE, and Canonical have certifications
    from NIST, the UK’s **National Cyber Security Centre** (**NCSC**), or Russia’s
    **Federal Service for Technic and Export** **Control** (**FSTEC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The risk management framework, according to NIST SP 800-37r2 (see the official
    NIST website at [https://csrc.nist.gov/publications/detail/sp/800-37/rev-2/final](https://csrc.nist.gov/publications/detail/sp/800-37/rev-2/final)),
    has seven steps, starting with preparing for the framework’s execution, up to
    monitoring the organization’s systems on a daily basis. We will not discuss those
    steps in detail; instead, we will provide a link at the end of this chapter for
    NIST’s official documentation. In a nutshell, the risk management framework is
    comprised of several important branches, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inventory**: A thorough inventory of all available systems that are on-premises,
    and a list of all software solutions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System categorization**: Assesses the impact level for each data type that’s
    used with regard to availability, integrity, and confidentiality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security control**: Subject to detailed procedures with regard to hundreds
    of computer systems’ security – a compendium of NIST security controls can be
    found under SP800-53r4 (the following is a link to the official NIST website:
    [https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final](https://csrc.nist.gov/publications/detail/sp/800-53/rev-4/final))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk assessment**: A series of steps that cover threat source identification,
    vulnerability identification, impact determination, information sharing, risk
    monitoring, and periodical updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System security plan**: A report based on every security control and how
    future actions are assessed, including their implementation and effectiveness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Certification, accreditation, assessment, and authorization**: The process
    of reviewing security assessments and highlighting security issues and effective
    resolutions that are detailed in a future plan of action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan of action**: A tool that’s used to track security weaknesses and apply
    the correct response procedures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many types of risks when it comes to information technology, including
    hardware failure, software errors, spam and viruses, human error, and natural
    disasters (fires, floods, earthquakes, hurricanes, and so on). There are also
    risks of a more criminal nature, including security breaches, employee dishonesty,
    corporate espionage, or anything else that could be considered a cybercrime. These
    risks can be addressed by implementing an appropriate risk management strategy.
    As a basis, such a strategy should have five distinct steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying risk**: Identifying possible threats and vulnerabilities that
    could impact your ongoing IT operations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analyzing risk**: Deciding how big or small it is, based on thorough studies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Evaluating risk**: Evaluating the impact that it could have on your operations;
    the immediate action is to respond to the risk based on the impact it has. This
    calls for real actions to be performed at every level of your operations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Responding to risk**: Activating your **disaster recovery plans** (**DRPs**),
    combined with strategies for prevention and mitigation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring and reviewing risk**: Triggering a drastic monitoring and reviewing
    strategy will ensure that all the IT teams know how to respond to the risk and
    have the tools and abilities to isolate it and enforce the company’s infrastructure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Risk assessment is extremely important to any business and should be taken very
    seriously by IT management. Now that we’ve tackled some concepts of risk management,
    it is time to explain what it really is.
  prefs: []
  type: TYPE_NORMAL
- en: Risk calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Risk assessment**, also known as **risk calculation** or **risk analysis**,
    refers to the action of finding and calculating solutions to possible threats
    and vulnerabilities. The following are some basic terms you should know when you
    talk about risk impact:'
  prefs: []
  type: TYPE_NORMAL
- en: The **annual loss expectancy** (**ALE**) defines the loss that’s expected in
    1 year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **single loss expectancy** (**SLE**) represents how much loss is expected
    at any given time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **annual rate of occurrence** (**ARO**) is the likeliness of a risky event
    occurring within 1 year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **risk calculation formula** is *SLE x ARO = ALE*. There is a monetary value
    that each element of the formula will provide, so the final result is also expressed
    as a monetary value. This is a formula that is useful to know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **mean time between failures** (**MTBF**) is used to measure the time between
    anticipated and reparable failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **mean time to failure** (**MTTF**) is the average time the system can operate
    before experiencing an irreparable failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **mean time to restore** (**MTTR**) measures the time needed to repair an
    affected system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **recovery time objective** (**RTO**) represents the maximum time that’s
    allocated for downtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **recovery point objective** (**RPO**) defines the time when a system needs
    to be restored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knowing those terms will help you understand risk assessments so that you can
    perform a well-documented assessment if or when needed. Risk assessment is based
    on two major types of actions (or better said, strategies):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proactive actions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk avoidance**: Based on risk identification and finding a quick solution
    to avoid its occurrence'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk mitigation**: Based on actions taken to reduce the occurrence of a possible
    risk'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk transference**: Transferring the risk’s possible outcome with an external
    entity'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk deterrence**: Based on specific systems and policies that should discourage
    any attacker from exploiting the system'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-active actions**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk acceptance**: Accepting the risk if the other proactive actions could
    exceed the cost of the harm that’s done by the risk'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategies described here can be applied to the risk associated with generic,
    on-premises computing, but nowadays, cloud computing is slowly and surely taking
    over the world. So, how could these risk strategies apply to cloud computing?
    In cloud computing, you use the infrastructure of a third party, but with your
    own data. Even though we will start discussing Linux in the cloud in [*Chapter
    14*](B19682_14.xhtml#_idTextAnchor299), *Short Introduction to* *Computing*, there
    are some concepts that we will introduce now. As we mentioned earlier, the cloud
    is taking the infrastructure operations from your on-premises environment to a
    larger player, such as Amazon, Microsoft, or Google. This could generally be seen
    as outsourcing. This means that some risks that were a threat when you were running
    services on-premises are now transferred to third parties.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three major cloud paradigms that are now buzzwords all over technology
    media:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software as a service** (**SaaS**): This is a software solution for companies
    looking to reduce IT costs and rely on software subscriptions. Some examples of
    SaaS solutions are **Slack**, **Microsoft 365**, **Google Apps**, and **Dropbox**,
    among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform as a service** (**PaaS**): The way you get software applications
    to your clients using another’s infrastructure, runtimes, and dependencies is
    also known as an application platform. This can be on a public cloud, on a private
    cloud, or on a hybrid solution. Some examples of PaaS are **Microsoft Azure**,
    **AWS Lambda**, **Google App Engine**, **SAP Cloud Platform**, **Heroku**, and
    **Red** **Hat OpenShift**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure as a service** (**IaaS**): These are services that are run
    online and provide high-level **application programming interfaces** (**APIs**).
    A notable example is **OpenStack**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about all these technologies will be provided in [*Chapter 14*](B19682_14.xhtml#_idTextAnchor299),
    *Short Introduction to* *Computing*, but for this chapter’s purpose, we have provided
    enough information. Major risks regarding cloud computing are concerned with data
    integration and compatibility. Those are among the risks that you must still overcome
    since most of the other risks are no longer your concern as they are transferred
    to the third party managing the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Risk calculation can be managed in different ways, depending on the IT scenario
    a company uses. When you’re using the on-premises scenario and you’re managing
    all the components in-house, risk assessments become quite challenging. When you’re
    using the IaaS, PaaS, and SaaS scenarios, risk assessment becomes less challenging
    as responsibilities are gradually transferred to an external entity.
  prefs: []
  type: TYPE_NORMAL
- en: Risk assessment should always be taken seriously by any individual concerned
    with the safety of their network and systems and by any IT manager. This is when
    a DRP comes into action. The foundation of a good DRP and strategy is having an
    effective risk assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a DRP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DRP is structured around the steps that should be taken when an incident occurs.
    In most cases, the DRP is part of a **business continuity plan**. This determines
    how a company should continue to operate based on a functioning infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Every DRP needs to start from an accurate **hardware inventory**, followed by
    a **software applications inventory** and a separate **data inventory**. The most
    important part of this is the strategy that’s designed to back up all the information
    that’s used.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the hardware that’s used, there must be a clear policy for standardized
    hardware. This will ensure that faulty hardware can easily be replaced. This kind
    of policy ensures that everything works and is optimized. Standardized hardware
    surely has good driver support, and this is very important in the Linux world.
    Nevertheless, using standardized hardware will tremendously limit practices such
    as **bring your own device** (**BYOD**), since employees only need to use the
    hardware provided by their employer. Using standardized hardware comes with using
    specific software applications that have been set up and configured by the company’s
    IT department, with limited input available from the user.
  prefs: []
  type: TYPE_NORMAL
- en: The IT department’s responsibility is huge, and it plays an important role in
    designing the **IT recovery strategies** as part of a DRP. Key tolerances for
    downtime and loss of data should be defined based on the minimal acceptable RPO
    and RTO.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the **roles** regarding who is responsible for what is another key
    step of a good DRP. This way, the response time for implementing the plan will
    be dramatically reduced and everyone will know their own responsibilities in case
    any risks arise. In this case, having a good **communication strategy** is critical.
    Enforcing clear procedures for every level of the organizational pyramid will
    provide clear communication, centralized decisions, and a succession plan for
    backup personnel.
  prefs: []
  type: TYPE_NORMAL
- en: DRPs need to be thoroughly tested at least twice a year to prove their efficiency.
    Unplanned downtime and outages can negatively impact a business, both on-premises
    and in any multi-cloud environment. Being prepared for worst-case scenarios is
    important. Therefore, in the following sections, we will show you some of the
    best tools and practices for backing up and restoring a Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up and restoring the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disasters can occur at any time. Risk is everywhere. In this respect, backing
    up your system is of utmost importance and needs to be done regularly. It is always
    better to practice good prevention than to recover from data loss and learn this
    the hard way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Backup** and **recovery** need to be done based on a well-thought-out strategy
    and need to take the RTO and RPO factors into consideration. The RTO should answer
    basic questions such as how fast to recover lost data and how this will affect
    the business operations, while the RPO should answer questions such as how much
    of your data you can afford to lose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types and methods of backup. The following are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Backup methods and types](img/B19682_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Backup methods and types
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing a backup, keep the following rules in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The **321 rule** means that you should always have at least three copies of
    your data, with two copies on two different media at separate locations and one
    backup always being kept off-site (at a different geographical location). This
    is also known as the **rule of three**; it can be adapted to anything, such as
    312, 322, 311, or 323.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backup checking** is extremely relevant and is overlooked most of the time.
    It checks the data’s integrity and usefulness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear and documented backup strategy and procedures** are beneficial to everyone
    in the IT team who is using the same practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at some well-known tools for full Linux system
    backups, starting with the ones that are integrated inside the operating system
    to third-party solutions that are equally suited for both home and enterprise
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Disk cloning solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good option for a backup is to clone the entire hard drive or several partitions
    that hold sensitive data. Linux offers a plethora of versatile tools for this
    job. Among those are the `dd` command, the `ddrescue` command, and the **Relax-and-Recover**
    (**ReaR**) software tool. Let’s look at these in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The dd command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most well-known disk backup commands is the `dd` command. We discussed
    this previously in [*Chapter 6*](B19682_06.xhtml#_idTextAnchor124), *Working with
    Disks and Filesystems*. Let’s recap how it is used in a backup and restore scenario.
    The `dd` command is used to copy block by block, regardless of the filesystem
    type, from a source to a destination.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to clone an entire disk. We have a virtual machine on our system
    that has a 20 GB drive that we want to back up on a 128 GB USB pen drive. The
    procedures we are going to show you will work on bare metal too.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will run the `sudo fdisk -l` command to verify that the disk sizes
    are correct. The output will show us information about both our local drive and
    the USB pen drive, among other information, depending on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what the sizes are and that the source can fit into the destination,
    we will proceed to cloning the entire virtual disk. We will clone the source disk,
    `/dev/vda`, to the destination disk, `/dev/sda` (the operation could take a while):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Using dd to clone an entire hard drive](img/B19682_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Using dd to clone an entire hard drive
  prefs: []
  type: TYPE_NORMAL
- en: 'The options shown in the preceding command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if=/dev/vda` represents the input file, which, in our case, is the source
    hard drive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of=/dev/sda` represents the output file, which is the destination USB drive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conv=noerror` represents the instruction that allows the command to continue
    ignoring errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync` represents the instruction to fill the input error blocks with zeros
    so that the data offset will always be synced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status=progress` shows statistics about the transfer process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please keep in mind that this operation could take a while to finish. On our
    system, it took 200 minutes to complete. We took the preceding screenshot while
    the operation was at the beginning. In the following section, we will show you
    how to use `ddrescue`.
  prefs: []
  type: TYPE_NORMAL
- en: The ddrescue command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ddrescue` command is yet another tool you can use to clone your disk. This
    tool copies from one device or file to another one, trying to copy only the good
    and healthy parts the first time. If your disk is failing, you might want to use
    `ddrescue` twice since, the first time, it will copy only the good sectors and
    map the errors to a destination file. The second time, it will copy only the bad
    sectors, so it is better to add an option for several read attempts just to be
    sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu, the `ddrescue` utility is not installed by default. To install it,
    use the following `apt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `ddrescue` on the same system we used previously and clone the
    same drive. The command for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Using ddrescue to clone the hard drive](img/B19682_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Using ddrescue to clone the hard drive
  prefs: []
  type: TYPE_NORMAL
- en: We used the `ddrescue` command with the `--force` option to make sure that everything
    on the destination will be overwritten. This operation is time-consuming too,
    so be prepared for a lengthy wait. In our case, it took almost 1 hour to finish.
    Next, we will show you how to use another useful tool, the ReaR utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using ReaR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ReaR is a powerful disaster recovery and system migration tool written in Bash.
    It is used by enterprise-ready distributions such as RHEL and SLES, and can also
    be installed on Ubuntu. It was designed to be easy to use and set up. It is integrated
    with the local bootloader, with the `cron` scheduler, or monitoring tools such
    as **Nagios**. For more details on this tool, visit the official website at [http://relax-and-recover.org/about/](http://relax-and-recover.org/about/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it on Ubuntu, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the packages have been installed, you will need to know the location of
    the main configuration file, which is `/etc/rear/local.conf`, and all the configuration
    options should be written inside it. ReaR makes ISO files by default, but it also
    supports Samba (CIFS), USB, and NFS as backup destinations. Next, we will show
    you how to use ReaR to back up to a local NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up to a local NFS server using ReaR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an example, we will show you how to back up to an NFS server. As specified
    in the *Technical requirements* section, you would need to have at least two systems
    available on your network for this exercise: an NFS server set up on one of the
    machines (as a backup server) and a second system as the production machine to
    be backed up. ReaR should be installed on both of them. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must configure the NFS server accordingly (the operation is covered
    in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring Linux Servers*).
    For extensive information on setting up an NFS server, please refer to [*Chapter
    13*](B19682_13.xhtml#_idTextAnchor276); here, we only cover it briefly. The configuration
    file for NFS is `/etc/exports` and it stores information about the share’s location.
    Before you add any new information about the ReaR backup share’s location, add
    a new directory. We will consider the `/home/export/` directory for our NFS setup.
    Inside that directory, we will create a new one for our ReaR backups. The command
    to create the new directory is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '/etc/exports file with your favorite editor and add a new line for the backup
    directory. The line should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use your local network’s IP range, not the one we used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the new line has been introduced, restart the NFS service and run the
    `exportfs` command using the `-``s` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OUTPUT=ISO
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: OUTPUT_URL=nfs://192.168.124.112/home/export/rear
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BACKUP=NETFS
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'OUTPUT: The bootable image type, which, in our case, is ISO'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`OUTPUT_URL`: The backup target, which can represent NFS, CIFS, FTP, RSYNC,
    or file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BACKUP`: The backup method used, which, in our case, is `NETFS`, the default
    ReaR method'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`BACKUP_URL`: The backup target’s location'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the `mkbackup` command with the `-v` and `-``d` options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output will be large, so we will not show it to you here. The command will
    take a significant time to finish. Once it has finished, you can check the NFS
    directory to view its output. The backup should be in there.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are several files written on the NFS server. Among those, the one called
    `rear-neptune.iso` is the actual backup and the one that will be used in case
    a system restore is needed. There is also a file called `backup.tar.gz`, which
    contains all the files from our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The naming convention of ReaR is as follows. The name will consist of the term
    `rear-`, followed by the system’s hostname and the `.iso` extension. Our system’s
    hostname is `neptune`, which is why the backup file is called `rear-neptune.iso`
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: Once the backup has been written on the NFS server, you will be able to restore
    the system by using a USB disk or DVD with the ISO image that was written on the
    NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up to USB using ReaR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There is also the option of directly backing up on the USB disk. Here are the
    steps to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a disk into the USB port and format it by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The command will take a significant time to complete. The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Formatting the USB disk with ReaR](img/B19682_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Formatting the USB disk with ReaR
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to modify the `/etc/rear/local.conf` file and adapt it so that
    it uses the USB as the backup destination. The new lines we will add should look
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To understand the last line of code, you can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.5 – Checking the URL location from the ReaR configuration file](img/B19682_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Checking the URL location from the ReaR configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'To back up the system on the USB disk, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To recover the system, you will need to boot from the USB drive and select the
    first option, which says `Recover "hostname"`, where `"hostname"` is the hostname
    of the computer you backed up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System backup and recovery are two very important tasks that should be indispensable
    to any Linux system administrator. Knowing how to execute those tasks can save
    data, time, and money for both the company and the client. Minimal downtime and
    having a quick, effective response should be the most important assets on every
    **Chief Technology Officer’s** (**CTO’s**) table. Backup and recovery strategies
    should always have a strong foundation in terms of good mitigation practices.
    In this respect, a strong diagnostics toolset and troubleshooting knowledge will
    always come in handy for every system administrator. This is why, in the next
    section, we will show you some of the best diagnostic tools in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing common Linux diagnostic tools for troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The openness of Linux is one of its best assets. This opened the door to an
    extensive number of solutions that can be used for any task at hand. Hence, many
    diagnostic tools are available to Linux system administrators. Depending on which
    part of your system you would like to diagnose, there are several tools available.
    Troubleshooting is essentially problem-solving based on diagnostics generated
    by specific tools. To reduce the number of diagnostic tools to cover, we will
    narrow down the issues to the following categories for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Boot issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General system issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are specific diagnostic tools for each of these categories. We will start
    by showing you some of the most widely used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for troubleshooting boot issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the issues that may affect the boot process, it is important to
    know how the boot process works. We have not covered this in detail yet, so pay
    attention to everything that we will tell you.
  prefs: []
  type: TYPE_NORMAL
- en: The boot process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the major Linux distributions, such as Ubuntu, OpenSUSE, Debian, Fedora,
    and RHEL, use `systemd` as their default init system. Until GRUB2 initialization
    and the `systemd` startup were put in place, the Linux boot process had several
    more stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The boot order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Basic Input Output System** (**BIOS**) **Power-On** **Self-Test** (**POST**)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GRUB2 bootloader initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GNU/Linux kernel initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`systemd init` system initialization'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BIOS POST is a process specific to hardware initialization and testing, and
    it is similar for every PC, regardless of whether it is using Linux or Windows.
    The BIOS makes sure that every hardware component inside the PC is working properly.
    When the BIOS fails to start, there is usually a hardware problem or incompatibility
    issue. The BIOS searches for the disk’s boot record, such as the **master boot
    record** (**MBR**) or **GUID Partition Table** (**GPT**), and loads it into memory.
  prefs: []
  type: TYPE_NORMAL
- en: GRUB2 initialization is where Linux starts to kick in. This is the stage when
    the system loads the kernel into memory. It can choose between several different
    kernels in case there’s more than one operating system available. Once the kernel
    has been loaded into memory, it takes control of the boot process.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is a self-extracting archive. Once extracted, it runs into the memory
    and loads the `init` system, the parent of all the other processes on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` system, called `systemd`, starts by mounting the filesystems and
    accessing all the available configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: During the boot process, issues may appear. In the next section, we will discuss
    what to do if disaster strikes and your bootloader won’t start.
  prefs: []
  type: TYPE_NORMAL
- en: Repairing GRUB2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If GRUB2 breaks, you will not be able to access your system. This calls for
    a GRUB repair. At this stage, a live bootable USB drive will save you. The following
    steps are an exercise that could count as an experiment. In our case, we have
    an Ubuntu 22.04 LTS Desktop edition live disk, and we will use it for this example.
    However, you can use any Linux distribution you like, not necessarily Ubuntu.
    The point is that you would need a live bootable USB drive with Linux on it. Here
    are the steps you should follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Plug in the Ubuntu 22.04 live disk drive and boot the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the BIOS, select the bootable disk as the main boot device, and restart
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Try** **Ubuntu** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once inside the Ubuntu instance, open Terminal, enter the `sudo fdisk -l` command,
    and check your disks and partitions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the one that GRUB2 is installed on and use the following command (use
    the disk names as provided by your system; don’t copy/paste our example):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install GRUB2 using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unmount the partition using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reboot the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dealing with bootloaders is extremely sensitive. Pay attention to all the details
    and take care of all the commands you type in. If not, everything could go sideways.
    In the next section, we will show you some diagnostic tools for general system
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for troubleshooting general system issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System issues can be of different types and complexities. Knowing the tools
    to deal with them is of utmost importance. In this section, we will cover the
    default tools provided by the Linux distribution. Basic troubleshooting knowledge
    is necessary for any Linux system administrator as issues can – and will – occur
    during regular operations.
  prefs: []
  type: TYPE_NORMAL
- en: What could general system issues mean? Well, basically, these are issues regarding
    disk space, memory usage, system load, and running processes.
  prefs: []
  type: TYPE_NORMAL
- en: Commands for disk-related issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Disks, be they HDDs or SSDs, are an important part of the system. They provide
    the necessary space for your data, files, and software of any type, including
    the operating system. We will not discuss hardware-related issues as this will
    be the subject of a future section in this chapter called *Tools for troubleshooting
    hardware issues*. Instead, we will cover issues related to **disk space**. The
    most common diagnostic tools for this are already installed on any Linux system,
    and they are represented by the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`du`: A utility that shows disk space utilization for files and directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`df`: A utility that shows the disk usage for directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using the `df` utility with the `-h` (human-readable)
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If one of the disks runs out of space, it will be shown in the output. This
    is not an issue in our case, but the tool is still relevant for finding out which
    of the available disks is having issues with the free available space.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a disk is full, or almost full, there are several fixes that can be applied.
    If you have to delete some of the files, we advise you to delete them from your
    `/home` directory. Try not to delete important system files. The following are
    some ideas for troubleshooting available space issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the unnecessary files using the `rm` command (optionally using, with
    caution, the `-rf` option) or the `rmdir` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move files to an external drive (or to the cloud) using the `rsync` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find which directories use the most space in your `/``home` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using the `du` utility to find the largest directories
    inside the `/home` directory. We are using two pipes to transfer the output of
    the `du` command to the `sort` command and finally to the `head` command with
    the option of `5` (because we want to show the five largest directories, not all
    of them):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Finding the largest directories in your /home directory](img/B19682_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Finding the largest directories in your /home directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Another troubleshooting scenario is with regard to the number of inodes being
    used, not with the space on a disk. In this case, you can use the `df -i` command
    to see whether you’ve run out of inodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – inode usage statistics](img/B19682_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – inode usage statistics
  prefs: []
  type: TYPE_NORMAL
- en: The output in the preceding screenshot shows basic information about the inode
    usage on the system. You will see the total numbers of inodes on different filesystems,
    how many inodes are in use (as a number and as a percentage), and how many are
    free.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the commands shown here, which are the defaults for every Linux distribution,
    there are many other open source tools for disk space issues, such as **pydf**,
    **parted**, **sfdisk**, **iostat**, and the GUI-based **GParted** application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show you how to use commands to verify possible
    memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: Commands for memory usage issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`free` and it can be accessed in any major distribution. In the following example,
    we will use the `-h` option for a human-readable output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Using the free command in Linux](img/B19682_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Using the free command in Linux
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, using the `free` command (with the `-h`
    option for human-readable output) shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`total`: The total amount of memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`used`: The used memory, which is calculated as the total memory minus the
    buffered, cache, and free memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free`: The free or unused memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared`: The memory used by `tmpfs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buff/cache`: The memory used by kernel buffers and the page cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`available`: The amount of memory available for new applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This way, you can find specific issues related to higher memory usage. Constantly
    checking memory usage on servers is important to see whether resources are being
    used efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to check for memory usage is to use the `top` command, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Using the top command to check memory usage](img/B19682_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Using the top command to check memory usage
  prefs: []
  type: TYPE_NORMAL
- en: While using the `top` command, there are several sections available on screen.
    The output is dynamic, in the sense that it constantly changes, showing real-time
    information about the processes running on the system. The `memory` section shows
    information about total memory used, as well as free and buffered memory. All
    the information is shown in megabytes by default so that it’s easier to read and
    understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another command that shows information about memory (and other valuable system
    information) is `vmstat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Using vmstat with no options](img/B19682_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Using vmstat with no options
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `vmstat` shows information about processes, memory, swap, disk,
    and CPU usage. The memory information is shown starting from the second column
    and contains the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '`swpd`: How much virtual memory is being used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free`: How much memory is free'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buff`: How much memory is being used for buffering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache`: How much memory is being used for caching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `vmstat` command has several options available. To learn about all the
    options and what all the columns from the output represent, visit the respective
    pages in the manual using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The options that can be used with `vmstat` to show different information about
    memory are `-a` and `-s`. By using `vmstat -a`, the output will show the active
    and inactive memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Using vmstat -a to show the active and inactive memory](img/B19682_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Using vmstat -a to show the active and inactive memory
  prefs: []
  type: TYPE_NORMAL
- en: Using `vmstat -s` will show detailed memory, CPU, and disk statistics.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands discussed in this section are essential for troubleshooting
    any memory issues. There might be others you can use, but these are the ones you
    will find by default on any Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, there is one more that deserves to be mentioned in this section:
    the `sar` command. This can be installed in Ubuntu through the `sysstat` package.
    Therefore, install the package using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package has been installed, to be able to use the `sar` command to
    show detailed statistics about the system’s memory usage, you will need to enable
    the `sysstat` service. It needs to be active to collect data. By default, the
    service runs every 10 minutes and saves the logs inside the `/var/log/sysstat/saXX`
    directory. Every directory is named after the day the service runs on. For example,
    if we were to run the `sar` command on April 25, the service would look for data
    inside `/var/log/sysstat/sa25`. We ran the `sar` command on April 25 before starting
    the service, and an error occurred. Thus, to enable data collection, first, we
    will start and enable the `sysstat` service, then we will run the application.
    With the `sar` command, you can generate different reports in real time. For example,
    if we want to generate a memory report times every two seconds, we will use the
    `-``r` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Starting and enabling the service and running sar](img/B19682_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Starting and enabling the service and running sar
  prefs: []
  type: TYPE_NORMAL
- en: The service’s name is `sadc`) and it uses the `sysstat` name for the package
    and service.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the event of a system reboot, the service might not restart by default, even
    though the preceding commands were executed. To overcome this, on Ubuntu, you
    should edit the /`etc/default/sysstat` file and change the `ENABLED` status from
    `false` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The output shown in *Figure 10**.12* will write one line every two seconds,
    five times in a row, and an average line at the end. It is a powerful tool that
    can be used for more than just memory statistics. There are options for CPU and
    disk statistics as well.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, in this section, we covered the most important tools to use for troubleshooting
    memory issues. In the next section, we will cover tools to use for general system
    load issues.
  prefs: []
  type: TYPE_NORMAL
- en: Commands for system load issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to what we covered in the previous sections, in this section, we will
    discuss `top` command is one of the most widely used when we’re trying to determine
    the sluggishness of a system. All the other tools, such as `vmstat` and `sar`,
    can also be used for CPU and system load troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic command for troubleshooting system load is `uptime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Using uptime for checking system load](img/B19682_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Using uptime for checking system load
  prefs: []
  type: TYPE_NORMAL
- en: The `uptime` output shows three values at the end. Those values represent the
    load averages for 1, 5, and 15 minutes. The load average can give you a fair image
    of what happens with the system’s processes.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a single CPU system, a load average of `1` means that that CPU is
    under full load. If the number is higher, this means that the load is much higher
    than the CPU can handle, and this will probably put a lot of stress on your system.
    Because of this, processes will take longer to execute and the system’s overall
    performance will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: A high load average means that there are applications that run multiple threads
    simultaneously at once. Nevertheless, some load issues are not only the result
    of an overcrowded CPU – they can be the combined effect of CPU load, disk I/O
    load, and memory load. In this case, the Swiss Army knife for troubleshooting
    system load issues is the `top` command. The output of the `top` command constantly
    changes in real time, based on the system’s load.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `top` sorts processes by how much CPU they use. It runs in interactive
    mode and, sometimes, the output is difficult to see on the screen. You can redirect
    the output to a file and use the command in batch mode using the `-b` option.
    This mode only updates the command a specified number of times. To run `top` in
    batch mode, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `top` command could be a little intimidating for inexperienced Linux users.
    The output is highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The output of the top command](img/B19682_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – The output of the top command
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at what the output means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`us`: User CPU time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sy`: System CPU time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ni`: Nice CPU time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id`: Idle CPU time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wa`: Input/output wait time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hi`: CPU hardware interrupts time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`si`: CPU software interrupts time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st`: CPU steal time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another useful tool for troubleshooting CPU usage and hard drive input/output
    time is `iostat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The output of iostat](img/B19682_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The output of iostat
  prefs: []
  type: TYPE_NORMAL
- en: 'The CPU statistics are similar to the ones from the output of the `top` command
    shown earlier. The I/O statistics are shown below the CPU statistic and here is
    what each column represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tps`: Transfers per second to the device (I/O requests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_read/s`: Amount of data read from the device (in terms of the number of
    blocks – kilobytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_wrtn/s`: Amount of data written to the device (in terms of the number of
    blocks – kilobytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_dscd/s`: Amount of data discarded for the device (in kilobytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_read`: Total number of blocks read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_wrtn`: Total number of blocks written'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kB_dscd`: Total number of blocks discarded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more details about the `iostat` command, read the respective manual pages
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides the `iostat` command, there is another one that you could use, called
    `iotop`. It is not installed by default on Ubuntu, but you can install it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the package has been installed, you will need `sudo` privileges to run
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Running the iotop command](img/B19682_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Running the iotop command
  prefs: []
  type: TYPE_NORMAL
- en: You can also run the `sysstat` service to troubleshoot system load issues, similar
    to how we used it for troubleshooting memory issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `sar` will output the CPU statistics for the current day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Running sar for CPU load troubleshooting](img/B19682_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Running sar for CPU load troubleshooting
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, `sar` ran five times, every two seconds. Our local
    network servers are not under heavy load at this time, but you can imagine that
    the output would be different when the command is run on a heavily used server.
    As we pointed out in the previous section, the `sar` command has several options
    that could prove useful in finding solutions to potential problems. Run the `man
    sar` command to view the manual page containing all the available options.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other tools that could be used for general system troubleshooting.
    We barely scratched the surface of this subject with the tools shown in this section.
    We advise you to search for more tools designed for general system troubleshooting
    if you feel the need to do so. Otherwise, the ones presented here are sufficient
    for you to generate a viable report about possible system issues.
  prefs: []
  type: TYPE_NORMAL
- en: Network-specific issues will be covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for troubleshooting network issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often, due to the complexities of a network, issues tend to appear. Networks
    are essential for everyday living. We use them everywhere, from our wireless smartwatch
    to our smartphone, to our computer, and up to the cloud. Everything is connected
    worldwide to make our lives better and a systems administrator’s life a little
    bit harder. In this interconnected world, things can go sideways quite easily,
    and network issues need troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting **network issues** is almost 80% of a system administrator’s
    job – probably even more. This number is not backed up by any official studies
    but more of a hands-on experience insight. Since most of the server and cloud
    issues are related to networking, an optimal working network means reduced downtime
    and happy clients and system administrators.
  prefs: []
  type: TYPE_NORMAL
- en: The tools we will cover in this section are the defaults on all major Linux
    distributions. All these tools were discussed in [*Chapter 7*](B19682_07.xhtml#_idTextAnchor139),
    *Networking with Linux*, and [*Chapter 9*](B19682_09.xhtml#_idTextAnchor194),
    *Securing Linux*, or will be discussed in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276),
    *Configuring Linux Servers*, so we will only name them again from a problem-solving
    standpoint. Let’s break down the tools we should use on specific TCP/IP layers.
    Remember how many layers there are in the TCP/IP model? There are five layers
    available, and we will start from layer 1\. As a good practice, troubleshooting
    a network is best done through the stack, starting from the application layer
    all the way to the physical layer.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing the physical layer (layer 1)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the basic testing tools and one of the first to be used by most system
    administrators is the `ping` command. The name comes from `-c` option of the `ping`
    command. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Running a basic test using the ping command](img/B19682_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Running a basic test using the ping command
  prefs: []
  type: TYPE_NORMAL
- en: Ping is sending simple ICMP packets to the destination (in our case, it was
    [google.com](http://google.com)) and is waiting for a response. Once it is received
    and no packets are lost, this means that everything is working fine. The `ping`
    command can be used to test connections to local network systems, as well as remote
    networks. It is the first tool that’s used to test and isolate possible problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are times when a simple test with the `ping` command is not enough. In
    this case, another versatile command is the `ip` command. You can use it to check
    whether there are any issues with the physical layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Showing the state of the physical interfaces with the ip command](img/B19682_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Showing the state of the physical interfaces with the ip command
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that the Ethernet interface is running
    well (`state UP`). As we are running on a virtual machine, we do not have a wireless
    connection. If we were to use a laptop, for example, the wireless connection would
    have been visible, showing something such as `wlp0s20f3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the interfaces is not working, for example, the wireless one, the
    output of the preceding command would show `state DOWN`. In our case, we will
    bring the wireless interface up using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once executed, you can check the state of the interface by running the `ip`
    command once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you have direct access to a bare metal system, maybe a server, you can directly
    check whether the wires are connected. If, by any chance, you are using a wireless
    connection (not recommended), you will need to use the `ip` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful tool for layer 1 is `ethtool`. On Ubuntu 22.04.2 LTS, it is
    installed by default. To check the Ethernet interface, run the following command
    by using the connection’s name (you’ve seen it while using the `ip` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By using `ethtool`, we can check whether a connection has negotiated the correct
    speed. In the output of the command (which we will not show here), you would see
    that the system has correctly negotiated a full 1,000 Mbps full-duplex connection,
    for example (it may differ in your case). In the next section, we will show you
    how to diagnose the layer 2 stack.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing the data link layer (layer 2)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second layer in the TCP/IP stack is called the `ip` command and the `arp`
    command. The `arp` command, which comes from the `arp` command is available through
    the `net-tools` package. First, proceed and install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the entries inside the ARP table, you can use the `arp` command with
    the `-a` (all) option. As we are running on a virtual machine, we will have only
    one entry. As a comparison, we run the same command on our host system, this time
    having three entries, one for the wireless connection, one for the wired connection,
    and another for the virtual bridge connection used by KVM. The following is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Using the arp command to map the ARP entries](img/B19682_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Using the arp command to map the ARP entries
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `arp` command will show all the connected devices, with details
    about their IP and MAC addresses. Note that the MAC addresses have been blurred
    for privacy reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `arp` command, you can use the `ip neighbor show` command, as
    shown in the following screenshot. We will use our host system, not the virtual
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Listing the ARP entries using the ip command](img/B19682_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Listing the ARP entries using the ip command
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ip` command can be used to delete entries from the ARP list, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We used the command to delete the virtual bridge connection, using its IP address
    and name from the list as shown in *Figure 10**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `arp` and `ip` commands have a similar output. They are powerful commands
    and very useful for troubleshooting possible layer 2 issues. In the next section,
    we will show you how to diagnose the layer 3 stack.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing the internet layer (layer 3)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the internet layer, layer 3, we are working with IP addresses only. We already
    know about the tools to use here, such as the `ip` command, the `ping` command,
    the `traceroute` command, and the `nslookup` command. Since we’ve already covered
    the `ip` and `ping` commands, we will only discuss how to use `traceroute` and
    `nslookup` here. The `traceroute` command is not installed by default in Ubuntu.
    You will have to install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nslookup` package is already available in Ubuntu by default. First, to
    check for the routing table to see the list of gateways for different routes,
    we can use the `ip route` `show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Showing the routing table using the “ip route show” command](img/B19682_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Showing the routing table using the “ip route show” command
  prefs: []
  type: TYPE_NORMAL
- en: The `ip route show` command is showing the default gateway. An issue would be
    if it is missing or incorrectly configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `traceroute` tool is used to check the path of traffic from the source
    to the destination. The following output shows the path of packets traveling from
    our local gateway to Google’s servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Using traceroute for path tracing](img/B19682_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Using traceroute for path tracing
  prefs: []
  type: TYPE_NORMAL
- en: Packets don’t usually have the same route when they’re sending and coming back
    to the source. Packets are sent to gateways to be processed and sent to the destination
    on a certain route. When packets exceed the local network, their route can be
    inaccurately represented by the `traceroute` tool, since the packets it relies
    on could be filtered by many of the gateways on the path (*ICMP TTL Exceeded*
    packets are generally filtered).
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `traceroute`, there is a newer tool called `tracepath`. It is installed
    by default on Ubuntu and is a replacement for `traceroute`. Both `traceroute`
    and `tracepath` use the UDP ports for tracking by default. The `tracepath` command
    can also be used with the `-n` option to show the IP address instead of the hostname.
    The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Using the tracepath command](img/B19682_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Using the tracepath command
  prefs: []
  type: TYPE_NORMAL
- en: Checking further network issues could lead to faulty DNS resolution, where a
    host can only be accessed by the IP address and not by the hostname. To troubleshoot
    this, even if it is not a layer 3 protocol, you could use the `nslookup` command,
    combined with the `ping` command.
  prefs: []
  type: TYPE_NORMAL
- en: If the `nslookup` command has the same IP output as the `ping` command, it means
    that everything is fine. If a different IP address shows up in the output, then
    you have an issue with your host’s configuration. In the next section, we will
    show you how to diagnose both the layer 4 and layer 5 stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing the transport and application layers (layers 4 and 5)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last two layers, layer 4 (`ss` command (where `ss` is short for **socket
    statistics**).
  prefs: []
  type: TYPE_NORMAL
- en: The `ss` command is a recent replacement for `netstat` and is used to see the
    list of all network sockets. As such, a list can have a significant size, so you
    could use several command options to reduce it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could use the `-t` option to see only the TCP sockets, the
    `-u` option for UDP sockets, and `-x` for Unix sockets. Thus, to see TCP and UDP
    socket information, we will use the `ss` command with the `-t` option. Furthermore,
    to see all the listening sockets on your system, you can use the `-l` option.
    This one, combined with the `-u` and `-t` options, will show you all the UDP and
    TCP listening sockets on your system. The following is an excerpt from a much
    longer list:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.25 – Using the ss command to list TCP and UDP sockets and \uFEFF\
    all listening sockets](img/B19682_10_25.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Using the ss command to list TCP and UDP sockets and all listening
    sockets
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ss` command is important for network troubleshooting when you want to
    verify the available sockets and the ones that are in the `LISTEN` state, for
    example. Another use is for the `TIME_WAIT` state, and in this case, you can use
    the command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Showing the TIME_WAIT ports with the ss command](img/B19682_10_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Showing the TIME_WAIT ports with the ss command
  prefs: []
  type: TYPE_NORMAL
- en: We used the `ss` command with the `-o` option and the `state time-wait` argument.
    The `TIME_WAIT` state is achieved when a socket closes for a short time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on this state, you can visit the following link: [https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux](https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ss` tool should not be missing from a system administrator’s toolbox. Layer
    5, the application layer, comprises protocols used by applications, and we will
    remember protocols such as the **Dynamic Host Configuration Protocol** (**DHCP**),
    the **Hypertext Transfer Protocol** (**HTTP**), and the **File Transfer Protocol**
    (**FTP**). Since diagnosing layer 5 is mainly an application troubleshooting process,
    this will not be covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss troubleshooting hardware issues.
  prefs: []
  type: TYPE_NORMAL
- en: Tools for troubleshooting hardware issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step in troubleshooting hardware issues is to check your hardware.
    A very good tool to see details about the system’s hardware is the `dmidecode`
    command. This command is used to read details about each hardware component in
    a human-readable format. Each piece of hardware has a specific DMI code, depending
    on its type. This code is specific to the **System Management Basic Input/Output
    System** (**SMBIOS**). There are 45 codes that are used by the SMBIOS. More information
    about the codes can be obtained at [https://www.thegeekstuff.com/2008/11/how-to-get-hardware-information-on-linux-using-dmidecode-command/](https://www.thegeekstuff.com/2008/11/how-to-get-hardware-information-on-linux-using-dmidecode-command/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To view details about the system’s memory, you can use the `dmidecode` command
    with the `-t` option (from `TYPE`) and code `17`, which corresponds to the memory
    device code from SMBIOS. An example from our virtual machine is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Using dmidecode to view information about memory](img/B19682_10_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Using dmidecode to view information about memory
  prefs: []
  type: TYPE_NORMAL
- en: To see details about other hardware components, use the command with the specific
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Other quick troubleshooting tools include commands such as `lspci`, `lsblk`,
    and `lscpu`. The output of the `lsblk` command shows information about the disks
    and partitions being used on the system. The `lscpu` command will show details
    about the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when you’re troubleshooting hardware issues, taking a quick look at the
    kernel’s logs could prove useful. To do this, use the `dmesg` command. You can
    use the `dmesg | more` command to have more control over the output.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this section, hardware troubleshooting is just as important
    and challenging as all other types of troubleshooting. Solving hardware-related
    issues is an integral part of any system administrator’s job. This involves constantly
    checking hardware components, replacing the faulty parts with new ones, and making
    sure that they run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we emphasized the importance of disaster recovery planning,
    backup and restore strategies, and troubleshooting various system issues. Every
    system administrator should be able to put their knowledge into practice when
    disaster strikes. Different types of failures will eventually hit the running
    servers, so solutions should be found as soon as possible to ensure minimal downtime
    and to prevent data loss.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter represented the culmination of the *Advanced Linux Administration*
    section of this book. In the next chapter, we will introduce you to **server administration**,
    with emphasis on KVM virtual machine management, Docker containers, and different
    types of Linux server configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Troubleshooting is problem-solving at its best. Before we dive into the server
    section, let’s test your troubleshooting knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to draft a DRP for your private network or small business.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back up your entire system using the 321 rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out what your system’s top 10 processes are that use CPU the most.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find out what your system’s top 10 processes are that use RAM the most.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ubuntu LTS official documentation: [https://ubuntu.com/server/docs](https://ubuntu.com/server/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RHEL official documentation: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SUSE official documentation: [https://documentation.suse.com/](https://documentation.suse.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3:Server Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this third part, you will learn about advanced Linux server administration
    tasks by setting up different types of servers, as well as working with and managing
    virtual machines and Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19682_11.xhtml#_idTextAnchor231), *Working with Virtual Machines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19682_12.xhtml#_idTextAnchor257), *Managing Containers with
    Docker*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring Linux Servers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
