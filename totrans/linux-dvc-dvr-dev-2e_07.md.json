["```\n#include <linux/of.h>\n#include <linux/of_device.h>\n```", "```\n/* This is a comment */\n// This is another comment\nnode_label: nodename@reg{\n   string-property = \"a string\";\n   string-list = \"red fish\", \"blue fish\";\n   one-int-property = <197>; /* One cell in the property */\n   int-list-property = <0xbeef 123 0xabcd4>;\n   mixed-list-property = \"a string\", <35>,[0x01 0x23 0x45];\n   byte-array-property = [0x01 0x23 0x45 0x67];\n   boolean-property;\n};\n```", "```\ni2c@021a0000 {\n    compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\";\n    reg = <0x021a0000 0x4000>;\n    [...]\n    expander@20 {\n        compatible = \"microchip,mcp23017\";\n        reg = <20>;\n        [...]       \n    };\n};\n```", "```\naliases {\n    ethernet0 = &fec;\n    gpio0 = &gpio1;\n    [...];\n};\nbus@2000000 { /* AIPS1 */\n    gpio1: gpio@209c000 {\n        compatible = \"fsl,imx6q-gpio\", \"fsl,imx35-gpio\";\n        reg = <0x0209c000 0x4000>;\n        interrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>,\n                    <0 67 IRQ_TYPE_LEVEL_HIGH>;\n        gpio-controller;\n        #gpio-cells = <2>;\n        interrupt-controller;\n        #interrupt-cells = <2>;\n    };\n    [...];\n};\nbus@2100000 { /* AIPS2 */\n    [...]\n    i2c1: i2c@21a0000 {\n        compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\";\n        reg = <0x021a0000 0x4000>;\n        interrupts = <0 36 IRQ_TYPE_LEVEL_HIGH>;\n        clocks = <&clks IMX6QDL_CLK_I2C1>;\n    };\n};\n&i2c1 {\n    eeprom-24c512@55 {\n        compatible = \"atmel,24c512\";\n        reg = <0x55>;\n    };\n    accelerometer@1d {\n        compatible = \"adi,adxl345\";\n        reg = <0x1d>;\n        interrupt-parent = <&gpio1>;\n        interrupts = <24 IRQ_TYPE_LEVEL_HIGH>,\n        <25 IRQ_TYPE_LEVEL_HIGH>;\n        [...]\n    };\n[...]\n};\n```", "```\naliases {\n    gpio0 = \"/soc/aips-bus@2000000/gpio@209c000\";\n    ethernet0 = \"/soc/aips-bus@2100000/ethernet@2188000\";\n    [...]\n};\naips-bus@2000000 {\n    gpio@209c000 {\n        compatible = \"fsl,imx6q-gpio\", \"fsl,imx35-gpio\";\n        gpio-controller;\n        #interrupt-cells = <0x2>;\n        interrupts = <0x0 0x42 0x4 0x0 0x43 0x4>;\n        phandle = <0x40>;\n        reg = <0x209c000 0x4000>;\n        #gpio-cells = <0x2>;\n        interrupt-controller;\n    };\n};\naips-bus@2100000 {\n    i2c@21a8000 {\n        compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\";\n        clocks = <0x4 0x7f>;\n        interrupts = <0x0 0x26 0x4>;\n        reg = <0x21a8000 0x4000>;\n        eeprom-24c512@55 {\n            compatible = \"atmel,24c512\";\n            reg = <0x55>;\n        };\n        accelerometer@1d {\n            compatible = \"adi,adxl345\";\n            interrupt-parent = <0x40>;\n            interrupts = <0x18 0x4 0x19 0x4>;\n            reg = <0x1d>;\n        };\n    };\n};\n```", "```\nbus@2100000 { /* AIPS2 */\n    [...]\n    i2c1: i2c@21a0000 {\n        [...]\n        status = \"disabled\";\n    };\n};\n```", "```\n&i2c1 {\n    [...]\n    status = \"okay\";\n};\n```", "```\ndtb-$(CONFIG_SOC_IMX6Q) += \\\n    imx6dl-alti6p.dtb \\\n    imx6dl-aristainetos_7.dtb \\\n[...]\n    imx6q-hummingboard.dtb \\\n    imx6q-hummingboard2.dtb \\\n    imx6q-hummingboard2-emmc-som-v15.dtb \\\n    imx6q-hummingboard2-som-v15.dtb \\\n    imx6q-icore.dtb \\\n[...]\n```", "```\n$ grep CONFIG_SOC_IMX6Q .config\nCONFIG_SOC_IMX6Q =y\n```", "```\nARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs\n```", "```\nARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- make dtbs\n```", "```\nARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make imx6q-hummingboard2.dtb\n```", "```\n$ dtc -I dtb -O dts arch/arm/boot/dts/imx6q-hummingboard2.dtb > path/to/my_devicetree.dts\n```", "```\n# dtc -I fs -O dts /sys/firmware/devicetree/base > MySBC.dts\n```", "```\n/dts-v1/;\n/plugin/; /* allow undefined label references and record them */\n/{\n    fragment@0 { /* first child node */\n        target=<phandle>; /* phandle of the target node to extend */\n    or\n        target-path=\"/path\"; /* full path of the node to extend */\n        __overlay__ {\n            property-a;  /* add property-a to the target */\n            property-b = <0x80>; /* update property-b value */\n            node-a { /* add to an existing, or create a node-a */\n                    ...\n            };\n        };\n    };\n    fragment@1 {\n         /* second fragment overlay ... */\n    };\n    /* more fragments follow */\n}\n```", "```\n/dts-v1/;\n/ {\n        foo: foonode {\n                foo-bool-property;\n                foo-int-property = <0x80>;\n                status = \"disabled\";\n        };\n};\n```", "```\ndtc -@ -I dts -O dtb -o base.dtb base.dts\n```", "```\n/dts-v1/;\n/plugin/;\n/ {\n        fragment@1 {\n                target = <&foo>;\n                __overlay__ {\n                        overlay-1-property;\n                        status = \"okay\";\n                        bar: barnode {\n                                bar-property;\n                        };\n                };\n        };\n};\n```", "```\ndtc -@ -I dts -O dtb -o foo-overlay.dtbo foo-overlay.dts\n```", "```\ndtb-y += foo-overlay.dtbo\n```", "```\n~# zcat /proc/config.gz | grep CONFIGFS\nCONFIG_CONFIGFS_FS=y\n~# zcat /proc/config.gz | grep OF_OVERLAY\nCONFIG_OF_OVERLAY=y\n~# \n```", "```\n# mount -t configfs none /sys/kernel/config\n```", "```\n# mkdir -p /sys/kernel/config/device-tree/overlays/\n```", "```\n# mkdir /sys/kernel/config/device-tree/overlays/foo\n```", "```\n# echo /path/to/foo-overlay.dtbo > /sys/kernel/config/device-tree/overlays/foo/path\n```", "```\n# cat foo.dtbo > /sys/kernel/config/device-tree/overlays/foo/dtbo\n```", "```\n# rmdir /sys/kernel/config/device-tree/overlays/foo\n```", "```\n&i2c3 {\n    [...]\n    status = \"okay\";\n    temperature-sensor@49 {\n        compatible = \"national,lm73\";\n        reg = <0x49>;\n    };\n    pcf8523: rtc@68 {\n        compatible = \"nxp,pcf8523\";\n        reg = <0x68>;\n    };\n};\n&ecspi1 {\n    fsl,spi-num-chipselects = <3>;\n    cs-gpios = <&gpio5 17 0>, <&gpio5 17 0>, <&gpio5 17 0>;\n    status = \"okay\";\n    [...]\n    ad7606r8_0: ad7606r8@1 {\n        compatible = \"ad7606-8\";\n        reg = <1>;\n        spi-max-frequency = <1000000>;\n        interrupt-parent = <&gpio4>;\n        interrupts = <30 0x0>;\n        convst-gpio = <&gpio6 18 0>;\n    };\n};\n```", "```\nsoc {\n    #address-cells = <1>;\n    #size-cells = <1>;\n    compatible = \"simple-bus\";\n    aips-bus@02000000 { /* AIPS1 */\n        compatible = \"fsl,aips-bus\", \"simple-bus\";\n        #address-cells = <1>;\n        #size-cells = <1>;\n        reg = <0x02000000 0x100000>;\n        [...];\n        spba-bus@02000000 {\n            compatible = \"fsl,spba-bus\", \"simple-bus\";\n            #address-cells = <1>;\n            #size-cells = <1>;\n             reg = <0x02000000 0x40000>;\n             [...]\n\n            ecspi1: ecspi@02008000 {\n                #address-cells = <1>;\n                #size-cells = <0>;\n                compatible = \"fsl,imx6q-ecspi\", \"fsl,imx51-ecspi\";\n                reg = <0x02008000 0x4000>;\n                [...]\n            };\n\n            i2c1: i2c@021a0000 {\n                #address-cells = <1>;\n                #size-cells = <0>;\n                compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\";\n                reg = <0x021a0000 0x4000>;\n              [...]\n            };\n        };\n    };\n};\n```", "```\nstruct resource {\n    resource_size_t start;\n    resource_size_t end;\n    const char *name;\n    unsigned long flags;\n[...]\n};\n```", "```\nstruct resource *platform_get_resource(\n                      struct platform_device *dev,\n                      unsigned int type, unsigned int num)\n```", "```\nstruct resource *platform_get_resource_byname(\n                             struct platform_device *dev,\n                             unsigned int type,\n                           const char *name)\n```", "```\nfake_device {\n    compatible = \"packt,fake-device\";\n    reg = <0x4a064000 0x800>,\n          <0x4a064800 0x200>,\n          <0x4a064c00 0x200>;\n    reg-names = \"ohci\", \"ehci\", \"config\";\n    interrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>,\n                 <0 67 IRQ_TYPE_LEVEL_HIGH>;\n    interrupt-names = \"ohci\", \"ehci\";\n};\n```", "```\nstruct resource *res_mem_config, resirq, *res_mem1;\nint txirq, rxirq;\n/*let's grab region <0x4a064000 0x800>*/\nres_mem1 = platform_get_resource_byname(pdev,\n                   IORESOURCE_MEM, \"ohci\");\n/*let's grab region <0x4a064c00 0x200>*/\nres_mem_config = platform_get_resource_byname(pdev,\n                  IORESOURCE_MEM, \"config\");\ntxirq = platform_get_resource_byname(pdev, \n                          IORESOURCE_IRQ, \"ohci\");\nrxirq = platform_get_resource_byname(pdev,\n                          IORESOURCE_MEM, \"ehci\");\n```", "```\nnode_label: nodename@reg{\n    string-property = \"a string\";\n    string-list = \"red fish\", \"blue fish\";\n    one-int-property = <197>; /* One cell property */\n   /* in the following line, each number (cell) is a\n    * 32-bit integer(uint32). There are 3 cells in\n    * this property */\n    int-list-property = <0xbeef 123 0xabcd4>;\n    mixed-list-property = \"a string\", <0xadbcd45>, \n                          <35>, [0x01 0x23 0x45];\n    byte-array-property = [0x01 0x23 0x45 0x67];\n    one-cell-property = <197>;\n    boolean-property;\n};\n```", "```\nstring-property = \"a string\";\nstring-list = \"red fish\", \"blue fish\";\n```", "```\nint of_property_read_string(const struct device_node *np,\n                           const char *propname,\n                           const char **out_string)\nint of_property_read_string_index(const struct \n                                 device_node *np,\n                                 const char *propname,\n                                 int index, \n                                 const char **output)\nint of_property_read_string_array(\n                  const struct device_node *np,\n                  const char *propname, \n                  const char **out_strs,\n                  size_t sz)\n```", "```\nsize_t count;\nconst char **res;\nconst char *my_string = NULL;\nconst char *blue_fish = NULL;\nof_property_read_string(pdev->dev.of_node,\n                      \"string-property\", &my_string);\nof_property_read_string_index(pdev->dev.of_node,\n                      \"string-list\", 1, &blue_fish);\ncount = of_property_read_string_array(dp, \n                      \"string-list\", res, count);\n```", "```\none-int-property = <197>;\nint-list-property = <1350000 0x54dae47 1250000 1200000>;\n```", "```\nint of_property_read_u32(const struct device_node *np,\n                        const char *propname,\n                        u32 *out_value)\nint of_property_read_u32_index(\n                      const struct device_node *np,\n                      const char *propname,\n                      u32 index, u32 *out_value)\nint of_property_read_u32_array(\n                      const struct device_node *np,\n                      const char *propname,\n                      u32 *out_values, size_t sz)\n```", "```\nunsigned int number;\nof_property_read_u32(pdev->dev.of_node,\n                    \"one-cell-property\", &number);\n```", "```\nint of_property_read_u32_array(\n                           const struct device_node *np,\n                           const char *propname,\n                           u32 *out_values, size_t sz);\n```", "```\nunsigned int cells_array[4]; /* return value by copy */\nif (!of_property_read_u32_array(pdev->dev.of_node,\n    \"int-list-property\", cells_array, 4))\n    dev_info(&pdev->dev, \"u32 list read successfully\\n\");\n/* can now process values in cells_array */\n[...]\n```", "```\nbool my_bool = of_property_read_bool(pdev->dev.of_node,\n                                  \"boolean-property\");\nif(my_bool){\n    /* boolean is true */\n} else\n    /* boolean is false */\n}\n```", "```\neeprom: ee24lc512@55 {\n    compatible = \"microchip,24xx512\";\n    reg = <0x55>;\n    partition@1 {\n        read-only;\n        part-name = \"private\";\n        offset = <0>;\n        size = <1024>;\n    };\n    config@2 {\n        part-name = \"data\";\n        offset = <1024>;\n        size = <64512>;\n    };\n};\n```", "```\nstructdevice_node *np = pdev->dev.of_node;\nstructdevice_node *sub_np;\nfor_each_child_of_node(np, sub_np) {\n    /* sub_np will point successively to each sub-node */\n    [...]\n    int size;\n    of_property_read_u32(client->dev.of_node,\n                        \"size\", &size);\n    ...\n}\n```"]