["```\nstruct bus_type {\n    const char        *name;\n    const char        *dev_name;\n    struct device     *dev_root;\n    const struct attribute_group **bus_groups;\n    const struct attribute_group **dev_groups;\n    const struct attribute_group **drv_groups;\n    int (*match)(struct device *dev,\n                 struct device_driver *drv);\n    int (*probe)(struct device *dev);\n    void (*sync_state)(struct device *dev);\n    int (*remove)(struct device *dev);\n    void (*shutdown)(struct device *dev);\n    int (*suspend)(struct device *dev, pm_message_t state);\n    int (*resume)(struct device *dev);\n    const struct dev_pm_ops *pm;\n[...]\n};\n```", "```\n/*\n * Let's write and export symbols that people\n * writing drivers for packt devices must use.\n */\nint packt_register_driver(struct packt_driver *driver)\n{    \n    driver->driver.bus = &packt_bus_type;\n    return driver_register(&driver->driver);\n}\nEXPORT_SYMBOL(packt_register_driver);\nvoid packt_unregister_driver(struct packt_driver *driver)\n{\n    driver_unregister(&driver->driver);\n}\nEXPORT_SYMBOL(packt_unregister_driver);\nint packt_register_device(struct packt_device *packt)\n{\n    packt->dev.bus = &packt_bus_type;\n    return device_register(&packt->dev);\n}\nEXPORT_SYMBOL(packt_device_register);\nvoid packt_unregister_device(struct packt_device *packt)\n{\n    device_unregister(&packt->dev);\n}\nEXPORT_SYMBOL(packt_unregister_device);\n```", "```\nstruct packt_device * packt_device_alloc(const char *name,\n                                          int id)\n{\n    struct packt_device    *packt_dev;\n    int                    status;\n    packt_dev = kzalloc(sizeof(*packt_dev), GFP_KERNEL);\n    if (!packt_dev)\n        return NULL;\n    /* devices on the bus are children of the bus device */\n    strcpy(packt_dev->name, name);\n    packt_dev->dev.id = id;\n    dev_dbg(&packt_dev->dev,\n      \"device [%s] registered with PACKT bus\\n\",\n       packt_dev->name);\n    return packt_dev;\n}\nEXPORT_SYMBOL_GPL(packt_device_alloc);\n```", "```\nstruct packt_controller {\n    char name[48];\n    struct device dev;    /* the controller device */\n    struct list_head  list;\n    int (*send_msg) (stuct packt_device *pdev,\n                       const char *msg, int count);\n    int (*recv_msg) (stuct packt_device *pdev,\n                        char *dest, int count);\n};\n```", "```\n/* system global list of controllers */\nstatic LIST_HEAD(packt_controller_list);\nstruct packt_controller\n    *packt_alloc_controller(struct device *dev)\n{\n    struct packt_controller *ctlr;\n    if (!dev)\n        return NULL;\n    ctlr = kzalloc(sizeof(packt_controller), GFP_KERNEL);\n    if (!ctlr)\n        return NULL;\n    device_initialize(&ctlr->dev);\n    [...]\n    return ctlr;\n}\nEXPORT_SYMBOL_GPL(packt_alloc_controller);\nint packt_register_controller(\n                           struct packt_controller *ctlr)\n{\n    /* must provide at least on hook */\nif (!ctlr->send_msg && !ctlr->recv_msg){\n        pr_err(\"Registering PACKT controller failure\\n\");\n    }\n    device_add(&ctlr->dev);\n    [...] /* other sanity check */\n    list_add_tail(&ctlr->list, &packt_controller_list);\n}\nEXPORT_SYMBOL_GPL(packt_register_controller);\n```", "```\n/* This is our bus structure */\nstruct bus_type packt_bus_type = {\n    .name     = \"packt\",\n    .match    = packt_device_match,\n    .probe    = packt_device_probe,\n    .remove   = packt_device_remove,\n    .shutdown = packt_device_shutdown,\n};\n```", "```\nstatic int __init packt_init(void)\n{\n    int status;\n    status = bus_register(&packt_bus_type);\n    if (status < 0)\n        goto err0;\n    status = class_register(&packt_master_class);\n    if (status < 0)\n        goto err1;\n    return 0;\nerr1:\n    bus_unregister(&packt_bus_type);\nerr0:\n    return status;\n}\npostcore_initcall(packt_init);\n```", "```\nint packt_device_register(struct packt_device *packt)\n{\n    packt->dev.bus = &packt_bus_type;\n    return device_register(&packt->dev);\n}\nEXPORT_SYMBOL(packt_device_register);\n```", "```\nstruct device_driver {\n    const char        *name;\n    struct bus_type   *bus;\n    struct module     *owner;\n    const struct of_device_id   *of_match_table;\n    const struct acpi_device_id  *acpi_match_table;\n    int (*probe) (struct device *dev);\n    int (*remove) (struct device *dev);\n    void (*shutdown) (struct device *dev);\n    int (*suspend) (struct device *dev,\n                    pm_message_t state);\n    int (*resume) (struct device *dev);\n    const struct attribute_group **groups;\n    const struct dev_pm_ops *pm;\n};\n```", "```\n    struct of_device_id {\n        char       compatible[128];\n        const void *data;\n    };\n    ```", "```\n/*\n * Bus specific driver structure\n * You should provide your device's probe\n * and remove functions.\n */\nstruct packt_driver {\n    int     (*probe)(struct packt_device *packt);\n    int     (*remove)(struct packt_device *packt);\n    void    (*shutdown)(struct packt_device *packt);\n    struct device_driver driver;\n    const struct i2c_device_id *id_table;\n};\n#define to_packt_driver(d) \\\n        container_of(d, struct packt_driver, driver)\n#define to_packt_device(d) container_of(d, \\\n                             struct packt_device, dev)\n```", "```\nstruct packt_device_id {\n    char name[PACKT_NAME_SIZE];\n    kernel_ulong_t driver_data;   /* Data private to the driver */\n};\n```", "```\nint bus_for_each_drv(struct bus_type * bus,\n                struct device_driver * start, void * data,\n                int (*fn)(struct device_driver *, void *));\n```", "```\nstruct device {\n    struct device *parent;\n    struct kobject kobj;\n    const struct device_type *type;\n    struct bus_type      *bus;\n    struct device_driver *driver;\n    void    *platform_data;\n    void    *driver_data;\n    struct device_node      *of_node;\n    struct class *class;\n    const struct attribute_group **groups;\n    void    (*release)(struct device *dev);\n[...]\n};\n```", "```\nint device_add(struct device *dev)\n{\n    [...]\n    bus_probe_device(dev);\n        if (parent)\n                klist_add_tail(&dev->p->knode_parent,\n                            &parent->p->klist_children);\n    [...]\n}\n```", "```\nint bus_for_each_dev(struct bus_type * bus,\n                    struct device * start, void * data,\n                    int (*fn)(struct device *, void *));\n```", "```\n/*\n * Bus specific device structure\n * This is what a PACKT device structure looks like\n */\nstruct packt_device {\n    struct module        *owner;\n    unsigned char        name[30];\n    unsigned long        price;\n    struct device        dev;\n};\n```", "```\nstruct kobject {\n    const char              *name;\n    struct list_head        entry;\n    struct kobject          *parent;\n    struct kset             *kset;\n    struct kobj_type        *ktype;\n    struct sysfs_dirent     *sd;\n    struct kref             kref;\n[...]\n};\n```", "```\nvoid kobject_init(struct kobject *kobj,\n                  struct kobj_type *ktype)\nstruct kobject *kobject_create(void)\n```", "```\nint kobject_add(struct kobject *kobj, struct kobject *parent,\n                const char *fmt, ...);\n```", "```\nint kobject_init_and_add(struct kobject *kobj,\n                         struct kobj_type *ktype,\n                         struct kobject *parent,\n                         const char *fmt, ...);\n```", "```\nstruct kobject * kobject_create_and_add(const char *name,\n                                     struct kobject *parent);\n```", "```\nvoid kobject_put(struct kobject * kobj);\nstruct kobject *kobject_get(struct kobject *kobj);\n```", "```\n/* Somewhere */\nstatic struct kobject *mykobj;\n[...]\nmykobj = kobject_create();\nif (!mykobj)\n    return -ENOMEM;\nkobject_init(mykobj, &my_ktype);\nif (kobject_add(mykobj, NULL, \"%s\", \"hello\")) {\n    pr_info(\"ldm: kobject_add() failed\\n\");\n    kobject_put(mykobj);\n    mykobj = NULL;\n    return -1;\n}\n```", "```\nstatic struct kobject * class_kobj   = NULL;\nstatic struct kobject * devices_kobj = NULL;\n/* Create /sys/class */\nclass_kobj = kobject_create_and_add(\"class\", NULL);\nif (!class_kobj)\n    return -ENOMEM;\n[...]\n/* Create /sys/devices */\ndevices_kobj = kobject_create_and_add(\"devices\", NULL);\nif (!devices_kobj)\n    return -ENOMEM;\n```", "```\nstruct kobj_type {\n    void (*release)(struct kobject *);\n    const struct sysfs_ops sysfs_ops;\n    struct attribute **default_attrs;\n};\n```", "```\nstruct sysfs_ops {\n    ssize_t (*show)(struct kobject *kobj,\n                   struct attribute *attr, char *buf);\n    ssize_t (*store)(struct kobject *kobj,\n                   struct attribute *attr, const char *buf,\n                   size_t size);\n};\n```", "```\nstruct kset {\n    struct list_head list; \n    spinlock_t list_lock;\n    struct kobject kobj;\n };\n```", "```\nstruct kset * kset_create_and_add(const char *name,\n                      const struct kset_uevent_ops *u,\n                      struct kobject *parent_kobj);\nvoid kset_unregister (struct kset * k);\n```", "```\nstatic struct kobject foo_kobj, bar_kobj;\n[...]\nexample_kset = kset_create_and_add(\"kset_example\",\n                           NULL, kernel_kobj);\n /* since we have a kset for this kobject,\n  * we need to set it before calling into the kobject core.\n  */\nfoo_kobj.kset = example_kset;\nbar_kobj.kset = example_kset;\n\nretval = kobject_init_and_add(&foo_kobj, &foo_ktype,\n                              NULL, \"foo_name\");\nretval = kobject_init_and_add(&bar_kobj, &bar_ktype,\n                              NULL, \"bar_name\");\n```", "```\nkset_unregister(example_kset);\n```", "```\nstruct attribute {\n        char              *name;\n        struct module     *owner;\n        umode_t           mode;\n};\n```", "```\nstruct kobj_attribute {\n struct attribute attr;\n ssize_t (*show)(struct kobject *kobj,\n                 struct kobj_attribute *attr, char *buf);\n ssize_t (*store)(struct kobject *kobj,\n                 struct kobj_attribute *attr,\n                 const char *buf, size_t count);\n};\n```", "```\nstatic ssize_t kobj_attr_show(struct kobject *kobj,\n                     struct attribute *attr, char *buf)\n{\n   struct kobj_attribute *kattr;\n   ssize_t ret = -EIO;\n   kattr = container_of(attr, struct kobj_attribute, attr);\n   if (kattr->show)\n       ret = kattr->show(kobj, kattr, buf);\n   return ret;\n}\nstatic ssize_t kobj_attr_store(struct kobject *kobj,\n                          struct attribute *attr, \n                          const char *buf, size_t count)\n{\n   struct kobj_attribute *kattr;\n   ssize_t ret = -EIO;\n   kattr = container_of(attr, struct kobj_attribute, attr);\n   if (kattr->store)\n       ret = kattr->store(kobj, kattr, buf, count);\n   return ret;\n}\nconst struct sysfs_ops kobj_sysfs_ops = {\n   .show  = kobj_attr_show,\n   .store = kobj_attr_store,\n};\n```", "```\n#define __ATTR(_name, _mode, _show, _store) {         \\\n    .attr = {.name = __stringify(_name),              \\\n           .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },\\\n     .show   = _show,                              \\\n     .store = _store,                               \\\n}\n```", "```\nstatic struct kobj_attribute foo_attr =\n    __ATTR(foo, 0660, attr_show, attr_store);\nstatic struct kobj_attribute bar_attr =\n    __ATTR(bar, 0660, attr_show, attr_store);\n```", "```\nint sysfs_create_file(struct kobject * kobj,\n                      const struct attribute * attr);\nvoid sysfs_remove_file(struct kobject * kobj,\n                        const struct attribute * attr);\n```", "```\nstruct kobject *demo_kobj;\nint err;\ndemo_kobj = kobject_create_and_add(\"demo\", kernel_kobj);\nif (!demo_kobj) {\n    pr_err(\"demo: demo_kobj registration failed.\\n\");\n    return -ENOMEM;\n}\nerr = sysfs_create_file(demo_kobj, &foo_attr.attr);\nif (err)\n    pr_err(\"unable to create foo attribute\\n\");\nerr = sysfs_create_file(demo_kobj, &bar_attr.attr);\nif (err){\n    sysfs_remove_file(demo_kobj, &foo_attr.attr);\n    pr_err(\"unable to create bar attribute\\n\");\n}\n```", "```\n#define __ATTR_RW_MODE(_name, _mode) {                 \\\n    .attr = { .name = __stringify(_name),              \\\n          .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },\\\n    .show   = _name##_show,                            \\\n    .store  = _name##_store,                          \\\n}\n```", "```\nstatic struct kobj_attribute attr_foo = __ATTR_RW(foo);\n```", "```\nstatic ssize_t attr_store(struct kobject *kobj,\n                      struct kobj_attribute *attr,\n                      const char *buf, size_t count)\n{\n    int value, ret;\n    ret = kstrtoint(buf, 10, &value);\n    if (ret < 0)\n        return ret;\n    if (strcmp(attr->attr.name, \"foo\") == 0)\n        foo = value;\n    else /* if (strcmp(attr->attr.name, \"bar\") == 0) */\n        bar = value;\n    return count;\n}\nstatic ssize_t attr_show(struct kobject *kobj,\n                      struct kobj_attribute *attr,\n                    char *buf)\n{\n    int value;\n    if (strcmp(attr->attr.name, \"foo\") == 0)\n        value = foo;\n    else\n        value = bar;\n     return sprintf(buf, \"%d\\n\", value);\n}\n```", "```\nstruct bin_attribute {\n    struct attribute attr;\n    size_t     size;\n    void             *private;\n    ssize_t (*read)(struct file *filp,\n              struct kobject *kobj,\n              struct bin_attribute *attr,\n              char *buffer, loff_t off, size_t count);\n    ssize_t (*write)(struct file *filp,\n             struct kobject *kobj,\n             struct bin_attribute *attr,\n             const char *buffer, \n             loff_t off, size_t count);\n    int (*mmap)(struct file *filp, struct kobject *kobj,\n                  struct bin_attribute *attr,\n                  struct vm_area_struct *vma);\n};\n```", "```\n#define __BIN_ATTR(_name, _mode, _read, _write, _size) {  \\\n   .attr = { .name = __stringify(_name), .mode = _mode }, \\\n   .read    = _read,                        \\\n   .write   = _write,                       \\\n    .size      = _size,                          \\\n```", "```\nBIN_ATTR_RO(name, size)\nBIN_ATTR_WO(name, size)\nBIN_ATTR_RW(name, size)\n```", "```\n#define BIN_ATTR_RW(_name, _size)         \\\nstruct bin_attribute bin_attr_##_name =   \\\n                __BIN_ATTR_RW(_name, _size)\n```", "```\n#define __BIN_ATTR_RW(_name, _size) \\\n __BIN_ATTR(_name, 0644, _name##_read, _name##_write, \\\n             _size)\n```", "```\nvoid sysfs_bin_attr_init(strict bin_attribute *bin_attr)\n```", "```\nint sysfs_create_bin_file(struct kobject *kobj, \n                          struct bin_attribute *attr);\n```", "```\nint sysfs_remove_bin_file(struct kobject *kobj, \n                          struct bin_attribute *attr);\n```", "```\nstruct eeprom_data {\n[...]\n    struct bin_attribute bin;\n    u8 buffer[];\n};\nstatic int i2c_slave_eeprom_probe(\n                             struct i2c_client *client)\n{\n    struct eeprom_data *eeprom;\n    int ret;\n    unsigned int size = FIELD_GET(I2C_SLAVE_BYTELEN,\n                                  id->driver_data) + 1;\n    eeprom = devm_kzalloc(&client->dev,\n                sizeof(struct eeprom_data) + size,\n                GFP_KERNEL);\n    if (!eeprom)\n        return -ENOMEM;\n    [...]\n    sysfs_bin_attr_init(&eeprom->bin);\n    eeprom->bin.attr.name = \"slave-eeprom\";\n    eeprom->bin.attr.mode = S_IRUSR | S_IWUSR;\n    eeprom->bin.read = i2c_slave_eeprom_bin_read;\n    eeprom->bin.write = i2c_slave_eeprom_bin_write;\n    eeprom->bin.size = size;\n    ret = sysfs_create_bin_file(&client->dev.kobj,\n                                  &eeprom->bin);\n    if (ret)\n        return ret;\n    [...]\n    return 0;\n};\n```", "```\nstatic int i2c_slave_eeprom_remove(struct i2c_client *client)\n{\n   struct eeprom_data *eeprom = i2c_get_clientdata(client);\n   sysfs_remove_bin_file(&client->dev.kobj, &eeprom->bin);\n[...]\n   return 0;\n}\n```", "```\nstatic ssize_t i2c_slave_eeprom_bin_read(struct file *filp,\n          struct kobject *kobj, struct bin_attribute *attr,\n          char *buf, loff_t off, size_t count)\n{\n    struct eeprom_data *eeprom;\n    eeprom = dev_get_drvdata(kobj_to_dev(kobj));\n[...]\n    memcpy(buf, &eeprom->buffer[off], count);\n[...]\n    return count;\n}\nstatic ssize_t i2c_slave_eeprom_bin_write(\n         struct file *filp, struct kobject *kobj,\n         struct bin_attribute *attr,\n         char *buf, loff_t off, size_t count)\n{\n     struct eeprom_data *eeprom;\n     eeprom = dev_get_drvdata(kobj_to_dev(kobj));\n[...]\n     memcpy(&eeprom->buffer[off], buf, count);\n[...]\n    return count;\n}\n```", "```\nstruct attribute_group {\n    const char        *name;\n    umode_t           (*is_visible)(struct kobject *,\n                         struct attribute *, int);\n    umode_t           (*is_bin_visible)(struct kobject *,\n                         struct bin_attribute *, int);\n    struct attribute  **attrs;\n    struct bin_attribute   **bin_attrs;\n};\n```", "```\nint sysfs_create_group(struct kobject *kobj,\n                       const struct attribute_group *grp)\nvoid sysfs_remove_group(struct kobject * kobj,\n                        const struct attribute_group * grp)\n```", "```\nstatic struct kobj_attribute foo_attr =\n    __ATTR(foo, 0660, attr_show, attr_store);\nstatic struct kobj_attribute bar_attr =\n    __ATTR(bar, 0660, attr_show, attr_store);\n/* attrs is aa array of pointers to attributes */\nstatic struct attribute *demo_attrs[] = {\n    &bar_foo_attr.attr,\n    &bar_attr.attr,\n    NULL,\n};\nstatic struct attribute_group my_attr_group = {\n    .attrs = demo_attrs,\n    /*.bin_attrs = demo_bin_attrs,*/\n};\n```", "```\nstruct kobject *demo_kobj;\nint err;\ndemo_kobj = kobject_create_and_add(\"demo\", kernel_kobj);\nif (!demo_kobj) {\n    pr_err(\"demo: demo_kobj registration failed.\\n\");\n    return -ENOMEM;\n}\nerr = sysfs_create_group(demo_kobj, &foo_attr.attr);\n```", "```\nint sysfs_create_link(struct kobject * kobj,\n                     struct kobject * target, char * name); \nvoid sysfs_remove_link(struct kobject * kobj, char * name);\n```", "```\n/sys$ tree -L 1\n├── block\n├── bus\n├── class\n├── dev\n├── devices\n├── firmware\n├── fs\n├── hypervisor\n├── kernel\n├── module\n└── power\n```", "```\n    struct driver_attribute {\n        struct attribute attr;\n        ssize_t (*show)(struct device_driver *driver,\n                    char *buf);\n        ssize_t (*store)(struct device_driver *driver,\n                    const char *buf, size_t count);\n    };\n    ```", "```\n    struct class_attribute {\n        struct attribute attr;\n        ssize_t (*show)(struct class *class,\n                 struct class_attribute *attr, char *buf);\n        ssize_t (*store)(struct class *class,\n                 struct class_attribute *attr,\n                 const char *buf, size_t count);\n    };\n    ```", "```\n    struct bus_attribute {\n        struct attribute  attr;\n        ssize_t (*show)(struct bus_type *bus, char *buf);\n        ssize_t (*store)(struct bus_type *bus,\n                     const char *buf, size_t count);\n    };\n    ```", "```\n    struct device_attribute {\n        struct attribute  attr;\n        ssize_t (*show)(struct device *dev,\n                     struct device_attribute *attr,\n                     char *buf);\n        ssize_t (*store)(struct device *dev,\n                           struct device_attribute *attr,\n                           const char *buf, size_t count);\n    };\n    ```", "```\n    BUS_ATTR_RW(_name)\n    BUS_ATTR_RO(_name)\n    BUS_ATTR_WO(_name)\n    ```", "```\n    DRIVER_ATTR_RW(_name)\n    DRIVER_ATTR_RO(_name)\n    DRIVER_ATTR_WO(_name)\n    ```", "```\n    CLASS_ATTR_RW(_name)\n    CLASS_ATTR_RO(_name)\n    CLASS_ATTR_WO(_name)\n    ```", "```\n    DEVICE_ATTR(_name, _mode, _show, _store)\n    DEVICE_ATTR_RW(_name)\n    DEVICE_ATTR_RO(_name)\n    DEVICE_ATTR_WO(_name)\n    ```", "```\nstatic CLASS_ATTR_RW(foo);\n```", "```\nstatic struct attribute *fake_class_attrs[] = {\n    &class_attr_foo.attr,\n    [...]\n    NULL,\n};\nstatic struct attribute_group fake_attr_group = {\n    .attrs = fake_class_attrs,\n};\n```", "```\nint device_create_file(struct device *device,\n            const struct device_attribute *entry);\nint driver_create_file(struct device_driver *driver,\n            const struct driver_attribute *attr);\nint bus_create_file(struct bus_type *bus,\n            struct bus_attribute *);\nint class_create_file(struct class *class,\n            const struct class_attribute *attr)\n```", "```\nint device_create_file(struct device *dev,\n                   const struct device_attribute *attr)\n{\n    [...]\n    error = sysfs_create_file(&dev->kobj, &attr->attr);\n    [...]\n}\nint class_create_file(struct class *cls,\n                    const struct class_attribute *attr)\n{\n    [...]\n    error =\n        sysfs_create_file(&cls->p->class_subsys.kobj,\n                          &attr->attr);\n    return error;\n}\nint bus_create_file(struct bus_type *bus,\n                   struct bus_attribute *attr)\n{\n    [...]\n    error =\n        sysfs_create_file(&bus->p->subsys.kobj,\n                           &attr->attr);\n    [...]\n}\n```", "```\nvoid device_remove_file(struct device *device,\n             const struct device_attribute *entry);\nvoid driver_remove_file(struct device_driver *driver,\n                const struct driver_attribute *attr);\nvoid bus_remove_file(struct bus_type *,\n                struct bus_attribute *);\nvoid class_remove_file(struct class *class,\n                       const struct class_attribute *attr);\n```", "```\nstatic ssize_t dev_attr_show(struct kobject *kobj,\n                            struct attribute *attr,\n                            char *buf)\n{\n    struct device_attribute *dev_attr = to_dev_attr(attr);\n    struct device *dev = kobj_to_dev(kobj);\n    ssize_t ret = -EIO;\n    if (dev_attr->show)\n          ret = dev_attr->show(dev, dev_attr, buf);\n    if (ret >= (ssize_t)PAGE_SIZE) {\n        print_symbol(\"dev_attr_show:\n                        %s returned bad count\\n\",\n                    (unsigned long)dev_attr->show);\n    }\n    return ret;\n}\nstatic ssize_t dev_attr_store(struct kobject *kobj,\n                      struct attribute *attr,\n                      const char *buf, size_t count)\n{\n    struct device_attribute *dev_attr = to_dev_attr(attr);\n    struct device *dev = kobj_to_dev(kobj);\n    ssize_t ret = -EIO;\n    if (dev_attr->store)\n        ret = dev_attr->store(dev, dev_attr, buf, count);\n    return ret;\n}\nstatic const struct sysfs_ops dev_sysfs_ops = {\n    .show     = dev_attr_show,\n    .store    = dev_attr_store,\n};\n```", "```\n#define to_dev_attr(_attr) \\\n       container_of(_attr, struct device_attribute, attr)\n```", "```\nvoid sysfs_notify(struct kobject *kobj, const char *dir,\n                  const char *attr)\n```", "```\nstatic ssize_t store(struct kobject *kobj,\n                     struct attribute *attr,\n                     const char *buf, size_t len)\n{\n    struct d_attr *da = container_of(attr, struct d_attr, \n                                      attr);\n    sscanf(buf, \"%d\", &da->value);\n    pr_info(\"sysfs_foo store %s = %d\\n\",\n             a->attr.name, a->value);\n    if (strcmp(a->attr.name, \"foo\") == 0){\n        foo.value = a->value;\n        sysfs_notify(mykobj, NULL, \"foo\");\n    }\n    else if(strcmp(a->attr.name, \"bar\") == 0){\n        bar.value = a->value;\n        sysfs_notify(mykobj, NULL, \"bar\");\n    }\n    return sizeof(int);\n}\n```"]