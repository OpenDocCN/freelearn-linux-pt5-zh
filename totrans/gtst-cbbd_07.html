<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Compiling the Bootloader and Kernel Using a BSP</h1></div></div></div><p>Sometimes, a special feature in the kernel is required that is not included in the precompiled binaries, or maybe some new piece of Allwinner-based hardware was obtained that is not yet supported in the existing list of precompiled files. To solve issues like these, you need to compile the bootloader or kernel from source. While it is perfectly possible to download and compile the bootloader and the kernel by itself, the linux-sunxi community developed a <a id="id324" class="indexterm"/>
<strong>board-support-package</strong> (<strong>BSP</strong>) that allows you to compile all these components together.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing a toolchain</li><li class="listitem" style="list-style-type: disc">Obtaining and using the BSP</li><li class="listitem" style="list-style-type: disc">Compiling the bootloader</li><li class="listitem" style="list-style-type: disc">Compiling the kernel</li><li class="listitem" style="list-style-type: disc">Creating a hardware pack</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Prerequisites</h1></div></div></div><p>Compiling <a id="id325" class="indexterm"/>things requires a compiler toolchain. Here, there are two options. Either compile on Cubieboard itself or cross compile on a regular PC. Getting a functional toolchain working on anything but Linux is up the reader to solve. The options are thus to use the installation created in the previous chapters and compile directly on Cubieboard or to have a (virtual) Linux machine available where a cross-compiler can be installed and used. In this chapter, both the methods will be described. Additionally, a working Internet connection on the device that is being used to compile on is initially required; this is to obtain the source code.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Installing a toolchain</h1></div></div></div><p>A <a id="id326" class="indexterm"/>toolchain<a id="id327" class="indexterm"/> is a collection of tools, including a compiler, required to compile the source code into binary forms. In theory, just the compiler is enough, but various other bits and pieces are often used to help with the compilation. One such example might be well known, the <code class="literal">make</code> command. A combination of all the tools required to compile things is known as a toolchain. Installing a toolchain varies from distribution to distribution; we will only cover a few examples here.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec34"/>Debian or Ubuntu</h2></div></div></div><p>For<a id="id328" class="indexterm"/> Debian, the<a id="id329" class="indexterm"/> toolchain is called <a id="id330" class="indexterm"/>
<code class="literal">build-essential</code>, and when cross-compiling, the arm compiler needs to be<a id="id331" class="indexterm"/> installed on top of that; this package is called <a id="id332" class="indexterm"/>
<code class="literal">gcc-arm-none-eabi</code>. Unfortunately, at the time of writing this book, the <code class="literal">gcc-arm-none-eabi</code> package did not exist in Debian wheezy. The version to be released after wheezy is jessie, which contains this cross compiler. One way to get it is to set up a virtual machine and install the testing version of Debian there.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec35"/>Fedora</h2></div></div></div><p>On Fedora, the<a id="id333" class="indexterm"/> installation is slightly different. Here, the <code class="literal">groupinstall</code> variant <a id="id334" class="indexterm"/>needs to be used to install the <code class="literal">Development Tools</code> and <code class="literal">Development Libraries</code> packages. To cross compile, install the <code class="literal">gcc-arm-linux-gnu</code> package in addition to that. It is necessary to use double quotes ("") due to the spaces in the meta packages.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec36"/>Other distributions</h2></div></div></div><p>Fedora <a id="id335" class="indexterm"/>and Debian are of course only two distributions out of the potential hundreds. These two distributions, however, give you a very good indication of how most other distributions handle the installation of the toolchain. These two significant distributions do it differently. For the Gentoo distribution, there is a crossdev toolset, which will compile and install a cross-compiler toolchain. After installing crossdev, use <code class="literal">crossdev --target arm-pc-linux-gnueabi</code> to install the arm toolchain. The arch distribution has the <code class="literal">gcc-arm-linux-gnueabihf-bin</code> package in the <a id="id336" class="indexterm"/>
<strong>Arch User Repository</strong> (<strong>AUR</strong>).</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>There are also vendor-supplied toolchains, such as the ones supplied by Linaro and CodeSourcery, for example. These are to be manually downloaded from the vendor site. Often, the toolchain comes in a tarball or a ZIP package and needs to be manually extracted. These toolchains are commonly used when no native arm-toolchain is available. Linaro even offers their cross-compiler for OSX and Windows; however, these two require an immense amount of work before you can start compiling.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Other required tools and packages</h1></div></div></div><p>Having obtained a complete toolchain, a few other packages are still required. Git<a id="id337" class="indexterm"/> is a tool used for source-code management; the package is named <code class="literal">git</code> on almost all distributions.</p><p>Additionally, <code class="literal">u-boot-tools</code> is required. The package is also named <a id="id338" class="indexterm"/>
<code class="literal">u-boot-tools</code> or <code class="literal">uboot-mkimage</code>
<a id="id339" class="indexterm"/> on some distributions.</p><p>On some distributions, when installing the toolchain, as described earlier, the <strong>pkg-config</strong> package<a id="id340" class="indexterm"/> sometimes doesn't get installed and needs to be installed on the distributions that lack it. The package is nearly always called pkg-config. To compile some of the tools, the <code class="literal">libusb</code> header files are required. The package name can vary between distributions. On Fedora, it is called<a id="id341" class="indexterm"/> <strong>libusb-devel</strong>. On Debian and Ubuntu, it is called <a id="id342" class="indexterm"/>
<strong>libusb-1.0-0-dev</strong>. Please note that <code class="literal">libusb</code> is often available under several versions in many distributions. The version required is <code class="literal">1.0</code>, and other versions may cause the compilation to fail.</p><p>Finally, the <em>ncurses</em> header files and libraries are required; the package is called either <a id="id343" class="indexterm"/>
<strong>ncurses-dev</strong> or <a id="id344" class="indexterm"/>
<strong>ncurses-devel</strong>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Obtaining and maintaining the BSP</h1></div></div></div><p>Whether <a id="id345" class="indexterm"/>the BSP is going to get cross-compiled or natively compiled, obtaining <a id="id346" class="indexterm"/>and using it is identical, and thus the instructions are common. All the code are stored on a git-server, and GitHub or Gitorious can and should be used as the main mirrors to obtain them from. Using Git, the repository can be cloned from one of the mirrors, as shown in the following screenshot:</p><div><img src="img/1572OS_07_01.jpg" alt="Obtaining and maintaining the BSP"/></div><p>After entering sunxi-bsp, the following list of files and directories will be visible:</p><div><img src="img/1572OS_07_02.jpg" alt="Obtaining and maintaining the BSP"/></div><p>Let us take a minute to quickly go over this list of file directories, of which some are actually separate Git repositories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">allwinner-tools</code>: This <a id="id347" class="indexterm"/>is a collection of files, drivers, and tools when working with the Allwinner-supplied material, such as livesuit. It is not of importance when working with the community tools.</li><li class="listitem" style="list-style-type: disc"><code class="literal">rootfs</code>: These <a id="id348" class="indexterm"/>are the files to be placed into the generated root filesystem, commonly named <code class="literal">rootfs</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sunxi-boards</code>: These<a id="id349" class="indexterm"/> are the FEX files of the community-supported boards. Refer to <a class="link" href="apc.html" title="Appendix C. The FEX Configuration File">Appendix C</a>, <em>The FEX Configuration File</em>, for more information about FEX.</li><li class="listitem" style="list-style-type: disc"><code class="literal">u-boot-sunxi</code>: This <a id="id350" class="indexterm"/>is the community-developed bootloader.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cedarx-libs</code>: These<a id="id351" class="indexterm"/> are proprietary libraries for the <strong>Video Processing Unit</strong> (<strong>VPU</strong>)<a id="id352" class="indexterm"/> supplied by Allwinner.</li><li class="listitem" style="list-style-type: disc"><code class="literal">linux-sunxi</code>: This<a id="id353" class="indexterm"/> is the community-developed Linux kernel.</li><li class="listitem" style="list-style-type: disc"><code class="literal">scripts</code>: These <a id="id354" class="indexterm"/>are various scripts used by BSP.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sunxi-tools</code>: These <a id="id355" class="indexterm"/>are community-developed tools to work with Allwinner hardware, including the FEX to a binary <code class="literal">script.bin</code> compiler.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Makefile</code>: This <a id="id356" class="indexterm"/>is a file to control how to compile various repositories.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Configure</code>: This<a id="id357" class="indexterm"/> is a script to choose and configure the entire BSP.</li><li class="listitem" style="list-style-type: disc"><code class="literal">README.md</code>: This<a id="id358" class="indexterm"/> is a simple text file with some basic usage instructions.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec37"/>Updating the repositories</h2></div></div></div><p>Some of the directories <a id="id359" class="indexterm"/>within the BSP are not yet populated. The BSP is smart enough to populate the required repositories by itself as and when it needs them. If, however, one of the repositories is to be manually populated or more importantly, updated, Git can be used to do so. Adding the <code class="literal">–init</code> parameter after the update is required when updating the repository for the first time, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ git submodule update --init sunxi-tools</strong>
</pre></div><p>Omitting the last parameter, in this case, <code class="literal">sunxi-tools</code>, will update and populate all the Git subrepositories. However, this will not always yield the latest version of the repository. The BSP controls the version of each repository to use. It can be said that it locks each of the subrepositories to a certain version. The BSP itself can be updated using Git, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ git pull</strong>
<strong>Already up-to-date.</strong>
</pre></div><p>If, however, the BSP is not updated or does not include the latest updates to subrepositories, the subrepositories can be manually updated. To update one of the repositories, enter it, and use the regular Git commands to update or check out a different branch as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ cd sunxi-tools/</strong>
<strong>packt@PacktPublishing:~/sunxi-bsp/sunxi-tools$ git pull</strong>
</pre></div><p>Do note that this could potentially break the version control of the BSP itself. Or rather, the local BSP will no longer match the official BSP. To delete all changes made to the local subrepository and bring the BSP in sync with the upstream version, the following command can be used:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ git checkout – sunxi-tools</strong>
</pre></div><p>Updating and modifying the submodules in Git is perfectly safe and is done frequently by developers. Do be careful <a id="id360" class="indexterm"/>when getting started and even more so when unfamiliar with Git.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>Some experience with version control systems, especially Git, is strongly recommended before tinkering with the repositories. In case all else fails, feel assured that it is always possible to remove the BSP and start again.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Choosing a kernel</h1></div></div></div><p>As <a id="id361" class="indexterm"/>discussed in <a class="link" href="ch06.html" title="Chapter 6. Updating the Bootloader and Kernel">Chapter 6</a>, <em>Updating the Bootloader and Kernel</em>, there are a few different kernels available. These kernels are built from the various branches available in the Git repository. Listing these branches is done using the <code class="literal">git branch</code> command, with the addition of the <code class="literal">-a</code> parameter telling Git to show all the available branches. In the following screenshot, the kernels discussed in <a class="link" href="ch06.html" title="Chapter 6. Updating the Bootloader and Kernel">Chapter 6</a>, <em>Updating the Bootloader and Kernel</em>, should be recognizable:</p><div><img src="img/1572OS_07_03.jpg" alt="Choosing a kernel"/></div><p>The detached branch, in this case, is the kernel version that is linked to the BSP at the time of writing this book. Using <a id="id362" class="indexterm"/>
<code class="literal">git checkout</code>, it is <a id="id363" class="indexterm"/>easy to switch to an alternative branch and eventually to a kernel. This can be seen in the following screenshot:</p><div><img src="img/1572OS_07_04.jpg" alt="Choosing a kernel"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Compiling for a Cubieboard</h1></div></div></div><p>Before compiling <a id="id364" class="indexterm"/>for a Cubieboard, the BSP has to be configured first. Whenever building for a different development board, the BSP will have to be reconfigured. This however, is an easy task using the configure script. Running configure without a parameter will populate the <code class="literal">sunxi-boards</code> repository, as that repository contains a list of supported boards and prints a list of available boards, as shown in the following code. Take note of the prefix <code class="literal">./</code>, which is used to the configure the script. The output generated by configure is reduced here for clarity and convenience:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ ./configure</strong>
<strong>Usage: ./configure &lt;board&gt;</strong>
<strong>supported boards:</strong>
<strong>        * a10s-olinuxino-m a10s-olinuxino-m-android</strong>
<strong>        * a10-olinuxino-lime a10-olinuxino-lime-android</strong>
<strong>        * a13-olinuxino a13-olinuxino-android</strong>
<strong>        * a13-olinuxinom a13-olinuxinom-android</strong>
<strong>        * a20-olinuxino_micro a20-olinuxino_micro-android</strong>
<strong>        * cubieboard cubieboard-android</strong>
<strong>        * cubieboard2 cubieboard2-android</strong>
<strong>        * cubietruck cubietruck-android</strong>
</pre></div><p>There are two variants for each board that are to be passed to the configure script; the Android variant is specifically used to build Android kernels. While Android is Linux, there are some small differences that need to be accounted for. In the following example, the BSP is configured to build for Cubieboard2:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ ./configure cubieboard2</strong>
<strong>cubieboard2 configured. Now run `make`</strong>
</pre></div><p>Now, before running, as suggested by the BSP, one more thing needs to be mentioned. The BSP wants to know what compiler to use, and it knows this from the <code class="literal">CROSS_COMPILE=</code> parameter. By default, this parameter is forced to <code class="literal">arm-linux-gnueabihf-</code> via the Makefile, which is the prefix to the installed arm compiler. Thus <code class="literal">gcc</code> is expected to be named <code class="literal">arm-linux-gnueabihf-gcc</code>. Things get more interesting when compiling natively on one of these boards. This is because in theory, no cross-compiler is desired, <code class="literal">gcc</code> should just be called gcc. To remedy this, pass an empty <code class="literal">CROSS_COMPILE=</code> parameter to make, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ make CROSS_COMPILE=</strong>
</pre></div><p>Otherwise, the installed compiler prefix needs to be added, and yes, the dash at the end is a part of the prefix. If you are compiling on Debian, the following command  can be used:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ make CROSS_COMPILE=arm-none-eabi-</strong>
</pre></div><p>Every distribution tends to name their cross-compiler differently; there is no right or wrong. Using arm- and double tab completion should yield the prefix for almost all distributions. Also, adding the correct cross-compiler prefix to the Makefile can be very helpful here.</p><p>Depending on <a id="id365" class="indexterm"/>the amount of memory and which system is used to perform the compilation, this could take from several minutes to an hour or two! If there are strange crashes or problems, before looking at <a class="link" href="apa.html" title="Appendix A. Getting Help and Finding Other Helpful Online Resources">Appendix A</a>, <em>Getting Help and Other Helpful Online Resources</em>, about contacting the community for support, make sure that the chosen board is properly supported and supplied with adequate power. Quite often, overclocked memory or a lack of enough power will show up under the heavy stresses that a kernel compilation encompasses.</p><p>While it is nice to be able to compile the standard kernel, often, someone will want to compile a kernel due to customization, for example, with certain drivers or options added or removed. Even a custom patch is something that needs a custom-compiled kernel. Normally, the <code class="literal">menuconfig</code> command<a id="id366" class="indexterm"/> is used in a kernel directory. The BSP also allows this by passing the <code class="literal">linux-config</code> parameter to the <code class="literal">make</code> command, as follows:</p><div><pre class="programlisting">
<strong>packt@PacktPublishing:~/sunxi-bsp$ make linux-config CROSS_COMPILE=arm-none-eabi-</strong>
</pre></div><p>Following this will yield a standard <code class="literal">menuconfig</code> session.</p><p>Some other parameters to the <code class="literal">make</code> command are Linux or u-boot, which are used to compile only the Linux kernel or only u-boot. The resulting binaries will be located under the <code class="literal">sunxi-bsp/build</code> directory under their own respective trees.</p><p>When the compilation is completed, a so-called hwpack or hardware pack is created in the <code class="literal">sunxi-bsp/output</code> directory. The hardware pack is an archive containing three subdirectories. The first is called <code class="literal">bootloader</code> and contains the <code class="literal">u-boot-sunxi-with-spl.bin</code> bootloader.</p><p>In the <code class="literal">kernel</code> subdirectory, the board-specific kernel, named <code class="literal">uImage</code>, lives combined with the board specific <code class="literal">script.bin</code> file.</p><p>The final directory <a id="id367" class="indexterm"/>is the <code class="literal">rootfs</code> directory. This directory contains everything specific for the chosen target board. The content can and should be copied to the target root filesystem.</p><p>Installing the files in the hwpack, specifically the bootloader, was described well in the <a class="link" href="ch06.html" title="Chapter 6. Updating the Bootloader and Kernel">Chapter 6</a>, <em>Updating the Bootloader and Kernel</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, the basics of the BSP were covered. Using the BSP in combination with Git, which is a powerful tool to download and manage the various source repositories, you can compile various components and generate an easy-to-use device-specific hardware pack.</p><p>The next chapter will cover <strong>general purpose input output pins</strong> (<strong>GPIOs</strong>). This can be useful to do various jobs, including blinking an LED!</p></div></body></html>