- en: 7 SSH Hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file49.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Secure Shell** (**SSH**) suite is one of those must-have tools for Linux
    administrators. It allows you to take care of Linux servers from the comfort of
    your cubicle, or even from the comfort of your own home. Either way, it's a lot
    better than having to don your parka and jump through security hoops to enter
    a cold server room. The *secure* in Secure Shell means that everything that you
    either type or transfer gets encrypted. That eliminates the possibility of someone
    obtaining sensitive data by plugging a sniffer into your network.
  prefs: []
  type: TYPE_NORMAL
- en: By this stage in your Linux career, you should already know how to use Secure
    Shell, or SSH, to do remote logins and remote file transfers. What you may not
    know is that the default configuration of SSH is actually quite insecure. In this
    chapter, we'll look at how to harden the default configuration in various ways.
    We'll look at how to use encryption algorithms that are stronger than the default,
    how to set up passwordless authentication, and how to set up a jail for users
    of the Secure File Transfer Protocol (SFTP). As a bonus, we'll look at how to
    scan SSH servers to find vulnerable configurations and how to share a remote directory
    via **Secure Shell Filesystem** (**SSHFS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that SSH protocol 1 is disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and managing keys for passwordless logins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling root user login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling username/password logins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling two-factor authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Secure Shell with strong encryption algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting system-wide encryption policies on RHEL 8/9-type systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIPS mode on RHEL 8/9-type systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring more detailed logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access control with whitelists and TCP Wrappers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring automatic logouts and security banners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other miscellaneous security settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up different configurations for different hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up different configurations for different users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning an SSH server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a chroot environment for SFTP users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up shared directories with SSHFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely connecting from Windows desktops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, if you're ready, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that SSH protocol 1 is disabled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the two previous editions of this book, I told you about how Version 1 of
    the SSH protocol is severely flawed, and how you should always ensure that it’s
    not enabled in the `/etc/ssh/sshd_config` file. Nowadays you don’t have to worry
    about that, because SSH protocol 1 is now gone, and is nothing but a thing of
    the past. So, yee-haw! It’s time to celebrate.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing keys for passwordless logins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Secure Shell suite is a great set of tools for communications with remote
    servers. You can use the `ssh` component to remotely log into the command line
    of a remote machine, and you can use either `scp` or `sftp` to securely transfer
    files. The default way to use any of these SSH components is to use the username
    of a person''s normal Linux user account. So, logging into a remote machine from
    the terminal of my OpenSUSE workstation would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While it's true that the username and password go across the network in an encrypted
    format, making it hard for malicious actors to intercept, it's still not the most
    secure way of doing business. The problem is that attackers have access to automated
    tools that can perform brute-force password attacks against an SSH server. Botnets,
    such as the Hail Mary Cloud, perform continuous scans across the Internet to find
    Internet-facing servers with SSH enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If a botnet finds that the servers allow SSH access via username and password,
    it will launch a brute-force password attack. Sadly, such attacks have been successful
    quite a few times, especially when the server operators allow the root user to
    log in via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: 'This older article provides more details about the Hail Mary Cloud botnet:
    [http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/](http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the next section, we''ll look at two ways to help prevent these types of
    attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSH logins through an exchange of public keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling the root user login through SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's create some keys.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user's SSH key set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each user has the ability to create his or her own set of private and public
    keys. It doesn't matter whether the user's client machine is running Linux, macOS,
    Cygwin on Windows, or Bash Shell for Windows. In all cases, the procedure is exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different types of keys that you can create, and 3072-bit
    RSA keys are normally the default. Until very recently, 2,048-bit RSA keys were
    considered strong enough for the foreseeable future. But now, the most recent
    guidance from the US **National Institute of Standards and Technology** (**NIST**)
    says to use either an RSA key of at least 3,072 bits or an **Elliptic Curve Digital
    Signature Algorithm** (**ECDSA**) key of at least 384 bits. (You'll sometimes
    see these ECDSA keys referred to as *P-384.*) Their reasoning is that they want
    to get us ready for quantum computing, which will be so powerful that it will
    render any weaker encryption algorithms obsolete. Of course, quantum computing
    isn't practical yet, and so far, it seems to be one of those things that's always
    just ten years off in the future, regardless of what year it is. But even if we
    discount the whole quantum thing, we still have to acknowledge that even our current,
    non-quantum computers keep getting more and more powerful. So, it's still not
    a bad idea to start going with stronger encryption standards.
  prefs: []
  type: TYPE_NORMAL
- en: To see the NIST list of recommended encryption algorithms and the recommended
    key lengths, go to [https://cryptome.org/2016/01/CNSA-Suite-and-Quantum-Computing-FAQ.pdf](https://cryptome.org/2016/01/CNSA-Suite-and-Quantum-Computing-FAQ.pdf).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For these next few demos, let''s switch over to an Ubuntu 22.04 client. To
    create a 3072 RSA key pair, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We didn’t have to use any option switches, because the command will already
    create a 3072-bit RSA pair by default. When prompted for the location and name
    of the keys, I'll just hit the **Enter** key to accept the defaults. You could
    just leave the private key with a blank passphrase, but that's not a recommended
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you choose an alternative name for your key files, you'll need
    to type in the entire path to make things work properly. For example, in my case,
    I could specify the path for `donnie_rsa` keys as `/home/donnie/.ssh/donnie_rsa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll see your new keys in the `.ssh` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `id_rsa` key is the private key, with read and write permissions only for
    me. The `id_rsa.pub` public key has to be world-readable. For ECDSA keys, the
    default length is 256 bits. If you choose to use ECDSA instead of RSA, do the
    following to create a strong 384-bit key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, when you look in the `.ssh` directory, you''ll see that the ECDSA
    keys are named differently from the RSA keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of elliptic curve algorithms is that their seemingly short key lengths
    are just as secure as RSA keys with longer key lengths. And, even the largest
    ECDSA keys require less computing power than RSA keys. The maximum key length
    you can do with ECDSA is 521 bits. (Yes, you read that correctly. It's 521 bits,
    not 524 bits.) So, you may be thinking, *Why don't we just go for the gusto with
    521-bit keys?* Well, it's mainly because 521-bit keys aren't recommended by NIST.
    There's some fear that they may be subject to **padding attacks**, which could
    allow the bad guys to break your encryption and steal your data.
  prefs: []
  type: TYPE_NORMAL
- en: If you take a gander at the man page for `ssh-keygen`, you'll see that you can
    also create an `Ed25519` type of key, which you'll sometimes see referred to as
    `curve25519`. This one isn't included in the NIST list of recommended algorithms
    and also isn’t allowed by the FIPS regulations, but there are a couple of reasons
    why some people like to use it.
  prefs: []
  type: TYPE_NORMAL
- en: RSA and DSA can leak private key data when creating signatures if the random
    number generator of the operating system is flawed. `Ed25519` doesn't require
    a random number generator when creating signatures, so it's immune to this problem.
    Also, `Ed25519` is coded in a way that makes it much less vulnerable to side-channel
    attacks. (A side-channel attack is when someone tries to exploit weaknesses in
    the underlying operating system, rather than in the encryption algorithm.)
  prefs: []
  type: TYPE_NORMAL
- en: The second reason why some folk like `Ed25519` is precisely because it's *not*
    on the NIST list. These are the folk who, rightly or wrongly, don't trust the
    recommendations of government agencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite a few years ago, in the early part of this century, there was a bit of
    a scandal that involved the **Dual Elliptic Curve Deterministic Random Bit Generator**
    (**Dual_EC_DRBG**). This was a random number generator that was meant for use
    in elliptic curve cryptography. The problem was that, early on, some independent
    researchers found that it had the capability to have *back doors* inserted by
    anyone who knew about this capability. And, it just so happened that the only
    people who were supposed to know about this capability were the folk who work
    at the U.S. **National Security Agency** (**NSA**). At the NSA''s insistence,
    NIST included Dual_EC_DRBG in their NIST list of recommended algorithms, and it
    stayed there until they finally removed it in April 2014\. You can get more details
    about this at the following links:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.pcworld.com/article/2454380/overreliance-on-the-nsa-led-to-weak-crypto-standard-nist-advisers-find.html](https://www.pcworld.com/article/2454380/overreliance-on-the-nsa-led-to-weak-crypto-standard-nist-advisers-find.html)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://www.math.columbia.edu/~woit/wordpress/?p=7045](http://www.math.columbia.edu/~woit/wordpress/?p=7045)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can read the details about Ed25519 here: [https://ed25519.cr.yp.to/](https://ed25519.cr.yp.to/).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There''s only one key size for `Ed25519`, which is 256 bits. So, to create
    a `curve25519` key, just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the keys that I''ve created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, however, some potential downsides to `ed25519`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it isn't supported by older SSH clients. However, if everyone on your
    team is using current operating systems that use current SSH clients, this shouldn't
    be a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second is that it only supports one certain set key length, which is the
    equivalent of either 256-bit elliptic curve algorithms or 3,000-bit RSA algorithms.
    So, it might not be quite as future-proof as the other algorithms that we've covered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, you can't use it if your organization is required to remain compliant
    with either NIST recommendations or FIPS requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, there is one other type of key that we haven't covered. That's the old-fashioned
    DSA key, which `ssh-keygen` will still create if you tell it to. But, don't do
    it. The DSA algorithm is old, creaky, and very insecure by modern standards. So,
    when it comes to DSA, just say *No*.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring the public key to the remote server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transferring my public key to a remote server allows the server to readily
    identify both me and my client machine. Before I can transfer the public key to
    the remote server, I need to add the private key to my session keyring. This requires
    two commands. (One command invokes `ssh-agent`, while the other actually adds
    the private key to the keyring):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I can transfer my public key(s) to my AlmaLinux 9 server, which is
    at address `192.168.0.17`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you would only create one pair of keys of whichever type you choose.
    As you can see here, I've created three key pairs, one pair of each type. All
    three private keys were added to my session keyring, and all three public keys
    were transferred to the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next time that I log in, I''ll use the key exchange, and I won''t have
    to enter a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned previously, you would normally only create one key pair per machine.
    However, there are exceptions to this rule. Some administrators prefer to use
    a different key pair for each server that they administer, rather than using the
    same key pair for all servers. A handy way to do this is to create keys with filenames
    that match the hostnames of the respective servers. Then, you can use the `-i`
    option to specify which key pair that you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I only have one server, but I have multiple keys for it. Let''s
    say that I prefer to use the `Ed25519` keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now you''re wondering, *How is that secure if I can log in without entering
    my password?* The answer is that once you close the client machine''s terminal
    window that you used for logging in, the private key will be removed from your
    session keyring. When you open a new terminal and try to log in to the remote
    server, you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, every time I log into this server, I'll need to enter the passphrase for
    my private key, until I add it back to the session keyring with the two commands
    that I showed you in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – Creating and transferring SSH keys
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this lab, you'll use one virtual machine (VM) as your client, and one VM
    as the server. Alternatively, if you're using a Windows host machine, you can
    use Cygwin, PowerShell, or the built-in Windows Bash shell for the client. (Be
    aware, though, that PowerShell and the Windows Bash shell store the key files
    in alternate locations.) If you're on either a Mac or a Linux host machine, you
    can use the host machine's native command-line terminal as the client. In any
    case, the procedure will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: For the server VM, use either Ubuntu 22.04 or CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure does work the same on AlmaLinux 8 and 9\. However, we'll be using
    this same VM for the next few labs, and AlmaLinux has some special considerations
    that we'll look at later.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client machine, create a pair of 384-bit elliptic curve keys. Accept
    the default filename and location and create a passphrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the keys, taking note of the permissions settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add your private key to your session keyring. Enter your passphrase when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer the public key to the server VM. When prompted, enter the password
    for your user account on the server VM. (Substitute your own username and IP address
    in the following command.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Log into the server VM as you normally would:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the `authorized_keys` file that was created on the server VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Log out of the server VM and close the terminal window on the client. Open another
    terminal window and try to log into the server again. This time, you should be
    prompted to enter the passphrase for your private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log back out of the server VM and add your private key back to the session
    keyring of your client. Enter the passphrase for your private key when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As long as you keep this terminal window open on your client, you'll be able
    to log into the server VM as many times as you want without having to enter a
    password. However, when you close the terminal window, your private key will be
    removed from your session keyring.
  prefs: []
  type: TYPE_NORMAL
- en: Keep your server VM, because we'll do more with it in a bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: What we've done here is good, but it's still not quite enough. One flaw is that
    if you go to another client machine, you'll still be able to use the normal username/password
    authentication to log in. That's okay; we'll fix that in a few moments.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling root user login
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few years ago, there was a somewhat celebrated case where malicious actors
    had managed to plant malware on quite a few Linux servers somewhere in southeast
    Asia. There were three reasons that the bad guys found this so easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: The Internet-facing servers involved were set up to use username/password authentication
    for SSH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root user was allowed to log in through SSH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User passwords, including the root user's password, were incredibly weak.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this meant that it was easy for the Hail Mary botnet to brute-force its
    way in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different distros have different default settings for root user login. In the
    `/etc/ssh/sshd_config` file of your CentOS 7 or AlmaLinux 8 machine, you''ll see
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike what you have in most configuration files, the commented-out lines in
    `sshd_config` define the default settings for the Secure Shell daemon. So, this
    line indicates that the root user is indeed allowed to log in through SSH. To
    change that, I''ll remove the comment symbol and change the setting to `no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the new setting take effect, I''ll reload the SSH daemon, which is
    named `sshd` on CentOS and AlmaLinux, and is named `ssh` on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Ubuntu machine, the default setting looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This means that the root user is allowed to log in, but only via a public key
    exchange. This is probably secure enough if you really need to allow the root
    user to log in. But in most cases, you'll want to force admin users to log in
    with their normal user accounts and use `sudo` for their admin needs. So, in most
    cases, you still want to change this setting to `no`.
  prefs: []
  type: TYPE_NORMAL
- en: On your AlmaLinux 9 machine, you’ll see that it also has `PermitRootLogin` set
    to `prohibit-password` by default.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that if you deploy a Linux instance on a cloud service, such as Rackspace
    or Vultr, the service owners will have you log into the VM with the root user
    account. The first thing you'll want to do is create your own normal user account,
    log back in with that account, disable the root user account, and disable the
    root user login in `sshd_config`. Microsoft Azure is one exception to this rule
    because it automatically creates a non-privileged user account for you.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You'll be able to practice this in just a few moments, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling username/password logins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is something that you'll only want to do after you've set up the key exchange
    with your clients. Otherwise, clients will be locked out of doing remote logins.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – disabling root login and password authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this lab, use the same server VM that you used for the previous lab. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On either an Ubuntu, CentOS, or AlmaLinux 8 server VM, look for this line in
    the `sshd_config` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the comment symbol, change the parameter value to `no`, and reload the
    SSH daemon. The line should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, when the botnets scan your system, they'll see that doing a brute-force
    password attack would be useless. They'll then just go away and leave you alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for either of these two lines, depending on whether the server is an Ubuntu
    or a CentOS 7/AlmaLinux 8 VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment the line and change it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the SSH daemon so that it will read in the new changes. On Ubuntu, do
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS/AlmaLinux, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Attempt to log into the server VM from the client that you used in the previous
    lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attempt to log into the server VM from another client on which you haven't created
    a key pair. (You shouldn't be able to.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As before, keep the server VM, because we'll do more with it in a bit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered how to create a private/public key pair on the client
    side and how to transfer the public key to the server, let’s talk about setting
    up two-factor authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling two-factor authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two-factor authentication can give an extra layer of protection. If you own
    a smart phone, you can set this up with **Google Authenticator**, which will present
    you with a **one-time password** for logging in at the local terminal, invoking
    a `sudo` command, or logging in remotely via SSH. Before we get started though,
    there are a few caveats that you need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: To make this work on a Linux machine, you’ll need to install a PAM module that
    isn’t supplied by Google. It’s in the repositories for some, but not all, Linux
    distros. (Of course, you could download the source code from the Github repository
    and compile it yourself, but that’s beyond the scope of this book.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creator of this PAM module has created some semblance of documentation,
    but it’s not very useful. If you search for documentation, you’ll find some blog
    posts with procedures that are worse than useless, because they *will* break your
    system if you follow them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set up your machine to require Google Authentication for either global
    usage, or for just logging in via SSH. (Global usage means that an Authenticator
    code will be needed for logging in at the local terminal, using `sudo`, *and*
    logging in remotely via SSH.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re dealing with multiple users, each user will need to set up Google
    Authenticator for his or her own user account, with his or her own smart phone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, with that out of the way, let’s set up our Ubuntu 22.04 server with Google
    Authenticator for local log-ins and sudo:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this PAM module is in the normal Ubuntu repository and in the EPEL
    repository for RHEL 8-type distros. It’s not available at all for RHEL 9-type
    distros.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hands-on lab--Setting up two-factor authentication on Ubuntu 22.04
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this lab, start with a fresh Ubuntu 22.04 virtual machine that’s not set
    up for public key authentication. (That will save a lot of confusion when going
    through this procedure.)
  prefs: []
  type: TYPE_NORMAL
- en: Install Google Authenticator on your smart phone. (It’s in the normal app stores
    for both Android and iPhone.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On your Ubuntu VM, install the `libpam-google-authenticator` package, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For this step, if you haven’t already, use SSH to remotely log into the Ubuntu
    VM from the GUI-type terminal of your host machine. (That’s because you might
    need to resize things to make the next step work.) Now, from this GUI-type terminal,
    run the `google-authenticator` app, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A big QR code will now show up on your screen. If the whole code graphic isn’t
    visible, use your GUI terminal controls to zoom out until the whole graphic is
    visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring up the Google Authenticator app on your smart phone, and touch the `+`
    sign in the lower right-hand corner of the screen. Choose the **Scan a QR code**
    option, and then take a picture of your QR code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On your smart phone, note that a new entry for your Ubuntu VM has been added
    to the list. On the Ubuntu VM, enter the verification code that shows up with
    that entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing you’ll see on the Ubuntu terminal is your emergency scratch codes.
    Copy them down and store them in a safe location. (If you lose your mobile phone,
    you’ll use these scratch codes to log in.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you’ll be asked series of questions. Just enter `y` for everything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this step, you’ll set up two-factor authentication for logging in at the
    local terminal and for using `sudo`. Open the `/etc/pam.d/common-auth` file in
    your favorite text editor. Add the `auth required pam_google_authenticator.so`
    line as the first parameter. The top portion of the file should now look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Certain blog posts that you’ll find tell you to add this line to the *end* of
    the file. Be aware that if you do that, you *will* get locked out of your machine,
    and you’ll need to perform an emergency procedure to get back in to fix it. Any
    time you edit a PAM file, it’s vitally important that you place the directives
    in the proper order. (In case you’re wondering, I’ll show you the emergency procedure
    in *Chapter 16*, *Security Tips & Tricks for the Busy Bee*.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the local terminal of the Ubuntu VM, log out and then log back in. When prompted,
    enter the verification code from your smart phone app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform a command that requires `sudo` privileges. You should see something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that you won’t be required to enter a verification code again until the
    `sudo` timer times out.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From either your host machine or another virtual machine, remotely log into
    the Ubuntu VM via SSH. You should still be able to do that, because we haven’t
    yet configured the `/etc/ssh/sshd_config` file. Open the `sshd_config` file in
    your text editor, and change the `KbdInteractiveAuthentication no` line to `KbdInteractiveAuthentication
    yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reload the Secure Shell configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Try logging in again from either your host machine or another virtual machine.
    This time, you should be prompted to enter your verification code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s say that your organization needs two-factor authentication for remote
    SSH logins, but doesn’t need it for either local logins or `sudo` operations.
    Let’s change the configuration so that only remote users will need to enter a
    code. Open the `/etc/pam.d/common-auth` file in your text editor, and remove the
    line that you inserted in Step 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `/etc/pam.d/sshd` file in your text editor, and add that line just
    under the `@include common-auth` line at the top of the file. The top portion
    of the file should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to log in to the local terminal and perform `sudo` actions
    without having to enter a verification code. Instead, you should only have to
    enter a verification code when logging in remotely.
  prefs: []
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s look at using Google Authenticator together with key exchange on
    our Ubuntu machine.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab--Using Google Authenticator with key exchange on Ubuntu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this lab, use the same Ubuntu virtual machine that you used for the previous
    lab.
  prefs: []
  type: TYPE_NORMAL
- en: On either your host machine or another virtual machine, create a pair of keys
    and transfer them to the Ubuntu virtual machine, as you did in the *Creating and
    transferring SSH keys* lab. This time, you should be prompted to enter a verification
    code when you execute the `ssh-copy-id` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Ubuntu virtual machine, open the `/etc/ssh/sshd_config` file in your
    text editor. This time, instead of changing the `#PasswordAuthentication yes`
    line, add this line below the `KbdInteractiveAuthentication yes` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After reloading the SSH configuration, you’ll see that you’ll be able to remotely
    log in by using key exchange if you’re logging in from a machine that has that
    set up. If you’re logging in from a machine that doesn’t have key exchange set
    up, you’ll still be able to log in with a password and a verification code. So,
    we don’t have true two-factor authentication just yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To require both key-based authentication and Google Authenticator verification,
    change the above line to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After reloading the SSH configuration, you’ll only be allowed to log in from
    machines for which you’ve set up key exchange. You now effectively have three-factor
    authentication, because you’ll still be prompted to enter your normal login password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To disable the password login so that you’ll only be using key exchange and
    a verification code, open the `/etc/pam.d/sshd` file in your text editor. At the
    very top of the file, find the `@include common-auth` line and change it to `#@include
    common-auth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the key exchange works by trying to log in from a virtual machine
    on which you haven’t performed the key exchange setup. (You shouldn’t be allowed
    to.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s it. End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s see what we can do with AlmaLinux 8.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab--Setting up two-factor authentication on AlmaLinux 8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For this lab, I assume that you’ve already installed the Google Authenticator
    app on your smart phone.
  prefs: []
  type: TYPE_NORMAL
- en: The Authenticator PAM module isn’t in any of the repositories for the RHEL 9
    distros, but it is in the EPEL repository for the RHEL 8 distros. (That might
    change by the time you read this, so it won’t hurt to check if you want to try
    this on AlmaLinux 9.) So, fire up a fresh AlmaLinux 8 VM, and let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the PAM module like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that you need the `qrencode-libs` package in order to produce a QR code.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the GUI terminal of your host machine, use SSH to remotely log into the
    AlmaLinux 8 VM. This will allow you to resize the QR code image so that you can
    take a picture of it with your smart phone. Then, run the `google-authenticator`
    app, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This time, we’re creating the `google_authenticator` file within the `.ssh`
    directory, because AlmaLinux is set up to use SELinux. When you try to log in
    remotely with Authenticator enabled, the SSH daemon will try to write to the `google_authenticator`
    file. SELinux prevents SSH from writing to files that are outside of the `.ssh`
    directory. (We’ll talk more about SELinux in *Chapter 10*, *Implementing Mandatory
    Access Control with SELinux and AppArmor*.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow through on the Authenticator setup, the same as you did in Steps 4 through
    8 of the *Setting up two-factor authentication on Ubuntu 22.04* lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `/etc/pam.d/sshd` file in your text editor. Add this line to the very
    bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: (Note that the line wraps around on the printed page.)
  prefs: []
  type: TYPE_NORMAL
- en: Open the `/etc/ssh/sshd_config` file in your text editor. Find the line that
    says `#ChallengeResponseAuthentication no` and change it to `ChallengeResponseAuthentication
    yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reload or restart the `sshd` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the proper SELinux security context on the google_authenticator file that
    you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Log out of the remote session, and try logging back in. This time, you should
    be prompted to enter a verification code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s set AlmaLinux up for using key exchange.
  prefs: []
  type: TYPE_NORMAL
- en: Hand-on lab--Using Google Authenticator with key exchange on AlmaLinux 8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This will mostly be the same as it was for Ubuntu, with only a few differences.
  prefs: []
  type: TYPE_NORMAL
- en: Transfer the public key from your host machine to the AlmaLinux 8 machine as
    you did in the *Creating and transferring SSH keys* lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `/etc/ssh/sshd_config` file, change the `#PasswordAuthentication yes`
    line to `PasswordAuthentication no`, and reload the SSH configuration. Now, you’ll
    only be using key exchange to log in, which will completely bypass the Authenticator.
    Let’s fix things so that you’ll be using both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `/etc/ssh/sshd_config` file, add the following line just beneath the
    `PasswordAuthentication no` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: After reloading the SSH configuration, you’ll have three-factor authentication,
    because you’ll need to enter both your password and a verification code along
    with the key exchange.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If desired, you can easily disable the password prompt and just use the key
    exchange and verification code. In the `/etc/pam.d/sshd` file, find the `auth
    substack password-auth` line at the top of the file, and change it to `#auth substack
    password-auth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That’s all there is to Google Authenticator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, let’s make sure that we’re only using the strongest encryption
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Secure Shell with strong encryption algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As I mentioned previously, the current set of NIST recommendations, the **Commercial
    National Security Algorithm Suite** (**CNSA Suite**), involves using stronger
    algorithms and longer keys than what we needed to use previously. I''ll summarize
    the new recommendations here in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| RSA, 3,072 bits or larger | Key establishment and digital signatures |'
  prefs: []
  type: TYPE_TB
- en: '| Diffie-Hellman (DH), 3,072 bits or larger | Key establishment |'
  prefs: []
  type: TYPE_TB
- en: '| ECDH with NIST P-384 | Key establishment |'
  prefs: []
  type: TYPE_TB
- en: '| ECDSA with NIST P-384 | Digital signatures |'
  prefs: []
  type: TYPE_TB
- en: '| SHA-384 | Integrity |'
  prefs: []
  type: TYPE_TB
- en: '| AES-256 | Confidentiality |'
  prefs: []
  type: TYPE_TB
- en: In other publications, you might see that NIST Suite B is the recommended standard
    for encryption algorithms. Suite B is an older standard that has been replaced
    by the CNSA Suite.
  prefs: []
  type: TYPE_NORMAL
- en: Another cryptographic standard that you might have to work with is the **Federal
    Information Processing Standard** (**FIPS**), which is also promulgated by the
    U.S. government. The current version is FIPS 140-3, which gained its final approval
    on September 22, 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SSH encryption algorithms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'SSH works with a combination of symmetric and asymmetric cryptography, similar
    to how Transport Layer Security works. The SSH client starts the process by using
    the public key method to set up an asymmetric session with an SSH server. Once
    this session has been set up, the two machines can agree on and exchange a secret
    code, which they''ll use to set up a symmetric session. (As we saw previously
    with TLS, we want to use symmetric cryptography for performance reasons, but we
    need an asymmetric session to perform the secret key exchange.) To perform this
    magic, we need four classes of encryption algorithms, which we''ll configure on
    the server side. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ciphers**: These are the symmetric algorithms that encrypt the data that
    the client and server exchange with each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HostKeyAlgorithms**: This is the list of host key types that the server can
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KexAlgorithms**: These are the algorithms that the server can use to perform
    the symmetric key exchange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAC**: Message Authentication Codes are hashing algorithms that cryptographically
    sign the encrypted data in transit. This ensures data integrity and will let you
    know if someone has tampered with your data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best way to get a feel for this is to look at the `sshd_config` man page,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I could use any VM to demo this. For now, though, I'm going with CentOS 7, unless
    I state otherwise. (The lists of default and available algorithms will be different
    for different Linux distributions and versions.) Also, note that to demo this,
    we want to look at in the `sshd_config` man page to see the lists of algorithms
    that are **available** and **enabled**. The **enabled** list is in the man pages
    for CentOS 7 and AlmaLinux 8, but not in the man page for AlmaLinux 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the list of supported ciphers. Scroll down the man page
    until you see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'However, not all of these supported ciphers are enabled. Just below this list,
    we can see the list of ciphers that are enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in alphabetical order, are the **HostKeyAlgorithms**. The list on CentOS
    7 looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, scroll down to the **KexAlgorithms** (short for **Key Exchange Algorithms**)
    section. You''ll see a list of supported algorithms, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that this list can vary from one distribution to the next. For example,
    RHEL 8/AlmaLinux 8 supports three additional algorithms that are newer and stronger.
    Its list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see the same list on an AlmaLinux 9 machine, except that the `sntrup761x25519-sha512@openssh.com`
    algorithm has been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll see the list of algorithms that are enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This list can also vary from one Linux distribution to another. (In this case,
    though, there's no difference between CentOS 7 and AlmaLinux 8.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the MAC algorithms. The default list of enabled algorithms
    looks like this on CentOS 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the list of algorithms that your particular system supports, either
    look at the `sshd_config` man page for that machine or perform the following `ssh
    -Q` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When you look in the `/etc/ssh/sshd_config` file, you won't see any lines that
    configure any of these algorithms. That's because the default list of algorithms
    is hard coded into the SSH daemon. The only time you'll configure any of these
    is if you want to either enable an algorithm that isn't enabled or disable one
    that is. Before we do that, let's scan our system to see what is enabled and see
    if the scanner can make any recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for enabled SSH algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have two good ways to scan an SSH server. If your server is accessible via
    the Internet, you can go to the SSHCheck site at [https://sshcheck.com/](https://sshcheck.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Then, just type in either the IP address or hostname of your server. If you've
    changed the port from the default port `22`, enter the port number as well. When
    the scan completes, you'll see the list of enabled algorithms, along with recommendations
    on which ones to either enable or disable.
  prefs: []
  type: TYPE_NORMAL
- en: If the machine that you want to scan isn't accessible from the Internet, or
    even if it is, you can use a local scanning tool. In the previous edition of this
    book, we used the **ssh_scan** tool. Sadly, this tool is no longer supported,
    and it doesn’t work on newer Linux distros that come with OpenSSL version 3\.
    So instead, let’s try this with the Nmap scripting engine.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – Scanning with Nmap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this lab, you can use any of your virtual machines. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `nmap` package from your normal distro repository. On Ubuntu
    do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS 7, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'On AlmaLinux 8 or 9, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `nmap` with the `ssh2-enum-algos.nse` script to scan the server VM that
    you created and configured in the previous labs. Substitute your own IP address
    for the one I''m using here. Note that even if you haven''t created a key pair
    on the scanner machine, the scan still works against machines that have had username/password
    authentication disabled. (But, of course, you won''t be able to log in from the
    scanner machine):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if you’re scanning a machine with an enabled firewall, you might
    get an error message about how the scan has been blocked. If that happens, try
    adding the `-Pn` switch, so that the command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the scan, but this time, save the output to a normal text file, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Open the text file in a normal text editor or pager. You'll see a complete list
    of all of the algorithms that are enabled. Compare your results with the standards
    that are applicable to your circumstances, such as NIST's CNSA standard, to be
    sure you enable or disable the right things.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On either your host machine or a VM with a desktop interface, visit the Shodan
    website at [https://www.shodan.io](https://www.shodan.io). Type `ssh` into the
    search window and observe the list of Internet-facing SSH servers that comes up.
    Click on different IP addresses until you find an SSH server that's *not* running
    on the default port `22`. Observe the list of enabled algorithms for that device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scan the device, using the `-p` switch to scan the different port, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that in addition to the list of enabled algorithms that you saw on Shodan,
    you now have a list of weak ones that the owner of this device needs to disable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep both this scanner and this server VM handy, because we'll use them again
    after we disable some algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's disable some of the creaky, old, and weak stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling weak SSH encryption algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I said before, we want to compare our scan results against the NIST recommendations,
    and configure things accordingly. Understand though, that the list of available
    algorithms differs from one Linux distro to the next. To make things less confusing,
    I'll present two hands-on procedures in this section. One is for Ubuntu 22.04,
    while the other is for CentOS 7\. AlmaLinux 8 and 9 have their own unique way
    of doing business, so I'm saving that for the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – disabling weak SSH encryption algorithms – Ubuntu 22.04
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this lab, you''ll need the VM that you''ve been using as a scanner, and
    another Ubuntu 22.04 VM to scan and configure. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t done so already, scan the Ubuntu 22.04 VM and save the output
    to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of lines in the file by doing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'On the target Ubuntu 22.04 VM, open the `/etc/ssh/sshd_config` file in your
    preferred text editor. Toward the top of the file, find these two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Beneath those two lines, insert these three lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the `Ciphers` and `MACs` lines, you see a comma-separated list of algorithms
    that were disabled by the preceding `-` sign. (You only need one `-` to disable
    all the algorithms in the list.) In the `KexAlgorithms` line, there's no `-` sign.
    This means that the algorithm that's listed on that line is the only one that
    is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the file and restart the SSH daemon. Verify that it started correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Scan the Ubuntu 22.04 VM again, saving the output to a different file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of lines in the new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'On the scanner VM, use `diff` to compare the two files. You should see fewer
    algorithms than you saw previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The sharp-eyed among you will notice that we left one Cipher that isn't on the
    NIST CNSA list. `chacha20-poly1305@openssh.com` is a lightweight algorithm that's
    good for use with low-powered, hand-held devices. It's a good, strong algorithm
    that can replace the venerable **Advanced Encryption Standard** (**AES**) algorithm,
    but with higher performance. However, if you have to remain 100% compliant with
    the NIST CNSA standard, then you might have to disable it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's work with CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – disabling weak SSH encryption algorithms – CentOS 7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You''ll notice two things when you start working with CentOS 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '**More algorithms enabled**: A default SSH configuration on CentOS 7 has a
    lot more enabled algorithms than what Ubuntu 22.04 has. This includes some really
    ancient stuff that you really don''t want to see anymore. I''m talking about things
    such as Blowfish and 3DES, which should have been retired years ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A different configuration technique**: On CentOS, placing a `-` sign in front
    of a list of algorithms that you want to disable doesn''t work. Instead, you''ll
    need to list all of the algorithms that you want to enable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this lab, you''ll need a CentOS 7 VM and the same scanner VM that you''ve
    been using. With that in mind, let''s get to work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scan the CentOS 7 VM and save the output to a file. Note that due to the CentOS
    7 firewall, you’ll need to add the `-Pn` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of lines in the output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'On the target CentOS 7 VM, open the `/etc/ssh/sshd_config` file in your preferred
    text editor. Toward the top of the file, find these two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Beneath those two lines, insert these three lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned previously, with CentOS, using `-` to disable algorithms doesn't
    work. Instead, we have to list all of the algorithms that we do want to enable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the file and reload the SSH daemon. Verify that it started correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Scan the CentOS 7 VM again, saving the output to a different file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of lines in the new output file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'On the scanner VM, use `diff` to compare the two files. You should see fewer
    algorithms than you saw previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As before, I left the `chacha20-poly1305@openssh.com` algorithm enabled. If
    you have to remain 100% compliant with the NIST CNSA standard, then you might
    have to disable it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at a handy new feature that comes with the RHEL 8 and 9 families.
  prefs: []
  type: TYPE_NORMAL
- en: Setting system-wide encryption policies on RHEL 8/9 and AlmaLinux 8/9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter 6*, *Encryption Technologies*, we briefly looked at how to set
    system-wide encryption policies on AlmaLinux 8 and 9\. With this cool feature,
    you no longer have to configure crypto policies for each individual daemon. Instead,
    you just run a couple of simple commands, and the policy is instantly changed
    for multiple daemons. To see which daemons are covered, look in the `/etc/crypto-policies/back-ends/`
    directory. Here''s a partial view of what''s there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, this directory contains symbolic links to text files that contain
    directives about which algorithms to either enable or disable for the `DEFAULT`
    configuration. One level up, in the `/etc/crypto-policies/` directory, there''s
    the `config` file. Open it, and you''ll see that this is where the system-wide
    configuration is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Scanning this VM with its `DEFAULT` configuration shows that quite a few older
    algorithms are still enabled. To get rid of them, we can change to either `FUTURE`
    mode or to `FIPS` mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At the time of this writing, the EPEL repository uses a security certificate
    that’s not compatible with `FUTURE` mode. This will prevent you from updating
    or installing any software packages from the EPEL repository. If you need to set
    your machine with both `FUTURE` mode and the EPEL repository, be aware that you’ll
    need to set the machine back to `DEFAULT` mode before you can either fully update
    your system or install packages from EPEL. (Of course, this problem could be fixed
    by the time you read this.)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: To show you how this works, let's get our hands dirty with another lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – setting encryption policies on AlmaLinux 9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start with a fresh AlmaLinux 9 VM and the scanner VM that you''ve been using.
    Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a AlmaLinux 9 VM, use the `update-crypto-policies` utility to verify that
    it''s running in `DEFAULT` mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Scan the AlmaLinux 9 VM in its `DEFAULT` configuration and save the output
    to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'On the AlmaLinux 9 VM, set the system-wide crypto policy to `FUTURE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `/etc/ssh/` directory, remove the current host machine keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: (Don’t worry. New keys will get created when you reboot the machine.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reboot the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: On the scanner VM, open the `~/.ssh/known_hosts` file in your text editor. Delete
    the entry that was previously made for the AlmaLinux VM and save the file. (We
    have to do this because the public key fingerprint on the AlmaLinux VM will have
    changed because of the new policy.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scan the AlmaLinux VM again, saving the output to a different file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Compare the two output files. You should now see fewer enabled algorithms than
    you did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the files in the `/etc/crypto-policies/back-ends/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You'll now see that the symbolic links point to files in the `FUTURE` directories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the host keys in the `/etc/ssh/` directory, and see if they differ
    from what you had before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Scan the AlmaLinux 9 VM that you set up in `FIPS` mode for the lab in *Chapter
    6*, *Encryption Technologies*. Compare the results with the `DEFAULT` and `FUTURE`
    mode scans.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If `FUTURE` mode hasn’t disabled enough algorithms for you, you can always
    just create your own custom policy. See the details here:'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening#customizing-system-wide-cryptographic-policies-with-subpolicies_using-the-system-wide-cryptographic-policies](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening#customizing-system-wide-cryptographic-policies-with-subpolicies_using-the-system-wide-cryptographic-policies)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You now know how to configure SSH to use only the most modern, most secure algorithms.
    Next, let's look at logging.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring more detailed logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In its default configuration, SSH already creates log entries whenever someone
    logs in via SSH, SCP, or SFTP. On Debian/Ubuntu systems, the entry is made in
    the `/var/log/auth.log` file. On Red Hat/CentOS/AlmaLinux systems, the entry is
    made in the `/var/log/secure` file. Either way, the log entry looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `sshd_config` man page and scroll down to the `LogLevel` item. There,
    you''ll see the various settings that provide different levels of detail for logging
    SSH messages. The levels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QUIET**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FATAL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ERROR**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INFO**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VERBOSE**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEBUG** or **DEBUG1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEBUG2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DEBUG3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, the only two of these we would care about are `INFO` and `VERBOSE`.
    `INFO` is the default setting, while `VERBOSE` is the only other one that we would
    use under normal circumstances. The various `DEBUG` levels might come in handy
    for troubleshooting, but the man page warns us that using `DEBUG` in production
    settings would violate users' privacy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and get our hands dirty, just to get a feel for what gets logged
    with the various levels.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – configuring more verbose SSH logging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this lab, use the same VM that you''ve been using for the previous labs.
    That way, you''ll get a better picture of what a complete `sshd_config` file should
    look like when it''s fully locked down. Remotely log into the target VM via SSH
    and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the main log file and scroll down to where you see the entry that was
    made due to your login and observe what it says. For Ubuntu, do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS or AlmaLinux, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned previously, you never want to run a production machine with
    the SSH log level set to any of the `DEBUG` levels. But, just so you can see what
    it does log, set your machine to `DEBUG` now. Open the `/etc/ssh/sshd_config`
    file in your favorite text editor. Find the line that says the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, reload SSH. On Ubuntu, do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS or AlmaLinux, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Log out of the SSH session, and then log back in. View the system log file to
    see the new entries from this new login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `/etc/ssh/sshd_config` file for editing. Change the `LogLevel DEBUG3`
    line to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: After saving the file, reload or restart the SSH daemon. Log out of the SSH
    session, log back in, and look at the entries in the system log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The main benefit of `VERBOSE` mode is that it will log the fingerprints of any
    key that was used to log in. This can be a big help with key management.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: So, you've just seen how to get more information about SSH logins in your system
    logs. Next, let's talk a bit about access control.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring access control with whitelists and TCP Wrappers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve already locked things down pretty well just by requiring that clients
    authenticate via key exchange, rather than by username and password. When we prohibit
    password authentication, the bad guys can do brute-force password attacks against
    us until the cows come home, and it won''t do them any good. (Although, in truth,
    they''ll just give up as soon as they find that password authentication has been
    disabled.) For an extra measure of security, we can also set up a couple of access
    control mechanisms that will allow only certain users, groups, or client machines
    to log in to an SSH server. These two mechanisms are:'
  prefs: []
  type: TYPE_NORMAL
- en: Whitelists within the `sshd_config` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP Wrappers, via the `/etc/hosts.allow` and `/etc/hosts.deny` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, you're now saying, *But what about firewalls? Isn't that a third mechanism
    that we can use?* And yeah, you're right. But, we already covered firewalls in
    *Chapter 4*, *Securing Your Server with a Firewall - Part 1*, and *Chapter 5*,
    *Securing Your Server with a Firewall - Part 2*, so I won't repeat any of that
    here. You can also place access control directives in your systemd unit files
    for SSH. For our present discussion though, I’d rather avoid the complexities
    of explaining how to edit a systemd unit file. At any rate, these are the ways
    of controlling access to your SSH server. You can use all of them together if
    you really want to, or you can just use one of them at a time. (It really depends
    on just how paranoid you really are.)
  prefs: []
  type: TYPE_NORMAL
- en: There are two competing philosophies about how to do access control. With blacklists,
    you specifically prohibit access by certain people or machines. That's difficult
    to do because the list could get very long, and you still won't block everybody
    that you need to block. The preferred and easier method is to use whitelists,
    which specifically allow access by certain people or machines.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, let's look at creating whitelists within `sshd_config` with a hands-on
    lab.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring whitelists within sshd_config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The four access control directives that you can set within `sshd_config` are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DenyUsers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllowUsers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DenyGroups**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AllowGroups**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each directive, you can specify more than one username or group name, separating
    them with a blank space. Also, these four directives are processed in the order
    that I've listed them here. In other words, if a user is listed with both the
    `DenyUsers` and the `AllowUsers` directives, `DenyUsers` takes precedence. If
    a user is listed with `DenyUsers` and is a member of a group that's listed with
    `AllowGroups`, `DenyUsers` again takes precedence. To demonstrate this, let's
    do a lab.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – configuring whitelists within sshd_config
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This lab will work on any of your VMs. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the VM that you wish to configure, create user accounts for Frank, Charlie,
    and Maggie. On Ubuntu, do it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS or AlmaLinux, do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `webadmins` group and add Frank to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: From either your host machine or from another VM, have the three users log in.
    Then, log them back out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `/etc/ssh/sshd_config` file in your favorite text editor. At the bottom
    of the file, add an `AllowUsers` line with your own username, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart or reload the SSH service and verify that it has started correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat *step 3*. This time, these three kitties shouldn''t be able to log in.
    Open the `/etc/ssh/sshd_config` file in your text editor. This time, add an `AllowGroups`
    line to the bottom of the file for the `webadmins` group, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Restart the SSH service and verify that it started properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From either your host machine or another VM, have Frank try to log in. You'll
    see that even though he's a member of the `webadmins` group, he'll still be denied.
    That's because the `AllowUsers` line with your own username takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Open `sshd_config` in your text editor and remove the `AllowUsers` line that
    you inserted in *step 4*. Restart the SSH service and verify that it started properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to log into your own account, and then try to log into the accounts of all
    the other users. You should now see that Frank is the only one who is allowed
    to log in. The only way that any of the other users can now log into the VM is
    from the VM's local console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into your own account at the VM's local console. Delete the `AllowGroups`
    line from `sshd_config` and restart the SSH service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: You've just seen how to configure a whitelist on the daemon level, using the
    SSH daemon's own configuration file. Next, we'll look at configuring whitelists
    at the network level.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring whitelists with TCP Wrappers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's a strange name, but a simple concept. TCP Wrappers – singular, not plural
    – listens to incoming network connections and either allows or denies connection
    requests. Whitelists and blacklists are configured in the `/etc/hosts.allow` file
    and the `/etc/hosts.deny` file. Both of these files work together. If you create
    a whitelist in `hosts.allow` without adding anything to `hosts.deny`, nothing
    will be blocked. That's because TCP Wrappers consults `hosts.allow` first, and
    if it finds a whitelisted item there, it will just skip over looking in `hosts.deny`.
    If a connection request comes in for something that isn't whitelisted, TCP Wrappers
    will consult `hosts.allow`, find that there's nothing there for the source of
    this connection request, and then will consult `hosts.deny`. If nothing is in
    `hosts.deny`, the connection request will still go through. So, after you configure
    `hosts.allow`, you have to also configure `hosts.deny` in order to block anything.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to note that the Red Hat folk have stripped TCP Wrappers from RHEL
    8/9 and their offspring. So, if you decide to practice with the techniques that
    I present here, you can do so with either your Ubuntu or CentOS 7 VMs, but not
    on your AlmaLinux 8/9 VMs. (The Red Hat folk now recommend doing access control
    via firewalld, rather than TCP Wrappers.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can read about it here: [https://access.redhat.com/solutions/3906701](https://access.redhat.com/solutions/3906701).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (You'll need a Red Hat account to read the whole article. If you don't need
    to pay for Red Hat support, you can open a free-of-charge developers' account.)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, here's something that's extremely important. Always, *always*, configure
    `hosts.allow` before you configure `hosts.deny`. That's because as soon as you
    save either one of these files, the new configuration immediately takes effect.
    So, if you configure the blocking rule in `hosts.deny` while logged in remotely,
    your SSH connection will break just as soon as you save the file. The only way
    to get back in will be to enter the server room and reconfigure things from the
    local console. Your best bet is to get used to the idea of always configuring
    `hosts.allow` first, even when you're working from the local console. That way,
    you'll always be sure. (Amazingly, though, there are other TCP Wrappers tutorials
    out there that tell you to configure `hosts.deny` first. What *are* these guys
    thinking?)
  prefs: []
  type: TYPE_NORMAL
- en: You can do some rather fancy tricks with TCP Wrappers, but for now, I just want
    to keep things simple. So, let's look at some of the most-used configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To whitelist a single IP address, place a line like this into the `/etc/hosts.allow`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, place this line into the `/etc/hosts.deny` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you try to log in from anywhere else besides the IP address that's listed
    in `hosts.allow`, you will be denied access.
  prefs: []
  type: TYPE_NORMAL
- en: You can also list either multiple IP addresses or network addresses in `hosts.allow`.
    For details on how to do this, see the `hosts.allow` man page.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, you can do some fancy things with TCP Wrappers. But,
    now that the Red Hat folk have deprecated it, you should probably get used to
    the idea of either setting up firewall rules or configuring the `sshd_config`
    file. On the other hand, TCP Wrappers could come in handy whenever you need to
    configure an access control rule very quickly, provided that you’re on a machine
    that supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring automatic logouts and security banners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Best security practice dictates that people log out of their computers before
    they walk away from their desks. This is especially important when an administrator
    uses his or her cubicle computer to remotely log into a sensitive server. By default,
    SSH allows a person to remain logged in forever without complaining. However,
    you can set it up to automatically log out idle users. We'll look at two quick
    methods for doing that.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring automatic logout for both local and remote users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This first method will automatically log out idle users who are logged on either
    at the local console or remotely via SSH. Go into the `/etc/profile.d/` directory
    and create the `autologout.sh` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This sets a timeout value of 100 seconds. (`TMOUT` is a Linux environmental
    variable that sets timeout values.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the executable permission for everybody:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Log out and then log back in. Then, let the VM sit idle. After 100 seconds,
    you should see that the VM is back at the login prompt. Note, though, that if
    any users are already logged in at the time you create this file, the new configuration
    won't take effect for them until they log out and then log back in.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring automatic logout in sshd_config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second method only logs out users who are logged in remotely via SSH. Instead
    of creating the `/etc/profile.d/autologout.sh` file, look for these two lines
    in the `/etc/ssh/sshd_config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Change them to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Then, restart or reload the SSH service to make the change take effect.
  prefs: []
  type: TYPE_NORMAL
- en: I've been using 100 seconds for the timeout value in both of these examples.
    However, you can set the timeout value to suit your own needs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You now know how to automatically log out your users. Now, let's look at setting
    up security banners.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pre-login security banner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Securing Normal User Accounts*, I showed you how to create
    a security message that shows up *after* a user has logged in. You do this by
    inserting a message into the `/etc/motd` file. But, when you think about it, wouldn't
    it be better for people to see a security banner *before* they log in? You can
    do that with `sshd_config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the `/etc/ssh/sshd-banner` file, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `/etc/ssh/sshd_config` file, look for this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, restart or reload the SSH service. Now, whoever logs in remotely
    will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: So, will this banner keep your system safe and secure from the bad guys? No,
    but it could be useful if you ever have to take a case to court. Sometimes, it's
    important to show a judge and jury that the intruders knew that they were going
    where they don't belong.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to set up security banners and automatic logouts, let's
    look at a few miscellaneous settings that don't fit neatly into any one category.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring other miscellaneous security settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our SSH configuration is a lot more secure than it used to be, but we can still
    make it better. Here are a few little tricks that you might not have seen elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling X11 forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you SSH into a server in the normal manner, as we''ve been doing, you
    can only run text-mode programs. If you try to remotely run any GUI-based program,
    such as Firefox, you''ll get an error message. But, when you open the `sshd_config`
    file of pretty much any Linux distribution, you''ll see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that with the right option switch, you can remotely run GUI-based
    programs. Assuming that you''re logging into a machine that has a graphical desktop
    environment installed, you can use either the `-Y` or the `-X` option when logging
    in, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that the X11 protocol, which powers graphical desktop environments
    on most Linux and Unix systems, has a few security weaknesses that make it somewhat
    dangerous to use remotely. The bad guys have ways of using it to compromise an
    entire system. Your best bet is to disable it by changing the `X11Forwarding`
    line to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: As usual, restart or reload the SSH service to make it read in the new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about X11 forwarding, let's dig some tunnels.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling SSH tunneling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SSH tunneling, or as it''s sometimes called, SSH port forwarding, is a handy
    way to protect non-secure protocols. For example, by tunneling normal HTTP through
    an SSH tunnel, you can access a non-secure website in a secure fashion. Here’s
    what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: I had to use `sudo` here because all network ports below port `1024` are **privileged
    ports**. If I were to change the web server configuration to listen on a non-privileged
    high-number port, I wouldn't need `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to connect to this site in a secure manner, I can just open the web browser
    on my local machine and type in the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost`'
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, it seems strange to access a remote machine by typing in `localhost`,
    but that's the designator I used when I logged in with SSH. I could have used
    another name, but `localhost` is the name you traditionally see in SSH tutorials,
    so I'm following suit here. Now, as soon as I log out of the SSH session, my connection
    to the web server will break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though this sounds like a good idea, it actually creates a security problem.
    Let''s say that your corporate firewalls are set up to prevent people from going
    home and remotely logging into their company workstations. That''s a good thing,
    right? Now, let''s say that the company firewall has to allow outbound SSH connections.
    A user could create an SSH tunnel from his or her company workstation to a computer
    at another location, then go to that location and create a reverse tunnel back
    to the company workstation. So, if it isn''t possible to block outgoing SSH traffic
    at the firewall, then your best bet is to disable SSH tunneling. In your `sshd_config`
    file, ensure that you have lines that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Restart or reload the SSH service, as always. Now, port tunneling will be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to disable SSH tunneling, let's talk about changing the
    default port.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default SSH port
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, SSH listens on port `22/TCP`. If you've been around for a while,
    you've surely seen plenty of documentation about how important it is to use some
    other port in order to make it harder for the bad guys to find your SSH server.
    But, I must say, this notion is a bit controversial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first place, if you enable key authentication and disable password authentication,
    then changing the port has limited value. When a scanner bot finds your server
    and sees that password authentication is disabled, it will just go away and won''t
    bother you anymore. In the second place, if you were to change the port, the bad
    guys'' scanning tools can still find it. If you don''t believe me, just go to
    Shodan.io and search for `ssh`. In this example, someone thought they were smart
    by changing to port `2211`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file50.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Yeah, smarty-pants. That didn''t hide things so well, now, did it?*'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, security expert Daniel Miessler says that it's still useful
    to change the port, in case someone tries to leverage a zero-day exploit against
    SSH. He recently published the results of an informal experiment that he did,
    in which he set up a public server that listens for SSH connections to both port
    `22` and port `24`, and observed the number of connection attempts to each port.
    He said that over a single weekend, there were 18,000 connections to port `22`
    and only five to port `24`. But, although he doesn't explicitly say, it appears
    that he left password authentication enabled. To have truly scientifically accurate
    results, he needs to conduct the same study with password authentication disabled.
    He also needs to conduct the study on separate servers that have SSH enabled for
    either port `22` or port `24`, instead of having both ports enabled on a single
    machine. My hunch is that when the scanner bots found that port `22` was open,
    they didn't bother to scan for any other open SSH ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read about his experiment here: [https://danielmiessler.com/study/security-by-obscurity/](https://danielmiessler.com/study/security-by-obscurity/).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Anyway, if you do want to change ports, just uncomment the `#Port 22` line in
    `sshd_config`, and change the port number to whatever you want.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's talk about key management.
  prefs: []
  type: TYPE_NORMAL
- en: Managing SSH keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, I showed you how to create a pair of keys on your local workstation,
    and then transfer the public key to a remote server. This allows you to disable
    username/password authentication on the server, making it much harder for the
    bad guys to break in. The only problem with this that we didn't address is that
    the public key goes into an `authorized_keys` file that's in the user's own home
    directory. So, the user can manually add extra keys to the file, which would allow
    the user to log in from other locations besides the one that's been authorized.
    And, there's also the problem of having `authorized_keys` files all over the place,
    in every user's home directory. That makes it a bit hard to keep track of everyone's
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to handle this is to move everyone''s `authorized_keys` file to one
    central location. Let''s take Vicky, my 15-year old solid gray kitty. The administrator
    created an account on the server that she needs to access and allowed her to create
    and transfer her key to it before disabling password authentication. So, Vicky
    now has her `authorized_keys` file in her home directory on that server, as we
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Vicky owns the file, and she has both read and write permissions on it. So,
    even though she can''t transfer other keys to it the normal way once the administrator
    has disabled password authentication, she can still transfer key files manually,
    and manually edit the `authorized_keys` file to include them. To thwart her efforts,
    our intrepid administrator will create a directory within the `/etc/ssh/` directory
    to hold everyone''s `authorized_keys` files, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Our intrepid administrator''s full admin privileges allow him to log into the
    root user''s shell, which allows him to go into the directories of all other users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to move Vicky''s `authorized_keys` file to the new location,
    changing its name to `vicky`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a bit of a conundrum. As you see here, the file still belongs
    to Vicky, and she has both read and write privileges. So, she can still edit the
    file without any administrator privileges. Removing the write privilege won''t
    work, because since the file belongs to her, she could just add the write privilege
    back. Changing ownership to the root user is part of the answer, but that will
    prevent Vicky from being able to read the file, which will prevent her from logging
    in. To see the whole solution, let''s see what I''ve already done with my own
    `authorized_keys` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The eagle-eyed among you have surely noticed what''s going on with the `donnie`
    file. You have seen that I changed ownership to the root user and then added an
    access control list, as indicated by the `+` sign. Let''s do the same for Vicky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the permissions settings, we see that Vicky has read access to the
    `vicky` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, let''s look at her access control list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Vicky can now read the file so that she can log in, but she can't change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to reconfigure the `sshd_config` file, and then restart or
    reload the SSH service. Open the file in your text editor and look for this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The `%u` at the end of the line is a mini-macro that tells the SSH service to
    look for a keys file that has the same name as the user who's logging in. Now,
    even if the users were to manually create their own `authorized_keys` files in
    their own home directories, the SSH service would just ignore them. Another benefit
    is that having the keys all in one place makes it a bit easier for an administrator
    to revoke someone's access, should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that there's a lot more to managing SSH keys than what I've been able
    to present here. One problem is that while there are a few different free open
    source software solutions for managing public keys, there aren't any for managing
    private keys. A large corporation could have thousands or perhaps even millions
    of private and public keys in different places. Those keys never expire, so they'll
    be around forever unless they get deleted. If the wrong people get hold of a private
    key, your whole system could become compromised. As much as I hate to say it,
    your best bet for managing SSH keys is to go with a commercial solution, such
    as ones from SSH.com and CyberArk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the key management solutions from SSH.com here: [https://www.ssh.com/academy/iam/ssh-key-management](https://www.ssh.com/academy/iam/ssh-key-management).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Head here for CyberArk''s key management solutions: [https://www.cyberark.com/resources/blog/ssh-keys-the-powerful-unprotected-privileged-credentials](https://www.cyberark.com/resources/blog/ssh-keys-the-powerful-unprotected-privileged-credentials).'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Full disclosure: I have no connection with either SSH.com or CyberArk, and
    receive no payment for telling you about them.'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: You've learned several cool tricks here for beefing up your server security.
    Now, let's look at how to create different configurations for different users
    and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Setting different configurations for different users and groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the server side, you can use the `Match User` or `Match Group` directive
    to set up custom configurations for certain users or groups. To see how it''s
    done, look at the example at the very bottom of the `/etc/ssh/sshd_config` file.
    There, you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this has no effect since it''s commented out, but that''s okay.
    Here''s what we see for user `anoncvs`:'
  prefs: []
  type: TYPE_NORMAL
- en: He can't do **X11 Forwarding**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He can't do **TCP Forwarding**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He won't have the use of a command terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As soon as he logs in, he'll be starting the **Concurrent Versioning Service**
    (**CVS**) server. By not having use of the terminal, `anoncvs` can start the CVS
    server, but can't do anything else.
  prefs: []
  type: TYPE_NORMAL
- en: You can set up different configurations for as many users as you need to. Anything
    that you put in the custom configurations will override the global settings. To
    set up a custom configuration for a group, just replace `Match User` with `Match
    Group`, and supply a group name instead of a user name.
  prefs: []
  type: TYPE_NORMAL
- en: Creating different configurations for different hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a change of pace, let''s look at the client''s end now. This time, we''ll
    look at a handy trick to help ease the pain of logging into different servers
    that require different keys or SSH options. All you have to do is go into the
    `.ssh` directory in your own home directory and create a `config` file. To demonstrate
    this, let''s say that we''ve created either a DNS record or an `/etc/hosts` file
    entry for our servers so that we don''t have to remember so many IP addresses.
    Let''s also say that we''ve created a separate pair of keys for each server that
    we need to access. In the `~/.ssh/config` file, we can add a stanza that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IdentityFile**: This specifies the key that goes with this server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IdentitiesOnly yes**: If you happen to have more than one key loaded into
    your session keyring, this forces your client to only use the key that''s specified
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ForwardX11 yes**: We want this client to use *X11* forwarding. (Of course,
    this will only be effective if the server has been configured to allow it.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cipher aes256-gcm@openssh.com**: We want to use this algorithm, and *only*
    this algorithm, to perform our encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create custom configurations for other hosts, just add a stanza for each
    one to this file.
  prefs: []
  type: TYPE_NORMAL
- en: After you save the file, you have to change its permissions settings to a value
    of `600`. If you don't, you'll get an error when you try to log into any of the
    servers that are configured in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about custom configurations, let's talk about SFTP, where
    we'll make good use of the `Match Group` directive that we just looked at.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a chroot environment for SFTP users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Secure File Transfer Protocol** (**SFTP**) is a great tool for performing
    secure file transfers. There is a command-line client, but users will most likely
    use a graphical client, such as FileZilla. With a default SSH setup, anyone who
    has a user account on a Linux machine can log in through either SSH or SFTP and
    can navigate through the server''s entire filesystem. What we really want for
    SFTP users is to prevent them from logging into a command prompt via SSH, and
    to confine them to their own designated directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One good use for this trick would be to set up SFTP configurations for web site
    creators. Instead of allowing these users to transfer files to and from only their
    own home directories, just allow them to transfer files to and from the web site
    content directories.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Creating a group and configuring the sshd_config file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the exception of the slight difference in user-creation commands, this
    procedure works the same on any of your VMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by creating an `sftpusers` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the user accounts and add them to the `sftpusers` group. We''ll do both
    operations in one step. On your CentOS or AlmaLinux machine, the commands for
    creating Max''s account would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'On your Ubuntu machine, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/ssh/sshd_config` file in your favorite text editor. Find the
    line that says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This setting allows you to disable normal SSH login for certain users.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the `sshd_config` file, add a `Match Group` stanza:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: An important consideration here is that the `ChrootDirectory` has to be owned
    by the root user, and it can't be writable by anyone other than the root user.
    When Max logs in, he'll be in the `/home/` directory, and will then have to `cd`
    into his own directory. This also means that you want all your users' home directories
    to have the restrictive `700` permissions settings, in order to keep everyone
    out of everyone else's stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and restart the SSH daemon. Then, try to log on as Max through
    normal SSH, just to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so he can''t do that. Now, let''s have Max try to log in through SFTP
    and verify that he is in the `/home/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see him try to `cd` out of the `/home/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: So, our chroot jail does indeed work.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – setting up a chroot directory for the sftpusers group
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this lab, you can use either the CentOS VM or the Ubuntu VM. You''ll add
    a group, then configure the `sshd_config` file to allow group members to only
    be able to log in via SFTP, and then confine them to their own directories. For
    the simulated client machine, you can use the terminal of your macOS or Linux
    desktop machine, or any of the available Bash shells from your Windows machine.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `sftpusers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a user account for Max and add him to the `sftpusers` group. On CentOS
    or AlmaLinux, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, ensure that the users'' home directories are all set with read,
    write, and execute permissions for only the directory''s user. If that''s not
    the case, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/ssh/sshd_config` file in your preferred text editor. Find the
    line that says the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `sshd_config` file, add this stanza:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the SSH configuration. On CentOS or AlmaLinux, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Have Max try to log in through normal SSH, to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, have Max log in through SFTP. Once he''s in, have him try to `cd` out
    of the `/home/` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to securely configure SFTP, let's look at how to securely
    share a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a directory with SSHFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to share a directory across a network. In enterprise
    settings, you'll find the **Network Filesystem** (**NFS**), **Samba**, and various
    distributed filesystems. **SSHFS** isn't used in enterprises quite as much, but
    it can still come in handy. The beauty of it is that all of its network traffic
    is encrypted by default, unlike with NFS or Samba. And, other than installing
    the SSHFS client program and creating a local mount-point directory, it doesn't
    require any configuration beyond what you've already done. It's especially handy
    for accessing a directory on a cloud-based **Virtual Private Server** (**VPS**)
    because it allows you to just create files in the shared directory rather than
    using `scp` or `sftp` commands to transfer the files. So, if you're ready, let's
    jump in.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – sharing a directory with SSHFS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this lab, we''ll use two VMs. For the server, you can use any of your virtual
    machines. The same is true of the client, except that each distro has the the
    SSHFS client in a different repository. Here’s what I’m talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is in the normal Ubuntu repositories, so you don’t have to do anything
    special to get it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For CentOS 7 and AlmaLinux 9, you’ll need to install the `epel-release` package
    with the normal `yum install` or `dnf install` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AlmaLinux 8 has the SSHFS client in its own PowerTools repository, which isn’t
    enabled by default. To enable it, open the `/etc/yum.repos.d/almalinux-powertools.repo`
    file in your favorite text editor. In the `[powertools]` section, find the line
    that says `enabled=0`, and change it to `enabled=1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have all that straight, let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Boot up one VM for a server. (That's all you need to do for the server end.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the other VM that you''ll use as a client, create a mount-point directory
    within your own home directory, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client VM, install the SSHFS client. On Ubuntu, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'On CentOS 7, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'On AlmaLinux 8 or 9, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'From the client machine, mount your own home directory that''s on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you don't specify a directory to share, the default is to share
    the home directory of the user account that's being used for logging in.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Verify that the directory was mounted properly with the `mount` command. You
    should see your new shared mount at the bottom of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '`cd` into the `remote` directory and create some files. Verify that they actually
    do show up on the server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the local console of the server VM, create some files in your own home directory.
    Verify that they show up in the `remote/` directory of your client VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've reached the end of the lab – congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: 'With this lab, I just showed you how to mount your own home directory from
    a remote server. You can also mount other server directories by specifying them
    in the `sshfs` command. For example, let''s say that I want to mount the `/maggie_files/`
    directory, with the `~/remote3/` directory as my local mount-point. (I chose that
    name because Maggie cat is sitting here in front of me where my keyboard should
    be.) Just do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: You can also make the remote directory automatically mount every time you boot
    your client machine by adding an entry to the `/etc/fstab` file. But, that's generally
    not a good idea. If the server isn't available when you boot the client machine,
    it could cause the boot process to hang up.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so you've seen how to use SSHFS to create an encrypted connection with
    a shared remote directory. Let's now log into the server from a Windows desktop
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Remotely connecting from Windows desktops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I know, all of us Penguinistas would like to use Linux, and nothing but Linux.
    But, in an enterprise environment, things just don't always work that way. There,
    you'll most likely have to administer your Linux servers from a Windows 10/11
    desktop machine that's sitting on your cubicle desk. In *Chapter 1*, *Running
    Linux in a Virtual Environment*, I showed you how to use either Cygwin or the
    new Windows 10/11 shell to remotely connect to your Linux VMs. You can also use
    these techniques to connect to actual Linux servers.
  prefs: []
  type: TYPE_NORMAL
- en: But, some shops require that admins use a terminal program, rather than a full-blown
    Bash Shell such as Cygwin. Normally, these shops will require that you use **PuTTY**
    on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'PuTTY is a free program that you can download from here: [https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Installation is simple. Just double-click the installer file and follow through
    the installer screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can open the PuTTY user manual from your Windows 10/11 Start menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connecting to a remote Linux machine is easy. Just enter the machine''s IP
    address and click on **Open**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that this also gives you the option to save your sessions. So, if you
    have to administer multiple servers, you can open PuTTY and just click on the
    name of the server that you want to connect to, and then click on **Open**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file54.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is a lot handier than having to manually type in the `ssh`
    command every time you need to log into a server, and it prevents you from having
    to remember a whole list of IP addresses for multiple servers. (But of course,
    you can accomplish the same thing with either Cygwin or a Windows 10 shell by
    creating a login shell script for each Linux machine that you need to administer.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Either way, you''ll end up at the remote machine''s Bash Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To set up key-exchange authentication, use PuTTYgen to create the key pair.
    The only slight catch is that you''ll have to transfer the public key to the server
    by manually copying and pasting the key into the server''s `authorized_keys` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file56.png)'
  prefs: []
  type: TYPE_IMG
- en: I've given you the basics about PuTTY. You can read the PuTTY manual to get
    the nitty-gritty details.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I think that that about wraps things up for our discussion of the Secure
    Shell suite.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we've seen that a default configuration of Secure Shell isn't
    as secure as we'd like it to be, and we've seen what to do about it. We've looked
    at how to set up key-based authentication and two-factor authentication, and we've
    looked at lots of different options that can lock down the SSH server. We also
    looked at how to disable weak encryption algorithms, and at how the new system-wide
    crypto policies on RHEL 8/CentOS 8 and RHEL 9/AlmaLinux 9 make doing that really
    easy. Along the way, we looked at setting up access controls, and at creating
    different configurations for different users, groups, and hosts. After demoing
    how to confine SFTP users to their own home directories, we used SSHFS to share
    a remote directory. We wrapped up this chapter by presenting a handy way to log
    into our Linux servers from a Windows desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: Conspicuous by their absence are a couple of technologies that you may have
    seen recommended elsewhere. Port knocking and Fail2Ban are two popular technologies
    that can help control access to an SSH server. However, they're only needed if
    you allow password-based authentication to your SSH server. If you set up key-based
    authentication, as I've shown you here, you won't need the added complexity of
    those other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take an in-depth look at the subject of discretionary
    access control. I'll see you there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which of the following statements is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Secure Shell is completely secure in its default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: B. It's safe to allow the root user to use Secure Shell to log in across the
    Internet.
  prefs: []
  type: TYPE_NORMAL
- en: C. Secure Shell is insecure in its default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: D. The most secure way to use Secure Shell is to log in with a username and
    password.
  prefs: []
  type: TYPE_NORMAL
- en: Which three of the following things would you do to conform with the best security
    practices for Secure Shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Make sure that all users are using strong passwords to log in via Secure
    Shell.
  prefs: []
  type: TYPE_NORMAL
- en: B. Have all users create a public/private key pair, and transfer their public
    keys to the server to which they want to log in.
  prefs: []
  type: TYPE_NORMAL
- en: C. Disable the ability to log in via username/password.
  prefs: []
  type: TYPE_NORMAL
- en: D. Ensure that the root user is using a strong password.
  prefs: []
  type: TYPE_NORMAL
- en: E. Disable the root user's ability to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Which one of the following lines in the `sshd_config` file will cause botnets
    to not scan your system for login vulnerabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `PasswordAuthentication no`
  prefs: []
  type: TYPE_NORMAL
- en: B. `PasswordAuthentication yes`
  prefs: []
  type: TYPE_NORMAL
- en: C. `PermitRootLogin yes`
  prefs: []
  type: TYPE_NORMAL
- en: D. `PermitRootLogin no`
  prefs: []
  type: TYPE_NORMAL
- en: How would you confine a user of SFTP to his or her own specified directory?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Ensure that proper ownership and permissions are set on that user's directory.
  prefs: []
  type: TYPE_NORMAL
- en: B. In the `sshd_config` file, disable that user's ability to log in via normal
    SSH and define a `chroot` directory for that user.
  prefs: []
  type: TYPE_NORMAL
- en: C. Define the user's limitations with TCP Wrappers.
  prefs: []
  type: TYPE_NORMAL
- en: D. Use whole-disk encryption on the server so that SFTP users will only be able
    to access their own directories.
  prefs: []
  type: TYPE_NORMAL
- en: Which two of the following commands would you use to add your private SSH key
    to your session keyring?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `ssh-copy-id`
  prefs: []
  type: TYPE_NORMAL
- en: B. `exec /usr/bin/ssh-agent`
  prefs: []
  type: TYPE_NORMAL
- en: C. `exec /usr/bin/ssh-agent $SHELL`
  prefs: []
  type: TYPE_NORMAL
- en: D. `ssh-agent`
  prefs: []
  type: TYPE_NORMAL
- en: E. `ssh-agent $SHELL`
  prefs: []
  type: TYPE_NORMAL
- en: F. `ssh-add`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is *not* on NIST's list of recommended algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `RSA`
  prefs: []
  type: TYPE_NORMAL
- en: B. `ECDSA`
  prefs: []
  type: TYPE_NORMAL
- en: C. `Ed25519`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is the correct directive for creating a custom configuration
    for Katelyn?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `User Match katelyn`
  prefs: []
  type: TYPE_NORMAL
- en: B. `Match katelyn`
  prefs: []
  type: TYPE_NORMAL
- en: C. `Match Account katelyn`
  prefs: []
  type: TYPE_NORMAL
- en: D. `Match User katelyn`
  prefs: []
  type: TYPE_NORMAL
- en: When creating a `~/.ssh/config` file, what should the permissions value on that
    file be?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `600`
  prefs: []
  type: TYPE_NORMAL
- en: B. `640`
  prefs: []
  type: TYPE_NORMAL
- en: C. `644`
  prefs: []
  type: TYPE_NORMAL
- en: D. `700`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following crypto policies provides the strongest encryption on
    RHEL 8/9-type distros?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `LEGACY`
  prefs: []
  type: TYPE_NORMAL
- en: B. `FIPS`
  prefs: []
  type: TYPE_NORMAL
- en: C. `DEFAULT`
  prefs: []
  type: TYPE_NORMAL
- en: D. `FUTURE`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following standards defines NIST's current recommendations for
    encryption algorithms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. FIPS 140-2
  prefs: []
  type: TYPE_NORMAL
- en: B. FIPS 140-3
  prefs: []
  type: TYPE_NORMAL
- en: C. CNSA
  prefs: []
  type: TYPE_NORMAL
- en: D. Suite B
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How to set up SSH keys on Debian 10 Buster: [https://devconnected.com/how-to-set-up-ssh-keys-on-debian-10-buster/](https://devconnected.com/how-to-set-up-ssh-keys-on-debian-10-buster/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to configure the OpenSSH Server: [https://www.ssh.com/academy/ssh/sshd_config](https://www.ssh.com/academy/ssh/sshd_config)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up passwordless SSH: [https://www.redhat.com/sysadmin/passwordless-ssh](https://www.redhat.com/sysadmin/passwordless-ssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenSSH best practices for Unix, Linux, and BSD: [https://www.cyberciti.biz/tips/linux-unix-bsd-openssh-server-best-practices.html](https://www.cyberciti.biz/tips/linux-unix-bsd-openssh-server-best-practices.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Different SSH configurations for different hosts: [https://www.putorius.net/how-to-save-per-user-per-host-ssh-client-settings.html](https://www.putorius.net/how-to-save-per-user-per-host-ssh-client-settings.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSH Query at Shodan: [https://www.shodan.io/search?query=ssh](https://www.shodan.io/search?query=ssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mozilla OpenSSH Security Guide: [https://infosec.mozilla.org/guidelines/openssh](https://infosec.mozilla.org/guidelines/openssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute commands on a remote system over SSH: [https://www.2daygeek.com/execute-run-linux-commands-remote-system-over-ssh/](https://www.2daygeek.com/execute-run-linux-commands-remote-system-over-ssh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CNSA Suite and Quantum Cryptography: [https://cryptome.org/2016/01/CNSA-Suite-and-Quantum-Computing-FAQ.pdf](https://cryptome.org/2016/01/CNSA-Suite-and-Quantum-Computing-FAQ.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FIPS 140-3: [https://csrc.nist.gov/projects/fips-140-3-transition-effort](https://csrc.nist.gov/projects/fips-140-3-transition-effort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ChaCha20 and Poly1305: [https://tools.ietf.org/html/rfc7539](https://tools.ietf.org/html/rfc7539)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System-wide cryptographic policies on Red Hat Enterprise Linux 8: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening#system-wide-crypto-policies_using-the-system-wide-cryptographic-policies](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening#system-wide-crypto-policies_using-the-system-wide-cryptographic-policies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to log out inactive users in Linux: [https://www.ostechnix.com/auto-logout-inactive-users-period-time-linux/](https://www.ostechnix.com/auto-logout-inactive-users-period-time-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure host-specific SSH settings: [https://www.putorius.net/how-to-save-per-user-per-host-ssh-client-settings.html](https://www.putorius.net/how-to-save-per-user-per-host-ssh-client-settings.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use SSHFS to mount remote directories over SSH: [https://linuxize.com/post/how-to-use-sshfs-to-mount-remote-directories-over-ssh/](https://linuxize.com/post/how-to-use-sshfs-to-mount-remote-directories-over-ssh/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B, C, E
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C, F
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
