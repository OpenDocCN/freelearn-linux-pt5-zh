<html><head></head><body>
		<div id="_idContainer027">
			<h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor117"/>Chapter 8</em>: Writing I2C Device Drivers</h1>
			<p><strong class="bold">I2C</strong> stands for <strong class="bold">Inter-Integrated Circuit</strong>. It is a serial, multi-master, and asynchronous<a id="_idIndexMarker554"/> bus invented by Philips (now NXP), though multi-master mode is not widely<a id="_idIndexMarker555"/> used. I2C is a two-wire bus, respectively named <strong class="bold">Serial Data</strong> (<strong class="bold">SDA</strong>) and <strong class="bold">Serial Clock</strong> (<strong class="bold">SCL</strong>, or <strong class="bold">SCK</strong>). An I2C device is a chip that interacts<a id="_idIndexMarker556"/> with another device via an I2C bus. On this bus, both SDA and SCL are open-drain/open collectors, meaning that each can drive its output low, but neither can drive its output high without having pull-up resistors. SCL is generated by the master to synchronize data (carried by SDA) transfer over the bus. Both the slave and master can send data (not at the same time, of course), thus making SDA a bidirectional line. That said, the SCL signal is also bidirectional since the slave can <em class="italic">stretch</em> the clock by keeping the SCL line low. The bus is controlled<a id="_idIndexMarker557"/> by the master, which in our case is part of the <strong class="bold">System on Chip</strong> (<strong class="bold">SoC</strong>). This bus is frequently used in embedded systems to connect serial EEPROM, RTC chips, GPIO expanders, temperature sensors, and so on.</p>
			<p>The following diagram shows various devices (also known as slaves) connected<a id="_idIndexMarker558"/> to an I2C bus:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B17934_08.jpg" alt="Figure 8.1 – I2C bus and device representation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – I2C bus and device representation</p>
			<p>From the preceding diagram, we can represent the Linux kernel I2C framework as follows:</p>
			<p class="source-code">CPU &lt;--platform bus--&gt;i2c adapter&lt;---i2c bus---&gt; i2c slave</p>
			<p>The CPU is the master hosting the I2C controller, also known<a id="_idIndexMarker559"/> as the I2C adapter, which implements the I2C protocol and manages the bus segment that's hosting the I2C devices. In the kernel I2C framework, the adapter is managed by a platform driver while the slave is driven by an I2C driver. However, both drivers use APIs provided by the I2C core. In this chapter, we will be focusing on I2C (slave) device drivers, though references to the adapter will be mentioned if necessary.</p>
			<p>Back to the hardware, I2C clock speed varies from 10 kHz to 100 kHz, and from 400 kHz to 2 MHz. There are no strict data transfer speed requirements for I2C, and all the slaves sitting on a given bus will use the same clock speed that the bus has been<a id="_idIndexMarker560"/> configured with. This is unlike <strong class="bold">Serial Peripheral Interfaces</strong> (<strong class="bold">SPIs</strong>), where the clock speed is applied on a per-device basis. An example of an I2C controller drive (for example, an i.MX6 chip) can be found at <strong class="source-inline">drivers/i2c/busses/i2c-imx.c</strong> in the kernel source, and the I2C specifications can be found at <a href="https://www.nxp.com/docs/en/user-guide/UM10204.pdf">https://www.nxp.com/docs/en/user-guide/UM10204.pdf</a>.</p>
			<p>Now that we know that we will be dealing with an I2C device driver, in this chapter, we will cover the following topics:</p>
			<ul>
				<li>I2c framework abstraction in the Linux kernel</li>
				<li>The I2C driver abstraction and architecture</li>
				<li>How not to write I2C device drivers </li>
			</ul>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor118"/>I2C framework abstractions in the Linux kernel</h1>
			<p>The Linux kernel I2C framework<a id="_idIndexMarker561"/> is made up of a few data structures, with the most important being as follows:</p>
			<ul>
				<li><strong class="source-inline">i2c_adapter</strong>: Used to abstract the I2C master device. It is used to identify a physical I2C bus.</li>
				<li><strong class="source-inline">i2c_algorithm</strong>: This abstracts the I2C bus transaction interface. Here, transaction means to transfer, such as read or write operations.</li>
				<li><strong class="source-inline">i2c_client</strong>: Used to abstract a slave device sitting on the I2C bus.</li>
				<li><strong class="source-inline">i2c_driver</strong>: The driver of the slave device. It contains a set of specific driving functions to deal with the device.</li>
				<li><strong class="source-inline">i2c_msg</strong>: This is the low-level representation of one segment of an I2C transaction. This data structure defines the device address, the transaction flags (if it's a transmit or receive, for example), a pointer to the data to send/receive, and the size of the data.</li>
			</ul>
			<p>Since the scope of this chapter is limited<a id="_idIndexMarker562"/> to slave device drivers, we will focus on the last three data structures. However, to help you understand this, we need to introduce both the adapter and algorithm data structures. </p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor119"/>A brief introduction to struct i2c_adapter</h2>
			<p>The kernel uses <strong class="source-inline">struct i2c_adapter</strong> to represent<a id="_idIndexMarker563"/> a physical I2C bus, along with the algorithms that are necessary to access it. It is defined as follows:</p>
			<p class="source-code">struct i2c_adapter {</p>
			<p class="source-code">    struct module *owner;</p>
			<p class="source-code">    const struct i2c_algorithm *algo;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, we have the following:</p>
			<ul>
				<li><strong class="source-inline">owner</strong>: Most of the time, this is set with <strong class="source-inline">THIS_MODULE</strong>. This is the owner, and it's used for reference counting.</li>
				<li><strong class="source-inline">algo</strong>: This is a set of callbacks that are used by the controller (the master) driver to drive the I2C line. These callbacks allow you to generate the signal that's needed for the I2C access cycle.</li>
			</ul>
			<p>The algorithm's data structure has the following definition:</p>
			<p class="source-code">struct i2c_algorithm {</p>
			<p class="source-code">    int (*master_xfer)(struct i2c_adapter *adap,</p>
			<p class="source-code">                       struct i2c_msg *msgs, int num);</p>
			<p class="source-code">    int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,</p>
			<p class="source-code">              unsigned short flags, char read_write,</p>
			<p class="source-code">              u8 command, int size, </p>
			<p class="source-code">              union i2c_smbus_data *data);</p>
			<p class="source-code">    /* To determine what the adapter supports */</p>
			<p class="source-code">    u32 (*functionality)(struct i2c_adapter *adap);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, the unimportant fields<a id="_idIndexMarker564"/> have been omitted. Let's look at each element in the excerpt:</p>
			<ul>
				<li><strong class="source-inline">master_xfer</strong>: This is the core transfer function. It must be provided for this algorithm driver to have plain I2C access. It is invoked when an I2C device driver needs to communicate with the underlying I2C device. However, if it is not implemented (if <strong class="source-inline">NULL</strong>), the <strong class="source-inline">smbus_xfer</strong> function is called instead.</li>
				<li><strong class="source-inline">smbus_xfer</strong>: This is a function pointer that is set by the I2C controller driver if its algorithm driver can perform SMBus accesses. It is used whenever an I2C chip driver wants to communicate with the chip device using the SMBus protocol. If it is <strong class="source-inline">NULL</strong>, the  <strong class="source-inline">master_xfer</strong> function is used instead and the SMBus is emulated.</li>
				<li><strong class="source-inline">functionality</strong>: This is a function pointer that's called by the I2C core to determine the capabilities of the adapter. It informs you about what kind of reads and writes the I2C adapter driver can do.</li>
			</ul>
			<p>In the preceding code, <strong class="source-inline">functionality</strong> is a sanity callback. Either the core or device drivers can invoke it (through <strong class="source-inline">i2c_check_functionality()</strong>) to check whether the given adapter can provide the I2C access we need before we initiate this access. For example, 10-bit addressing mode is not supported by all adapters. Thus, it is safe to call <strong class="source-inline">i2c_check_functionality(client-&gt;adapter, I2C_FUNC_10BIT_ADDR)</strong> in the chip driver to check whether it is supported by the adapter. All the flags<a id="_idIndexMarker565"/> are in the form of <strong class="source-inline">I2C_FUNC_XXX</strong>. Though each can be checked individually, the I2C core has split them into logical functions, as follows:</p>
			<p class="source-code">#define I2C_FUNC_I2C              0x00000001</p>
			<p class="source-code">#define I2C_FUNC_10BIT_ADDR       0x00000002</p>
			<p class="source-code">#define I2C_FUNC_SMBUS_BYTE   (I2C_FUNC_SMBUS_READ_BYTE | \</p>
			<p class="source-code">                         I2C_FUNC_SMBUS_WRITE_BYTE)</p>
			<p class="source-code">#define I2C_FUNC_SMBUS_BYTE_DATA \</p>
			<p class="source-code">                      (I2C_FUNC_SMBUS_READ_BYTE_DATA | \</p>
			<p class="source-code">                       I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</p>
			<p class="source-code">#define I2C_FUNC_SMBUS_WORD_DATA \</p>
			<p class="source-code">                     (I2C_FUNC_SMBUS_READ_WORD_DATA | \</p>
			<p class="source-code">                      I2C_FUNC_SMBUS_WRITE_WORD_DATA)</p>
			<p class="source-code">#define I2C_FUNC_SMBUS_BLOCK_DATA \</p>
			<p class="source-code">                     (I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</p>
			<p class="source-code">                      I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</p>
			<p class="source-code">#define I2C_FUNC_SMBUS_I2C_BLOCK \</p>
			<p class="source-code">                     (I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</p>
			<p class="source-code">                      I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</p>
			<p>With the preceding code, you can check the <strong class="source-inline">I2C_FUNC_SMBUS_BYTE</strong> flag to make sure that the adapter supports SMBus byte-oriented commands.</p>
			<p>This introduction to I2C controllers will be referenced in other sections as needed. It may make sense to understand this first, even though the main purpose of this chapter is to discuss the I2C client driver, which we will do in the next section.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor120"/>I2C client and driver data structures</h2>
			<p>The first and most evident data structure is the <strong class="source-inline">struct i2c_client</strong> structure, which<a id="_idIndexMarker566"/> is declared like so:</p>
			<p class="source-code">struct i2c_client {</p>
			<p class="source-code">    unsigned short flags;</p>
			<p class="source-code">    unsigned short addr;</p>
			<p class="source-code">    char name[I2C_NAME_SIZE];</p>
			<p class="source-code">    struct i2c_adapter *adapter;</p>
			<p class="source-code">    struct device dev;</p>
			<p class="source-code">    int irq;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, which holds the properties of the I2C device, <strong class="source-inline">flags</strong> represents the device flags, the most important of which is the one telling us whether this is a 10-bit chip address. <strong class="source-inline">addr</strong> contains the chip address. In the case of a 7-bit address chip, it will be stored in the lower 7 bits. <strong class="source-inline">name</strong> contains the device name, which is limited to <strong class="source-inline">I2C_NAME_SIZE</strong> (set to <strong class="source-inline">20</strong> in <strong class="source-inline">include/linux/mod_devicetable.h</strong>) characters. <strong class="source-inline">adapter</strong> is the adapter (remember, it is the I2C bus) that this device sits on. <strong class="source-inline">dev</strong> is the underlying device structure for the device model, and <strong class="source-inline">irq</strong> is the interrupt line that's been assigned to the device.</p>
			<p>Now that we are familiar with the I2C device data structure, let's focus on its driver, which is abstracted by <strong class="source-inline">struct i2c_driver</strong>. It can be declared like so:</p>
			<p class="source-code">struct i2c_driver {</p>
			<p class="source-code">    unsigned int class;</p>
			<p class="source-code">    /* Standard driver model interfaces */</p>
			<p class="source-code">    int (*probe)(struct i2c_client *client,</p>
			<p class="source-code">                  const struct i2c_device_id *id);</p>
			<p class="source-code">    int (*remove)(struct i2c_client *client);</p>
			<p class="source-code">    int (*probe_new)(struct i2c_client *client);</p>
			<p class="source-code">    void (*shutdown)(struct i2c_client *client);</p>
			<p class="source-code">    struct device_driver driver;</p>
			<p class="source-code">    const struct i2c_device_id *id_table;</p>
			<p class="source-code">};</p>
			<p>Let's look<a id="_idIndexMarker567"/> at each element in the data structure:</p>
			<ul>
				<li><strong class="source-inline">probe</strong>: A callback for device binding that should return 0 on success or the appropriate error code on failure.</li>
				<li><strong class="source-inline">remove</strong>: A callback for device unbinding. It must undo what has been done in <strong class="source-inline">probe</strong>.</li>
				<li><strong class="source-inline">shutdown</strong>: A callback for device shutdown.</li>
				<li><strong class="source-inline">probe_new</strong>: The new driver model interface. This will deprecate the legacy <strong class="source-inline">probe</strong> method to get rid of its commonly unused second parameter (that is, the <strong class="source-inline">struct i2c_device_id</strong> parameter).</li>
				<li><strong class="source-inline">driver</strong>: The underlying device driver model's driver structure.</li>
				<li><strong class="source-inline">id_table</strong>: The list of I2C devices that are supported by this driver.</li>
			</ul>
			<p>The third and last data structure of this series is <strong class="source-inline">struct i2c_msg</strong>, which represents one operation of an I2C transaction. It is declared like so:</p>
			<p class="source-code">struct i2c_msg { </p>
			<p class="source-code">    __u16 addr; </p>
			<p class="source-code">    __u16 flags; </p>
			<p class="source-code">#define I2C_M_TEN 0x0010 </p>
			<p class="source-code">#define I2C_M_RD 0x0001 </p>
			<p class="source-code">    __u16 len; </p>
			<p class="source-code">    __u8 * buf; </p>
			<p class="source-code">};</p>
			<p>Each element in this data structure is self-explanatory. Let's look at them in more detail:</p>
			<ul>
				<li><strong class="source-inline">addr</strong>: This is always the slave address.</li>
				<li><strong class="source-inline">flags</strong>: Because a transaction may be made of several operations, this element represents the flags of this operation. It should be set to <strong class="source-inline">0</strong> in the case of a write operation (that the master sends to the slave). However, it can be ORed with either <strong class="source-inline">I2C_M_RD</strong> if it's a read operation (the master reads from the slave) or <strong class="source-inline">I2C_M_TEN</strong> if the device is a 10-bit chip address.</li>
				<li><strong class="source-inline">length</strong>: This is the size of data in the buffer. In a read operation, it corresponds to the number of bytes to be read from the device and is stored in <strong class="source-inline">buf</strong>. In the case of a write operation, it represents the number bytes in <strong class="source-inline">buf</strong> to write to the device.</li>
				<li><strong class="source-inline">buf</strong>: This is the read/write buffer, which must be allocated as per <strong class="source-inline">length</strong>.<p class="callout-heading">Note</p><p class="callout">Since <strong class="source-inline">i2c_msg.len</strong> is <strong class="source-inline">u16</strong>, you must ensure you are always less than 2<span class="superscript">16</span> (64k) away with your read/write buffer.</p></li>
			</ul>
			<p>Now that we have discussed<a id="_idIndexMarker568"/> the most important I2C data structures, let's look at the APIs (most of which involve the I2C adapter under the hood) that are exposed by the I2C core to get the most out of our devices.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor121"/>I2C communication APIs</h2>
			<p>Once the driver and the data<a id="_idIndexMarker569"/> structure have been initialized, communication between the slave and the master can take place. Serial bus transactions are just simple matters of register access, either to get or set their content. I2C devices respect this principle.</p>
			<h3>Plain I2C communication</h3>
			<p>We will start from<a id="_idIndexMarker570"/> the lowest level – <strong class="source-inline">i2c_transfer()</strong> is the core function that's used<a id="_idIndexMarker571"/> to transfer I2C messages. Other APIs<a id="_idIndexMarker572"/> wrap this function, which is backed by <strong class="source-inline">algo-&gt;master_xfer</strong> of the adapter. The following<a id="_idIndexMarker573"/> is its prototype:</p>
			<p class="source-code">int i2c_transfer(struct i2c_adapter *adap,</p>
			<p class="source-code">              struct i2c_msg *msg, int num);</p>
			<p>With <strong class="source-inline">i2c_transfer()</strong>, no stop bit is sent between bytes in the same read/write operation of the same transaction. This is useful for devices that require no stop bit between address write and data read, for example. The following code shows how it can be used:</p>
			<p class="source-code">static int i2c_read_bytes(struct i2c_client *client, </p>
			<p class="source-code">                          u8 cmd, u8 *data, u8 data_len)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct i2c_msg msgs[2];</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    u8 *buffer;</p>
			<p class="source-code">    buffer = kzalloc(data_len, GFP_KERNEL);</p>
			<p class="source-code">    if (!buffer)</p>
			<p class="source-code">        return -ENOMEM;;</p>
			<p class="source-code">    msgs[0].addr = client-&gt;addr;</p>
			<p class="source-code">    msgs[0].flags = client-&gt;flags;</p>
			<p class="source-code">    msgs[0].len = 1;</p>
			<p class="source-code">    msgs[0].buf = &amp;cmd;</p>
			<p class="source-code">    msgs[1].addr = client-&gt;addr;</p>
			<p class="source-code">    msgs[1].flags = client-&gt;flags | I2C_M_RD;</p>
			<p class="source-code">    msgs[1].len = data_len;</p>
			<p class="source-code">    msgs[1].buf = buffer;</p>
			<p class="source-code">    ret = i2c_transfer(client-&gt;adapter, msgs, 2);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        dev_err(&amp;client-&gt;adapter-&gt;dev,</p>
			<p class="source-code">                 "i2c read failed\n");</p>
			<p class="source-code">    else</p>
			<p class="source-code">        memcpy(data, buffer, data_len);</p>
			<p class="source-code">    kfree(buffer);</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p>If the device requires a stop bit in the middle of a read sequence, you should split your transaction<a id="_idIndexMarker574"/> into two parts (two operations) – <strong class="source-inline">i2c_transfer</strong> for address<a id="_idIndexMarker575"/> write (a transaction with a single write operation), and another <strong class="source-inline">i2c_transfer</strong> for data read (a transaction with a single read operation), as shown here: </p>
			<p class="source-code">static int i2c_read_bytes(struct i2c_client *client, </p>
			<p class="source-code">                          u8 cmd, u8 *data, u8 data_len)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct i2c_msg msgs[2];</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    u8 *buffer;</p>
			<p class="source-code">    buffer = kzalloc(data_len, GFP_KERNEL);</p>
			<p class="source-code">    if (!buffer)</p>
			<p class="source-code">        return -ENOMEM;;</p>
			<p class="source-code">    msgs[0].addr = client-&gt;addr;</p>
			<p class="source-code">    msgs[0].flags = client-&gt;flags;</p>
			<p class="source-code">    msgs[0].len = 1;</p>
			<p class="source-code">    msgs[0].buf = &amp;cmd;</p>
			<p class="source-code">    ret = i2c_transfer(client-&gt;adapter, msgs, 1);</p>
			<p class="source-code">    if (ret &lt; 0) {</p>
			<p class="source-code">        dev_err(&amp;client-&gt;adapter-&gt;dev, </p>
			<p class="source-code">                "i2c read failed\n");</p>
			<p class="source-code">        kfree(buffer);</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    msgs[1].addr = client-&gt;addr;</p>
			<p class="source-code">    msgs[1].flags = client-&gt;flags | I2C_M_RD;</p>
			<p class="source-code">    msgs[1].len = data_len;</p>
			<p class="source-code">    msgs[1].buf = buffer;</p>
			<p class="source-code">    ret = i2c_transfer(client-&gt;adapter, &amp;msgs[1], 1);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        dev_err(&amp;client-&gt;adapter-&gt;dev, </p>
			<p class="source-code">                "i2c read failed\n");</p>
			<p class="source-code">    else</p>
			<p class="source-code">        memcpy(data, buffer, data_len);</p>
			<p class="source-code">    kfree(buffer);</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p>Otherwise, you can use alternative<a id="_idIndexMarker576"/> APIs, such as <strong class="source-inline">i2c_master_send</strong> and <strong class="source-inline">i2c_master_recv</strong>, respectively:</p>
			<p class="source-code">int i2c_master_send(struct i2c_client *client,</p>
			<p class="source-code">             const char *buf, int count);</p>
			<p class="source-code">int i2c_master_recv(struct i2c_client *client,</p>
			<p class="source-code">             char *buf, int count);</p>
			<p>These APIs are both implemented on top of <strong class="source-inline">i2c_transfer()</strong>. <strong class="source-inline">i2c_master_send()</strong> actually implements an I2C transaction<a id="_idIndexMarker577"/> with a single write<a id="_idIndexMarker578"/> operation, while <strong class="source-inline">i2c_master_recv()</strong> does the same with a single read operation.</p>
			<p>The first argument is the I2C device to be accessed. The second parameter is the read/write buffer, while the third represents the number of bytes to read or write. The returned value is the number of bytes being read/written. The following code is a simplified version of our previous excerpt:</p>
			<p class="source-code">static int i2c_read_bytes(struct i2c_client *client, </p>
			<p class="source-code">                          u8 cmd, u8 *data, u8 data_len)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct i2c_msg msgs[2];</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    u8 *buffer;</p>
			<p class="source-code">    buffer = kzalloc(data_len, GFP_KERNEL);</p>
			<p class="source-code">    if (!buffer)</p>
			<p class="source-code">        return -ENOMEM;;</p>
			<p class="source-code">    ret = i2c_master_send(client, &amp;cmd, 1);</p>
			<p class="source-code">    if (ret &lt; 0) {</p>
			<p class="source-code">        dev_err(&amp;client-&gt;adapter-&gt;dev, </p>
			<p class="source-code">                "i2c read failed\n");</p>
			<p class="source-code">        kfree(buffer);</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    ret = i2c_master_recv(client, buffer, data_len);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        dev_err(&amp;client-&gt;adapter-&gt;dev, </p>
			<p class="source-code">                "i2c read failed\n");</p>
			<p class="source-code">    else</p>
			<p class="source-code">        memcpy(data, buffer, data_len);</p>
			<p class="source-code">    kfree(buffer);</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p>With that, we are familiar with how plain I2C APIs are implemented in the kernel. However, there is a category of devices we need to address – SMBus-compatible devices – which are not to be confused<a id="_idIndexMarker579"/> with I2C ones, even though<a id="_idIndexMarker580"/> they sit on the same physical bus.</p>
			<h3>System Management Bus (SMBus)-compatible functions</h3>
			<p>SMBus is a two-wire bus developed<a id="_idIndexMarker581"/> by Intel and is very similar to I2C. Moreover, it is a subset<a id="_idIndexMarker582"/> of I2C, which means I2C devices are SMBus-compatible, but not the reverse. SMBus is a subset of I2C, which means I2C controllers support most SMBus operations. However, this is not true for SMBus controllers as they may not support all the protocol options that an I2C controller will. Therefore, it is better to use SMBus methods in case you have doubts about the chip you are writing the driver for. </p>
			<p>The following are some examples<a id="_idIndexMarker583"/> of SMBus APIs:</p>
			<p class="source-code">s32 i2c_smbus_read_byte_data(struct i2c_client *client, </p>
			<p class="source-code">                             u8 command);</p>
			<p class="source-code">s32 i2c_smbus_write_byte_data(struct i2c_client *client,</p>
			<p class="source-code">                               u8 command, u8 value);</p>
			<p class="source-code">s32 i2c_smbus_read_word_data(struct i2c_client *client, </p>
			<p class="source-code">                             u8 command);</p>
			<p class="source-code">s32 i2c_smbus_write_word_data(struct i2c_client *client,</p>
			<p class="source-code">                              u8 command, u16 value);</p>
			<p class="source-code">s32 i2c_smbus_read_block_data(struct i2c_client *client,</p>
			<p class="source-code">                              u8 command, u8 *values);</p>
			<p class="source-code">s32 i2c_smbus_write_block_data(struct i2c_client *client,</p>
			<p class="source-code">                               u8 command, u8 length, </p>
			<p class="source-code">                               const u8 *values);</p>
			<p>A complete list of SMBus APIs is available in <strong class="source-inline">include/linux/i2c.h</strong> in the kernel sources. Each function<a id="_idIndexMarker584"/> is self-explanatory. The following example shows a simple read/write operation<a id="_idIndexMarker585"/> that's using SMBus-compatible APIs to access an I2C GPIO expander:</p>
			<p class="source-code">struct mcp23016 {</p>
			<p class="source-code">    struct i2c_client   *client;</p>
			<p class="source-code">    struct gpio_chip    chip;</p>
			<p class="source-code">    struct mutex        lock;</p>
			<p class="source-code">};</p>
			<p class="source-code">[...]</p>
			<p class="source-code">static int mcp23016_set(struct mcp23016 *mcp,</p>
			<p class="source-code">             unsigned offset, intval)</p>
			<p class="source-code">{</p>
			<p class="source-code">    s32 value;</p>
			<p class="source-code">    unsigned bank = offset / 8;</p>
			<p class="source-code">    u8 reg_gpio = (bank == 0) ? GP0 : GP1;</p>
			<p class="source-code">    unsigned bit = offset % 8;</p>
			<p class="source-code">    value = i2c_smbus_read_byte_data(mcp-&gt;client, </p>
			<p class="source-code">                                     reg_gpio);</p>
			<p class="source-code">    if (value &gt;= 0) {</p>
			<p class="source-code">        if (val)</p>
			<p class="source-code">            value |= 1 &lt;&lt; bit;</p>
			<p class="source-code">        else</p>
			<p class="source-code">            value &amp;= ~(1 &lt;&lt; bit);</p>
			<p class="source-code">        return i2c_smbus_write_byte_data(mcp-&gt;client,</p>
			<p class="source-code">                                         reg_gpio, value);</p>
			<p class="source-code">    } else</p>
			<p class="source-code">        return value;</p>
			<p class="source-code">}</p>
			<p>The SMBus part is as simple<a id="_idIndexMarker586"/> as the list of APIs that are available. Now that we can<a id="_idIndexMarker587"/> access the device either using plain I2C functions or SMBus functions, we can start implementing the body of our I2C driver. </p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor122"/>The I2C driver abstraction and architecture</h1>
			<p>The <strong class="source-inline">struct i2c_driver</strong> structure, as we saw in the<a id="_idIndexMarker588"/> previous section, contains the driving<a id="_idIndexMarker589"/> methods that are needed to handle the I2C devices it is responsible for. Once added to the bus, the device will need to be probed, which makes the <strong class="source-inline">i2c_driver.probe_new</strong> method the entry point of the driver.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor123"/>Probing the I2C device</h2>
			<p>The <strong class="source-inline">probe()</strong> callback in the <strong class="source-inline">struct i2c_driver</strong> structure is invoked any time an I2C device is instantiated<a id="_idIndexMarker590"/> on the bus and claims this driver. It is responsible for the following tasks:</p>
			<ul>
				<li>Checking whether the I2C bus controller (the I2C adapter) supports the functionalities needed by the device using the <strong class="source-inline">i2c_check_functionality()</strong> function</li>
				<li>Checking whether the device is the one we expected</li>
				<li>Initializing the device</li>
				<li>Setting up device-specific data if necessary</li>
				<li>Registering with the appropriate kernel frameworks</li>
			</ul>
			<p>Formerly, the probing callback was assigned to the <strong class="source-inline">probe</strong> element of <strong class="source-inline">struct i2c_driver</strong> and had the following prototype:</p>
			<p class="source-code">int foo_probe(struct i2c_client *client,</p>
			<p class="source-code">            const struct i2c_device_id *id)</p>
			<p>Because the second argument is rarely used, this callback has been deprecated in favor of <strong class="source-inline">probe_new</strong>, which has the following prototype:</p>
			<p class="source-code">int probe(struct i2c_client *client)</p>
			<p>In the preceding prototype, the <strong class="source-inline">struct i2c_client</strong> pointer represents the I2C device itself. This parameter is prebuilt and initialized by the core according to the device's description, which is done either in the device tree or in the board file.</p>
			<p>It is not recommended to access the device early in the <strong class="source-inline">probe</strong> method. Because each I2C adapter has different capabilities, it is better to request for it to know what capabilities it supports and adapt the driver's behavior accordingly:</p>
			<p class="source-code">#define CHIP_ID 0x13</p>
			<p class="source-code">#define DA311_REG_CHIP_ID  0x000f</p>
			<p class="source-code">static int fake_i2c_probe(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int err;</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    if (!i2c_check_functionality(client-&gt;adapter,</p>
			<p class="source-code">            I2C_FUNC_SMBUS_BYTE_DATA))</p>
			<p class="source-code">        return -EIO;</p>
			<p class="source-code">    /* read family id */</p>
			<p class="source-code">    ret = i2c_smbus_read_byte_data(client, REG_CHIP_ID);</p>
			<p class="source-code">    if (ret != CHIP_ID)</p>
			<p class="source-code">        return (ret &lt; 0) ? ret : -ENODEV;</p>
			<p class="source-code">    /* register with other frameworks */</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we checked whether the underlying adapter supports the type/command the device<a id="_idIndexMarker591"/> needs. Only after a successful sanity check, we can safely access the device and go further by allocating resources of any kind and registering with other frameworks if necessary.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor124"/>Implementing the i2c_driver.remove method</h2>
			<p>The <strong class="source-inline">i2c_driver.remove</strong> callback must undo what has been<a id="_idIndexMarker592"/> done in the <strong class="source-inline">probe</strong> function. It must unregister from each framework that was registered with <strong class="source-inline">probe</strong> and release each resource that was requested. This callback has the following prototype:</p>
			<p class="source-code">static int remove(struct i2c_device *client)</p>
			<p>In the preceding line of code, <strong class="source-inline">client</strong> is the same I2C device data structure that was passed by the core to the <strong class="source-inline">probe</strong> method. This means that whatever data you have stored at probing time can be retrieved here. For example, you may need to process some cleaning or any other stuff based<a id="_idIndexMarker593"/> on the private data you set up in the <strong class="source-inline">probe</strong> function:</p>
			<p class="source-code">static int mc9s08dz60_remove(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct mc9s08dz60 *mc9s;</p>
			<p class="source-code">    /* We retrieve our private data */</p>
			<p class="source-code">    mc9s = i2c_get_clientdata(client);</p>
			<p class="source-code">   /* Which hold gpiochip we want to work on */</p>
			<p class="source-code">    return gpiochip_remove(&amp;mc9s-&gt;chip);</p>
			<p class="source-code">}</p>
			<p>The preceding example is simple and may represent most cases that you will see in drivers. Since this callback is supposed to return zero on success, the failure reasons may include that the device can't power down, is still in use, and so on. This means that there may be situations where you will want to consult the device and perform some additional operations in this callback function.</p>
			<p>At this stage in the development process, all the callbacks have been prepared. Now, it is time for the driver to register with the I2C core, as we'll see in the next section.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor125"/>Driver initialization and registration</h2>
			<p>I2C drivers register and unregister themselves<a id="_idIndexMarker594"/> with the core using the <strong class="source-inline">i2c_add_driver()</strong> and <strong class="source-inline">i2c_del_driver()</strong> APIs, respectively. The former<a id="_idIndexMarker595"/> is a macro that's backed by the <strong class="source-inline">i2c_register_driver()</strong> function. The following code shows their respective prototypes:</p>
			<p class="source-code">int i2c_add_driver(struct i2c_driver *drv);</p>
			<p class="source-code">void i2c_del_driver(struct i2c_driver *drv);</p>
			<p>In both functions, <strong class="source-inline">drv</strong> is the I2C driver structure that had been set up previously. The registration API returns zero on success or a negative error code on failure.</p>
			<p>Driver registration mostly takes place in the module initialization while unregistering  this driver is usually done<a id="_idIndexMarker596"/> in module exit method. The following is a<a id="_idIndexMarker597"/> typical demonstration of I2C driver registering:</p>
			<p class="source-code">static int __init foo_init(void)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...] /*My init code */</p>
			<p class="source-code">      return i2c_add_driver(&amp;foo_driver);</p>
			<p class="source-code">}</p>
			<p class="source-code">module_init(foo_init);</p>
			<p class="source-code">static void __exit foo_cleanup(void)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...] /* My clean up code */</p>
			<p class="source-code">      i2c_del_driver(&amp;foo_driver);</p>
			<p class="source-code">}</p>
			<p class="source-code">module_exit(foo_cleanup);</p>
			<p>If the driver needs to do nothing else but register/unregister the driver during module initialization/cleanup, then the <strong class="source-inline">module_i2c_driver()</strong> macro can be used to reduce the preceding code, like so:</p>
			<p class="source-code">module_i2c_driver(foo_driver);</p>
			<p>This macro will be expanded at build time to the appropriate initialization/exit methods in the module, which will take care of registering/unregistering the I2C driver.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor126"/>Provisioning devices in the driver</h2>
			<p>For the matching loop<a id="_idIndexMarker598"/> to be invoked with our I2C driver, the <strong class="source-inline">i2c_driver.id_table</strong> field must be set with a list of I2C device IDs, each described by an instance of the <strong class="source-inline">struct i2c_device_id</strong> data structure, which has the following definition: </p>
			<p class="source-code">struct i2c_device_id {</p>
			<p class="source-code">   char name[I2C_NAME_SIZE];</p>
			<p class="source-code">   kernel_ulong_t driver_data;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">name</strong> is a descriptive name for the device, while <strong class="source-inline">driver_data</strong> is the driver<a id="_idIndexMarker599"/> state data, which is private to the driver. It can be set with a pointer to a per-device data structure, for example. Additionally, for device matching and module (auto)loading purposes, this same device ID array needs to be given to the <strong class="source-inline">MODULE_DEVICE_TABLE</strong> macro.</p>
			<p>However, this does not concern device tree matching. For a device node in the device tree to match our driver, the <strong class="source-inline">i2c_driver.device.of_match_table</strong> element of our driver must be set with a list of elements of the <strong class="source-inline">struct of_device_id</strong> type. Each entry in that list will describe an I2C device that can be matched from the device tree. The following is the definition of this data structure:</p>
			<p class="source-code">struct of_device_id {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    char  compatible[128];</p>
			<p class="source-code">    const void *data;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">compatible</strong> is a quite descriptive string that can be used in the device tree to match this driver, while <strong class="source-inline">data</strong> can point to anything, such as a per-device resource. In the same way, for module (auto)loading due to a device tree match, this list must be given to the <strong class="source-inline">MODULE_DEVICE_TABLE</strong> macro.</p>
			<p>The following is an example:</p>
			<p class="source-code">#define ID_FOR_FOO_DEVICE  0</p>
			<p class="source-code">#define ID_FOR_BAR_DEVICE  1 </p>
			<p class="source-code">static struct i2c_device_id foo_idtable[] = {</p>
			<p class="source-code">   { "foo", ID_FOR_FOO_DEVICE },</p>
			<p class="source-code">   { "bar", ID_FOR_BAR_DEVICE },</p>
			<p class="source-code">   { },</p>
			<p class="source-code">};</p>
			<p class="source-code">MODULE_DEVICE_TABLE(i2c, foo_idtable);</p>
			<p>Now, for module loading<a id="_idIndexMarker600"/> after a device tree match, we need to do the following: </p>
			<p class="source-code">static const struct of_device_id foobar_of_match[] = {</p>
			<p class="source-code">        { .compatible = "packtpub,foobar-device" },</p>
			<p class="source-code">        { .compatible = "packtpub,barfoo-device" },</p>
			<p class="source-code">        {},</p>
			<p class="source-code">};</p>
			<p class="source-code">MODULE_DEVICE_TABLE(of, foobar_of_match);</p>
			<p>The excerpt shows the final content for <strong class="source-inline">i2c_driver</strong>, with the respective device table pointers set:</p>
			<p class="source-code">static struct i2c_driver foo_driver = {</p>
			<p class="source-code">    .driver         = {</p>
			<p class="source-code">        .name   = "foo",</p>
			<p class="source-code">        /* The below line adds Device Tree support */</p>
			<p class="source-code">        .of_match_table = of_match_ptr(foobar_of_match),</p>
			<p class="source-code">    },</p>
			<p class="source-code">    .probe          = fake_i2c_probe,</p>
			<p class="source-code">    .remove         = fake_i2c_remove,</p>
			<p class="source-code">    .id_table       = foo_idtable,</p>
			<p class="source-code">};</p>
			<p>In the preceding code, we can see what an I2C driver structure would look like once it has been set up. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor127"/>Instantiating I2C devices</h2>
			<p>We will be using the device tree declaration<a id="_idIndexMarker601"/> because the board file, though used in old drivers so far, is an era far behind us. I2C devices must be declared as children (sub-nodes) of the bus node they sit on. The following are the properties that are required for their binding:</p>
			<ul>
				<li><strong class="source-inline">reg</strong>: This represents the address of the device on the bus.</li>
				<li><strong class="source-inline">compatible</strong>: This is a string that is used to match the device with a driver. It must match an entry in the driver's <strong class="source-inline">of_match_table</strong>.</li>
			</ul>
			<p>The following is an example declaration of two I2C devices on the same adapter: </p>
			<p class="source-code">&amp;i2c2 { /* Phandle of the bus node */</p>
			<p class="source-code">    pcf8523: rtc@68 {</p>
			<p class="source-code">        compatible = "nxp,pcf8523";</p>
			<p class="source-code">        reg = &lt;0x68&gt;;</p>
			<p class="source-code">    };</p>
			<p class="source-code">    eeprom: ee24lc512@55 { /* eeprom device */</p>
			<p class="source-code">        compatible = "labcsmart,ee24lc512";</p>
			<p class="source-code">        reg = &lt;0x55&gt;;</p>
			<p class="source-code">    };</p>
			<p class="source-code">};</p>
			<p>The preceding sample declares an RTC chip at address <strong class="source-inline">0x68</strong> and an EEPROM at address <strong class="source-inline">0x55</strong> on the same bus, which is the SoC's I2C bus number 2. The I2C core will rely on the <strong class="source-inline">compatible</strong> string property and the <strong class="source-inline">i2c_device_id</strong> table to bind devices and drivers. A first attempt is made to match the device by compatible string (the <strong class="source-inline">OF</strong> style, which is the device tree); if it fails, then the I2C core tries to match the device by the <strong class="source-inline">id</strong> table.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor128"/>How not to write I2C device drivers</h1>
			<p>Deciding not to write the device driver consists<a id="_idIndexMarker602"/> of writing the appropriate user code to deal with the underlying hardware. Though it is user code, the kernel always intervenes to ease the development process. I2C adapters are exposed by the kernel in the user space as character devices in the form of <strong class="source-inline">/dev/i2c-&lt;X&gt;</strong>, where <strong class="source-inline">&lt;X&gt;</strong> is the bus number. Once you have opened the character device file that corresponds to the adapter your device sits on, there is a series of commands you can execute.</p>
			<p>First, the required headers for dealing with I2C devices from the user space are as follows:</p>
			<p class="source-code">#include &lt;linux/i2c-dev.h&gt;</p>
			<p class="source-code">#include &lt;i2c/smbus.h&gt;</p>
			<p class="source-code">#include &lt;linux/i2c.h&gt;</p>
			<p>The following are the possible commands:</p>
			<ul>
				<li><strong class="source-inline">ioctl(file, I2C_FUNCS, unsigned long *funcs)</strong>: This command is probably the first command you should issue. It is the equivalent of <strong class="source-inline">i2c_check_functionality()</strong> in the kernel, which returns the necessary adapter functionality (in the <strong class="source-inline">*funcs</strong> argument). The returned flags are also in the form of <strong class="source-inline">I2C_FUNC_*</strong>:<p class="source-code">unsigned long funcs;</p><p class="source-code">if (ioctl(file, I2C_FUNCS, &amp;funcs) &lt; 0)</p><p class="source-code">        return -errno;</p><p class="source-code">if (!(funcs &amp; I2C_FUNC_SMBUS_QUICK)) {</p><p class="source-code">    /* Oops, SMBus write_quick) not available! */</p><p class="source-code">    exit(1);</p><p class="source-code">}</p><p class="source-code">/* Now it is safe to use SMBus write_quick command */</p></li>
				<li><strong class="source-inline">ioctl(file, I2C_TENBIT, long select)</strong>: Here, you can select whether the slave you need to talk to is a 10-bit address chip (<strong class="source-inline">select = 1</strong>) or not (<strong class="source-inline">select = 0</strong>).</li>
				<li><strong class="source-inline">ioctl(file, I2C_SLAVE, long addr)</strong>: This is used to set the chip address you need to talk to on this adapter. The address is stored in the 7 lower bits of <strong class="source-inline">addr</strong> (except for 10-bit addresses, which are passed in the 10 lower bits in this case). This chip may already be in use, in which case you can use <strong class="source-inline">I2C_SLAVE_FORCE</strong> to force usage.</li>
				<li><strong class="source-inline">ioctl(file, I2C_RDWR, struct i2c_rdwr_ioctl_data *msgset)</strong>: You can use this to perform combined plain I2C read/write transactions without stop bit in between. The structure<a id="_idIndexMarker603"/> of interest is <strong class="source-inline">struct i2c_rdwr_ioctl_data</strong>, which has the following definition:<p class="source-code">struct i2c_rdwr_ioctl_data {</p><p class="source-code">  struct i2c_msg *msgs; /* ptr to array of messages */</p><p class="source-code">  int nmsgs; /* number of messages to exchange */</p><p class="source-code">}</p></li>
			</ul>
			<p>The following is an example of using this IOCTL:</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    uint8_t buf [5] = {regaddr, '0x55', '0x65', </p>
			<p class="source-code">                       '0x88', '0x14'};</p>
			<p class="source-code">    struct i2c_msg messages[] = {</p>
			<p class="source-code">        {</p>
			<p class="source-code">            .addr = dev,</p>
			<p class="source-code">            .buf = buf,</p>
			<p class="source-code">            .len = 5, /* buf size is 5 */</p>
			<p class="source-code">        },</p>
			<p class="source-code">    };</p>
			<p class="source-code">    struct i2c_rdwr_ioctl_data payload = {</p>
			<p class="source-code">        .msgs = messages,</p>
			<p class="source-code">        .nmsgs = sizeof(messages) </p>
			<p class="source-code">                 /sizeof(messages[0]),</p>
			<p class="source-code">    };</p>
			<p class="source-code">    ret = ioctl(file, I2C_RDWR, &amp;payload);</p>
			<p>You can also use the <strong class="source-inline">read()</strong> and <strong class="source-inline">write()</strong> calls to make plain I2C transactions (once the address has been set with <strong class="source-inline">I2C_SLAVE</strong>).</p>
			<ul>
				<li><strong class="source-inline">ioctl(file, I2C_SMBUS, struct i2c_smbus_ioctl_data *args)</strong>: This command<a id="_idIndexMarker604"/> is used to issue an SMBus transfer. The main structure argument has the following prototype:<p class="source-code">struct i2c_smbus_ioctl_data {</p><p class="source-code">    __u8 read_write;</p><p class="source-code">    __u8 command;</p><p class="source-code">    __u32 size;</p><p class="source-code">    union i2c_smbus_data __user *data;</p><p class="source-code">};</p></li>
			</ul>
			<p>In the preceding data structure, <strong class="source-inline">read_write</strong> determines the direction of the transfer – <strong class="source-inline">I2C_SMBUS_READ</strong> to read and <strong class="source-inline">I2C_SMBUS_WRITE</strong> to write. <strong class="source-inline">command</strong> is a command that can be interpreted by the chip. It may be a register address, for example. <strong class="source-inline">size</strong> is the message's length, while <strong class="source-inline">buf</strong> is the message buffer. Note that standardized sizes are already exposed by the I2C core. These are <strong class="source-inline">I2C_SMBUS_BYTE</strong>, <strong class="source-inline">I2C_SMBUS_BYTE_DATA</strong>, <strong class="source-inline">I2C_SMBUS_WORD_DATA</strong>, <strong class="source-inline">I2C_SMBUS_BLOCK_DATA</strong>, and <strong class="source-inline">I2C_SMBUS_I2C_BLOCK_DATA</strong>, for 1, 2, 3, 5, and 8 bytes, respectively. The full list is available at <strong class="source-inline">include/uapi/linux/i2c.h</strong>. The following is an example that shows<a id="_idIndexMarker605"/> how to do an SMBus transfer in the user space:</p>
			<p class="source-code">    uint8_t buf [5] = {'0x55', '0x65', '0x88'};</p>
			<p class="source-code">    struct i2c_smbus_ioctl_data payload = {</p>
			<p class="source-code">        .read_write = I2C_SMBUS_WRITE,</p>
			<p class="source-code">        .size = I2C_SMBUS_WORD_DATA,</p>
			<p class="source-code">        .command = regaddr,</p>
			<p class="source-code">        .data = (void *) buf,</p>
			<p class="source-code">    };</p>
			<p class="source-code">    ret = ioctl (fd, I2C_SLAVE_FORCE, dev);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        /* handle errors */</p>
			<p class="source-code">    ret = ioctl (fd, I2C_SMBUS, &amp;payload);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        /* handle errors */</p>
			<p>Since you can use a simple <strong class="source-inline">read()</strong>/<strong class="source-inline">write()</strong> system call to do a plain I2C transfer (even though a stop bit is sent after each transfer), the I2C core provides the following APIs to perform an SMBus transfer: </p>
			<p class="source-code">__s32 i2c_smbus_write_quick(int file, __u8 value);</p>
			<p class="source-code">__s32 i2c_smbus_read_byte(int file);</p>
			<p class="source-code">__s32 i2c_smbus_write_byte(int file, __u8 value);</p>
			<p class="source-code">__s32 i2c_smbus_read_byte_data(int file, __u8 command);</p>
			<p class="source-code">__s32 i2c_smbus_write_byte_data(int file, __u8 command,</p>
			<p class="source-code">                                 __u8 value);</p>
			<p class="source-code">__s32 i2c_smbus_read_word_data(int file, __u8 command);</p>
			<p class="source-code">__s32 i2c_smbus_write_word_data(int file, __u8 command,</p>
			<p class="source-code">                                 __u16 value);</p>
			<p class="source-code">__s32 i2c_smbus_read_block_data(int file, __u8 command,</p>
			<p class="source-code">                                 __u8 *values);</p>
			<p class="source-code">__s32 i2c_smbus_write_block_data(int file, __u8 command,</p>
			<p class="source-code">                              __u8 length, __u8 *values);</p>
			<p>You are encouraged to use these functions instead of IOCTLs. If a failure occurs, all of these transactions<a id="_idIndexMarker606"/> will return <strong class="source-inline">-1</strong>; you can check <strong class="source-inline">errno</strong> for a better understanding of what went wrong. On success, the <strong class="source-inline">*_write_*</strong> transactions will return 0, while the <strong class="source-inline">*_read_*</strong> transactions will return the read value, except for <strong class="source-inline">*_read_block_*</strong>, which will return the number of values that have been read. In block-oriented operations, buffers don't need to be longer than 32 bytes.</p>
			<p>Apart from the APIs, which would require that you write some code, you can use a CLI package, <strong class="source-inline">i2ctools</strong>, which is shipped with the following tools:</p>
			<ul>
				<li><strong class="source-inline">i2cdetect</strong>: A command that enumerates the I2C devices sitting on a given adapter.</li>
				<li><strong class="source-inline">i2cget</strong>: This is used to dump the content of device registers.</li>
				<li><strong class="source-inline">i2cset</strong>: This is used to set the content of device registers.</li>
			</ul>
			<p>In this section, we learned how to use user space APIs and commands or command-line tools to communicate with I2C devices. While all these may be useful for prototyping, it could be difficult to handle devices that support interrupts or other kernel-based resources, such as clocks. </p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor129"/>Summary</h1>
			<p>In this chapter, we looked at I2C device drivers. Now, it's time for you to pick any I2C device on the market and write the corresponding driver, along with the necessary device tree support. This chapter talked about the kernel I2C core and its associated API, including device tree support, to give you the necessary skills to talk with I2C devices. You should now be able to write efficient probe functions and register them with the kernel I2C core. </p>
			<p>In the next chapter, we will use the skills we have learned in this chapter to develop an SPI device driver.</p>
		</div>
	</body></html>