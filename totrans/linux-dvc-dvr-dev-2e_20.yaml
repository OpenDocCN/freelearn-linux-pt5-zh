- en: '*Chapter 16*: Getting the Most Out of the Pin Controller and GPIO Subsystems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**System-on-chips** (**SoCs**) are becoming more and more complex and feature-rich.
    These features are mostly exposed through electrical lines originating from the
    SoC and are called pins. Most of these pins are routed to or multiplexed with
    several functional blocks (for instance, UART, SPI, RGMI, **General-Purpose Input
    Output** (**GPIO**), and so on), and the underlying device responsible for configuring
    these pins and switching between operating modes (switching between functional
    blocks) is called the **pin controller**.'
  prefs: []
  type: TYPE_NORMAL
- en: One mode in which such pins can be configured is **GPIO**. Then comes the Linux
    GPIO subsystem, which enables drivers to read signals on GPIO configured pins
    as high or low and to drive the signal high/low on GPIO configured pins. On the
    other hand, the **pin control** (abbreviated **pinctrl**) subsystem enables multiplexing
    of some pin/pin groups for different functions, and the capability to configure
    the electrical properties of pins, such as slew rate, pull up/down resistor, hysteresis,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the pin controller mainly does two things: pin multiplexing,
    that is, reusing the same pin for different purposes, and pin configuration, that
    is, configuring electronic properties of pins. Then, the GPIO subsystem allows
    driving pins, provided these pins are configured to work in GPIO mode by the pin
    controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, pin controller and GPIO subsystems will be introduced via
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to some hardware terms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the pin control subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with the GPIO controller interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the most out of the GPIO consumer interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how not to write GPIO client drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to some hardware terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel GPIO subsystem is not just about GPIO toggling. It is tightly
    coupled to the pin controller subsystem; they share some terms and concepts that
    we need to introduce:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pin** and **pad**: A pin is a physical input or output wire/line that transports
    an electrical signal from or to a component. In schematics, the term "pin" is
    widely used. Contact pads, on the other hand, are the contact surface areas of
    a printed circuit board or an integrated circuit. As a result, a pin comes from
    a pad, and a pin is a pad by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO**: Most MCUs and CPUs can share one pad among several functional blocks.
    This is accomplished by multiplexing the input and output signals of the pad.
    The different modes the pin/pad can operate in are known as **ALT modes** (or
    alternate modes), and it is common for CPUs to support up to eight settings (or
    modes) per pad. GPIO is one of these modes. It allows changing the pin direction
    and reading its value when it is configured as input or setting its value when
    it is configured as output. Other modes are ADC, UART Tx, UART Rx, SPI MOSI, SPI
    MISO, PWM, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pin controller**: This is the underlying device or controller (or rather,
    a group of registers) allowing you to perform **pin multiplexing** (also referred
    to as **pinmux** or **pinmuxing**) to reuse the same pin for different purposes.
    Apart from pinmuxing, it allows pin configuration, that is, configuring electronic
    properties of pins. The following are some of these properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Biasing**, that is, setting the initial operating conditions, for example,
    grounding the pins or connecting them to Vdd. This is not to be confused with
    pull up and pull down, which is another property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pin debounce**, which is the time after which a state should be considered
    valid. This, for example, prevents multiple key pushes on keypads attached to
    GPIO lines.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slew rate**, which determines how fast the pin toggles between the two logic
    states. It allows us to control the rise and fall time for the output signals.
    A trade-off has to be found because rapidly changing states consume more power
    and generate spikes, thus low slew rates are preferred, except for quick control
    signals such as parallel interfaces: EIM, EB&, SPI, or SDRAM, which need fast
    toggling.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull Up/Down resistors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GPIO controller**: This is the device allowing you to drive pins when they
    are put in GPIO mode. It allows changing the GPIO direction and value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following the previous definitions, certain general rules have been established
    for writing pin controllers or GPIO controller drivers, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If your GPIO/pin controller can only do simple GPIO, implement just `struct
    gpio_chip` in `drivers/gpio/gpio-foo.c` and leave it there. Do not use the generic
    or old-style number-based GPIO.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your GPIO/pin controller in `drivers/gpio` if it can generate interrupts
    in addition to GPIO capabilities; simply fill in `struct irq_chip` and register
    it with the IRQ subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement composite pin controller drivers in `drivers/pinctrl/pinctrl-foo.c`
    if this controller supports pinmuxing, advanced pin driver strength, complicated
    biasing, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the `struct gpio_chip`, `struct irq_chip`, and `struct pinctrl_desc`
    interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are familiar with the terms related to the underlying hardware devices,
    let's introduce the Linux implementation, starting with the pin control subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the pin control subsystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pin controller allows gathering pins, the modes these pins should operate
    in, and their configurations. The driver is responsible for providing the appropriate
    set of callbacks according to the features that are to be implemented, provided
    the underlying hardware supports these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pin controller descriptor data structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In that pin controller data structure, only relevant elements have been listed,
    and the following are their meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is the name of the pin controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pins`: An array of pin descriptors that describe all the pins that this controller
    can handle. It has to be noted that the controller side represents each pin/pad
    as an instance of `struct pinctrl_pin_desc`, defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding data structure, `number` represents the unique pin number from
    the global pin number space of the pin controller, and `name` is the name of this
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: '`npins`: The number of descriptors in the `pins` array, usually obtained using
    `ARRAY_SIZE()` in the `pins` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pctlops` stores the pin control operation table, to support global concepts
    such as the grouping of pins. This is optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pmxops` represents the **pinmux** operations table if you support pinmuxing
    in your driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`confops`: The pin configuration operations table if you support pin configuration
    in your driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the appropriate callbacks are defined and this data structure has been
    initialized, it can be passed to `devm_pinctrl_register()`, defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function will register the pin controller with the system, returning
    in the meantime a pointer to an instance of `struct pinctrl_dev`, representing
    the pin controller device, passed as a parameter to most (if not all) of the callback
    operations exposed by the pin controller driver. On error, the function returns
    an error pointer, which can be handled with `PTR_ERR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller''s control, multiplexing, and configuration operation tables
    are to be set up according to the features supported by the underlying hardware.
    Their respective data structures are defined in the header files that must also
    be included in the driver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to the pin control consumer interface, the following header must
    be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before being accessed by consumer drivers, pins must be assigned to the devices
    that need to control them. The recommended way to assign pins to devices is from
    the **device tree** (**DT**). How pins groups are assigned in the DT closely depends
    on the platform, thus the pin controller driver and its binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every pin control state is assigned a contiguous integer ID that starts at
    0\. A `name` property list can be used to map strings on top of these IDs to ensure
    that the same name always points to the same ID. It goes without saying that the
    set of states that must be defined in each device''s DT node is determined by
    the binding of this device. This binding also determines whether to define the
    set of state IDs that must be provided, or whether to define the set of state
    names that must be provided. In any case, two properties can be used to assign
    a pin configuration node to a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pinctrl-<ID>`: This allows you to provide the list of pin configurations needed
    for particular states of the device. It is a list of `phandles` identified by
    `<ID>`, each of which points to a pin configuration node. These referenced pin
    configuration nodes must be child nodes of (or nested in) the pin controller node
    they belong to. This property can accept multiple entries so that multiple groups
    of pins may be configured and used for a particular device state, allowing in
    the meantime to specify pins from different pin controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pinctrl-names`: This allows giving names to `pinctrl-<ID>` properties according
    to the state of the device owning the group(s) of pins. List entry 0 defines the
    name for the state whose ID is 0, list entry 1 for state ID 1, and so on. State
    ID 0 is commonly given the name `default`. A list of standardized states can be
    found in `include/linux/pinctrl/pinctrl-state.h`. However, clients or consumer
    drivers are free to implement any state they need, provided this state is documented
    in the device binding description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an excerpt of the DT, showing some device nodes, along with their pin
    control nodes. Let''s name this excerpt `pinctrl-excerpt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, a pin configuration is given in the form `<PIN_FUNCTION>
    <PIN_SETTING>`, where `<PIN_FUNCTION>` can be seen as the pin function or pin
    mode, and `<PIN_SETTING>` represents the pin''s electrical properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the excerpt, `MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09` represents the pin function/mode,
    which is GPIO in this case, and `0x80000000` represents the pin settings or electrical
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In that excerpt, `MX6QDL_PAD_EIM_D25__UART3_RX_DATA` represents the pin function,
    which is the RX line of UART3, and `0x1b0b1` represents its electrical settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pin function is a macro whose value is meaningful for the pin controller
    driver only. These are generally defined in header files located in `arch/<arch>/boot/dts/`.
    If you use an UDOO quad, for example, which has an i.MX6 quad core (32-bit ARM),
    the pin function header would be `arch/arm/boot/dts/imx6q-pinfunc.h`. The following
    is the macro corresponding to the fifth line of the GPIO5 controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`<PIN_SETTING>` can be used to set up things such as pull-ups, pull-downs,
    keepers, drive strength, and so on. How it should be specified depends on the
    pin controller binding, and the meaning of its value depends on the SoC datasheet,
    generally in the IOMUX section. On i.MX6 IOMUXC, only the lower 17 bits are used
    for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to `pinctrl-excerpt`, prior to selecting a pin group and applying its configuration,
    the driver must first obtain a handle to this group of pins using the `devm_inctrl_get()`
    function and then select the appropriate state using `pinctrl_lookup_state()`
    before finally applying the corresponding configuration state to hardware thanks
    to `pinctrl_select_state()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that shows how to grab a pin control group and
    apply its default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Like other resources (such as memory regions, clocks, and so on), it is a good
    practice to grab pins and apply their configuration from within the `probe()`
    function. However, this operation is so common that it has been integrated into
    the Linux device core as a step while probing devices. Thus, when a device is
    being probed, the device core will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the pins assigned to the device that is just about to probe using `devm_pinctrl_get()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for the default pin state (`PINCTRL_STATE_DEFAULT`) using `pinctrl_lookup_state()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look in the meantime for an init (which means during the device initialization)
    pin state (`PINCTRL_STATE_INIT`) using the same API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the init pin state if any, otherwise apply the default pin state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If power management is enabled, look for the optional sleep (`PINCTRL_STATE_SLEEP`)
    and idle (`PINCTRL_STATE_IDLE`) pin states for later use, during power management
    related operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the `pinctrl_bind_pins()` function (defined in `drivers/base/pinctrl.c`),
    and the `really_probe()` function (defined in `drivers/base/dd.c`), which calls
    the former. These functions will help you understand how pins are bound to the
    device on its probing path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`pinctrl_select_state()` internally calls `pinmux_enable_setting()`, which
    in turn calls `pin_request()` on each pin in the pin control (group of pins) node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pinctrl_put()` function can be used to release a pin control that has
    been requested using the non-managed API, that is, `pinctrl_get()`. That said,
    you can use `devm_pinctrl_get_select()`, given the name of the state to select,
    in order to configure pinmux in a single shot. This function is defined in `include/linux/pinctrl/consumer.h`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous prototype, `name` is the name of the state as written in the
    `pinctrl-name` property. If the name of the state is `default`, the helper `devm_pinctr_get_select_default()`
    can be used, which is a wrapper around `devm_pinctl_get_select()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are familiar with the pin control subsystem (with both controller
    and consumer interfaces), we can learn how to deal with GPIO controllers, knowing
    that GPIO is an operating mode that a pin can work in.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the GPIO controller interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GPIO controller interface is designed around a single data structure, `struct
    gpio_chip`. This data structure provides a set of functions, among which are methods
    to establish GPIO direction (input and output), methods used to access GPIO values
    (get and set), methods to map a given GPIO to IRQ and return the associated Linux
    interrupt number, and the `debugfs` dump method (showing extra state like pull-up
    config). Apart from these functions, that data structure provides a flag to determine
    the nature of the controller, that is, to allow checking whether this controller's
    accessors may sleep or not. Still from within this data structure, the driver
    can set the GPIO base number, from which GPIO numbering should start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the code, a GPIO controller is represented as an instance of `struct
    gpio_chip`, defined in `<linux/gpio/driver.h>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: This is the GPIO controller''s functional name. It could be a part
    number or the name of the SoC IP block implementing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpiodev`: This is the internal state container of the GPIO controller. It
    is also the structure through which the character device associated with this
    GPIO controller will be exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request` is an optional hook for chip-specific activation. If provided, it
    is executed prior to allocating GPIO whenever you call `gpio_request()` or `gpiod_get()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`free` is an optional hook for chip-specific deactivation. If provided, it
    is executed before the GPIO is deallocated whenever you call `gpiod_put()` or
    `gpio_free()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_direction` is executed whenever you need to know the direction of the
    GPIO offset. The return value should be `0` to mean out, and `1` to mean in (the
    same as `GPIOF_DIR_XXX`) or a negative error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction_input` configures the signal offset as input, or returns an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get` returns the value of the GPIO offset; for output signals, this returns
    either the value actually sensed or zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` assigns an output value to the GPIO offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_multiple` is called when you need to assign output values for multiple
    signals defined by `mask`. If not provided, the kernel will install a generic
    hook that will walk through mask bits and execute `chip->set(i)` on each bit set.
    See here how you can implement this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`set_debounce` if supported by the controller, this hook is an optional callback
    provided to set the debounce time for the specified GPIO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`to_irq` is an optional hook to provide GPIO to IRQ mapping. This is called
    whenever you want to execute the `gpio_to_irq()` or `gpiod_to_irq()` function.
    This implementation may not sleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base` indicates the first GPIO number handled by this chip; or, if negative
    during registration, the kernel will automatically (dynamically) assign one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngpio` is the number of GPIOs this controller provides, starting from base
    to (`base` + `ngpio - 1`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`names`, if not `NULL`, must be a list (an array) of strings to use as alternative
    names for the GPIOs in this chip. The array must be `ngpio` sized, and any GPIO
    that does not need an alias may have its entry set to `NULL` in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`can_sleep` is a Boolean flag to be set if `get()`/`set()` methods may sleep.
    It is the case for GPIO controllers (also known as GPIO expanders) sitting on
    buses such as I2C or SPI, whose accesses may lead to sleep. This means that if
    the chip supports IRQs, these IRQs must be threaded because the chip access may
    sleep when, for example, reading out the IRQ status registers. For a GPIO controller
    mapped to memory (part of SoC), this can be set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements that are conditioned by the enabling of `CONFIG_GPIO_GENERIC` are related
    to a generic memory-mapped GPIO controller, with a standard register set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq`: The IRQ chip of this GPIO controller if the controller can map GPIOs
    to IRQs. In such cases, this field must be set up before the GPIO chip is registered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid_mask`: If not `NULL`, this element contains a bitmask of GPIOs that
    are valid to be used from the chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_node` is a pointer to the device tree node representing this GPIO controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_gpio_n_cells` is the number of cells used to form the GPIO specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`of_xlate` is a callback to translate a device tree GPIO specifier into a chip
    relative GPIO number and flags. This hook is invoked when a GPIO line from this
    controller is specified in the device tree and must be parsed. If not provided,
    the GPIO core will set it to `of_gpio_simple_xlate()` by default, which is a generic
    GPIO core helper that supports two cell specifiers. The first cell identifies
    the GPIO number, and the second one, the GPIO flags. Additionally, when setting
    the default callback, `of_gpio_n_cells` will be set to `2`. If the GPIO controller
    needs one or more than two cell specifiers, you''ll have to implement the corresponding
    translation callback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each GPIO controller exposes a number of signals that are identified in function
    calls by offset values in the range of `0` to (`ngpio - 1`). When those GPIO lines
    are referenced through calls such as `gpio_get_value(gpio)`, the offset is determined
    by subtracting `base` from the GPIO number and passed to the underlying driver
    function (`gpio_chip->get()` for example). The controller driver should then have
    the logic to map this offset to the control/status register associated with the
    GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GPIO controller driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A GPIO controller needs nothing but the set of callbacks that correspond to
    the features it supports. After every callback of interest has been defined and
    other fields set, the driver should call `devm_gpiochip_add_data()` on the configured
    `struct gpio_chip` structure in order to register the controller with the kernel.
    You have probably guessed that you''d better use the managed API (the `devm_`
    prefix) since it takes care of chip removal when necessary and releasing resources.
    If, however, you used the classical method, you will have to use `gpiochip_remove()`
    to remove the chip if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding prototypes, `gc` is the chip to register and `data` is the
    driver's private data associated with this chip. They both return a negative error
    code if the chip can't be registered, such as because `gc->base` is invalid or
    already associated with a different chip. Otherwise, they return zero as a success
    code.
  prefs: []
  type: TYPE_NORMAL
- en: There are, however, pin controllers that are tightly coupled to the GPIO chip,
    and both are implemented in the same driver, much of which being in `drivers/pinctrl/pinctrl-*.c`.
    In such drivers, when `gpiochip_add_data()` is invoked, for device-tree-supported
    systems, the GPIO core will check the pin control's device node for the `gpio-ranges`
    property. If it is present, it will take care of adding the pin ranges for the
    driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the driver must call `gpiochip_add_pin_range()` in order to be compatible
    with older, existing device tree files that don''t set the `gpio-ranges` attribute
    or systems that use ACPI. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once more, it must be noted that the preceding is used just for backward compatibility
    for these old `pinctrl` nodes without the `gpio-ranges` property. Otherwise, calling
    `gpiochip_add_pin_range()` directly from a device tree-supported pin controller
    driver is deprecated. Please see *Section 2.1* of `Documentation/devicetree/bindings/gpio/gpio.txt`
    on how to bind pin controller and GPIO drivers via the `gpio-ranges` property.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how easy it is to write a GPIO controller driver. In the book sources
    repository, you will find a working GPIO controller driver, for the MCP23016 I2C
    I/O expander from microchip, whose datasheet is available at [http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'To write such drivers, the following header should be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is an excerpt from the driver we have written for our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding excerpt, the GPIO chip data structure has been set up before
    being passed to `devm_gpiochip_get_data()`, which is called to register the GPIO
    controller with the system. As a result, a GPIO character device node will appear
    under `/dev`.
  prefs: []
  type: TYPE_NORMAL
- en: IRQ chip enabled GPIO controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IRQ chip support can be enabled in a GPIO controller by setting up the `struct
    gpio_irq_chip` structure embedded into this GPIO controller data structure. This
    `struct gpio_irq_chip` structure is used to group all fields related to interrupt
    handling in a GPIO chip and is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There are architectures that may be multiple interrupt controllers involved
    in delivering an interrupt from the device to the target CPU. This feature is
    enabled in the kernel by setting the `CONFIG_IRQ_DOMAIN_HIERARCHY` config option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous data structure, some elements have been omitted. These are
    elements conditioned by `CONFIG_IRQ_DOMAIN_HIERARCHY`, that is, IRQ domain hierarchy
    related fields, which we won''t discuss in this chapter. For the remaining elements,
    the following are their definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chip` is the IRQ chip implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain` is the IRQ interrupt translation domain associated with `chip`; it
    is responsible for mapping between the GPIO hardware IRQ number and Linux IRQ
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain_ops` represents the set of interrupt domain operations associated with
    the IRQ domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handler` is the high-level interrupt flow handler (typically a predefined
    IRQ core function) for GPIO IRQs. There is a note on this field later in the section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_type` is the default IRQ triggering type applied during GPIO driver
    initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_handler` is the interrupt handler for the GPIO chip''s parent interrupts.
    It may be `NULL` if the parent interrupts are nested rather than chained. Moreover,
    setting this element to `NULL` will allow handling the parent IRQ in the driver.
    `gpio_chip.can_sleep` cannot be set to `true` if this handler is supplied because
    you cannot have chained interrupts on a chip that may sleep.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_handler_data` and `parent_handler_data_array` are data associated with,
    and passed to, the handler for the parent interrupt. This can either be a single
    pointer if `per_parent_data` is `false`, or an array of `num_parents` pointers
    otherwise. If `per_parent_data` is `true`, `parent_handler_data_array` cannot
    be `NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_parents` is the number of interrupt parents for the GPIO chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parents` is a list of interrupt parents of the GPIO chip. Because the driver
    owns this list, the core will only refer to it, not edit it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map` is a list of interrupt parents for each line of the GPIO chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threaded` indicates whether the interrupt handling is threaded (uses nested
    threads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`per_parent_data` tells whether `parent_handler_data_array` describes a `num_parents`
    sized array to be used as parent data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init_hw` is an optional routine for initializing hardware before an IRQ chip
    will be added. This is extremely beneficial when a driver has to clear IRQ-related
    registers in order to avoid unwanted events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init_valid_mask` is an optional callback that can be used to initialize `valid_mask`,
    which is used if not all GPIO lines are valid interrupts. There might be lines
    that just cannot fire interrupts, and this callback, when defined, is passed a
    bitmap in `valid_mask`, which will have `ngpios` bits from `0..(ngpios-1)` set
    to `1` as valid. The callback can then directly set some bits to `0` if they cannot
    be used for interrupts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid_mask`, if not `NULL`, contains a bitmask of GPIOs that are valid for
    inclusion in the IRQ domain of the chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first` is necessary in the case of static IRQ allocation. If set, `irq_domain_add_simple()`
    will allocate (starting from this value) and map all IRQs during initialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_enable`, `irq_disable`, `irq_unmask`, and `irq_mask` respectively store
    old `irq_chip.irq_enable`, `irq_chip.irq_disable`, `irq_chip.irq_unmask`, and
    `irq_chip.irq_mask` callbacks. See [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*, for a detailed explanation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the premise that your interrupts are 1-to-1 mapped to the GPIO line index,
    `gpiolib` will handle a significant portion of overhead code. In this 1-to-1 mapping,
    GPIO line offset 0 maps to hardware IRQ 0, GPIO line offset `1` maps to hardware
    IRQ `1`, and so on until GPIO line offset `ngpio-1`, which maps to hardware IRQ
    `ngpio-1`. The bitmask `valid_mask` and the flag `need_valid_mask` in `gpio_irq_chip`
    can be used to mask off some lines as invalid for associating with IRQs, provided
    some GPIO lines do not have corresponding IRQs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide GPIO IRQ chips into two broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cascaded interrupt chips**: This indicates that the GPIO chip has a single
    common interrupt output line that is triggered by any enabled GPIO line on that
    chip. The interrupt output line is subsequently routed to a parent interrupt controller
    one level up, which in the simplest case is the system''s primary interrupt controller.
    An IRQ chip implements this by inspecting bits inside the GPIO controller to determine
    which line fired it. To figure this out, the IRQ chip part of the driver will
    need to inspect registers, and it will almost certainly need to acknowledge that
    it is handling the interrupt by clearing some bits (sometimes implicitly, by simply
    reading a status register), as well as setting up configurations such as edge
    sensitivity (rising or falling edge or a high/low level interrupt, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hierarchical interrupt chips**: This means that each GPIO line is connected
    to a parent interrupt controller one level up by a dedicated IRQ line. It is not
    necessary to query the GPIO hardware to determine which line has fired, but you
    might need to acknowledge the interrupt and configure edge sensitivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cascaded GPIO IRQ chips usually fall in one of three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chained cascaded GPIO IRQ chips**: These are the types that are usually seen
    on SoCs. This means that the GPIOs have a fast IRQ flow handler that is called
    in a chain from the parent IRQ handler, which is usually the system interrupt
    controller. This means that the parent IRQ chip will immediately call the GPIO
    IRQ chip handler while holding the IRQs disabled. In its interrupt handler, the
    GPIO IRQ chip will then call something similar to this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because everything happens directly in the callback, chained GPIO IRQ chips
    cannot set the `.can_sleep` flag on `struct gpio_chip` to `true`. In this case,
    no slow bus traffic like I2C can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '`CHAINED GPIO IRQCHIPS`, but they don''t use chained IRQ handlers. GPIO IRQs
    are instead dispatched via a generic IRQ handler, which is specified using `request_irq()`.
    In this IRQ handler, the GPIO IRQ chip will then end up calling something similar
    to the following sequence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Nested thread GPIO IRQ chips**: Off-chip GPIO expanders and any other GPIO
    IRQ chip sitting on a sleeping bus, such as I2C or SPI, fall under this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, such drivers who require sluggish bus traffic to read out IRQ status
    and other information, traffic which may result in further IRQs, cannot be accommodated
    in a rapid IRQ handler with IRQs disabled. Instead, they must create a thread
    and then mask the parent IRQ line until the interrupt is handled by the driver.
    This driver''s distinguishing feature is that it calls something like the following
    in its interrupt handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Threaded GPIO IRQ chips are distinguished by the fact that they set the `.can_sleep`
    flag on `struct gpio_chip` to `true`, indicating that the chip can sleep when
    accessing the GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth recalling that `gpio_irq_chip.handler` is the interrupt flow handler.
    It is the high-level IRQ-events handler, the one that calls the underlying handlers
    registered by client drivers using `request_irq()` or `request_threaded_irq()`.
    Its value depends on the IRQ being edge- or level-triggered. It is most often
    a predefined IRQ core function, one between `handle_simple_irq`, `handle_edge_irq`,
    and `handle_level_irq`. These are all kernel helper functions that do some operations
    before and after calling the real IRQ handler.
  prefs: []
  type: TYPE_NORMAL
- en: When the parent IRQ handler calls `generic_handle_irq()` or `handle_nested_irq()`,
    the IRQ core will look for the IRQ descriptor structure (Linux's view of an interrupt)
    corresponding to the Linux IRQ number passed as an argument (`struct irq_desc
    *desc = irq_to_desc(irq)`) and calling `generic_handle_irq_desc()` on this descriptor,
    which will result in `desc->handle_irq(desc)`. You should note that `desc->handle_irq`
    corresponds to the high-level IRQ handler supplied earlier, which has been assigned
    to the IRQ descriptor using `irq_set_chip_and_handler()` during the mapping of
    this IRQ. Guess what, the mapping of these GPIO IRQs is done in `gpiochip_irq_map`,
    which is the `.map` callback of the default IRQ domain operation table (`gpiochip_domain_ops`)
    assigned by the GPIO core to the GPIO IRQ chip if not provided by the driver.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, `desc->handle_irq = gpio_irq_chip.handler`, which may be `handle_level_irq`,
    `handle_simple_irq`, `handle_edge_irq`, or (rarely) a driver-provided function.
  prefs: []
  type: TYPE_NORMAL
- en: Example of adding IRQ chip support in a GPIO chip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, we will demonstrate how to add the support of an IRQ chip into
    a GPIO controller driver. To do that, we will update our initial driver, more
    precisely, the probe method, as well as implementing an interrupt handler, which
    will hold the IRQ handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Multiplexing IRQs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_16_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – Multiplexing IRQs
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, let's consider that we have configured `io_0` and `io_1`
    as interrupt lines (this is what `DeviceA` and `deviceB` see).
  prefs: []
  type: TYPE_NORMAL
- en: Whether an interrupt happens on `io_0` or `io_1`, the same parent interrupt
    line will be raised on the GPIO chip. At this step, the GPIO chip driver must
    figure out, by reading the GPIO status register of the GPIO controller, which
    GPIO line (`io_0` or `io_1`) has really fired the interrupt. This is how, in the
    case of the MCP23016 chip, a single interrupt line (the parent actually) can be
    a multiplex for 16 GPIO interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's update the initial GPIO controller driver. It must be noted that because
    the device sits on a slow bus, we have no choice but to implement nested (threaded)
    interrupt flow handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining our IRQ chip data structure, with a set of callbacks that
    can be used by the IRQ core. The following is an excerpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, the callbacks that have been defined depend on the need. In
    our case, we have only implemented interrupt (un)masking related callbacks, as
    well as the callback allowing you to set the IRQ type. To see the full description
    of a `struct irq_chip` structure, you can refer to [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the IRQ chip data structure has been set up, we can modify the probe
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the previous probe method update, we first initialized the `struct gpio_irq_chip`
    data structure embedded into `struct gpio_chip`, and then we registered an IRQ
    handler, which will act as the parent IRQ handler, responsible for enquiring the
    underlying GPIO chip for any IRQ-enabled GPIOs that have changed, and then running
    their IRQ handlers, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following is our IRQ handler, which must have been implemented
    before the `probe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In our interrupt handler, we simply read the current GPIO, and we compare it
    with the old status to determine GPIOs that have changes. All the tricks are handled
    by `handle_nested_irq()`, which is explained in [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done and are familiar with the implementation of IRQ chips in
    GPIO controller drivers, we can learn about the binding of these GPIO controllers,
    which will allow declaring the GPIO chip hardware in the device tree in a way
    the driver understands.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO controller bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The device tree is the de facto standard to declare and describe devices on
    embedded platforms, especially on ARM architectures. It this then recommended
    for new drivers to provide the associated device bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to GPIO controllers, there are mandatory properties that need to be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`compatible`: This is the list of strings to match the driver(s) that will
    handle this device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpio-controller`: This is a property that indicates to the device tree core
    that this node represents a GPIO controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpio-cells`: Tells how many cells are used to describe a GPIO specifier. It
    should correspond to `gpio_chip.of_gpio_n_cells`, or to a value that `gpio_chip.of_xlate`
    can deal with. It is typically `<2>` for a less complex controller, with the first
    cell identifying the GPIO number, and the second defining the flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are additional mandatory properties to define if the GPIO controller
    has IRQ chip support, that is, if this controller allows mapping its GPIO lines
    to IRQs. With such GPIO controllers, the following mandatory properties must be
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interrupt-controller`: Some controllers provide IRQs mapped to the GPIOs.
    In that case, the property `#interrupt-cells` should be set too and usually you
    use `2`, but it depends on your needs. The first cell is the pin number, and the
    second represents the interrupt flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`#interrupt-cells`: This must be defined as a value supported by the `xlate`
    hook of the IRQ domain, that is, `irq_domain_ops.xlate`. It is common for this
    hook to be set with `irq_domain_xlate_twocell`, which is a generic kernel IRQ
    core helper able to handle a two-cell specifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the properties listed, we can declare our GPIO controller under its bus
    node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all for the controller side. In order to demonstrate how clients can
    consume resources provided by the MCP23016, let''s consider the following scenario:
    we have two devices, device A, named `foo`, and device B, named `bar`. The `bar`
    device consumes two GPIO lines from our controller (they will be used in output
    mode), and the `foo` device would like to map a GPIO to IRQ. This configuration
    could be declared in the device tree as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding excerpt, `parent_node` is given `simple-bus` as a `compatible`
    string in order to instruct the device tree core and the platform core to instantiate
    two platform devices, which correspond to our nodes. In that excerpt, we have
    also demonstrated how GPIOs, as well as IRQs from our controller, are specified.
    The number of cells used for each property matches the declaration in the controller
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO- and pin-controller interaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These two subsystems are closely related. A pin controller can route some or
    all of the GPIOs provided by a GPIO controller to pins on the package. This allows
    those pins to be muxed (also known as pinmuxing) between GPIO and other functions.
  prefs: []
  type: TYPE_NORMAL
- en: It may then be useful to know which GPIOs correspond to which pins on which
    pin controllers. The `gpio-ranges` property, which will be described below, represents
    this correspondence with a discrete set of ranges that map pins from the pin controller
    local number space to pins in the GPIO controller local number space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gpio-ranges` format is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The GPIO controller offset refers to the GPIO controller node containing the
    range definition. The bindings defined in `Documentation/pinctrl/pinctrl-bindings.txt`
    must be followed by the pin controller node referenced by `phandle`.
  prefs: []
  type: TYPE_NORMAL
- en: Each offset is a number between 0 and N. It is possible to stack any number
    of ranges with just one pin-to-GPIO line mapping if the ranges are concocted,
    but in practice, these ranges are generally gathered together as discrete sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ten pins (`20..29`) on pin controller `foo` are mapped to GPIO lines `0..9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twenty pins ( `50..69` ) on pin controller `bar` are mapped to GPIO lines `10..29`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be noted that GPIOs have a global number space and the pin controller
    has a local number space, so we need to define a way to cross-reference them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to map PIN `GPIO_5_29` with PIN number `89` in the pin controller number
    space. The following is the device tree property to define the mapping between
    the GPIO and pin control subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the previous excerpt, 1 GPIO line from the 29th GPIO line of GPIO bank5 will
    be mapped to pin ranges from 89 on pin controller `pinctrl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this on a real platform, let''s consider the i.MX6 SoC, which
    has 32 GPIOs per bank. The following is an excerpt from the pin controller node
    of i.MX6 SoCs, declared in `arch/arm/boot/dts/imx6qdl.dtsi`, and whose driver
    is `drivers/pinctrl/freescale/pinctrl-imx6dl.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the pin controller has been declared, a GPIO controller (bank3) is
    declared in the same base device tree, `arch/arm/boot/dts/imx6qdl.dtsi`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For information, the driver of this GPIO controller is `drivers/gpio/gpio-mxc.c`.
    After the GPIO controller node has been declared in the base device tree, this
    same GPIO controller node is overridden in a SoC-specific base device tree, `arch/arm/boot/dts/imx6q.dtsi`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding override of the GPIO controller node means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<&iomuxc 0 69 16>` means that 16 pins, from pin 69 (to 84) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 0 (to 15).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<&iomuxc 16 36 8>` means that 8 pins, from pin 36 (to 43) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 16 (to 23).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<&iomuxc 24 45 8>` means that 8 pins, from pin 45 (to 52) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 24 (to 31).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As expected, we have a 32-line GPIO bank, `16 + 8 + 8`.
  prefs: []
  type: TYPE_NORMAL
- en: As of now, we are able to both understand existing and instantiate new GPIO
    controllers from the device tree that interact with one or more pin controllers.
    As the last step in this GPIO controller binding learning curve, let's learn how
    to hog GPIOs in order to avoid writing a particular driver (or prevent existing
    ones) to control them.
  prefs: []
  type: TYPE_NORMAL
- en: Pin hogging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPIO chip can contain GPIO hog definitions. GPIO hogging is a mechanism
    providing automatic GPIO requests and configuration as part of the GPIO controller's
    driver probe function. This means that as soon as the pin control device is registered,
    the GPIO core will attempt to call `devm_pinctrl_get()`, `lookup_state()`, and
    `select_state()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are properties required for each GPIO hog definition, which is
    represented as a child node of the GPIO controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gpio-hog`: A property that indicates whether or not this child node represents
    a GPIO hog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpios`: Contains the GPIO information (ID, flags, ...) for each GPIO to affect.
    Will contain an integer multiple of the number of cells specified in its parent
    node (GPIO controller node).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only one of the following properties can be specified, scanned in the order
    they are listed. This means that when multiple properties are present, they will
    be searched in the order they are presented here, with the first match being considered
    as the intended configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input`: A property that specifies that the GPIO direction should be set to
    input.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-low`: A property that specifies that the GPIO should be configured
    as output, with an initial low state value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output-high`: A property that specifies that the GPIO direction should be
    set to output with an initial high value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An optional property is `line-name`: the GPIO label name. If it''s not present,
    the node name is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt, where we first declare (as GPIO) the pins we are
    interested in in the pin controller node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After the pins of interest are declared, we can hog each GPIO under the node
    of the GPIO controller this GPIO belongs to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It must be noted that hogging pins should be used for those pins that are not
    controlled by any particular driver.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO hogging was the last part on the GPIO controller side. Now that controllers
    have no more secrets for us, let's switch to the consumer interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the most out of the GPIO consumer interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GPIO is a feature, or a mode in which a pin can operate, in terms of hardware.
    It is nothing more than a digital line that may be used as an input or output
    and has just two values (or states): 1 for high or 0 for low. The kernel''s GPIO
    subsystem includes all of the functions you''ll need to set up and manage GPIO
    lines from within your driver.'
  prefs: []
  type: TYPE_NORMAL
- en: Before using a GPIO from within the driver, it must first be claimed by the
    kernel. It's a means to take control of a GPIO and prohibit other drivers from
    using it, as well as preventing the controller driver from being unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'After claiming control of the GPIO, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the direction and, if needed, set the GPIO configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's being used as an output, start toggling its output state (driving the
    line high or low).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If used as input, set the debounce-interval if needed and read the state. For
    a GPIO line mapped to an IRQ, configure at what edge/level the interrupt should
    be triggered, and register a handler that will be run when the interrupt occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Linux kernel, there are two different ways to deal with GPIOs:'
  prefs: []
  type: TYPE_NORMAL
- en: The legacy and deprecated integer-based interface, which uses integers to represent
    GPIOs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new descriptor-based interface, where a GPIO is represented and described
    by an opaque structure, with a dedicated API. This is the recommended way to go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we will discuss the two approaches in this chapter, let's start with the
    legacy interface.
  prefs: []
  type: TYPE_NORMAL
- en: Integer-based GPIO interface – now deprecated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The integer-based interface is the most known usage of GPIOs in Linux systems,
    either in the kernel or in the user space. In this mode, the GPIO is identified
    by an integer, which is used for every operation that needs to be performed on
    this GPIO. The following is the header that contains the legacy GPIO access function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The integer-based interface relies on a set of functions, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding functions are mapped to a set of callbacks provided by the
    GPIO controller through its `struct gpio_chip` structure, thanks to which it exposes
    a generic set of callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: In all these functions, `gpio` represents the GPIO number we are interested
    in. Before using a GPIO, client drivers must call `gpio_request()` in order to
    take ownership of the line and, very importantly, to prevent this GPIO controller
    driver from being unloaded. In the same function, `label` is the label used by
    the kernel for labeling/describing the GPIO in sysfs as we can see in `/sys/kernel/debug/gpio`.
    `gpio_request``()` returns `0` on success, and a negative error code on error.
    If in doubt, before requesting the GPIO, you can use the `gpio_is_valid()` function
    to check whether the specified GPIO number is valid on the system prior to it
    being requested.
  prefs: []
  type: TYPE_NORMAL
- en: Once a driver owes the GPIO, it can change its direction, depending on the need,
    whether it should be an input or output, using the `gpio_direction_input()` or
    `gpio_direction_output()` functions. In these functions, `gpio` is the GPIO number
    the driver needs to set the direction, which should have already been requested.
    There is a second parameter when it comes to configuring the GPIO as output, `value`,
    which is the initial state the GPIO should be in once the output direction is
    effective. Here again, in both functions, the return value is `0` on success or
    a negative error code on failure. Internally, these functions are mapped to lower-level
    callback functions exported by the driver of the GPIO chip that provides the GPIO
    line `gpio`.
  prefs: []
  type: TYPE_NORMAL
- en: Some GPIO controllers allow you to adjust the GPIO debounce-interval (this is
    only useful when the GPIO line is configured as input). This parameter can be
    set using `gpio_set_debounce()`. In this function, the `debounce` argument is
    the debounce time in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: As it is a good practice to grab and configure resources in the driver's probing
    method, GPIO lines must respect this rule.
  prefs: []
  type: TYPE_NORMAL
- en: It has to be noticed that GPIO management (either configuration or getting/setting
    values) is not context agnostic; that is, there are memory-mapped GPIO controllers
    that can be accessed from any context (process and atomic contexts). On the other
    hand, there are GPIOs provided by discrete chips sitting on slow buses (such as
    I2C or SPI) that can sleep (because sending/receiving commands on such buses requires
    waiting to get to the head of a queue to transmit a command and get its response).
    Such GPIOs must be manipulated from a process context exclusively. A well-designed
    controller driver must be able to inform clients whether calls to its GPIO driving
    methods may sleep or not. This can be checked with the `gpio_cansleep()` function.
    This function returns `true` for GPIO lines whose controller sits on a slow bus,
    and `false` for GPIOs that belong to a memory-mapped controller.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the GPIOs are requested and configured, we can set/get their values
    using the appropriate APIs. Here again, the APIs to use are context-dependent.
    For memory-mapped GPIO controllers, their GPIO lines can be accessed using `gpio_get_value()`
    or `gpio_set_value()`. The first function returns a value that represents the
    GPIO state, and the second one will set the value of the GPIO, which should have
    been configured as an output using `gpio_direction_output()`. `value` can be considered
    as Boolean for both functions, with zero indicating a low level and a non-zero
    value indicating a high level.
  prefs: []
  type: TYPE_NORMAL
- en: In case of doubt about the kind of GPIO controller from where the GPIO originates,
    the driver should use the context agnostic APIs, `gpio_get_value_cansleep()` and
    `gpio_set_value_cansleep()`. These APIs are safe to use in threaded contexts but
    also work in an atomic context.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The legacy (that is, integer-based) interface supports specifying GPIOs from
    the device tree, in which case the APIs to be used to grab those GPIOs will be
    `of_get_gpio()`, `of_get_named_gpio()`, or similar APIs. These are mentioned here
    for studying purposes and won't be discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO mapped to IRQ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are GPIO controllers that allow their GPIO lines to be mapped to IRQs.
    These IRQs can be either edge- or level-triggered. The configuration depends on
    the needs. The GPIO controller is responsible for providing the mapping between
    the GPIO and its IRQ.
  prefs: []
  type: TYPE_NORMAL
- en: If the IRQ has been specified in the device tree and the underlying device is
    an I2C or SPI device, the consumer driver must just request the IRQ normally,
    since upon the device tree parsing, the GPIO mapped to IRQ specified in the device
    tree will be translated by the device tree core and assigned to your device structure,
    that is, `i2c_client.irq` or `spi_device.irq`. This is the case in `foo_device`
    from the example we have seen in the *GPIO controller bindings* section. For another
    device type, you'll have to call `irq_of_parse_and_map()` or a similar API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, however, the driver is given a GPIO (from module parameters, for example)
    or specified from the device tree without being mapped to IRQ there, the driver
    must use `gpio_to_irq()` to map the given GPIO number to its IRQ number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This function returns the corresponding Linux IRQ number, which can be passed
    to `request_irq()` (or the threaded counterpart, `request_threaded_irq()`) to
    register a handler for this IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`request_any_context_irq()` is smart enough to identify the underlying context
    supported by the IRQ chip integrated into the GPIO controller. If this controller''s
    accessors can sleep, `request_any_context_irq()` will request a threaded IRQ,
    otherwise, it will request an atomic-context IRQ.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a short example demonstrating what we have discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the previous excerpt, we have demonstrated how to use a legacy integer-based
    interface to grab a GPIO specified in the device tree, as well as the old API
    to translate this GPIO into a valid Linux IRQ number. These were the main points
    to highlight.
  prefs: []
  type: TYPE_NORMAL
- en: Though deprecated, we briefly introduced the legacy GPIO APIs. As is recommended,
    in the next section, we will deal with the new descriptor-based GPIO interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Descriptor-based GPIO interface: the new and recommended way'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the new descriptor-based GPIO interface, the subsystem has been oriented
    to the producer/consumer. The header required for the descriptor-based GPIO interface
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'With the descriptor-based interface, a GPIO is described and characterized
    by a coherent data structure, `struct gpio_desc`, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding data structure, `chip` is the controller providing this GPIO
    line; `flags` are the flags characterizing the GPIO and `label` is the name describing
    the GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to requesting and acquiring ownership of GPIOs with the descriptor-based
    interface, these GPIOs must have been specified or mapped somewhere. It means
    they should be allocated to a driver, whereas with the legacy integer-based interface,
    a driver could just obtain a number from anywhere and request it as GPIO. Since
    descriptor-based GPIOs are represented by an opaque structure, such a method is
    not possible anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new interface, GPIOs must exclusively be mapped to names or indexes,
    specifying at the same time the GPIO chips providing the GPIOs of interest. This
    gives us three ways to specify and assign GPIOs to drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform data mapping**: In such cases, for example, the mapping is done
    in the board file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device tree**: The mapping is done in the device tree. This is the mapping
    we will discuss in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Configuration and Power Interface mapping (ACPI)**: This is ACPI-style
    mapping. On x86-based systems, this is the most common configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are done with the GPIO descriptor interface introduction, let's
    learn how it is mapped and assigned to devices.
  prefs: []
  type: TYPE_NORMAL
- en: GPIO descriptor mapping in the device tree and its APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GPIO descriptor mappings are defined in the device tree node of the consumer
    device. The GPIO descriptor mapping property must be named `<name>-gpios` or `<name>-gpio`,
    where `<name>` is meaningful enough to describe the function for which the GPIO(s)
    will be used. This is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that descriptor-based GPIO lookup relies on the `gpio_suffixes[]`
    variable, a `gpiolib` variable defined in `drivers/gpio/gpiolib.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This variable is used in both device tree lookup and ACPI-based lookup. To
    see how it works, let''s see how it is used in `of_find_gpio()`, the device tree''s
    low-level GPIO lookup function defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s consider the following node, which is an excerpt of `Documentation/gpio/board.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is what a mapping should look like, with meaningful names, corresponding
    to the functions assigned to the GPIOs. This excerpt will be used as the basis
    for the rest of this section to demonstrate the use of the descriptor-based GPIO
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the GPIOs have been specified in the device tree, the first thing
    to be done is to allocate GPIO descriptors and take the ownership of these GPIOs.
    This can be done using `gpiod_get()`, `gpiod_getindex()`, or `gpiod_get_optional()`,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It must be noted that we can also use the device-managed variant of these APIs,
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Both non `_optional` functions will return `-ENOENT` if no GPIO with the given
    function is assigned or a negative error if another error occurred. On success,
    the GPIO descriptor corresponding to the GPIO is returned. The first method returns
    the GPIO descriptor structure for the GPIO at a particular index (useful when
    the specifier is a list of GPIOs), whereas the second function always returns
    the GPIO at index `0` (single GPIO mapping). The `_optional` variant is useful
    for drivers that need to deal with optional GPIOs; it's the same as `gpiod_get()`,
    except that it returns `NULL` when no GPIO has been assigned to the device (that
    is, specified in the device tree).
  prefs: []
  type: TYPE_NORMAL
- en: 'In parameters, `dev` is the device to which the GPIO descriptor will belong.
    It is the underlying `device` structure the driver is responsible for; for example,
    `i2c_client.dev`, `spi_device.dev`, or `platform_device.dev`. `con_id` is the
    function of the GPIO within the consumer interface. It corresponds to the `<name>`
    prefix of the GPIO specifier property name in the device tree. `idx` is the index
    (starting from `0`) of the GPIO in case the specifier contains a list of GPIOs.
    `flags` is an optional parameter that determines the GPIO initialization flags,
    to configure the direction and/or the initial output value. It is an instance
    of `enum gpiod_flags`, defined in `include/linux/gpio/consumer.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s demonstrate in the following how these APIs can be used in drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of readability, the preceding code does not perform error checking.
    The LED GPIOs will be active-high, but the power GPIO will be active-low (that
    is, `gpiod_is_active_low(power)` returns `true` in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `flags` argument is optional, there might be situations where either
    the initial flags are not specified or when the initial function of the GPIO needs
    to be changed. To address this, drivers can use `gpiod_direction_input()` or `gpiod_direction_output()`
    to change the GPIO direction. These APIs are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding APIs, `desc` is the GPIO descriptor of the GPIO of interest,
    and `value` is the initial value to apply to this GPIO when it is configured as
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'It must be noted that the same attention must be paid as with the integer-based
    interface. In other words, the driver must take care of whether the underlying
    GPIO chip is memory-mapped (and thus can be accessed in any context) or sits on
    a slow bus (which would require accessing the chip in process or threaded context
    exclusively). This can be achieved using the `gpiod_cansleep()` function, defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This function returns `true` if the underlying hardware can put the caller to
    sleep while it is accessed. In such cases, drivers should use dedicated APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are APIs to get or set the GPIO value on a controller that sits
    on a slow bus, that is, a GPIO descriptor for which `gpiod_cansleep()` returned
    `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If the underlying chip is memory mapped, the following APIs can be used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The context must be considered only if the driver is intended to access the
    GPIO(s) from within an interrupt handler or from within any other atomic context.
    Otherwise, you can just use the normal APIs, that is, the ones without the `_cansleep`
    suffix.
  prefs: []
  type: TYPE_NORMAL
- en: '`gpiod_to_irq()` can be used to get the IRQ number that corresponds to a GPIO
    descriptor mapped to IRQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The resulting IRQ number can be used with the `request_irq()` function (or the
    threaded variant `request_threaded_irq()`). If the driver does not need to bother
    with the context supported by the underlying hardware chip, `request_any_context_irq()`
    can be used instead. That said, the driver can use the device managed variant
    of these functions, that is, `devm_request_irq()`, `devm_request_threaded_irq()`,
    or `devm_request_any_context_irq()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If for any reason the module needs to switch back and forth between the descriptor-based
    interface and the legacy integer-based interface, the APIs `desc_to_gpio()` and
    `gpio_to_desc()` can be used for translations. They are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, `gpio_to_desc()` takes a legacy GPIO number in the parameter
    and returns the associated GPIO descriptor, while `desc_to_gpio()` does the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of using the device-managed APIs is that drivers need not care
    about releasing the GPIO at all, since it will be handled by the GPIO core. If,
    however, non-managed APIs were used to request a GPIO descriptor, this descriptor
    must explicitly be released with `gpiod_put()`, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with the consumer side's descriptor-based APIs, let's summarize
    what we have learned in a concrete example, from the mapping from the device tree
    to the consumer code based on consumer APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following driver summarizes the concepts introduced in the descriptor-based
    interface. In this example, we need four GPIOs split as follows: two for LEDs
    (red and green, which are then configured as output) and two for buttons (thus
    configured as input). The logic to implement is that pushing button 1 toggles
    both LEDs only when button 2 is pushed as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve that, let''s consider the following mapping in the device tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the GPIOs have been mapped in the device tree, let''s write the platform
    driver that will leverage these GPIOs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding, we have started with the IRQ handler. The toggling logic
    is implemented by `led_state = 1 – led_state`. Next, we implement the driver''s
    `probe` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding probe method is quite simple. We first start requesting the GPIOs,
    then we translate the button 1 GPIO line into a valid IRQ number, and then we
    register a handler for this IRQ. You should pay attention to the fact that we
    have exclusively used device-managed APIs in that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we set up a device ID table before filling and registering our platform
    device driver, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We may wonder why neither GPIO descriptors nor interrupts were released. This
    is because we exclusively used device-managed APIs in the `probe` function. Thanks
    to these, we do not need to release anything explicitly, thus we can get rid of
    the `remove` method of the platform driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use non-managed APIs, the `remove` method could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, we can notice the use of regular `gpiod_put()` and `free_irq()`
    APIs to release GPIO descriptors and the IRQ line.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have done with the kernel side of GPIO management, both
    on the controller and client sides. As we have learned all through this book,
    there are situations where we might want to avoid writing specific kernel code.
    Regarding GPIOs, the next section will teach us how not to write GPIO client drivers
    to control these GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how not to write GPIO client drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations where writing user space code would achieve the same goals
    as writing kernel drivers. Moreover, the GPIO framework is one of the most used
    frameworks in the user space. It then goes without saying that there are several
    possibilities to deal with it in the user space, some of which we will introduce
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Goodbye to the legacy GPIO sysfs interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sysfs has ruled GPIO management from the user space for quite a long time now.
    Though it is scheduled for removal, the sysfs GPIO interface still has a few days
    ahead of it. `CONFIG_GPIO_SYSFS` can still enable it, but its use is discouraged,
    and it will be removed from mainline Linux. This interface allows managing and
    controlling GPIOs through a set of files. It is located at `/sys/class/gpio/`,
    and the following are the common directory paths and attributes that are involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys/class/gpio/`: This is where it all starts. There are two special files
    in this directory, `export` and `unexport`, and as many directories as there are
    GPIO controllers registered with the system:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export`: By writing the number of a GPIO to this file, we ask the kernel to
    export control of that GPIO to the user space. For example, typing `echo 21 >
    export` will create a `gpio21` node (resulting in a subdirectory of the same name)
    for GPIO `#21`, if this GPIO is not already requested by the kernel code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unexport`: The effect of exporting to the user space is reversed by writing
    the same GPIO number to this file. For example, the `gpio21` node exported using
    the `export` file will be removed by typing `echo 21 > unexport`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On successful `gpio_chip` registration, a directory entry with a path such
    as `/sys/class/gpio/gpiochipX/` will be created, where `X` is the GPIO controller
    base (the controller providing GPIOs starting at `#X`), having the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`base`, whose value is the same as `X`, and which corresponds to `gpio_chip.base`
    (if assigned statically), and being the first GPIO managed by this chip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`, which is provided for diagnostics (not always unique).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngpio`, which tells us how many GPIOs this controller provides (`N` to `N
    + ngpio - 1`). This is the same as defined in `gpio_chip.ngpios`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys/class/gpio/gpioN/`: This directory corresponds to the GPIO line `N`,
    exported either using the `export` file or directly from the kernel. `/sys/class/gpio/gpio42/`
    (for GPIO `#42`) is an example. The following read/write attributes are contained
    in such directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direction`: Use this file to get/set GPIO direction. Acceptable values are
    either `in` or `out` strings. This attribute will normally be written and writing
    the `out` value will initialize the GPIO value as `low` by default. To ensure
    glitch-free operation, values low and high may be written to configure the GPIO
    as an output with that initial value. If, however, the GPIO has been exported
    from the kernel (see the `gpiod_export()` or `gpio_export()` functions), then
    this attribute will be missing, disabling at the same time direction change.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: This attribute can be used to get or set the state of the GPIO line
    based on its direction, input, or output. If the GPIO is configured as an output,
    any non-zero value written will set the output high, while writing `0` will set
    this output low. If the pin can be set up as an interrupt-generating line and
    is set to do so, then the `poll()` system function can be used on that file and
    will return when an interrupt occurs. Setting the events `POLLPRI` and `POLLERR`
    is required when using `poll()`. If, however, `select()` is used instead, the
    file descriptor should be set in `exceptfds`. After `poll()` returns, the user
    code should either `lseek()` to the beginning of the sysfs file and read the new
    value or close the file and re-open it to read the value. It is the same principle
    as we discussed for the pollable sysfs attribute.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edge` determines the signal edge that will let the `poll()` or `select()`
    functions return. `none`, `rising`, `failing`, or `both` are acceptable values.
    This readable and writable file exists only if the GPIO can be configured as an
    interrupt generating input pin.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active_low`: When it is read, this attribute either returns `0` (for `false`)
    or `1` (meaning `true`). Writing any nonzero value will invert the `value` attribute
    for both reading and writing. Existing and subsequent `poll()`/`select()` support
    configuration through the `edge` attribute for rising and falling edges will follow
    this setting.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a short sequence of commands demonstrating the use of the
    sysfs interface to drive GPIOs from the user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Let's not spend more time on this legacy interface. Without delay, let's switch
    to what kernel developers have provided as a new GPIO management interface from
    the user space, the `Libgpiod` library.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the Libgpiod GPIO library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Kernel Linux GPIO user space sysfs is deprecated and has been discontinued.
    That said, it was suffering from many ailments, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: State not tied to processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of concurrent access management to sysfs attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lack of support for bulk GPIO operations, that is, performing operations on
    a set of GPIOs with a single command (in a single shot).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of operations were needed just to set a GPIO value (opening and writing
    into the export file, opening and writing into the direction file, opening and
    writing into the value file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unreliable polling – user code had to poll on `/sys/class/gpio/gpioX/`value,
    and on each event, it was necessary to `close/re-open` or `lseek` in the file
    before re-reading the new value. This could lead to events being lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was not possible to set GPIO electrical properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the process crashed, the GPIOs remained exported; there was no context concept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address the limits of the sysfs interface, a new GPIO interface has been
    developed, the descriptor-based GPIO interface. It comes with GPIO character devices
    – a new user API, merged in Linux v4.8\. This new interface has introduced the
    following improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One device file per GPIO chip: `/dev/gpiochip0`, `/dev/gpiochip1`, `/dev/gpiochipX`
    ….'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s similar to other kernel interfaces: `open()` + `ioctl()` + `poll()` +
    `read()` + `close()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to request multiple lines at once (for reading/setting values)
    using bulk-related APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to find GPIO lines and chips by name, which is much more reliable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open source and open-drain flags, user/consumer strings, and uevents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliable polling, preventing the loss of events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Libgpiod` is shipped with a C API allowing you to get the most out of any
    GPIO chip registered on the system. That said, the C++ and Python languages are
    supported as well. The API is well documented, and too extensive to fully cover
    here. The basic use cases usually follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the desired GPIO chip character device by calling one of the `gpiod_chip_open*`
    functions, such as `gpiod_chip_open_by_name()` or `gpiod_chip_open_lookup()`.
    This returns a pointer to `struct gpiod_chip`, which is used by subsequent API
    calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the handle to the desired GPIO line by calling `gpiod_chip_get_line()`,
    which will return a pointer to an instance of `struct gpiod_line`. While the previous
    API returns the handle to a single GPIO line, the function `gpiod_chip_get_lines()`
    can be used if several GPIO lines are needed in a single shot. `gpiod_chip_get_lines()`
    will return a pointer to an instance of `struct gpiod_line_bulk`, which can be
    used later for bulk operations. The other API that can return a set of GPIO handles
    is `gpiod_chip_get_all_lines()`, which returns all the lines of a given GPIO chip
    in `struct gpiod_line_bulk`. When you have such a set of GPIO objects, you can
    request a GPIO line at a specific index local to this bulk object by using the
    `gpiod_line_bulk_get_line()` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request the use of the line as an input or output by calling `gpiod_line_request_input()`
    or `gpiod_line_request_output()`. For bulk operations on a set of GPIO lines,
    `gpiod_line_request_bulk_input()` or `gpiod_line_request_bulk_output()` can be
    used instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the value of input GPIO lines by calling `gpiod_line_get_value()` for a
    single GPIO or `gpiod_line_get_value_bulk()` in the case of a set of GPIOs. For
    output GPIO lines, the level can be set by calling `gpiod_line_set_value()` for
    a single GPIO line or `gpiod_line_set_value_bulk()` on a set of output GPIOs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When done, release the lines by calling `gpiod_line_release()` or `gpiod_line_release_bulk()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once all the GPIO lines have been released, the associated chips can be released
    using `gpiod_chip_close()` on each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gpiod_line_release()` is to be called once done with a GPIO line. The GPIO
    line to release is passed as a parameter. If it is, however, a set of GPIOs that
    needs to be released, `gpiod_line_release_bulk()` should be used instead. It has
    to be noted that if the lines were not previously requested together (were not
    requested with `gpiod_line_request_bulk()`), the behavior of `gpiod_line_release_bulk()`
    is undefined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are sanity APIs it might worth mentioning, which are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding APIs, `gpiod_line_is_requested()` can be used to check if the
    calling user owns this GPIO line. This function returns `true` if `line` was already
    requested, or `false` otherwise. It is different from `gpiod_line_is_free()`,
    which is used to check if the calling user has neither requested ownership `line`
    nor set up any event notifications on it. It returns `true` if `line` is free,
    and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Other APIs are available for more advanced functions such as configuring pin
    modes for pullup or pulldown resistors or registering a callback function to be
    called when an event occurs, such as the level of an input pin changing, as we
    will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Event- (interrupt-) driven GPIO
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interrupt-driven GPIO handling consists of grabbing one (`struct gpiod_line`)
    or more (`struct gpiod_line_bulk`) GPIO handles and listening for events on these
    GPIO lines, either infinitely or in a timed manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'A GPIO line event is abstracted by a `struct gpiod_line_event` object, defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding data structure, `ts` is the time specifier data structure to
    represent the wait event timeout, and `event_type` is the type of event, which
    can be either `GPIOD_LINE_EVENT_RISING_EDGE` or `GPIOD_LINE_EVENT_FALLING_EDGE`,
    respectively for a rising edge event or a falling edge event.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the GPIO handle(s) has been obtained using `gpiod_chip_get_line()` or
    `gpiod_chip_get_lines()` or `gpiod_chip_get_all_lines()`, the user code should
    request events of interest on these GPIO handles using one of the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding APIs request either rising edge, falling edge, or both edge events,
    respectively on a single GPIO line or on a set of GPIO (the bulk-related API).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the events have been requested, the user code can wait on the GPIO lines
    of interest, waiting for the requested events to occur using one of the following
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding, `gpiod_line_event_wait()` waits for event(s) on a single GPIO
    line, while `gpiod_line_event_wait_bulk()` will wait on a set of GPIOs. In parameters,
    `line` is the GPIO line on which to wait events in the case of single GPIO monitoring,
    while `bulk` is the set of GPIO lines in the case of bulk monitoring. Finally,
    `event_bulk` is an output parameter, holding the set of GPIO lines on which the
    GPIO events of interest have occurred. These are all blocking APIs, which will
    continue execution flow only after the events of interest have occurred or after
    a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the blocking function returns, `gpiod_line_event_read()` must be used
    to read the events that occurred on the GPIO line(s) returned by the previously
    mentioned monitoring functions. This API has the following prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: On error, this API returns `-1`, otherwise, it returns `0`. In parameters, `line`
    is the GPIO line to read the events on, and `event` is an output parameter, the
    event buffer to which the event data will be copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of requesting an event and reading and processing
    that event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we first look up the GPIO chip by its name and use
    the returned GPIO chip handle to grab a handle on GPIO line #25\. Next, we request
    a rising events notification (interrupt-driven) on the GPIO line. After that,
    we loop on waiting for events to happen, read which event it was, and validate
    that it''s a rising event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the previous code example, let''s now imagine a much complex example,
    where we monitor five GPIO lines, and let''s start by feeding the required headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s provide the static variables we will use in the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, `chip` will hold the handle to the GPIO chip that we
    are interested in. `gpio_lines` will hold the handles of the event-driven GPIO
    lines, that is, the GPIO lines to be monitored. Finally, `gpio_events` will be
    given to the library so that upon monitoring, it is filled with the handles of
    GPIO lines on which events have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s start implementing our `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, we have simply opened the GPIO chip device and kept
    a pointer to it. Next, we will have to grab handles of the GPIO lines of interest
    and store them in `gpio_lines`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use these GPIO line handles to request event monitoring on their underlying
    GPIO lines. Because we are interested in more than one GPIO, we use the `bulk`
    API variant, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous snippet, `gpiod_line_request_bulk_rising_edge_events()` will
    request rising edge event notifications. Now that we have requested event-driven
    monitoring for our GPIO, we can call the blocking monitoring API on these GPIO
    lines, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the previous excerpt, since we need time-bounded event polling, we set up
    a `struct timespec` data structure with the desired timeout and we pass it to
    `gpiod_line_event_wait_bulk()`.
  prefs: []
  type: TYPE_NORMAL
- en: That said, reaching this step (passing the polling function) would mean that
    either the blocking monitoring API has timed out or that an event occurred on
    at least one of the GPIO lines that are monitored. The GPIO handles on which events
    occurred are stored in `gpio_events`, which is an output argument, and the list
    of monitored GPIO lines is passed in `gpio_lines`. It must be noted that both
    `gpio_lines` and `gpio_events` are bulk GPIO data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'If ever we are interested in reading the values of the GPIO lines on which
    events have occurred, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If instead of reading the values of GPIO lines on which events occurred we needed
    to read the value of all the monitored GPIO lines, we would have replaced `gpio_events`
    with `gpio_lines` in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, if we are interested in the type of event that occurred on each GPIO
    line in `gpio_events`, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we iterate over each GPIO line in `gpio_events`, which
    represents the list of GPIO lines on which events have occurred. `gpiod_line_bulk_num_lines()`
    retrieves the number of GPIO lines held by the line bulk object, and `gpiod_line_bulk_get_line()`
    retrieves the line handle from a line bulk object at the given offset, local to
    this line bulk object. You should, however, note that to achieve the same goal,
    we could have used the `gpiod_line_bulk_foreach_line()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on each GPIO line in the line bulk object, we invoke `gpiod_line_event_read()`,
    `gpiod_line_name()`, and `gpiod_line_offset()`. The first function will retrieve
    the event data structure corresponding to the event that occurred on that line.
    We could have then checked that the event type that occurred (especially when
    monitoring for both event types) is what we expected using something such as `if
    (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)`, for example. The second function
    is a helper that will retrieve the GPIO line name, while the third one, `gpiod_line_offset()`,
    will retrieve the GPIO line offset, global to the running system.
  prefs: []
  type: TYPE_NORMAL
- en: If we were interested in monitoring these GPIO lines infinitely or for a certain
    number of rounds, we could have wrapped the code between the `marker1` and `marker2`
    labels into a `while()` or a `for()` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the execution flow, we do some cleaning, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The previous cleaning code snippet first releases all the GPIO lines that we
    have requested, and then closes the associated GPIO chip.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It must be noted that bulk GPIO monitoring must be done on a per GPIO chip basis.
    That is, it is not recommended to embed GPIO lines from different GPIO chips in
    the same line bulk object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with API usage and have demonstrated it in a practical
    example, we can switch to command-line tools shipped with the `libgpiod` library.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you simply need to perform simple GPIO operations, the `Gpiod` library includes
    a collection of command-line tools that are particularly handy for interactively
    exploring GPIO functions and can be used in shell scripts to avoid the need to
    write C or C++ code. There are the following commands available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gpiodetect`: Displays the list of all GPIO chips on the system, together with
    their names, labels, and the number of GPIO lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpioinfo`: Displays the names, consumers, direction, active status, and other
    flags for all lines of the selected GPIO chips. `gpioinfo gpiochip6` is an example.
    If no GPIO chip is given, the command will iterate through all GPIO chips on the
    system and list their associated lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpioget`: Gets the values of GPIO lines specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpioset`: Sets the values of specified GPIO lines, and potentially keeps them
    exported until a timeout, user input, or signal occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpiofind`: Given a line name, this command finds the associated GPIO chip
    name and line offset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpiomon`: Monitors GPIOs by waiting for events on these lines. This command
    allows you to specify which events to watch and how many of them should be processed
    before exiting or whether the events should be reported to the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have listed the available command-line tools, we can go on to learn
    about another mechanism offered by the GPIO subsystem, and that can be leveraged
    from the user space, thanks to which we can use the aforementioned tools.
  prefs: []
  type: TYPE_NORMAL
- en: The GPIO aggregator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GPIO access control now uses permissions on `/dev/gpiochip*` with the new interface.
    The typical Unix filesystem permissions enable all-or-nothing access control to
    these character devices. Compared to the earlier `/sys/class/gpio` interface,
    this new interface provides a number of advantages, which we listed at the beginning
    of the *Welcome to the Libgpiod GPIO library* section. One disadvantage, however,
    is that it creates one device file per GPIO chip, implying that access privileges
    are defined on a per GPIO chip basis, rather than per GPIO line.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the `/dev/gpiochip*` device.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is handy for designating a set of GPIOs to a certain user and implementing
    access control. Furthermore, exporting GPIOs to a virtual machine is simplified
    and hardened because the virtual machine can just grab the entire GPIO controller
    and no longer has to worry about which GPIOs to grab and which not to, decreasing
    the attack surface. `Documentation/admin-guide/gpio/gpio-aggregator.rst` is where
    you'll find its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To have GPIO aggregator support in your kernel, you must have `CONFIG_GPIO_AGGREGATOR=y`
    in your kernel configuration. This feature can be configured either via sysfs
    or the device tree, as we will see in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating GPIOs using sysfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aggregated GPIO controllers are instantiated and destroyed by writing to write-only
    attribute files in sysfs, mainly from the `/sys/bus/platform/drivers/gpio-aggregator/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This directory contains the followings attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new_device`: Used to ask the kernel to instantiate an aggregated GPIO controller
    by writing a string describing the GPIOs to aggregate. The `new_device` file understands
    the format `[<gpioA>] [<gpiochipB> <offsets>] ...`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<gpioA>` is a GPIO line name.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<gpiochipB>` is a GPIO chip label.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<offsets>` is a comma-separated list of GPIO offsets and/or GPIO offset ranges
    denoted by dashes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_device`: Used to ask the kernel to destroy an aggregated GPIO controller
    after use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example that instantiated a new GPIO aggregator by aggregating
    GPIO line 19 of `e6052000.gpio` and GPIO lines 20-21 of `e6050000.gpio` into a
    new `gpio_chip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'After use, the previously created aggregated GPIO controller can be destroyed
    using the following command, assuming it is named `gpio-aggregator.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: From the previous example, the GPIO chip that resulted from the aggregation
    was `gpiochip12`, having three GPIO lines. Instead of `gpioinfo gpio-aggregator.0`,
    we could have used `gpioinfo gpiochip12`.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating GPIOs from the device tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The device tree can also be used to aggregate GPIOs. To do so, simply define
    a node with `gpio-aggregator` as a compatible string and set the `gpios` property
    to the list of GPIOs that you want to be part of the new GPIO chip. A unique feature
    of this technique is that, like any other GPIO controller, the GPIO lines can
    be named and subsequently queried by user-space applications using the `libgpiod`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we will demonstrate the use of the GPIO aggregator with several
    GPIO lines from the device tree. First, we enumerate the pins we need to use GPIOs
    in our new GPIO chip. We do this under the pin controller node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our pins have been configured, we can declare our GPIO aggregator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `pinctrl_aggregator_pins` is the GPIO pin node, which must
    have been instantiated under the pin controller node. `gpios` contains the list
    of GPIO lines the new GPIO chip must be made of. At the end, the meaning of `gpio-line-names`
    is line 30 of GPIO controller `gpio3` is used and is named `line_a`, line 23 of
    GPIO controller `gpio3` is used and is named `line_b`, line 29 of GPIO controller
    `gpio1` is used and named `line_c`, and so on up to line 1 of GPIO controller
    `gpio7`, which is named `line_h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the user space, we can see the GPIO chip and its aggregated lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can search a GPIO chip and a line number by the line name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We can access a GPIO line by its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the GPIO chip device file ownership to allow user or group to
    access the attached lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The GPIO chip created by the aggregator can be retrieved from sysfs in `/sys/bus/platform/devices/gpio-aggregator/`.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating GPIOs using a generic GPIO driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without a particular in-kernel driver, the GPIO aggregator can be used as a
    generic driver for a simple GPIO-operated device described in the device tree.
    Modifying the `gpio-aggregator` driver or writing to the `driver_override` file
    in sysfs are both options for binding a device to the GPIO aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further, let's talk about the `driver_override` file; this file
    is more precisely located in `/sys/bus/platform/devices/.../driver_override`.
    This file specifies the driver for a device, which will override the standard
    device tree, ACPI, ID table, and name matching, as we have seen in [*Chapter 6*](B17934_06_Epub.xhtml#_idTextAnchor095),
    *Introduction to Devices, Drivers, and Platform Abstraction*. It has to be noted
    that only a driver whose name matches the value written to `driver_override` will
    be able to bind to the device. The override is set by writing a string to the
    `driver_override` file (`echo vfio-platform > driver_override`), and it can be
    cleared by writing an empty string to the file (`echo > driver_override`). This
    reverts the device to its default binding of matching rules. It must, however,
    be noted that writing to driver override does not unbind the device from its existing
    driver or attempt to load the supplied driver automatically. The device will not
    bind to any driver if no driver with a matching name is currently loaded in the
    kernel. Devices can also use a `driver_override` name such as `none` to opt out
    of driver binding. There is no support for parsing delimiters, and only a single
    driver can be given in the override.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given a `door` device, which is a GPIO-operated device described
    in the device tree, use its own compatible value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be bound to the GPIO aggregator with either of the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding its compatible value to `gpio_aggregator_dt_ids[]` in `drivers/gpio/gpio-aggregator.c`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding manually using `driver_override`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first method is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the previous commands, we have written the driver's name (`gpio-aggregator`
    in this case) in the `driver_override` file present in the device directory, `/sys/bus/platform/devices/<device-name>/`.
    After that, we have bound the device to the driver by writing the device name
    in the `bind` file present in the driver's directory, `/sys/bus/<bus-name>/drivers/<driver-name>/`.
    It has to be noted that `<bus-name>` corresponds to the bus framework the driver
    belongs to. It could be `i2c`, `spi`, `platform`, `pci`, `isa`, `usb`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the binding, a new GPIO chip, `door`, will be created. Its information
    can then be carried out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Next, the library APIs can be used on this GPIO chip like any other normal (non-virtual)
    GPIO chip.
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with GPIO aggregation from the user space in particular, and
    with GPIO management from the user space in general. We have learned how to create
    virtual GPIO chips to isolate a set of GPIOs, and we have learned how to use the
    GPIO library to drive these GPIOs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the pin control framework and described its interaction
    with the GPIO subsystem. We learned how to deal with GPIOs, either as a controller
    or consumer, from both the kernel and the user space. Though the legacy integer-based
    interface is deprecated, it was introduced because it is still widely used. Additionally,
    we introduced some advanced topics such as IRQ chip support in the GPIO chip and
    the mapping of GPIOs to IRQs. We ended this chapter by learning how to deal with
    GPIOs from the user space, by writing C code or by using dedicated command-line
    tools provided by the standard Linux GPIO library, `libgpiod`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we deal with input devices, which can be implemented using
    GPIOs.
  prefs: []
  type: TYPE_NORMAL
