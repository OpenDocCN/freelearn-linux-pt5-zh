<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Handling SELinux-aware Applications</h1></div></div></div><p>In this chapter, we will cover handling of SELinux-aware applications through the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Controlling D-Bus message flows</li><li class="listitem" style="list-style-type: disc">Restricting service ownership</li><li class="listitem" style="list-style-type: disc">Understanding udev's SELinux integration</li><li class="listitem" style="list-style-type: disc">Using cron with SELinux</li><li class="listitem" style="list-style-type: disc">Checking the SELinux state programmatically</li><li class="listitem" style="list-style-type: disc">Querying SELinux userland configuration in C</li><li class="listitem" style="list-style-type: disc">Interrogating the SELinux subsystem code-wise</li><li class="listitem" style="list-style-type: disc">Running new processes in a new context</li><li class="listitem" style="list-style-type: disc">Reading the context of a resource</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec87"/>Introduction</h1></div></div></div><p>For most <a id="id642" class="indexterm"/>applications, the SELinux subsystem in the Linux kernel is capable of enforcing security controls without further interaction with other applications and components. However, there are actions that cannot be handled by the SELinux subsystem autonomously. Some applications execute commands for specific users, but the target domain cannot be deduced from the path of the application that is itself being executed, making type transitions based on the label impossible.</p><p>One solution for this problem is to make the application SELinux-aware, having the application interrogate the SELinux subsystem as to what should be the context of the newly executed application. Once the context is obtained, the application can then instruct the SELinux subsystem that this context can be assigned to the process that will be launched next.</p><p>Of course, it isn't only about deciding what context a process should be in. Applications can also check the SELinux policy and act on the policy themselves, rather than having the policies enforced through the Linux kernel. If applications use SELinux to get more information about a session and set contexts based on this information, then we call these applications SELinux-aware.</p><p>The <a id="id643" class="indexterm"/>easiest method to see whether an application is SELinux-aware is to check the documentation, or to check whether it is linked with the <code class="literal">libselinux.so</code> library:</p><div><pre class="programlisting">
<strong>~$  ldd /usr/sbin/crond | grep selinux</strong>
<strong>  libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007fa53299a000)</strong>
</pre></div><p>Some SELinux-aware applications not only query information, but also enforce decisions on objects that the SELinux subsystem in the Linux kernel cannot control. Examples of such <a id="id644" class="indexterm"/>objects are the database objects in the <strong>Security Enhanced PostgreSQL</strong> (<strong>SEPostgreSQL</strong>) application or the D-Bus services. Although represented in the SELinux policy, they are not part of the regular Linux operating system but are instead owned by the application itself. Such SELinux-aware<a id="id645" class="indexterm"/> applications are called <strong>user space object managers</strong>.</p><p>Regardless of how an application handles its SELinux-specific code, whenever such applications are used on a system, it is important to know how the SELinux code in the application works, as the standard approach (look at AVC denials and see whether a context needs to be changed or the policy tuned) might not work at all in these cases.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec88"/>Controlling D-Bus message flows</h1></div></div></div><p>D-Bus<a id="id646" class="indexterm"/> implementation on Linux is an example of an SELinux-aware application, acting as a user space object manager. Applications can register themselves on a bus and can send messages between applications through D-Bus. These messages can be controlled through the SELinux policy as well.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec212"/>Getting ready</h2></div></div></div><p>Before looking at the SELinux access controls related to message flows, it is important to focus on a D-Bus service and see how its authentication is done (and how messages are relayed in D-Bus) as this is reflected in the SELinux integration.</p><p>Go to <code class="literal">/etc/dbus-1/system.d/</code> (which hosts the configuration files for D-Bus services) and take a look at a configuration file. For instance, the service configuration file for <code class="literal">dnsmasq</code> looks like the following:</p><div><pre class="programlisting">&lt;!DOCTYPE busconfig PUBLIC "-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd"&gt;
&lt;busconfig&gt;
  &lt;policy user="root"&gt;
    &lt;allow own="uk.org.thekelleys.dnsmasq"/&gt;
    &lt;allow send_destination="uk.org.thekelleys.dnsmasq"/&gt;
  &lt;/policy&gt;
  &lt;policy context="default"&gt;
    &lt;deny own="uk.org.thekelleys.dnsmasq"/&gt;
    &lt;deny send_destination="uk.org.thekelleys.dnsmasq"/&gt;
  &lt;/policy&gt;
&lt;/busconfig&gt;</pre></div><p>This <a id="id647" class="indexterm"/>configuration tells D-Bus that only the root Linux user is allowed to have a service <em>own</em> the <code class="literal">uk.org.thekelleys.dnsmasq</code> service and send messages to this service. Others (as managed through the default policy) are denied these operations.</p><p>On a system with SELinux enabled, having root as the finest granularity doesn't cut it. So, let's look at how the SELinux policy can offer a fine-grained access control in D-Bus.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How to do it…</h2></div></div></div><p>To control D-Bus message flows with SELinux, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the domain of the application that will (or does) own the D-Bus service we are interested in. For the <code class="literal">dnsmasq</code> application, this would be <code class="literal">dnsmasq_t</code>:<div><pre class="programlisting">
<strong>~# ps -eZ | grep dnsmasq | awk '{print $1}'</strong>
<strong>system_u:system_r:dnsmasq_t:s0-s0:c0.c1023</strong>
</pre></div></li><li class="listitem">Identify the domain of the application that wants to send messages to the service. For instance, this could be the <code class="literal">sysadm_t</code> user domain.</li><li class="listitem">Allow the two domains to interact with each other through D-Bus messages as follows:<div><pre class="programlisting">gen_require(`
  class dbus send_msg;
')
allow sysadm_t dnsmasq_t:dbus send_msg;
allow dnsmasq_t sysadm_t:dbus send_msg;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec214"/>How it works…</h2></div></div></div><p>When an application connects to D-Bus, the SELinux label of its connection is used as the label to check when sending messages. As there is no transition for such connections, the label of the connection is the context of the process itself (the domain); hence the selection of <code class="literal">dnsmasq_t</code> in the example.</p><p>When<a id="id648" class="indexterm"/> D-Bus receives a request to send a message to a service, D-Bus will check the SELinux policy for the <code class="literal">send_msg</code> permission. It does so by passing on the information about the session (source and target context and the permission that is requested) to the SELinux subsystem, which computes whether access should be allowed or not. The access control itself, however, is not enforced by SELinux (it only gives feedback), but by D-Bus itself as governing the message flows is solely D-Bus' responsibility.</p><p>This is also why, when developing D-Bus-related policies, both the class and permission need to be explicitly mentioned in the policy module. Without this, the development environment might error out, claiming that <code class="literal">dbus</code> is not a valid class.</p><p>D-Bus checks the context of the client that is sending a message as well as the context of the connection of the service (which are both domain labels) and see if there is a <code class="literal">send_msg</code> permission allowed. As most communication is two-fold (sending a message and then receiving a reply), the permission is checked in both directions. After all, sending a reply is just sending a message (policy-wise) in the reverse direction.</p><p>It is possible to verify this behavior with <code class="literal">dbus-send</code> if the rule is on a user domain. For instance, to look at the objects provided by the service, the D-Bus introspection can be invoked against the service:</p><div><pre class="programlisting">
<strong>~# dbus-send --system --dest=uk.org.thekelleys.dnsmasq --print-reply /uk/org/thekelleys/dnsmasq org.freedesktop.DBus.Introspectable.Introspect</strong>
</pre></div><p>When SELinux does not have the proper <code class="literal">send_msg</code> allow rules in place, the following error will be logged by D-Bus in its service logs (but no AVC denial will show up as it isn't the SELinux subsystem that denies the access):</p><div><pre class="programlisting">
<strong>Error org.freedesktop.DBus.Error.AccessDenied: An SELinux policy prevents this sender from sending this message to this recipient. 0 matched rules; type="method_call", sender=":1.17" (uid=0 pid=6738 comm="") interface="org.freedesktop.DBus.Introspectable" member="Introspect" error name="(unset)" requested_reply="0" destination="uk.org.thekelleys.dnsmasq" (uid=0 pid=6635 comm="")</strong>
</pre></div><p>When the policy does allow the <code class="literal">send_msg</code> permission, the introspection returns an XML output showing the provided methods and interfaces for this service.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec215"/>There's more...</h2></div></div></div><p>The current D-Bus implementation is a pure user space implementation. Because more applications become dependent on D-Bus, work is being done to create a kernel-based D-Bus<a id="id649" class="indexterm"/> implementation called <strong>kdbus</strong>. The exact implementation <a id="id650" class="indexterm"/>details of this project are not finished yet, so it is unknown whether the SELinux access controls that are currently applicable to D-Bus will still be valid on kdbus.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec89"/>Restricting service ownership</h1></div></div></div><p>Applications<a id="id651" class="indexterm"/> that register themselves on the bus own a service name. The <code class="literal">uk.org.thekelleys.dnsmasq</code> service name is an example of this. The D-Bus policy, declared in the <code class="literal">busconfig</code> XML file at <code class="literal">/etc/dbus-1/system.d/</code> (or <code class="literal">session.d/</code> if the service is for the session bus instead of system bus) provides information for D-Bus to decide when taking ownership of a particular service is allowed.</p><p>Thanks to D-Bus' SELinux integration, additional constraints can be added to ensure that only authorized applications can take ownership of a particular service.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec216"/>How to do it…</h2></div></div></div><p>To restrict service ownership through the SELinux policy, follow the ensuing set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Inside the D-Bus configuration file of the service, make sure that the <code class="literal">own</code> permission is properly protected. For instance, make sure only the <code class="literal">root</code> Linux user can own the service:<div><pre class="programlisting">&lt;policy user="root"&gt;
  &lt;allow own="uk.org.thekelleys.dnsmasq" /&gt;
&lt;/policy&gt;</pre></div></li><li class="listitem">If the runtime service account can differ, it is possible to declare a <code class="literal">group=</code> parameter instead of a <code class="literal">user=</code> parameter as well.</li><li class="listitem">Next, declare which label to associate to the service:<div><pre class="programlisting">&lt;selinux&gt;
  &lt;associate own="uk.org.thekelleys.dnsmasq" context="dnsmasq_t" /&gt;
&lt;/selinux&gt;</pre></div></li><li class="listitem">In the SELinux policy, declare which domain(s) are allowed to acquire this service:<div><pre class="programlisting">gen_require(`
  class dbus acquire_svc;
')
allow dnsmasq_t self:dbus acquire_svc;</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec217"/>How it works…</h2></div></div></div><p>The D-Bus configuration allows administrators to define when service ownership for a particular service can be taken. Most services define the user (or group) that is allowed to own a service, as shown in the example. But for system services, only declaring that the Linux<a id="id652" class="indexterm"/> root user can own a particular service is definitely not sufficiently fine-grained.</p><p>Enter SELinux. With the association definition in the <code class="literal">busconfig</code> XML file, D-Bus is told that any application domain that tries to own that particular service must have the <code class="literal">acquire_svc</code> privilege (in the <code class="literal">dbus</code> class) against the mentioned context.</p><p>With this approach, administrators can ensure that other domains, even though they run as the Linux root user, are not allowed to own the service.</p><p>Although the usual approach, for the target label, is to require the context of the application itself, it is also possible to use a different context. For instance, a new type can be declared such as <code class="literal">dnsmasq_dbus_t</code> and then the SELinux policy is set to the following:</p><div><pre class="programlisting">allow dnsmasq_t dnsmasq_dbus_t:dbus acquire_svc;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec218"/>There's more...</h2></div></div></div><p>The D-Bus application has a configuration file inside <code class="literal">/etc/selinux/mcs/contexts/</code>, which follows the same structure, called <code class="literal">dbus_contexts</code>. This is a default context definition for D-Bus ownership (what context should be used by default if it cannot be deduced by other means). By default, no SELinux-specific settings are provided anymore as D-Bus is now fully aware of the contexts to use, and it is not recommended to modify this file anymore.</p><p>However, it is useful to know that the file exists and is used, especially when D-Bus would be executed in a container, chroot, or other environment as D-Bus will complain if the file is missing:</p><div><pre class="programlisting">
<strong>Failed to start message bus: Failed to open "/etc/selinux/mcs/contexts/dbus_contexts": No such file or directory</strong>
</pre></div><p>If the SELinux support in D-Bus needs to be disabled (but without rebuilding D-Bus), then edit <code class="literal">/etc/dbus-1/system.conf</code> and <code class="literal">session.conf</code> and remove the following line:</p><div><pre class="programlisting">&lt;include if_selinux_enabled="yes" selinux_root_relative="yes"&gt;contexts/dbus_contexts&lt;/include&gt;</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec90"/>Understanding udev's SELinux integration</h1></div></div></div><p>The udev device manager is responsible for handling device files inside the <code class="literal">/dev/</code> structure <a id="id653" class="indexterm"/>whenever changes occur. As many device files have different contexts, without any SELinux awareness, the udev policy would need to be enhanced with many, many named file transitions. Such a named file transition, for a device <code class="literal">/dev/mydevice</code> towards the <code class="literal">mydevice_t</code> type, would look like the following code:</p><div><pre class="programlisting">dev_filetrans(udev_t, mydevice_t, chr_file, "mydevice")</pre></div><p>However, when <code class="literal">/dev/mydevice1</code>, <code class="literal">/dev/mydevice2</code>, and so on need to be labeled as well, then each possible name would need to be iterated in the policy (named file transitions do not support regular expressions). Luckily, udev is SELinux-aware, making it unnecessary to create policy enhancements for every device file.</p><p>This recipe shows us when additional policy enhancements are needed and when not.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec219"/>How to do it…</h2></div></div></div><p>To understand how udev's SELinux integration works, the following decision criteria can be followed:</p><div><ol class="orderedlist arabic"><li class="listitem">Whenever a device file is created by udev inside a directory with the <code class="literal">device_t</code> label, then udev will automatically label the device file with the label known to the SELinux subsystem through its <code class="literal">file_contexts</code> definitions if the target type is assigned the <code class="literal">device_node</code> attribute.</li><li class="listitem">If the parent directory does not use the <code class="literal">device_t</code> type, then make sure that udev holds manage rights on that target type.</li><li class="listitem">If the target file context is not associated with the <code class="literal">device_node</code> attribute, grant udev the proper <code class="literal">relabelto</code> privileges.</li><li class="listitem">If udev's rules are configured to create symbolic links, then assert that the label of the links remains the generic <code class="literal">device_t</code> type.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec220"/>How it works…</h2></div></div></div><p>The udev application is a standard SELinux-aware application that interacts with the SELinux user space by querying the context definitions and either creating the new device files with the queried context or by relabeling the device files afterwards.</p><p>By querying the context definitions (instead of relying on the SELinux policy), administrators can easily modify the rules for different device names or include support for new device types, without the need to enhance the <code class="literal">udev_t</code> related policies. All that an administrator has to do is to configure the proper file context definition:</p><div><pre class="programlisting">
<strong>~# semanage fcontext -a -t mydevice_t -f -c /dev/mydevice[0-9]*</strong>
</pre></div><p>However, if the target device type (<code class="literal">mydevice_t</code>) is not associated with the <code class="literal">device_node</code> attribute, then <code class="literal">udev_t</code> will not have the privileges to relabel this device type. This attribute is vital for the support of <code class="literal">udev_t</code>, as it has relabel (and manage) rights on all device nodes through this attribute.</p><p>If a <a id="id654" class="indexterm"/>udev rule would request the creation of a device file that is not associated with the <code class="literal">device_node</code> attribute (or a different file—the requested file does not need to be a device), then an update on the SELinux policy is needed if the default context association (that is, through inheritance of the type through the parent directory) is not sufficient.</p><p>For the same reason, it is necessary to have symbolic links remain as <code class="literal">device_t</code> as the SELinux policy does not handle different types for symbolic links.</p><p>Of course, this SELinux support inside udev also has its consequences when device files are created outside of udev's handling. If that is the case, then the administrator has to make sure that the label of the files is corrected, as wrong device types can result in a system malfunction.</p><p>A popular approach for that is to relabel the entire <code class="literal">/dev/</code> structure (which is often done by a distribution <code class="literal">init</code> script to counter the default device file creation—and its default <code class="literal">device_t</code> type—from within the initial RAM filesystem or the <code class="literal">devtmpfs</code> mount):</p><div><pre class="programlisting">
<strong>~# restorecon -R /dev</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec91"/>Using cron with SELinux</h1></div></div></div><p>Another<a id="id655" class="indexterm"/> example of an SELinux-aware application is cron. Well, actually <a id="id656" class="indexterm"/>a set of cron implementations, as there is not a single cron application. Examples of cron implementations are vixie-cron, cronie, and fcron.</p><p>The cron implementations invoke commands for (and as) a particular Linux user. As these commands are not set in stone (the main purpose of cron is to allow any command to be run for a particular user or even for the system itself), it is not possible to easily create a policy that is sufficiently fine-grained to accommodate all features provided by cron. After all, for SELinux itself, there is no difference between cron calling a command for one user or another: all that is involved is the cron domain (<code class="literal">crond_t</code>) and the target type of the command (such as <code class="literal">bin_t</code>).</p><p>For this reason, many cron implementations are made SELinux-aware, allowing the cron implementation to select the proper target context.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec221"/>How to do it…</h2></div></div></div><p>To properly interact with an SELinux-aware cron, the following steps need to be followed:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure that the crontab files are properly labeled: <code class="literal">user_cron_spool_t</code> for the user crontabs, and <code class="literal">system_cron_spool_t</code> for the system crontab.</li><li class="listitem">Check <code class="literal">/etc/selinux/mcs/contexts/default_contexts</code> or <code class="literal">/etc/selinux/mcs/contexts/users/*</code> for the target context of the <code class="literal">system_r:crond_t</code> domain.</li><li class="listitem">Have the crontab file context be an entrypoint for the target domain. For instance, if the target domain for a user is its own user domain (such as <code class="literal">user_t</code>), then <code class="literal">user_cron_spool_t</code> has to be known as an entrypoint for <code class="literal">user_t</code>.</li><li class="listitem">Set the <code class="literal">cron_userdomain_transition</code> Boolean to <code class="literal">on</code> if the target domain for user jobs is the user domain, or <code class="literal">off</code> if the target domain should be the <code class="literal">cronjob_t</code> domain.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec222"/>How it works…</h2></div></div></div><p>When<a id="id657" class="indexterm"/> cron is SELinux-aware, it is vital that it is running <a id="id658" class="indexterm"/>in the <code class="literal">crond_t</code> domain. Its internal SELinux code will query the SELinux policy to see what the target domain is for a user through the application, and if cron isn't running in the <code class="literal">crond_t</code> domain, then this query will not result in the correct set of domains:</p><div><pre class="programlisting">
<strong>~# ps -efZ | grep fcron | awk '{print $1}'</strong>
<strong>system_u:system_r:crond_t:s0-s0:c0.c1023</strong>
</pre></div><p>Before launching user jobs from cron, the cron application will check the file context of the user crontab file. This file context is then used to see whether the target domain for the user jobs has the user crontab file context as an entrypoint.</p><p>To know what the current target domain will be, we can use the <code class="literal">getseuser</code> helper application:</p><div><pre class="programlisting">
<strong>~# getseuser hannah system_u:system_r:crond_t:s0</strong>
<strong>seuser: user_u</strong>
<strong>Context 0    user_u:user_r:cronjob_t:s0</strong>
</pre></div><p>In this case, the target domain is <code class="literal">cronjob_t</code>. This should be confirmed by the <code class="literal">default_contexts</code> (or user-specific context) file:</p><div><pre class="programlisting">
<strong>~# grep crond_t /etc/selinux/mcs/contexts/users/user_u</strong>
<strong>system_r:crond_t  user_r:cronjob_t</strong>
</pre></div><p>If the target domain should be the user domain, then we need to toggle the right Boolean and adjust the context file accordingly:</p><div><pre class="programlisting">
<strong>~# setsebool cron_userdomain_transition on</strong>
<strong>~# grep crond_t /etc/selinux/mcs/contexts/users/user_u</strong>
<strong>system_r:crond_t  user_r:user_t</strong>
</pre></div><p>With the target domain known, the last thing that is needed is that the user cronjob file context is known as an entrypoint for the domain, which most cron implementations will check as a sort-of access control:</p><div><pre class="programlisting">
<strong>~# sesearch -s user_t -t user_cron_spool_t -c file -p entrypoint -A</strong>
<strong>Found 1 semantic av rules:</strong>
<strong>  allow user_t user_cron_spool_t : file entrypoint ;</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec223"/>There's more…</h2></div></div></div><p>Not all <a id="id659" class="indexterm"/>cron implementations are SELinux-aware. If the implementation<a id="id660" class="indexterm"/> is not SELinux-aware, then the cron jobs will all run inside a single cron job container (<code class="literal">cronjob_t</code> for user cron jobs and <code class="literal">system_cronjob_t</code> for system cron jobs) with the <code class="literal">system_u</code> SELinux user and the <code class="literal">system_r</code> SELinux role.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec92"/>Checking the SELinux state programmatically</h1></div></div></div><p>If the need <a id="id661" class="indexterm"/>arises to make an SELinux-aware application, then several languages can be used. The <code class="literal">libselinux</code> package usually provides bindings for<a id="id662" class="indexterm"/> multiple programming and scripting languages. In the next set of recipes, the C programming language will be used as an example implementation.</p><p>The first step to support SELinux in an application is to check the SELinux state. In this recipe, we will show how to create an application that links with the <code class="literal">libselinux</code> library and checks the state of SELinux.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec224"/>Getting ready</h2></div></div></div><p>As we are going to update a C application, this set of recipes will assume basic knowledge of C programming. An example C application that uses all the input from this (and other) recipes can be found in the download pack of this book.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec225"/>How to do it…</h2></div></div></div><p>In order to link with <code class="literal">libselinux</code> and to check the current SELinux state, the following set of steps can be used:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a C application code file and refer to the SELinux header files through a compiler directive:<div><pre class="programlisting">#ifdef SELINUX
#include &lt;selinux/selinux.h&gt;
#include &lt;selinux/av_permissions.h&gt;
#include &lt;selinux/get_context_list.h&gt;
#endif</pre></div></li><li class="listitem">In the <a id="id663" class="indexterm"/>application, have the SELinux-related function call return <code class="literal">success</code> if SELinux support should not be built-in (that is, when the compiler directive isn't set):<div><pre class="programlisting">int selinux_prepare_fork(char * name) {
#ifndef SELINUX
  return 0;
#else
  …
#endif
};</pre></div></li><li class="listitem">Inside the SELinux function, check whether SELinux is enabled using the <code class="literal">is_selinux_enabled()</code> function call:<div><pre class="programlisting">int rc;
rc = is_selinux_enabled();
if (rc == 0) {
  … // SELinux is not enabled
} else if (rc == -1) {
  … // Could not check SELinux state (call failed)
} else {
  … // SELinux is enabled
};</pre></div></li><li class="listitem">Add a check to see whether SELinux is in permissive or enforcing mode. Of course, this check is only needed if SELinux is enabled:<div><pre class="programlisting">rc = security_getenforce();
if (rc == 0) {
  … // SELinux is in permissive mode
} else if (rc == 1) {
  … // SELinux is in enforcing mode
} else {
  … // Failed to query state
};</pre></div></li><li class="listitem">Build the application while linking with <code class="literal">libselinux</code>:<div><pre class="programlisting">
<strong>~# gcc -o test -DSELINUX -lselinux test.c</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec226"/>How it works…</h2></div></div></div><p>The <code class="literal">libselinux</code> library<a id="id664" class="indexterm"/> provides all needed functions for applications to query SELinux and interact with the SELinux subsystem. Of course, when developing applications, it remains important that SELinux support is a compile-time optional choice: not all Linux systems have SELinux enabled, so if the application is by default linked with <code class="literal">libselinux</code>, then all target systems would need to install the necessary dependencies.</p><p>But even applications that are linked with <code class="literal">libselinux</code> must be able to support systems where SELinux has been disabled; hence, the need to check the state of SELinux using <code class="literal">is_selinux_enabled()</code>.</p><p>However, this <code class="literal">is_selinux_enabled()</code> function does not return any other information (such as <a id="id665" class="indexterm"/>which policy is loaded). To check if SELinux is running in <a id="id666" class="indexterm"/>permissive mode, the call to <code class="literal">security_getenforce()</code> can be used.</p><p>A well-defined application should use this state as well to adjust its behavior: if the application is running in permissive mode, then it should try not to enforce SELinux policy-related decisions in its application logic.</p><p>To refer to the cron example from an earlier recipe: if the crontab file context is not known as an entrypoint for the selected domain, then the application should log that this is not the case, but still continue working (as the mode is set in permissive mode). Sadly, most SELinux-aware applications do not change their behavior based on the permissive state of SELinux and can still fail (or follow a different logic) as if SELinux is in the enforcing state.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec227"/>There's more...</h2></div></div></div><p>There are other similar methods available that can be used to query the SELinux state.</p><p>The <code class="literal">is_selinux_mls_enabled()</code> method, for instance, returns a value indicating whether <a id="id667" class="indexterm"/>SELinux is running with MLS or not. This is useful as some context-related methods require level information if MLS is enabled, so querying the state and changing the method calls depending on the MLS state might be necessary.</p><p>A similar function to <code class="literal">security_getenforce()</code> is <code class="literal">security_setenforce()</code>. As can be deduced from the name, this allows applications to toggle the enforcing mode of SELinux. Of course, this is only possible if the domain in which the application runs has the proper SELinux permissions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec93"/>Querying SELinux userland configuration in C</h1></div></div></div><p>In<a id="id668" class="indexterm"/> this <a id="id669" class="indexterm"/>recipe, we will be querying the SELinux userland to obtain the default context for a given user based on the context of the current process. The process is responsible for gathering the Linux username of the user upfront.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec228"/>How to do it…</h2></div></div></div><p>Query the SELinux configuration as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the current context of the process:<div><pre class="programlisting">char * curcon = 0;
rc = getcon(&amp;curcon);
if (rc) {
  … // Getting context failed
  if (permissive) {
    … // Continue with the application logic, ignoring SELinux stuff
  } else {
    … // Log failure and stop application logic
  };
};</pre></div></li><li class="listitem">Take the Linux username (assumed to be in the <code class="literal">name</code> variable) and get the SELinux user:<div><pre class="programlisting">char * sename = 0;
char * selevel = 0;
rc = getseuserbyname(name, &amp;sename, &amp;selevel);
if (rc) {
  … // Call failed. Again check permissive state
  … // and take appropriate action.
  freecon(curcon);
};</pre></div></li><li class="listitem">Now, get the default context based on the obtained SELinux user (<code class="literal">sename</code>) and current context (which is handled by the method itself through the <code class="literal">NULL</code> variable):<div><pre class="programlisting">char * newcon = 0;
rc = get_default_context(sename, NULL, &amp;newcon);
if (rc) {
  … // Call failed. Again check permissive state
  … // and take appropriate action.
  freecon(curcon);
};</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec229"/>How it works…</h2></div></div></div><p>In the <a id="id670" class="indexterm"/>first block, the current process context is obtained using the <code class="literal">getcon()</code> method. For the end result of this recipe, getting the current context explicitly isn't necessary—the <code class="literal">get_default_context()</code> method that is invoked later will base its decision on the current context anyway (through the second parameter, which is <code class="literal">NULL</code> in this recipe). However, having the current context known is important for logging purposes as well as to query the SELinux policy itself (as we will do in the next recipe).</p><p>The next <a id="id671" class="indexterm"/>step<a id="id672" class="indexterm"/> is to obtain the SELinux user given a Linux user. The <code class="literal">sename</code> (SELinux user) and <code class="literal">selevel</code> (SELinux sensitivity) variables are filled in by the <code class="literal">getseuserbyname()</code> method, given the Linux username (which is a regular <code class="literal">char *</code> variable).</p><p>Finally, with the SELinux user now available, <code class="literal">get_default_context()</code> is invoked to get the default context stored into the third parameter (<code class="literal">newcon</code>). If we would need to get the default context from a different context than the current one, then instead of <code class="literal">NULL</code>, the second parameter should be the context to query for:</p><div><pre class="programlisting">rc = get_default_context(sename, curcon, &amp;newcon);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec230"/>There's more...</h2></div></div></div><p>Some other methods might be interesting to use in SELinux-aware applications.</p><p>The <code class="literal">getprevcon()</code> method, for<a id="id673" class="indexterm"/> instance, returns the previous context rather than the current context of the process. This previous context is usually the context of the parent process, although with applications that can perform dynamic transitions, this can be the previous context of the current process as well.</p><p>This information can also be obtained from the <code class="literal">/proc/</code> filesystem, in the process's <code class="literal">attr/</code> subdirectory in which the <code class="literal">current</code> and <code class="literal">prev</code> files can be checked:</p><div><pre class="programlisting">
<strong>~$ id -Z</strong>
<strong>staff_u:staff_r:staff_t:s0</strong>
<strong>~$ newrole -r sysadm_r</strong>
<strong>Password: </strong>
<strong>~$ id -Z</strong>
<strong>staff_u:sysadm_r:sysadm_t:s0</strong>
<strong>~$ cat /proc/$$/attr/current</strong>
<strong>staff_u:sysadm_r:sysadm_t:s0</strong>
<strong>~$ cat /proc/$$/attr/prev</strong>
<strong>staff_u:staff_r:newrole_t:s0</strong>
</pre></div><p>As can be seen, after running <code class="literal">newrole</code> to switch roles, the last domain that the process was in was the <code class="literal">newrole_t</code> domain (which then performed a domain and role transition to the current context).</p><p>Applications that are allowed to perform dynamic transitions (that is, without launching new commands) can <a id="id674" class="indexterm"/>use the <code class="literal">setcon()</code> method to switch from the current context to a new context.</p><p>The<a id="id675" class="indexterm"/> <code class="literal">get_default_context()</code> method is also part of a larger family of methods. For instance, when the user has multiple roles assigned, there<a id="id676" class="indexterm"/> can be multiple contexts allowed for a particular transition. The <code class="literal">get_ordered_context_list()</code> method returns the list of contexts that are supported (whereas the <code class="literal">get_default_context()</code> method only <a id="id677" class="indexterm"/>returns the first). One can filter out specific contexts by providing the role with the <code class="literal">get_ordered_context_list_with_role()</code> method.</p><p>On <a id="id678" class="indexterm"/>MLS-enabled systems, <code class="literal">get_default_context_with_level()</code> or <code class="literal">get_default_context_with_rolelevel()</code> will apply a specified level to the resulting context as well.</p><p>Another<a id="id679" class="indexterm"/> method that is available is the <code class="literal">get_default_type()</code> method, which returns the default type for a given role. As with the other methods, this results in the SELinux code to query configuration files inside <code class="literal">/etc/selinux/</code>; in this particular case, the <code class="literal">default_type</code> file inside <code class="literal">/etc/selinux/mcs/contexts/</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec94"/>Interrogating the SELinux subsystem code-wise</h1></div></div></div><p>In <a id="id680" class="indexterm"/>order to query the SELinux policy, we have seen the use of the <code class="literal">sesearch</code> command and other SELinux utilities. Code-wise, SELinux policies can be queried using the <code class="literal">security_compute_av_flags</code> method.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec231"/>Getting ready</h2></div></div></div><p>The <code class="literal">curcon</code> and <code class="literal">newcon</code> variables can be filled in through methods such as <code class="literal">getcon()</code> (for the current context) or <code class="literal">get_default_context()</code> as we have seen in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec232"/>How to do it…</h2></div></div></div><p>As an example, we want to query the transition permission between two process domains. To accomplish this, the following method is used:</p><div><ol class="orderedlist arabic"><li class="listitem">First of all, call the <code class="literal">security_compute_av_flags()</code> method:<div><pre class="programlisting">struct av_decision avd;
rc = security_compute_av_flags(curcon, newcon, SECCLASS_PROCESS, PROCESS__TRANSITION, &amp;avd);
if (rc) {
  … // Method failed.
  freecon(curcon);
  freecon(newcon);
};</pre></div></li><li class="listitem">Now read the response:<div><pre class="programlisting">if (!(avd.allowed &amp; PROCESS__TRANSITION)) {
  … // Transition is denied
};</pre></div></li><li class="listitem">Check whether the current context is a permissive domain or not:<div><pre class="programlisting">if (avd.flags &amp; SELINUX_AVD_FLAGS_PERMISSIVE) {
  … // Domain is permissive
};</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec233"/>How it works…</h2></div></div></div><p>The <code class="literal">security_compute_av_flags()</code> method is the C method equivalent of <code class="literal">sesearch</code> (roughly speaking). It takes the source and target context, class, and permission and stores the result of the query in a specific structure (<code class="literal">struct av_decision</code>).</p><p>The <a id="id681" class="indexterm"/>class and permission entries can be obtained from the <code class="literal">flask.h</code> (for the class declarations) and the <code class="literal">av_permissions.h</code> (for the permission declarations) header files that are located inside <code class="literal">/usr/include/selinux/</code>.</p><p>The result of the query is obtained by checking whether the permission is in the decision result.</p><p>Next to the permission query, an important aspect to validate (and which is often forgotten by SELinux-aware applications) is to check whether the domain itself is marked as permissive. After all, even on an SELinux-enabled system, where SELinux is in enforcing mode, some domains can still be marked as permissive.</p><p>The <code class="literal">SELINUX_AVD_FLAGS_PERMISSIVE</code> flag is<a id="id682" class="indexterm"/> a flag added to the query response (<code class="literal">struct av_decision</code>), which allows developers to query the permissive state of domains. With this information at hand, the SELinux-aware application can still decide to continue even if the policy denies a certain activity, just as the user has requested.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec234"/>There's more...</h2></div></div></div><p>There<a id="id683" class="indexterm"/> are other methods available as well to query the SELinux policy that might be used by SELinux-aware applications.</p><p>With <code class="literal">selinux_check_access()</code>, for instance, applications can query the SELinux policy to see if a given source context has the access permission for a given class and permission on the target context. This is not the same as <code class="literal">security_compute_av_flags()</code>, as this method uses strings for the class and permission, and also has a different return based on the enforcing state of SELinux or the permissive nature of a particular domain.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec95"/>Running new processes in a new context</h1></div></div></div><p>Sometimes, it isn't possible to force a particular domain upon invocation of a new task or process. The <a id="id684" class="indexterm"/>default transition rules that can be enabled <a id="id685" class="indexterm"/>through the SELinux policy are only applicable if the source domain and file context (of the application or task to execute) are unambiguously decisive for the target context.</p><p>In applications that can run the same command (or execute commands with the same context) for different target domains, SELinux-awareness is a must.</p><p>This recipe will show how to force a particular domain for a new process.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec235"/>Getting ready</h2></div></div></div><p>The <code class="literal">newcon</code> variable that is used in this recipe can be filled in through methods such as <code class="literal">get_default_context()</code> as we have seen in a previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec236"/>How to do it…</h2></div></div></div><p>To launch a process in a specific context, go through the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Tell SELinux what the new context should be:<div><pre class="programlisting">int rc = setexeccon(newcon);
if (rc) {
  … // Call failed
  freecon(newcon);
};</pre></div></li><li class="listitem">Fork and execute the command. For instance, to execute <code class="literal">id -Z</code>, the following code is used:<div><pre class="programlisting">pid_t child;
child = fork();
if (child &lt; 0) {
  … // Fork failed } else if (child == 0) {
  int pidrc;
  pidrc = execl("/usr/bin/id", "id", "-Z", NULL);
  if (pidrc != 0) {
    … // Command failed
  };
} else {
  … // Parent process
  int status;
  wait(&amp;status);
};</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec237"/>How it works…</h2></div></div></div><p>Applications that want newly executed tasks to run in a particular context need to tell the SELinux subsystem that the next <code class="literal">execve</code>, <code class="literal">execl</code>, or other <code class="literal">exec*</code> method should result in the child process running in the new domain.</p><p>Of course, the SELinux policy must still allow the transition policy-wise, even though there is<a id="id686" class="indexterm"/> no more need for an automatic domain transition in<a id="id687" class="indexterm"/> the policy (as this would require an unambiguous decision, which is exactly what isn't possible if the source domain and file context are the same for different target contexts):</p><div><pre class="programlisting">allow crond_t self : process setexec;
allow crond_t staff_t : process transition;</pre></div><p>The <code class="literal">setexec</code> permission allows<a id="id688" class="indexterm"/> the source domain to explicitly tell the SELinux subsystem what context the task should run in. Without this permission, the call to <code class="literal">setexeccon()</code> would fail.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec238"/>There's more...</h2></div></div></div><p>The <code class="literal">setexeccon()</code> method has a sibling method called <code class="literal">getexeccon()</code>. This method returns <a id="id689" class="indexterm"/>the context that would be assigned when executing a new process (which would provide a validation of the last <code class="literal">setexeccon()</code> call).</p><p>Another<a id="id690" class="indexterm"/> similar method is the <code class="literal">setexecfilecon()</code> method. This method allows SELinux-aware applications to take the SELinux policy decisions into account in case of file-based transition information. So, if there is a domain transition known when executing a particular file, then this domain transition is honored. If not, the fallback type provided through the <code class="literal">setexecfilecon()</code> method is used:</p><div><pre class="programlisting">char * fallbackcon = "system_u:object_r:openscap_helper_script_t:s0";
char * filename = "/usr/libexec/openscap/probe_process";
…rc = setexecfilecon(filename, fallbackcon);</pre></div><p>In this<a id="id691" class="indexterm"/> example, if the context of the <code class="literal">probe_process</code> file is used in the SELinux policy to create an automatic domain transition <a id="id692" class="indexterm"/>upon invocation by the current application, then that target domain is used for the application execution. However, if the context of the <code class="literal">probe_process</code> file is the one that does not trigger any automatic domain transition, then the <code class="literal">fallbackcon</code> context is used for the next application execution.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec96"/>Reading the context of a resource</h1></div></div></div><p>It is, of <a id="id693" class="indexterm"/>course, also important to obtain the context of a resource if the application is SELinux-aware. This could be for logging purposes or to decide which domain to transition to (based on the resource context, current context, username, and so on).</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec239"/>How to do it…</h2></div></div></div><p>To read the context of a resource, the following methods are available:</p><div><ol class="orderedlist arabic"><li class="listitem">Given a file path, the following call to <code class="literal">getfilecon()</code> will provide the context of the file:<div><pre class="programlisting">security_context_t filecon = 0;
char * path = "/etc/passwd";
rc = getfilecon(path, &amp;filecon);
if (rc &lt; 0) {
  … // Call failed
};
… // Do stuff with the context
freecon(filecon);</pre></div></li><li class="listitem">To get the context of a process, assuming the <code class="literal">pid</code> variable (of the <code class="literal">pid_t</code> type) has the proper process ID in it, the following code is used:<div><pre class="programlisting">security_context_t pidcon = 0;
rc = getpidcon(pid, &amp;pidcon);
if (rc &lt; 0) {
  … // Call failed
};
… // Do stuff with the context
freecon(pidcon);</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec240"/>How it works…</h2></div></div></div><p>The SELinux library has various methods for obtaining the contexts of resources. File and process types are shown in the recipe, but other methods exist as well. For instance, with <a id="id694" class="indexterm"/>the <code class="literal">fgetfilecon()</code> method, the context of a file descriptor can be obtained. All these methods provide the context in a standard string (<code class="literal">char *</code>) format.</p><p>After getting the context of a resource, it is important to free the context when it is no longer used. Otherwise, a memory leak will occur in the application as there are no other methods that will clean up the contexts.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec241"/>There's more...</h2></div></div></div><p>When labeled networking is used (for instance, with CIPSO/NetLabel support or labeled IPSec), then <a id="id695" class="indexterm"/>the <code class="literal">getpeercon()</code> method can be used to obtain the context of the peer that participates in the communication session.</p><p>Alongside<a id="id696" class="indexterm"/> querying the context, it is also possible to tell the SELinux subsystem that file creation should result in that file being created immediately with a particular context. For this, the <code class="literal">setfscreatecon()</code> method can be used—this is also <a id="id697" class="indexterm"/>the method that recent udev versions use when creating new device files in <code class="literal">/dev/</code>.</p></div></div></body></html>