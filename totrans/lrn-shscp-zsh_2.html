<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Alias and History</h1></div></div></div><p>In this chapter, we'll expand on the basics of zsh while focusing on aliases, one of the most time-saving features available. We'll take a closer look at how aliases work and learn to replace long, boring commands with our own short versions and automate the whole process within the startup files. We'll then move on to brace expansion, in order to avoid typing extra keystrokes whenever we can. Instead of typing the same things over again, we'll learn how to work with zsh's history and history expansion mechanisms and incorporate these new features into our workflow.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Working with aliases</h1></div></div></div><p>An <em>alias</em><a class="indexterm" id="id44"/> is an alternative way of saying the same thing. Think of it as a<a class="indexterm" id="id45"/> nickname for your commands. Though, unlike the embarrassing nicknames that you might get after a party, the alias mechanism provided by your shell is a handy shortcut to a series of commands and options under a friendlier name. The whole point of an alias is to do more and, preferably, type less.</p><p>I bet I got your attention with that last "type less" part. Allow me to explain:</p><p>The <code class="literal">ls</code> command lists a directory's contents. A quick look at its manpage (<code class="literal">man ls</code>) tells us that there are quite a few options there:</p><div><pre class="programlisting">ls -a # lists all files, even those hidden that start with a dot
ls -l # shows more information for each file, like size and permissions</pre></div><p>Using aliases we can go ahead and do something like the following:</p><div><pre class="programlisting">
<strong>% alias la='ls -a'</strong>
</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>No spaces are allowed around the equals (<code class="literal">=</code>) sign. If the right-hand side of the assignment (that is, the part that comes after the equals) contains spaces or tabs, then make sure you use quotation marks around it as follows:</p><div><pre class="programlisting">% alias talk='echo "quack!"'
% talk
&gt; quack!</pre></div></div></div><p>Now guess what<a class="indexterm" id="id46"/> happens if you type <code class="literal">la</code>? Go ahead and try it. The shell reads your alias—<code class="literal">la</code> in this particular case—and expands it. The whole process is similar to looking up the meaning of a word in the dictionary. Although here, once it's been found, the meaning is executed.</p><p>We can do basically the same for the <code class="literal">-l</code> option:</p><div><pre class="programlisting">
<strong>% alias ll='ls -l'</strong>
</pre></div><p>Or even mix and match as shown in the following line:</p><div><pre class="programlisting">
<strong>% alias lla='ls -laF' </strong>
</pre></div><p>That last snippet uses both the <code class="literal">l</code> and <code class="literal">a</code> flags together with <code class="literal">F</code>, meaning it behaves just the same as the <code class="literal">–la</code> switch, with the added option to format the output so as to easily tell files and folders apart.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Aliases apply only to interactive shells. Your shell will disable all of your existing aliases if it's being run in the non-interactive mode. Keep this in mind when creating your scripts.</p></div></div><p>You have two ways of declaring an alias. The first one is straight from the command line, as we have been doing so far. This nets you an alias which you can use instantly; the downside is that changes are only present temporarily for the duration of your current session. Close your terminal emulator or log out of the system and it goes the way of the dodo. The basic syntax for declaring an alias is as follows:</p><div><pre class="programlisting">
<strong>alias [shortname]=&lt;longname or command(s)&gt;</strong>
</pre></div><p>You can use this approach for something you'll be typing a lot but won't come back to it later. Most of the time though, we'll need something a bit more resilient. Something we can use every time we work with the command line.</p><p>Enter the startup files; if you recall from the previous chapter, startup files are read every time the shell starts, and its configuration is loaded for the current session. Kind of what the doctor recommended.</p><p>Let's open up your <code class="literal">.zshrc</code> then, and add the aliases we've been working on so far:</p><div><pre class="programlisting">
<strong># put this on your .zshrc</strong>
<strong>alias la='ls -aF'</strong>
<strong>alias ll='ls -lF'</strong>
<strong>alias lla='ls -laF'</strong>
</pre></div><p>Save your changes, <code class="literal">source</code> (or use its alias, the dot (<code class="literal">.</code>)) your file, and aliases will be set for you to use on every future session of the shell. Despite their different behavior, both the ways of alias declaration sport the same syntax.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Quoting characters</h2></div></div></div><p>Any given <a class="indexterm" id="id47"/>character can be quoted by adding a <code class="literal">\</code> character in front of it. This is particularly useful when dealing with "special characters" which have an additional meaning, such as <code class="literal">$</code>, and even an actual <code class="literal">\</code> character. Take, for example, the following <code class="literal">echo</code> sentence:</p><div><pre class="programlisting">
<strong># this is wrong!</strong>
<strong>% echo 'that's a quoted sentence for you'</strong>
<strong>quote&gt;</strong>
</pre></div><p>The shell prompt indicates it's waiting for a quote character to be (properly) closed. The problem here is that we did not properly escape the apostrophe on "that's":</p><div><pre class="programlisting">
<strong>% echo 'that\'s a quoted sentence for you'</strong>
<strong>&gt; that's a quoted sentence for you</strong>
</pre></div><p>That's all nice and working, but what happens when we have a great number of escaping to do?</p><div><pre class="programlisting">
<strong>% echo 'Escaping single quotes like this \' with backslashes \\ is really tedious'</strong>
<strong>&gt; Escaping single quotes like this ' with backslashes \ is really tedious</strong>
</pre></div><p>Luckily, zsh provides the <code class="literal">RCQUOTES</code> option as a workaround, which allows you to use double single quotes (<code class="literal">''</code>) for escaping:</p><div><pre class="programlisting">
<strong>% setopt rcquotes</strong>
<strong>% echo 'Look ma'' I''m escapin'' single quotes'</strong>
<strong>&gt; Look ma' I'm escapin' single quotes</strong>
</pre></div><p>What about double quotes then? Well, these are truly special and out of the bunch, as they allow you to perform parameter and command substitution as we'll see in no time. What you have to remember when using double quotes is that either <code class="literal">"</code>, <code class="literal">\</code>, <code class="literal">$</code>, and <code class="literal">`</code> characters need to be escaped with a backslash.</p><p>Let's give double quotes a try:</p><div><pre class="programlisting">
<strong>% echo "'echo \"\$HOME\"' will print out '$HOME'"</strong>
<strong>&gt; 'echo "$HOME"' will print out '/Users/gfestari'</strong>
</pre></div><p>In the preceding example, the <code class="literal">$HOME</code> environment variable gets replaced by the actual value (<code class="literal">/Users/gfestari</code>) when the <code class="literal">$</code> character is not quoted.</p><p>You can also use backquote within double quotes for executing programs:</p><div><pre class="programlisting">
<strong>% echo "zshenv is located at: `locate zshenv`"</strong>
<strong>&gt; zshenv is located at: /etc/zshenv</strong>
</pre></div><p>The shell will <a class="indexterm" id="id48"/>first execute <code class="literal">locate zshenv</code> as if it were any other command, and substitute its output within the parameters being passed to <code class="literal">echo</code>.</p><p>As you can see, you can work around single quotes' limitations for most day-to-day usage, and turn to double quotes, escape sequences, and parameter expansions whenever you have a particular need for doing so.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Single and double quoting aliases</h2></div></div></div><p>Single quotes<a class="indexterm" id="id49"/> (<code class="literal">'</code>) are required when using spaces on your alias assignments; nevertheless, it's generally advisable to use them regardless of the spaces on your right-hand side. Granted, this is a "just to be safe" approach, but trust me when I say it will save <a class="indexterm" id="id50"/>you from a couple of avoidable headaches when declaring your aliases.</p><p>On the other hand, if you wish to use things such as environment variables or parameter substitution within your assignment expression (think of the prompt escape sequences we saw in the previous chapter), <a class="indexterm" id="id51"/>double quotes (<code class="literal">"</code>) are required instead. Imagine you wish to output the current user's name with an alias. As we saw earlier, the direct way of accessing it is via the environment variable <code class="literal">$USERNAME</code>. The first thing that comes to mind then is to use the following alias:</p><div><pre class="programlisting">
<strong># This is wrong!</strong>
<strong>alias saymyname='echo $USERNAME'</strong>
</pre></div><p>Unfortunately, this won't work with single quotes. The correct way of doing this is with double quotation marks as follows:</p><div><pre class="programlisting">
<strong>% alias saymyname="echo $USERNAME"</strong>
<strong>% saymyname</strong>
<strong>&gt; gfestari</strong>
</pre></div><p>Complex expressions <a class="indexterm" id="id52"/>with variables generally need to be quoted, we use single quotation marks for that. If your alias requires variables to be expanded before the alias is used, go with double quotes.</p><p>As you can see, the <code class="literal">alias</code> mechanism is indeed a nifty powerful feature. If used properly, it even allows you to reshape a command's meaning:</p><div><pre class="programlisting">
<strong>% alias ls='ls --color=auto'</strong>
</pre></div><p>Or its equivalent on OS X:</p><div><pre class="programlisting">
<strong>% alias ls='ls –G'</strong>
</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>You can define aliases from another alias. Following the preceding example, if you do the following:</p><div><pre class="programlisting">alias ls='ls --color=auto'
alias la='ls -a'</pre></div><p>The <code class="literal">la</code> alias will behave just as if you typed <code class="literal">ls --color=auto –a</code>, there's no need to type <code class="literal">--color=auto</code> again on your definition.</p></div></div><p>This alias alters the behavior of <code class="literal">ls</code> by calling it with the <code class="literal">color</code> flag every time you type it, instead of using its more vanilla version. While this comes in handy for this particular scenario, it can be really dangerous for commands such as <code class="literal">rm</code> if not used with caution.</p><p>For example, imagine what would happen if you aliased a force removal of files to <code class="literal">rm</code>:</p><div><pre class="programlisting">
<strong># Be careful when doing things like this!</strong>
<strong>alias rm='rm -f'</strong>
</pre></div><p>Here you are forcing the <a class="indexterm" id="id53"/>deletion of files without a warning. What will happen is that someone, unknowingly, will execute the wrong command and end up bashing their heads on the keyboard after a mistaken deletion. The takeaway message here is that the further you stay from overriding an existing command with your "l33t alias", the better. Think of all those broken keyboards. Don't be that guy.</p><p>So, what if you don't know whether you are bypassing any of the aliases' current set for your session? Well, there's a command for that. Typing <code class="literal">alias</code> will list all the aliases for the current session:</p><div><pre class="programlisting">
<strong>% alias</strong>
<strong>&gt; la='ls -aF'</strong>
<strong>ll='ls -lF'</strong>
<strong>lla='ls -laF'</strong>
<strong>saymyname="echo $USERNAME"</strong>
</pre></div><p>You can also get the information for a particular alias simply by specifying its name, as follows:</p><div><pre class="programlisting">
<strong>% alias la</strong>
<strong>&gt; la='ls -aF' </strong>
</pre></div><p>And you can disable, albeit temporarily, any existing alias by typing:</p><div><pre class="programlisting">
<strong>% unalias &lt;aliasname&gt;</strong>
</pre></div><p>Simply replace <code class="literal">aliasname</code> with the name of the alias you want to turn off. This comes in really handy on those occasions when you're using a particularly strict program whose options, or even command-line syntax, is overridden by an alias.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>There are a few ways by which you can prevent the shell from executing an alias that is called just as another command. Single-quoted commands and commands prepended with a backslash (<code class="literal">\</code>) as well as those typed as relative or absolute paths are not treated as aliases by the shell.</p><p>For example, you could use either of the following if you wish to avoid a call to an alias:</p><div><pre class="programlisting">% 'ls'
% \ls</pre></div><p>or even:</p><div><pre class="programlisting">% /usr/bin/ls</pre></div><p>Zsh also has <code class="literal">command</code> that will execute any argument as an external command instead of as a function or built in. Thus, you can also use it to avoid aliases. That would leave us with the following for the preceding example:</p><div><pre class="programlisting">% command ls</pre></div><p>You can get more information via <code class="literal">man zshbuiltins</code>.</p></div></div><p>As with many other<a class="indexterm" id="id54"/> things we'll be discovering throughout this book, <a class="indexterm" id="id55"/>an alias is not a golden hammer and as such, you shouldn't be aliasing willy-nilly throughout your terminal sessions. Here are a few simple considerations to keep in mind before you embark into your less-typing adventure with your pack o'aliases:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Is my alias easier to remember? <code class="literal">echo -n</code> is way simpler than aliasing something like <code class="literal">echodontprinttrail</code>. Keep it simple, don't use aliases for the sake of it. The "Future You" will be really thankful two months from now.</li><li class="listitem" style="list-style-type: disc">Is my alias easier to type? An awkward alias is an awful alias. Using <code class="literal">alias grepcola='grep --color=auto'</code> instead of a simpler <code class="literal">grep</code>, really? Remember: clear, concise names are awesome, but something you can't remember for the life of <code class="literal">ping</code> is not cool.</li><li class="listitem" style="list-style-type: disc">Is my alias overriding some behavior just for the sake of it? Think of the previous <code class="literal">rm -f</code> example. Most of the time we would like to stay away from something like that; however, prompting the user each time seems like a sensible feature to add to our toolbox. Aliasing <code class="literal">rm='rm -i'</code> so the shell requires confirmation before deleting something seems a bit... nicer. Be careful with these kinds of tricks though, as relying too much on such an alias could lead to a false sense of security. That is, imagine what would happen if you get used to <code class="literal">rm</code> constantly waiting for confirmation and eventually use it recklessly on a different environment?</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Global aliases</h2></div></div></div><p>If you enjoyed <a class="indexterm" id="id56"/>the simplicity aliases brought to the table, then global aliases<a class="indexterm" id="id57"/> are the icing on the cake. As the name implies, <em>global aliases</em> are, well, aliases that can be used anywhere, allowing you to treat filters or certain commands as a simple suffix.</p><p>Let's see some examples:</p><div><pre class="programlisting">
<strong>alias -g L='|less'</strong>
</pre></div><p>Pay particular attention to the <code class="literal">-g</code> option, as in a global alias.</p><p>Now you can append the <code class="literal">less</code> pager to any command's output, just by adding the <code class="literal">L</code> suffix:</p><div><pre class="programlisting">
<strong>% ls -la /etc L</strong>
</pre></div><p>Another option that is frequently spotted in the wild is redirecting standard error (<code class="literal">stderr</code>) and standard output (<code class="literal">stdout</code>) to <code class="literal">/dev/null</code>, so any given command can run silently:</p><div><pre class="programlisting">
<strong>alias -g NUL="&gt; /dev/null 2&gt;&amp;1"</strong>
</pre></div><p>This will allow you to call things such as <code class="literal">command NUL</code> without the need to pollute your current terminal window with thousands of log lines and messages.</p><p>Just for the sake of clarity, never mind sticking to standards, it's advisable for you to try and define your global aliases just like your global variables, all in caps.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Hashes</h2></div></div></div><p>You <a class="indexterm" id="id58"/>can use a <a class="indexterm" id="id59"/>hash to give a particular directory an alias. This is particularly convenient for your workspace:</p><div><pre class="programlisting">
<strong>% echo $GOPATH</strong>
<strong>&gt; /Users/gfestari/workspace/go</strong>
</pre></div><p>I don't want to type <code class="literal">/Users/gfestari/workspace/go</code> each time I want to reach the <code class="literal">src</code> folder in my <code class="literal">$GOPATH</code> directory. So how about putting hash to a good use?</p><div><pre class="programlisting">
<strong>% hash -d gosrc=$HOME/go/src</strong>
</pre></div><p>And now we can get there as quick as typing <code class="literal">cd ~gosrc</code> (pay attention to the leading <code class="literal">~</code> character).</p><p>Here's another example, this time using the <code class="literal">/var/www</code> directory:</p><div><pre class="programlisting">
<strong>% hash -d www=/var/www</strong>
<strong>% cd ~www</strong>
<strong>/var/www</strong>
</pre></div><p>You can go ahead and hash your most frequently visited directories. Just remember to add the required entries to your <code class="literal">.zshrc</code>, so you don't have to type the same thing over and over again.</p><p>For bonus <a class="indexterm" id="id60"/>points, set the <code class="literal">AUTO_CD</code> option, so you only need to input the directory's name whenever you want to change the working directories:</p><div><pre class="programlisting">
<strong>% setopt autocd</strong>
<strong>% ~www</strong>
<strong>&gt; /var/www</strong>
</pre></div><p>Now go ahead and start showing off with your acquaintances, I'll wait here.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Putting it all together</h2></div></div></div><p>Before we move on to the next topic, here's a couple of things to try with our newly found aliases.</p><p>Raise your hand if you found yourself typing <code class="literal">cd ..</code> more than a few times on a terminal session. I know, I feel your pain. How about making it simpler?</p><p>We could try the following instead:</p><div><pre class="programlisting">
<strong>% alias ..='cd ..'</strong>
</pre></div><p>Now it's just a matter of typing <code class="literal">.</code> to move your current working directory up one level<code class="literal">.</code> Not bad, uh? We can take it a bit further:</p><div><pre class="programlisting">
<strong>alias ...='cd ../..'</strong>
<strong>alias ....='cd ../../..'</strong>
</pre></div><p>I'd argue that going more levels in for directory changing is pushing things a bit too far, but feel free to extend your aliases as you see fit.</p><p>What about creating directories? I bet that, like myself, more than once you saw the following:</p><div><pre class="programlisting">
<strong>% mkdir dir1/dir2</strong>
<strong>&gt; mkdir: dir1: no such file or directory</strong>
</pre></div><p>This happens because <code class="literal">dir1</code> doesn't exist. So what we do is—you guessed it—create an alias that allows us to automatically create the <em>parent</em> directory and also, be more verbose (as in, "list directories as they are created") about the output:</p><div><pre class="programlisting">
<strong>alias mkdir='mkdir -pv'</strong>
</pre></div><p>Now try to issue <code class="literal">mkdir dir1/dir2</code> and see what happens. You can also apply the same switch to commands such as <code class="literal">cp</code> and <code class="literal">mv</code>, just remember to quote your assignments!</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>You can use the <code class="literal">COMPLETE_ALIASES</code> option in your startup files in order to force the shell to treat aliases as a distinct command for completion purposes. In other words, the alias won't get substituted before attempting completion.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Expansion</h1></div></div></div><p>The shell <a class="indexterm" id="id61"/>allows<a class="indexterm" id="id62"/> you to perform different types of manipulations right before executing a line. In the following section we'll learn how to take advantage of each of the different forms of expansion and substitution available in zsh.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Parameter expansion</h2></div></div></div><p>Parameter expansion <a class="indexterm" id="id63"/>allows you to replace known variables<a class="indexterm" id="id64"/> in between the assignments of the command line. Simply put, parameter substitution is the mechanism by which the shell can change the following:</p><div><pre class="programlisting">
<strong>% foo=Hello</strong>
</pre></div><p>It will be changed to the following:</p><div><pre class="programlisting">
<strong>% echo "${foo}, world!"</strong>
<strong>&gt; Hello, world!</strong>
</pre></div><p>Notice how the variable <code class="literal">foo</code> we declared in the previous line is replaced inside the arguments of <code class="literal">echo</code> with its actual value. You should be paying special attention to that peculiar <code class="literal">${}</code> construction. What happens is that when zsh reads the <code class="literal">${foo}</code> construction, it immediately knows it has to replace what's in it with whatever value it holds.</p><p>The astute reader might also have taken notice of the double quotes that surround the <code class="literal">echo</code> arguments. It's important to remember that just like aliases and prompt sequences, parameter substitution will work for arguments passed between double quotes, just like every other variable out there.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Command substitution</h2></div></div></div><p>Like parameter expansion, <a class="indexterm" id="id65"/>command substitution<a class="indexterm" id="id66"/> allows the shell to execute a command call and replace its output within a specially formed syntax. Command substitution usually takes the form of <code class="literal">`command`</code>, a program name wrapped around back quotes.</p><p>There's another form of program substitution available in newer shells such as zsh, which takes the form of <code class="literal">$(command)</code>. Both forms of substitution, <code class="literal">``</code> and <code class="literal">$()</code>, mean the same; however, back quotes are considered a bit more portable, as they are recognized on pretty much every other shell out there.</p><p>In the wild, <a class="indexterm" id="id67"/>command substitution is frequently used to find out the full path to a command:</p><div><pre class="programlisting">
<strong>% print $(which zsh)</strong>
<strong>/usr/local/bin/zsh</strong>
</pre></div><p>Or, to make it more portable:</p><div><pre class="programlisting">
<strong>% print `which zsh`</strong>
<strong>/usr/local/bin/zsh</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Arithmetic expansion</h2></div></div></div><p>Don't let the <a class="indexterm" id="id68"/>name discourage you; just like parameter <a class="indexterm" id="id69"/>substitution, arithmetic expansion is yet another form of substitution to help us sail swiftly across the command line. As its name implies, you can expand your input into a series of elements that will otherwise require you to type a lot.</p><p>Let's try it:</p><div><pre class="programlisting">
<strong>% echo $(( 5 + 4 ))</strong>
<strong>&gt; 9</strong>
</pre></div><p>We started with some rather simple arithmetic expression (I know, I know; Math). But fret not, what just happened can be easily explained. We already know <code class="literal">echo</code> prints information into the standard output, so there are no mysteries there. What follows it is just an arithmetic expression using the <code class="literal">$(( ))</code> construct. Notice that, unlike parameter substitution, this kind of arithmetic substitution requires an extra set of parentheses. This is our way of letting zsh know that it needs to work with numbers, and that's why our <code class="literal">5 + 4</code> is treated as such.</p><p>The same rules apply to the following:</p><div><pre class="programlisting">
<strong>% echo $(( 5 + 4 * 3 ))</strong>
<strong>&gt; 17</strong>
</pre></div><p>Which leads us to realize we need more parentheses for operator precedence:</p><div><pre class="programlisting">
<strong>% echo $(( (5 + 4) * 3 ))</strong>
<strong>&gt; 27</strong>
</pre></div><p>Remember, the <code class="literal">$(( ))</code> construct is just a special construct, it's what tells zsh to treat what resides inside as arithmetic expressions.</p><p>Interestingly, we can invite parameter substitution to this party too. Looks like variables can also be substituted inside arithmetic expressions:</p><div><pre class="programlisting">
<strong>% num=5+4</strong>
<strong>% echo $(( num * 3 ))</strong>
<strong>&gt; 27</strong>
</pre></div><p>In the preceding snippet,<a class="indexterm" id="id70"/> we declare a variable to hold our <code class="literal">5 + 4</code> expression; this makes <code class="literal">num</code> a container that, when asked what's up, will yell out our <code class="literal">5 + 4</code> expression. An easy way to check this is:</p><div><pre class="programlisting">
<strong>% echo ${num}</strong>
<strong>&gt; 5+4</strong>
</pre></div><p>Note however, <a class="indexterm" id="id71"/>that by using <code class="literal">num</code> in the expression we did not require an extra set of parentheses in order to set operator precedence. This is because our <code class="literal">num</code> variable gets replaced on the following line with its value, which leaves us with an expression equivalent to <code class="literal">(5 + 4) * 3</code>. Expressions get evaluated before they are replaced, otherwise the result of the preceding call would have been <code class="literal">17</code>.</p><p>Let's kick it up a notch with another handy arithmetic substitution:</p><div><pre class="programlisting">
<strong>% num=5+</strong>
<strong>% echo $(( $num 4 ))</strong>
<strong>&gt; 9</strong>
</pre></div><p>On this opportunity, we are leaving the <code class="literal">num</code> expression as something that resembles "add whatever follows to it". This is why when it is evaluated on the next line, it gets replaced for what you'd expect, in this case <code class="literal">5 +</code>. See that <code class="literal">$</code> right before the <code class="literal">num</code> variable? Remember parameter substitution from the beginning of this section? That's what's going on here. Without that <code class="literal">$num</code> there, zsh simply does not know how to deal with the <code class="literal">num</code> assignment:</p><div><pre class="programlisting">
<strong># This is horribly wrong!</strong>
<strong>% num=5+</strong>
<strong>% echo $(( num 4 ))</strong>
<strong>&gt; zsh: bad math expression: operator expected at `4 '</strong>
</pre></div><p>Remember, if you wish to substitute a parameter, use <code class="literal">$</code>:</p><div><pre class="programlisting">
<strong>% echo $(( $num 4 ))</strong>
</pre></div><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>You can always have a look at all supported types of expansions by typing <code class="literal">man zshexpn</code> on your console.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Brace expansion</h2></div></div></div><p>Another useful <a class="indexterm" id="id72"/>type of <a class="indexterm" id="id73"/>expansion is known as brace expansion. As the name implies, its syntax has to do with the use of curly braces (<code class="literal">{}</code>)—I suppose "curly brace expansion" was a bit too verbose when they were picking a name for it. Brace expansion allows you to declare an array of entries as follows:</p><div><pre class="programlisting">
<strong>% echo picture.jp{eg,g}</strong>
<strong>&gt; picture.jpeg picture.jpg</strong>
</pre></div><p>What happens then is <a class="indexterm" id="id74"/>that the <code class="literal">{eg,g}</code> construct gets expanded into an array containing the elements <code class="literal">eg</code> and <code class="literal">g</code>. The shell then loops through those elements, passing two arguments to the <code class="literal">echo</code> command, which basically has the same meaning as typing the following:</p><div><pre class="programlisting">
<strong>% echo picture.jpeg</strong>
<strong>% echo picture.jpg</strong>
</pre></div><p>But you saved <a class="indexterm" id="id75"/>yourself from quite a few keystrokes and the accompanying boredom. Let's try another example:</p><div><pre class="programlisting">
<strong>% touch log_00{1,2,3}.txt</strong>
<strong>% ls</strong>
<strong>&gt; log_001.txt  log_002.txt  log_003.txt</strong>
</pre></div><p>This time we are creating simple logfiles with the pattern <code class="literal">log_00&lt;num&gt;.txt</code>. The shell expands the <code class="literal">{1,2,3}</code> element into the elements <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>, and then calls the <code class="literal">touch</code> command three times:</p><div><pre class="programlisting">
<strong>% touch log_001.txt</strong>
<strong>% touch log_002.txt</strong>
<strong>% touch log_003.txt</strong>
</pre></div><p>In case you didn't notice, we use commas (<code class="literal">,</code>) in order to declare each of the elements inside curly braces. Now, you might be thinking "what happens when we use a longer array?" Here's when it gets even more interesting; declare a range of values:</p><div><pre class="programlisting">
<strong>% touch log_{007..011}.nfo</strong>
<strong>% ls | grep .nfo</strong>
<strong>log_007.nfo  log_008.nfo [...] log_010.nfo  log_011.nfo</strong>
</pre></div><p>It's worth noting a couple of things going on with the preceding example. I took the liberty to format the output of the list. But that (<code class="literal">…</code>) implies files <code class="literal">007</code> to <code class="literal">011</code> do exist. Firstly, we are now using brace expansion to extend a range, this time from nine up to eleven. The next thing that's also worth mentioning is that zsh is smart enough to notice the leading zeros and use it as a padding for the other values instead of replacing them with, say, vanilla integers. That is why you see the sequence starting with <code class="literal">log_007.nfo</code> and ending with <code class="literal">log_011.nfo</code>.</p><p>On the second line, we use a pipe symbol (<code class="literal">|</code>) to link or redirect output between different commands on your shell. This way we are listing the contents of the file, and redirecting the output into the utility <code class="literal">grep</code>, so we can filter said output by the <code class="literal">.nfo</code> extension.</p><p>Arrays can get even more interesting when we sparkle a bit more math in them:</p><div><pre class="programlisting">
<strong>% foo=(A B C)</strong>
<strong>% bar=(1 2 3)</strong>
<strong>% echo $^foo-$^bar</strong>
<strong>&gt; A-1 A-2 A-3 B-1 B-2 B-3 C-1 C-2 C-3</strong>
</pre></div><p>In the preceding snippet, we declare two arrays, one containing the elements <code class="literal">A</code>, <code class="literal">B</code>, and <code class="literal">C</code>, and the other with the <a class="indexterm" id="id76"/>elements <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code>. The call to <code class="literal">echo</code> then passes the <a class="indexterm" id="id77"/>argument <code class="literal">${^foo}-${^bar}</code>. Notice the <code class="literal">^</code> operator (curly braces were implicit on the previous call, so I added them here for the sake of clarity). Again, we are telling zsh to expand the variables that come after the <code class="literal">$</code> character, only this time we get a <strong>Cartesian product</strong><a class="indexterm" id="id78"/> instead of, say, <code class="literal">A B C-1 2 3</code>. This is because the <code class="literal">^</code> operator serves as the array expansion expression. So as far as zsh is concerned, we're using each element of the array independently.</p><p>For a more detailed description of how array expansion and the <code class="literal">^</code> operator works, visit <code class="literal">man zshoptions</code> (particularly, the <code class="literal">RC_EXPAND_PARAM</code> section) and <code class="literal">man zshexpn</code>.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>As with other sequences, some characters are considered "special" and need to be escaped. Commas and single quotes need to be escaped with a backslash:</p><div><pre class="programlisting">% echo \'{\,,\'}\'' needs to be escaped'
&gt; ',' needs to be escaped ''' needs to be escaped</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Working with history</h1></div></div></div><p>Like an elephant, <a class="indexterm" id="id79"/>many modern Unix shells tend to remember in great detail the copious amount of commands entered while working with them. As many others, zsh <a class="indexterm" id="id80"/>too boasts a history log and an even more convenient way of accessing each of its entries. Being able to glimpse at what you have been up to is not only practical from a work-log perspective, but also as a way to speed things up. Think about it; you could use <code class="literal">history</code> to see (and eventually edit) a previously typed command, get a bit of context as to what's going on with your system, or avoid retyping the same thing over and over. Being able to easily retrieve a command from the past sounds awesome, because it is indeed a really neat feature.</p><p>We'll now take a look at how to use zsh's history expansion to work with previous entries in the command line.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>
<strong>Working with history</strong>
</p><p>A more traditional approach to recalling history entries is by using the up arrow and down arrow keys on your keyboard to scroll through history entries. We'll have a closer look at how to alter this behavior when we examine the zsh line editor (ZLE) module in the next chapter. For now, we'll pretend that these are the only keys to move around history.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>History expansion</h2></div></div></div><p>One of the ways zsh provides<a class="indexterm" id="id81"/> for you to access your history is via the so-called history expansion. This works whenever your input begins with the bang <code class="literal">!</code> special character. As we saw in the previous chapter, the default behavior of the <code class="literal">!</code> character can be overridden by setting the <code class="literal">histchars</code> shell parameter to something different:</p><div><pre class="programlisting">
<strong>% set histchars='@^#'</strong>
</pre></div><p>Unlike other shells though, zsh <a class="indexterm" id="id82"/>accepts up to three parameters when setting <code class="literal">histchars</code>. In addition to expansion (changed to <code class="literal">@</code>), the other two are used for substitution (<code class="literal">^</code>) and comments (<code class="literal">#</code>) respectively.</p><p>By replacing the default bang (<code class="literal">!</code>) with the <code class="literal">@</code> character, you can now do things like calling your last executed command line as follows:</p><div><pre class="programlisting">
<strong>% ls *.txt</strong>
<strong>&gt; readme.txt notes.txt</strong>
<strong>% @@</strong>
<strong>% ls *.txt</strong>
<strong>&gt; readme.txt notes.txt</strong>
</pre></div><p>By redefining <code class="literal">histchars</code> you'll be able to use commands that actually require special characters such as <code class="literal">!</code> without the need to escape them or worry about history substitution. You can choose any combination that you want, but, as a rule of thumb, try to stick with the less frequently used characters so that it is actually worth the effort.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>History expansion will only work if you are running an interactive shell and the option <code class="literal">NO_BANG_HIST</code> is unset in your <code class="literal">.zshrc</code> file.</p></div></div><p>Accessing your history entries is done via what we call <em>event designators</em>. Like escape sequences, designators are fancy names for constructs that the shell expands in order to know exactly what needs to be retrieved from history. One of the most popular and helpful event designators is the double bang (<code class="literal">!!</code>), which by itself refers to the most recent command entered:</p><div><pre class="programlisting">
<strong>% sh myscript.sh</strong>
<strong>&gt; myscript.sh: Error: you need to be root to execute this.</strong>
<strong>% sudo !!</strong>
<strong>&gt; myscript.sh: executing myscript.sh</strong>
</pre></div><p>As you can see, the <code class="literal">!!</code> character can be really useful for those occasions when you forget to run something on elevated privileges. What happens then is that zsh immediately expands the reference to the last command in history and replaces it in the line that contains the <code class="literal">sudo</code> call, saving you from entering the whole line again.</p><p>Having the shell making <a class="indexterm" id="id83"/>substitutions and automatically executing commands demands a bit more "blind faith" than most of us would like to deposit on their shell. Luckily, we can set the <code class="literal">HIST_VERIFY</code> option in <code class="literal">.zshrc</code> to force zsh into asking for confirmation every time you bang a command:</p><div><pre class="programlisting">
<strong>% setopt HIST_VERIFY</strong>
<strong>% echo 'Hello!'</strong>
<strong>&gt; Hello!</strong>
<strong>% !!</strong>
<strong>% echo 'Hello!'</strong>
</pre></div><p>As you can see, the shell completes the input in your prompt using the previous command, but does not execute it. This is really useful for things like elevated privileges or sudo commands. Feel free to go ahead and add <code class="literal">setopt HIST_VERIFY</code> to your <code class="literal">.zshrc</code> file, as we'll assume it is being used from now on.</p><p>That's really neat for the command we just typed, but what if the previous command is further back in the history timeline? Well, then we need to use the vanilla event bang:</p><div><pre class="programlisting">
<strong>% !cat</strong>
<strong>% cat /etc/hosts | grep 127.0.1.1</strong>
</pre></div><p>Here my last executed command that had <code class="literal">cat</code> in it was a printout of my <code class="literal">hosts</code> file (<code class="literal">cat /etc/hosts</code>), followed by a call to <code class="literal">grep</code> as I was looking for lines that have <code class="literal">127.0.1.1</code> on them.</p><p>If you connect to a remote host using SSH, you could use something like the following to retrieve the last run connection:</p><div><pre class="programlisting">
<strong>% !ssh</strong>
<strong>% ssh gfestari@192.168.1.10</strong>
</pre></div><p>As you can see, the syntax for history expansion is fairly easy to remember. Just put a <code class="literal">!</code> character together with the command you're looking for and let zsh work its magic.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>
<em>Word designators</em> indicate the words of the command line that will be included in a history reference. What follows is a quick reference of the available designators:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">^</code>: The first argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$</code>: The last argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">%</code>: The most recent match for a given word.</li><li class="listitem" style="list-style-type: disc"><code class="literal">x-y</code>: A range of words. Negative indexes like <code class="literal">-i</code> mean <code class="literal">0-i</code>; thus, <code class="literal">-1</code> would mean "the penultimate entry".</li><li class="listitem" style="list-style-type: disc"><code class="literal">*</code>: All the arguments. Return null for events with just one word.</li></ul></div><p>Note that a <code class="literal">%</code> word designator will only work when used as <code class="literal">!%</code>, <code class="literal">!:%</code>, or <code class="literal">!?str?:%</code>; anything else and you will be greeted with an error.</p><p>For a more in-depth look at word designators and history expansion semantics, please refer to <code class="literal">man zshexpn</code>, particularly the section titled "HISTORY EXPANSION".</p></div></div><p>Let's kick it up a notch then; you can combine the special characters <code class="literal">^</code> and <code class="literal">$</code> in order to access the first and last arguments of a history entry respectively:</p><div><pre class="programlisting">
<strong>% mkdir new_folder</strong>
<strong>% cd !^</strong>
<strong>% cd new_folder</strong>
</pre></div><p>The <code class="literal">^</code> character gets <a class="indexterm" id="id84"/>expanded into the first argument of the <code class="literal">mkdir</code> command, which in this particular case is <code class="literal">new folder</code>.</p><div><pre class="programlisting">
<strong>% touch log1.txt log2.txt</strong>
<strong>% nano !$</strong>
<strong>% nano log2.txt</strong>
</pre></div><p>Here the same happens with <code class="literal">$</code>, only this time the last argument of the <code class="literal">touch</code> command is expanded so we can eventually edit it using <code class="literal">nano</code>.</p><p>If you are familiar with regular expressions, both of these designators' behavior shouldn't be too surprising. However, if what you need to do is access some string that is not located either at the beginning (<code class="literal">^</code>) or end (<code class="literal">$</code>) of the history, then you need the <code class="literal">?</code> designator:</p><div><pre class="programlisting">
<strong>% !?etc</strong>
<strong>&gt; cat /etc/hosts | grep 127.0.1.1 </strong>
</pre></div><p>The preceding expression matches the most recent command containing <code class="literal">etc</code>. Generally speaking, the syntax for using the <code class="literal">?</code> event designator can then be summed up as follows:</p><div><pre class="programlisting">
<strong>!?str[?]</strong>
</pre></div><p>The optional <code class="literal">?</code> you see there at the end is only necessary if the command is followed by any text that is not to be considered part of <code class="literal">str</code>; for example:</p><div><pre class="programlisting">
<strong>% !?etc?^</strong>
<strong>&gt; /etc/hosts</strong>
</pre></div><p>Did you notice how both the <code class="literal">?</code> characters serve as delimiters for the <code class="literal">etc</code> keyword? Think of them as parentheses that wrap the expression you're trying to match. The caret operator (<code class="literal">^</code>) is there as we are interested in the first argument of that particular command line, which coincidentally is the <code class="literal">/etc/hosts</code> string.</p><p>There's lots more we can do with the history bang operator. Another neat trick is that it can refer to a particular line in your history. As before, the syntax is merely a tweak of what we already know:</p><div><pre class="programlisting">
<strong>!&lt;hist_number&gt; </strong>
<strong>% !103 # this retrieves the 103rd entry in your $HISTFILE.</strong>
<strong>% !4   # this retrieves the 4th entry.</strong>
</pre></div><p>But what about knowing which line I want to use? Well, that's a bit more complex, but not as much as using <code class="literal">grep</code>, <code class="literal">ack</code>, or whatever it is that kids are using these days to search within your history file:</p><div><pre class="programlisting">
<strong>% history | grep nano</strong>
<strong>&gt; 2045  nano /etc/hosts</strong>
</pre></div><p>Using <code class="literal">grep</code> and <a class="indexterm" id="id85"/>searching for entries that feature <code class="literal">nano</code>, I can see that I edited <code class="literal">/etc/hosts</code> with it, and that the record resides on line <code class="literal">2045</code> of my <code class="literal">$HISTFILE</code>. If we wanted to open the hosts file again, it'll be a simple matter of calling:</p><div><pre class="programlisting">
<strong>% !2045</strong>
<strong>% nano /etc/hosts</strong>
</pre></div><p>And now for a bit of mix and match:</p><div><pre class="programlisting">
<strong>% history | grep git</strong>
<strong>&gt; 1571  cd ../git/dotfiles</strong>
<strong>  1572  git status</strong>
<strong>  1573  git diff zsh/zsh_funcs</strong>
<strong>  1574  git diff zsh/zshrc</strong>
<strong>  1584  history | grep git</strong>
</pre></div><p>On this opportunity I'm looking for <code class="literal">git</code> entries. As you can see from the results, there are quite a few things I've been doing with it. Combine what we have learned so far, and we can accomplish quite a few things:</p><div><pre class="programlisting">
<strong>% more !1573$</strong>
<strong>% more zsh/zsh_funcs</strong>
</pre></div><p>As you can see, we used the bang operator together with the <code class="literal">$</code> selector to refer to the last argument of line 1573 of our history.</p><p>Interestingly, you can also use a negative integer to refer to the nth-to-last entry:</p><div><pre class="programlisting">
<strong>% !-2 # this will retrieve the 2nd to last entry in history.</strong>
<strong>% !-97 # this does the same to the 97th to last entry.</strong>
</pre></div><p>Negative indexes should be pretty familiar territory for some programmers (I'm looking at you, Python and Ruby developers).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>History substitution</h2></div></div></div><p>Another helpful<a class="indexterm" id="id86"/> feature of the history expansion on zsh is command substitution. Using <a class="indexterm" id="id87"/>this kind of substitution, you can avoid re-entering a whole line of your shell history just so you can edit a comparatively smaller section of it.</p><p>Raise your hand if you have made something like the following:</p><div><pre class="programlisting">
<strong>% ls</strong>
<strong>&gt; dir1  file.txt</strong>
<strong>% mv fiel.txt dir1/</strong>
<strong>mv: rename fiel.txt to dir1/fiel.txt: No such file or directory</strong>
</pre></div><p>It seems I misspelled the <code class="literal">file.txt</code> name, so what now? Traditional history usage would suggest we just press the up arrow key to recall the previous line, navigate left to the <code class="literal">fiel</code> typo, re-type the correct name, and be done with it. The zsh approach however, is a bit more practical:</p><div><pre class="programlisting">
<strong>% ^fiel^file</strong>
<strong>% mv file.txt dir1/</strong>
</pre></div><p>What sorcery is this? Put simply, the chained <code class="literal">^</code> operator allows you to match the first occurrence of a word and replace it with the word attached to the second <code class="literal">^</code> operator. A more general syntax would be:</p><div><pre class="programlisting">
<strong>^history-entry^word-replacement</strong>
</pre></div><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>You can prevent a command from being added to your history by setting <code class="literal">HIST_IGNORE_SPACE</code> in your startup options. This will make the shell ignore the lines that start with a space.</p><div><pre class="programlisting">% echo "this line will be recorded in history"
%  echo "this will not"</pre></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec28"/>More useful options</h2></div></div></div><p>To round off this section, here are a couple of history-related options worth considering when populating your startup files, in addition to what we have already discussed throughout this chapter. Just put any (or all) of these on your <code class="literal">.zshrc</code> and remember to append <code class="literal">setopt</code> before each entry.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EXTENDED_HISTORY</code>: Saves <a class="indexterm" id="id88"/>a timestamp and duration for each history entry run. An excellent addition for the data analysis aficionado.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HIST_IGNORE_ALL_DUPS</code>: Ignores<a class="indexterm" id="id89"/> duplicate entries when showing results.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HIST_FIND_NO_DUPS</code>: Does <a class="indexterm" id="id90"/>not display eventual duplicates of a line that has already been found.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HIST_REDUCE_BLANKS</code>: Removes<a class="indexterm" id="id91"/> extra spaces and tabs from history entries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">INC_APPEND_HISTORY</code>: Adds <a class="indexterm" id="id92"/>entries to the history as they are typed, that is, doesn't wait until the shell exits. Probably one of the most awesome features of zsh. You know you want this.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SHARE_HISTORY</code>: Shares<a class="indexterm" id="id93"/> history between different zsh processes. Another great option to compliment the previous entry.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter we had a look at some of the most prominent time-saving features of zsh. The purpose of this entry in our shell adventure was to start accomplishing more by typing less. Thus, this chapter focused on understanding aliases, how they work, and how to roll our own keystroke-saving definitions in a way that won't cause more trouble than what they attempt to solve.</p><p>We then moved onto expansions, learning the ways of arithmetic and brace expansion in order to make command-line related chores feel more like a breeze. Finally, we took a closer look at how to work with history, going beyond the keyboard arrow-mashing approach and learning history expansion and event designators in order to avoid repeating ourselves into oblivion.</p><p>By now you should have a fairly solid notion regarding the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Aliases</strong>: We learned what an alias is and how to define a useful shortcut for our commands together with a handful of tips to start your collection.</li><li class="listitem" style="list-style-type: disc"><strong>Parameter expansion, command substitution, and arithmetic and brace expansion</strong>: How to replace entries on the command line with the output of any given program, the result of an arithmetic expression, and even how to expand arrays so you don't have to type the same thing more than once.</li><li class="listitem" style="list-style-type: disc"><strong>History expansion and substitution</strong>: How to apply all of the above, together with some more specific constructs such as the double bang (<code class="literal">!!</code>) to the shell's history and avoid repeating yourself to boredom.</li></ul></div><p>Not bad at all. Pat yourself on the back or go grab a beer, by now you should feel confident enough to work your way around zsh without problems. That's great, but there's still much more left for us to discover, so don't slack! Next in store for us is ZLE, the zsh line editor. We'll get to know another of zsh's cooler features and discover that we don't actually require a dedicated program in order to perform some of the more advanced text processing on the command line. Besides saving us hundreds of hours of mind-numbing repeated keystrokes, we'll also learn how to customize the editor's shortcuts and key bindings so we don't have to rely on guesswork anymore.</p></div></body></html>