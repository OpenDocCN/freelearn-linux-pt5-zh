- en: Chapter 2. Getting Started with etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover `etcd`, CoreOS's central hub of services, which
    provides a reliable way of storing shared data across cluster machines and monitoring
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing, we will use our already installed CoreOS VM from the previous
    chapter. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `etcd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to `etcd` from the host machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing from an application container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Watching changes in `etcd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TTL (Time to Live) examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases of `etcd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `etcd` function is an open source distributed key value store on a computer
    network where information is stored on more than one node and data is replicated
    using the Raft consensus algorithm. The `etcd` function is used to store the CoreOS
    cluster service discovery and the shared configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration is stored in the write-ahead log and includes the cluster
    member ID, cluster ID and cluster configuration, and is accessible by all cluster
    members.
  prefs: []
  type: TYPE_NORMAL
- en: The `etcd` function runs on each cluster's central services role machine, and
    gracefully handles master election during network partitions and in the event
    of a loss of the current master.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to etcd from the host machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are going to learn how read and write to `ectd` from the host machine. We
    will use both the `etcdctl` and `curl` examples here.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in to the host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To log in to CoreOS VM, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boot the CoreOS VM installed in the first chapter. In your terminal, type this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to log in to the host via `ssh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading and writing to ectd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s read and write to `etcd` using `etcdctl`. So, perform these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set a `message1` key with `etcdctl` with `Book1` as the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s read the key value to double-check whether everything is fine there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s try to do the same using `curl` via an HTTP-based API. The `curl`
    function is handy for accessing `etcd` from any place from where you have access
    to an `etcd` cluster but don''t want/need to use the `etcdctl` client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s read it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the HTTP-based `etcd` API means that `etcd` can be read from and written
    to by client applications without the need to interact with the command line.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, if we want to delete the key-value pair, we type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, we can add a key value pair to a directory, as directories are created
    automatically when a key is placed inside. We only need one command to put a key
    inside a directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now check the directory''s content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we get the key value from the directory by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading and writing from the application container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, application containers (this is a general term for `docker`, `rkt`,
    and other types of containers) do not have `etcdctl` or even `curl` installed
    by default. Installing `curl` is much easier than installing `etcdctl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, we will use the Alpine Linux docker image, which is very small
    in size and will not take much time to pull from the `docker` registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to check the `docker0` interface IP, which we will use with
    `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s run the `docker` container with a `bash` shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see something like this in Command Prompt:`/ #`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As `curl` is not installed by default on Alpine Linux, we need to install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat steps 3 and 4 from the previous subtopic so that you understand that
    no matter where you are connecting to `etcd` from, `curl` still works in the same
    way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* +*D* to exit from the `docker` container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Watching changes in etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, let''s watch the key changes in `etcd`. Watching key changes is
    useful when we have, for example, one `fleet` unit with `nginx` writing its port
    to `etcd`, and another reverse proxy application watching for changes and updating
    its configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a directory in `etcd` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we watch for changes in this directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open another CoreOS shell in a new terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We add a new key to the `/foo-data` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the first terminal, we should see a notification saying that the key was
    changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: TTL (time to live) examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is handy to put a **time to live** (**TTL**) for a key to expire
    in a certain amount of time. This is useful, for example, in the case of watching
    a key with a 60 second TTL, from a reverse proxy. So, if the `nginx fleet` service
    has not updated the key, it will expire in 60 seconds and will be removed from
    `etcd`. Then the reverse proxy checks for it and does not find it. Hence, it will
    remove the `nginx` service from `config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set a TTL of 30 seconds in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type this in a terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the key is still there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check again after 30 seconds :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your requested key has already expired, you will be returned `Error`: `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time the key got deleted by `etcd` because we put a TTL of 30 seconds for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TTL is very handy to use to communicate between the different services using
    `etcd` as the checking point.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases of etcd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application containers running on worker nodes with `etcd` in proxy mode can
    read and write to an `etcd` cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Very common `etcd` use cases are as follows: storing database connection settings,
    cache settings, and shared settings. For example, the Vulcand proxy server ([http://vulcanproxy.com/](http://vulcanproxy.com/))
    uses `etcd` to store web host connection details, and it becomes available for
    all cluster-connected worker machines. Another example could be to store a database
    password for MySQL and retrieve it when running an application container.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover more details about cluster setup, central services, and worker
    role machines in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this short chapter, we covered the basics of `etcd` and how to read and write
    to `etcd`, watch for changes in `etcd`, and use TTL for `etcd` keys.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to use the `systemd` and `fleet` units.
  prefs: []
  type: TYPE_NORMAL
