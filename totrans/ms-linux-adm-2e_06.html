<html><head></head><body>
<div id="_idContainer189">
<h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-109"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.2.1">Working with Disks and Filesystems</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, you will learn how to manage disks and filesystems, how to use the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Logical Volume Management</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">LVM</span></strong><span class="koboSpan" id="kobo.7.1">) system, and how to mount and partition the hard drive, as well as gain an understanding of</span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.8.1"> storage in Linux. </span><span class="koboSpan" id="kobo.8.2">You will also learn how to partition and format a disk, as well as how to create logical volumes, and you will gain a deeper understanding of filesystem types. </span><span class="koboSpan" id="kobo.8.3">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">Understanding devices </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">in Linux</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Understanding filesystem types </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">in Linux</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Understanding disks </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">and partitions</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Introducing LVM </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">in Linux</span></span></li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">A basic knowledge of disks, partitions, and filesystems is preferred. </span><span class="koboSpan" id="kobo.19.2">No other special technical requirements are needed, just a working installation of Linux on your system. </span><span class="koboSpan" id="kobo.19.3">We will mainly use Ubuntu or Debian for this chapter’s exercises. </span><span class="koboSpan" id="kobo.19.4">All the commands used in this chapter can be replicated on any Linux distribution, even if you don’t use Debian </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">or Ubuntu.</span></span></p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.21.1">Understanding devices in Linux</span></h1>
<p><span class="koboSpan" id="kobo.22.1">As already stated on several occasions</span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.23.1"> in this book, everything in Linux is a file. </span><span class="koboSpan" id="kobo.23.2">This also includes devices. </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Device files</span></strong><span class="koboSpan" id="kobo.25.1"> are special files in Unix and Linux operating</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.26.1"> systems. </span><span class="koboSpan" id="kobo.26.2">Those special files are interfaces to device drivers, and they are present in the filesystem as a </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">regular file.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">With no further ado, let’s see how Linux abstraction layers work. </span><span class="koboSpan" id="kobo.28.2">This will give you an overview of how hardware and software are related </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">and interconnected.</span></span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.30.1">Linux abstraction layers</span></h2>
<p><span class="koboSpan" id="kobo.31.1">Now is as good a time as any</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.32.1"> to discuss Linux system abstraction layers and how devices fit into the overall picture. </span><span class="koboSpan" id="kobo.32.2">Any computer is generally organized into two layers (or levels) – the hardware and the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">software levels:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Hardware level</span></strong><span class="koboSpan" id="kobo.35.1">: This level contains the hardware</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.36.1"> components of your machine, such as the memory (RAM), </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">central processing unit</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">CPU</span></strong><span class="koboSpan" id="kobo.40.1">), and devices, including disks, network interfaces, ports, </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">and controllers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Software level</span></strong><span class="koboSpan" id="kobo.43.1">: For all these hardware components</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.44.1"> to work, the operating system (Linux, in our case) uses </span><strong class="bold"><span class="koboSpan" id="kobo.45.1">abstraction layers</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Those layers exist in the </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">kernel</span></strong><span class="koboSpan" id="kobo.48.1">, which is the main software component of Linux. </span><span class="koboSpan" id="kobo.48.2">Without diving into more</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.49.1"> information, it is sufficient for you to know</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.50.1"> that Linux has these layers that are responsible for accessing low-level resources and providing the specific drivers for different hardware components. </span><span class="koboSpan" id="kobo.50.2">When the computer is booted up, the Linux kernel</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.51.1"> is loaded from the disk</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.52.1"> into the system’s memory (RAM). </span><span class="koboSpan" id="kobo.52.2">Thus, inside the memory, there will be two separate regions, called </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">kernel space</span></strong><span class="koboSpan" id="kobo.54.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">user space</span></strong><span class="koboSpan" id="kobo.56.1">, and this would be the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.57.1">software level</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">:</span></span><ul><li><span class="koboSpan" id="kobo.59.1">The kernel is the beating heart of the Linux operating system. </span><span class="koboSpan" id="kobo.59.2">The kernel resides inside the memory (RAM) and manages all the hardware components. </span><span class="koboSpan" id="kobo.59.3">It is the </span><em class="italic"><span class="koboSpan" id="kobo.60.1">interface</span></em><span class="koboSpan" id="kobo.61.1"> between the software and hardware on your </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">Linux system.</span></span></li><li><span class="koboSpan" id="kobo.63.1">The user space level is the level where user processes are executed. </span><span class="koboSpan" id="kobo.63.2">As presented in </span><a href="B19682_05.xhtml#_idTextAnchor104"><em class="italic"><span class="koboSpan" id="kobo.64.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.65.1">, </span><em class="italic"><span class="koboSpan" id="kobo.66.1">Working with Processes, Daemons, and Signals</span></em><span class="koboSpan" id="kobo.67.1">, a process is a running instance of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">a program.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.69.1">Where are devices in this grand scheme of things? </span><span class="koboSpan" id="kobo.69.2">Devices are managed by the </span><em class="italic"><span class="koboSpan" id="kobo.70.1">kernel</span></em><span class="koboSpan" id="kobo.71.1">. </span><span class="koboSpan" id="kobo.71.2">To sum up, the kernel is in charge of managing</span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.72.1"> processes, system calls, memory, and devices. </span><span class="koboSpan" id="kobo.72.2">When dealing with devices, the kernel manages </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">device drivers</span></strong><span class="koboSpan" id="kobo.74.1">, which are the interface between hardware components and software. </span><span class="koboSpan" id="kobo.74.2">All devices are accessible only in kernel mode, for a more secure and </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">streamlined operation.</span></span></p>
<p><span class="koboSpan" id="kobo.76.1">How does all this work? </span><span class="koboSpan" id="kobo.76.2">Well, the </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.77.1">memory, known as RAM, consists of cells that are used to store information temporarily. </span><span class="koboSpan" id="kobo.77.2">Those cells are accessed by different programs that are executed and function as an intermediary between the CPU and the storage. </span><span class="koboSpan" id="kobo.77.3">The speeds of accessing memory are very high to secure a seamless process of execution. </span><span class="koboSpan" id="kobo.77.4">The management of user processes inside the user space is the kernel’s job. </span><span class="koboSpan" id="kobo.77.5">The kernel makes sure that none of the processes will interfere with each other. </span><span class="koboSpan" id="kobo.77.6">The kernel space is usually accessed only by the kernel, but</span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.78.1"> there are times when user processes need to access this space. </span><span class="koboSpan" id="kobo.78.2">This is done through </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">system calls</span></strong><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">A system call is the way a user process requests a kernel</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.81.1"> service through an active process inside the kernel space, for anything such as </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">input/output</span></strong><span class="koboSpan" id="kobo.83.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.84.1">I/O</span></strong><span class="koboSpan" id="kobo.85.1">) requests to internal or external devices. </span><span class="koboSpan" id="kobo.85.2">All those requests transfer data to and from the CPU, through RAM, to get</span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.86.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">job done.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">In the following section, we will introduce you to the naming convention in Linux and how device files </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">are managed.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.90.1">Device files and naming conventions</span></h2>
<p><span class="koboSpan" id="kobo.91.1">After seeing how the abstraction layers work, you may</span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.92.1"> be wondering how</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.93.1"> Linux manages devices. </span><span class="koboSpan" id="kobo.93.2">Well, it does </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.94.1">that with the help of </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">userspace /dev</span></strong><span class="koboSpan" id="kobo.96.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.97.1">udev</span></strong><span class="koboSpan" id="kobo.98.1">), which is a device manager for the kernel. </span><span class="koboSpan" id="kobo.98.2">It works with </span><strong class="bold"><span class="koboSpan" id="kobo.99.1">device nodes</span></strong><span class="koboSpan" id="kobo.100.1">, which are special files (also called </span><strong class="bold"><span class="koboSpan" id="kobo.101.1">device files</span></strong><span class="koboSpan" id="kobo.102.1">) that are used as an interface to </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">the driver.</span></span></p>
<h3><span class="koboSpan" id="kobo.104.1">Device files in Linux</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">udev</span></strong><span class="koboSpan" id="kobo.106.1"> runs as a daemon</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.107.1"> that listens to the user space calls that the kernel is sending, so it is aware of what kinds of devices are used and how they are used. </span><span class="koboSpan" id="kobo.107.2">The daemon is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">udevd</span></strong><span class="koboSpan" id="kobo.109.1"> and its configurations are currently available under </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">/etc/udev/udev.conf</span></strong><span class="koboSpan" id="kobo.111.1">. </span><span class="koboSpan" id="kobo.111.2">You can concatenate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">/etc/udev/udev.conf</span></strong><span class="koboSpan" id="kobo.113.1"> file to see its contents by running the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.115.1">
cat /etc/udev/udev.conf</span></pre> <p><span class="koboSpan" id="kobo.116.1">Each Linux distribution has a default set of rules that governs </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">udevd</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">Those rules are normally stored under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">/etc/udev/rules.d/</span></strong><span class="koboSpan" id="kobo.120.1"> directory, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.122.1"><img alt="Figure 6.1 – udevd rules location" src="image/B19682_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.123.1">Figure 6.1 – udevd rules location</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.124.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.125.1">The kernel sends calls for events using the </span><strong class="bold"><span class="koboSpan" id="kobo.126.1">Netlink</span></strong><span class="koboSpan" id="kobo.127.1"> socket. </span><span class="koboSpan" id="kobo.127.2">The netlink socket is an interface for inter-process</span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.128.1"> communication that’s used for both userspace and kernel space </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">processes alike.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">/dev</span></strong><span class="koboSpan" id="kobo.132.1"> directory is the interface</span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.133.1"> between user processes and devices managed by the kernel. </span><span class="koboSpan" id="kobo.133.2">If you were to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">ls -la /dev</span></strong><span class="koboSpan" id="kobo.135.1"> command, you would see a lot of files inside, each with different names. </span><span class="koboSpan" id="kobo.135.2">If you were to do a long listing, you would see different file types. </span><span class="koboSpan" id="kobo.135.3">Some of the files will start with the letters </span><em class="italic"><span class="koboSpan" id="kobo.136.1">b</span></em><span class="koboSpan" id="kobo.137.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.138.1">c</span></em><span class="koboSpan" id="kobo.139.1">, but the letters </span><em class="italic"><span class="koboSpan" id="kobo.140.1">p</span></em><span class="koboSpan" id="kobo.141.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.142.1">s</span></em><span class="koboSpan" id="kobo.143.1"> may also be present, depending</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.144.1"> on your system. </span><span class="koboSpan" id="kobo.144.2">Files starting with those letters are device files. </span><span class="koboSpan" id="kobo.144.3">The ones</span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.145.1"> starting with </span><em class="italic"><span class="koboSpan" id="kobo.146.1">b</span></em><span class="koboSpan" id="kobo.147.1"> are </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">block devices</span></strong><span class="koboSpan" id="kobo.149.1">, and those starting with the letter </span><em class="italic"><span class="koboSpan" id="kobo.150.1">c</span></em><span class="koboSpan" id="kobo.151.1"> are </span><strong class="bold"><span class="koboSpan" id="kobo.152.1">character devices</span></strong><span class="koboSpan" id="kobo.153.1">, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.155.1"><img alt="Figure 6.2 – Device files inside the /dev directory" src="image/B19682_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.156.1">Figure 6.2 – Device files inside the /dev directory</span></p>
<p><span class="koboSpan" id="kobo.157.1">Let’s see how disk devices</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.158.1"> are presented inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">/dev</span></strong><span class="koboSpan" id="kobo.160.1"> directory. </span><span class="koboSpan" id="kobo.160.2">But first, we’ve provided a few words about our working setup in the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">following note.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.162.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.163.1">For most of the exercises in this book, we will be using virtual machines with planet names as hostnames, running different Linux-based operating systems. </span><span class="koboSpan" id="kobo.163.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">neptune</span></strong><span class="koboSpan" id="kobo.165.1"> is running on Ubuntu 22.04.2 LTS Server, so when you see the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">neptune</span></strong><span class="koboSpan" id="kobo.167.1"> hostname on the shell’s prompt, you will know we are on an Ubuntu-based system. </span><span class="koboSpan" id="kobo.167.2">We also have </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">jupiter</span></strong><span class="koboSpan" id="kobo.169.1">, running on the openSUSE 15.4 Leap server, </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">saturn</span></strong><span class="koboSpan" id="kobo.171.1"> running on Fedora 37 Workstation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">venus</span></strong><span class="koboSpan" id="kobo.173.1"> running on AlmaLinux, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">mars</span></strong><span class="koboSpan" id="kobo.175.1"> running on a Debian 11.6 server. </span><span class="koboSpan" id="kobo.175.2">Inside a virtual machine, device drivers are presented with different names than on bare-metal systems. </span><span class="koboSpan" id="kobo.175.3">We will provide details when we discuss device naming conventions in the following section. </span><span class="koboSpan" id="kobo.175.4">For some examples, though, which are marked accordingly, we will also use our primary workstation, which is running on Debian </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">12 GNU/Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.179.1">.3</span></em><span class="koboSpan" id="kobo.180.1">, the disk device, </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">sda</span></strong><span class="koboSpan" id="kobo.182.1">, is represented as a block device. </span><span class="koboSpan" id="kobo.182.2">Block devices have a fixed size</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.183.1"> that can easily be indexed. </span><span class="koboSpan" id="kobo.183.2">Character devices, on the</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.184.1"> other hand, can be accessed using data streams, as they don’t have a size like block devices. </span><span class="koboSpan" id="kobo.184.2">For example, printers are represented as character devices. </span><span class="koboSpan" id="kobo.184.3">In the following screenshot, </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">sg0</span></strong><span class="koboSpan" id="kobo.186.1"> is an SCSI generic device, and not assigned to any disks in our case. </span><span class="koboSpan" id="kobo.186.2">We used our primary workstation running on Debian GNU/Linux and the device presented as </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">sda</span></strong><span class="koboSpan" id="kobo.188.1"> is an external </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">USB device:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.190.1"><img alt="Figure 6.3 – Disk drives inside the /dev directory" src="image/B19682_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.191.1">Figure 6.3 – Disk drives inside the /dev directory</span></p>
<p><span class="koboSpan" id="kobo.192.1">In comparison, when listing devices from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">neptune</span></strong><span class="koboSpan" id="kobo.194.1"> virtual machine, we will have the output presented in the </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.196.1"><img alt="Figure 6.4 – Virtual devices inside a virtual machine" src="image/B19682_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">Figure 6.4 – Virtual devices inside a virtual machine</span></p>
<p><span class="koboSpan" id="kobo.198.1">Device blocks presented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">vdaX</span></strong><span class="koboSpan" id="kobo.200.1"> are virtual devices inside the virtual machine. </span><span class="koboSpan" id="kobo.200.2">You will learn more about virtual</span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.201.1"> machines in </span><a href="B19682_11.xhtml#_idTextAnchor231"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.203.1">, </span><em class="italic"><span class="koboSpan" id="kobo.204.1">Working with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.205.1">Virtual Machines</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">But for now, let’s find out more about device naming conventions </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">in Linux.</span></span></p>
<h3><span class="koboSpan" id="kobo.209.1">Understanding device naming conventions</span></h3>
<p><span class="koboSpan" id="kobo.210.1">Linux uses a device naming</span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.211.1"> convention that makes device management easier and more consistent throughout the Linux ecosystem. </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">udev</span></strong><span class="koboSpan" id="kobo.213.1"> uses several specific naming schemes that, by default, assign fixed names to devices. </span><span class="koboSpan" id="kobo.213.2">Those names are standardized for device categories. </span><span class="koboSpan" id="kobo.213.3">For example, when naming network devices, the kernel uses information compiled from sources such as firmware, topology, and location. </span><span class="koboSpan" id="kobo.213.4">On a Red Hat-based system, five schemes are used for naming a network interface, and we encourage</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.214.1"> you to look at these on the Red Hat customer portal official documentation </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">website: </span></span><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9"><span class="No-Break"><span class="koboSpan" id="kobo.216.1">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.217.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">On a Debian-based system, the naming convention is similar in that it’s based on hardware buses’ names for predictability. </span><span class="koboSpan" id="kobo.218.2">This is similar to all modern Linux-based </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">You could also check what </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">udev</span></strong><span class="koboSpan" id="kobo.222.1"> rules are active on your system. </span><span class="koboSpan" id="kobo.222.2">On Debian and Red Hat-based distributions, they are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">lib/udev/rules.d/</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.225.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.226.1">When it comes to hard drives or external drives, the conventions are more streamlined. </span><span class="koboSpan" id="kobo.226.2">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">some examples:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.228.1">For classic IDE drivers used for ATA drives</span></strong><span class="koboSpan" id="kobo.229.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">hda</span></strong><span class="koboSpan" id="kobo.231.1"> (the master device), </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">hdb</span></strong><span class="koboSpan" id="kobo.233.1"> (the slave device</span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.234.1"> on the first channel), </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">hdc</span></strong><span class="koboSpan" id="kobo.236.1"> (the master device on the second channel), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">hdd</span></strong><span class="koboSpan" id="kobo.238.1"> (the slave device on the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">second channel)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.240.1">For NVMe drivers</span></strong><span class="koboSpan" id="kobo.241.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">nvme0</span></strong><span class="koboSpan" id="kobo.243.1"> (the first device </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.244.1">controller – character device), </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">nvme0n1</span></strong><span class="koboSpan" id="kobo.246.1"> (first namespace – block device), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">nvme0n1p1</span></strong><span class="koboSpan" id="kobo.248.1"> (first namespace, first partition – </span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">block device)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.250.1">For MMC drivers</span></strong><span class="koboSpan" id="kobo.251.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">mmcblk</span></strong><span class="koboSpan" id="kobo.253.1"> (for SD cards using</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.254.1"> eMMC chips), </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">mmcblk0</span></strong><span class="koboSpan" id="kobo.256.1"> (first device), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">mmcblk0p1</span></strong><span class="koboSpan" id="kobo.258.1"> (first device, </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">first partition)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">For SCSI drivers used for modern SATA or USB</span></strong><span class="koboSpan" id="kobo.261.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">sd</span></strong><span class="koboSpan" id="kobo.263.1"> (for mass storage devices), </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">sda</span></strong><span class="koboSpan" id="kobo.265.1"> (for the first registered</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.266.1"> device), </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">sdb</span></strong><span class="koboSpan" id="kobo.268.1"> (for the second registered device), </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">sdc</span></strong><span class="koboSpan" id="kobo.270.1"> (for the third registered device), and so on, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">sg</span></strong><span class="koboSpan" id="kobo.272.1"> (for generic SCSI layers – </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">character device)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.274.1">The devices that we are most interested</span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.275.1"> in regarding this chapter are the mass storage devices. </span><span class="koboSpan" id="kobo.275.2">Those devices are usually </span><strong class="bold"><span class="koboSpan" id="kobo.276.1">hard disk drives</span></strong><span class="koboSpan" id="kobo.277.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.278.1">HDDs</span></strong><span class="koboSpan" id="kobo.279.1">) or </span><strong class="bold"><span class="koboSpan" id="kobo.280.1">solid-state drives</span></strong><span class="koboSpan" id="kobo.281.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.282.1">SSDs</span></strong><span class="koboSpan" id="kobo.283.1">), which are used inside your computer to store data. </span><span class="koboSpan" id="kobo.283.2">These drives are most likely divided</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.284.1"> into partitions with a specific structure provided by the filesystem. </span><span class="koboSpan" id="kobo.284.2">We talked a little bit about filesystems earlier in this book in </span><a href="B19682_02.xhtml#_idTextAnchor053"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.285.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.286.1">, </span><em class="italic"><span class="koboSpan" id="kobo.287.1">The </span></em><em class="italic"><span class="koboSpan" id="kobo.288.1">Linux Shell and</span></em><em class="italic"><span class="koboSpan" id="kobo.289.1"> Filesystem</span></em><span class="koboSpan" id="kobo.290.1">, when we referred to the Linux directory</span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.291.1"> structure, but now, it is time to get into more details about filesystem types </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">in Linux.</span></span></p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.293.1">Understanding filesystem types in Linux</span></h1>
<p><span class="koboSpan" id="kobo.294.1">When talking about physical</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.295.1"> media, such as hard drives or external drives, we are </span><em class="italic"><span class="koboSpan" id="kobo.296.1">not</span></em><span class="koboSpan" id="kobo.297.1"> referring to the directory structure. </span><span class="koboSpan" id="kobo.297.2">Here, we are talking about the structures that are created on the physical drive when formatting and/or partitioning it. </span><span class="koboSpan" id="kobo.297.3">These structures, depending on their type, are known as filesystems, and they determine how the files are managed when stored on </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the drive.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">There are several types of filesystems, some being native to the Linux ecosystem, while others are not, such as specific Windows or macOS filesystems. </span><span class="koboSpan" id="kobo.299.2">In this section, we will describe only the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">Linux-native filesystems.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">The most widely</span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.302.1"> used filesystems in Linux are the </span><strong class="bold"><span class="koboSpan" id="kobo.303.1">extended filesystems</span></strong><span class="koboSpan" id="kobo.304.1">, known as </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Ext</span></strong><span class="koboSpan" id="kobo.306.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Ext2</span></strong><span class="koboSpan" id="kobo.308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Ext3</span></strong><span class="koboSpan" id="kobo.310.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">Ext4</span></strong><span class="koboSpan" id="kobo.312.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">XFS</span></strong><span class="koboSpan" id="kobo.314.1"> filesystem, </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">ZFS</span></strong><span class="koboSpan" id="kobo.316.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">btrfs</span></strong><span class="koboSpan" id="kobo.318.1"> (short for </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">B-tree filesystem</span></strong><span class="koboSpan" id="kobo.320.1">). </span><span class="koboSpan" id="kobo.320.2">Each of these have their strengths and weaknesses, but they are all able to do the job they were designed for. </span><span class="koboSpan" id="kobo.320.3">The extended filesystems are the ones that were most widely used in Linux, and they have proven trustworthy all this time. </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Ext4</span></strong><span class="koboSpan" id="kobo.322.1">, the latest iteration, is similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Ext3</span></strong><span class="koboSpan" id="kobo.324.1">, but better, with improved support for larger files, fragmentation, and performance. </span><span class="koboSpan" id="kobo.324.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Ext3</span></strong><span class="koboSpan" id="kobo.326.1"> filesystem uses 32-bit addressing, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">Ext4</span></strong><span class="koboSpan" id="kobo.328.1"> uses 48-bit addressing, thus supporting files up to 16 TB in size. </span><span class="koboSpan" id="kobo.328.2">It also offers support for unlimited subdirectories as </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">Ext3</span></strong><span class="koboSpan" id="kobo.330.1"> only supports 32k subdirectories. </span><span class="koboSpan" id="kobo.330.2">Also, support for extended timestamps was added in </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Ext4</span></strong><span class="koboSpan" id="kobo.332.1">, offering two more bits for up to the year 2446 AD, and online defragmentation at the </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">kernel level.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">Nonetheless, </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">Ext4</span></strong><span class="koboSpan" id="kobo.336.1"> is not a truly next-gen filesystem; rather, it is an improved, trustworthy, robust, and stable </span><em class="italic"><span class="koboSpan" id="kobo.337.1">workhorse</span></em><span class="koboSpan" id="kobo.338.1"> that failed the data protection and integrity test. </span><span class="koboSpan" id="kobo.338.2">Its journaling system is not suitable for detecting and repairing data corruption and degradation. </span><span class="koboSpan" id="kobo.338.3">That is why other filesystems, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">XFS</span></strong><span class="koboSpan" id="kobo.340.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">ZFS</span></strong><span class="koboSpan" id="kobo.342.1">, started to resurface by being used in Red Hat Enterprise Linux, starting from version 7 (</span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">XFS</span></strong><span class="koboSpan" id="kobo.344.1">) and in Ubuntu since version </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">16.04 (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">ZFS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">The case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">btrfs</span></strong><span class="koboSpan" id="kobo.350.1"> is somewhat controversial. </span><span class="koboSpan" id="kobo.350.2">It is considered a modern filesystem, but it is still used as a single-disk filesystem and not used in multiple disk volume managers due to several performance issues compared to other filesystems. </span><span class="koboSpan" id="kobo.350.3">It is used in SUSE Linux Enterprise and openSUSE, is no longer supported by Red Hat, and has been voted as the future default filesystem in Fedora, starting with </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">version 33.</span></span></p>
<p><span class="koboSpan" id="kobo.352.1">Here are some more details on the major </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">filesystem features:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.354.1">Ext4</span></strong><span class="koboSpan" id="kobo.355.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Ext4</span></strong><span class="koboSpan" id="kobo.357.1"> filesystem was designed</span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.358.1"> for Linux right from the outset. </span><span class="koboSpan" id="kobo.358.2">Even though</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.359.1"> it is slowly being replaced with other filesystems, this one still has powerful features. </span><span class="koboSpan" id="kobo.359.2">It offers block size selection, with values between 512 and 4,096 bytes. </span><span class="koboSpan" id="kobo.359.3">There is also a feature called inode reservation, which saves a couple of inodes when</span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.360.1"> you create a directory, for improved performance when creating </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">new files.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.362.1">The layout is simple, written in </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">little-endian</span></strong><span class="koboSpan" id="kobo.364.1"> order (for more details on this, visit </span><a href="https://www.section.io/engineering-education/what-is-little-endian-and-big-endian/"><span class="koboSpan" id="kobo.365.1">https://www.section.io/engineering-education/what-is-little-endian-and-big-endian/</span></a><span class="koboSpan" id="kobo.366.1">), with block groups containing</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.367.1"> inode data for lower access</span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.368.1"> times. </span><span class="koboSpan" id="kobo.368.2">Each file has data blocks pre-allocated for reduced fragmentation. </span><span class="koboSpan" id="kobo.368.3">There are also many enhancements that </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">Ext4</span></strong><span class="koboSpan" id="kobo.370.1"> takes advantage of. </span><span class="koboSpan" id="kobo.370.2">Among them, we will bring the following into</span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.371.1"> the discussion: a maximum filesystem size of 1 </span><strong class="bold"><span class="koboSpan" id="kobo.372.1">exabyte</span></strong><span class="koboSpan" id="kobo.373.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">EB</span></strong><span class="koboSpan" id="kobo.375.1">), the ability to use multi-block allocation, splitting large files into the largest possible sizes for better performance, application of the allocate-on-flush technique for better performance, the use of the handy </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">fsck</span></strong><span class="koboSpan" id="kobo.377.1"> command for speedy filesystem checks, the use of checksums for journaling and better reliability, and the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">improved timestamps.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">ZFS</span></strong><span class="koboSpan" id="kobo.380.1">: This filesystem was created at Sun Microsystems</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.381.1"> and combines a file system and a logical volume</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.382.1"> manager into one solution. </span><span class="koboSpan" id="kobo.382.2">It was announced in 2004, with development starting in 2001, and was first integrated into the Solaris operating system, then used (not the default though) by Debian, FreeBSD, and others. </span><span class="koboSpan" id="kobo.382.3">ZFS is a highly scalable 128-bit system that offers simple administration, data</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.383.1"> integrity, scalability, and performance. </span><span class="koboSpan" id="kobo.383.2">Development of this filesystem is done through the </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">OpenZFS</span></strong><span class="koboSpan" id="kobo.385.1"> open source project. </span><span class="koboSpan" id="kobo.385.2">ZFS offers a complex structure by using a copy-on-write mechanism, different from traditional filesystems. </span><span class="koboSpan" id="kobo.385.3">For more detailed</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.386.1"> information about ZFS, we recommend the following </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">link: </span></span><a href="https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.388.1">https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.389.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.390.1">XFS</span></strong><span class="koboSpan" id="kobo.391.1">: Enterprise Linux is starting to change</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.392.1"> by moving away from </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">Ext4</span></strong><span class="koboSpan" id="kobo.394.1"> to other competent filesystem</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.395.1"> types. </span><span class="koboSpan" id="kobo.395.2">Among those is </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">XFS</span></strong><span class="koboSpan" id="kobo.397.1">. </span><span class="koboSpan" id="kobo.397.2">This filesystem was first created by Silicon Graphics, Inc and used in the IRIX operating system. </span><span class="koboSpan" id="kobo.397.3">Its most important key design element is performance as it is capable of dealing with large datasets. </span><span class="koboSpan" id="kobo.397.4">Furthermore, it is designed to handle parallel I/O tasks with a guaranteed high I/O rate. </span><span class="koboSpan" id="kobo.397.5">The filesystem supports up to 16 EB with support for individual files up to 8 EB. </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">XFS</span></strong><span class="koboSpan" id="kobo.399.1"> has a feature to journal quota information, together with online maintenance tasks such as defragmenting, enlarging, and restoring. </span><span class="koboSpan" id="kobo.399.2">There are also specific tools for backup and restore, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">xfsdump</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.401.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">xfsrestore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.404.1">btrfs</span></strong><span class="koboSpan" id="kobo.405.1">: The B-tree filesystem (</span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">btrfs</span></strong><span class="koboSpan" id="kobo.407.1">) is still under</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.408.1"> development, but it addresses</span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.409.1"> issues associated with existing filesystems, including the lack of snapshots, pooling, checksums, and multi-device spanning. </span><span class="koboSpan" id="kobo.409.2">These are features that are required in an enterprise Linux environment. </span><span class="koboSpan" id="kobo.409.3">The ability to take snapshots of the filesystem and maintain its internal framework for managing new partitions makes </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">btrfs</span></strong><span class="koboSpan" id="kobo.411.1"> a viable newcomer in terms of the critical </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">enterprise ecosystem.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.413.1">There are other</span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.414.1"> filesystems</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.415.1"> that we did not discuss here, including </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">ReiserFS</span></strong><span class="koboSpan" id="kobo.417.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">GlusterFS</span></strong><span class="koboSpan" id="kobo.419.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">Network File System</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">NFS</span></strong><span class="koboSpan" id="kobo.423.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.424.1">Samba CIFS File System</span></strong><span class="koboSpan" id="kobo.425.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.426.1">SMB</span></strong><span class="koboSpan" id="kobo.427.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.428.1">ISO9660</span></strong><span class="koboSpan" id="kobo.429.1"> for CD-ROMs and Joliet extensions, and non-native Linux ones, including </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">FAT</span></strong><span class="koboSpan" id="kobo.431.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.432.1">NTFS</span></strong><span class="koboSpan" id="kobo.433.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.434.1">exFAT</span></strong><span class="koboSpan" id="kobo.435.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">APFS</span></strong><span class="koboSpan" id="kobo.437.1">, or </span><strong class="bold"><span class="koboSpan" id="kobo.438.1">MacOS Extended</span></strong><span class="koboSpan" id="kobo.439.1">, among others. </span><span class="koboSpan" id="kobo.439.2">If you</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.440.1"> want to learn</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.441.1"> about these</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.442.1"> in more</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.443.1"> detail, feel </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.444.1">free to investigate</span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.445.1"> further; a good</span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.446.1"> starting point</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.447.1"> is Wikipedia: </span><a href="https://en.wikipedia.org/wiki/File_system"><span class="koboSpan" id="kobo.448.1">https://en.wikipedia.org/wiki/File_system</span></a><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">To check the list of supported filesystems on your Linux </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.450.1">distribution, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">cat /</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">proc/filesystems</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">Linux implements a special software</span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.455.1"> system that is designed to run specific functions of the filesystems. </span><span class="koboSpan" id="kobo.455.2">It is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">virtual file system</span></strong><span class="koboSpan" id="kobo.457.1"> and acts as a bridge between the kernel and the filesystem types and hardware. </span><span class="koboSpan" id="kobo.457.2">Therefore, when an application wants to open a file, the action is delivered through the Virtual File System as an </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">abstraction layer:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.459.1"><img alt="Figure 6.5 – The Linux Virtual File System abstraction layer" src="image/B19682_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.460.1">Figure 6.5 – The Linux Virtual File System abstraction layer</span></p>
<p><span class="koboSpan" id="kobo.461.1">Basic filesystem functions include provisioning namespaces, metadata structures as a logical foundation for hierarchical directory structures, disk block usage, file size and access information, and high-level</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.462.1"> data for logical volumes and partitions. </span><span class="koboSpan" id="kobo.462.2">There is also an </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">application programming interface</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">API</span></strong><span class="koboSpan" id="kobo.466.1">) available for every filesystem. </span><span class="koboSpan" id="kobo.466.2">Thus, developers can access system function calls for filesystem object manipulation with specific algorithms for creating, moving, and deleting files, or for indexing, searching, and finding files. </span><span class="koboSpan" id="kobo.466.3">Furthermore, every modern filesystem provides a special access rights scheme</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.467.1"> that’s used to determine the rules governing a user’s access </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">to files.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">At this point, we have already covered the principal Linux filesystems, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">EXT4</span></strong><span class="koboSpan" id="kobo.471.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">btrfs</span></strong><span class="koboSpan" id="kobo.473.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">XFS</span></strong><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">In the next section, we will teach you the basics of disks and partition management </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">in Linux.</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.477.1">Understanding disks and partitions</span></h1>
<p><span class="koboSpan" id="kobo.478.1">Understanding disks and partitions is a key asset</span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.479.1"> for any system</span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.480.1"> administrator. </span><span class="koboSpan" id="kobo.480.2">Formatting and partitioning disks is critical, starting with system installation. </span><span class="koboSpan" id="kobo.480.3">Knowing the type of hardware available on your system is important, and it is therefore imperative to know how to work with it. </span><span class="koboSpan" id="kobo.480.4">One of these is the disk; let’s look at this in </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">further detail.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.482.1">Common disk types</span></h2>
<p><span class="koboSpan" id="kobo.483.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">disk</span></strong><span class="koboSpan" id="kobo.485.1"> is a hardware component that</span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.486.1"> stores your data. </span><span class="koboSpan" id="kobo.486.2">It comes in various types and uses different</span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.487.1"> interfaces. </span><span class="koboSpan" id="kobo.487.2">The main disk types are the well-known </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">spinning HDD</span></strong><span class="koboSpan" id="kobo.489.1">, the SSD, and the </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">non-volatile memory express</span></strong><span class="koboSpan" id="kobo.491.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.492.1">NVMe</span></strong><span class="koboSpan" id="kobo.493.1">). </span><span class="koboSpan" id="kobo.493.2">SSDs and NVMes use RAM-like</span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.494.1"> technologies, with better energy</span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.495.1"> consumption and higher transfer rates than original spinning hard drives. </span><span class="koboSpan" id="kobo.495.2">The following interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">are used:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.497.1">Integrated Drive Electronics</span></strong><span class="koboSpan" id="kobo.498.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.499.1">IDE</span></strong><span class="koboSpan" id="kobo.500.1">): This is an old standard that’s used on consumer hardware</span><a id="_idIndexMarker826"/><span class="koboSpan" id="kobo.501.1"> with small transfer rates. </span><span class="koboSpan" id="kobo.501.2">It’s </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">now</span></span><span class="No-Break"><a id="_idIndexMarker827"/></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1"> deprecated.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.504.1">Serial Advanced Technology Attachment</span></strong><span class="koboSpan" id="kobo.505.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.506.1">SATA</span></strong><span class="koboSpan" id="kobo.507.1">): This replaced IDEs and has transfer</span><a id="_idIndexMarker828"/><span class="koboSpan" id="kobo.508.1"> rates of up </span><a id="_idIndexMarker829"/><span class="koboSpan" id="kobo.509.1">to </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">16 GB/s.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.511.1">Small Computer Systems Interface</span></strong><span class="koboSpan" id="kobo.512.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.513.1">SCSI</span></strong><span class="koboSpan" id="kobo.514.1">): This is used mostly in enterprise servers with RAID configurations</span><a id="_idIndexMarker830"/><span class="koboSpan" id="kobo.515.1"> with sophisticated </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">hardware</span></span><span class="No-Break"><a id="_idIndexMarker831"/></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1"> components.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.518.1">Serial Attached SCSI</span></strong><span class="koboSpan" id="kobo.519.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.520.1">SAS</span></strong><span class="koboSpan" id="kobo.521.1">): This is a point-to-point serial protocol interface with transfer rates</span><a id="_idIndexMarker832"/><span class="koboSpan" id="kobo.522.1"> similar to SATA. </span><span class="koboSpan" id="kobo.522.2">It is mostly used in enterprise environments</span><a id="_idIndexMarker833"/><span class="koboSpan" id="kobo.523.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">their reliability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.525.1">Universal Serial Bus</span></strong><span class="koboSpan" id="kobo.526.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.527.1">USB</span></strong><span class="koboSpan" id="kobo.528.1">): This is used for external hard drives</span><a id="_idIndexMarker834"/><span class="koboSpan" id="kobo.529.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">memory </span></span><span class="No-Break"><a id="_idIndexMarker835"/></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">drives.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.532.1">Each disk has a specific geometry that consists of heads, cylinders, tracks, and sectors. </span><span class="koboSpan" id="kobo.532.2">On a Linux system, to see the information regarding a disk’s geometry, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">fdisk -</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">l</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">On our primary workstation, we have a single SSD running Debian 12 GNU/Linux and a USB device inserted in one of the ports. </span><span class="koboSpan" id="kobo.536.2">We will run the following command to obtain information about the drives on </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">our machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
sudo fdisk -l</span></pre> <p><span class="koboSpan" id="kobo.539.1">The following screenshot shows excerpts of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">fdisk</span></strong><span class="koboSpan" id="kobo.541.1"> command’s output for </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">both drives:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.543.1"><img alt="Figure 6.6 – The output of the fdisk -l command showing disk information" src="image/B19682_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.544.1">Figure 6.6 – The output of the fdisk -l command showing disk information</span></p>
<p><span class="koboSpan" id="kobo.545.1">The output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">fdisk</span></strong><span class="koboSpan" id="kobo.547.1"> utility may look intimidating</span><a id="_idIndexMarker836"/><span class="koboSpan" id="kobo.548.1"> at first, but rest assured that we will explain it to you so that it will look friendlier from now on. </span><span class="koboSpan" id="kobo.548.2">By using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">fdisk</span></strong><span class="koboSpan" id="kobo.550.1"> utility without a specific partition as an argument, all the partition information available inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">/proc/partitions</span></strong><span class="koboSpan" id="kobo.552.1"> will be shown. </span><span class="koboSpan" id="kobo.552.2">In the example shown in the preceding screenshot, you have details on two disks that are available on our system: a 1 TB Lexar NM620 SSD and an 8 GB USB flash drive attached. </span><span class="koboSpan" id="kobo.552.3">Let’s explain how the 1 TB drive </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">is shown:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.554.1">First, you have </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">Disk model</span></strong><span class="koboSpan" id="kobo.556.1"> with the name of the drive, </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">Units</span></strong><span class="koboSpan" id="kobo.558.1"> as sectors, each of which has a size of 512 bytes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">Disklabel type</span></strong><span class="koboSpan" id="kobo.560.1"> as GPT, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">Disk identifier</span></strong><span class="koboSpan" id="kobo.562.1">, which is unique for </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">each drive.</span></span></li>
<li><span class="koboSpan" id="kobo.564.1">Next is a table of the partitions available on the disk. </span><span class="koboSpan" id="kobo.564.2">This table has six columns (sometimes seven columns, as in the case of the USB flash drive, shown on the lower side of the screenshot). </span><span class="koboSpan" id="kobo.564.3">The first column has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Device</span></strong><span class="koboSpan" id="kobo.566.1"> header and shows the partition naming scheme. </span><span class="koboSpan" id="kobo.566.2">The second and third columns (in our example) show the starting and ending sectors. </span><span class="koboSpan" id="kobo.566.3">The fourth column shows the total number of sectors on the partition. </span><span class="koboSpan" id="kobo.566.4">The fifth column shows the size of the partition in human-readable format and the last column shows the type of </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">the filesystem.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.568.1">Knowing basic information about disk devices</span><a id="_idIndexMarker837"/><span class="koboSpan" id="kobo.569.1"> on your system is merely the starting point for working with disks and partitions on Linux. </span><span class="koboSpan" id="kobo.569.2">Disks are just a big chunk of metal if we don’t format and partition them so that the system can use them. </span><span class="koboSpan" id="kobo.569.3">This is why, in the next section, we will teach you what </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">partitions are.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.571.1">Partitioning disks</span></h2>
<p><span class="koboSpan" id="kobo.572.1">Commonly, disks use </span><strong class="bold"><span class="koboSpan" id="kobo.573.1">partitions</span></strong><span class="koboSpan" id="kobo.574.1">. </span><span class="koboSpan" id="kobo.574.2">To understand partitions, knowing</span><a id="_idIndexMarker838"/><span class="koboSpan" id="kobo.575.1"> a disk’s geometry is essential. </span><span class="koboSpan" id="kobo.575.2">This legacy knowledge base is useful even when dealing with SSDs. </span><span class="koboSpan" id="kobo.575.3">Partitions are contiguous sets of sectors and/or cylinders, and they can be of several types: </span><strong class="bold"><span class="koboSpan" id="kobo.576.1">primary</span></strong><span class="koboSpan" id="kobo.577.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.578.1">extended</span></strong><span class="koboSpan" id="kobo.579.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.580.1">logical</span></strong><span class="koboSpan" id="kobo.581.1"> partitions. </span><span class="koboSpan" id="kobo.581.2">A maximum number of 15 partitions can exist</span><a id="_idIndexMarker839"/><span class="koboSpan" id="kobo.582.1"> on a disk. </span><span class="koboSpan" id="kobo.582.2">The first</span><a id="_idIndexMarker840"/><span class="koboSpan" id="kobo.583.1"> four will be either</span><a id="_idIndexMarker841"/><span class="koboSpan" id="kobo.584.1"> primary or extended, and the remaining are logical partitions. </span><span class="koboSpan" id="kobo.584.2">Furthermore, there can only be a single extended partition, but they can be divided into several logical partitions until the maximum number </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">is reached.</span></span></p>
<h3><span class="koboSpan" id="kobo.586.1">Partition types</span></h3>
<p><span class="koboSpan" id="kobo.587.1">There are two</span><a id="_idIndexMarker842"/><span class="koboSpan" id="kobo.588.1"> major partition types – the </span><strong class="bold"><span class="koboSpan" id="kobo.589.1">Master Boot Record</span></strong><span class="koboSpan" id="kobo.590.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.591.1">MBR</span></strong><span class="koboSpan" id="kobo.592.1">) and the </span><strong class="bold"><span class="koboSpan" id="kobo.593.1">GUID Partition Table</span></strong><span class="koboSpan" id="kobo.594.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.595.1">GPT</span></strong><span class="koboSpan" id="kobo.596.1">). </span><span class="koboSpan" id="kobo.596.2">MBR was intensively used</span><a id="_idIndexMarker843"/><span class="koboSpan" id="kobo.597.1"> up to around 2010. </span><span class="koboSpan" id="kobo.597.2">Its limitations</span><a id="_idIndexMarker844"/><span class="koboSpan" id="kobo.598.1"> include the maximum number of primary partitions (four) and the maximum size of a partition (2 TB). </span><span class="koboSpan" id="kobo.598.2">MBR uses hexadecimal codes for different types of partitions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">0x0c</span></strong><span class="koboSpan" id="kobo.600.1"> for FAT, </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">0x07</span></strong><span class="koboSpan" id="kobo.602.1"> for NTFS, </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">0x83</span></strong><span class="koboSpan" id="kobo.604.1"> for a Linux filesystem type, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">0x82</span></strong><span class="koboSpan" id="kobo.606.1"> for swap. </span><span class="koboSpan" id="kobo.606.2">GPT became a part of the </span><strong class="bold"><span class="koboSpan" id="kobo.607.1">Unified Extensible Firmware Interface</span></strong><span class="koboSpan" id="kobo.608.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.609.1">UEFI</span></strong><span class="koboSpan" id="kobo.610.1">) standard as a solution to some issues with</span><a id="_idIndexMarker845"/><span class="koboSpan" id="kobo.611.1"> MBR, including partition limitations, addressing methods, using only one copy of the partition table, and so on. </span><span class="koboSpan" id="kobo.611.2">It supports up to 128 partitions and disk sizes of up to 75.6 </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.612.1">Zettabytes</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.614.1">ZB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.616.1">The partition table</span></h3>
<p><span class="koboSpan" id="kobo.617.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.618.1">partition table</span></strong><span class="koboSpan" id="kobo.619.1"> of a disk is stored inside the disk’s MBR. </span><span class="koboSpan" id="kobo.619.2">MBR</span><a id="_idIndexMarker846"/><span class="koboSpan" id="kobo.620.1"> is the first 512 bytes of a drive. </span><span class="koboSpan" id="kobo.620.2">Out </span><a id="_idIndexMarker847"/><span class="koboSpan" id="kobo.621.1">of these, the partition table is 64 bytes and is stored</span><a id="_idIndexMarker848"/><span class="koboSpan" id="kobo.622.1"> after the first 446 bytes of records. </span><span class="koboSpan" id="kobo.622.2">At the end of MBR, there are 2 bytes known as the end of sector marker. </span><span class="koboSpan" id="kobo.622.3">The first 446 bytes are reserved for code that usually belongs to a bootloader</span><a id="_idIndexMarker849"/><span class="koboSpan" id="kobo.623.1"> program. </span><span class="koboSpan" id="kobo.623.2">In the case of Linux, the bootloader is called </span><strong class="bold"><span class="koboSpan" id="kobo.624.1">GRand Unified </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.625.1">Bootloader</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.627.1">GRUB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">When you boot up a Linux system, the bootloader looks for the active partition. </span><span class="koboSpan" id="kobo.629.2">There can only be one active partition on a single disk. </span><span class="koboSpan" id="kobo.629.3">When the active partition is located, the bootloader loads items. </span><span class="koboSpan" id="kobo.629.4">The partition table has 4 entries, each of which is 16 bytes in size, with each belonging to a possible primary partition on the system. </span><span class="koboSpan" id="kobo.629.5">Furthermore, each entry contains information regarding the beginning address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">cylinder/head/sectors</span></strong><span class="koboSpan" id="kobo.631.1">, the partition type code, the end address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">cylinder/head/sectors</span></strong><span class="koboSpan" id="kobo.633.1">, the starting sector, and the number of sectors inside </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">one partition.</span></span></p>
<h3><span class="koboSpan" id="kobo.635.1">Naming partitions</span></h3>
<p><span class="koboSpan" id="kobo.636.1">The kernel interacts with the disk</span><a id="_idIndexMarker850"/><span class="koboSpan" id="kobo.637.1"> at a low level. </span><span class="koboSpan" id="kobo.637.2">This is done through device nodes that are stored inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">/dev</span></strong><span class="koboSpan" id="kobo.639.1"> directory. </span><span class="koboSpan" id="kobo.639.2">Device nodes use a simple naming convention that tells you which disk is the one that requires your attention. </span><span class="koboSpan" id="kobo.639.3">Looking</span><a id="_idIndexMarker851"/><span class="koboSpan" id="kobo.640.1"> at the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">/dev</span></strong><span class="koboSpan" id="kobo.642.1"> directory, you can see all the available disk nodes, also referred to as disk drives, in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.643.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.644.1">.2</span></em><span class="koboSpan" id="kobo.645.1"> and </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.646.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.647.1">.3</span></em><span class="koboSpan" id="kobo.648.1"> earlier in this section. </span><span class="koboSpan" id="kobo.648.2">A short explanation is always useful, so disks and partitions are recognized </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.650.1">The first hard drive is always </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">/dev/sda</span></strong><span class="koboSpan" id="kobo.652.1"> (for an SCSI or </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">SATA device)</span></span></li>
<li><span class="koboSpan" id="kobo.654.1">The second hard drive is </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">/dev/sdb</span></strong><span class="koboSpan" id="kobo.656.1">, the third is </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">/dev/sdc</span></strong><span class="koboSpan" id="kobo.658.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">so on</span></span></li>
<li><span class="koboSpan" id="kobo.660.1">The first partition of the first disk </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">/dev/sda1</span></strong></span></li>
<li><span class="koboSpan" id="kobo.663.1">The first partition of the second disk </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">/dev/sdb1</span></strong></span></li>
<li><span class="koboSpan" id="kobo.666.1">The second partition of the second disk is </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">/dev/sdb2</span></strong><span class="koboSpan" id="kobo.668.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">so on</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.670.1">We specified that this is true</span><a id="_idIndexMarker852"/><span class="koboSpan" id="kobo.671.1"> in the case of an SCSI and SATA, and we need to explain this in a little more detail. </span><span class="koboSpan" id="kobo.671.2">The kernel gives the letter designation, such as </span><em class="italic"><span class="koboSpan" id="kobo.672.1">a</span></em><span class="koboSpan" id="kobo.673.1">, </span><em class="italic"><span class="koboSpan" id="kobo.674.1">b</span></em><span class="koboSpan" id="kobo.675.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.676.1">c</span></em><span class="koboSpan" id="kobo.677.1">, based on the ID number of the SCSI device, and not based on the position of the </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">hardware bus.</span></span></p>
<h3><span class="koboSpan" id="kobo.679.1">Partition attributes</span></h3>
<p><span class="koboSpan" id="kobo.680.1">To learn about your partition’s attributes, you</span><a id="_idIndexMarker853"/><span class="koboSpan" id="kobo.681.1"> can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">lsblk</span></strong><span class="koboSpan" id="kobo.683.1"> command. </span><span class="koboSpan" id="kobo.683.2">We will run it on our Debian system, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.685.1"><img alt="Figure 6.7 – The output of lsblk" src="image/B19682_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.686.1">Figure 6.7 – The output of lsblk</span></p>
<p><span class="koboSpan" id="kobo.687.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">lsblk</span></strong><span class="koboSpan" id="kobo.689.1"> command shows the device’s name (the node’s name from </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">sysfs</span></strong><span class="koboSpan" id="kobo.691.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">udev</span></strong><span class="koboSpan" id="kobo.693.1"> database), the major and minor device number, the removable state of the device (</span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">0</span></strong><span class="koboSpan" id="kobo.695.1"> for a non-removable device and </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">1</span></strong><span class="koboSpan" id="kobo.697.1"> for a removable device), the size in human-readable format, the read-only state (again, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">0</span></strong><span class="koboSpan" id="kobo.699.1"> for the ones that are not read-only and </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">1</span></strong><span class="koboSpan" id="kobo.701.1"> for the read-only ones), the type</span><a id="_idIndexMarker854"/><span class="koboSpan" id="kobo.702.1"> of device, and the device’s mount point (</span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">where available).</span></span></p>
<p><span class="koboSpan" id="kobo.704.1">Now that we know more about the drive, let’s learn how to alter a disk’s </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">partition table.</span></span></p>
<h3><span class="koboSpan" id="kobo.706.1">Partition table editors</span></h3>
<p><span class="koboSpan" id="kobo.707.1">In Linux, there are several tools</span><a id="_idIndexMarker855"/><span class="koboSpan" id="kobo.708.1"> we can use when managing partition tables. </span><span class="koboSpan" id="kobo.708.2">Among the most commonly used ones are </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">fdisk</span></strong><span class="koboSpan" id="kobo.711.1">: A command-line partition editor, perhaps the most widely </span><span class="No-Break"><span class="koboSpan" id="kobo.712.1">used one</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Sfdisk</span></strong><span class="koboSpan" id="kobo.714.1">: A non-interactive partition editor, used mostly </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">in scripting</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">parted</span></strong><span class="koboSpan" id="kobo.717.1">: The GNU (the recursive acronym for GNU is </span><em class="italic"><span class="koboSpan" id="kobo.718.1">GNU's Not Unix</span></em><span class="koboSpan" id="kobo.719.1">) partition </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">manipulation software</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">gparted</span></strong><span class="koboSpan" id="kobo.722.1">: The graphical interface </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">parted</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.725.1">Of these, we will only detail how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">fdisk</span></strong><span class="koboSpan" id="kobo.727.1"> as this is the most widely used command-line partition editor in Linux. </span><span class="koboSpan" id="kobo.727.2">It is found in both Ubuntu/Debian and RHEL/Fedora or openSUSE and many other </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">distributions too.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">But before we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">fdisk</span></strong><span class="koboSpan" id="kobo.731.1">, we would like to see the partitions that the operating system knows about. </span><span class="koboSpan" id="kobo.731.2">If you are not sure about the operations you just completed, you can always visualize the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">/proc/partitions</span></strong><span class="koboSpan" id="kobo.733.1"> file with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">cat</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.735.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.736.1"><img alt="Figure 6.8 – Listing the /proc/partitions file" src="image/B19682_06_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.737.1">Figure 6.8 – Listing the /proc/partitions file</span></p>
<p><span class="koboSpan" id="kobo.738.1">To use </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">fdisk</span></strong><span class="koboSpan" id="kobo.740.1">, you must be the root user. </span><span class="koboSpan" id="kobo.740.2">We advise you to use caution when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">fdisk</span></strong><span class="koboSpan" id="kobo.742.1"> as it can damage your existing partitions and disks. </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">fdisk</span></strong><span class="koboSpan" id="kobo.744.1"> can be used on a particular disk </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 6.9 – Using fdisk for the first time" src="image/B19682_06_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 6.9 – Using fdisk for the first time</span></p>
<p><span class="koboSpan" id="kobo.748.1">You will notice that when using </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">fdisk</span></strong><span class="koboSpan" id="kobo.750.1"> for the first time, you are warned that changes will be done to the disk only when you decide to write them to it. </span><span class="koboSpan" id="kobo.750.2">You will also be prompted to introduce a command, and you will be shown the </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">m</span></strong><span class="koboSpan" id="kobo.752.1"> option for help. </span><span class="koboSpan" id="kobo.752.2">We advise you to always use the help menu, even if you already know the most </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">used commands.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">When you type </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">m</span></strong><span class="koboSpan" id="kobo.756.1">, you will be shown the entire list of commands available for </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">fdisk</span></strong><span class="koboSpan" id="kobo.758.1">. </span><span class="koboSpan" id="kobo.758.2">You will see options to manage partitions, create new boot records, save changes, and others. </span><span class="koboSpan" id="kobo.758.3">Partition table editors </span><a id="_idIndexMarker856"/><span class="koboSpan" id="kobo.759.1">are important tools for managing disks in Linux. </span><span class="koboSpan" id="kobo.759.2">Their use is incomplete if you do not know how to format a partition. </span><span class="koboSpan" id="kobo.759.3">In the next section, we will show you how to partition a </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">disk drive.</span></span></p>
<h3><span class="koboSpan" id="kobo.761.1">Creating and formatting partitions</span></h3>
<p><span class="koboSpan" id="kobo.762.1">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">fdisk</span></strong><span class="koboSpan" id="kobo.764.1"> utility to create</span><a id="_idIndexMarker857"/><span class="koboSpan" id="kobo.765.1"> a new partition table on a USB memory stick plugged</span><a id="_idIndexMarker858"/><span class="koboSpan" id="kobo.766.1"> into our primary workstation running Debian GNU/Linux. </span><span class="koboSpan" id="kobo.766.2">We will create an MBR partition table using the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.768.1">
sudo fdisk /dev/sda</span></pre> <p><span class="koboSpan" id="kobo.769.1">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">o</span></strong><span class="koboSpan" id="kobo.771.1"> option to create an empty MBR partition table and then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">w</span></strong><span class="koboSpan" id="kobo.773.1"> option to save the changes to disk. </span><span class="koboSpan" id="kobo.773.2">The output of the command is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.775.1"><img alt="Figure 6.10 – Creating a new MBR partition table with fdisk" src="image/B19682_06_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.776.1">Figure 6.10 – Creating a new MBR partition table with fdisk</span></p>
<p><span class="koboSpan" id="kobo.777.1">With that, the partition</span><a id="_idIndexMarker859"/><span class="koboSpan" id="kobo.778.1"> table has been created, but there is no partition defined</span><a id="_idIndexMarker860"/><span class="koboSpan" id="kobo.779.1"> on the disk. </span><span class="koboSpan" id="kobo.779.2">While still inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">fdisk</span></strong><span class="koboSpan" id="kobo.781.1"> command-line interface, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">v</span></strong><span class="koboSpan" id="kobo.783.1"> option to verify the newly created partition table and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">I</span></strong><span class="koboSpan" id="kobo.785.1"> option to see information about existing partitions. </span><span class="koboSpan" id="kobo.785.2">You will see some output saying that no partitions have been defined yet. </span><span class="koboSpan" id="kobo.785.3">So, it is time to set up a </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">new partition.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">To create a new partition, we will use the following series </span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">of options:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.789.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">n</span></strong><span class="koboSpan" id="kobo.791.1"> option to start the </span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">creation processes</span></span></li>
<li><span class="koboSpan" id="kobo.793.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">p</span></strong><span class="koboSpan" id="kobo.795.1"> option when asked to create either a primary (</span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">p</span></strong><span class="koboSpan" id="kobo.797.1">) or extended (</span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">e</span></strong><span class="koboSpan" id="kobo.799.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">partition type</span></span></li>
<li><span class="koboSpan" id="kobo.801.1">Enter the partition number (use the default </span><span class="No-Break"><span class="koboSpan" id="kobo.802.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.805.1">Enter the first sector (use the default </span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">2048</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.809.1">Enter the last sector – if you want a specific size for the partition, you can use size values in KB, MB, GB, and so on, or sector values (the default is the maximum size of </span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">the disk)</span></span></li>
<li><span class="koboSpan" id="kobo.811.1">If asked to remove any signatures, type </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">Y</span></strong><span class="koboSpan" id="kobo.813.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">remove them</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">w</span></strong><span class="koboSpan" id="kobo.816.1"> to write changes </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">to disk</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.818.1">The output of the previous series of actions is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<span class="koboSpan" id="kobo.820.1"><img alt="Figure 6.11 – Creating a new partition with fdisk" src="image/B19682_06_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.821.1">Figure 6.11 – Creating a new partition with fdisk</span></p>
<p><span class="koboSpan" id="kobo.822.1">With that, the partition</span><a id="_idIndexMarker861"/><span class="koboSpan" id="kobo.823.1"> has been created, but it hasn’t been formatted. </span><span class="koboSpan" id="kobo.823.2">Before we learn</span><a id="_idIndexMarker862"/><span class="koboSpan" id="kobo.824.1"> how to format partitions, let’s learn how to back up a </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">partition table.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">There are situations</span><a id="_idIndexMarker863"/><span class="koboSpan" id="kobo.827.1"> when you will need to back up and restore your </span><strong class="bold"><span class="koboSpan" id="kobo.828.1">partition tables</span></strong><span class="koboSpan" id="kobo.829.1">. </span><span class="koboSpan" id="kobo.829.2">As partitioning could go sideways sometimes, a good backup strategy could help you. </span><span class="koboSpan" id="kobo.829.3">To do this, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">dd</span></strong><span class="koboSpan" id="kobo.831.1"> utility. </span><span class="koboSpan" id="kobo.831.2">The command to use is </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.833.1">
sudo dd if=/dev/sda of=mbr-backup bs=512 count=1</span></pre> <p><span class="koboSpan" id="kobo.834.1">This program is very useful and powerful as it can clone disks or wipe data. </span><span class="koboSpan" id="kobo.834.2">Here is an example showing the output of </span><span class="No-Break"><span class="koboSpan" id="kobo.835.1">the command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<span class="koboSpan" id="kobo.836.1"><img alt="Figure 6.12 – Backing up MBR with the dd command" src="image/B19682_06_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.837.1">Figure 6.12 – Backing up MBR with the dd command</span></p>
<p><span class="koboSpan" id="kobo.838.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">dd</span></strong><span class="koboSpan" id="kobo.840.1"> command has a clear</span><a id="_idIndexMarker864"/><span class="koboSpan" id="kobo.841.1"> syntax. </span><span class="koboSpan" id="kobo.841.2">By default, it uses the standard input and standard</span><a id="_idIndexMarker865"/><span class="koboSpan" id="kobo.842.1"> output, but you can change those by specifying new input files with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">if</span></strong><span class="koboSpan" id="kobo.844.1"> option, and output files with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">of</span></strong><span class="koboSpan" id="kobo.846.1"> option. </span><span class="koboSpan" id="kobo.846.2">We specified the input file as the device file for the disk we wanted to back up and gave a name for the backup output file. </span><span class="koboSpan" id="kobo.846.3">We also specified the block size using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">bs</span></strong><span class="koboSpan" id="kobo.848.1"> option, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">count</span></strong><span class="koboSpan" id="kobo.850.1"> option to specify the number of blocks </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">To restore the bootloader, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">dd</span></strong><span class="koboSpan" id="kobo.854.1"> command, </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.856.1">
sudo dd if=~/mbr-backup of=/dev/sda bs=512 count=1</span></pre> <p><span class="koboSpan" id="kobo.857.1">Now that you have learned how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.858.1">dd</span></strong><span class="koboSpan" id="kobo.859.1"> to back up a partition table, let’s format the partition we created earlier. </span><span class="koboSpan" id="kobo.859.2">The most commonly used program for formatting a filesystem on a partition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.860.1">mkfs</span></strong><span class="koboSpan" id="kobo.861.1">. </span><span class="koboSpan" id="kobo.861.2">Formatting a partition is also known as </span><em class="italic"><span class="koboSpan" id="kobo.862.1">making</span></em><span class="koboSpan" id="kobo.863.1"> a filesystem, hence the name of the utility. </span><span class="koboSpan" id="kobo.863.2">It has specific tools for different filesystems, all using the same frontend utility. </span><span class="koboSpan" id="kobo.863.3">The following is a list of all filesystems supported </span><span class="No-Break"><span class="koboSpan" id="kobo.864.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">mkfs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<span class="koboSpan" id="kobo.867.1"><img alt="Figure 6.13 – Details regarding the mkfs utility" src="image/B19682_06_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.868.1">Figure 6.13 – Details regarding the mkfs utility</span></p>
<p><span class="koboSpan" id="kobo.869.1">To format the target disk </span><a id="_idIndexMarker866"/><span class="koboSpan" id="kobo.870.1">as having the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">Ext4</span></strong><span class="koboSpan" id="kobo.872.1"> filesystem, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">mkfs</span></strong><span class="koboSpan" id="kobo.874.1"> utility. </span><span class="koboSpan" id="kobo.874.2">The commands</span><a id="_idIndexMarker867"/><span class="koboSpan" id="kobo.875.1"> to execute are </span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">shown here:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.877.1">First, we will run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">fdisk</span></strong><span class="koboSpan" id="kobo.879.1"> utility to make sure that we select the largest disk correctly. </span><span class="koboSpan" id="kobo.879.2">Run the </span><span class="No-Break"><span class="koboSpan" id="kobo.880.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.881.1">sudo fdisk -l</span></strong></pre></li> <li><span class="koboSpan" id="kobo.882.1">Then, check the output with extreme caution and select the correct </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">disk name.</span></span></li>
<li><span class="koboSpan" id="kobo.884.1">Now that we know which disk to work with, we will use </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">mkfs</span></strong><span class="koboSpan" id="kobo.886.1"> to format it as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">Ext4</span></strong><span class="koboSpan" id="kobo.888.1"> filesystem. </span><span class="koboSpan" id="kobo.888.2">The output is </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">shown here:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer173">
<span class="koboSpan" id="kobo.890.1"><img alt="Figure 6.14 – Formatting an Ext4 partition using mkfs" src="image/B19682_06_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.891.1">Figure 6.14 – Formatting an Ext4 partition using mkfs</span></p>
<p><span class="koboSpan" id="kobo.892.1">When using </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">mkfs</span></strong><span class="koboSpan" id="kobo.894.1">, there are several options available. </span><span class="koboSpan" id="kobo.894.2">To create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Ext4</span></strong><span class="koboSpan" id="kobo.896.1"> type partition, you can either use the command </span><a id="_idIndexMarker868"/><span class="koboSpan" id="kobo.897.1">shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.898.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.899.1">.14</span></em><span class="koboSpan" id="kobo.900.1"> or you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">-t</span></strong><span class="koboSpan" id="kobo.902.1"> option followed by the filesystem</span><a id="_idIndexMarker869"/><span class="koboSpan" id="kobo.903.1"> type. </span><span class="koboSpan" id="kobo.903.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">-v</span></strong><span class="koboSpan" id="kobo.905.1"> option for a more verbose output, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">-c</span></strong><span class="koboSpan" id="kobo.907.1"> option for bad sector scanning while creating the filesystem. </span><span class="koboSpan" id="kobo.907.2">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">-L</span></strong><span class="koboSpan" id="kobo.909.1"> option if you want to add a label for the partition right from the command. </span><span class="koboSpan" id="kobo.909.2">The following is an example of creating an </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">Ext4</span></strong><span class="koboSpan" id="kobo.911.1"> filesystem partition with the </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">name </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.913.1">newpartition</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.914.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.915.1">
sudo mkfs -t ext4 -v -c -L newpartition /dev/sda</span></pre> <p><span class="koboSpan" id="kobo.916.1">Once a partition is formatted, it’s advised</span><a id="_idIndexMarker870"/><span class="koboSpan" id="kobo.917.1"> that you check it for errors. </span><span class="koboSpan" id="kobo.917.2">Similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">mkfs</span></strong><span class="koboSpan" id="kobo.919.1">, there is a tool called </span><strong class="source-inline"><span class="koboSpan" id="kobo.920.1">fsck</span></strong><span class="koboSpan" id="kobo.921.1">. </span><span class="koboSpan" id="kobo.921.2">This is a utility that sometimes</span><a id="_idIndexMarker871"/><span class="koboSpan" id="kobo.922.1"> runs automatically following an abnormal shutdown or on set intervals. </span><span class="koboSpan" id="kobo.922.2">It has specific programs for the most commonly used filesystems, just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.923.1">mkfs</span></strong><span class="koboSpan" id="kobo.924.1">. </span><span class="koboSpan" id="kobo.924.2">The following is the output of running </span><strong class="source-inline"><span class="koboSpan" id="kobo.925.1">fsck</span></strong><span class="koboSpan" id="kobo.926.1"> on one of our partitions. </span><span class="koboSpan" id="kobo.926.2">After running, it will show whether there are any problems. </span><span class="koboSpan" id="kobo.926.3">In the following screenshot, the output shows that checking the partition resulted in </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">no errors:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<span class="koboSpan" id="kobo.928.1"><img alt="Figure 6.15 – Using fsck to check a partition" src="image/B19682_06_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.929.1">Figure 6.15 – Using fsck to check a partition</span></p>
<p><span class="koboSpan" id="kobo.930.1">After partitions are created, they need to be mounted; otherwise, they cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">be used.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.932.1">Important note</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.933.1">Mounting</span></strong><span class="koboSpan" id="kobo.934.1"> is an important action in Linux, and any other operating system</span><a id="_idIndexMarker872"/><span class="koboSpan" id="kobo.935.1"> for that matter. </span><span class="koboSpan" id="kobo.935.2">By mounting, you give the operating system access to the disk resource in such a way that it looks like it is using a local disk. </span><span class="koboSpan" id="kobo.935.3">On Linux, the external disk that is mounted is linked to a mount point, which is a directory on the local filesystem. </span><span class="koboSpan" id="kobo.935.4">Mount points are essential to POSIX-compatible operating systems, such as Linux. </span><span class="koboSpan" id="kobo.935.5">Mounting a disk makes it accessible</span><a id="_idIndexMarker873"/><span class="koboSpan" id="kobo.936.1"> to the entire operating system through mount points. </span><span class="koboSpan" id="kobo.936.2">For more information on mounting, </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">visit </span></span><a href="https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html"><span class="No-Break"><span class="koboSpan" id="kobo.938.1">https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.939.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.940.1">Each partition will be mounted inside the existing filesystem structure. </span><span class="koboSpan" id="kobo.940.2">Mounting is allowed at any point in the tree structure. </span><span class="koboSpan" id="kobo.940.3">Each filesystem is mounted</span><a id="_idIndexMarker874"/><span class="koboSpan" id="kobo.941.1"> under certain directories, created inside the directory</span><a id="_idIndexMarker875"/><span class="koboSpan" id="kobo.942.1"> structure. </span><span class="koboSpan" id="kobo.942.2">We will explore mounting and unmounting partitions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">next section.</span></span></p>
<h3><span class="koboSpan" id="kobo.944.1">Mounting and unmounting partitions</span></h3>
<p><span class="koboSpan" id="kobo.945.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.946.1">mounting</span></strong><span class="koboSpan" id="kobo.947.1"> utility in Linux is simply </span><a id="_idIndexMarker876"/><span class="koboSpan" id="kobo.948.1">called </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">mount</span></strong><span class="koboSpan" id="kobo.950.1">, and the </span><strong class="bold"><span class="koboSpan" id="kobo.951.1">unmounting</span></strong><span class="koboSpan" id="kobo.952.1"> utility is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">umount</span></strong><span class="koboSpan" id="kobo.954.1">. </span><span class="koboSpan" id="kobo.954.2">To see whether</span><a id="_idIndexMarker877"/><span class="koboSpan" id="kobo.955.1"> a certain partition is mounted, you can simply type </span><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">mount</span></strong><span class="koboSpan" id="kobo.957.1"> and see the output, which will be of a significant size. </span><span class="koboSpan" id="kobo.957.2">You can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">grep</span></strong><span class="koboSpan" id="kobo.959.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">filter it:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.961.1">
mount | grep /dev/sda</span></pre> <p><span class="koboSpan" id="kobo.962.1">We are looking for </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">/dev/sda</span></strong><span class="koboSpan" id="kobo.964.1"> in the output, but it is not shown. </span><span class="koboSpan" id="kobo.964.2">This means that the drive is </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">not mounted.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">To mount it, we need to make a new directory. </span><span class="koboSpan" id="kobo.966.2">For simplicity, we will show all the steps required until you mount and use </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">the partition:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.968.1">Create a new directory to mount the partition. </span><span class="koboSpan" id="kobo.968.2">In our case, we created a new directory called </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">USB</span></strong><span class="koboSpan" id="kobo.970.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">home/alexandru</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1"> directory:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.974.1">mkdir USB</span></strong></pre></li> <li><span class="koboSpan" id="kobo.975.1">Mount the partition using the </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.977.1">sudo mount /dev/sda /home/alexandru/USB</span></strong></pre></li> <li><span class="koboSpan" id="kobo.978.1">Start using the new partition from the new location. </span><span class="koboSpan" id="kobo.978.2">As an example, we will copy the </span><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">mbr-backup</span></strong><span class="koboSpan" id="kobo.980.1"> file we created a few steps back to the newly mounted USB memory stick using the </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.982.1">sudo cp mbr-backup USB/</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.983.1">The following is the output for all the commands from the </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">preceding list:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<span class="koboSpan" id="kobo.985.1"><img alt="Figure 6.16 – Mounting an external memory stick" src="image/B19682_06_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.986.1">Figure 6.16 – Mounting an external memory stick</span></p>
<p><span class="koboSpan" id="kobo.987.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.988.1">mount</span></strong><span class="koboSpan" id="kobo.989.1"> command needs </span><a id="_idIndexMarker878"/><span class="koboSpan" id="kobo.990.1">to be used with superuser permission. </span><span class="koboSpan" id="kobo.990.2">If you try to mount</span><a id="_idIndexMarker879"/><span class="koboSpan" id="kobo.991.1"> an external USB device without </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">sudo</span></strong><span class="koboSpan" id="kobo.993.1">, you will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">following message:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<span class="koboSpan" id="kobo.995.1"><img alt="Figure 6.17 – Error for not using sudo with mount" src="image/B19682_06_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.996.1">Figure 6.17 – Error for not using sudo with mount</span></p>
<p><span class="koboSpan" id="kobo.997.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">mount</span></strong><span class="koboSpan" id="kobo.999.1"> utility has many options available. </span><span class="koboSpan" id="kobo.999.2">Use the help menu to see everything that it has under the hood. </span><span class="koboSpan" id="kobo.999.3">Now that the partition has been mounted, you can start using it. </span><span class="koboSpan" id="kobo.999.4">If you want to unmount it, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">umount</span></strong><span class="koboSpan" id="kobo.1001.1"> utility. </span><span class="koboSpan" id="kobo.1001.2">You can use it </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1003.1">
sudo umount /dev/sda</span></pre> <p><span class="koboSpan" id="kobo.1004.1">When unmounting a filesystem, you may receive errors if that partition is still in use. </span><span class="koboSpan" id="kobo.1004.2">Being in use means that certain programs from that filesystem are still running in memory, using files from that partition. </span><span class="koboSpan" id="kobo.1004.3">Therefore, you first have to close all running applications, and if other processes are using that filesystem, you will have to kill them, too. </span><span class="koboSpan" id="kobo.1004.4">Sometimes, the reason a filesystem is busy is not clear at first, and to know which files are open and running, you can use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">lsof</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1007.1">
sudo lsof | grep /dev/sda</span></pre> <p><span class="koboSpan" id="kobo.1008.1">Mounting a filesystem only makes it available until the system is shut down or rebooted. </span><span class="koboSpan" id="kobo.1008.2">If you want the changes to be persistent, you will have to edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1010.1"> file accordingly. </span><span class="koboSpan" id="kobo.1010.2">First, open the file with your favorite </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">text editor:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1012.1">
sudo nano /etc/fstab</span></pre> <p><span class="koboSpan" id="kobo.1013.1">Add a new line similar to the one </span><span class="No-Break"><span class="koboSpan" id="kobo.1014.1">that follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1015.1">
/dev/sda /mnt/sdb ext4 defaults 0 0</span></pre> <p><span class="koboSpan" id="kobo.1016.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1018.1"> file is a configuration file for the filesystem table. </span><span class="koboSpan" id="kobo.1018.2">It consists of a set of rules needed to control how the filesystems are used. </span><span class="koboSpan" id="kobo.1018.3">This simplifies the need to manually mount and unmount each disk when used, by drastically reducing possible errors. </span><span class="koboSpan" id="kobo.1018.4">The table has a six-column structure, with each column designated with a specific parameter. </span><span class="koboSpan" id="kobo.1018.5">There is only one correct order for the parameters </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">to work:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1020.1">Device name</span></strong><span class="koboSpan" id="kobo.1021.1">: Either by using UUID or the mounted </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">device name</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1023.1">Mount point</span></strong><span class="koboSpan" id="kobo.1024.1">: The directory where the device is, or will </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">be, mounted</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1026.1">Filesystem type</span></strong><span class="koboSpan" id="kobo.1027.1">: The filesystem </span><span class="No-Break"><span class="koboSpan" id="kobo.1028.1">type used</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1029.1">Options</span></strong><span class="koboSpan" id="kobo.1030.1">: The options shown, with multiple ones separated </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">by commas</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1032.1">Backup operation</span></strong><span class="koboSpan" id="kobo.1033.1">: This is the first digit from the last two digits in the file; </span><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">0</span></strong><span class="koboSpan" id="kobo.1035.1"> = no backup, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">1</span></strong><span class="koboSpan" id="kobo.1037.1"> = dump </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">utility backup</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1039.1">Filesystem check order</span></strong><span class="koboSpan" id="kobo.1040.1">: This is the last digit inside the file; </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">0</span></strong><span class="koboSpan" id="kobo.1042.1"> = no </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">fsck</span></strong><span class="koboSpan" id="kobo.1044.1"> filesystem check, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">1</span></strong><span class="koboSpan" id="kobo.1046.1"> for the root filesystem, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">2</span></strong><span class="koboSpan" id="kobo.1048.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1049.1">other partitions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1050.1">By updating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1052.1"> file, the mounting is permanent and is not affected by any shutdown or system reboot. </span><span class="koboSpan" id="kobo.1052.2">Usually, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1054.1"> file only stores information about the internal hard</span><a id="_idIndexMarker880"/><span class="koboSpan" id="kobo.1055.1"> drive partitions and filesystems. </span><span class="koboSpan" id="kobo.1055.2">The external hard drives or USB drives are automatically mounted under </span><strong class="source-inline"><span class="koboSpan" id="kobo.1056.1">/media</span></strong><span class="koboSpan" id="kobo.1057.1"> by the kernel’s </span><strong class="bold"><span class="koboSpan" id="kobo.1058.1">hardware abstraction </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1059.1">layer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1061.1">HAL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">By now, you should be comfortable</span><a id="_idIndexMarker881"/><span class="koboSpan" id="kobo.1064.1"> with managing partitions in Linux, but there is still one type </span><a id="_idIndexMarker882"/><span class="koboSpan" id="kobo.1065.1">of partition we have not discussed: the </span><strong class="bold"><span class="koboSpan" id="kobo.1066.1">swap partition</span></strong><span class="koboSpan" id="kobo.1067.1">. </span><span class="koboSpan" id="kobo.1067.2">In the next section, we will introduce you to how swap works </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">on Linux.</span></span></p>
<h3><span class="koboSpan" id="kobo.1069.1">Swap partition</span></h3>
<p><span class="koboSpan" id="kobo.1070.1">Linux uses a robust swap implementation. </span><span class="koboSpan" id="kobo.1070.2">The virtual memory</span><a id="_idIndexMarker883"/><span class="koboSpan" id="kobo.1071.1"> uses hard drive space when physical memory is full through swap. </span><span class="koboSpan" id="kobo.1071.2">This additional space is made available either for the programs that do not use all the memory they are given, or when memory pressure is high. </span><span class="koboSpan" id="kobo.1071.3">Swapping is usually done using one or more dedicated partitions as Linux permits multiple swap areas. </span><span class="koboSpan" id="kobo.1071.4">The recommended swap size is at least the total RAM on the system. </span><span class="koboSpan" id="kobo.1071.5">To check the actual swap used on the system, you can concatenate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">/proc/swaps</span></strong><span class="koboSpan" id="kobo.1073.1"> file or use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">free</span></strong><span class="koboSpan" id="kobo.1075.1"> command to see swap utilization, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<span class="koboSpan" id="kobo.1077.1"><img alt="Figure 6.18 – Checking the currently used swap" src="image/B19682_06_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1078.1">Figure 6.18 – Checking the currently used swap</span></p>
<p><span class="koboSpan" id="kobo.1079.1">If swap is not set up on your system, you can format a partition as swap and activate it. </span><span class="koboSpan" id="kobo.1079.2">The commands to do that are </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1081.1">
mkswap /dev/sda1
swapon /dev/sda1</span></pre> <p><span class="koboSpan" id="kobo.1082.1">The operating system is caching file contents inside the memory to prevent the use of swap as much as possible. </span><span class="koboSpan" id="kobo.1082.2">This happens because memory is working at much higher speeds compared to hard drives or hard disk drives. </span><span class="koboSpan" id="kobo.1082.3">Only when available memory is limited will swap be used. </span><span class="koboSpan" id="kobo.1082.4">However, the memory that the kernel uses is never swapped; only the memory that the user space is using gets to be swapped. </span><span class="koboSpan" id="kobo.1082.5">This assures data integrity for the kernel. </span><span class="koboSpan" id="kobo.1082.6">Refer to the utilities we applied in </span><a href="B19682_05.xhtml#_idTextAnchor104"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1083.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.1084.1"> to show memory usage </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">in Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.1086.1">Filesystems and partitions</span><a id="_idIndexMarker884"/><span class="koboSpan" id="kobo.1087.1"> are the bare bones of any disk management task, but there are still several hiccups that an administrator needs to overcome, and this can be solved by using logical volumes. </span><span class="koboSpan" id="kobo.1087.2">This is why, in the next section, we will introduce you </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">to LVM.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.1089.1">Introducing LVM in Linux</span></h1>
<p><span class="koboSpan" id="kobo.1090.1">Some of you may have already heard of </span><strong class="bold"><span class="koboSpan" id="kobo.1091.1">LVM</span></strong><span class="koboSpan" id="kobo.1092.1">. </span><span class="koboSpan" id="kobo.1092.2">For those who do not know what</span><a id="_idIndexMarker885"/><span class="koboSpan" id="kobo.1093.1"> it is, we will explain it briefly in this section. </span><span class="koboSpan" id="kobo.1093.2">Imagine a situation where your disks run out of space. </span><span class="koboSpan" id="kobo.1093.3">You can always move it to a larger disk and then replace the smaller one, but this implies system restarts and unwanted downtimes. </span><span class="koboSpan" id="kobo.1093.4">As a solution, you can consider LVM, which offers more flexibility and efficiency. </span><span class="koboSpan" id="kobo.1093.5">By using LVM, you can add more physical disks to your existing volume groups while they’re still in use. </span><span class="koboSpan" id="kobo.1093.6">This still offers the possibility to move data to a new hard drive but with no downtime – everything is done while filesystems </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">are online.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">The utilities used in Linux for LVM management are called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">pvcreate</span></strong><span class="koboSpan" id="kobo.1097.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">vgcreate</span></strong><span class="koboSpan" id="kobo.1099.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">vgdisplay</span></strong><span class="koboSpan" id="kobo.1101.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1102.1">lvcreate</span></strong><span class="koboSpan" id="kobo.1103.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">lvextend</span></strong><span class="koboSpan" id="kobo.1105.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">lvdisplay</span></strong><span class="koboSpan" id="kobo.1107.1">. </span><span class="koboSpan" id="kobo.1107.2">Let’s learn how to </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">use them.</span></span></p>
<p><span class="koboSpan" id="kobo.1109.1">As we don’t have a system with LVM </span><a id="_idIndexMarker886"/><span class="koboSpan" id="kobo.1110.1">set up just yet, we will show you the steps that are necessary to create new LVM volumes by using another system with two internal drives: one with the operating system installed on it, and a second, internal one that’s available. </span><span class="koboSpan" id="kobo.1110.2">We’ll be using Debian GNU/Linux, but the commands are the same for any other Linux-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1111.1">operating system.</span></span></p>
<p><span class="koboSpan" id="kobo.1112.1">Follow these steps to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">LVM volume:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1114.1">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">fdisk</span></strong><span class="koboSpan" id="kobo.1116.1"> command to verify the names of the available disks (you can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">lsblk</span></strong><span class="koboSpan" id="kobo.1118.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">this step):</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1120.1">sudo fdisk -l</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1121.1">In our case, the second drive </span><span class="No-Break"><span class="koboSpan" id="kobo.1122.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">/dev/sda</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1124.1">.</span></span></p></li> <li><span class="koboSpan" id="kobo.1125.1">Create the LVM physical volume with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">pvcreate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1"> command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1128.1">sudo pvcreate /dev/sda</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1129.1">Using this command might not work from the beginning and give an error message regarding the status of the drive where you want to create a physical volume. </span><span class="koboSpan" id="kobo.1129.2">It happened to us with one of the drives; here, we had to wipe the filesystem information from the drive using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">wipefs</span></strong><span class="koboSpan" id="kobo.1131.1"> utility. </span><span class="koboSpan" id="kobo.1131.2">The output is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1">following screenshot:</span></span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer178">
<span class="koboSpan" id="kobo.1133.1"><img alt="Figure 6.19 – Using pvcreate to create an LVM physical volume" src="image/B19682_06_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1134.1">Figure 6.19 – Using pvcreate to create an LVM physical volume</span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1135.1">Create a new volume group</span><a id="_idIndexMarker887"/><span class="koboSpan" id="kobo.1136.1"> to add the new physical volume to using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">vgcreate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1"> command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1139.1">sudo vgcreate newvolume /dev/sda</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1140.1">You can see the new volume group by running the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">vgdisplay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1142.1"> command:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer179">
<span class="koboSpan" id="kobo.1143.1"><img alt="Figure 6.20 – Creating and viewing details of the new volume" src="image/B19682_06_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1144.1">Figure 6.20 – Creating and viewing details of the new volume</span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.1145.1">Now, let’s create a logical volume using some of the space available from the volume group, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">lvcreate</span></strong><span class="koboSpan" id="kobo.1147.1">. </span><span class="koboSpan" id="kobo.1147.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">-n</span></strong><span class="koboSpan" id="kobo.1149.1"> option to add a name for the logical volume and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">-L</span></strong><span class="koboSpan" id="kobo.1151.1"> to set the size in a human-readable manner (we created a 5 GB logical volume </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">projects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">):</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer180">
<span class="koboSpan" id="kobo.1155.1"><img alt="Figure 6.21 – Creating a logical volume using lvcreate" src="image/B19682_06_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1156.1">Figure 6.21 – Creating a logical volume using lvcreate</span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1157.1">Check whether the logical </span><span class="No-Break"><span class="koboSpan" id="kobo.1158.1">volume exists:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1159.1">sudo ls /dev/mapper/newvolume-projects</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1160.1">The newly created device can only be used if it’s formatted using a known filesystem and mounted </span><a id="_idIndexMarker888"/><span class="koboSpan" id="kobo.1161.1">afterward, in the same way as a regular partition. </span><span class="koboSpan" id="kobo.1161.2">First, let’s format the </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">new volume:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer181">
<span class="koboSpan" id="kobo.1163.1"><img alt="Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem" src="image/B19682_06_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1164.1">Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem</span></p>
<ol>
<li value="8"><span class="koboSpan" id="kobo.1165.1">Now, it’s time to mount the logical volume. </span><span class="koboSpan" id="kobo.1165.2">First, create a new directory and mount the logical volume there. </span><span class="koboSpan" id="kobo.1165.3">Then, check its size using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1166.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1"> command:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer182">
<span class="koboSpan" id="kobo.1168.1"><img alt="Figure 6.23 – Mounting the logical volume" src="image/B19682_06_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1169.1">Figure 6.23 – Mounting the logical volume</span></p>
<ol>
<li value="9"><span class="koboSpan" id="kobo.1170.1">All changes implemented hitherto are not permanent. </span><span class="koboSpan" id="kobo.1170.2">To make them permanent, you will have to edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">/etc/fstab</span></strong><span class="koboSpan" id="kobo.1172.1"> file by adding the following within </span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">the file:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1174.1">/dev/mapper/newvolume-projects /home/alexandru/LVM ext4 defaults 1 2</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1175.1">You can now check the space available on your logical volume and grow it if you want. </span><span class="koboSpan" id="kobo.1175.2">Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">vgdisplay</span></strong><span class="koboSpan" id="kobo.1177.1"> command to see the </span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1">following details:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1179.1">sudo vgdisplay newvolume</span></strong></pre></li> <li><span class="koboSpan" id="kobo.1180.1">You can now expand the logical volume by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">lvextend</span></strong><span class="koboSpan" id="kobo.1182.1"> command. </span><span class="koboSpan" id="kobo.1182.2">We will extend the initial size by 5 GB, for a total of 10 GB. </span><span class="koboSpan" id="kobo.1182.3">The following is </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">an example:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer183">
<span class="koboSpan" id="kobo.1184.1"><img alt="Figure 6.24 – Extending the logical volume using lvextend" src="image/B19682_06_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1185.1">Figure 6.24 – Extending the logical volume using lvextend</span></p>
<ol>
<li value="12"><span class="koboSpan" id="kobo.1186.1">Now, resize the filesystem so that it fits the new size of the logical volume using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1187.1">resize2fs</span></strong><span class="koboSpan" id="kobo.1188.1"> and check for the size </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">df</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer184">
<span class="koboSpan" id="kobo.1192.1"><img alt="Figure 6.25 – Resizing the logical volume with resize2fs and checking for the size with df" src="image/B19682_06_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1193.1">Figure 6.25 – Resizing the logical volume with resize2fs and checking for the size with df</span></p>
<p><span class="koboSpan" id="kobo.1194.1">LVM is an advanced topic that will prove essential</span><a id="_idIndexMarker889"/><span class="koboSpan" id="kobo.1195.1"> for any Linux system administrator to have. </span><span class="koboSpan" id="kobo.1195.2">The brief hands-on examples we provided in this section only show the basic operations that you need to work with LVM. </span><span class="koboSpan" id="kobo.1195.3">Feel free to dig deeper into this topic if you </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">need to.</span></span></p>
<p><span class="koboSpan" id="kobo.1197.1">In the following section, we will discuss several more advanced LVM topics, including how to take full </span><span class="No-Break"><span class="koboSpan" id="kobo.1198.1">filesystem snapshots.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.1199.1">LVM snapshots</span></h2>
<p><span class="koboSpan" id="kobo.1200.1">What is an LVM snapshot? </span><span class="koboSpan" id="kobo.1200.2">It is a frozen instance of an LVM </span><a id="_idIndexMarker890"/><span class="koboSpan" id="kobo.1201.1">logical volume. </span><span class="koboSpan" id="kobo.1201.2">More specifically, it uses a </span><strong class="bold"><span class="koboSpan" id="kobo.1202.1">copy-on-write</span></strong><span class="koboSpan" id="kobo.1203.1"> technology. </span><span class="koboSpan" id="kobo.1203.2">This technology monitors each block of the existing volume, and when</span><a id="_idIndexMarker891"/><span class="koboSpan" id="kobo.1204.1"> blocks change, due to new writings, that block’s value is copied to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">snapshot volume.</span></span></p>
<p><span class="koboSpan" id="kobo.1206.1">The snapshots are created constantly and instantly and persist until they are deleted. </span><span class="koboSpan" id="kobo.1206.2">This way, you can create backups from any snapshot. </span><span class="koboSpan" id="kobo.1206.3">As snapshots are constantly changing due to the copy-on-write technology, initial thoughts on the size of the snapshot should be given when creating one. </span><span class="koboSpan" id="kobo.1206.4">Take into consideration, if possible, how much data is going to change during the existence of the snapshot. </span><span class="koboSpan" id="kobo.1206.5">Once the snapshot is full, it will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">automatically disabled.</span></span></p>
<h3><span class="koboSpan" id="kobo.1208.1">Creating a new snapshot</span></h3>
<p><span class="koboSpan" id="kobo.1209.1">To create a new snapshot, you can</span><a id="_idIndexMarker892"/><span class="koboSpan" id="kobo.1210.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">lvcreate</span></strong><span class="koboSpan" id="kobo.1212.1"> command, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">-s</span></strong><span class="koboSpan" id="kobo.1214.1"> option. </span><span class="koboSpan" id="kobo.1214.2">You can also specify the size with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">-L</span></strong><span class="koboSpan" id="kobo.1216.1"> option and add a name for the snapshot with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1217.1">-n</span></strong><span class="koboSpan" id="kobo.1218.1"> option, </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<span class="koboSpan" id="kobo.1220.1"><img alt="Figure 6.26 – Creating an LVM snapshot with the lvcreate command" src="image/B19682_06_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1221.1">Figure 6.26 – Creating an LVM snapshot with the lvcreate command</span></p>
<p><span class="koboSpan" id="kobo.1222.1">In the preceding command, we set a size of 5 GB and used the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">linux-snapshot-01</span></strong><span class="koboSpan" id="kobo.1224.1">. </span><span class="koboSpan" id="kobo.1224.2">The last part of the command contains the destination of the volume for which we created the snapshot. </span><span class="koboSpan" id="kobo.1224.3">To list the new snapshot, use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">lvs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1226.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.1227.1"><img alt="Figure 6.27 – Listing the available volume and the newly created snapshot" src="image/B19682_06_27.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1228.1">Figure 6.27 – Listing the available volume and the newly created snapshot</span></p>
<p><span class="koboSpan" id="kobo.1229.1">For more information on the logical volumes, run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">lvdisplay</span></strong><span class="koboSpan" id="kobo.1231.1"> command. </span><span class="koboSpan" id="kobo.1231.2">The output will show information about all the volumes, and among them, you will see the snapshot we </span><span class="No-Break"><span class="koboSpan" id="kobo.1232.1">just created.</span></span></p>
<p><span class="koboSpan" id="kobo.1233.1">When we created the snapshot, we gave it a size of 5 GB. </span><span class="koboSpan" id="kobo.1233.2">Now, we would like to extend it to the size of the source, which was 10 GB. </span><span class="koboSpan" id="kobo.1233.3">We will do this with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">lvextend</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<span class="koboSpan" id="kobo.1236.1"><img alt="Figure 6.28 – Extending the snapshot from 5 to 10 GB" src="image/B19682_06_28.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1237.1">Figure 6.28 – Extending the snapshot from 5 to 10 GB</span></p>
<p><span class="koboSpan" id="kobo.1238.1">As shown in the preceding screenshot, the name that the snapshot volume is using is different from the one we used. </span><span class="koboSpan" id="kobo.1238.2">Even though we used the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.1239.1">linux-snapshot-01</span></strong><span class="koboSpan" id="kobo.1240.1"> for the snapshot volume, if we do a listing of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1241.1">/dev/mapper/</span></strong><span class="koboSpan" id="kobo.1242.1"> directory, we will see that the name uses two more dashes</span><a id="_idIndexMarker893"/><span class="koboSpan" id="kobo.1243.1"> instead. </span><span class="koboSpan" id="kobo.1243.2">This is a convention that’s used to represent logical </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">volume files.</span></span></p>
<p><span class="koboSpan" id="kobo.1245.1">Now that you know how to create snapshots, let’s learn how to restore </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">a snapshot.</span></span></p>
<h3><span class="koboSpan" id="kobo.1247.1">Restoring a snapshot</span></h3>
<p><span class="koboSpan" id="kobo.1248.1">To restore a snapshot, first, you would need to unmount</span><a id="_idIndexMarker894"/><span class="koboSpan" id="kobo.1249.1"> the filesystem. </span><span class="koboSpan" id="kobo.1249.2">To unmount, we will use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1250.1">umount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1"> command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1252.1">
sudo umount /home/alexandru/LVM</span></pre> <p><span class="koboSpan" id="kobo.1253.1">Then, we can proceed to restore the snapshot with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">lvconvert</span></strong><span class="koboSpan" id="kobo.1255.1"> command. </span><span class="koboSpan" id="kobo.1255.2">After the snapshot is merged into the source, we can check this by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">lvs</span></strong><span class="koboSpan" id="kobo.1257.1"> command. </span><span class="koboSpan" id="kobo.1257.2">The output of the two commands is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<span class="koboSpan" id="kobo.1259.1"><img alt="Figure 6.29 – Restoring and checking the snapshot" src="image/B19682_06_29.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1260.1">Figure 6.29 – Restoring and checking the snapshot</span></p>
<p><span class="koboSpan" id="kobo.1261.1">Following the merge, the snapshot is </span><span class="No-Break"><span class="koboSpan" id="kobo.1262.1">automatically removed.</span></span></p>
<p><span class="koboSpan" id="kobo.1263.1">We have now covered all the basics of LVM in Linux. </span><span class="koboSpan" id="kobo.1263.2">LVM is more complicated than normal disk partitioning. </span><span class="koboSpan" id="kobo.1263.3">It might be intimidating to many, but it can show its strengths when needed. </span><span class="koboSpan" id="kobo.1263.4">Nevertheless, it also comes with several drawbacks – for example, it can add unwanted complexity in a disaster recovery</span><a id="_idIndexMarker895"/><span class="koboSpan" id="kobo.1264.1"> scenario or when a hardware failure occurs. </span><span class="koboSpan" id="kobo.1264.2">But all this aside, it is still worth </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">learning about.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1266.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1267.1">Managing filesystems and disks is an important task for any Linux system administrator. </span><span class="koboSpan" id="kobo.1267.2">Understanding how devices are managed in Linux, and how to format and partition disks, is essential. </span><span class="koboSpan" id="kobo.1267.3">Furthermore, it is important to learn about LVM as it offers a flexible way to </span><span class="No-Break"><span class="koboSpan" id="kobo.1268.1">manage partitions.</span></span></p>
<p><span class="koboSpan" id="kobo.1269.1">Mastering those skills will give you a strong foundation for any basic administration task. </span><span class="koboSpan" id="kobo.1269.2">In the following chapter, we will introduce you to the vast domain of </span><strong class="bold"><span class="koboSpan" id="kobo.1270.1">networking</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1271.1">in Linux.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.1272.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1273.1">If you managed to skim through some parts of this chapter, you might want to recap a few essential details about Linux filesystem and </span><span class="No-Break"><span class="koboSpan" id="kobo.1274.1">disk management:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1275.1">Think of another tool to use for working with disks and </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">install it.</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.1277.1">Hint</span></strong><span class="koboSpan" id="kobo.1278.1">: Try installing </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">parted</span></strong><span class="koboSpan" id="kobo.1280.1"> and use it from the command line. </span><span class="koboSpan" id="kobo.1280.2">You can also use GParted from </span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">the GUI.</span></span></p></li>
<li><span class="koboSpan" id="kobo.1282.1">Experiment with using Disks (in GNOME) and KDE Partition Manager (in KDE) and use the command-line interface side </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">by side.</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.1284.1">Hint</span></strong><span class="koboSpan" id="kobo.1285.1">: Keep both applications open and use the command-line utilities side by side. </span><span class="koboSpan" id="kobo.1285.2">Try to format and mount a disk from the command line while keeping the GUI </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">apps open.</span></span></p></li>
<li><span class="koboSpan" id="kobo.1287.1">Format new partitions using </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">different filesystems.</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.1289.1">Hint</span></strong><span class="koboSpan" id="kobo.1290.1">: Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">btrfs</span></strong><span class="koboSpan" id="kobo.1292.1"> instead </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">ext4</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">.</span></span></p></li>
<li><span class="koboSpan" id="kobo.1296.1">Explore your filesystem </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">and disks.</span></span><p class="list-inset"><strong class="bold"><span class="koboSpan" id="kobo.1298.1">Hint</span></strong><span class="koboSpan" id="kobo.1299.1">: Use tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">lsblk</span></strong><span class="koboSpan" id="kobo.1301.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1302.1">df</span></strong><span class="koboSpan" id="kobo.1303.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">fdisk</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">.</span></span></p></li>
</ol>
<h1 id="_idParaDest-122"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.1307.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1308.1">For more information about what was covered in this chapter, please refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1">Packt titles:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1310.1">Linux Administration Best Practices</span></em><span class="koboSpan" id="kobo.1311.1">, by Scott </span><span class="No-Break"><span class="koboSpan" id="kobo.1312.1">Alan Miller</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1313.1">Mastering Ubuntu Server – Fourth Edition</span></em><span class="koboSpan" id="kobo.1314.1">, by </span><span class="No-Break"><span class="koboSpan" id="kobo.1315.1">Jay LaCroix</span></span></li>
</ul>
</div>
</body></html>