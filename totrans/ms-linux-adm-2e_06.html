<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-108"><a id="_idTextAnchor124"/>6</h1>
<h1 id="_idParaDest-109"><a id="_idTextAnchor125"/>Working with Disks and Filesystems</h1>
<p>In this chapter, you will learn how to manage disks and filesystems, how to use the <strong class="bold">Logical Volume Management</strong> (<strong class="bold">LVM</strong>) system, and how to mount and partition the hard drive, as well as gain an understanding of<a id="_idIndexMarker754"/> storage in Linux. You will also learn how to partition and format a disk, as well as how to create logical volumes, and you will gain a deeper understanding of filesystem types. In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Understanding devices in Linux</li>
<li>Understanding filesystem types in Linux</li>
<li>Understanding disks and partitions</li>
<li>Introducing LVM in Linux</li>
</ul>
<h1 id="_idParaDest-110"><a id="_idTextAnchor126"/>Technical requirements</h1>
<p>A basic knowledge of disks, partitions, and filesystems is preferred. No other special technical requirements are needed, just a working installation of Linux on your system. We will mainly use Ubuntu or Debian for this chapter’s exercises. All the commands used in this chapter can be replicated on any Linux distribution, even if you don’t use Debian or Ubuntu.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor127"/>Understanding devices in Linux</h1>
<p>As already stated on several occasions<a id="_idIndexMarker755"/> in this book, everything in Linux is a file. This also includes devices. <strong class="bold">Device files</strong> are special files in Unix and Linux operating<a id="_idIndexMarker756"/> systems. Those special files are interfaces to device drivers, and they are present in the filesystem as a regular file.</p>
<p>With no further ado, let’s see how Linux abstraction layers work. This will give you an overview of how hardware and software are related and interconnected.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor128"/>Linux abstraction layers</h2>
<p>Now is as good a time as any<a id="_idIndexMarker757"/> to discuss Linux system abstraction layers and how devices fit into the overall picture. Any computer is generally organized into two layers (or levels) – the hardware and the software levels:</p>
<ul>
<li><strong class="bold">Hardware level</strong>: This level contains the hardware<a id="_idIndexMarker758"/> components of your machine, such as the memory (RAM), <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>), and devices, including disks, network interfaces, ports, and controllers.</li>
<li><strong class="bold">Software level</strong>: For all these hardware components<a id="_idIndexMarker759"/> to work, the operating system (Linux, in our case) uses <strong class="bold">abstraction layers</strong>. Those layers exist in the <strong class="bold">kernel</strong>, which is the main software component of Linux. Without diving into more<a id="_idIndexMarker760"/> information, it is sufficient for you to know<a id="_idIndexMarker761"/> that Linux has these layers that are responsible for accessing low-level resources and providing the specific drivers for different hardware components. When the computer is booted up, the Linux kernel<a id="_idIndexMarker762"/> is loaded from the disk<a id="_idIndexMarker763"/> into the system’s memory (RAM). Thus, inside the memory, there will be two separate regions, called <strong class="bold">kernel space</strong> and <strong class="bold">user space</strong>, and this would be the <strong class="bold">software level</strong>:<ul><li>The kernel is the beating heart of the Linux operating system. The kernel resides inside the memory (RAM) and manages all the hardware components. It is the <em class="italic">interface</em> between the software and hardware on your Linux system.</li><li>The user space level is the level where user processes are executed. As presented in <a href="B19682_05.xhtml#_idTextAnchor104"><em class="italic">Chapter 5</em></a>, <em class="italic">Working with Processes, Daemons, and Signals</em>, a process is a running instance of a program.</li></ul></li>
</ul>
<p>Where are devices in this grand scheme of things? Devices are managed by the <em class="italic">kernel</em>. To sum up, the kernel is in charge of managing<a id="_idIndexMarker764"/> processes, system calls, memory, and devices. When dealing with devices, the kernel manages <strong class="bold">device drivers</strong>, which are the interface between hardware components and software. All devices are accessible only in kernel mode, for a more secure and streamlined operation.</p>
<p>How does all this work? Well, the <a id="_idIndexMarker765"/>memory, known as RAM, consists of cells that are used to store information temporarily. Those cells are accessed by different programs that are executed and function as an intermediary between the CPU and the storage. The speeds of accessing memory are very high to secure a seamless process of execution. The management of user processes inside the user space is the kernel’s job. The kernel makes sure that none of the processes will interfere with each other. The kernel space is usually accessed only by the kernel, but<a id="_idIndexMarker766"/> there are times when user processes need to access this space. This is done through <strong class="bold">system calls</strong>. A system call is the way a user process requests a kernel<a id="_idIndexMarker767"/> service through an active process inside the kernel space, for anything such as <strong class="bold">input/output</strong> (<strong class="bold">I/O</strong>) requests to internal or external devices. All those requests transfer data to and from the CPU, through RAM, to get<a id="_idIndexMarker768"/> the job done.</p>
<p>In the following section, we will introduce you to the naming convention in Linux and how device files are managed.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor129"/>Device files and naming conventions</h2>
<p>After seeing how the abstraction layers work, you may<a id="_idIndexMarker769"/> be wondering how<a id="_idIndexMarker770"/> Linux manages devices. Well, it does <a id="_idIndexMarker771"/>that with the help of <strong class="bold">userspace /dev</strong> (<strong class="bold">udev</strong>), which is a device manager for the kernel. It works with <strong class="bold">device nodes</strong>, which are special files (also called <strong class="bold">device files</strong>) that are used as an interface to the driver.</p>
<h3>Device files in Linux</h3>
<p><code>udev</code> runs as a daemon<a id="_idIndexMarker772"/> that listens to the user space calls that the kernel is sending, so it is aware of what kinds of devices are used and how they are used. The daemon is called <code>udevd</code> and its configurations are currently available under <code>/etc/udev/udev.conf</code>. You can concatenate the <code>/etc/udev/udev.conf</code> file to see its contents by running the following command:</p>
<pre class="console">
cat /etc/udev/udev.conf</pre> <p>Each Linux distribution has a default set of rules that governs <code>udevd</code>. Those rules are normally stored under the <code>/etc/udev/rules.d/</code> directory, as shown in the following screenshot:</p>
<div><div><img alt="Figure 6.1 – udevd rules location" src="img/B19682_06_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – udevd rules location</p>
<p class="callout-heading">Note</p>
<p class="callout">The kernel sends calls for events using the <strong class="bold">Netlink</strong> socket. The netlink socket is an interface for inter-process<a id="_idIndexMarker773"/> communication that’s used for both userspace and kernel space processes alike.</p>
<p>The <code>/dev</code> directory is the interface<a id="_idIndexMarker774"/> between user processes and devices managed by the kernel. If you were to use the <code>ls -la /dev</code> command, you would see a lot of files inside, each with different names. If you were to do a long listing, you would see different file types. Some of the files will start with the letters <em class="italic">b</em> and <em class="italic">c</em>, but the letters <em class="italic">p</em> and <em class="italic">s</em> may also be present, depending<a id="_idIndexMarker775"/> on your system. Files starting with those letters are device files. The ones<a id="_idIndexMarker776"/> starting with <em class="italic">b</em> are <strong class="bold">block devices</strong>, and those starting with the letter <em class="italic">c</em> are <strong class="bold">character devices</strong>, as shown in the following screenshot:</p>
<div><div><img alt="Figure 6.2 – Device files inside the /dev directory" src="img/B19682_06_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Device files inside the /dev directory</p>
<p>Let’s see how disk devices<a id="_idIndexMarker777"/> are presented inside the <code>/dev</code> directory. But first, we’ve provided a few words about our working setup in the following note.</p>
<p class="callout-heading">Important note</p>
<p class="callout">For most of the exercises in this book, we will be using virtual machines with planet names as hostnames, running different Linux-based operating systems. For example, <code>neptune</code> is running on Ubuntu 22.04.2 LTS Server, so when you see the <code>neptune</code> hostname on the shell’s prompt, you will know we are on an Ubuntu-based system. We also have <code>jupiter</code>, running on the openSUSE 15.4 Leap server, <code>saturn</code> running on Fedora 37 Workstation, <code>venus</code> running on AlmaLinux, and <code>mars</code> running on a Debian 11.6 server. Inside a virtual machine, device drivers are presented with different names than on bare-metal systems. We will provide details when we discuss device naming conventions in the following section. For some examples, though, which are marked accordingly, we will also use our primary workstation, which is running on Debian 12 GNU/Linux.</p>
<p>As shown in <em class="italic">Figure 6</em><em class="italic">.3</em>, the disk device, <code>sda</code>, is represented as a block device. Block devices have a fixed size<a id="_idIndexMarker778"/> that can easily be indexed. Character devices, on the<a id="_idIndexMarker779"/> other hand, can be accessed using data streams, as they don’t have a size like block devices. For example, printers are represented as character devices. In the following screenshot, <code>sg0</code> is an SCSI generic device, and not assigned to any disks in our case. We used our primary workstation running on Debian GNU/Linux and the device presented as <code>sda</code> is an external USB device:</p>
<div><div><img alt="Figure 6.3 – Disk drives inside the /dev directory" src="img/B19682_06_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Disk drives inside the /dev directory</p>
<p>In comparison, when listing devices from our <code>neptune</code> virtual machine, we will have the output presented in the following screenshot:</p>
<div><div><img alt="Figure 6.4 – Virtual devices inside a virtual machine" src="img/B19682_06_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Virtual devices inside a virtual machine</p>
<p>Device blocks presented with <code>vdaX</code> are virtual devices inside the virtual machine. You will learn more about virtual<a id="_idIndexMarker780"/> machines in <a href="B19682_11.xhtml#_idTextAnchor231"><em class="italic">Chapter 11</em></a>, <em class="italic">Working with </em><em class="italic">Virtual Machines</em>.</p>
<p>But for now, let’s find out more about device naming conventions in Linux.</p>
<h3>Understanding device naming conventions</h3>
<p>Linux uses a device naming<a id="_idIndexMarker781"/> convention that makes device management easier and more consistent throughout the Linux ecosystem. <code>udev</code> uses several specific naming schemes that, by default, assign fixed names to devices. Those names are standardized for device categories. For example, when naming network devices, the kernel uses information compiled from sources such as firmware, topology, and location. On a Red Hat-based system, five schemes are used for naming a network interface, and we encourage<a id="_idIndexMarker782"/> you to look at these on the Red Hat customer portal official documentation website: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9">https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9</a>.</p>
<p>On a Debian-based system, the naming convention is similar in that it’s based on hardware buses’ names for predictability. This is similar to all modern Linux-based operating systems.</p>
<p>You could also check what <code>udev</code> rules are active on your system. On Debian and Red Hat-based distributions, they are stored in the <code>/</code><code>lib/udev/rules.d/</code> directory.</p>
<p>When it comes to hard drives or external drives, the conventions are more streamlined. Here are some examples:</p>
<ul>
<li><code>hda</code> (the master device), <code>hdb</code> (the slave device<a id="_idIndexMarker783"/> on the first channel), <code>hdc</code> (the master device on the second channel), and <code>hdd</code> (the slave device on the second channel)</li>
<li><code>nvme0</code> (the first device <a id="_idIndexMarker784"/>controller – character device), <code>nvme0n1</code> (first namespace – block device), and <code>nvme0n1p1</code> (first namespace, first partition – block device)</li>
<li><code>mmcblk</code> (for SD cards using<a id="_idIndexMarker785"/> eMMC chips), <code>mmcblk0</code> (first device), and <code>mmcblk0p1</code> (first device, first partition)</li>
<li><code>sd</code> (for mass storage devices), <code>sda</code> (for the first registered<a id="_idIndexMarker786"/> device), <code>sdb</code> (for the second registered device), <code>sdc</code> (for the third registered device), and so on, and <code>sg</code> (for generic SCSI layers – character device)</li>
</ul>
<p>The devices that we are most interested<a id="_idIndexMarker787"/> in regarding this chapter are the mass storage devices. Those devices are usually <strong class="bold">hard disk drives</strong> (<strong class="bold">HDDs</strong>) or <strong class="bold">solid-state drives</strong> (<strong class="bold">SSDs</strong>), which are used inside your computer to store data. These drives are most likely divided<a id="_idIndexMarker788"/> into partitions with a specific structure provided by the filesystem. We talked a little bit about filesystems earlier in this book in <a href="B19682_02.xhtml#_idTextAnchor053"><em class="italic">Chapter 2</em></a>, <em class="italic">The </em><em class="italic">Linux Shell and</em><em class="italic"> Filesystem</em>, when we referred to the Linux directory<a id="_idIndexMarker789"/> structure, but now, it is time to get into more details about filesystem types in Linux.</p>
<h1 id="_idParaDest-114"><a id="_idTextAnchor130"/>Understanding filesystem types in Linux</h1>
<p>When talking about physical<a id="_idIndexMarker790"/> media, such as hard drives or external drives, we are <em class="italic">not</em> referring to the directory structure. Here, we are talking about the structures that are created on the physical drive when formatting and/or partitioning it. These structures, depending on their type, are known as filesystems, and they determine how the files are managed when stored on the drive.</p>
<p>There are several types of filesystems, some being native to the Linux ecosystem, while others are not, such as specific Windows or macOS filesystems. In this section, we will describe only the Linux-native filesystems.</p>
<p>The most widely<a id="_idIndexMarker791"/> used filesystems in Linux are the <code>Ext</code>, <code>Ext2</code>, <code>Ext3</code>, and <code>Ext4</code>, the <code>XFS</code> filesystem, <code>ZFS</code>, and <code>btrfs</code> (short for <code>Ext4</code>, the latest iteration, is similar to <code>Ext3</code>, but better, with improved support for larger files, fragmentation, and performance. The <code>Ext3</code> filesystem uses 32-bit addressing, while <code>Ext4</code> uses 48-bit addressing, thus supporting files up to 16 TB in size. It also offers support for unlimited subdirectories as <code>Ext3</code> only supports 32k subdirectories. Also, support for extended timestamps was added in <code>Ext4</code>, offering two more bits for up to the year 2446 AD, and online defragmentation at the kernel level.</p>
<p>Nonetheless, <code>Ext4</code> is not a truly next-gen filesystem; rather, it is an improved, trustworthy, robust, and stable <em class="italic">workhorse</em> that failed the data protection and integrity test. Its journaling system is not suitable for detecting and repairing data corruption and degradation. That is why other filesystems, such as <code>XFS</code> and <code>ZFS</code>, started to resurface by being used in Red Hat Enterprise Linux, starting from version 7 (<code>XFS</code>) and in Ubuntu since version 16.04 (<code>ZFS</code>).</p>
<p>The case of <code>btrfs</code> is somewhat controversial. It is considered a modern filesystem, but it is still used as a single-disk filesystem and not used in multiple disk volume managers due to several performance issues compared to other filesystems. It is used in SUSE Linux Enterprise and openSUSE, is no longer supported by Red Hat, and has been voted as the future default filesystem in Fedora, starting with version 33.</p>
<p>Here are some more details on the major filesystem features:</p>
<ul>
<li><code>Ext4</code> filesystem was designed<a id="_idIndexMarker792"/> for Linux right from the outset. Even though<a id="_idIndexMarker793"/> it is slowly being replaced with other filesystems, this one still has powerful features. It offers block size selection, with values between 512 and 4,096 bytes. There is also a feature called inode reservation, which saves a couple of inodes when<a id="_idIndexMarker794"/> you create a directory, for improved performance when creating new files.<p class="list-inset">The layout is simple, written in <code>Ext4</code> takes advantage of. Among them, we will bring the following into<a id="_idIndexMarker797"/> the discussion: a maximum filesystem size of 1 <code>fsck</code> command for speedy filesystem checks, the use of checksums for journaling and better reliability, and the use of improved timestamps.</p></li>
<li><strong class="bold">ZFS</strong>: This filesystem was created at Sun Microsystems<a id="_idIndexMarker798"/> and combines a file system and a logical volume<a id="_idIndexMarker799"/> manager into one solution. It was announced in 2004, with development starting in 2001, and was first integrated into the Solaris operating system, then used (not the default though) by Debian, FreeBSD, and others. ZFS is a highly scalable 128-bit system that offers simple administration, data<a id="_idIndexMarker800"/> integrity, scalability, and performance. Development of this filesystem is done through the <strong class="bold">OpenZFS</strong> open source project. ZFS offers a complex structure by using a copy-on-write mechanism, different from traditional filesystems. For more detailed<a id="_idIndexMarker801"/> information about ZFS, we recommend the following link: <a href="https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html">https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html</a>.</li>
<li><code>Ext4</code> to other competent filesystem<a id="_idIndexMarker803"/> types. Among those is <code>XFS</code>. This filesystem was first created by Silicon Graphics, Inc and used in the IRIX operating system. Its most important key design element is performance as it is capable of dealing with large datasets. Furthermore, it is designed to handle parallel I/O tasks with a guaranteed high I/O rate. The filesystem supports up to 16 EB with support for individual files up to 8 EB. <code>XFS</code> has a feature to journal quota information, together with online maintenance tasks such as defragmenting, enlarging, and restoring. There are also specific tools for backup and restore, including <code>xfsdump</code> and <code>xfsrestore</code>.</li>
<li><code>btrfs</code>) is still under<a id="_idIndexMarker804"/> development, but it addresses<a id="_idIndexMarker805"/> issues associated with existing filesystems, including the lack of snapshots, pooling, checksums, and multi-device spanning. These are features that are required in an enterprise Linux environment. The ability to take snapshots of the filesystem and maintain its internal framework for managing new partitions makes <code>btrfs</code> a viable newcomer in terms of the critical enterprise ecosystem.</li>
</ul>
<p>There are other<a id="_idIndexMarker806"/> filesystems<a id="_idIndexMarker807"/> that we did not discuss here, including <code>cat /</code><code>proc/filesystems</code> command.</p>
<p>Linux implements a special software<a id="_idIndexMarker817"/> system that is designed to run specific functions of the filesystems. It is known as the <strong class="bold">virtual file system</strong> and acts as a bridge between the kernel and the filesystem types and hardware. Therefore, when an application wants to open a file, the action is delivered through the Virtual File System as an abstraction layer:</p>
<div><div><img alt="Figure 6.5 – The Linux Virtual File System abstraction layer" src="img/B19682_06_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The Linux Virtual File System abstraction layer</p>
<p>Basic filesystem functions include provisioning namespaces, metadata structures as a logical foundation for hierarchical directory structures, disk block usage, file size and access information, and high-level<a id="_idIndexMarker818"/> data for logical volumes and partitions. There is also an <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) available for every filesystem. Thus, developers can access system function calls for filesystem object manipulation with specific algorithms for creating, moving, and deleting files, or for indexing, searching, and finding files. Furthermore, every modern filesystem provides a special access rights scheme<a id="_idIndexMarker819"/> that’s used to determine the rules governing a user’s access to files.</p>
<p>At this point, we have already covered the principal Linux filesystems, including <code>EXT4</code>, <code>btrfs</code>, and <code>XFS</code>. In the next section, we will teach you the basics of disks and partition management in Linux.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor131"/>Understanding disks and partitions</h1>
<p>Understanding disks and partitions is a key asset<a id="_idIndexMarker820"/> for any system<a id="_idIndexMarker821"/> administrator. Formatting and partitioning disks is critical, starting with system installation. Knowing the type of hardware available on your system is important, and it is therefore imperative to know how to work with it. One of these is the disk; let’s look at this in further detail.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor132"/>Common disk types</h2>
<p>A <strong class="bold">disk</strong> is a hardware component that<a id="_idIndexMarker822"/> stores your data. It comes in various types and uses different<a id="_idIndexMarker823"/> interfaces. The main disk types are the well-known <strong class="bold">spinning HDD</strong>, the SSD, and the <strong class="bold">non-volatile memory express</strong> (<strong class="bold">NVMe</strong>). SSDs and NVMes use RAM-like<a id="_idIndexMarker824"/> technologies, with better energy<a id="_idIndexMarker825"/> consumption and higher transfer rates than original spinning hard drives. The following interfaces are used:</p>
<ul>
<li><strong class="bold">Integrated Drive Electronics</strong> (<strong class="bold">IDE</strong>): This is an old standard that’s used on consumer hardware<a id="_idIndexMarker826"/> with small transfer rates. It’s now<a id="_idIndexMarker827"/> deprecated.</li>
<li><strong class="bold">Serial Advanced Technology Attachment</strong> (<strong class="bold">SATA</strong>): This replaced IDEs and has transfer<a id="_idIndexMarker828"/> rates of up <a id="_idIndexMarker829"/>to 16 GB/s.</li>
<li><strong class="bold">Small Computer Systems Interface</strong> (<strong class="bold">SCSI</strong>): This is used mostly in enterprise servers with RAID configurations<a id="_idIndexMarker830"/> with sophisticated hardware<a id="_idIndexMarker831"/> components.</li>
<li><strong class="bold">Serial Attached SCSI</strong> (<strong class="bold">SAS</strong>): This is a point-to-point serial protocol interface with transfer rates<a id="_idIndexMarker832"/> similar to SATA. It is mostly used in enterprise environments<a id="_idIndexMarker833"/> for their reliability.</li>
<li><strong class="bold">Universal Serial Bus</strong> (<strong class="bold">USB</strong>): This is used for external hard drives<a id="_idIndexMarker834"/> and memory <a id="_idIndexMarker835"/>drives.</li>
</ul>
<p>Each disk has a specific geometry that consists of heads, cylinders, tracks, and sectors. On a Linux system, to see the information regarding a disk’s geometry, you can use the <code>fdisk -</code><code>l</code> command.</p>
<p>On our primary workstation, we have a single SSD running Debian 12 GNU/Linux and a USB device inserted in one of the ports. We will run the following command to obtain information about the drives on our machine:</p>
<pre class="source-code">
sudo fdisk -l</pre> <p>The following screenshot shows excerpts of the <code>fdisk</code> command’s output for both drives:</p>
<div><div><img alt="Figure 6.6 – The output of the fdisk -l command showing disk information" src="img/B19682_06_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – The output of the fdisk -l command showing disk information</p>
<p>The output of the <code>fdisk</code> utility may look intimidating<a id="_idIndexMarker836"/> at first, but rest assured that we will explain it to you so that it will look friendlier from now on. By using the <code>fdisk</code> utility without a specific partition as an argument, all the partition information available inside <code>/proc/partitions</code> will be shown. In the example shown in the preceding screenshot, you have details on two disks that are available on our system: a 1 TB Lexar NM620 SSD and an 8 GB USB flash drive attached. Let’s explain how the 1 TB drive is shown:</p>
<ul>
<li>First, you have <code>Disk model</code> with the name of the drive, <code>Units</code> as sectors, each of which has a size of 512 bytes, <code>Disklabel type</code> as GPT, and <code>Disk identifier</code>, which is unique for each drive.</li>
<li>Next is a table of the partitions available on the disk. This table has six columns (sometimes seven columns, as in the case of the USB flash drive, shown on the lower side of the screenshot). The first column has the <code>Device</code> header and shows the partition naming scheme. The second and third columns (in our example) show the starting and ending sectors. The fourth column shows the total number of sectors on the partition. The fifth column shows the size of the partition in human-readable format and the last column shows the type of the filesystem.</li>
</ul>
<p>Knowing basic information about disk devices<a id="_idIndexMarker837"/> on your system is merely the starting point for working with disks and partitions on Linux. Disks are just a big chunk of metal if we don’t format and partition them so that the system can use them. This is why, in the next section, we will teach you what partitions are.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor133"/>Partitioning disks</h2>
<p>Commonly, disks use <strong class="bold">partitions</strong>. To understand partitions, knowing<a id="_idIndexMarker838"/> a disk’s geometry is essential. This legacy knowledge base is useful even when dealing with SSDs. Partitions are contiguous sets of sectors and/or cylinders, and they can be of several types: <strong class="bold">primary</strong>, <strong class="bold">extended</strong>, and <strong class="bold">logical</strong> partitions. A maximum number of 15 partitions can exist<a id="_idIndexMarker839"/> on a disk. The first<a id="_idIndexMarker840"/> four will be either<a id="_idIndexMarker841"/> primary or extended, and the remaining are logical partitions. Furthermore, there can only be a single extended partition, but they can be divided into several logical partitions until the maximum number is reached.</p>
<h3>Partition types</h3>
<p>There are two<a id="_idIndexMarker842"/> major partition types – the <code>0x0c</code> for FAT, <code>0x07</code> for NTFS, <code>0x83</code> for a Linux filesystem type, and <code>0x82</code> for swap. GPT became a part of the <strong class="bold">Unified Extensible Firmware Interface</strong> (<strong class="bold">UEFI</strong>) standard as a solution to some issues with<a id="_idIndexMarker845"/> MBR, including partition limitations, addressing methods, using only one copy of the partition table, and so on. It supports up to 128 partitions and disk sizes of up to 75.6 <strong class="bold">Zettabytes</strong> (<strong class="bold">ZB</strong>).</p>
<h3>The partition table</h3>
<p>The <strong class="bold">partition table</strong> of a disk is stored inside the disk’s MBR. MBR<a id="_idIndexMarker846"/> is the first 512 bytes of a drive. Out <a id="_idIndexMarker847"/>of these, the partition table is 64 bytes and is stored<a id="_idIndexMarker848"/> after the first 446 bytes of records. At the end of MBR, there are 2 bytes known as the end of sector marker. The first 446 bytes are reserved for code that usually belongs to a bootloader<a id="_idIndexMarker849"/> program. In the case of Linux, the bootloader is called <strong class="bold">GRand Unified </strong><strong class="bold">Bootloader</strong> (<strong class="bold">GRUB</strong>).</p>
<p>When you boot up a Linux system, the bootloader looks for the active partition. There can only be one active partition on a single disk. When the active partition is located, the bootloader loads items. The partition table has 4 entries, each of which is 16 bytes in size, with each belonging to a possible primary partition on the system. Furthermore, each entry contains information regarding the beginning address of <code>cylinder/head/sectors</code>, the partition type code, the end address of <code>cylinder/head/sectors</code>, the starting sector, and the number of sectors inside one partition.</p>
<h3>Naming partitions</h3>
<p>The kernel interacts with the disk<a id="_idIndexMarker850"/> at a low level. This is done through device nodes that are stored inside the <code>/dev</code> directory. Device nodes use a simple naming convention that tells you which disk is the one that requires your attention. Looking<a id="_idIndexMarker851"/> at the contents of the <code>/dev</code> directory, you can see all the available disk nodes, also referred to as disk drives, in <em class="italic">Figure 6</em><em class="italic">.2</em> and <em class="italic">Figure 6</em><em class="italic">.3</em> earlier in this section. A short explanation is always useful, so disks and partitions are recognized as follows:</p>
<ul>
<li>The first hard drive is always <code>/dev/sda</code> (for an SCSI or SATA device)</li>
<li>The second hard drive is <code>/dev/sdb</code>, the third is <code>/dev/sdc</code>, and so on</li>
<li>The first partition of the first disk is <code>/dev/sda1</code></li>
<li>The first partition of the second disk is <code>/dev/sdb1</code></li>
<li>The second partition of the second disk is <code>/dev/sdb2</code>, and so on</li>
</ul>
<p>We specified that this is true<a id="_idIndexMarker852"/> in the case of an SCSI and SATA, and we need to explain this in a little more detail. The kernel gives the letter designation, such as <em class="italic">a</em>, <em class="italic">b</em>, and <em class="italic">c</em>, based on the ID number of the SCSI device, and not based on the position of the hardware bus.</p>
<h3>Partition attributes</h3>
<p>To learn about your partition’s attributes, you<a id="_idIndexMarker853"/> can use the <code>lsblk</code> command. We will run it on our Debian system, as shown in the following screenshot:</p>
<div><div><img alt="Figure 6.7 – The output of lsblk" src="img/B19682_06_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – The output of lsblk</p>
<p>The <code>lsblk</code> command shows the device’s name (the node’s name from <code>sysfs</code> and the <code>udev</code> database), the major and minor device number, the removable state of the device (<code>0</code> for a non-removable device and <code>1</code> for a removable device), the size in human-readable format, the read-only state (again, using <code>0</code> for the ones that are not read-only and <code>1</code> for the read-only ones), the type<a id="_idIndexMarker854"/> of device, and the device’s mount point (where available).</p>
<p>Now that we know more about the drive, let’s learn how to alter a disk’s partition table.</p>
<h3>Partition table editors</h3>
<p>In Linux, there are several tools<a id="_idIndexMarker855"/> we can use when managing partition tables. Among the most commonly used ones are the following:</p>
<ul>
<li><code>fdisk</code>: A command-line partition editor, perhaps the most widely used one</li>
<li><code>Sfdisk</code>: A non-interactive partition editor, used mostly in scripting</li>
<li><code>parted</code>: The GNU (the recursive acronym for GNU is <em class="italic">GNU's Not Unix</em>) partition manipulation software</li>
<li><code>gparted</code>: The graphical interface for <code>parted</code></li>
</ul>
<p>Of these, we will only detail how to use <code>fdisk</code> as this is the most widely used command-line partition editor in Linux. It is found in both Ubuntu/Debian and RHEL/Fedora or openSUSE and many other distributions too.</p>
<p>But before we use <code>fdisk</code>, we would like to see the partitions that the operating system knows about. If you are not sure about the operations you just completed, you can always visualize the contents of the <code>/proc/partitions</code> file with the <code>cat</code> command:</p>
<div><div><img alt="Figure 6.8 – Listing the /proc/partitions file" src="img/B19682_06_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Listing the /proc/partitions file</p>
<p>To use <code>fdisk</code>, you must be the root user. We advise you to use caution when using <code>fdisk</code> as it can damage your existing partitions and disks. <code>fdisk</code> can be used on a particular disk as follows:</p>
<div><div><img alt="Figure 6.9 – Using fdisk for the first time" src="img/B19682_06_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Using fdisk for the first time</p>
<p>You will notice that when using <code>fdisk</code> for the first time, you are warned that changes will be done to the disk only when you decide to write them to it. You will also be prompted to introduce a command, and you will be shown the <code>m</code> option for help. We advise you to always use the help menu, even if you already know the most used commands.</p>
<p>When you type <code>m</code>, you will be shown the entire list of commands available for <code>fdisk</code>. You will see options to manage partitions, create new boot records, save changes, and others. Partition table editors <a id="_idIndexMarker856"/>are important tools for managing disks in Linux. Their use is incomplete if you do not know how to format a partition. In the next section, we will show you how to partition a disk drive.</p>
<h3>Creating and formatting partitions</h3>
<p>We will use the <code>fdisk</code> utility to create<a id="_idIndexMarker857"/> a new partition table on a USB memory stick plugged<a id="_idIndexMarker858"/> into our primary workstation running Debian GNU/Linux. We will create an MBR partition table using the following command:</p>
<pre class="console">
sudo fdisk /dev/sda</pre> <p>We will use the <code>o</code> option to create an empty MBR partition table and then the <code>w</code> option to save the changes to disk. The output of the command is shown in the following screenshot:</p>
<div><div><img alt="Figure 6.10 – Creating a new MBR partition table with fdisk" src="img/B19682_06_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Creating a new MBR partition table with fdisk</p>
<p>With that, the partition<a id="_idIndexMarker859"/> table has been created, but there is no partition defined<a id="_idIndexMarker860"/> on the disk. While still inside the <code>fdisk</code> command-line interface, you can use the <code>v</code> option to verify the newly created partition table and the <code>I</code> option to see information about existing partitions. You will see some output saying that no partitions have been defined yet. So, it is time to set up a new partition.</p>
<p>To create a new partition, we will use the following series of options:</p>
<ul>
<li>The <code>n</code> option to start the creation processes</li>
<li>The <code>p</code> option when asked to create either a primary (<code>p</code>) or extended (<code>e</code>) partition type</li>
<li>Enter the partition number (use the default of <code>1</code>)</li>
<li>Enter the first sector (use the default of <code>2048</code>)</li>
<li>Enter the last sector – if you want a specific size for the partition, you can use size values in KB, MB, GB, and so on, or sector values (the default is the maximum size of the disk)</li>
<li>If asked to remove any signatures, type <code>Y</code> to remove them</li>
<li><code>w</code> to write changes to disk</li>
</ul>
<p>The output of the previous series of actions is shown in the following screenshot:</p>
<div><div><img alt="Figure 6.11 – Creating a new partition with fdisk" src="img/B19682_06_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Creating a new partition with fdisk</p>
<p>With that, the partition<a id="_idIndexMarker861"/> has been created, but it hasn’t been formatted. Before we learn<a id="_idIndexMarker862"/> how to format partitions, let’s learn how to back up a partition table.</p>
<p>There are situations<a id="_idIndexMarker863"/> when you will need to back up and restore your <code>dd</code> utility. The command to use is as follows:</p>
<pre class="console">
sudo dd if=/dev/sda of=mbr-backup bs=512 count=1</pre> <p>This program is very useful and powerful as it can clone disks or wipe data. Here is an example showing the output of the command:</p>
<div><div><img alt="Figure 6.12 – Backing up MBR with the dd command" src="img/B19682_06_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Backing up MBR with the dd command</p>
<p>The <code>dd</code> command has a clear<a id="_idIndexMarker864"/> syntax. By default, it uses the standard input and standard<a id="_idIndexMarker865"/> output, but you can change those by specifying new input files with the <code>if</code> option, and output files with the <code>of</code> option. We specified the input file as the device file for the disk we wanted to back up and gave a name for the backup output file. We also specified the block size using the <code>bs</code> option, and the <code>count</code> option to specify the number of blocks to read.</p>
<p>To restore the bootloader, we can use the <code>dd</code> command, as follows:</p>
<pre class="console">
sudo dd if=~/mbr-backup of=/dev/sda bs=512 count=1</pre> <p>Now that you have learned how to use <code>dd</code> to back up a partition table, let’s format the partition we created earlier. The most commonly used program for formatting a filesystem on a partition is <code>mkfs</code>. Formatting a partition is also known as <em class="italic">making</em> a filesystem, hence the name of the utility. It has specific tools for different filesystems, all using the same frontend utility. The following is a list of all filesystems supported by <code>mkfs</code>:</p>
<div><div><img alt="Figure 6.13 – Details regarding the mkfs utility" src="img/B19682_06_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Details regarding the mkfs utility</p>
<p>To format the target disk <a id="_idIndexMarker866"/>as having the <code>Ext4</code> filesystem, we will use the <code>mkfs</code> utility. The commands<a id="_idIndexMarker867"/> to execute are shown here:</p>
<ol>
<li>First, we will run the <code>fdisk</code> utility to make sure that we select the largest disk correctly. Run the following command:<pre class="source-code">
<strong class="bold">sudo fdisk -l</strong></pre></li> <li>Then, check the output with extreme caution and select the correct disk name.</li>
<li>Now that we know which disk to work with, we will use <code>mkfs</code> to format it as an <code>Ext4</code> filesystem. The output is shown here:</li>
</ol>
<div><div><img alt="Figure 6.14 – Formatting an Ext4 partition using mkfs" src="img/B19682_06_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Formatting an Ext4 partition using mkfs</p>
<p>When using <code>mkfs</code>, there are several options available. To create an <code>Ext4</code> type partition, you can either use the command <a id="_idIndexMarker868"/>shown in <em class="italic">Figure 6</em><em class="italic">.14</em> or you can use the <code>-t</code> option followed by the filesystem<a id="_idIndexMarker869"/> type. You can also use the <code>-v</code> option for a more verbose output, and the <code>-c</code> option for bad sector scanning while creating the filesystem. You can also use the <code>-L</code> option if you want to add a label for the partition right from the command. The following is an example of creating an <code>Ext4</code> filesystem partition with the name <code>newpartition</code>:</p>
<pre class="console">
sudo mkfs -t ext4 -v -c -L newpartition /dev/sda</pre> <p>Once a partition is formatted, it’s advised<a id="_idIndexMarker870"/> that you check it for errors. Similar to <code>mkfs</code>, there is a tool called <code>fsck</code>. This is a utility that sometimes<a id="_idIndexMarker871"/> runs automatically following an abnormal shutdown or on set intervals. It has specific programs for the most commonly used filesystems, just like <code>mkfs</code>. The following is the output of running <code>fsck</code> on one of our partitions. After running, it will show whether there are any problems. In the following screenshot, the output shows that checking the partition resulted in no errors:</p>
<div><div><img alt="Figure 6.15 – Using fsck to check a partition" src="img/B19682_06_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Using fsck to check a partition</p>
<p>After partitions are created, they need to be mounted; otherwise, they cannot be used.</p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="bold">Mounting</strong> is an important action in Linux, and any other operating system<a id="_idIndexMarker872"/> for that matter. By mounting, you give the operating system access to the disk resource in such a way that it looks like it is using a local disk. On Linux, the external disk that is mounted is linked to a mount point, which is a directory on the local filesystem. Mount points are essential to POSIX-compatible operating systems, such as Linux. Mounting a disk makes it accessible<a id="_idIndexMarker873"/> to the entire operating system through mount points. For more information on mounting, visit <a href="https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html">https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html</a>.</p>
<p>Each partition will be mounted inside the existing filesystem structure. Mounting is allowed at any point in the tree structure. Each filesystem is mounted<a id="_idIndexMarker874"/> under certain directories, created inside the directory<a id="_idIndexMarker875"/> structure. We will explore mounting and unmounting partitions in the next section.</p>
<h3>Mounting and unmounting partitions</h3>
<p>The <code>mount</code>, and the <code>umount</code>. To see whether<a id="_idIndexMarker877"/> a certain partition is mounted, you can simply type <code>mount</code> and see the output, which will be of a significant size. You can use <code>grep</code> to filter it:</p>
<pre class="console">
mount | grep /dev/sda</pre> <p>We are looking for <code>/dev/sda</code> in the output, but it is not shown. This means that the drive is not mounted.</p>
<p>To mount it, we need to make a new directory. For simplicity, we will show all the steps required until you mount and use the partition:</p>
<ol>
<li>Create a new directory to mount the partition. In our case, we created a new directory called <code>USB</code> inside the <code>/</code><code>home/alexandru</code> directory:<pre class="source-code">
<strong class="bold">mkdir USB</strong></pre></li> <li>Mount the partition using the following command:<pre class="source-code">
<code>mbr-backup</code> file we created a few steps back to the newly mounted USB memory stick using the following command:<pre class="source-code">
<strong class="bold">sudo cp mbr-backup USB/</strong></pre></li> </ol>
<p>The following is the output for all the commands from the preceding list:</p>
<div><div><img alt="Figure 6.16 – Mounting an external memory stick" src="img/B19682_06_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Mounting an external memory stick</p>
<p>The <code>mount</code> command needs <a id="_idIndexMarker878"/>to be used with superuser permission. If you try to mount<a id="_idIndexMarker879"/> an external USB device without <code>sudo</code>, you will get the following message:</p>
<div><div><img alt="Figure 6.17 – Error for not using sudo with mount" src="img/B19682_06_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Error for not using sudo with mount</p>
<p>The <code>mount</code> utility has many options available. Use the help menu to see everything that it has under the hood. Now that the partition has been mounted, you can start using it. If you want to unmount it, you can use the <code>umount</code> utility. You can use it as follows:</p>
<pre class="console">
sudo umount /dev/sda</pre> <p>When unmounting a filesystem, you may receive errors if that partition is still in use. Being in use means that certain programs from that filesystem are still running in memory, using files from that partition. Therefore, you first have to close all running applications, and if other processes are using that filesystem, you will have to kill them, too. Sometimes, the reason a filesystem is busy is not clear at first, and to know which files are open and running, you can use the <code>lsof</code> command:</p>
<pre class="console">
sudo lsof | grep /dev/sda</pre> <p>Mounting a filesystem only makes it available until the system is shut down or rebooted. If you want the changes to be persistent, you will have to edit the <code>/etc/fstab</code> file accordingly. First, open the file with your favorite text editor:</p>
<pre class="console">
sudo nano /etc/fstab</pre> <p>Add a new line similar to the one that follows:</p>
<pre class="console">
/dev/sda /mnt/sdb ext4 defaults 0 0</pre> <p>The <code>/etc/fstab</code> file is a configuration file for the filesystem table. It consists of a set of rules needed to control how the filesystems are used. This simplifies the need to manually mount and unmount each disk when used, by drastically reducing possible errors. The table has a six-column structure, with each column designated with a specific parameter. There is only one correct order for the parameters to work:</p>
<ul>
<li><strong class="bold">Device name</strong>: Either by using UUID or the mounted device name</li>
<li><strong class="bold">Mount point</strong>: The directory where the device is, or will be, mounted</li>
<li><strong class="bold">Filesystem type</strong>: The filesystem type used</li>
<li><strong class="bold">Options</strong>: The options shown, with multiple ones separated by commas</li>
<li><code>0</code> = no backup, <code>1</code> = dump utility backup</li>
<li><code>0</code> = no <code>fsck</code> filesystem check, with <code>1</code> for the root filesystem, and <code>2</code> for other partitions</li>
</ul>
<p>By updating the <code>/etc/fstab</code> file, the mounting is permanent and is not affected by any shutdown or system reboot. Usually, the <code>/etc/fstab</code> file only stores information about the internal hard<a id="_idIndexMarker880"/> drive partitions and filesystems. The external hard drives or USB drives are automatically mounted under <code>/media</code> by the kernel’s <strong class="bold">hardware abstraction </strong><strong class="bold">layer</strong> (<strong class="bold">HAL</strong>).</p>
<p>By now, you should be comfortable<a id="_idIndexMarker881"/> with managing partitions in Linux, but there is still one type <a id="_idIndexMarker882"/>of partition we have not discussed: the <strong class="bold">swap partition</strong>. In the next section, we will introduce you to how swap works on Linux.</p>
<h3>Swap partition</h3>
<p>Linux uses a robust swap implementation. The virtual memory<a id="_idIndexMarker883"/> uses hard drive space when physical memory is full through swap. This additional space is made available either for the programs that do not use all the memory they are given, or when memory pressure is high. Swapping is usually done using one or more dedicated partitions as Linux permits multiple swap areas. The recommended swap size is at least the total RAM on the system. To check the actual swap used on the system, you can concatenate the <code>/proc/swaps</code> file or use the <code>free</code> command to see swap utilization, as shown in the following screenshot:</p>
<div><div><img alt="Figure 6.18 – Checking the currently used swap" src="img/B19682_06_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Checking the currently used swap</p>
<p>If swap is not set up on your system, you can format a partition as swap and activate it. The commands to do that are as follows:</p>
<pre class="console">
mkswap /dev/sda1
swapon /dev/sda1</pre> <p>The operating system is caching file contents inside the memory to prevent the use of swap as much as possible. This happens because memory is working at much higher speeds compared to hard drives or hard disk drives. Only when available memory is limited will swap be used. However, the memory that the kernel uses is never swapped; only the memory that the user space is using gets to be swapped. This assures data integrity for the kernel. Refer to the utilities we applied in <a href="B19682_05.xhtml#_idTextAnchor104"><em class="italic">Chapter 5</em></a> to show memory usage in Linux.</p>
<p>Filesystems and partitions<a id="_idIndexMarker884"/> are the bare bones of any disk management task, but there are still several hiccups that an administrator needs to overcome, and this can be solved by using logical volumes. This is why, in the next section, we will introduce you to LVM.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor134"/>Introducing LVM in Linux</h1>
<p>Some of you may have already heard of <strong class="bold">LVM</strong>. For those who do not know what<a id="_idIndexMarker885"/> it is, we will explain it briefly in this section. Imagine a situation where your disks run out of space. You can always move it to a larger disk and then replace the smaller one, but this implies system restarts and unwanted downtimes. As a solution, you can consider LVM, which offers more flexibility and efficiency. By using LVM, you can add more physical disks to your existing volume groups while they’re still in use. This still offers the possibility to move data to a new hard drive but with no downtime – everything is done while filesystems are online.</p>
<p>The utilities used in Linux for LVM management are called <code>pvcreate</code>, <code>vgcreate</code>, <code>vgdisplay</code>, <code>lvcreate</code>, <code>lvextend</code>, and <code>lvdisplay</code>. Let’s learn how to use them.</p>
<p>As we don’t have a system with LVM <a id="_idIndexMarker886"/>set up just yet, we will show you the steps that are necessary to create new LVM volumes by using another system with two internal drives: one with the operating system installed on it, and a second, internal one that’s available. We’ll be using Debian GNU/Linux, but the commands are the same for any other Linux-based operating system.</p>
<p>Follow these steps to create an LVM volume:</p>
<ol>
<li>Use the <code>fdisk</code> command to verify the names of the available disks (you can also use <code>lsblk</code> for this step):<pre class="source-code">
<code>/dev/sda</code>.</p></li> <li>Create the LVM physical volume with the <code>pvcreate</code> command:<pre class="source-code">
<code>wipefs</code> utility. The output is shown in the following screenshot:</p></li> </ol>
<div><div><img alt="Figure 6.19 – Using pvcreate to create an LVM physical volume" src="img/B19682_06_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Using pvcreate to create an LVM physical volume</p>
<ol>
<li value="3">Create a new volume group<a id="_idIndexMarker887"/> to add the new physical volume to using the <code>vgcreate</code> command:<pre class="source-code">
<code>vgdisplay</code> command:</li>
</ol>
<div><div><img alt="Figure 6.20 – Creating and viewing details of the new volume" src="img/B19682_06_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Creating and viewing details of the new volume</p>
<ol>
<li value="5">Now, let’s create a logical volume using some of the space available from the volume group, using <code>lvcreate</code>. Use the <code>-n</code> option to add a name for the logical volume and <code>-L</code> to set the size in a human-readable manner (we created a 5 GB logical volume named <code>projects</code>):</li>
</ol>
<div><div><img alt="Figure 6.21 – Creating a logical volume using lvcreate" src="img/B19682_06_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Creating a logical volume using lvcreate</p>
<ol>
<li value="6">Check whether the logical volume exists:<pre class="source-code">
<strong class="bold">sudo ls /dev/mapper/newvolume-projects</strong></pre></li> <li>The newly created device can only be used if it’s formatted using a known filesystem and mounted <a id="_idIndexMarker888"/>afterward, in the same way as a regular partition. First, let’s format the new volume:</li>
</ol>
<div><div><img alt="Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem" src="img/B19682_06_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem</p>
<ol>
<li value="8">Now, it’s time to mount the logical volume. First, create a new directory and mount the logical volume there. Then, check its size using the <code>df</code> command:</li>
</ol>
<div><div><img alt="Figure 6.23 – Mounting the logical volume" src="img/B19682_06_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Mounting the logical volume</p>
<ol>
<li value="9">All changes implemented hitherto are not permanent. To make them permanent, you will have to edit the <code>/etc/fstab</code> file by adding the following within the file:<pre class="source-code">
<code>vgdisplay</code> command to see the following details:<pre class="source-code">
<code>lvextend</code> command. We will extend the initial size by 5 GB, for a total of 10 GB. The following is an example:</li>
</ol>
<div><div><img alt="Figure 6.24 – Extending the logical volume using lvextend" src="img/B19682_06_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Extending the logical volume using lvextend</p>
<ol>
<li value="12">Now, resize the filesystem so that it fits the new size of the logical volume using <code>resize2fs</code> and check for the size with <code>df</code>:</li>
</ol>
<div><div><img alt="Figure 6.25 – Resizing the logical volume with resize2fs and checking for the size with df" src="img/B19682_06_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Resizing the logical volume with resize2fs and checking for the size with df</p>
<p>LVM is an advanced topic that will prove essential<a id="_idIndexMarker889"/> for any Linux system administrator to have. The brief hands-on examples we provided in this section only show the basic operations that you need to work with LVM. Feel free to dig deeper into this topic if you need to.</p>
<p>In the following section, we will discuss several more advanced LVM topics, including how to take full filesystem snapshots.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor135"/>LVM snapshots</h2>
<p>What is an LVM snapshot? It is a frozen instance of an LVM <a id="_idIndexMarker890"/>logical volume. More specifically, it uses a <strong class="bold">copy-on-write</strong> technology. This technology monitors each block of the existing volume, and when<a id="_idIndexMarker891"/> blocks change, due to new writings, that block’s value is copied to the snapshot volume.</p>
<p>The snapshots are created constantly and instantly and persist until they are deleted. This way, you can create backups from any snapshot. As snapshots are constantly changing due to the copy-on-write technology, initial thoughts on the size of the snapshot should be given when creating one. Take into consideration, if possible, how much data is going to change during the existence of the snapshot. Once the snapshot is full, it will be automatically disabled.</p>
<h3>Creating a new snapshot</h3>
<p>To create a new snapshot, you can<a id="_idIndexMarker892"/> use the <code>lvcreate</code> command, with the <code>-s</code> option. You can also specify the size with the <code>-L</code> option and add a name for the snapshot with the <code>-n</code> option, as follows:</p>
<div><div><img alt="Figure 6.26 – Creating an LVM snapshot with the lvcreate command" src="img/B19682_06_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.26 – Creating an LVM snapshot with the lvcreate command</p>
<p>In the preceding command, we set a size of 5 GB and used the name <code>linux-snapshot-01</code>. The last part of the command contains the destination of the volume for which we created the snapshot. To list the new snapshot, use the <code>lvs</code> command:</p>
<div><div><img alt="Figure 6.27 – Listing the available volume and the newly created snapshot" src="img/B19682_06_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.27 – Listing the available volume and the newly created snapshot</p>
<p>For more information on the logical volumes, run the <code>lvdisplay</code> command. The output will show information about all the volumes, and among them, you will see the snapshot we just created.</p>
<p>When we created the snapshot, we gave it a size of 5 GB. Now, we would like to extend it to the size of the source, which was 10 GB. We will do this with the <code>lvextend</code> command:</p>
<div><div><img alt="Figure 6.28 – Extending the snapshot from 5 to 10 GB" src="img/B19682_06_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.28 – Extending the snapshot from 5 to 10 GB</p>
<p>As shown in the preceding screenshot, the name that the snapshot volume is using is different from the one we used. Even though we used the name <code>linux-snapshot-01</code> for the snapshot volume, if we do a listing of the <code>/dev/mapper/</code> directory, we will see that the name uses two more dashes<a id="_idIndexMarker893"/> instead. This is a convention that’s used to represent logical volume files.</p>
<p>Now that you know how to create snapshots, let’s learn how to restore a snapshot.</p>
<h3>Restoring a snapshot</h3>
<p>To restore a snapshot, first, you would need to unmount<a id="_idIndexMarker894"/> the filesystem. To unmount, we will use the <code>umount</code> command:</p>
<pre class="console">
sudo umount /home/alexandru/LVM</pre> <p>Then, we can proceed to restore the snapshot with the <code>lvconvert</code> command. After the snapshot is merged into the source, we can check this by using the <code>lvs</code> command. The output of the two commands is shown in the following screenshot:</p>
<div><div><img alt="Figure 6.29 – Restoring and checking the snapshot" src="img/B19682_06_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.29 – Restoring and checking the snapshot</p>
<p>Following the merge, the snapshot is automatically removed.</p>
<p>We have now covered all the basics of LVM in Linux. LVM is more complicated than normal disk partitioning. It might be intimidating to many, but it can show its strengths when needed. Nevertheless, it also comes with several drawbacks – for example, it can add unwanted complexity in a disaster recovery<a id="_idIndexMarker895"/> scenario or when a hardware failure occurs. But all this aside, it is still worth learning about.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor136"/>Summary</h1>
<p>Managing filesystems and disks is an important task for any Linux system administrator. Understanding how devices are managed in Linux, and how to format and partition disks, is essential. Furthermore, it is important to learn about LVM as it offers a flexible way to manage partitions.</p>
<p>Mastering those skills will give you a strong foundation for any basic administration task. In the following chapter, we will introduce you to the vast domain of <strong class="bold">networking</strong> in Linux.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor137"/>Questions</h1>
<p>If you managed to skim through some parts of this chapter, you might want to recap a few essential details about Linux filesystem and disk management:</p>
<ol>
<li>Think of another tool to use for working with disks and install it.<p class="list-inset"><code>parted</code> and use it from the command line. You can also use GParted from the GUI.</p></li>
<li>Experiment with using Disks (in GNOME) and KDE Partition Manager (in KDE) and use the command-line interface side by side.<p class="list-inset"><strong class="bold">Hint</strong>: Keep both applications open and use the command-line utilities side by side. Try to format and mount a disk from the command line while keeping the GUI apps open.</p></li>
<li>Format new partitions using different filesystems.<p class="list-inset"><code>btrfs</code> instead of <code>ext4</code>.</p></li>
<li>Explore your filesystem and disks.<p class="list-inset"><code>lsblk</code>, <code>df</code>, and <code>fdisk</code>.</p></li>
</ol>
<h1 id="_idParaDest-122"><a id="_idTextAnchor138"/>Further reading</h1>
<p>For more information about what was covered in this chapter, please refer to the following Packt titles:</p>
<ul>
<li><em class="italic">Linux Administration Best Practices</em>, by Scott Alan Miller</li>
<li><em class="italic">Mastering Ubuntu Server – Fourth Edition</em>, by Jay LaCroix</li>
</ul>
</div>
</body></html>