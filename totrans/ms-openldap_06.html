<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. LDAP Schemas</h1></div></div></div><a class="indexterm" id="id562"/><p>The focus of this chapter will be LDAP Schemas. Schemas are the standard way of describing the structure of objects that may be stored inside the directory. The first few sections are designed to provide foundational knowledge of what schemas do and how they work—a foundation necessary for our work, later in this chapter, using and implementing schemas. But we will continue on from there to a number of more practical topics, including adding pre-defined schemas and defining our own custom schemas.</p><p>We will begin with a general examination of schemas. From there, we will look at schema hierarchies. Like the directory information tree itself, schemas are organized into hierarchies. Next, we will examine some of the basic schemas that are included with OpenLDAP. We will also look at two overlays that require their own schemas. Finally, we will create a custom schema consisting of a pair of new object classes, each with new attributes. The main topics we will discuss in this chapter are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basics of schema definitions</li><li class="listitem" style="list-style-type: disc">The three types of object classes</li><li class="listitem" style="list-style-type: disc">Using different schemas in OpenLDAP</li><li class="listitem" style="list-style-type: disc">Configuring the Accesslog and Password Policy Overlays</li><li class="listitem" style="list-style-type: disc">Obtaining and using an Object Identifier (OID)</li><li class="listitem" style="list-style-type: disc">Creating new schemas by hand</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Introduction to LDAP Schemas</h1></div></div></div><p>We have already looked at a variety of attributes and object classes used in OpenLDAP. For example, we created entries for our users using the <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code> object classes and, in so doing, we used attributes like <code class="literal">cn</code>, <code class="literal">sn</code>, <code class="literal">uid</code>, <code class="literal">mail</code>, and <code class="literal">userPassword</code>. We also created groups using the <code class="literal">groupOfNames</code> and <code class="literal">groupOfUniqueNames</code> object classes, paying special attention to the <code class="literal">member</code> and <code class="literal">uniqueMember</code> attributes. We even looked briefly (in Chapter 3) at object classes and attributes for describing documents and collections of documents (<code class="literal">document</code> and <code class="literal">documentCollection</code> respectively).</p><p>Each of these object classes and attributes has a strict definition. The definitions of attributes and object classes are bundled together into larger collections called schemas. OpenLDAP applications use these schemas to determine how records should be structured and where (in the hierarchical structure) each entry can be located.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Why Do They Look So Complicated?</h2></div></div></div><a class="indexterm" id="id563"/><p>LDAP schemas have a bad reputation. They are viewed as complex, arcane, hyper-technical, and difficult to implement. The goal of this chapter is to overcome this perception.</p><p>It is understandable why this reputation persists though. I think there are a few aspects of LDAP schemas that are daunting to the neophyte.</p><p>First, LDAP schemas are based on generations of technical specifications coming out of the complex X.500 system. Because of this heritage, LDAP schemas make frequent use of equipment that is not particularly human-friendly, such as object identifier numbers that look like this: <code class="literal">1.3.6.1.4.1.1466.115.121.1.25</code>. However, a little bit of background knowledge can overcome this hurdle.</p><p>Second, the LDAP schema definition language is notably different from the sorts of definition languages (DDL) familiar to SQL developers. This is largely due to the different nature of the backend database. LDAP is not inherently tabular as relational databases are, while it does make frequent use of concepts like inheritance (a rarity in SQL DDL languages, though some do support the idea). Finally, while SQL DDL takes the form of a SQL command, LDAP schema definitions are purely descriptive.</p><p>But the LDAP schema language is actually quite compact and typically only two directives (<code class="literal">attributetype</code> and <code class="literal">objectclasstype</code>), each with a handful of arguments, are needed in order to create custom schemas. For this reason, the learning curve is short, and by the end of this chapter you should be able to comfortably create your own schemas.</p><p>Typically schemas are written in plain-text files and stored in a subdirectory of the OpenLDAP configuration folder. In Ubuntu these files are located at <code class="literal">/etc/ldap/schema</code>. If you built from source the schema files are located by default at <code class="literal">/usr/local/etc/openldap/schema</code>.</p><p>SLAPD does not automatically use all of the schemas in the schema directory. When SLAPD starts up, it loads only the schemas specified in the <code class="literal">slapd.conf</code> file.</p><div><div><h3 class="title"><a id="note91"/>Note</h3><p>There is an exception to this rule: certain vital LDAP schema components, like <code class="literal">objectclass</code>, are hard-coded into OpenLDAP, since they are fundamental to the operation of the server.</p></div></div><p>Usually schemas are included using the <code class="literal">include</code> directive. In Chapter 2 we included three schema files in our <code class="literal">slapd.conf</code> file. The include section, near the top of the file, looks like this:</p><div><pre class="programlisting">include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema</pre></div><p>The first line imports the core schema, which contains the schemas of attributes and object classes necessary for standard LDAP use. The second imports a number of commonly used object classes and attributes, including those used for storing document information and DNS records. The <code class="literal">inetorgperson.schema</code> file includes the inetOrgPerson object class definition and its associated attribute definitions.</p><p>In the coming sections we will look at the format of these files, implementing some existing schemas, and finally creating our own schema.<a class="indexterm" id="id564"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Schema Definitions</h2></div></div></div><a class="indexterm" id="id565"/><p>LDAP schemas are used to formally define attributes, object classes, and various rules for structuring the directory information tree. The term <strong>schema</strong> refers to a collection of (conceptually related) schema definitions. The <code class="literal">inetOrgPerson</code> schema, for example, contains the definition of the <code class="literal">inetOrgPerson</code> object class, as well as all of the extra (non-core) attributes that are allowed or required by the <code class="literal">inetOrgPerson</code> object class.</p><p>A <strong>schema definition</strong> is a special type of directive that provides information about how a particular entity in SLAPD is to be structured. There are four different types of schema definition that can be included in <code class="literal">slapd.conf</code> (or an included schema definition):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Object class definitions</strong>: <a class="indexterm" id="id566"/><a class="indexterm" id="id567"/>This defines an object class, including its unique identifier, its name, and the attributes it may or must have.</li><li class="listitem" style="list-style-type: disc"><strong>Attribute definitions</strong>: <a class="indexterm" id="id568"/><a class="indexterm" id="id569"/>This defines an attribute, including its unique identifier, its name or names, the rules for what types of content will be allowed as values, and how matching operations are performed.</li><li class="listitem" style="list-style-type: disc"><strong>Object identifiers</strong>: <a class="indexterm" id="id570"/><a class="indexterm" id="id571"/>This attaches a string name to a unique identifier. It is primarily used to expedite creating schemas.</li><li class="listitem" style="list-style-type: disc"><strong>DIT content rules</strong>: <a class="indexterm" id="id572"/><a class="indexterm" id="id573"/>This specifies rules for what additional (auxiliary) object classes an entry with a particular structural object class may have.</li></ul></div><p>In addition to these four, there are other schema definitions that are not typically placed in a schema. Instead, most of these are generated by OpenLDAP code. Here is a brief description of what each does (for more information see RFC 4512, which defines the LDAP schema language):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Matching rule definitions</strong>: <a class="indexterm" id="id574"/>These define a rule used for matching operations. Searches may use matching rules (such as equality and substring matching) to find specific attribute values. For example, the <code class="literal">distinguishedNameMatch</code> matching rule (with unique identifier <code class="literal">2.5.13.1</code>) defines the matching rule for exactly matching DNs. This rule is used by attributes like <code class="literal">member</code> (for group membership) and <code class="literal">seeAlso</code>. Searching with this rule will return successful results only if an attribute's value matches the given DN. The matching rules for any attribute determine what indexes can be created for that attribute.</li><li class="listitem" style="list-style-type: disc"><strong>Matching rule uses</strong>: <a class="indexterm" id="id575"/>These map attributes to matching rules, and is usually created dynamically by SLAPD. Based on this definition, a client can tell which attributes a particular matching rule can be applied to. It can be used, for example, to find out all of the attribute values that support exact DN matches (the <code class="literal">distinguishedNameMatch</code> matching rule). The schema definition for a matching rule use (<code class="literal">matchingRuleUse</code>) contains a unique identifier, the matching rule name, and all of the attributes that this matching rule applies to.</li><li class="listitem" style="list-style-type: disc"><strong>LDAP syntaxes</strong>: <a class="indexterm" id="id576"/>These describe the syntax allowed for the content of an attribute value. The exact type and syntax of data for an attribute value can be specified when an attribute is defined. There are a number of supported syntaxes (<code class="literal">ldapSyntaxes</code>) defined for SLAPD, including a syntax for the DN structure, one for binary data, several for kinds of plain text data, and so on. We will talk about supported syntaxes more when we look at attribute definitions.</li><li class="listitem" style="list-style-type: disc"><strong>Structure rules</strong>: <a class="indexterm" id="id577"/>These define where in a directory information tree a given entry can be located. It is based on the structural object class of the entry. Structural object classes and the object class hierarchy are discussed later in the section <em>The</em> <em>Object</em> <em>Class</em> <em>Hierarchy</em> section.</li><li class="listitem" style="list-style-type: disc"><strong>Name forms</strong>: <a class="indexterm" id="id578"/>These specify what attributes may or must be used in the RDN portion of an entry's DN (based on the entry's structural object class).</li></ul></div><p>SLAPD builds this part of the schema in code. For example, matching rule uses are generated based on what matching rules exist and what attributes implement those matching rules. Like the rest of the schema, matching rules, LDAP syntaxes, structure rules, and name forms can all be accessed over the LDAP protocol. See the <em>Retrieving</em> <em>Schemas</em> <em>from</em> <em>SLAPD</em> section for more information.</p><p>For the time being though, we will focus primarily on the four schema definitions that can be included in the <code class="literal">slapd.conf</code> file. In particular, we will focus on creating new object classes and attributes.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Object Classes and Attributes</h2></div></div></div><p>There are two different types of schema definition that we need in order to extend the types of information that our directory server will store:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Attribute type definition</strong>: An attribute type definition defines an attribute, including what attribute names it may have (for example, <code class="literal">cn</code> and <code class="literal">commonName</code>), what sort of values an attribute may contain (numbers, string, DNs, and so on), what rules to use when trying to match values, and whether it may have more than one value.<p>Any given attribute may require that its value or values be composed of certain characters or data types. For example, the <code class="literal">description</code> attribute allows long strings of characters, which makes it possible to include a sentence or two of information as a value to a description field.</p></li><li class="listitem" style="list-style-type: disc"><strong>Object class definition</strong>: An object class definition specifies the name of the object class, what attributes it must have, what attributes it may have, and what kind of object it is.</li></ul></div><p>We will look at each of these in turn. To start, let's take another look at one of the schemas introduced in Chapter 3. Here is a graphical representation of the <code class="literal">person</code> object class:</p><div><img alt="Object Classes and Attributes" src="img/1021_06_01.jpg"/></div><p>The <code class="literal">person</code> object class has two required attributes (<code class="literal">cn</code> and <code class="literal">sn</code>) and four more attributes that are allowed, but not required: <code class="literal">userPassword</code>, <code class="literal">telephoneNumber</code>, <code class="literal">seeAlso</code>, and <code class="literal">description</code>.</p><p>A new record that is of object class <code class="literal">person</code> (and has no other object classes) might look like this:</p><div><pre class="programlisting">dn: cn=Thomas Reid, dc=example,dc=com
objectclass: person
cn: Thomas Reid
sn: Reid
userPassword:: DSFSUYJKHGH=
telephoneNumber: 555-555-5555
seeAlso: uid=david,ou=users,dc=example,dc=com
description: A basic user.</pre></div><p>This record contains all, and only, the attributes in the <code class="literal">person</code> object class. Attempting to add a different attribute type not mentioned in the schema would lead to an error. Similarly, trying to remove all values for the <code class="literal">cn</code> or <code class="literal">sn</code> attributes would also lead to an error since their presence is required.</p><p>But how does OpenLDAP know which attributes are required and which are allowed? This information is stored in the schema definition for the <code class="literal">person</code> object class.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Object Class Definitions</h2></div></div></div><p>The<a class="indexterm" id="id579"/> schema definition is stored in the <code class="literal">core.schema</code> (and also in <code class="literal">core.ldif</code>) file at <code class="literal">/etc/ldap/schema</code> (or <code class="literal">/usr/local/etc/openldap/schema</code> if you compiled from source). Have a look at this:</p><div><pre class="programlisting">objectclass 
  ( 
   2.5.6.6
   NAME 'person'
   DESC 'RFC4519: a person'
   SUP top STRUCTURAL
   MUST ( sn $ cn )
   MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) 
  )</pre></div><p>This is a simple object class definition. It begins with a descriptor, <code class="literal">objectclass</code>, which tells the schema interpreter what type of definition is being made. The rest of the definition is enclosed in parentheses. Extra whitespace characters, including line breaks, are generally ignored (unless enclosed in a quoted string), but remember that </p><p>since <code class="literal">objectclass</code> is a directive in the <code class="literal">slapd.conf</code> file format, every line other than the first must start with a whitespace character.</p><p>The first field within the definition is the numeric identifier for the object class: <code class="literal">2.5.6.6</code>. This<a class="indexterm" id="id580"/>
<a class="indexterm" id="id581"/> unique<a class="indexterm" id="id582"/> identifier is called an <strong>Object IDentifier </strong>(<strong>OID</strong>). Every schema definition has a unique OID that distinguishes that definition from any other definition in the world. Because this OID is supposed to be globally unique there is an official procedure for giving a definition a unique identifier. This will be described later in the chapter. For now it is sufficient to note that these OIDs must be universally unique.</p><p>Any LDAP application may refer to a definition by its OID. Object classes, attributes, matching rules, and many other LDAP entities have OIDs.</p><div><div><h3 class="title"><a id="note92"/>Note</h3><p>The<a class="indexterm" id="id583"/> Root DSE record is a good example of how LDAP clients can learn important information about a server's capabilities based on the OIDs that the server presents to the client. See <a class="link" href="apc.html" title="Appendix C. Useful LDAP Commands">Appendix C</a> for an example.</p></div></div><p>The second field in the definition is the <code class="literal">NAME</code> field. While an OID is easily used by a computer, it is not so easily used by humans. So, in addition to an OID, server-unique names (in character strings) may be specified. The above object class only has one name: <code class="literal">person</code>. Multiple names can be given to a single object class, but usually a single one will suffice.</p><p>In a schema definition, the string names should always be enclosed in single quotation marks. In a list of string values, each value must be enclosed in single quotes and the entire list must be enclosed in parentheses. For example, if the person definition specified two names, <code class="literal">person</code> and <code class="literal">humanBeing</code>, the <code class="literal">NAME</code> field would look like this:</p><div><pre class="programlisting">NAME ( 'person' 'humanBeing' )</pre></div><p>Note also that spaces are not allowed in the values of the <code class="literal">NAME</code> field, so <code class="literal">'human</code> <code class="literal">being'</code> would be an illegal name.</p><div><div><h3 class="title"><a id="note93"/>Note</h3><a class="indexterm" id="id584"/><p>In attribute definitions, it is more common to give attributes a long name and an abbreviated name. For example, <code class="literal">cn</code> and <code class="literal">commonName</code> are both names for the attribute with OID <code class="literal">2.5.4.3</code>.</p></div></div><p>Most of the time object classes and attributes are referred to by the values in the <code class="literal">NAME</code> field rather than by OID.</p><div><div><h3 class="title"><a id="note94"/>Note</h3><p>By convention, names that consist of multiple words are concatenated by capitalizing the first letter of each word after the first. For example, <code class="literal">commonName</code> is composed of two words: <code class="literal">common</code> and <code class="literal">name</code>. Only the second word is capitalized. Underscores, dashes, and other special characters are typically not used to concatenate words. Thus, you should not use names like <code class="literal">common_name</code> or <code class="literal">common-name</code>.</p></div></div><p>The <code class="literal">DESC</code> field is a brief description of what this schema definition is to be used for. In this case the description field refers to an RFC (RFC 4519) that gives a detailed explanation of the object class. Of course it is not necessary to create an RFC to formally define your schemas, though if you plan on distributing the schema widely writing an RFC is a good idea.</p><p>The next field, <code class="literal">SUP</code>, which is short for 'superior,' indicates what the parent object class of this object class is. The parent of the <code class="literal">person</code> object class is the object class called <code class="literal">top</code>. Object classes, like directory information trees, are organized in hierarchies. The <code class="literal">top</code> object class is at the top of the object class hierarchy. The <code class="literal">STRUCTURAL</code> keyword also pertains to how this schema definition fits into the schema hierarchy. We will discuss schema hierarchies in the next part.</p><p>The last two fields are less mysterious. They define which attributes a <code class="literal">person</code> object must (<code class="literal">MUST</code>) contain, and which attributes an object may (<code class="literal">MAY</code>) contain.</p><p>The syntax for the <code class="literal">MUST</code> and <code class="literal">MAY</code> fields is straightforward. Each description takes a list of attributes:</p><div><pre class="programlisting">MAY ( userPassword $ telephoneNumber $ seeAlso $ description )</pre></div><p>The<a class="indexterm" id="id585"/> list of attribute values (designated either by OID or by an attribute name) is enclosed in parentheses. Values are separated with the dollar sign (<code class="literal">$</code>). The example above indicates that the four values, <code class="literal">userPassword</code>, <code class="literal">telephoneNumber</code>, <code class="literal">seeAlso</code>, and <code class="literal">description</code>, are all attributes that a person object is allowed to have.</p><p>An attribute should be specified in only one of the two lists. There is no need to put an attribute in both a <code class="literal">MAY</code> and a <code class="literal">MUST</code> list.</p><p>Of course, the names can be replaced with OIDs instead. Thus, the following two lines are equivalent:</p><div><pre class="programlisting">   MUST ( sn $ cn )</pre></div><p>and </p><div><pre class="programlisting">   MUST ( sn $ 2.5.4.3 )</pre></div><p>The OID for the <code class="literal">cn</code> attribute is <code class="literal">2.5.4.3</code>, and either identifier will work.</p><p>There are a few fields that may be present in an object class definition but which are not present in the previous code. The first is the <code class="literal">OBSOLETE</code> keyword, which appears after the <code class="literal">DESC</code> field. This is used to designate an object class as obsolete but still (temporarily) supported.</p><p>The second is the extensions section, which is used for providing implementation-specific extensions to a schema. At the end of the schema one or more extensions may be specified. An extension is a keyword followed by a list enclosed in parentheses. By default, none of the schemas included in OpenLDAP's <code class="literal">schema/</code> directory have any extensions.</p><p>In summary then, an object class definition begins with the <code class="literal">objectclasstype</code> directive, and can contain the following fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A unique OID to identify this object class (example: <code class="literal">2.5.6.6</code>).</li><li class="listitem" style="list-style-type: disc">A <code class="literal">NAME</code> field with a unique name (<code class="literal">NAME</code> <code class="literal">'person'</code>).</li><li class="listitem" style="list-style-type: disc">A <code class="literal">DESC</code> field with a brief description of the purpose of the object class (<code class="literal">DESC</code> <code class="literal">'RFC4519:</code> <code class="literal">a</code> <code class="literal">person'</code>).</li><li class="listitem" style="list-style-type: disc">Optionally, it may contain an <code class="literal">OBSOLETE</code> tag if the class is obsolete and should not be used.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">SUP</code> line, indicating what object class is the parent (superior) of this one. Also, this line should specify the type of object class (<code class="literal">STRUCTURAL</code>, <code class="literal">ABSTRACT</code>, or <code class="literal">AUXILLIARY</code>). Example: <code class="literal">SUP</code> <code class="literal">top</code> <code class="literal">STRUCTURAL</code>. Abstract classes do not have superiors. When defining an abstract class <code class="literal">SUP</code> can be omitted.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">MUST</code> field with a list of attributes that must be specified for an instance of this object class. Example: <code class="literal">MUST</code> <code class="literal">(</code> <code class="literal">sn</code> <code class="literal">$</code> <code class="literal">cn</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">MAY</code> field with a list of attributes that can optionally be added to records of this object class. Example: <code class="literal">MAY</code> <code class="literal">(</code> <code class="literal">userPassword</code> <code class="literal">$</code> <code class="literal">telephoneNumber</code> <code class="literal">$</code> <code class="literal">seeAlso</code> <code class="literal">$</code> <code class="literal">description</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc">One or more extensions.</li></ul></div><p>Object class definitions are an important part of schemas and we will look back at these concepts several times in this chapter. After covering other definition types, we will take a detailed look at the object class hierarchy. As we do that the role of the <code class="literal">SUP</code> line will become clearer.</p><p>Further on we will look at some specific object classes and we will also write our own custom object class. But before we move on to those things we will look at the other schema definitions. Next, we will look at attribute definitions.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Attribute Definitions</h2></div></div></div><p>The<a class="indexterm" id="id586"/> <code class="literal">person</code> object class that we examined now can have six different attributes—the two necessary <code class="literal">sn</code> and <code class="literal">cn</code> attributes, and the optional <code class="literal">userPassword</code>, <code class="literal">telephoneNumber</code>, <code class="literal">seeAlso</code>, and <code class="literal">description</code> attributes. Just as the object class was defined in the schema, so each attribute is also defined. The syntax for attribute definitions is similar though the fields allowed in the definition are different and more numerous.</p><p>The schema definition for the <code class="literal">telephoneNumber</code> attribute is a good example of a basic attribute definition:</p><div><pre class="programlisting">attributetype 
  ( 
   2.5.4.20
   NAME 'telephoneNumber'
   DESC 'RFC2256: Telephone Number'
   EQUALITY telephoneNumberMatch
   SUBSTR telephoneNumberSubstringsMatch
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.50{32} 
  )</pre></div><p>The attribute definition begins with an <code class="literal">attributetype</code> directive. The rest of the <a class="indexterm" id="id587"/>definition is enclosed in parentheses.</p><p>The first field in the definition is the unique OID for this attribute. As with all OIDs, this identifier must be globally unique. The OID <code class="literal">2.5.4.20</code> should only be used to refer to a <code class="literal">telephoneNumber</code> attribute. Later in this chapter, in the section <em>Getting</em> <em>an</em> <em>OID</em>, we will discuss getting and using a base OID.</p><p>After the OID comes the <code class="literal">NAME</code> field that associates one or more names with the attribute.</p><div><div><h3 class="title"><a id="note95"/>Note</h3><p>The names given in the <code class="literal">NAME</code> field are usually called <em>attribute</em> <em>descriptions</em> (see the discussion of the search operation in Chapter 3). This term is confusing when talking about schema definitions because the attribute schema definition has a description field, and that field is not the attribute description.</p></div></div><p>It is not uncommon for attributes to have two names—a long name (such as <code class="literal">commonName</code> or <code class="literal">surname</code>) and an abbreviated name (<code class="literal">cn</code> or <code class="literal">sn</code> respectively). When an attribute has multiple names, the list of names should be enclosed in parentheses. As an example, consider the <code class="literal">NAME</code> field for the <code class="literal">fax</code> attribute:</p><div><pre class="programlisting">attributetype 
  ( 
   2.5.4.23
<strong>   NAME ( 'facsimileTelephoneNumber' 'fax' )</strong>
   DESC 'RFC2256: Facsimile (Fax) Telephone Number'
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.22 
  )</pre></div><p>Note the syntax of the highlighted line. Each name in the list of names is enclosed in single quotes (<code class="literal">'</code>) and the entire list is enclosed in parentheses.</p><div><div><h3 class="title"><a id="note96"/>Note</h3><p>SLAPD will refer to attributes by the first name. Thus, if you search for the <code class="literal">fax</code> attribute SLAPD will return the matching attributes as <code class="literal">facsimileTelephoneNumber</code> not as <code class="literal">fax</code>.</p></div></div><p>The <code class="literal">DESC</code> field provides a brief description of the purpose of the attribute. In the <code class="literal">telephoneNumber</code> attribute definition, the value of this field is <code class="literal">'RFC2256:</code> <code class="literal">Telephone</code> <code class="literal">Number'</code>, indicating that the attribute is defined in RFC 2256.</p><p>One important aspect of defining an attribute is specifying how an application should test two attribute values to see if they match. Do <code class="literal">TEST</code> and <code class="literal">test</code> match? In some cases we might want them to, while in others we might not. Does <code class="literal">t*st</code> match <code class="literal">test</code>? Again, in some cases, this is desirable while in others it is not.</p><a class="indexterm" id="id588"/><p>We can determine, in the attribute definition, which matching rules should be used to test whether one value matches another. When we discussed the search operation in Chapter 3 we saw four different comparison operators that could be used in search filters:<a class="indexterm" id="id589"/>
<a class="indexterm" id="id590"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The equality operator (<code class="literal">=</code>)<a class="indexterm" id="id591"/><a class="indexterm" id="id592"/></li><li class="listitem" style="list-style-type: disc">The approximation operator (<code class="literal">~=</code>)<a class="indexterm" id="id593"/><a class="indexterm" id="id594"/></li><li class="listitem" style="list-style-type: disc">The greater-than-or-equal-to operator (<code class="literal">&gt;=</code>)<a class="indexterm" id="id595"/><a class="indexterm" id="id596"/></li><li class="listitem" style="list-style-type: disc">The less-than-or-equal-to operator: (<code class="literal">&lt;=</code><a class="indexterm" id="id597"/>)</li></ul></div><p>In addition to these we looked at using regular expression characters, such as the asterisk (<code class="literal">*</code>), to match portions, or substrings, of an attribute value. The behavior of each of these is determined, to a large degree, by the matching rules in the attribute definition.</p><p>When the LDAP server processes a comparison (during operations like binding, comparing, and searching) it uses the schema to determine how to handle these comparisons. The schema specifies which matching rules should be used. There are three different sorts of matching rules that can be assigned in a schema:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The equality rule, EQUALITY</li><li class="listitem" style="list-style-type: disc">The ordering rule, ORDERING<a class="indexterm" id="id598"/></li><li class="listitem" style="list-style-type: disc">The substring matching rule, SUBSTRING</li></ul></div><p>An attribute schema may specify rules for one, two, or all three of these. The value of each can be either the OID or the name of a matching rule. In the <code class="literal">telephoneNumber</code> schema, <code class="literal">EQUALITY</code> and <code class="literal">SUBSTRING</code> are used:</p><div><pre class="programlisting">EQUALITY telephoneNumberMatch
SUBSTR telephoneNumberSubstringsMatch</pre></div><p>When an equality test for a telephone number is requested, such as the evaluation of the filter <code class="literal">(telephoneNumber=+1</code> <code class="literal">234</code> <code class="literal">567</code> <code class="literal">8901)</code>, the <code class="literal">telephoneNumberMatch</code> rule is used. Note that the plus sign (<code class="literal">+</code>) is part of the telephone number, not part of the operator. If the filter includes a wild-card match, such as <code class="literal">(telephoneNumber=+1</code> <code class="literal">234</code> <code class="literal">567*)</code>, then the <code class="literal">telephoneNumberSubstringsMatch</code> rule is used instead.</p><div><div><h3 class="title"><a id="note97"/>Note</h3><p>With no <code class="literal">ORDERING</code> rule defined, SLAPD will not process matching tests for <code class="literal">&gt;=</code> or <code class="literal">&lt;=</code> operators. Any comparison will return false.</p></div></div><p>How do these two matching rules perform? Let's look at an example. When we defined the user with UID <code class="literal">matt</code>, we assigned that user a telephone number. Here, we will search for that entry, requesting only the <code class="literal">telephoneNumber</code> attribute:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -LL -U matt '(uid=matt)' telephoneNumber</strong>
</pre></div><p>And the search result is as follows:</p><div><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: uid=matt,ou=Users,dc=example,dc=com
telephoneNumber: +1 555 555 4321</pre></div><p>The <code class="literal">telephoneNumber</code> attribute has the value <code class="literal">+1</code> <code class="literal">555</code> <code class="literal">555</code> <code class="literal">4321</code>. Now let's perform a search using the telephone number:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -LL -U matt '(telephoneNumber=+1 555 555 4321)' uid \</strong>
<strong>       telephoneNumber</strong>
</pre></div><p>And the search result is as follows:</p><div><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: uid=matt,ou=Users,dc=example,dc=com
uid: matt
telephoneNumber: +1 555 555 4321</pre></div><p>As expected a search using the exact phone number returned a result. This looks no different from what we would expect a string matching rule to do. Using the special <code class="literal">telephoneNumberMatch</code> rule in the schema has some advantages though. When using this matching rule, SLAPD will ignore certain telephone number formatting characters. Here's an example using a substring search:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -LL -U matt '(telephoneNumber=+1 555-555-43*)' uid \</strong>
<strong>       telephoneNumber</strong>
</pre></div><p>Here is the result:</p><div><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: uid=matt,ou=Users,dc=example,dc=com
uid: matt
telephoneNumber: +1 555 555 4321</pre></div><p>The filter in this example uses dashes (<code class="literal">-</code>) where the previous filter used spaces. Using the <code class="literal">telphoneNumberSubstringMatch</code> rule, SLAPD ignored the dashes. With the <code class="literal">telephoneNumberMatch</code> and <code class="literal">telephoneNumberSubstringMatch</code> rules, the numbers <code class="literal">+15555554321</code>, <code class="literal">+1</code> <code class="literal">555</code> <code class="literal">555</code> <code class="literal">4321</code>, <code class="literal">1-5-5-55554-3-2-1</code>, and <code class="literal">+1</code> <code class="literal">555-555-4321</code> are all treated as identical matches.</p><p>This illustrates the virtue of being able to specify matching rules in the schema. For attributes such as <code class="literal">cn</code>, <code class="literal">sn</code>, or <code class="literal">mail</code> (email address), we certainly wouldn't want dashes to be treated the same as white space characters. We wouldn't want <code class="literal">Dan</code> <code class="literal">Forth</code> to match <code class="literal">Danforth</code>. But it is certainly a desirable feature when matching phone numbers. The LDAP answer to this problem is to assign matching rules fitting to the type of information stored in the attribute.</p><div><div><h3 class="title"><a id="note98"/>Note</h3><p>Other attributes, like <code class="literal">homePhone</code>, <code class="literal">pagerTelephoneNumber</code>, and <code class="literal">mobileTelephoneNumber</code> (all defined in <code class="literal">cosine.schema</code>) all use the <code class="literal">telephoneNumberMatch</code> and <code class="literal">telelphoneNumberSubstringMatch</code> matching rules too. Since they all share the same format there is no need to assign each a different specialized matching rule.</p></div></div><div><div><h3 class="title"><a id="note99"/>Note</h3><p><strong>Matching Rules and Indexes</strong></p><a class="indexterm" id="id599"/><a class="indexterm" id="id600"/><p>Some backends, such as BDB and HDB, support indexes (using the <code class="literal">index</code> directive in <code class="literal">slapd.conf</code>). The index supported is determined by the matching rules defined for an attribute. For example, an attribute with an equality matching rule can have an equality (<code class="literal">eq</code>) index. Likewise, one with a substring matching rule supports <code class="literal">sub</code> indexes.</p></div></div><p>The last field in the <code class="literal">telephoneNumber</code> matching scheme is the <code class="literal">SYNTAX</code> field. This relates to the type and structure of the data stored in values for <code class="literal">telephoneNumber</code> attributes.</p><div><pre class="programlisting">SYNTAX 1.3.6.1.4.1.1466.115.121.1.50{32}</pre></div><a class="indexterm" id="id601"/><a class="indexterm" id="id602"/><p>The value of the <code class="literal">SYNTAX</code> parameter has two parts. The first is the OID (or the name) of the LDAP syntax, and the second, set off in curly braces (<code class="literal">{</code> and <code class="literal">}</code>) is the maximum length (usually  the number of characters) for the field. The length specifier is optional, and the server is not obligated to enforce the maximum length.</p><p>The OID mentioned earlier, <code class="literal">1.3.6.1.4.1.1466.115.121.1.50</code>, is the telephone number syntax. This indicates that attribute values for instances of the <code class="literal">telephoneNumber</code> attribute are to contain the characters (integers, dashes, spaces, and so on) that a phone number would require. SLAPD will reject attempts to add phone numbers that contain letters and other special characters. Later in this chapter, in the <em>Creating</em> <em>a</em> <em>Schema</em> part, we will look at the list of common LDAP syntaxes that OpenLDAP supports.</p><p>As far as complexity goes the <code class="literal">telephoneNumber</code> attribute is about average. However, many attribute definitions are much shorter, taking advantage of the fields set in similar attributes. Thus, there are many attributes that, because they inherit most of their features from their superior (parent) attribute, have only an OID, a <code class="literal">NAME</code> field, and a <code class="literal">DESC</code> field. The schema definition for the ever popular <code class="literal">cn</code> attribute looks like this:</p><div><pre class="programlisting">attributetype 
  ( 
   2.5.4.3
   NAME ( 'cn' 'commonName' )
   DESC 'RFC2256: common name(s) for which the entity is known by'
   SUP name 
  )</pre></div><p>In this case, the <code class="literal">SUP</code> name field indicates that the <code class="literal">name</code> attribute is the parent of the <code class="literal">cn</code> attribute. Attributes, like object classes, can be organized hierarchically. A superior attribute is the parent or prototype for this attribute and certain properties, if left unspecified in the schema definition, are inherited from the superior. Syntax and matching rules, for example, can be inherited from a parent.</p><p>In the previous example no matching rules and no LDAP syntax were specified. Therefore, the <code class="literal">cn</code> attribute type inherits these values from its superior. The <code class="literal">name</code> attribute uses the <code class="literal">caseIgnoreMatch</code> <code class="literal">EQUALITY</code> matching rule and the <code class="literal">caseIgnoreSubstringMatch</code> <code class="literal">SUBSTR</code> rule, and uses the Directory String LDAP syntax (<code class="literal">1.3.6.1.4.1.1466.115.121.1.15</code>). A directory string is a UTF-8 encoded string intended to store text.</p><p>There are a handful of other fields that the previous examples do not make use of. These are <code class="literal">OBSOLETE</code>, <code class="literal">SINGLE-VALUE</code>, <code class="literal">COLLECTIVE</code>, <code class="literal">NO-USER-MODIFICATION</code>, <code class="literal">USAGE</code>, and the extension area. Let's briefly look at those.</p><a class="indexterm" id="id603"/><a class="indexterm" id="id604"/><p>The <code class="literal">OBSOLETE</code> flag, which usually appears after the <code class="literal">DESC</code> field, plays the same role in attribute definitions as it does in object class definitions. It labels an attribute obsolete. While obsolete attributes are still supported and can be used for records in the directory information tree, they are to be treated as deprecated, subject to removal in future versions of the schema or software. <code class="literal">OBSOLETE</code> takes no parameters.</p><a class="indexterm" id="id605"/><a class="indexterm" id="id606"/><p>The <code class="literal">SINGLE-VALUE</code> flag indicates that the defined attribute can only have one attribute value. Typically, an attribute can have an arbitrary number of values. But any attribute whose schema includes the <code class="literal">SINGLE-VALUE</code> flag can have no more than one. The domain component (<code class="literal">dc</code>) attribute that we looked at in Chapters 3 and 4 is an example of this. An object that has a <code class="literal">dc</code> attribute can only assign one value to that attribute. <code class="literal">SINGLE-VALUE</code> takes no parameters.</p><a class="indexterm" id="id607"/><a class="indexterm" id="id608"/><p>The <code class="literal">COLLECTIVE</code> flag indicates that this attribute is a collective attribute. Entries can be grouped, with collective attributes, into an <strong>entry collection</strong>.<a class="indexterm" id="id609"/>
</p><p>Collectives are implemented in OpenLDAP via the <code class="literal">collect</code> overlay, which is not compiled or installed by default, though it can be found in the <code class="literal">servers/slapd/overlays</code> directory of the source code. The schemas necessary for collective support are also not included by default in the OpenLDAP distribution, and must be copied from another source (such as RFC 3671).</p><p>Here's a rough idea of how entry collections work:<a class="indexterm" id="id610"/>
<a class="indexterm" id="id611"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">One record is the collection record, and must use the <code class="literal">collectiveAttributeSubentry</code> object class. This becomes the authority for that collective attribute. All other subordinate records then inherit the attribute (and its value) and the attribute is visible (though read-only) as an attribute of each of these records. For more information on collectives see RFC 3671 (<a class="ulink" href="http://www.ietf.org/rfc/rfc3671.txt">http://www.ietf.org/rfc/rfc3671.txt</a>).</li><li class="listitem">The <code class="literal">NO-USER-MODIFICATION</code> flag is used to indicate that the attribute is an operational attribute (used by SLAPD or an overlay), and cannot be modified by an LDAP client. This is not usually used in user-defined schemas. Use it only when writing a custom overlay that will make use of its own operational  attributes.</li><li class="listitem">The <code class="literal">USAGE</code> field provides SLAPD with information about what will use the attribute. There are four possible values. The first three, <code class="literal">directoryOperation</code>, <code class="literal">distributedOperation</code>, and <code class="literal">dSAOperation</code>, all indicate that SLAPD itself uses the attribute. The last, <code class="literal">userApplication</code>, is the default and it indicates that the attribute is primarily intended to be used by client applications. Since most schemas are intended for client application use, the default is usually what is desired and the <code class="literal">USAGE</code> field is rarely used.</li><li class="listitem">Finally, <code class="literal">attributetype</code> definitions can also use extensions, though there are no extensions used in the main schemas included in OpenLDAP. The syntax <a class="indexterm" id="id612"/>for extensions is the same for attribute types as it is for object class definitions.<a class="indexterm" id="id613"/></li></ol></div><p>In summary, an attribute schema definition begins with the <code class="literal">attributetype</code> directive which is followed by a schema definition enclosed in parentheses. The following fields are allowed in attribute definitions:<a class="indexterm" id="id614"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A unique OID number, which is required. Example: <code class="literal">2.5.4.15</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">NAME</code> field, with one or more names for the attribute. Example: <code class="literal">NAME</code> <code class="literal">'businessCategory'</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">DESC</code> field containing a description of the attribute type. Example: <code class="literal">DESC</code> <code class="literal">'RFC2256:</code> <code class="literal">business</code> <code class="literal">category'</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">DEPRECATED</code> tag, if the attribute is deprecated.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">SUP</code> field with the name or OID of the superior attribute type. Example: <code class="literal">SUP</code> <code class="literal">postalAddress</code>.</li><li class="listitem" style="list-style-type: disc">An <code class="literal">EQUALITY</code> matching rule OID or name. Example: <code class="literal">EQUALITY</code> <code class="literal">caseIgnoreMatch</code>.</li><li class="listitem" style="list-style-type: disc">An <code class="literal">ORDERING</code> matching rule OID or name.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">SUBSTR</code> matching rule OID or name. Example: <code class="literal">SUBSTR</code> <code class="literal">caseIgnoreSubstringsMatch</code>.</li><li class="listitem" style="list-style-type: disc">A <code class="literal">SYNTAX</code> field with an LDAP syntax OID, and an optional length. Example: <code class="literal">SYNTAX</code> <code class="literal">1.3.6.1.4.1.1466.115.121.1.15{128}</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">SINGLE-VALUE</code> flag, if the attribute can only have one value.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">COLLECTIVE</code> flag, if the attribute is a collective attribute.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">NO-USER-MODIFICATION</code> flag, if the attribute is an operational attribute that client applications should not be able to modify.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">USAGE</code> field, together with one of the four keywords (<code class="literal">userApplication</code>, <code class="literal">directoryOperation</code>, <code class="literal">distributedOperation</code>, or <code class="literal">dSAOperation</code>) used to indicate what the attribute is to be used for.</li><li class="listitem" style="list-style-type: disc">Any extensions that the attribute definition requires.<a class="indexterm" id="id615"/></li></ul></div><p>At this point we have looked at both object class definitions and attribute definitions. When creating your own custom schemas it is most likely that these are the only two types of schema definitions that you will need to use.</p><p>We have discussed the basics of schemas and seen a few examples in the text. Later in this chapter we will look at some other specific examples. But if you want to take a look at more examples of attribute and object class schemas peruse the files in the schema directory for OpenLDAP (<code class="literal">/etc/ldap/schema</code> or <code class="literal">/usr/local/etc/openldap/schema</code>). The best place to start is with the <code class="literal">core.schema</code> schema, which defines the standard LDAPv3 schemas.</p><div><div><h3 class="title"><a id="note100"/>Note</h3><p>While reading <code class="literal">core.schema</code> you might notice that several very important object classes and attribute types are commented out. Why? Because they are included in the <strong>system schema</strong>, which is hard-coded into OpenLDAP. This schema is found in the OpenLDAP source code in <code class="literal">slapd/schema_prep.c</code>.</p></div></div><p>The <code class="literal">cosine.schema</code> file contains many other commonly used schemas and is also a good place to look. The <code class="literal">inetOrgPerson.schema</code> schema is a good example of what a user-defined schema file ought to look like. Or, for a shorter example of a user-defined schema, see <code class="literal">openldap.schema</code>.</p><p>While <code class="literal">attributetype</code> and <code class="literal">objectclass</code> are the two primary directives used in schema creation there are a few others which we will cover, albeit more briefly, in the next two sections.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Object Identifier Definitions</h2></div></div></div><a class="indexterm" id="id616"/><p>The object identifier directive (<code class="literal">objectidentifier</code>) is an extension to the standard definition language. While it doesn't provide additional functionality to the schema language, it serves as a time-saving (and human-friendly) utility.</p><p>The <code class="literal">objectidentifier</code> directive is used to assign a string alias to an OID. When SLAPD processes OID fields for <code class="literal">attributetype</code>, <code class="literal">objectclasstype</code>, and <code class="literal">ditcontentrule</code> directives, if it encounters a string instead of an OID, it will check to see if this string is an alias to an OID and, if so, it will use the value of the OID. The <code class="literal">telephoneNumber</code> schema we examined in the last section provides a good example:</p><div><pre class="programlisting">attributetype 
  ( 
   2.5.4.20
   NAME 'telephoneNumber'
   DESC 'RFC2256: Telephone Number'
   EQUALITY telephoneNumberMatch
   SUBSTR telephoneNumberSubstringsMatch
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.50{32} 
  )</pre></div><p>Instead of using the OID for the telephone number equality and substring matching rules (<code class="literal">1.3.6.1.4.1.1466.115.121.1.50</code> and <code class="literal">1.3.6.1.4.1.1466.115.121.1.58</code>, respectively), the schema refers to the names of the matching rules: <code class="literal">telephoneNumberMatch</code> and <code class="literal">telephoneNumberSubstringMatch</code>. This later form is much easier for humans to read.</p><p>The <code class="literal">objectidentifier</code> directive makes it easy to define such aliases for OID numbers, in whole or in part. Here is a simple example of assigning a name to an OID:</p><div><pre class="programlisting">objectidentifier exampleComDemo 1.3.6.1.4.1.8254.1021.3.1</pre></div><p>Using a directive like this at the top of a schema makes it possible to refer to the OID using the name <code class="literal">exampleComDemo</code> later.</p><div><div><h3 class="title"><a id="note101"/>Note</h3><p>The given OID is valid and is registered to the author. If you are developing your own LDAP schemas, you should register your own OID (see the <em>Getting</em> <em>an</em> <em>OID</em> section). While you are free to use this OID when recreating these examples, do not use it to write your own extensions. Otherwise, there will be no way to ensure that such OIDs are globally unique which defeats the purpose of the OID.</p></div></div><p>For example, we could create a schema like this:<a class="indexterm" id="id617"/>
</p><div><pre class="programlisting">objectclass 
  (
   exampleComDemo
   NAME 'myPersonObjectClass'
   DESC 'My Person Object Class'
   SUP inetOrgPerson STRUCTURAL
  )</pre></div><p>Note that instead of using the OID number for the object, we used the <code class="literal">exampleComDemo</code> alias. But, generally, we would not assign one alias per object class. It would be more convenient to alias a common root OID and then append just the last part of the OID number. For example:</p><div><pre class="programlisting">objectidentifier exampleComOC 1.3.6.1.4.1.8254.1021.1

objectclass <a class="indexterm" id="id618"/>
  (
   exampleComOC:1
   NAME 'myPersonObjectClass'
   DESC 'My Person Object Class'
   SUP inetOrgPerson STRUCTURAL
  )</pre></div><p>In this example we used the <code class="literal">objectidentifier</code> directive to create an alias for the OID base that will be used for all of my object class definitions. Thus, when SLAPD encounters the name <code class="literal">exampleComOC</code>, it will expand it to <code class="literal">1.3.6.1.4.1.8254.1021.1</code>. The object class definition for <code class="literal">myPersonObjectClass</code> should have the OID <code class="literal">1.3.6.1.4.1.8254.1021.1.1</code> (note the extra <code class="literal">.1</code> at the end). Rather than writing out the entire number we use the <code class="literal">exampleComOC</code> alias and append a colon (<code class="literal">:</code>) and then the numeric suffix for the object class.</p><p>When SLAPD encounters <code class="literal">exampleComOC:1</code> it will expand it to <code class="literal">1.3.6.1.4.1.8254.1021.1.1</code>. Likewise, if I were to create a second object class with the desired OID <code class="literal">1.3.6.1.4.1.8254.1021.1.2</code>, I could use <code class="literal">exampleComOC:2</code> instead of typing out the entire long OID.<a class="indexterm" id="id619"/>
</p><div><div><h3 class="title"><a id="note102"/>Note</h3><p>Using the <code class="literal">objectidentifier</code> attribute can not only save typing, but reduce typos in an area particularly prone to typos (and with typos particularly difficult to spot).</p></div></div><p>For more examples of the <code class="literal">objectidentifier</code> directive, see <code class="literal">openldap.schema</code> in the schema directory for OpenLDAP.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec77"/>DIT Content Rules</h2></div></div></div><a class="indexterm" id="id620"/><p>The last schema directive we will look at is the <code class="literal">ditcontentrule</code> directive which is used for creating <strong>DIT Content Rules</strong>.</p><div><div><h3 class="title"><a id="note103"/>Note</h3><p>
<em>DIT</em> stands for Directory Information Tree. This abbreviation is a frequently used bit of LDAP parlance.</p></div></div><p>A DIT content rule identifies a particular structural object class, and indicates which auxiliary object classes are allowed (or not allowed) to be included in entries that use that object class.</p><p>For an example, let's use a few of the object classes introduced in Chapter 3. In the <em>Anatomy</em> <em>of</em> <em>an</em> <em>LDIF</em> <em>File</em> section we created an entry representing a document. It implemented the <code class="literal">document</code> object class, whose schema (located in <code class="literal">cosine.schema</code>) looks like this:</p><div><pre class="programlisting">objectclass 
  ( 
   0.9.2342.19200300.100.4.6 
   NAME 'document'
   SUP top 
   STRUCTURAL
   MUST documentIdentifier
   MAY ( commonName $ description $ seeAlso $ localityName $
         organizationName $ organizationalUnitName $
         documentTitle $ documentVersion $ documentAuthor $
         documentLocation $ documentPublisher )
  )</pre></div><a class="indexterm" id="id621"/><p>This is a structural object class. Also in Chapter 3, in the <em>Adding</em> <em>System</em> <em>Records</em> section we added the entry for <code class="literal">uid=authenticate,ou=System,dc=example,dc=com</code>. This entry implemented the <code class="literal">simpleSecurityObject</code> object class. Here is the schema for <code class="literal">simpleSecurityObject</code>:</p><div><pre class="programlisting">objectclass 
  ( 
   0.9.2342.19200300.100.4.19 
   NAME 'simpleSecurityObject'
   DESC 'RFC1274: simple security object'
   SUP top 
   AUXILIARY
   MUST userPassword 
  )</pre></div><a class="indexterm" id="id622"/><p>This object class is an auxiliary object class, meaning that it can be added to entries that already have a structural object class, the result being that the attributes of the auxiliary object class are now available for that entry.</p><div><div><h3 class="title"><a id="note104"/>Note</h3><p>For more discussion on the different sorts of object classes and how they function, see the discussion in Chapter 3 and the section in this chapter called <em>The</em> <em>Object</em> <em>Class</em> <em>Hierarchy</em>.</p></div></div><p>According to default OpenLDAP settings, if we had an entry with the <code class="literal">document</code> structural object class, we could give this document a password (for binding to the directory) by adding <code class="literal">objectclass:</code> <code class="literal">simpleSecurityObject</code> to the record, and then adding a <code class="literal">userPassword</code> attribute. This would give us a record looking something like this:</p><div><pre class="programlisting">dn: documentIdentifier=011,uid=david,ou=Users,dc=example,dc=com
documentIdentifier: 011
documentTitle: Treatise on Human Nature
userPassword:: c2VjcmV0
objectClass: document
objectClass: simpleSecurityObject</pre></div><p>This entry is essentially a document that has the ability to log in! A client that used this record's DN and the correct password could log in as this document.</p><p>Perhaps there are cases where this is desirable, but for the sake of this example, let us suppose that this is a configuration that we do not want to allow.</p><p>Normally, decisions about which entries have which object classes are left to external applications. But what if we wanted to make sure that no application could give <code class="literal">document</code> a <code class="literal">userPassword</code> attribute?</p><p>The best method for solving this problem is to create a DIT content rule that disallows adding the <code class="literal">userPassword</code> attribute to any entry that has the <code class="literal">document</code> object class. This is done with the <code class="literal">ditcontentrule</code> directive:</p><div><pre class="programlisting">ditcontentrule 
  ( 
   0.9.2342.19200300.100.4.6 
   NAME 'noPWForDocs'
   DESC 'Do not allow passwords for documents'
   NOT userPassword
  )</pre></div><p>The form of the <code class="literal">ditcontentrule</code> directive should be familiar by now. Like the <code class="literal">objectclass</code> and <code class="literal">attributetype</code> directives, this directive encloses the DIT content rule definition inside of parentheses.</p><p>The first field is an OID. But unlike the other schema definitions, this OID is not the OID for this definition. Instead, it is the OID of the structural object class that we are targeting.</p><p>In this case, the OID <code class="literal">0.9.2342.19200300.100.4.6</code> is the OID for the <code class="literal">document</code> object class. You can verify this with a glance at the document schema listed a few pages back or by browsing the cosine schema.</p><a class="indexterm" id="id623"/><p>The <code class="literal">NAME</code> field should contain a unique name used for referencing this rule. For the most part, the value of this field is used in reporting references to this rule in the log file, and in responses to the client.</p><p>The <code class="literal">DESC</code> field contains a short-text description of what the rule does.</p><p>The <code class="literal">NOT</code> field contains a list of OIDs or names of attributes that should be disallowed. The name <code class="literal">userPassword</code> comes from the <code class="literal">NAME</code> field in the <code class="literal">userPassword</code> attribute definition.</p><p>With this content rule in place, what will happen if we try to add a <code class="literal">userPassword</code> attribute to a document? Here is an example using <code class="literal">ldapmodify</code>:</p><div><pre class="programlisting">$ ldapmodify -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
<a class="indexterm" id="id624"/>
<strong>dn: documentIdentifier=011,uid=dave,ou=users,dc=example,dc=com</strong>
<strong>changetype: modify</strong>
<strong>add: objectclass</strong>
<strong>objectclass: simpleSecurityObject</strong>
<strong>-</strong>
<strong>add: userPassword</strong>
<strong>userPassword: secret</strong><a class="indexterm" id="id625"/>
modifying entry 
       "documentIdentifier=011,uid=dave,ou=users,dc=example,dc=com"
ldap_modify: Object class violation (65)
        additional info: content rule 'noPWForDocs' precluded 
        attribute 'userPassword'</pre></div><p>The highlighted portion in this example is the attempted modification. We attempted to add the <code class="literal">simpleSecurityObject</code> object class and the <code class="literal">userPassword</code> attribute to the record. But the server responded with an <strong>Object class violation</strong> error, giving the following reason:</p><div><pre class="programlisting">content rule 'noPWForDocs' precluded attribute 'userPassword'</pre></div><p>Our custom DIT content rule did its job—it prevented the addition of the <code class="literal">userPassword</code> attribute to the <code class="literal">document</code> entry.</p><p>This DIT content rule we created above is a negative rule—it defines what attributes an entry <em>cannot</em> have. But <code class="literal">ditcontentrule</code> can also be used to create positive rules: rules that specify which attributes (or auxiliary object classes) are allowed.</p><p>For example, we could write a rule that says that every entry that is an <code class="literal">inetOrgPerson</code> must have a <code class="literal">userPassword</code>:</p><div><pre class="programlisting">ditcontentrule 
  (
   2.16.840.1.113730.3.2.2
   NAME 'reqPassword'
   DESC 'Require userPassword for inetOrgPerson'
   MUST userPassword
  )</pre></div><p>The OID used in this rule is the OID for the <code class="literal">inetOrgPerson</code> object class. The <code class="literal">MUST</code> field indicates that any entry with the structural object class <code class="literal">inetOrgPerson</code> must also have the <code class="literal">userPassword</code> attribute set.</p><p>Because of this rule, an attempt to add a new <code class="literal">inetOrgPerson</code> entry without a <code class="literal">userPassword</code> would result in an error similar to the one we looked at earlier:</p><div><pre class="programlisting">$ ldapadd -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

<strong>dn: uid=Johann,ou=users,dc=example,dc=com</strong>
<strong>uid: johann</strong>
<strong>ou: users</strong>
<strong>cn: Johann Fichte</strong>
<strong>cn: Johann Gottlieb Fichte</strong>
<strong>sn: Fichte</strong>
<strong>givenName: Johann</strong>
<strong>objectclass: person</strong>
<strong>objectclass: organizationalPerson</strong>
<strong>objectclass: inetOrgPerson</strong>

adding new entry "uid=Johann,ou=users,dc=example,dc=com"
ldap_add: Object class violation (65)
        additional info: content rule 'reqPassword' requires attribute 'userPassword'</pre></div><p>The record being added (highlighted) is a valid <code class="literal">inetOrgPerson</code> entry, according to the <code class="literal">inetOrgPerson</code> object class definition. But, because of the DIT content rule, adding the record failed because there is no <code class="literal">userPassword</code> attribute value specified.</p><p>Now let's expand this rule to take advantage of the <code class="literal">AUX</code> field. The <code class="literal">AUX</code> field may be used to explicitly state which auxiliary classes can be combined with this structural object class.</p><p>In our newly revised DIT content rule we will make it so that only the <code class="literal">pkiUser</code> and the <code class="literal">labeledURIObject</code> auxiliary object classes can be added to an <code class="literal">inetOrgUser</code> record.</p><div><div><h3 class="title"><a id="note105"/>Note</h3><p>The <code class="literal">pkiUser</code> object class is an auxiliary object class designed to indicate that an entry is capable of performing <strong>public key infrastructure</strong> (<strong>PKI</strong>) secure transactions. It has one attribute, <code class="literal">userCertificate</code>, that contains the user's cryptographic certificate. See the Wikipedia page for a quick introduction to PKI: <a class="ulink" href="http://en.wikipedia.org/wiki/Public_key_infrastructure">http://en.wikipedia.org/wiki/Public_key_infrastructure</a>.</p></div></div><p>The <code class="literal">labeledURIObject</code> object class allows an additional attribute, <code class="literal">labeledURI</code>, which takes a URI (such as a URL) and a plain text description:</p><div><pre class="programlisting">labeledURI: http://aleph-null.tv Home Page</pre></div><p>The URI is separated from the label by a white space. So the URI is <a class="ulink" href="http://aleph-null.tv">http://aleph-null.tv</a> and the label is <code class="literal">Home</code> <code class="literal">Page</code>. The <code class="literal">labeledURIObject</code> is defined in RFC 2079 (<a class="ulink" href="http://www.ietf.org/rfc/rfc2079.txt">http://www.ietf.org/rfc/rfc2079.txt</a>).</p><p>Also, we will change the <code class="literal">NAME</code> and <code class="literal">DESC</code> elements to reflect the fact that our rule now does more than just require a <code class="literal">userPassword</code>. The DIT content rule now looks like this:</p><div><pre class="programlisting">ditcontentrule 
  (
   2.16.840.1.113730.3.2.2
   NAME 'inetOrgPersonRules'
   DESC 'Restrictions for entries with inetOrgPerson object class'
   MUST userPassword
   AUX ( labeledURIObject $ pkiUser )
  )</pre></div><p>Note the syntax of the <code class="literal">AUX</code> field. To list multiple values in a field it is necessary to enclose the list of values, separated by a dollar sign (<code class="literal">$</code>), inside of parentheses.</p><p>Using this DIT content rule, we can successfully add a URL (using the <code class="literal">labeledURIObject</code> auxiliary object class) to my record:</p><div><pre class="programlisting">$ ldapmodify -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

<strong>dn: uid=matt,ou=users,dc=example,dc=com</strong>
<strong>changetype: modify</strong>
<strong>add: objectclass</strong>
<strong>objectclass: labeledURIObject</strong>
<strong>-</strong>
<strong>add: labeledURI</strong>
<strong>labeledURI: http://aleph-null.tv Home Page</strong>

modifying entry "uid=matt,ou=users,dc=example,dc=com"</pre></div><p>The entry, highlighted above, was added successfully because the <code class="literal">labeledURIObject</code> (which allows the <code class="literal">labeledURI</code> attribute) is allowed by the content rule. But if I try to add a different auxiliary object class—one not explicitly allowed in the DIT content rule – the change request will be denied:</p><div><pre class="programlisting">$ ldapmodify -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

<strong>dn: uid=matt,ou=users,dc=example,dc=com</strong>
<strong>changetype: modify</strong>
<strong>add: objectclass</strong>
<strong>objectclass: userSecurityInformation</strong>

modifying entry "uid=matt,ou=users,dc=example,dc=com"
ldap_modify: Object class violation (65)
        additional info: content rule 'inetOrgPersonRules' does not 
        allow class 'userSecurityInformation'</pre></div><p>The DIT content rule prevented the addition of an auxiliary object class because this class is not specified in the <code class="literal">AUX</code> field of the rule.</p><p>Like the other definitions, the <code class="literal">ditcontentrule</code> directive also allows the <code class="literal">OBSOLETE</code> flag.</p><p>In summary, the <code class="literal">ditcontentrule</code> directive takes a definition of a DIT content rule enclosed in parentheses. The following fields are supported:<a class="indexterm" id="id626"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The OID of the structural object class to which this rule applies.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">NAME</code> field, which provides a short name used to identify the rule.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">DESC</code> field, which contains a description of the rule.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">OBSOLETE</code> flag to mark this rule as obsolete.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">AUX</code> field, which contains the names or OIDs of all auxiliary classes that the entries of this object class are allowed to implement.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">MUST</code> field, which contains a list of all of the (not already mandatory) attributes that entries of this object class must have.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">MAY</code> field, which lists all of the fields that a member of this object class may have. As of OpenLDAP 2.3.30, this is not exclusive. Attributes not in this list but allowed by object class schema definitions are still allowed. In other words, <code class="literal">MAY</code> does not impose any restrictions.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">NOT</code> field, which contains a list of attributes that an entry of this object class cannot have. This cannot be applied to attributes that are required by the object classes schema definition.</li></ul></div><p>Now we have looked at the four different schema definition directives allowed in the <code class="literal">slapd.conf</code> file (or included files). With this information you should be able to read <a class="indexterm" id="id627"/>through and understand any of the schemas defined in OpenLDAP.</p><p>Next we will take a quick look at how to get schema information out of a SLAPD server using the LDAP protocol.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Retrieving the Schemas from SLAPD</h2></div></div></div><a class="indexterm" id="id628"/><a class="indexterm" id="id629"/><p>When SLAPD loads the schemas, it stores them in a special part of the directory information tree, along with the Root DSE record; a special entry holds schema information. Having this information is useful for debugging, but more importantly it provides a way for client applications to find out about what types of objects and attributes may be stored in this directory server.</p><p>Obtaining the information from the directory is as easy as issuing an <code class="literal">ldapsearch</code> command.</p><p>The schema information is stored in a special record called the <strong>subschema subentry</strong>. You can access the subschema subentry using <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -U matt -b 'cn=subschema' -s base +</strong>
</pre></div><div><div><h3 class="title"><a id="note106"/>Note</h3><p>Access to the <code class="literal">cn=subschema</code> record is governed by global ACLs (ACLs that appear before the database section). For example, to grant access to the subschema to users only, you can use a rule like this: <code class="literal">access</code> <code class="literal">to</code> <code class="literal">dn.exact="cn=subschema"</code> <code class="literal">by</code> <code class="literal">users</code> <code class="literal">read</code>.</p></div></div><p>This will retrieve the entire schema specification from the server including not only the attribute and object class definitions, but also definitions of matching rules, matching rule uses, structure rules, name forms, and LDAP syntaxes.</p><p>But, as with any other record in an LDAP server, we can use search filters to get just the values of specific attributes. For example, we can find out what all of the existing DIT content rules are:</p><div><pre class="programlisting">$ ldapsearch -LL -U matt -b 'cn=subschema' -s base ditcontentrules
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: cn=Subschema
dITContentRules: ( 0.9.2342.19200300.100.4.6 NAME 'noPWForDocs' DESC
       'Do not allow passwords for documents' NOT userPassword )
dITContentRules: ( 2.16.840.1.113730.3.2.2 NAME 'inetOrgPersonRules'
      DESC 'Restrictions for inetOrgPerson object class.'
      AUX ( labeledURIObject $ pkiUser )
      MUST userPassword )</pre></div><p>This search returns all of the DIT content rules currently included in the schema definitions for this server. Of course, the only two there are the ones we created in the last section.<a class="indexterm" id="id630"/>
</p><p>The following schema-related attributes are included in the <code class="literal">cn=Subschema</code> record:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ldapSyntaxes</code>: This attribute has one value for every LDAP syntax supported in the directory. Example: <code class="literal">ldapSyntaxes:</code> <code class="literal">(</code> <code class="literal">1.3.6.1.1.16.1</code> <code class="literal">DESC</code> <code class="literal">'UUID'</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">matchingRules</code>: This attribute has one value for every matching rule in the directory. Example: <code class="literal">matchingRules:</code> <code class="literal">(</code> <code class="literal">2.5.13.14</code> <code class="literal">NAME</code> <code class="literal">'integerMatch'</code> <code class="literal">SYNTAX</code> <code class="literal">1.3.6.1.4.1.1466.115.121.1.27</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">matchingRuleUse</code>: This attribute has one value for every matching rule use, which pairs matching rule OIDs with a list of all of the attributes that implement that matching rule. Example: <code class="literal">matchingRuleUse:</code> <code class="literal">(</code> <code class="literal">2.5.13.27</code> <code class="literal">NAME</code> <code class="literal">'generalizedTimeMatch'</code> <code class="literal">APPLIES</code> <code class="literal">(</code> <code class="literal">createTimestamp</code> <code class="literal">$</code> <code class="literal">modifyTimestamp</code> <code class="literal">)</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">attributeTypes</code>: This attribute has one value for every attribute definition in this directory. Example: <code class="literal">attributeTypes:</code> <code class="literal">(</code> <code class="literal">2.5.4.3</code> <code class="literal">NAME</code> <code class="literal">(</code> <code class="literal">'cn'</code> <code class="literal">'commonName'</code> <code class="literal">)</code> <code class="literal">DESC</code> <code class="literal">'RFC2256:</code> <code class="literal">common</code> <code class="literal">name(s)</code> <code class="literal">for</code> <code class="literal">which</code> <code class="literal">the</code> <code class="literal">entity</code> <code class="literal">is</code> <code class="literal">known</code> <code class="literal">by'</code> <code class="literal">SUP</code> <code class="literal">name</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">objectClasses</code>: This attribute contains one value for every object class definition. Example: <code class="literal">objectClasses:</code> <code class="literal">(</code> <code class="literal">2.5.6.2</code> <code class="literal">NAME</code> <code class="literal">'country'</code> <code class="literal">DESC</code> <code class="literal">'RFC2256:</code> <code class="literal">a</code> <code class="literal">country'</code> <code class="literal">SUP</code> <code class="literal">top</code> <code class="literal">STRUCTURAL</code> <code class="literal">MUST</code> <code class="literal">c</code> <code class="literal">MAY</code> <code class="literal">(</code> <code class="literal">searchGuide</code> <code class="literal">$</code> <code class="literal">description</code> <code class="literal">)</code> <code class="literal">)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dITContentRules</code>: This attribute contains one value for every DIT content rule defined.</li></ul></div><p>Other standard attributes, such as <code class="literal">cn</code>, <code class="literal">objectclass</code>, and the basic operational attributes, are also part of the record.</p><p>Examining schemas this way is an alternative to simply reading the schema files. While it has less documentation (since there are no comments), using filters can be helpful. Also, information not in the standard schemas (such as schema definitions for operational attributes) is also available in this record.</p><p>Later in the chapter we will begin implementing schemas in SLAPD, first by including some already written schemas, then by writing our own. But next we will take a quick look at one more theoretical component of schemas: the schema hierarchy.<a class="indexterm" id="id631"/>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>The ObjectClass Hierarchy</h1></div></div></div><a class="indexterm" id="id632"/><p>Object classes and attributes in LDAP can be organized into hierarchical relationships. A hierarchical relationship is one in which one entity stands in a parent or superior relationship to one or more subordinate entities.</p><p>Attribute hierarchies tend to be simple, and require only a short explanation. Object classes, on the other hand, use a more complicated hierarchical model and will be the focus of this part of the chapter.</p><p>In the cases of both attribute and object class hierarchies, the mechanism for creating the hierarchy is the schema definition. Schema definitions for both attributes and object classes use the <code class="literal">SUP</code> field to indicate a relationship to a parent, or superior.</p><p>We will start out with a brief discussion of attribute hierarchies, and then move on to the more complicated object class hierarchies.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Attribute Hierarchies</h2></div></div></div><a class="indexterm" id="id633"/><a class="indexterm" id="id634"/><p>Attribute hierarchies are simple relationships wherein one attribute can, through its subordinate relationship to another attribute, inherit certain features, such as matching rules and LDAP syntaxes.</p><p>The simplicity of attribute hierarchies manifests itself in a few ways:<a class="indexterm" id="id635"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is no requirement that an attribute have any relation to other attributes. In other words, there is no requirement that attributes be part of a hierarchy. Many, such as the <code class="literal">telephoneNumber</code> attribute we looked at in the previous part, stand on their own.</li><li class="listitem" style="list-style-type: disc">Attribute hierarchies do not play a significant role in how attributes are used. Attribute hierarchies exist primarily to keep attribute schema definitions clean and succinct, minimizing repetition.</li></ul></div><p>The <code class="literal">name</code> attribute, which is conventionally not used directly in any object class, is a good example of the use of superior/subordinate relationships in attribute definitions. Thirteen attributes in the core schema list <code class="literal">name</code> as their superior. The <code class="literal">cn</code> attribute is one example.</p><div><img alt="Attribute Hierarchies" src="img/1021_06_02.jpg"/></div><p>The schema definition for <code class="literal">cn</code> uses only the <code class="literal">NAME</code>, <code class="literal">DESC</code>, and <code class="literal">SUP</code> fields, with <code class="literal">SUP</code> indicating that the <code class="literal">name</code> attribute is the superior of <code class="literal">cn</code>.</p><p>Since the <code class="literal">cn</code> attribute definition does not specify any matching rules or an LDAP syntax, these are inherited from the name attribute. Hence, <code class="literal">cn</code> is assigned the equality and substring matching rules defined in <code class="literal">name</code>, as well as the LDAP syntax and length.</p><p>But there is not much more that can be done with attribute hierarchies. Other than matching rules and syntax nothing else is automatically inherited from the superior, and there are no other benefits in using attribute hierarchies.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec76"/>Subordinate Attributes and Searching</h3></div></div></div><a class="indexterm" id="id636"/><a class="indexterm" id="id637"/><p>There is one interesting effect that results from attribute hierarchies. A request for a superior attribute may return subordinate attributes as matches. For example, here is a search requesting just a single attribute: <code class="literal">name</code>:</p><div><pre class="programlisting">$ ldapsearch -LL -U matt '(uid=matt)' name
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

<strong>dn: uid=matt,ou=Users,dc=example,dc=com</strong>
<strong>ou: Users</strong>
<strong>cn: Matt Butcher</strong>
<strong>sn: Butcher</strong>
<strong>givenName: Matt</strong>
<strong>givenName: Matthew</strong>
<strong>title: Systems Integrator</strong>
<strong>st: Illinois</strong>
<strong>l: Chicago</strong>
</pre></div><p>According to the search parameters, the search should return any <code class="literal">name</code> attribute values for records with <code class="literal">uid=matt</code>. But the record returned (highlighted) has more than that. In addition to the DN, which is always returned, the record also has <code class="literal">ou</code>, <code class="literal">cn</code>, <code class="literal">sn</code>, <code class="literal">givenName</code>, <code class="literal">title</code>, <code class="literal">st</code>, and <code class="literal">l</code> values.</p><p>Why is this? This happens simply because all of those attribute types have <code class="literal">name</code> as the superior.<a class="indexterm" id="id638"/>
</p><p>Such behavior extends to search filter behavior, as well. For example, a search filter like (<code class="literal">name=Marcus</code>) will result in a search being performed against all attributes that use <code class="literal">name</code> as a superior:<a class="indexterm" id="id639"/>
</p><div><pre class="programlisting">$ ldapsearch -LL -U matt '(name=Marcus)'
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: uid=cicero,ou=Users,dc=example,dc=com
uid: marcus
uid: cicero
sn: Tullius
cn: Marcus Tullius
<strong>givenName: Marcus</strong>
ou: users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>The record for <code class="literal">uid=cicero</code> matched because the <code class="literal">givenName</code> field has the value <code class="literal">Marcus</code>. As can be seen in the attribute type definition, the <code class="literal">givenName</code> attribute has <code class="literal">name</code> as a superior attribute type:</p><div><pre class="programlisting">attributetype ( 2.5.4.42 NAME ( 'givenName' 'gn' )
    DESC 'RFC2256: first name(s) for which the entity is known by'
    SUP name </pre></div><p>While this feature can cause some unexpected behavior for those unfamiliar with schemas, it can prove quite useful at times.</p><p>For the most part, attribute hierarchies are fairly simple. Object class hierarchies are more complex though. And we will now take a look at them.<a class="indexterm" id="id640"/>
<a class="indexterm" id="id641"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Object Class Types: Abstract, Structural, and Auxiliary</h2></div></div></div><a class="indexterm" id="id642"/><p>Like attributes, object classes can be organized into hierarchies. Typically, there is one major object class hierarchy. But while the hierarchical organization of object classes plays an important part in the structure of the directory, not all object classes are part of the hierarchy. To understand why this is we must begin by examining the different types of object classes.</p><p>There are three types of object class: abstract, structural, and auxiliary as follows: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="indexterm" id="id643"/>An <strong>abstract object class</strong> <a class="indexterm" id="id644"/>holds a place at the top of the object class hierarchy. It may set required and allowed attributes for all object classes beneath it in the hierarchy, but no record can be an instance of that object class only. Further, any parent of an abstract object class must also be abstract.</li><li class="listitem" style="list-style-type: disc">A <strong>structural object class</strong> <a class="indexterm" id="id645"/>also<a class="indexterm" id="id646"/> holds a place in the hierarchy, and is a subordinate of (or, to phrase it differently, inherits from) either another structural object class or an abstract object class. An entry in the directory is an instance of a structural object class. When one structural object class subclasses another structural object class, the parent class is treated as if it were abstract. So, operationally speaking, for any given record it has only one structural object class—the structural object class is lowest on the object class hierarchy.</li><li class="listitem" style="list-style-type: disc">An <strong>auxiliary object class</strong> <a class="indexterm" id="id647"/><a class="indexterm" id="id648"/>is not required to be part of the object class hierarchy, though it can be. An auxiliary object class is intended to allow extra attributes to be defined for a record that already has a structural object class. For example, a record that describes a system account may not be in the person part of the hierarchy but may still need a password. The <code class="literal">simpleSecurityObject</code> is an auxiliary object class that can be added to other structural object classes to allow (and, in fact, require) that a <code class="literal">userPassword</code> attribute be set.</li></ul></div><p>Abstract and structural object classes are organized into a hierarchy, with abstract classes at the top, and structural object classes as subordinates of those. In core schema (<code class="literal">core.schema</code>), there is only one abstract object class: <code class="literal">top</code>. This object class marks the top of the object class hierarchy—the ancestor (the highest superior) of all object classes.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec77"/>The Object Class Hierarchy: An Overview</h3></div></div></div><a class="indexterm" id="id649"/><p>The hierarchy begins with the abstract object class <code class="literal">top</code>. Beneath it are any number of structural object classes, all of which are either direct or indirect subordinates. A direct subordinate is one that lists <code class="literal">top</code> as its superior object class (in the <code class="literal">SUP</code> field of the schema definition). An indirect subordinate is farther down the object class hierarchy. It lists another abstract or structural object class as its superior, but that superior either itself refers to <code class="literal">top</code> as its superior, or refers to another indirect subordinate.</p><div><div><h3 class="title"><a id="note107"/>Note</h3><p>In other LDAP references, a superior class is sometimes called a <strong>superclass</strong>, while a superior attribute (in the attribute hierarchy) is called a <strong>supertype</strong>. Likewise, the terms <strong>subclass</strong> and <strong>subtype</strong> can be used to indicate the subordinate relationships in classes and attributes.</p></div></div><p>Structural object classes have either an abstract object class or another structural object class as their superior.</p><p>Auxiliary object classes may or may not be in the object class hierarchy. They can have superiors, but they are not required to.</p><p>Here is a pictorial representation of a simple object class hierarchy (consisting of four object classes) and a pair of records in the directory information tree that we created in Chapter 3:</p><div><img alt="The Object Class Hierarchy: An Overview" src="img/1021_06_03.jpg"/></div><p>The <code class="literal">account</code> and <code class="literal">groupOfNames</code> structural object classes both have <code class="literal">top</code> listed as their superior (as indicated by the solid lines). <code class="literal">simpleSecurityObject</code>, an auxiliary object class, has no superiors.</p><p>Beneath the object class hierarchy are two records, with the DN and object class attributes displayed. The dotted lines indicate which schemas these entries implement. Each of the two records (the <code class="literal">uid=authenticate</code> user and the <code class="literal">cn=Admins</code> group) are related to a different part of the object class hierarchy. <code class="literal">cn=Admins</code> is a <code class="literal">groupOfNames</code>, while <code class="literal">uid=authenticate</code> is an account that also has the attributes of a <code class="literal">simpleSecurityObject</code>.</p><p>This representation of the object class hierarchy is designed to show how the organization of schemas is related to the entries within the directory.</p><p>It is important to keep in mind that there are two different hierarchies in play here. The two entries above are part of the directory information tree hierarchy. Their position in that hierarchy is indicated by their DNs. The <code class="literal">uid=authenticate</code> entry, for example, is a child of the <code class="literal">ou=System</code> entry, which in turn is a child of the <code class="literal">dc=example,dc=com</code> entry (the root entry for our directory information tree).</p><p>But by their object classes, the entries can also be related to the object class hierarchy, as is illustrated. For the time being it is only this second hierarchy—the object class hierarchy—that we are interested in.</p><p>Let's take a look at each of the three types of object classes. Understanding the differences between the three, and the respective role each plays, will illuminate the concepts at play in the object class hierarchy.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec78"/>Abstract Classes</h3></div></div></div><p>The<a class="indexterm" id="id650"/>
<a class="indexterm" id="id651"/> first of the three types that we will examine is the <strong>abstract class</strong>. While abstract classes are only rarely used, they play a major role in the development of the object class hierarchy.</p><p>We have already talked about the special <code class="literal">top</code> object class. The most commonly used LDAP schemas do not use any other abstract object classes beside <code class="literal">top</code>. The <code class="literal">top</code> object class definition looks like this:</p><div><pre class="programlisting">objectclass 
  ( 
   2.5.6.0
   NAME 'top'
   DESC 'RFC2256: top of the superclass chain'
   ABSTRACT
   MUST objectClass
  )</pre></div><p>It requires only one attribute: <code class="literal">objectclass</code>. All structural object classes should be related, either directly or indirectly, to <code class="literal">top</code>. And any abstract object class that will have structural object classes subordinate to it must also be related to <code class="literal">top</code>. While it is possible to create an abstract class without a superior class, effectively starting a new tree of object classes, this is rarely done.</p><div><div><h3 class="title"><a id="tip03132"/>Tip</h3><p><strong>Abstracts without Superiors</strong></p><p>The main circumstance for defining abstract classes without superiors is when all of the classes that inherit from that abstract class will be auxiliary object classes. Structural object classes, according to RFC 4512, must be related (directly or indirectly) to the top object class.</p></div></div><p>But <code class="literal">top</code> is not the only abstract object class in frequent use. There are a few common schemas included with OpenLDAP, notably the <code class="literal">java.schema</code> and <code class="literal">corba.schema</code>, which make use of abstract object classes whose superiors are <code class="literal">top</code>. If an abstract object class has a superior, it must be an abstract superior.</p><a class="indexterm" id="id652"/><p>Abstract object classes can have lists of attributes in the <code class="literal">MUST</code> and <code class="literal">MAY</code> fields of their definition. The <code class="literal">top</code> object class, as we just saw, requires the <code class="literal">objectclass</code> attribute. Any entry that implements a structural object class subordinate to this abstract object class inherits the <code class="literal">MUST</code> and <code class="literal">MAY</code> constraints of the parent.</p><p>For example, in the <code class="literal">java.schema</code> the class <code class="literal">javaObject</code> is abstract. Here is its definition:</p><div><pre class="programlisting">objectclass 
  ( 
   1.3.6.1.4.1.42.2.27.4.2.4
   NAME 'javaObject'
   DESC 'Java object representation'
   SUP top
   ABSTRACT
   MUST javaClassName
   MAY ( javaClassNames $ javaCodebase $
         javaDoc $ description ) 
  )</pre></div><p>According to the <code class="literal">SUP</code> field, this object class is subordinate to <code class="literal">top</code>. It requires that any entry that implements <code class="literal">javaObject</code> has a <code class="literal">javaClassName</code> attribute. It also defines several attributes—<code class="literal">javaClassNames</code>, <code class="literal">javaCodebase</code>, <code class="literal">javaDoc</code>, and <code class="literal">description</code>—that entries may include.</p><div><div><h3 class="title"><a id="note108"/>Note</h3><p>The Java schema is used to store serialized Java objects in a directory server. It is defined in RFC 2713.</p></div></div><p>There are no structural object classes subordinate to <code class="literal">javaObject</code>. However, there are a couple of auxiliary object classes that are subordinate to <code class="literal">javaObject</code>: <code class="literal">javaSerializedObject</code> and <code class="literal">javaMarshalledObject</code>. Here is the <code class="literal">javaSerializedObject</code> schema definition:</p><div><pre class="programlisting">objectclass 
  ( 
   1.3.6.1.4.1.42.2.27.4.2.5
   NAME 'javaSerializedObject'
   DESC 'Java serialized object'
   SUP javaObject
   AUXILIARY
   MUST javaSerializedData 
  )</pre></div><a class="indexterm" id="id653"/><p>Only one attribute is required in this class: <code class="literal">javaSerializedData</code>. There are no optional attributes specified in this definition.</p><p>If some entry uses the <code class="literal">javaSerializedData</code> object class what fields <em>must</em> it have? And what fields <em>may</em> it have?</p><p>It must have a <code class="literal">javaSerializedData</code> attribute. We can see that from the <code class="literal">javaSerializedObject</code> schema. But it also must have the <code class="literal">javaClassName</code> attribute because that is required in the object class of the superior <code class="literal">javaObject</code> object class. And a <code class="literal">javaSerializedData</code> entry may have any of the attributes listed in the <code class="literal">MAY</code> field of the <code class="literal">javaObject</code> schema: <code class="literal">javaClassNames</code>, <code class="literal">javaCodebase</code>, <code class="literal">javaDoc</code>, and <code class="literal">description</code>.</p><p>This example illustrates the use of the abstract object class as a way of organizing object classes into hierarchies, grouping similar object classes (here, <code class="literal">javaSerializedObject</code> and <code class="literal">javaMarshalledObject</code>) under a common (and more generic) ancestor, <code class="literal">javaObject</code>. The <code class="literal">javaObject</code> abstract object class is then used to specify the common attributes that both of the subordinate object classes need included.</p><p>Thus, one of the major uses of abstract object classes is to collect common attributes that should be (or may be) included in object classes that are defined as subordinate to it.</p><p>Abstract classes are rare. In contrast, the most commonly used object class type is the structural object class.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec79"/>
<a class="indexterm" id="id654"/>Structural Object Classes
</h3></div></div></div><p>As<a class="indexterm" id="id655"/> we have seen in a number of examples, every record has a DN and one or more object classes. From there, what other attributes it has depends on the object classes. But there are constraints on which object classes an entry has. One major factor that determines what object classes an entry may have is the structural object class hierarchy.</p><a class="indexterm" id="id656"/><p>Every record in the directory must have at least one structural object class. The structural object class determines what type of entry a record is. For example, an entry with the structural object class <code class="literal">organization</code> is an <code class="literal">organization</code> entry.</p><div><div><h3 class="title"><a id="note109"/>Note</h3><p>Once an entry has been created in the directory, its structural object class cannot be changed. Adding and removing auxiliary object classes is allowed, but the structural object class is unalterable (as is, <em>ipso</em> <em>facto</em>, the chain of superior object classes).</p></div></div><p>An entry may implement more than one object class, and not all the object classes that it implements need be structural. Let's take a look at the organization record we created in Chapter 3:</p><div><pre class="programlisting">dn: dc=example,dc=com
description: Example.Com, your trusted non-existent corporation.
dc: example
o: Example.Com
objectClass: top
objectClass: dcObject
objectClass: organization</pre></div><p>There are three object classes for this entry:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">top</code>—an abstract object class</li><li class="listitem" style="list-style-type: disc"><code class="literal">dcObject</code>—an auxiliary object class</li><li class="listitem" style="list-style-type: disc"><code class="literal">organization</code>—a structural object class</li></ul></div><div><div><h3 class="title"><a id="note110"/>Note</h3><p>The <code class="literal">top</code> object class is not strictly necessary in this entry. SLAPD implicitly includes <code class="literal">top</code> in all entries, since all structural object classes derive from it.</p></div></div><p>How do we know which object classes are of which type? The schema definitions for these object classes are the primary source of such information.</p><p>The structural object class locates this entry in the hierarchy of object classes, a hierarchy composed of abstract and structural object classes.</p><p>An entry may have more than one structural object class as long as they are all related by superior/subordinate relationships.</p><p>In the case where there are multiple structural object classes in one record, the most subordinate object class (the one farthest from the root object class, <code class="literal">top</code>) will have all of the rest of the structural object classes as ancestors. That is, for the object class farthest from <code class="literal">top</code> in the object class hierarchy, all other structural object classes must be superior to it. This lowest object class is then treated as the structural object class.</p><p>For example, in Chapter 3 we created a record for the user <code class="literal">barbara</code>:</p><div><pre class="programlisting">dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
<a class="indexterm" id="id657"/>sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword: secret
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>This user belongs to four object classes. Three of these were explicitly stated earlier: <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code>. All three of these happen to be structural object classes. The fourth, the <code class="literal">top</code> object class, is implicitly included.</p><p>All four of these object classes are related in the hierarchy. The <code class="literal">top</code> abstract object class sits at the top of the object class hierarchy. The <code class="literal">person</code> object class is directly subordinate to top. That is, the <code class="literal">person</code> object class definition lists <code class="literal">top</code> as its parent:</p><div><pre class="programlisting"> objectclass 
  ( 
   2.5.6.6
   NAME 'person'
   DESC 'RFC2256: a person'
<strong>   SUP top </strong>
   STRUCTURAL
   MUST ( sn $ cn )
   MAY ( userPassword $ telephoneNumber $ seeAlso $ description ) 
  )</pre></div><p>While <code class="literal">person</code> points to <code class="literal">top</code> as its superior, <code class="literal">organizationalPerson</code> points to <code class="literal">person</code>. And <code class="literal">inetOrgPerson</code> points to <code class="literal">organizationalPerson</code> as its superior. Thus, we get a hierarchy of object classes:</p><div><img alt="abstract object classworking ofStructural Object Classes" src="img/1021_06_04.jpg"/></div><p>So, according to this hierarchy, any entry that is an <code class="literal">inetOrgPerson</code> must also abide by definitions of all of its superiors: <code class="literal">organizationalPerson</code>, <code class="literal">person</code>, and <code class="literal">top</code>. Any required attributes of any of those object classes will be required for an <code class="literal">inetOrgPerson</code> entry, and any optional attributes for any of those classes is optional for an <code class="literal">inetOrgPerson</code> entry.</p><p>Thus<a class="indexterm" id="id658"/>, the required fields for <code class="literal">inetOrgPerson</code> are <code class="literal">sn</code> and <code class="literal">cn</code>, both of which it gets from the <code class="literal">person</code> object class, and the <code class="literal">objectclass</code> attribute, which it inherits from <code class="literal">top</code>.</p><div><div><h3 class="title"><a id="note111"/>Note</h3><p>For a complete list of fields required by and allowed by <code class="literal">inetOrgPerson</code>, see the subsection <em>Adding</em> <em>User</em> <em>Records</em> in Chapter 3.</p></div></div><p>In the previous figure, the <code class="literal">pilotPerson</code> object class is also included, which represents another branch of the hierarchy. Like <code class="literal">organizationalPerson</code> and <code class="literal">inetOrgPerson</code>, <code class="literal">pilotPerson</code> describes a person within an organization, but it includes a number of attributes not present in <code class="literal">organizationalPerson</code> and <code class="literal">inetOrgPerson</code>, including the <code class="literal">favouriteDrink</code> and <code class="literal">janetMailBox</code> attributes.</p><p>While <code class="literal">pilotPerson</code> is not officially obsolete, it is not usually used; <code class="literal">inetOrgPerson</code> is typically used instead. But like <code class="literal">organizationalPerson</code>, <code class="literal">pilotPerson</code> lists <code class="literal">person</code> as its superior. Thus, it inherits the attributes of <code class="literal">person</code> and <code class="literal">top</code>. However, it is not related, directly or indirectly, to <code class="literal">organizationalPerson</code> or <code class="literal">inetOrgPerson</code>, and thus inherits none of their attributes.</p><p>Because <code class="literal">pilotPerson</code> is not related to <code class="literal">organizationalPerson</code> or <code class="literal">inetOrgPerson</code>, and because all of these are structural object classes, SLAPD will not allow any record to implement the <code class="literal">pilotPerson</code> object class and <code class="literal">organizationalPerson</code> or its subordinates. For example, if we try to add a record with all four of the person-describing object classes, we will get an error:</p><div><pre class="programlisting">$ ldapadd -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

<strong>dn: uid=charles,ou=users,dc=example,dc=com</strong>
<strong>uid: charles</strong>
<strong>ou: users</strong>
<strong>cn: Charles Sanders Peirce</strong>
<strong>sn: Peirce</strong>
<strong>gn: Charles</strong>
<strong>objectclass: person</strong>
<strong>objectclass: organizationalPerson</strong>
<strong>objectclass: inetOrgPerson</strong>
<strong>objectclass: pilotPerson</strong>

adding<a class="indexterm" id="id659"/> new entry "uid=charles,ou=users,dc=example,dc=com"
ldap_add: Object class violation (65)
        additional info: invalid structural object class chain 
        (inetOrgPerson/pilotPerson)</pre></div><p>When the client requests that the record above be added, SLAPD responds with an <strong>Object class violation</strong> error, indicating that the chain of object classes is not correct. This is because <code class="literal">pilotPerson</code> is not related to <code class="literal">organizationalPerson</code> or <code class="literal">inetOrgPerson</code>.</p><p>Returning to our record for <code class="literal">uid=barbara</code>, that entry lists three object classes:</p><div><pre class="programlisting">objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>As we saw in the previous figure, <code class="literal">inetOrgPerson</code> is the lowest object class on the hierarchy—the far most from <code class="literal">top</code>. That means that SLAPD considers this object class to be the structural object class for the record. It even sets a special operational attribute, <code class="literal">structuralObjectClass</code>, that stores this value. Thus, you can get information on the structural object class through <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting"><strong>  $ ldapsearch -LL -U matt '(uid=barbara)' structuralObjectClass</strong></pre></div><p>Here is the information:</p><div><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: uid=barbara,ou=Users,dc=example,dc=com
structuralObjectClass: inetOrgPerson</pre></div><p>When handling operations and evaluating rules, such as DIT content rules, SLAPD will treat this record as an <code class="literal">inetOrgPerson</code> record.</p><p>Within this discussion of structural object classes we have covered the gist of the object class hierarchy. An entry's place in the hierarchy is determined by its structural object class. But not all object classes affect a record's placement in the object class hierarchy. Let's turn to the third type of object class: auxiliary object classes.<a class="indexterm" id="id660"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec80"/>Auxiliary Object Classes</h3></div></div></div><a class="indexterm" id="id661"/><a class="indexterm" id="id662"/><p>Auxiliary object classes provide a mechanism for adding one or more attributes to an entry with an existing structural object class. Think of it as a modular system for defining a collection of related attributes that can be attached to otherwise (conceptually) unrelated object classes.</p><p>To get an idea of how this works let's take another look at the <code class="literal">uid=authenticate</code> entry:</p><div><pre class="programlisting">dn: uid=authenticate,ou=System,dc=example,dc=com
uid: authenticate
ou: System
description: Special account for authenticating users
userPassword:: c2VjcmV0
objectClass: account
objectClass: simpleSecurityObject</pre></div><p>The structural object class for this entry is <code class="literal">account</code>. The <code class="literal">simpleSecurityObject</code> object class is auxiliary.</p><p>The <code class="literal">account</code> schema, found in <code class="literal">cosine.schema</code>, looks like this:</p><div><pre class="programlisting">objectclass 
  ( 
   0.9.2342.19200300.100.4.5 
   NAME 'account'
   SUP top STRUCTURAL
   MUST userid
   MAY ( description $ seeAlso $ localityName $
         organizationName $ organizationalUnitName $ host )
  )</pre></div><p>This entry, according to the COSINE standard (RFC 4524), is to define a system account on a computer.</p><p>For whatever reason, the creators of the standard did not include the attributes necessary to give the account a password. This makes sense. It is probably not typical that a system account would need to authenticate against LDAP. However, the system account we have created needs to perform directory operations and so we need this account to have a <code class="literal">userPassword</code> attribute.</p><p>One way to achieve this is to create a new structural object class subordinate to account, but which requires a <code class="literal">userPassword</code> attribute. But there is also an object class in <code class="literal">core.schema</code> designed specifically for the purpose of giving non-person entries in the directory a <code class="literal">userPassword</code> to allow them to bind. In other words, there is an existing object class that provides exactly the functionality we require: the <code class="literal">simpleSecurityObject</code> object class.</p><div><div><h3 class="title"><a id="note112"/>Note</h3><p>The <code class="literal">simpleSecurityObject</code> is also defined in the COSINE schema.</p></div></div><p>The <code class="literal">simpleSecurityObject</code> schema looks like this:</p><div><pre class="programlisting">objectclass 
  ( 
   0.9.2342.19200300.100.4.19 
   NAME 'simpleSecurityObject'
   DESC 'RFC1274: simple security object'
   SUP top 
   AUXILIARY
   MUST userPassword 
  )<a class="indexterm" id="id663"/>
</pre></div><p>This schema definition adds one required attribute to any implementing entry, <code class="literal">userPassword</code>. Effectively then, the <code class="literal">simpleSecurityObject</code> object class can be added to an entry in order to allow it to bind to the directory (assuming the ACLs allow).</p><p>Given the combination of the structural object class, <code class="literal">account</code>, and the auxiliary object class, <code class="literal">simpleSecurityObject</code>, our <code class="literal">uid=authenticate</code> record now has three required fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">objectclass</code>, inherited from <code class="literal">top</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">uid</code>, from the <code class="literal">account</code> structural object class</li><li class="listitem" style="list-style-type: disc"><code class="literal">userPassword</code>, from the <code class="literal">simpleSecurityObject</code> auxiliary object class.</li></ul></div><p>This example illustrates how the auxiliary object class can be used to add additional attributes to an entry that already belongs to a structural object class.</p><p>Rather than creating new structural object classes for each set of attributes you want an entry to have, the auxiliary object class mechanism makes it possible to define a modular collection of add-on attributes that can be attached to entries as needed.</p><p>By default, any auxiliary object class can be added to a record regardless of the structural object class of that record.</p><p>In other words, by default it is legal to take an entry with a <code class="literal">person</code> structural object class (an entry obviously intended to represent a human being) and attach to it the <code class="literal">javaSerializedObject</code> auxiliary object class (an entry intended to describe a stored representation of a Java binary class).</p><p>Historically, the responsibility for judiciously choosing which auxiliary object classes ought to be added to an entry has been left to LDAP client applications and users. However, you can use DIT content rules (see the previous part of this chapter) to formalize which auxiliary object classes an entry of a given structural object class is allowed to have.<a class="indexterm" id="id664"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Moving Onward</h2></div></div></div><p>Up to this point, this chapter has focused on the details of the LDAP schema system, and has focused as much on theoretical points as it has on practice.</p><p>In these pages, I have tried to provide a condensed explanation of LDAP schemas, focusing on the aspects most applicable to the goals of this book. This material should provide the necessary background knowledge for reading schema definitions, wisely selecting which schemas to use for your own directory needs, and writing custom schemas.</p><p>However, if you intend to work on the OpenLDAP code, write overlays or modules, or even write schemas intended for public standardization, you ought to read the LDAP RFCs, particularly RFC 4512, which defines the LDAP schema language.</p><p>Now we are ready to move on to more practical matters. In the next section, we will implement a few overlays that require extra schemas. As we configure those overlays we will examine the schemas and the role those schemas play in the functioning of the overlay.</p><p>After that, we will create our own short schema.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Schemas: Accesslog and Password Policy Overlays</h1></div></div></div><p>In the last chapter we saw OpenLDAP's overlay technology, and we implemented a few simple overlays. In this chapter we have seen how LDAP schemas work. Now we are going to take a look at a few overlays that require custom schemas.</p><p>The two overlays that we will examine are the <code class="literal">accesslog</code> overlay and the <code class="literal">ppolicy</code> (Password Policy) overlay.</p><p>Because they require their own schemas, and because each provides a robust feature set, these two overlays have a more complicated configuration. However, since the basic concepts are familiar already, we will move quickly.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Logging with the Accesslog Overlay</h2></div></div></div><a class="indexterm" id="id665"/><a class="indexterm" id="id666"/><a class="indexterm" id="id667"/><p>The Access Logging overlay (<code class="literal">accesslog</code>) extends the logging abilities of the SLAPD server. First, it makes it possible to track client access to the directory server. Second, it stores this logging data within the directory, making it possible to retrieve access logs from any authorized LDAP client.</p><p>Since it stores information inside of the directory server, and since the format for access log entries is not already described in any of the familiar schemas, the access logging overlay needs its own schema.</p><p>The access log schema is still considered experimental, and has not yet been finalized. Nor is it included in the schema directory (<code class="literal">/etc/ldap/schema</code> or <code class="literal">/usr/local/etc/openldap/schema</code>). The object classes are defined in the man page (<code class="literal">man</code> <code class="literal">slapo-accesslog</code>).</p><p>However, the access log overlay automatically loads its own schema, so there is no manual schema configuration to be done.</p><p>The process of installing the <code class="literal">accesslog</code> is of four steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Load the <code class="literal">accesslog</code> module</li><li class="listitem">Configure the <code class="literal">accesslog</code> backend section</li><li class="listitem">Create a database to store the access log</li><li class="listitem">Configure the directory backend to log to the new database</li></ol></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec81"/>Loading the accesslog Module</h3></div></div></div><a class="indexterm" id="id668"/><p>By now, this step should be familiar. Along with the other <code class="literal">moduleload</code> statements at the top of <code class="literal">slapd.conf</code>, we need to add one to load the <code class="literal">accesslog</code> module:</p><div><pre class="programlisting">modulepath      /usr/local/libexec/openldap
moduleload      back_hdb
moduleload      denyop
moduleload      refint
moduleload      unique
<strong>moduleload      accesslog</strong>
</pre></div><p>When SLAPD is restarted the <code class="literal">accesslog</code> module, which contains the <code class="literal">accesslog</code> overlay, will be loaded.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec82"/>Configuring the Access Log Backend</h3></div></div></div><a class="indexterm" id="id669"/><p>The <code class="literal">accesslog</code> overlay needs a location within the directory server to write the access information. We will create an extra database backend that will hold the logging data.</p><p>There is nothing particularly special about this backend. It functions just like any other, and we will use the standard set of configuration directives. But there is one catch to implementing <code class="literal">accesslog</code>: the database where the access logs are stored must appear in <code class="literal">slapd.conf</code> <em>before</em> the database that it is going to record access data about.</p><p>We want to log access to our first database (the one with suffix <code class="literal">dc=example,dc=com</code>), so we need to insert the configuration directives for the access log before the <code class="literal">dc=example,dc=com</code> database. Here's the beginning of the original Example.Com database definition:</p><div><pre class="programlisting">##############################
# BDB Database Configuration #
##############################
# Database 1: Example.Com

database        hdb
suffix          "dc=example,dc=com" "o=My Company,c=US"
rootdn          "cn=Manager,dc=example,dc=com"</pre></div><p>We will insert our access log configuration above the <code class="literal">database</code> directive in the previous example:</p><div><pre class="programlisting">##############################
# BDB Database Configuration #
##############################
<strong># Database 1: Logging DB</strong>

<strong>database hdb</strong>
<strong>suffix cn=log</strong>
<strong>rootdn          "cn=Manager,cn=log"</strong>
<strong>rootpw          secret</strong>
<strong>directory      /var/lib/ldap/accesslog</strong>
<strong>#directory       /usr/local/var/openldap-data/accesslog</strong>
<strong>index reqStart eq</strong>

##############################
# Database 2: Example.Com

database        hdb
suffix          "dc=example,dc=com" "o=My Company,c=US"</pre></div><p>The highlighted section is the definition for the access log database.</p><p>As with the other databases, this one uses the HDB backend. The suffix for our logging directory will simply be <code class="literal">cn=log</code>.</p><p>Each logging event will be stored as an LDAP record, and each entry in the logging directory will have a DN composed of two attributes. The RDN is the <code class="literal">reqStart</code> attribute (which contains the timestamp indicating when the request started), and ends with the suffix which, in our case, is <code class="literal">cn=log</code>.</p><p>This database also has its own manager account and password (<code class="literal">rootdn</code> and <code class="literal">rootpw</code>). The Berkeley DB files will be stored at <code class="literal">/var/lib/ldap/accesslog</code>—a directory we will create on the file system in the next step.</p><a class="indexterm" id="id670"/><p>Finally, the <code class="literal">index</code> directive configures an equality (<code class="literal">eq</code>) index for the <code class="literal">reqStart</code> attribute, which is the attribute SLAPD uses to create DNs. It uses this attribute when performing maintenance operations, so it is a good idea to have this attribute indexed.</p><p>There are a few more things to do in <code class="literal">slapd.conf</code>. But before doing those, we will create a directory for the Berkeley DB files.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec83"/>Creating A Directory for the Access Log Files</h3></div></div></div><a class="indexterm" id="id671"/><p>Like the other HDB databases, this new database needs a location on the server's file system to store Berkeley DB database files. In the earlier configuration, we pointed SLAPD to the directory <code class="literal">/var/lib/ldap/accesslog</code>. Now, we need to create that directory and configure it for a Berkeley DB environment.</p><p>The first thing to do is create the new directory. From a shell this can be done easily:</p><div><pre class="programlisting">
<strong>  $ sudo mkdir /var/lib/ldap/accesslog</strong>
</pre></div><p>From there, all we need to do is copy the <code class="literal">DB_CONFIG</code> to the new <code class="literal">accesslog/</code> directory:</p><div><pre class="programlisting">
<strong>  $ sudo cp /var/lib/ldap/DB_CONFIG /var/lib/ldap/accesslog/</strong>
</pre></div><p>Depending on the traffic on your server and the amount of data you are logging, you may want to increase or decrease the cache size allocated in <code class="literal">DB_CONFIG</code>. See the discussion in the previous chapter for more information on tuning the <code class="literal">DB_CONFIG</code> file.</p><div><div><h3 class="title"><a id="note113"/>Note</h3><p><strong>Check the DB_CONFIG files</strong></p><p>The <code class="literal">DB_CONFIG</code> file we created in the last chapter did not have any absolute references to locations on the file system. But some directives in the <code class="literal">DB_CONFIG</code> file (like <code class="literal">set_lg_dir</code>) might have absolute path references, which could result in two databases using the same log. That would have catastrophic consequences. Make sure you adjust the <code class="literal">DB_CONFIG</code> file accordingly.</p></div></div><p>Make sure that the new <code class="literal">accesslog/</code> directory is readable and writable for the user account that runs the SLAPD process, and also make sure that that user can read the <code class="literal">DB_CONFIG</code> file.<a class="indexterm" id="id672"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec84"/>Enabling Logging for the Main Backend</h3></div></div></div><a class="indexterm" id="id673"/><p>Now we have the logging environment set up. The next thing to do is configure our <code class="literal">dc=example,dc=com</code> backend to start using the new logging backend.</p><p>Back in <code class="literal">slapd.conf</code>, we need to add some new overlay-specific directives inside of the <code class="literal">dc=example,dc=com</code> backend. These directives must come after the database definition for the Example.Com database:</p><div><pre class="programlisting">##############################
# Database 1: Example.Com

database        hdb
suffix          "dc=example,dc=com" "o=My Company,c=US"

# ... a dozen lines omitted ...

overlay accesslog
logdb cn=log
logops all
logold (objectclass=person)
logpurge 7+00:00 2+00:00
logsuccess TRUE</pre></div><p>The first directive, <code class="literal">overlay</code> <code class="literal">accesslog</code>, loads the access logging overlay within the context of this particular database. The next five directives are the accesslog-specific directives.</p><p>The <code class="literal">logdb</code> directive is the only one required by the <code class="literal">accesslog</code> overlay. All the rest are optional.</p><p>The <code class="literal">logdb</code> directive specifies which database will be treated as an access log. In our case we want to use the <code class="literal">cn=log</code> database. For a site hosting multiple directory information trees, separate logging databases could be set up for each suffix.</p><p>The <code class="literal">logops</code> directive is used to specify exactly which LDAP operations should be logged. In this example, the keyword <code class="literal">all</code> indicates that all operations will be logged. But the following options are supported:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Any operation can be specified by name: <code class="literal">add</code>, <code class="literal">delete</code>, <code class="literal">modify</code>, <code class="literal">modrdn</code>, <code class="literal">search</code>, <code class="literal">compare</code>, <code class="literal">extended</code>, <code class="literal">bind</code>, <code class="literal">unbind</code>, and <code class="literal">abandon</code>.</li><li class="listitem" style="list-style-type: disc">There are a few special keywords that include a collection of operations. These are:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">read</code> (search, compare)</li><li class="listitem" style="list-style-type: disc"><code class="literal">write</code> (add, delete, modify, modrdn)</li><li class="listitem" style="list-style-type: disc"><code class="literal">session</code> (bind, unbind, abandon)</li></ul></div></li><li class="listitem" style="list-style-type: disc">There is the <code class="literal">all</code> keyword, which includes all operations.</li></ul></div><p>More than one value can be placed on a <code class="literal">logops</code> line. Values should be separated by an empty space. For example, <code class="literal">logops</code> <code class="literal">modify</code> <code class="literal">modrdn</code> will log all modify and modrdn operations.<a class="indexterm" id="id674"/>
</p><p>The <code class="literal">logold</code> ("log old") directive takes a search filter. When a delete or modify operation is successfully executed, then <code class="literal">accesslog</code> will check to see if the record matches the filter. If it does match, then <code class="literal">accesslog</code> will store a complete record of the change, including what attributes were added, and what attributes were changed or removed. For example, when I modified a user with the <code class="literal">ldapmodify</code> command-line tool, an entry detailing the changes was written to the accesslog directory information tree:</p><div><pre class="programlisting">dn: reqStart=20070117022818.000002Z,cn=log
objectClass: auditModify
reqStart: 20070117022818.000002Z
reqEnd: 20070117022818.000003Z
reqType: modify
reqSession: 4
reqAuthzID: uid=matt,ou=users,dc=example,dc=com
reqDN: uid=barbara,ou=users,dc=example,dc=com
reqResult: 0
<strong>reqMod: objectClass:+ labeledURIObject</strong>
<strong>reqMod: labeledURI:+ http://example.com Home Page</strong>
<strong>reqMod: entryCSN:= 20070117022818Z#000001#00#000000</strong>
<strong>reqMod: modifiersName:= uid=matt,ou=users,dc=example,dc=com</strong>
<strong>reqMod: modifyTimestamp:= 20070117022818Z</strong>
<strong>reqOld: objectClass: person</strong>
<strong>reqOld: objectClass: organizationalPerson</strong>
<strong>reqOld: objectClass: inetOrgPerson</strong>
<strong>reqOld: entryCSN: 20061228230549Z#000000#00#000000</strong>
<strong>reqOld: modifiersName: cn=Manager,dc=example,dc=com</strong>
<strong>reqOld: modifyTimestamp: 20061228230549Z</strong>
</pre></div><p>The <code class="literal">reqMod</code> values show the new modifications, while the <code class="literal">reqOld</code> attribute values show the old lines. Note that two lines were added (the object class and the <code class="literal">labeledURI</code>), and two were changed (<code class="literal">modifiersName</code>, <code class="literal">modifyTimestamp</code>).</p><p>Why use <code class="literal">logold</code>? It may not be particularly useful for log evaluation but, when combined with SyncRepl, synchronization between SLAPD servers can be done more efficiently. (This form of SyncRepl is called <strong>Delta-SyncRepl</strong>.) If you are not using SyncRepl, you probably won't want to use <code class="literal">logold</code> at all. We will discuss SyncRepl (and Delta-SyncRepl) in detail in the next chapter.</p><p>The <code class="literal">logpurge</code> directive directs SLAPD to periodically check the access log and delete old entries. It takes two parameters that provide the following information: how old an entry must be before it is a candidate for being purged, and how long of an interval should pass between checking for entries to remove.</p><p>The format of the two parameters is the same: <a class="indexterm" id="id675"/>
</p><div><pre class="programlisting">[&lt;number of days&gt;+]&lt;hours&gt;:&lt;minutes&gt;[:&lt;seconds&gt;]</pre></div><p>Where number of days and number of seconds are optional fields. Our <code class="literal">logpurge</code> parameter looked like this:</p><div><pre class="programlisting">logpurge 7+00:00 2+00:00</pre></div><p>This indicates that logs seven days old are to be considered for deletion. And after running a check, SLAPD will wait the indicated amount of time—two days—before checking for new deletions.</p><p>The last parameter is <code class="literal">logsuccess</code>. By default, <code class="literal">accesslog</code> records all attempted operations, whether successful or not. To log only the operations that are successfully completed set <code class="literal">logsuccess</code> to <code class="literal">TRUE</code>.</p><p>That's all there is to configuring <code class="literal">accesslog</code>. SLAPD will need to be restarted for the new overlay to be added.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec85"/>The Log Records</h3></div></div></div><a class="indexterm" id="id676"/><a class="indexterm" id="id677"/><p>Now that we have our new logging overlay running, let's test it out. The first step is to generate some logging data. Since we are logging all operations (<code class="literal">logops</code> <code class="literal">all</code>), any LDAP operation will do.</p><p>Here is a simple <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \</strong>
<strong>      '(uid=matt)' mail gn sn</strong>
</pre></div><p>This uses a simple bind, and searches for my own record (<code class="literal">uid=matt</code>), retrieving the values for the <code class="literal">mail</code>, <code class="literal">gn</code> (given name) and <code class="literal">sn</code> attributes.</p><p>With a search like this, what is written to the access log? To find out, we can use <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">
<strong>$ ldapsearch -LL -U matt -b 'cn=log'</strong>
</pre></div><p>The output for this command, even with the results of only one command, is surprisingly large:</p><div><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
version: 1

dn: cn=log
objectClass: auditContainer
cn: log

dn: reqStart=20070117044539.000000Z,cn=log
objectClass: auditBind
reqStart: 20070117044539.000000Z
reqEnd: 20070117044539.000001Z
reqType: bind
reqSession: 0
reqAuthzID:
reqDN: uid=matt,ou=users,dc=example,dc=com
reqResult: 0
reqVersion: 3<a class="indexterm" id="id678"/>
reqMethod: SIMPLE

dn: reqStart=20070117044539.000002Z,cn=log
objectClass: auditSearch
reqStart: 20070117044539.000002Z
reqEnd: 20070117044539.000003Z
reqType: search
reqSession: 0
reqAuthzID: uid=matt,ou=Users,dc=example,dc=com
reqDN: dc=example,dc=com
reqResult: 0
reqScope: sub
reqDerefAliases: never
reqAttrsOnly: FALSE
reqFilter: (uid=matt)
reqAttr: mail
reqAttr: gn
reqAttr: sn
reqEntries: 1
reqTimeLimit: 3600
reqSizeLimit: 500

dn: reqStart=20070117044540.000000Z,cn=log
objectClass: auditObject
reqStart: 20070117044540.000000Z
reqEnd: 20070117044540.000001Z
reqType: unbind
reqSession: 0
reqAuthzID: uid=matt,ou=Users,dc=example,dc=com</pre></div><p>There are four different entries returned from the <code class="literal">ldapsearch</code> and each one has a different structural object class. We will look at each in turn.</p><p>The first LDIF entry it displays is the base record for <code class="literal">cn=log</code>:</p><div><pre class="programlisting">dn: cn=log<a class="indexterm" id="id679"/>
objectClass: auditContainer
cn: log</pre></div><p>The <code class="literal">auditContainer</code> object class is designed as a sort of general-purpose object class for the access log. It's schema looks like this:</p><div><pre class="programlisting">objectClass 
  ( 
   1.3.6.1.4.1.4203.666.11.5.2.0 
   NAME 'auditContainer' 
   DESC 'AuditLog container' 
   SUP top 
   STRUCTURAL 
   MAY ( cn $ reqStart $ reqEnd ) 
  )</pre></div><p>The base record only uses the optional <code class="literal">cn</code> attribute.</p><p>In the <code class="literal">accesslog</code> schema there are object classes defined for each LDAP operation: <code class="literal">auditAbandon</code>, <code class="literal">auditAdd</code>, <code class="literal">auditBind</code>, <code class="literal">auditCompare</code>, <code class="literal">auditDelete</code>, <code class="literal">auditModify</code>, <code class="literal">auditModRDN</code>, <code class="literal">auditSearch</code>, and <code class="literal">auditExtended</code>. In addition, there is a special object class called <code class="literal">auditObject</code> that describes general events.</p><p>In fact (in the current version) all of the operation object classes listed are subordinates to the <code class="literal">auditObject</code> object class. Because it is the parent of these other object classes, we will begin by looking at the <code class="literal">auditObject</code> schema definition.</p><p>The <code class="literal">auditObject</code> object class definition looks like this:</p><div><pre class="programlisting">objectclass 
  ( 
   1.3.6.1.4.1.4203.666.11.5.2.1 
   NAME 'auditObject' 
   DESC 'OpenLDAP request auditing' 
   SUP top 
   STRUCTURAL 
   MUST ( reqStart $ reqType $ reqSession ) 
   MAY ( reqDN $ reqAuthzID $ reqControls $ reqRespControls $
         reqEnd $ reqResult $ reqMessage $ reqReferral ) 
  )</pre></div><p>The three required attributes are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reqStart</code>:A timestamp indicating the starting time of the operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqType</code>: A string indicating the operation being executed</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqSession</code>: The connection ID number used (internally) by SLAPD</li></ul></div><p>In addition to these required attributes, there are eight optional attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reqDN</code>: This records the DN of the record the operation is currently operating on.<a class="indexterm" id="id680"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">reqAuthzID</code>: This records the DN of the user performing the operation. If the user is Anonymous the value is left blank.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqControls</code> and <code class="literal">reqRespControls</code>: If the client sets any controls, they are indicated here.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqEnd</code>: This stores the timestamp indicating when the operation was completed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqResult</code>: This contains the numeric error code if an error was encountered. If the operation is successful this returns <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqMessage</code>: If the error code is accompanied by a text message, the message is put in this attribute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqReferral</code>: If the operation returned a referral, the referral is noted here.</li></ul></div><p>The second entry returned in the search records the client's bind operation:</p><div><pre class="programlisting">dn: reqStart=20070117044539.000000Z,cn=log
objectClass: auditBind
reqStart: 20070117044539.000000Z
reqEnd: 20070117044539.000001Z
reqType: bind
reqSession: 0
reqAuthzID:
reqDN: uid=matt,ou=users,dc=example,dc=com
reqResult: 0
reqVersion: 3
reqMethod: SIMPLE</pre></div><p>This first entry records the bind operation, and is an instance of the <code class="literal">auditBind</code> object class. The <code class="literal">auditBind</code> object class is a subordinate of <code class="literal">auditObject</code>:</p><div><pre class="programlisting">objectClass 
  ( 
   1.3.6.1.4.1.4203.666.11.5.2.6 
   NAME 'auditBind' 
   DESC 'Bind operation' 
   SUP auditObject 
   STRUCTURAL 
   MUST ( reqVersion $ reqMethod ) 
  )<a class="indexterm" id="id681"/>
</pre></div><p>It adds two required attributes: <code class="literal">reqVersion</code>, which records the version of LDAP used for the connection and <code class="literal">reqMethod</code>, which indicates what method was used in binding.</p><p>Looking at the bind entry, we can see that it records the details of a successful bind operation. The start and end times are recorded in <code class="literal">reqStart</code> and <code class="literal">reqEnd</code> respectively. The <code class="literal">reqType</code> indicates that the operation performed is a bind operation. The <code class="literal">reqSession</code> indicates the internal ID of the request (which happens to be zero because this is the first operation run since we started SLAPD, and connection IDs increment starting at <code class="literal">0</code>).</p><p>Since the bind was performed by the anonymous user, the <code class="literal">reqAuthzID</code> attribute is present, but has no value. The <code class="literal">reqDN</code> indicates that the client was attempting to bind as <code class="literal">uid=matt,ou=users,dc=example,dc=com</code>, and the <code class="literal">reqResult</code> of <code class="literal">0</code> indicates that the bind operation was completed successfully. The bottom two attributes are the attributes that belong to the <code class="literal">auditBind</code> object class. The <code class="literal">reqVersion</code> attribute indicates that the client used the LDAPv3 protocol and, according to <code class="literal">reqMethod</code>, the bind was a simple bind.</p><p>So, the first operation performed in this LDAP session was a bind. The second operation is the search:</p><div><pre class="programlisting">dn: reqStart=20070117044539.000002Z,cn=log
objectClass: auditSearch
reqStart: 20070117044539.000002Z
reqEnd: 20070117044539.000003Z
reqType: search
reqSession: 0
reqAuthzID: uid=matt,ou=Users,dc=example,dc=com
reqDN: dc=example,dc=com
reqResult: 0
reqScope: sub
reqDerefAliases: never
reqAttrsOnly: FALSE
reqFilter: (uid=matt)
reqAttr: mail
reqAttr: gn
reqAttr: sn
reqEntries: 1
reqTimeLimit: 3600
reqSizeLimit: 500</pre></div><p>Since it describes a search operation, this entry uses the <code class="literal">auditSearch</code> object class, which has the following schema definition:</p><div><pre class="programlisting">objectClass 
  ( 
   1.3.6.1.4.1.4203.666.11.5.2.11 
   NAME 'auditSearch' 
   DESC 'Search operation' 
   SUP auditReadObject 
   STRUCTURAL 
   MUST ( reqScope $ reqDerefAliases $ reqAttrsonly ) 
   MAY ( reqFilter $ reqAttr $ reqEntries $ reqSizeLimit $
         reqTimeLimit ) 
  )</pre></div><p>Note that <code class="literal">auditSearch</code> is a subordinate not of <code class="literal">auditObject</code> but of <code class="literal">auditReadObject</code>, another structural object class that is itself subordinate to <code class="literal">auditObject</code>. In other words, <code class="literal">auditSearch</code> is an indirect subclass of <code class="literal">auditObject</code>. The <code class="literal">auditReadObject</code> (as of OpenLDAP 2.3.30) does not add any additional attributes.</p><p>For the most part the attributes inherited from <code class="literal">auditObject</code> perform in the same capacity here as they did in the entry for the bind operation. The <code class="literal">reqAuthzID</code> in this case is the authenticated user's DN, instead of empty, and the <code class="literal">reqDN</code> shows the base DN for the search operation.<a class="indexterm" id="id682"/>
</p><p>The next set of attributes provide detailed information about the nature of the search request.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reqScope</code> indicates the scope of the search. <code class="literal">reqDerefAliases</code> indicates that aliased entries (entries mapped to other entries elsewhere in the directory, a concept similar to symbolic linking in Linux file systems) are never dereferenced during searches. The <code class="literal">reqAttrsOnly</code> flag indicates that the search did not request that only the attribute names be returned. Instead, the names and values were to be returned.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqFilter</code> contains the LDAP search filter. This is the filter we specified on the command line when running the <code class="literal">ldapsearch</code> command.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqAttr</code> has three values, <code class="literal">mail</code>, <code class="literal">gn</code>, and <code class="literal">sn</code>, corresponding to the three attributes I requested in the <code class="literal">ldapsearch</code> command. And <code class="literal">reqEntries</code> indicates the total number of matching records found in the directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reqTimeLimit</code> and <code class="literal">reqSizeLimit</code> indicate the (soft) size and time limits requested in the search.</li></ul></div><p>Taken as a whole, this entry provides a detailed record of what my LDAP search was and, from this record alone, it would be trivial to replicate the exact search.</p><p>There is one final (short) entry left, the entry that records the client's unbind.</p><div><pre class="programlisting">dn: reqStart=20070117044540.000000Z,cn=log
objectClass: auditObject
reqStart: 20070117044540.000000Z
reqEnd: 20070117044540.000001Z
reqType: unbind
reqSession: 0
reqAuthzID: uid=matt,ou=Users,dc=example,dc=com</pre></div><p>Since there are no paramters to the unbind operation (just the closing of a connection), there is no specific object class to model this event. Instead, the <code class="literal">auditObject</code> object class is used as the structural object class for this entry.</p><p>When clients perform other kinds of LDAP operations, such as additions and modifications, different object classes will be used. The object class definitions (and attribute definitions) can be found in the <code class="literal">cn=sucbschema</code> record. See the earlier section <em>Retrieving</em> <em>the</em> <em>Schema</em> <em>from</em> <em>SLAPD</em> for information on how to do this.</p><p>Now we have finished looking at the <code class="literal">accesslog</code> overlay. This overlay can come in use not only for record keeping but for debugging troublesome issues, discovering which attributes would most benefit form indexing, and even adding performance-enhancing functionality to directory replication. In the next section, we will look at the password policy overlay.<a class="indexterm" id="id683"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec83"/>Implementing a Complex Overlay: Password Policy</h2></div></div></div><a class="indexterm" id="id684"/><a class="indexterm" id="id685"/><p>One of the proposed extensions to LDAP is a standardized method for implementing password policies in an LDAP directory. The Password Policy (<code class="literal">ppolicy</code>) overlay implements the "Password Policy for LDAP Directories" IETF draft, which is likely to soon become an RFC.</p><p>A password policy provides account aging, password expirations, password strength checking, grace logins, and a variety of other password maintenance services.</p><p>How does this work in OpenLDAP? Password policy information is stored inside of the directory information tree in records described by a specialized schema. The <code class="literal">ppolicy</code> overlay monitors connections, updating password information and enforcing the password policy as appropriate.</p><div><div><h3 class="title"><a id="note114"/>Note</h3><p>Password policies operate on the <code class="literal">userPassword</code> attribute. That means that if you use SASL and store the passwords outside of the directory information tree (in a place such as the <code class="literal">sasldb</code>), then the <code class="literal">ppolicy</code> overlay will not function. In this chapter we will be using simple binding.</p></div></div><p>The password policy schema defines the object class, <code class="literal">pwdPolicy</code>, that is implemented by password policy entries. There are no object classes for user records. Instead, operational attributes (attributes used internally by SLAPD) are used to store password policy information in user records. These operational attributes are used to store internal information (such as when a user last changed the password), and usually managed solely by the <code class="literal">ppolicy</code> overlay.</p><p>The password policy extension has many features, all documented in the man page, as well as in the IETF draft standard. Since the draft has not been finalized, and is still in a state of change, this module is marked as experimental. New features may be added, or current features altered or even removed, as the standard changes. But the experimental categorization does not reflect on the stability of the code. Administrators of large systems have reported this module to be production quality.</p><p>Because of the wealth of features, the <code class="literal">ppolicy</code> overlay is not a quick and easy install. It will require the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Include the password policy schema and load the module</li><li class="listitem">Create a password policy</li><li class="listitem">Configure the <code class="literal">ppolicy</code> overlay</li></ol></div><p>Once the password policy overlay is implemented, we will do some testing.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec86"/>Setting the Global Directives in slapd.conf: Schema and Module</h3></div></div></div><a class="indexterm" id="id686"/><p>The first thing we need to do is configure the global (basic) section of the <code class="literal">slapd.conf</code> file. As with the other overlays we will need to load the <code class="literal">ppolicy</code> module. And since we are using a new schema—one stored in the <code class="literal">schema/</code> directory—we will need to include that too.</p><p>Since the directives are close together, we can look at both additions at once:</p><div><pre class="programlisting">include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema
<strong>include /etc/ldap/schema/ppolicy.schema</strong>

#pidfile /var/run/slapd/slapd.pid
#argsfile /var/run/slapd/slapd.args
pidfile /usr/local/var/run/slapd.pid
argsfile /usr/local/var/run/slapd.args
loglevel none

modulepath /usr/lib/ldap
# modulepath /usr/local/libexec/openldap
moduleload back_hdb
moduleload denyop
moduleload refint
moduleload unique
moduleload accesslog
<strong>moduleload ppolicy</strong>
</pre></div><p>The two highlighted lines show the necessary changes:</p><div><ol class="orderedlist arabic"><li class="listitem">The highlighted <code class="literal">include</code> directive imports the <code class="literal">ppolicy.schema</code> file into the configuration</li><li class="listitem">The <code class="literal">moduleload</code> directive loads the <code class="literal">ppolicy</code> module</li></ol></div><p>In step 3 we come back to the <code class="literal">slapd.conf</code> file and make a few more changes, but next we need to create a password policy and load it into the directory. That will require restarting SLAPD to pick up the new schema definitions:<a class="indexterm" id="id687"/>
</p><div><pre class="programlisting">
<strong>  $ sudo invoke-rc.d slapd restart</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec87"/>Creating a Password Policy</h3></div></div></div><a class="indexterm" id="id688"/><p>This step is more demanding than the previous. Our goal is to load a new password policy into the directory. To do this, we will need to get acquainted with the <code class="literal">pwdPolicy</code> object class in the <code class="literal">ppolicy</code> schema, create the requisite LDIF entries for our directory information tree, and then load these into the directory with <code class="literal">ldapadd</code>.</p><p>The <code class="literal">pwdPolicy</code> object class contains a number of attributes that can be used for storing information about a password policy. A password policy is a set of conditions determining what constraints will be placed on password usage within the LDAP server.</p><p>Here is the schema for the <code class="literal">pwdPolicy</code> object class:</p><div><pre class="programlisting">objectclass 
  ( 
   1.3.6.1.4.1.42.2.27.8.2.1
   NAME 'pwdPolicy'
   SUP top
   AUXILIARY
   MUST ( pwdAttribute )
   MAY ( pwdMinAge $ pwdMaxAge $ pwdInHistory $ pwdCheckQuality $
         pwdMinLength $ pwdExpireWarning $ pwdGraceAuthNLimit $
         pwdLockout $ pwdLockoutDuration $ pwdMaxFailure $
         pwdFailureCountInterval $ pwdMustChange $ pwdAllowUserChange 
         $ pwdSafeModify ) 
  )</pre></div><p>This object class is an auxiliary object class so, when we create an entry to hold the policy, it will need a structural object class.</p><p>There is only one required attribute for <code class="literal">pwdPolicy</code>: <code class="literal">pwdAttribute</code>. The value of this attribute should be set to the OID of the attribute used for password storage. Since the schema is part of a proposed standard, the purpose of this attribute is to make it possible for different directory servers to all use the same schema (since different directory server implementations use different attributes for storing password values). However, for OpenLDAP's SLAPD, the only attribute that can be used here is the OID for <code class="literal">userPassword</code>, which is <code class="literal">2.5.4.35</code>.</p><div><div><h3 class="title"><a id="note115"/>Note</h3><p>The <code class="literal">authPassword</code> attribute, defined in RFC 3112, is a candidate for replacing <code class="literal">userPassword</code> in future versions of OpenLDAP. However, at this time it is not completely implemented.</p></div></div><a class="indexterm" id="id689"/><p>The remaining attributes, all of which are optional, are used to store policy information. Here is a brief explanation of what each attribute is used for:<a class="indexterm" id="id690"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pwdMinAge</code>: This specifies how much time must pass (in seconds) between the last time the password was changed and the next time SLAPD will allow the password to be changed. Setting this prevents an account from having the password changed multiple times in rapid succession.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdMaxAge</code>: This specifies how long (in seconds) a password will be considered good. This is calculated from the time when the password was last changed. After the elapsed time, the password will be marked as expired.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdInHistory</code>: If you store your passwords in plain text (unencrypted) in the directory then the <code class="literal">ppolicy</code> overlay can be configured to maintain a password history and prevent users from re-using passwords. This attribute is used to specify the maximum number of passwords that <code class="literal">ppolicy</code> will maintain for each user. Unless this attribute is set, and to a value greater than zero, no history will be maintained.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdCheckQuality</code>: There are two quality checks done by <code class="literal">ppolicy</code> if <code class="literal">pwdCheckQuality</code> is set to check passwords. The first is length checking (discussed next). The second is running a custom quality checking function. It is possible (using the <code class="literal">pwdCheckModule</code> object class and some custom C code) to add your own password quality checking module to SLAPD, and then use it to check password quality. This attribute takes one of three integer values: <code class="literal">0</code>, <code class="literal">1</code>, and <code class="literal">2</code>. Now we have three cases:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the value is <code class="literal">0</code> (the default), then <code class="literal">ppolicy</code> will not attempt to do any quality checking.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">1</code>, then <code class="literal">ppolicy</code> will attempt checking, but if the password is encrypted and certain checking functions cannot be performed, it will return successful.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">2</code>, then if the password checking function cannot run, it will return an error message.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdMinLength</code>: If <code class="literal">pwdCheckQuality</code> is set to <code class="literal">1</code> or <code class="literal">2</code>, then <code class="literal">ppolicy</code> will make sure that new passwords meet a minimum length requirement. This attribute, which takes a positive integer, can be used to set the minimum acceptable length for a password.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdExpireWarning</code>: When a password approaches its expiration date (set in <code class="literal">pwdMaxAge</code>), <code class="literal">ppolicy</code> can provide a warning to the user when the user logs in. This attribute takes the time, in seconds, prior to when the password expires that it should start warning the user. In other words, at <code class="literal">pwdMaxAge</code>—<code class="literal">pwdExpireWarning</code> from when the password was set—the user will start getting warning messages. If this is set to <code class="literal">0</code> (the default) then no expiration warning will be sent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdGraceAuthNLimit</code>: By default (or if this attribute is set to <code class="literal">0</code>), when a password expires the account is locked and the user can no longer bind to the directory server. But using this attribute we can allow grace logins. The value of this attribute should be a non-negative integer, which will specify how many grace logins a user with an expired password will be allowed before the account is locked.<a class="indexterm" id="id691"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdLockout</code>: This attribute allows you to turn on password lockouts. If this is turned on, then when a user fails to bind a certain number of times (<code class="literal">pwdMaxFailures</code>) in a row, then the account will be locked for some duration of time (<code class="literal">pwdLockoutDuration</code>). To turn on <code class="literal">pwdLockout</code>, which is off by default, set the value of this attribute to <code class="literal">TRUE</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdLockoutDuration</code>: This attribute specifies the amount of time, in seconds, that an account will be locked out if <code class="literal">pwdLockout</code> is set to <code class="literal">TRUE</code> and the user fails to log in too many times (the number set in <code class="literal">pwdMaxFailures</code>). If this is set to <code class="literal">0</code> or is not set, then the account will be locked until an administrator re-enables it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdMaxFailures</code>: This specifies the number of times in a row that a user can fail a login before being locked out. <code class="literal">pwdLockout</code> must be set to <code class="literal">TRUE</code> before this constraint will be enforced though.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdFailureCountInterval</code>: This attribute can be used to fine-tune the timing involved in password lockouts. By default (or when this attribute is set to <code class="literal">0</code>), failed login attempts are stored until a successful login is made. But the value of this attribute can be set to a number of seconds that <code class="literal">ppolicy</code> will wait before clearing the password failure count.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdMustChange</code>: This determines whether or not a user must change their password after an administrator sets it. By default, the user is not prompted to change a password. But if this is set to <code class="literal">TRUE</code>, if an administrator changes (or initially sets) a password, the user will be prompted to reset the password.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdAllowUserChange</code>: By default, users are allowed to change their own passwords. But if this is set to <code class="literal">FALSE</code>, users under this policy will not be allowed to change their own passwords. Since different policies can be assigned to different groups of users, this allows finer-grained control of write permissions to a password than ACLs do.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdSafeModify</code>: By default, once a user has successfully performed a bind operation, the user can change passwords without having to re-send the original password. But if <code class="literal">pwdSafeModify</code> is set to <code class="literal">TRUE</code>, then the user will have to send both the old password and the new password in order to change the password value. This adds an extra level of security to the password changing process.<a class="indexterm" id="id692"/></li></ul></div><p>Some of the policy attributes—primarily the password checking functions and password history—require that the password be stored in cleartext within the directory. This is the case simply because comparison functions do not work on encrypted values. Two identical password values, if using different salt sequences, will result in different ciphertexts. Two different hashing algorithms (like MD5 and SHA) will generate different hashes for the same password even if the same salt is used. Likewise, given certain hashing algorithms, two different strings could generate the same ciphertext (though the possibility of this happening to a particular user is negligible).</p><p>Most of the other features though, work regardless of how the values are stored in the directory.</p><p>Now we are ready to create an LDIF file to hold our policy. By convention, password policies are usually located in a separate OU in the directory information tree. We will add a new OU for that purpose.</p><p>And for our policy we will use the majority of the possible attributes:</p><div><pre class="programlisting">dn: ou=Policies,dc=example,dc=com
ou: Policies
description: Directory policies.
objectclass: organizationalUnit

dn: cn=Standard,ou=Policies,dc=example,dc=com
cn: Standard
description: Standard password policy.
pwdAttribute: 2.5.4.35
pwdMinAge: 60
# 30 days: 60 sec * 60 min * 24 hr * 30 days
pwdMaxAge: 2592000
pwdCheckQuality: 1
pwdMinLength: 7
# Warn three days in advance
pwdExpireWarning: 259200
pwdGraceAuthNLimit: 3
pwdLockout: TRUE
pwdLockoutDuration: 1200
pwdMaxFailure: 3
pwdFailureCountInterval: 1200
pwdMustChange: TRUE
pwdAllowUserChange: TRUE
pwdSafeModify: TRUE
objectclass: device
objectclass: pwdPolicy</pre></div><p>The first entry is for our organizational unit. The second is our password policy. Since the <code class="literal">pwdPolicy</code> object class is auxiliary we have to give the entry another object class, a structural object class. The <code class="literal">device</code> object class is typically used (based on the testing schema used in the source distribution of OpenLDAP).<a class="indexterm" id="id693"/>
</p><div><div><h3 class="title"><a id="tip4656464565"/>Tip</h3><p><strong>Why is pwdPolicy Auxiliary?</strong></p><p>There are a few reasons why the creators of the password policy specification might have made such a choice. First, according to RFC 4512, a structural object class must represent a physical entity. Second, making the class auxiliary makes it possible to integrate this schema with other existing schemas. For us, though, this presents the minor difficulty that there are no good candidates for a structural object class.</p></div></div><p>We can now add this LDIF with <code class="literal">ldapadd</code>. We have the above LDIF saved in a file called <code class="literal">ppolicy.ldif</code>, so we can add it with the following command:</p><div><pre class="programlisting">
<strong>  ldapadd -x -W -D 'uid=matt,ou=users,dc=example,dc=com' -f ppolicy.ldif</strong>
</pre></div><p>This adds our two new entries to the directory.</p><div><div><h3 class="title"><a id="note116"/>Note</h3><p>Make sure you have restarted the server since adding the schema. If the <code class="literal">ppolicy</code> schema has not been loaded, the above will not work.</p></div></div><p>Now that we have our entries loaded it is time to return to <code class="literal">slapd.conf</code> and configure the overlay.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec88"/>Configure the Overlay Directives</h3></div></div></div><a class="indexterm" id="id694"/><p>In the first step of setting up the password policy overlay, we added directives to <code class="literal">slapd.conf</code> to include the <code class="literal">ppolicy</code> schema definitions and load the <code class="literal">ppolicy</code> module. Now we will look at the backend configuration for the overlay.</p><p>As with the other overlays, all of the configuration directives are backend specific. Also, since the <code class="literal">ppolicy</code> overlay does a lot of writing to the directory information tree, not all features work on read-only databases.</p><p>While this overlay is sophisticated, there are only three directives for the overlay, and these are all straightforward. The relevant section in our <code class="literal">slapd.conf</code> file, in the <code class="literal">dc=example,dc=com</code> directory tree, looks like this:</p><div><pre class="programlisting">overlay ppolicy
ppolicy_default cn=Standard,ou=Policies,dc=example,dc=com
ppolicy_use_lockout
ppolicy_hash_cleartext </pre></div><p>Once the overlay is applied to this database using the <code class="literal">overlay</code> directive, there are three overlay-specific directives.</p><p>The first, <code class="literal">ppolicy_default</code>, points to the DN of the entry in the directory information tree that is to be treated as the default password policy entry. As we will see shortly different entries can use different policies. But the one indicated by <code class="literal">ppolicy_default</code> is the one that <code class="literal">ppolicy</code> will use when another is not explicitly set. For our example above, it is set to the DN of the entry that we created in the previous step.</p><p>The second directive is <code class="literal">ppolicy_use_lockout</code>. This directive alters how SLAPD reports error messages due to account lockouts. When a user's account is locked by the password policy overlay the user is not allowed to bind again. By default (when this directive is not included), the client is notified that the bind failed because of invalid credentials (the generic LDAP error) but no additional information is given. When this directive is present though, then SLAPD sends the <em>Account</em> <em>Locked</em> error code.</p><div><div><h3 class="title"><a id="note117"/>Note</h3><p>While this extra error message might be helpful to the user, it could have negative consequences. An attacker might be able to determine, based on this information, that the server is using the password lockout features. Such an attacker could then perform a denial of service attack against known accounts on the server simply by attempting to login on each known account until the account was locked.</p></div></div><p>The last <code class="literal">ppolicy</code> directive, <code class="literal">ppolicy_hash_cleartext</code>, modifies the way SLAPD handles changes to the password. In short, if this directive is present, then SLAPD will automatically hash cleartext passwords when they are changed using the LDAP modify operation (as opposed to the LDAP password modify extended operation).</p><p>To understand what this means, let's look at an example. In our directory we have the following record (created in Chapter 3):</p><div><pre class="programlisting">dn: uid=adam,ou=Users,dc=example,dc=com
cn: Adam Smith
sn: Smith
uid: adam
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>This user does not yet have a password. One way to set such a password would be to use the <code class="literal">ldappasswd</code> too, which (as we saw in Chapter 3) uses the LDAP password modify extended operation. This is the best way to change passwords as the server handles the password encryption. Here's an example of setting a password with <code class="literal">ldappasswd</code>:</p><div><pre class="programlisting">
<strong>  $ ldappasswd -U matt -s secret 'uid=adam,ou=users,dc=example,dc=com'</strong>
</pre></div><p>This sets the password for <code class="literal">uid=adam</code> to <code class="literal">secret</code>. What will the record look like now? Like this:<a class="indexterm" id="id695"/>
</p><div><pre class="programlisting">dn: uid=adam,ou=Users,dc=example,dc=com
cn: Adam Smith
sn: Smith
uid: adam
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
userPassword:: e1NTSEF9WlFzZWdrVUdpT3JKNUgwYXFRdisxQ0dpaTNYUFdkMjA=</pre></div><p>The <code class="literal">userPassword</code> value is base64 encoded. Its decoded value is this:</p><div><pre class="programlisting">{SSHA}ZQsegkUGiOrJ5H0aqQv+1CGii3XPWd20</pre></div><p>SLAPD performed the SSHA hashing of the value.</p><p>There is a second way of modifying the password and this is with the LDAP modify operation (as used by the <code class="literal">ldapmodify</code> client). When a <code class="literal">userPassword</code> value is changed with LDAP modify it is assumed that the client is sending the password value in the form in which it should be stored. In fact, the LDAP standard states that this is how the server should act when performing a modification of an attribute value. Thus, SLAPD will not encrypt the password.</p><p>Here's an example of using <code class="literal">ldapmodify</code> to set the password:</p><div><pre class="programlisting">$ ldapmodify -x -W -D 'uid=matt,ou=users,dc=example,dc=com'
Enter LDAP Password: 
<strong>dn: uid=adam,ou=users,dc=example,dc=com</strong>
<strong>changetype: modify</strong>
<strong>replace: userPassword</strong>
<strong>userPassword: secret</strong>
modifying entry "uid=adam,ou=users,dc=example,dc=com"</pre></div><p>The highlighted portion above is the LDIF information to be modified. The value of the <code class="literal">userPassword</code> attribute was set to <code class="literal">secret</code>—the same password used in the <code class="literal">ldappasswd</code> example. But this time, if we look at the entry, the <code class="literal">userPassword</code> value is not encrypted:</p><div><pre class="programlisting">dn: uid=adam,ou=Users,dc=example,dc=com
cn: Adam Smith
sn: Smith
uid: adam
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
userPassword:: c2VjcmV0</pre></div><p>The password is not hashed. Instead, it is just base64 encoded. The decoded value is <code class="literal">secret</code>.<a class="indexterm" id="id696"/>
</p><p>Including the <code class="literal">ppolicy_hash_cleartext</code> directive modifies this behavior. During modifications the <code class="literal">ppolicy</code> overlay checks to see if the modified attribute is <code class="literal">userPassword</code> and if the value is in cleartext. If the value is in cleartext then <code class="literal">ppolicy</code> hashes it.</p><div><div><h3 class="title"><a id="note118"/>Note</h3><p>In effect, turning on this feature causes SLAPD to perform in a nonstandard way, but for the sake of additional security.</p></div></div><p>For example, we can re-run the same <code class="literal">ldapmodify</code>:</p><div><pre class="programlisting">$ ldapmodify -x -W -D 'uid=matt,ou=users,dc=example,dc=com'
Enter LDAP Password: 
dn: uid=adam,ou=users,dc=example,dc=com
changetype: modify
replace: userPassword
userPassword: secret
modifying entry "uid=adam,ou=users,dc=example,dc=com"</pre></div><p>But this time, since <code class="literal">ppolicy_hash_cleartext</code> is on, the password is encrypted:</p><div><pre class="programlisting">dn: uid=adam,ou=Users,dc=example,dc=com
cn: Adam Smith
sn: Smith
uid: adam
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
userPassword:: e1NTSEF9Q0M3QUdSQUlPMG4vYy8rbVZiRE95bC9aYnpqNHcxd1Q=</pre></div><p>The <code class="literal">userPassword</code> value, decoded, is <code class="literal">{SSHA}CC7AGRAIO0n/c/+mVbDOyl/Zbzj4w1wT</code>. When hashing cleartext is enabled, LDAP modify operations (for the <code class="literal">userPassword</code> <a class="indexterm" id="id697"/>attribute only) behave more like LDAP password modify extended operations.</p><p>We've now configured the overlay completely. It will take a restart for SLAPD to pick up the changes to <code class="literal">slapd.conf</code> though. Now we are ready to test some of these features.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec89"/>Test the Overlay</h3></div></div></div><a class="indexterm" id="id698"/><p>As it is configured now, SLAPD will enforce policy controls on any entry with a <code class="literal">userPassword</code> attribute. Let's do a little testing to see how the password policy works.</p><div><div><h3 class="title"><a id="tip4654646518"/>Tip</h3><p><strong>The Administrator</strong></p><p>As I work through the examples I use the <code class="literal">uid=matt</code> account as a managing account. This account is allowed (by the ACLs) to perform administrative tasks. But it is also subject to the constraints of the <code class="literal">ppolicy</code> overlay.</p><p>The root DN account <code class="literal">(cn=manager,dc=example,dc=com on this server)</code> is treated differently. For example, the manager can set a password for a user without having to know the user's old password, even if <code class="literal">pwdSafeModify</code> is on.</p></div></div><p>First, let's see how the policy responds to some password changes. And let's start this examination with an <code class="literal">ldapmodify</code> attempt:</p><div><pre class="programlisting">$ ldapmodify -x -W -D 'uid=matt,ou=users,dc=example,dc=com'
Enter LDAP Password: 
dn: uid=adam,ou=users,dc=example,dc=com
changetype: modify
replace: userPassword
userPassword: new_password
modifying entry "uid=adam,ou=users,dc=example,dc=com"
ldap_modify: Insufficient access (50)
        additional info: Must supply old password to be changed as
        well as new one</pre></div><p>The modification attempt fails because the the <code class="literal">pwdSafeModify</code> is set to <code class="literal">TRUE</code>. There is no way to satisfy this requirement with <code class="literal">ldapmodify</code>. Instead we will have to use <code class="literal">ldappasswd</code> to change the password and we will have to set it to supply the server with the old password. This is what we will get:</p><div><pre class="programlisting">$ ldappasswd -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \
   -s new_password -a secret 'uid=adam,ou=users,dc=example,dc=com'
Enter LDAP Password: 
Result: Success (0)</pre></div><p>The <code class="literal">-s</code> flag is used to specify the new password, while the <code class="literal">-a</code> flag is used to provide the old password (and then <code class="literal">ldappasswd</code> prompts for the password of the DN that is binding too). With both of these set we meet the requirements of <code class="literal">pwdSafeModify</code>.</p><p>Since we have password checking turned on we should be able to test password length:</p><div><pre class="programlisting">$ ldappasswd -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \
  -s short -a new_password  'uid=adam,ou=users,dc=example,dc=com'
Enter LDAP Password: 
Result: Constraint violation (19)
Additional info: Password fails quality checking policy</pre></div><a class="indexterm" id="id699"/><p>In this case the new password, <code class="literal">short</code>, is (as the name implies) too short. The <code class="literal">pwdMinLength</code> of the policy states that the password must be seven characters long, and when the password quality checking function is performed (which it will since <code class="literal">pwdCheckQuality</code> is set to <code class="literal">1</code>), the server returns an error noting that it failed. Unfortunately for the user the message does not indicate the precise reason.</p><p>Next, let's look at password expiration warnings and password expirations. This will require some minor changes to our policy for the sake of testing—namely we will want to set the values for <code class="literal">pwdMaxAge</code> and <code class="literal">pwdExpireWarning</code> to lower values (values that would normally be too low for a production environment). Let's set the password to expire every ten minutes, and the expiration message to come up for the last nine minutes:</p><div><pre class="programlisting">$ ldapmodify -x -W -D 'uid=matt,ou=users,dc=example,dc=com'
Enter LDAP Password: 
dn: cn=Standard,ou=Policies,dc=example,dc=com
changetype: modify
replace: pwdMaxAge
pwdMaxAge: 600
-
replace: pwdExpireWarning
pwdExpireWarning: 540
modifying entry "cn=Standard,ou=Policies,dc=example,dc=com"</pre></div><p>Now, when <code class="literal">uid=adam</code> binds, the following message is logged in the LDAP log:</p><div><pre class="programlisting">ppolicy_bind: Setting warning for password expiry for 
              uid=adam,ou=users,dc=example,dc=com = 536 seconds</pre></div><p>Unfortunately, no message is sent to the client so the user does not see the message. This may be due to the fact that the draft specification doesn't require that the messages be sent to the client. Expiry warnings then, are useful mainly to administrators.</p><p>After ten minutes the <code class="literal">userPassword</code> value will be past the expiration point and, the next time the user logs in, SLAPD will mark the password as expired. Again, the user gets no explicit warning of this fact. An entry in the log file indicates the expiration of the account:</p><div><pre class="programlisting">ppolicy_bind: Entry uid=adam,ou=Users,dc=example,dc=com 
              has an expired password: 3 grace logins</pre></div><p>But in addition to this log entry, a new operational attribute is added to the user's record. The <code class="literal">pwdGraceUseTime</code> attribute is added to the user's record, and the time stamp there indicates the last time the user performed a bind operation:</p><div><pre class="programlisting">$ ldapsearch -LL -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \
 '(uid=adam)' pwdGraceUseTime
Enter LDAP Password: 
version: 1
<a class="indexterm" id="id700"/>
dn: uid=adam,ou=Users,dc=example,dc=com
pwdGraceUseTime: 20070121172107Z</pre></div><p>Each time a DN with an expired <code class="literal">userPassword</code> binds to the directory, a new value is added to the <code class="literal">pwdGraceUseTime</code> attribute. So after <code class="literal">uid=adam</code> has performed three binds after the password expiration date, the user's record will contain three <code class="literal">pwdGraceUseTime</code> attribute values:</p><div><pre class="programlisting">$ ldapsearch -LL -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \
 '(uid=adam)' pwdGraceUseTime
Enter LDAP Password: 
version: 1

dn: uid=adam,ou=Users,dc=example,dc=com
pwdGraceUseTime: 20070121172107Z
pwdGraceUseTime: 20070121173638Z
pwdGraceUseTime: 20070121174603Z</pre></div><p>After the number of <code class="literal">pwdGraceUseTime</code> values reaches the number in the <code class="literal">pwdGraceAuthNLimit</code> attribute of the policy, the account will be treated as locked, and that DN (<code class="literal">uid=adam</code>, in this case) will not be allowed to bind anymore. If <code class="literal">uid=adam</code> attempts to bind he will get an error message:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'uid=adam,ou=users,dc=example,dc=com' \
 '(uid=adam)'
Enter LDAP Password: 
ldap_bind: Invalid credentials (49)</pre></div><p>Furthermore, a message is added to the log noting the problem:</p><div><pre class="programlisting">ppolicy_bind: Entry uid=adam,ou=Users,dc=example,dc=com 
              has an expired password: 0 grace logins</pre></div><p>At this point an administrator will have to take steps to enable the account again. <a class="indexterm" id="id701"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec90"/>Password Policy Operational Attributes</h3></div></div></div><a class="indexterm" id="id702"/><p>In the previous section we tested several different features of the password policy. Now we will look at performing administration operations on accounts.</p><p>The <code class="literal">ppolicy</code> overlay stores information about a user's adherence to a password policy in that user's record. The information is stored in operational attributes.</p><p>Unlike regular attributes, operational attributes are not returned to clients unless the client explicitly requests them (either by name, or with the special plus (<code class="literal">+</code>) attribute specifier, which matches any operational attribute). And SLAPD can prevent clients from being able to modify operational attributes.</p><p>To begin we will look at an example of what happens when password lockout (<code class="literal">pwdLockout</code>) is turned on, and an account gets locked out. The <code class="literal">ppolicy</code> overlay uses operational attributes to store information about failures and lockouts.</p><p>In our policy, when a user fails to authenticate correctly three times in a row (according to <code class="literal">pwdMaxFailure</code>), they will be locked out of their account for some period of time (determined by <code class="literal">pwdLockoutDuration</code>).</p><p>One of the other users in our directory is <code class="literal">uid=dave,ou=users,dc=example,dc=com</code>. This user has failed to authenticate three times. The next time the user attempts to authenticate, even if he uses the right password, he will be disallowed from binding:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'uid=dave,ou=users,dc=example,dc=com'\
   '(uid=dave)'
Enter LDAP Password: 
ldap_bind: Invalid credentials (49)</pre></div><p>A few operational attributes in that user's record indicate what the problem is:</p><div><pre class="programlisting">$ ldapsearch -LL -x -W -D 'uid=matt,ou=users,dc=example,dc=com' \
   '(uid=dave)' +
Enter LDAP Password: 
version: 1

dn: uid=dave,ou=Users,dc=example,dc=com
structuralObjectClass: inetOrgPerson
entryUUID: efbf8838-c734-102a-935c-57e457da105f
creatorsName: cn=Manager,dc=example,dc=com
createTimestamp: 20060823205147Z
pwdChangedTime: 20070121180110Z
<strong>pwdFailureTime: 20070121180139Z</strong>
<strong>pwdFailureTime: 20070121180140Z</strong>
<strong>pwdFailureTime: 20070121180142Z</strong>
<strong>pwdAccountLockedTime: 20070121180142Z</strong>
entryCSN: 20070121180142Z#000000#00#000000
modifiersName: cn=Manager,dc=example,dc=com
modifyTimestamp: 20070121180142Z
entryDN: uid=dave,ou=Users,dc=example,dc=com
subschemaSubentry: cn=Subschema
hasSubordinates: TRUE</pre></div><p>Note that the <code class="literal">ldapsearch</code> in the example is for all of (and only) the operational attributes for entries that match the filter—that's what the plus sign (<code class="literal">+</code>) does.</p><p>The highlighted lines show the attributes in which we are interested: <code class="literal">pwdFailureTime</code> and <code class="literal">pwdAccountLockedTime</code>.<a class="indexterm" id="id703"/>
</p><p>The <code class="literal">pwdFailureTime</code> operational attribute has a timestamp for every time the user failed a login. When a user has a successful login, the values of <code class="literal">pwdFailureTime</code> are cleared, so having three values indicates that three logins in a row have failed.</p><p>The <code class="literal">pwdAccountLockedTime</code> indicates what time the password was locked. According to our configuration, the lockout should only last for twenty minutes, after which the user will be allowed to try again.</p><p>If the user succeeds the <code class="literal">pwdFailureTime</code> and <code class="literal">pwdAccountLockedTime</code> attributes will be removed from the user's record:</p><div><pre class="programlisting">$ ldapsearch -LL -x -W -D 'uid=matt,ou=users,dc=example,dc=com' '(uid=dave)' +
Enter LDAP Password: 
version: 1

dn: uid=dave,ou=Users,dc=example,dc=com
structuralObjectClass: inetOrgPerson
entryUUID: efbf8838-c734-102a-935c-57e457da105f
creatorsName: cn=Manager,dc=example,dc=com
createTimestamp: 20060823205147Z
pwdChangedTime: 20070121180110Z
entryCSN: 20070121182203Z#000000#00#000000
modifiersName: cn=Manager,dc=example,dc=com
modifyTimestamp: 20070121182203Z
entryDN: uid=dave,ou=Users,dc=example,dc=com
subschemaSubentry: cn=Subschema
hasSubordinates: TRUE</pre></div><p>In such cases administrators do not have to make any special changes to a user's entry. But what if the user gets locked out? This can happen if <code class="literal">pwdLockDuration</code> is set to <code class="literal">0</code> and the user fails to login too many times. It can also happen, as we saw in the example, if the user's password has expired and the user has exhausted the allowed grace logins.</p><p>Once the account has been locked, the user will not even be allowed to change his or her password. That means that the manager will need to intervene on the user's behalf and change the password using <code class="literal">ldappasswd</code>, <code class="literal">ldapmodify</code>, or another similar tool.</p><p>In rare cases, it may be desirable to modify the operational attributes directly. For example, <code class="literal">pwdAccountLockedTime</code>, <code class="literal">pwdReset</code>, and <code class="literal">pwdPolicySubentry</code> can be modified by the manager: </p><div><pre class="programlisting">$ ldapmodify -x -W -D 'cn=manager,dc=example,dc=com'
Enter LDAP Password: 

dn: uid=adam,ou=users,dc=example,dc=com
changetype: modify
add: pwdReset
pwdReset: TRUE

modifying entry "uid=adam,ou=users,dc=example,dc=com"</pre></div><p>In this example, the <code class="literal">pwdReset</code> flag for the <code class="literal">uid=adam</code> account was set to <code class="literal">TRUE</code>. This will require the user to change the password the next time a bind is performed.</p><p>But SLAPD may not allow the other operational attributes to be modified by the standard LDAP modification. This is because the <code class="literal">ppolicy</code> schema sets the <code class="literal">NO-USER-MODIFICATION</code> flag on these schema definitions.</p><p>Can these operational attributes ever be modified? Using a special control, the <strong>Relax Rules control</strong> (formerly called ManageDIT), managers can change the values of operational parameters that usually do not allow such changes. However, the Relax Rules control is not yet officially released and is not enabled by default in OpenLDAP. We would have to build the development version of OpenLDAP to enable the control.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec91"/>Summary of ppolicy Operational Attributes</h3></div></div></div><p>We have looked at a few more operational attributes that <code class="literal">ppolicy</code> can attach to a record used for bindng. Here's a list of all of the possible attributes along with a brief description of each:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pwdChangedTime</code>: This contains a timestamp indicating when the password was last changed. There can only be one value for this attribute. Passwords in entries that do not have this attribute will never expire.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdAccountLockedTime</code>: This attribute is added to an entry when the entry is locked. It contains a timestamp indicating at what time SLAPD marked the account as locked. We saw this used when a user failed to authenticate too many times in a row.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdFailureTime</code>: A <code class="literal">pwdFailureTime</code> attribute value is added to a record every time a user tries to bind, but fails to supply the right password. A successful login clears all <code class="literal">pwdFailureTime</code> attributes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdGraceUseTime</code>: If a user's account has expired, and the policy allows grace logins, a new <code class="literal">pwdGraceUseTime</code> value will be added every time the user logs in with an expired password. Resetting the password clears all <code class="literal">pwdGraceUseTime</code> values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdHistory</code>: If password history tracking is turned on then every time a user changes passwords, the old password is stored in a <code class="literal">pwdHistory</code> attribute value. Only the number of password specified in the policy are retained in the history</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdPolicySubentry</code>: This attribute, which allows only one value, takes the DN of the password policy that this record should use. If this attribute is not found, SLAPD uses the default policy (as specified by the <code class="literal">ppolicy_default</code> directive in <code class="literal">slapd.conf</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">pwdReset</code>: This attribute takes a boolean value. When a manager changes the password the flag is set to <code class="literal">TRUE</code>. If the policy also has <code class="literal">pwdMustChange</code> set to <code class="literal">TRUE</code> then the user will have to change her or his password on the next bind (using <code class="literal">ldappasswd</code>).</li></ul></div><p>At this point we are done working with the Password Policy overlay. Next we will move on to create our own schema.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Creating a Schema</h1></div></div></div><a class="indexterm" id="id704"/><p>Up to this point we have taken an in-depth look at schema definitions and then implemented a few overlays that made use of custom schemas. By now you should be comfortable working with and reading schemas. Here we are going to create our own schema.</p><p>Our goal in this section is to create a small schema for adding blog information to our directory. We want to be able to store a record in the directory to represent a blog, and also link existing entries to these blogs, indicating, for example, that a particular user maintains a particular blog.</p><p>To do this we are going to add two object classes—one structural and one auxiliary—and a handful of new attributes. The structural object class, <code class="literal">blog</code>, will describe an individual blog. It will contain the necessary attributes to describe a blog.</p><p>The auxiliary class <code class="literal">blogOwner</code>, will be used to add blog ownership information to a particular entry. Since the information about the blog will be stored in a <code class="literal">blog</code> entry, the <code class="literal">blogOwner</code> object class will only need one attribute that can be used to point to the appropriate <code class="literal">blog</code> entry.</p><p>The first thing we will do is walk through the process of obtaining an OID. Then we will create our object classes. After the object classes are created we will define our new attributes. Finally, we will try out our new schema.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Getting an OID</h2></div></div></div><a class="indexterm" id="id705"/><p>As we have seen so far the OID (Object Identifier) plays an important role in defining a schema.</p><p>An OID is a sequence of integers separated by dots (<code class="literal">.</code>). But OIDs are not arbitrary combinations of digits. They are structured to represent the pedigree of an object. As we will use them here, for creating a new schema, we will treat the OID as being composed of three parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The base OID</li><li class="listitem" style="list-style-type: disc">The type number</li><li class="listitem" style="list-style-type: disc">The item number </li></ul></div><p>The base part of an OID number is assigned by a naming authority. We will get ours from the <strong>Internet Assigned Numbers Authority</strong> (<strong>IANA</strong>).</p><div><div><h3 class="title"><a id="note119"/>Note</h3><p>
<strong>IANA</strong> is not the only naming authority. Each country may have its own registry. For instance, in the United States the <strong>American National Standards Institute (ANSI)</strong> also has a registry.</p></div></div><p>IANA maintains a registry of OIDs for private enterprises. It allocates numbers free of charge and all that is necessary is a one-time registration. However, IANA only gives one number to each enterprise so, if your organization has one already, you should use the existing one. You can view the registry at <a class="ulink" href="http://www.iana.org/assignments/enterprise-numbers">http://www.iana.org/assignments/enterprise-numbers</a>.</p><p>To obtain a number go to <a class="ulink" href="http://iana.org/cgi-bin/enterprise.pl">http://iana.org/cgi-bin/enterprise.pl</a> and complete the form there. You will then be assigned an OID looking something like this: 1.3.6.1.4.1.?, where the question mark is replaced with an integer. This OID serves as the basis for the OIDs we use when creating schemas. By appending your own series of digits and dots to this string you can create your own OID numbers, and as long as you take care to keep your OIDs unique within your own domain, you can assume that these OIDs are also globally unique (for you are the only one with the exact base OID).</p><div><div><h3 class="title"><a id="note120"/>Note</h3><p>In these examples I am using the OID registered to me. These OIDs may be used to replicate the examples herein, but do not use my OID to create your own schemas. The practice of using someone else's OID is called <strong>OID hijacking</strong>, and is frowned upon because it compromises the assumption that OIDs are globally unique.</p></div></div><p>While this series of digits has some semantic meaning (it means, roughly, that the owner is a private enterprise operating within IANA's namespace), there are no constraints on how you decide to structure your OIDs. You could, for example, just append a new set of random digits to the base OID each time you needed to create a new OID:</p><div><pre class="programlisting">1.3.6.1.4.1.8254.78.45146762
1.3.6.1.4.1.8254.57.483729598</pre></div><p>But it is often more manageable to come up with some semantic scheme for organization. A version derived from the OpenLDAP foundation's scheme is recommended. From the base OID, create a segment to be used just for LDAP OIDs:</p><div><pre class="programlisting">1.3.6.1.4.1.8254.1021</pre></div><p>Now we have just one portion of the namespace that will be used only for LDAP OIDs. From here we will use a simple subcategory identifier. Starting with the OID arc 1.3.6.1.4.1.8254.1021, we will create OIDs of the form:</p><div><pre class="programlisting">1.3.6.1.4.1.8254.1021.x.y</pre></div><p>Where <code class="literal">x</code> indicates the type of object and <code class="literal">y</code> indicates the specific object we are identifying. The OpenLDAP Foundation uses the following types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">LDAP syntaxes (<code class="literal">1</code>)<a class="indexterm" id="id706"/></li><li class="listitem" style="list-style-type: disc">Matching rules (<code class="literal">2</code>)</li><li class="listitem" style="list-style-type: disc">Attribute types (<code class="literal">3</code>)</li><li class="listitem" style="list-style-type: disc">Object classes (<code class="literal">4</code>)</li><li class="listitem" style="list-style-type: disc">Supported features (<code class="literal">5</code>)</li><li class="listitem" style="list-style-type: disc">Protocol mechanisms (<code class="literal">9</code>)</li><li class="listitem" style="list-style-type: disc">Controls (<code class="literal">10</code>)</li><li class="listitem" style="list-style-type: disc">Extended operations (<code class="literal">11</code>)</li></ul></div><p>We are only going to create object classes and attributes, so the value of <code class="literal">x</code> for our classes will be <code class="literal">3</code> for OIDs attached to attributes and <code class="literal">4</code> for OIDs attached to object classes.</p><p>For the <code class="literal">y</code> value, we will just start with the digit <code class="literal">1</code> and increment each time we define a new object of that type. For example, our first object class will have the OID:</p><div><pre class="programlisting">1.3.6.1.4.1.8254.1021.4.1</pre></div><p>And for our second object class we will just increment the last value from <code class="literal">1</code> to <code class="literal">2</code>:</p><div><pre class="programlisting">1.3.6.1.4.1.8254.1021.4.2</pre></div><p>Again, this is just one convention and different organizations use different conventions. While I advocate this convention you are free to choose another if you find that it is better for your needs.</p><p>There are two things to keep in mind though. First, you need to ensure that the OIDs are unique across your arc. That means you should maintain a registry of them in a place accessible to all people in your organization who work with the OIDs. Second, adding meaning to the numbers can provide tremendous utility, as it can help you recall or derive what an otherwise arbitrary string of numbers represents.</p><p>Now we are ready to begin creating our schema.<a class="indexterm" id="id707"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec85"/>Giving Our OID a Name</h2></div></div></div><a class="indexterm" id="id708"/><p>Our schema definitions are all going in a file called <code class="literal">blog.schema</code>, which we will later reference in an <code class="literal">include</code> statement in <code class="literal">slapd.conf</code>.</p><p>Most usually once the base OID for LDAP objects is defined, it is convenient to use the <code class="literal">objectidentifier</code> directive in <code class="literal">slapd.conf</code> to make the OIDs more readable, and make the process of creating schema definitions less error prone.</p><p>We can do this in the first few lines of our schema file:</p><div><pre class="programlisting">objectidentifier blogSchema 1.3.6.1.4.1.8254.1021
objectidentifier blogAttrs blogSchema:3
objectidentifier blogOCs blogSchema:4</pre></div><p>The first line maps the name <code class="literal">blogSchema</code> onto the OID <code class="literal">1.3.6.1.4.1.8254.1021</code>. Now we can refer to that long OID as <code class="literal">blogSchema</code>, which is much easier to remember.</p><p>The second and third <code class="literal">objectidentifier</code> directives add a few more aliases. The second one sets the name <code class="literal">blogAttrs</code> refer to the OID <code class="literal">blogSchema:3</code> (which is <code class="literal">1.3.6.1.4.1.8254.1021.3</code>). Thus, when we define attributes we can use the shortcut <code class="literal">blogAttrs:1</code> instead of typing the whole thing out as <code class="literal">1.3.6.1.4.1.8254.1021.3.1</code>.</p><p>Similarly, <code class="literal">blogOCs</code> alias (short for "blog object classes") can be used to refer to the <code class="literal">1.3.6.1.4.1.8254.1021.4</code> arc.</p><p>With this mechanism in place we have implemented the organizational strategy explained in the previous section, and our OID naming from here on should be a simple matter of incrementing the last integer of an OID.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Creating Object Classes</h2></div></div></div><a class="indexterm" id="id709"/><p>We will be starting with our object classes, and then use these defined object classes to guide the creation of our attributes. This is typically the way creation of schemas is done, but it does have one counter-intuitive result: object classes must be defined after the attributes that they contain. In effect then, we are jumping to the end of our schema file to add object classes, and will later add attribute definitions between the object identifiers and the object classes.</p><p>The first object class to describe is the <code class="literal">blog</code> class. This object class will define the attributes necessary to define a blog. For our purposes we are going to create a very simple object class, though there are many more attributes that could be attached.</p><p>We want the class to have the following attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">blogTitle</code>: The title of the blog</li><li class="listitem" style="list-style-type: disc"><code class="literal">blogUrl</code>: The URL (Uniform Resource Locater) of the main page for the blog</li><li class="listitem" style="list-style-type: disc"><code class="literal">blogFeedUrl</code>: The URL for the RSS or Atom feed of the URL</li><li class="listitem" style="list-style-type: disc"><code class="literal">description</code>: A brief text description of the blog</li></ul></div><p>Of these, the <code class="literal">blogUrl</code> and <code class="literal">blogTitle</code> attributes should be required. <code class="literal">blogUrl</code> is an essential component of a blog. Without this, an entry describing a blog would be of little value. And the <code class="literal">blogTitle</code> attribute is necessary to give us a naming component to use in DNs.</p><p>For the sake of clarity of meaning, here we have prepended the <code class="literal">blog</code> string to any new attributes so that they can be immediately distinguished from other similar attributes.</p><div><div><h3 class="title"><a id="tip664554"/>Tip</h3><p><strong>Naming Object Classes and Attributes</strong></p><p>If your object classes or attributes are designed for internal use, or for application-specific use, it is advised that the name of the organization or application be prepended to the attribute and object class names. That helps to make the purpose of the defined items explicit.</p></div></div><p>Fortunately for us, <code class="literal">description</code> is already defined. While we could use the <code class="literal">title</code> attribute, as defined in <code class="literal">core.schema</code>, this could introduce confusion, as that attribute is used to refer to the title of a person in an organization. To avoid any confusion then, we will avoid reusing that attribute.</p><p>Already we have said that this object class is going to be structural, and we have a scheme for determining an OID number. There are no similar object classes so we will create a class whose superior is <code class="literal">top</code>. We now have all the information we need to create our schema definition:</p><div><pre class="programlisting">objectclass 
  (
   blogOCs:1
   NAME 'blog'
   DESC 'Describes an online blog accessible by URL.'
   SUP top
   STRUCTURAL
   MUST ( blogUrl $ blogTitle )
   MAY ( blogFeedUrl $ description )
  )</pre></div><p>In the OID field we used the object identifier we assigned in the last section. And we started with <code class="literal">1</code>, our first object class.<a class="indexterm" id="id710"/>
</p><p>The <code class="literal">blogOwner</code> object class is to be marked auxiliary so that we can attach it to a variety of different entries, regardless of the structural object class. For example, regardless of whether the blog is a corporate blog, or is maintained by an organizational unit, or is simply an individual's, we can add this object class to the desired entry.</p><p>We want to use the <code class="literal">blogOwner</code> object class to insert a pointer from an entry to the appropriate <code class="literal">blog</code> entry in the directory information tree. Since that is all we need, a single attribute will suffice for these purposes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">blogDN</code>: The DN describing the <code class="literal">blog</code> that this entry is affiliated with.</li></ul></div><p>This object class then, turns out to be even simpler than the previous one:</p><div><pre class="programlisting">objectclass 
  (
   blogOCs:2
   NAME 'blogOwner'
   DESC 'Indicates that this entry is responsible for a blog.'
   AUXILIARY
   MUST ( blogDN )
  )</pre></div><p>This OID number differs from the first only in that the last value has been incremented. This follows the scheme we defined in the previous section.</p><p>Since this is an auxiliary object class, there is no need for a superior. And since we want this class to be used to point to a <code class="literal">blog</code> entry elsewhere in the directory, the <code class="literal">blogDN</code> attribute is required.</p><p>Now we have our two object classes. In creating them we have referred to four attributes that currently do not exist. It is time to create them.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Creating Attributes</h2></div></div></div><a class="indexterm" id="id711"/><p>As we created the <code class="literal">blog</code> and <code class="literal">blogOwner</code> object classes, we tentatively defined (in our text) four attributes: <code class="literal">blogTitle</code>, <code class="literal">blogUrl</code>, <code class="literal">blogFeedUrl</code>, and <code class="literal">blogDN</code>. Now we will define each of these, beginning with <code class="literal">blogTitle</code>.</p><p>In order to define our attribute we want to decide on the syntax of the attribute and also the matching rules that SLAPD will use for this attribute. The <code class="literal">blogTitle</code> will contain values that are strings of text data. So the syntax we want is one that supports this. The <strong>Directory String syntax</strong>, defined in RFC 4517, is intended for just such a purpose. And <a class="indexterm" id="id712"/>it supports internationalization, storing characters in UTF-8.</p><p>When performing searches, we do not want the case of the text (upper or lower) to make a difference. In other words, we want "My Blog" and "my blog" to be treated as matches. So we need to find the matching rule that will best support this. There are over three dozen matching rules supported in OpenLDAP (you can see a list by searching the <code class="literal">cn=Subschema</code> entry). We want to implement string-based equality and substring matching on our <code class="literal">blogTitle</code> attribute, so the pair of matching rules we will want to use are <code class="literal">caseIgnoreMatch</code> and <code class="literal">caseIgnoreSubstringsMatch</code>.</p><p>Now, we have all of the information necessary for creating a new attribute type:</p><div><pre class="programlisting">attributetype 
  (
   blogAttrs:1
   NAME 'blogTitle'
   DESC 'Title of a blog.'
   EQUALITY caseIgnoreMatch
   SUBSTR caseIgnoreSubstringsMatch
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.15{256}
  )</pre></div><p>The OID field is <code class="literal">blogAttrs:1</code>, indicating that this is our first attribute.</p><p>The LDAP syntax OID is the OID for a <strong>Directory String</strong>. At the end of the OID, the <code class="literal">{256}</code> suggests that the maximum length of the title be constrained to 256 characters.</p><div><div><h3 class="title"><a id="note121"/>Note</h3><p>The characters are in UTF-8, so this might take up as much as 512 bytes of space if each of the 256 characters is two bytes.</p></div></div><p>The next two attributes, <code class="literal">blogUrl</code> and <code class="literal">blogFeedUrl</code>, are similar and we can take advantage of that as we define them.</p><p>The first thing to examine is the LDAP syntax of these attributes. Unlike <code class="literal">blogTitle</code>, we do not want the values of <code class="literal">blogUrl</code> and <code class="literal">blogFeedUrl</code> to be in the Directory String syntax, because (according to RFC 3986 and the previous URL standards) URLs are to use a subset of the ASCII character set.</p><div><div><h3 class="title"><a id="note122"/>Note</h3><p>For more on URLs and internationalization, see the W3C's <em>Web</em> <em>Naming</em> <em>and</em> <em>Addressing</em> page: <a class="ulink" href="http://www.w3.org/Addressing/">http://www.w3.org/Addressing/</a>. Links to information as well as pertinent RFCs can be found there.</p></div></div><p>Instead of using Directory String syntax, we should use the <strong>IA5 String syntax</strong> which describes an extended ASCII character set. The OID for this syntax is <code class="literal">1.3.6.1.4.1.1466.115.121.1.26</code>.</p><p>Similarly, when we specify matching rules, we want to use the IA5 matching rules. And since URLs are case-sensitive, we want exact matches. We do not want the case to be ignored. So for matching rules we want <code class="literal">caseExactIA5Match</code> and <code class="literal">caseExactIA5SubstringsMatch</code>.</p><p>Now we can define both attributes:</p><div><pre class="programlisting">attributetype 
  (<a class="indexterm" id="id713"/>
   blogAttrs:2
   NAME 'blogUrl'
   DESC 'Uniform Resource Locator (URL) for a blog.'
   EQUALITY caseExactIA5Match
   SUBSTR caseExactIA5SubstringsMatch
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.26{512}
  )


attributetype 
  (
   blogAttrs:3
   NAME 'blogFeedUrl'
   DESC 'URL to an XML feed for a blog.'
   SUP blogUrl
  )</pre></div><p>Since the <code class="literal">blogUrl</code> field contains the matching rules and syntax that <code class="literal">blogFeedUrl</code> uses, and since there is an obvious similarity in usage between the two, it makes sense to treat <code class="literal">blogUrl</code> as the supertype of <code class="literal">blogFeedUrl</code>. So, <code class="literal">blogFeedUrl</code> inherits the LDAP syntax and matching rules from <code class="literal">blogUrl</code>.</p><p>Finally, we need to define our <code class="literal">blogDN</code> field, which will hold a DN. There is syntax and specific matching rules for DNs, and we will use those. The <strong>Distinguished Name syntax</strong>, defined with the OID <code class="literal">1.3.6.1.4.1.1466.115.121.1.12</code>, is used for values that are DNs. And the <code class="literal">distinguishedNameMatch</code> matching rule is used for performing exact matches on DNs. There are no substring or ordering matches for DNs.</p><p>Our last attribute then, looks like this:</p><div><pre class="programlisting">attributetype 
  (
   blogAttrs:4
   NAME 'blogDN'
   DESC 'DN of a blog entry in the directory.'
   EQUALITY distinguishedNameMatch
   SYNTAX 1.3.6.1.4.1.1466.115.121.1.12 
  )</pre></div><p>Now we have our entire schema defined. We are ready to test it.<a class="indexterm" id="id714"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Loading the New Schema</h2></div></div></div><a class="indexterm" id="id715"/><a class="indexterm" id="id716"/><p>As with all other schemas, in order to load this schema, we must include it in <code class="literal">slapd.conf</code>.</p><div><pre class="programlisting">include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema
include /etc/ldap/schema/ppolicy.schema
<strong>include /etc/ldap/schema/blog.schema</strong>
</pre></div><p>It is assumed here that <code class="literal">blog.schema</code> is located in the <code class="literal">/etc/ldap/schema</code> directory (which is a good place to put the schema). If you choose to locate the schema elsewhere, adjust the path accordingly.</p><p>The highlighted line in the code is the only addition necessary (the rest should be there already). Note that our schema is only dependent on <code class="literal">core.schema</code>. The other three are not necessary to make our schema work.</p><p>Restarting SLAPD will load the schema.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec92"/>Troubleshooting Schema Loading</h3></div></div></div><a class="indexterm" id="id717"/><a class="indexterm" id="id718"/><p>If there is an error in the schema SLAPD will not start, failing instead with an elaborate error message like this:</p><div><pre class="programlisting">/etc/schema/blog.schema: line 89: Unexpected token before 
                         MUST ( blogDN ) )
ObjectClassDescription = "(" whsp
   numericoid whsp  ; ObjectClass identifier
   [ "NAME" qdescrs ]
   [ "DESC" qdstring ]
   [ "OBSOLETE" whsp ]
   [ "SUP" oids ]  ; Superior ObjectClasses
   [ ( "ABSTRACT" / "STRUCTURAL" / "AUXILIARY" ) whsp ]
                   ; default structural
   [ "MUST" oids ]  ; AttributeTypes
   [ "MAY" oids ]  ; AttributeTypes
   whsp ")"
slapd stopped.
connections_destroy: nothing to destroy.</pre></div><p>This error was triggered when we misspelled <code class="literal">AUXILIARY</code>—a cause not easily divined by this error message. But it illustrates the fact that the process of writing a schema definition takes patience and precision.</p><p>The best strategy for dealing with such failures is to carefully read the errant schema definition over, hunting for errors. Sometimes simplifying a definition can help eliminate other possible errors too. Finally, checking the definition against the specification in RFC 4512 can help you spot any nondescript syntactical errors.<a class="indexterm" id="id719"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec89"/>A New Record</h2></div></div></div><p>Now we can use <code class="literal">ldapadd</code> to add a new <code class="literal">blog</code> entry to our directory information tree. We will add information about the official corporate blog of Example.Com:</p><div><pre class="programlisting">$ ldapadd -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

<strong>dn: blogTitle=Example.Com News,dc=example,dc=com</strong>
<strong>blogTitle: Example.Com News</strong>
<strong>blogUrl: http://example.com/blogs/main</strong>
<strong>blogFeedUrl: http://example.com/rss/main</strong>
<strong>description: The Official Example.Com Blog.</strong>
<strong>objectclass: blog</strong>

adding new entry "blogTitle=Example.Com News,dc=example,dc=com"</pre></div><p>The highlighted portion above is the new entry we are adding. The last line, returned by SLAPD, indicates that the entry has been added successfully.</p><p>Our user <code class="literal">uid=barbara</code> is responsible for maintaining this blog so we can indicate this relationship by adding the <code class="literal">blogOwner</code> object class and <code class="literal">blogDN</code> attribute to her record with <code class="literal">ldapmodify</code>:</p><div><pre class="programlisting">$ ldapmodify -U matt
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

dn: uid=barbara,ou=users,dc=example,dc=com
changetype: modify
add: objectclass
objectclass: blogOwner
-
add: blogDN
blogDN:  blogTitle=Example.Com News,dc=example,dc=com

modifying entry "uid=barbara,ou=users,dc=example,dc=com"</pre></div><p>The record for <code class="literal">uid=barbara</code> now looks like this:</p><div><pre class="programlisting">dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: labeledURIObject
<strong>objectClass: blogOwner</strong>
<strong>blogDN: blogTitle=Example.Com News,dc=example,dc=com</strong>
</pre></div><p>We have just successfully created and implemented a new schema including new attributes and object classes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Summary</h1></div></div></div><p>The focus of this chapter has been the schema. We began with a theoretical look at what makes up a schema and how schemas are defined. Then we looked at the organization of schemas in the directory, focusing on the different types of object class and how they work together to compose a hierarchical directory. From there we turned to more practical material. We looked at the <code class="literal">accesslog</code> and <code class="literal">ppolicy</code> overlays, each of which requires its own schema. Finally, we ended by creating our own custom schema, creating a pair of object classes, and a handful of attributes.</p><p>In the next chapter we will discuss working with multiple directories, focusing particluarly on directory replication, the process of keeping two or more directory servers synchronized with the same content.</p></div></body></html>