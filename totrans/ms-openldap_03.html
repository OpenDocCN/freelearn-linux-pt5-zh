<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using OpenLDAP</h1></div></div></div><a class="indexterm" id="id91"/><p>Now that we have a basic OpenLDAP server installed, configured, and running, it is time to turn our attention to using OpenLDAP. In this chapter we will be looking at what the various applications in the <strong>OpenLDAP suite</strong> do. In the process, we will discuss LDAP operations, create our initial directory tree, and use the OpenLDAP clients and utilities to interact with the directory server. As we do this we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The basic functional division of the OpenLDAP tools: daemons, clients, and utilities</li><li class="listitem" style="list-style-type: disc">The basic directory server operations</li><li class="listitem" style="list-style-type: disc">Building an initial directory tree in an LDIF file</li><li class="listitem" style="list-style-type: disc">Loading the data into the directory</li><li class="listitem" style="list-style-type: disc">Working with the directory records</li><li class="listitem" style="list-style-type: disc">Searching the directory</li><li class="listitem" style="list-style-type: disc">Setting passwords and authenticating against the directory</li></ul></div><p>Along the way, we will also see many new LDAP terms and concepts.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>A Brief Survey of the LDAP Suite</h1></div></div></div><a class="indexterm" id="id92"/><p>In the last chapter we saw that the OpenLDAP suite was composed of daemons, libraries, clients, and utilities.</p><p>In UNIX parlance, a daemon is a process that runs for long periods of time without user interaction. It is a process that runs in the background. A server is a type of daemon that answers requests from other applications (clients). There are two daemons in the OpenLDAP suite: the SLAPD daemon (server) and the SLURPD daemon. In the next section we will look at these two.</p><p>There are a host of utilities included with OpenLDAP too. Utilities are programs that assist in managing the directory but do not use the LDAP protocol. They do things like maintain indexes, dump the contents of the database, and assist with migrating records from one directory to another.</p><p>Clients, in contrast to utilities, are programs that connect to the directory server using the LDAP protocol and perform directory operations, such as searching for, adding, modifying, and deleting records from the directory.</p><p>We will look at all of the utilities and clients. But before we dive into that we will look at the daemons and some of the concepts involved in communication between LDAP clients and servers. This will give us the foundational knowledge for our work with the LDAP utilities and clients.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>LDAP from the Server Side</h1></div></div></div><a class="indexterm" id="id93"/><p>OpenLDAP includes two daemons: <strong>SLAPD</strong> and <strong>SLURPD</strong>. SLAPD is the main server, and we will examine its operation throughout this book. SLURPD is a special-purpose daemon used for replicating directories. While it is still in use, it is now deprecated in favor of a more robust replication mechanism. We will cover it only briefly in this book.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>SLAPD</h2></div></div></div><a class="indexterm" id="id94"/><a class="indexterm" id="id95"/><a class="indexterm" id="id96"/><p>The first, SLAPD, is the stand-alone LDAP daemon. It is the LDAP server. It listens for client requests and, when it receives a request, performs the requested operation and returns any necessary data. In the most common case a client will send a query message to the server. The SLAPD server will then look up the information and return the results. Let's consider an example (in conversational English):<a class="indexterm" id="id97"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">Client: Log in as user Bob with the password Password</li><li class="listitem" style="list-style-type: none">Server: Bob is now logged in</li><li class="listitem" style="list-style-type: none">Client: Bob wants all of the usernames of users whose email addresses start with 'm'</li><li class="listitem" style="list-style-type: none">Server: There are four users with email addresses that start with 'm'. The user IDs are: mattb, markd, melaniek, melindaq</li><li class="listitem" style="list-style-type: none">Client: Log Bob off</li><li class="listitem" style="list-style-type: none">Server: OK</li></ul></div><p>This example is very simplistic (and omits lots of the details of an LDAP transaction), but it should give you the main idea of what SLAPD does.</p><p>The SLAPD program is called, appropriately enough, <code class="literal">slapd</code>. It is located at <code class="literal">/usr/sbin</code> (if you compiled from source, it is in <code class="literal">/usr/local/libexec</code>). In the previous chapter we configured SLAPD using the <code class="literal">/etc/ldap/slapd.conf</code> configuration file.</p><p>The SLAPD server handles all client interactions, including authentication, processing ACLs, performing searches, and handling changes, additions, and deletions of the data. It also manages the databases that store LDAP content. All of the clients that we look at in this chapter interact directly with SLAPD. The utilities provide maintenance services for SLAPD, though they rarely directly interact with the SLAPD server (they tend to operate on files that the directory uses).</p><a class="indexterm" id="id98"/><p>Let's take a slightly more technical look at the simple LDAP exchange that we outlined here. We can break the exchange into two major parts: the authentication process (called <strong>binding</strong> in LDAP parlance) and the search process.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec09"/>The Binding Operation</h3></div></div></div><a class="indexterm" id="id99"/><p>The first thing that must happen is the client must authenticate to the server. Keep in mind that in order to interact with an LDAP server the client must provide two pieces of information: a DN and a password.</p><p>Typically, there are two different ways by which a client can authenticate to a server: through a Simple Bind, and through an SASL Bind. It is possible to write custom methods of binding, too, but that's a significant undertaking. Let's look at the way clients <a class="indexterm" id="id100"/>connect to LDAP using the <strong>Simple Bind</strong> method.</p><p>Typically, to authenticate a user, SLAPD looks up the DN (and the DN's <code class="literal">userPassword</code> attribute) in the directory and verifies the following:<a class="indexterm" id="id101"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">The supplied DN exists in the directory.</li><li class="listitem">The DN is allowed to connect under the present conditions (such as from the originating IP address, or with the currently-implemented security features).</li><li class="listitem">The password supplied matches the value of the DN's <code class="literal">userPassword</code> attribute.</li></ol></div><p>In our example scenario the user Bob wants to bind to the directory. For Bob to bind according to the outlined steps, the client would have to provide Bob's full DN, which might be something like <code class="literal">cn=Bob,dc=example,dc=net</code>. But, not all clients know the full DN of the user. Most applications require only a username and password, not a full DN. To solve this problem, LDAP servers support the idea of the <strong>Anonymous</strong> user.</p><p>When the LDAP server receives a bind request with an empty DN and an empty password field, the server treats the user as Anonymous. The Anonymous user can be granted or denied access to information in the directory based on the ACLs specified for SLAPD. Generally, the task of the Anonymous user is to get Bob's DN out of the directory and request that Bob be authenticated.</p><p>How does this happen? The client first connects to the server as Anonymous, then searches the directory for Bob's entry with a filter of something like this: <em>entries</em> <em>whose</em> <em>CN</em> <em>is</em> <em>"Bob"</em> <em>and</em> <em>who</em> <em>have</em> <em>the</em> <em>objectclass</em> <em>"organizationalPerson"</em>.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The actual LDAP filter for this request would look like this: <code class="literal">(&amp;(cn=Bob)(objectClass=oraganizationalPerson))</code>
</p></div></div><p>Assuming that the filter is specific enough, and the directory actually has an entry for Bob, then the server would then send the client one DN: <code class="literal">cn=Bob,dc=example,dc=net</code>. The client would then re-bind, this time as <code class="literal">cn=Bob,dc=example,dc=net</code> (and with Bob's password), rather than as Anonymous. <a class="indexterm" id="id102"/>
</p><p>In order for anonymous authentication to work, the ACLs will need to allow the Anonymous user to bind and attempt to perform authentication. The ACLs we added to <code class="literal">slapd.conf</code> in the previous chapter allowed the Anonymous user to request authentication services with the <code class="literal">userPassword</code> attribute.</p><p>In this chapter, we will use Simple Binding, though we will specify a full DN, rather than bind as Anonymous and search, and then rebind. Simple Bind sends the password from the client to the server. Without additional security (like SSL or TLS encryption), this <a class="indexterm" id="id103"/>makes the authentication process vulnerable to attacks. <strong>SASL (Simple Authentication and Security Layer) Binding</strong> provides another method of authenticating that relies on external security measures for added security. In Chapter 4, we will look at the authentication process in more detail, with particular emphasis on security.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec10"/>The Search Operation</h3></div></div></div><a class="indexterm" id="id104"/><p>In our example scenario, after Bob authenticates to the server he searches for all the email addresses that begin with the letter <em>m</em>. Let's examine that process in a little more detail.</p><p>In order to search the directory we need to know the following things:<a class="indexterm" id="id105"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Base DN</strong>: Where in the directory to start from</li><li class="listitem" style="list-style-type: disc"><strong>Scope</strong>: How deep in the tree to look</li><li class="listitem" style="list-style-type: disc"><strong>Attributes</strong>: What information we want retrieved</li><li class="listitem" style="list-style-type: disc"><strong>Filter</strong>: What to look for</li></ul></div><p>Let's look at what Bob wants to get out of the directory. Bob wants to get a list of all of the people in his organization, Example.Com, who have email addresses that begin with the letter <em>m</em>. From this information, we can construct a search.</p><p>First, Bob wants to know about everyone in the Example.Com organization. In the directory, this is everything under the Example.Com entry: <code class="literal">dc=example,dc=com</code>. Also, since we know that Bob wants all of the email addresses that begin with <em>m</em>, not just one layer down; we know that Bob wants to search the entire subtree under <code class="literal">dc=example,dc=com</code>. So we have:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Base DN</strong>: <code class="literal">dc=example,dc=com</code></li><li class="listitem" style="list-style-type: disc"><strong>Scope</strong>: Entire subtree</li></ul></div><p>Next, we want to know what attributes Bob wants the server to return. The DN will be automatically returned. Other than that, Bob is concerned only with the attribute that stores the email address. Email addresses are stored in the <code class="literal">mail</code> attribute. We could also grab any number of attributes, such as the user's name (<code class="literal">cn</code>) and telephone number (<code class="literal">telephoneNumber</code>). So we have:<a class="indexterm" id="id106"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Attributes</strong>: <code class="literal">mail</code>, <code class="literal">cn</code>, <code class="literal">telephoneNumber</code><div><div><h3 class="title"><a id="note09"/>Note</h3><p>
<strong>Attribute Descriptions</strong>
</p><a class="indexterm" id="id107"/><p>The attribute referred to by <code class="literal">mail</code> also has a second name: <code class="literal">rfc822Mailbox</code>. These two names are called <strong>attribute descriptions</strong> because they both describe a common attribute. Each attribute has at least one attribute description, but it is legal to have multiple descriptions (such as <code class="literal">cn</code> and <code class="literal">commonName</code>, or <code class="literal">dc</code> and <code class="literal">domainComponent</code>). When you have an attribute with more than one description it doesn't matter which description you use. All should return the same results.</p></div></div></li></ul></div><p>Finally, we need to create a filter from Bob's criteria. Bob wants all of the entries where the email address starts with the letter <em>m</em>.</p><p>Here is the search filter:</p><div><pre class="programlisting">(mail=m*)</pre></div><p>This simple filter is composed of four parts:<a class="indexterm" id="id108"/>
<a class="indexterm" id="id109"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="indexterm" id="id110"/>First, the filter is enclosed in parentheses. Parentheses are used for grouping elements within the filter. For any filter, the entire filter should always be enclosed in parentheses.</li><li class="listitem" style="list-style-type: disc">Second, the filter begins with an attribute description: <code class="literal">mail</code>.</li><li class="listitem" style="list-style-type: disc">Third is the matching rule. There are four matching rules: equality (<code class="literal">=</code>), approximate match (<code class="literal">~=</code>), greater than or equal to (<code class="literal">&gt;=</code>), and less than or equal to (<code class="literal">&lt;=</code>). How these are used (and whether they can be used) is determined to a large degree by the directory schema, which we will discuss at length in Chapter 6. In this case the filter performs string matching.</li><li class="listitem" style="list-style-type: disc">Finally, we have the assertion value—the string or pattern that we want results to match. In this case it is composed of the character <code class="literal">m</code> and the wildcard character (<code class="literal">*</code>). This indicates that the string must start with <code class="literal">m</code>, and can then have zero or more characters following it.<a class="indexterm" id="id111"/></li></ul></div><a class="indexterm" id="id112"/><a class="indexterm" id="id113"/><p>This type of search is called a <strong>substring search</strong>, because the filter provides only part of the string, and requests that the server respond with any entries that match the substring (according to the pattern supplied).</p><p>What if Bob also needed all of the users with email addresses that started with <code class="literal">n</code>? We could run two separate searches, or we could create a more elaborate filter:</p><div><pre class="programlisting">(|(mail=m*)(mail=n*))</pre></div><p>This filter is composed of two subfilters: <code class="literal">(mail=m*)</code> and <code class="literal">(mail=n*)</code>. The first matches only mail addresses that start with <em>m</em>, while the second matches only addresses that start with <em>n</em>. These two subfilters are disjoined using the pipe (<code class="literal">|</code>) symbol. That means that an OR operation will be performed, and the filter will match a record if the record matches either <code class="literal">(mail=m*)</code> or <code class="literal">(mail=n*)</code>.</p><p>The syntax may seem a little unusual at first, as the operator (the OR) comes before the two filters are listed.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>There are three logical operators that can be used in filters: AND (<code class="literal">&amp;</code>), OR (<code class="literal">|</code>), and NOT (<code class="literal">!</code>).<a class="indexterm" id="id114"/>
</p></div></div><p>Just to make things more interesting, let's say that Bob wants to restrict the list to only people whose offices have room numbers of 300 or above. We can simply add one more sub-filter to our list, and we will have the results that Bob is looking for:</p><div><pre class="programlisting">(&amp;(|(mail=m*)(mail=n*))(roomNumber&gt;=300))</pre></div><p>To visualize this a little better let's add some line breaks and spaces:</p><div><pre class="programlisting">(&amp;
  (|
    (mail = m*)
    (mail = n*)
  )
  (roomNumber &gt;= 300)
)</pre></div><p>Now it should be a little easier to see how this filter is interpreted. In the innermost level, mail addresses are considered matches if they start with <em>m</em> OR <em>n</em>. Now, these matches are only returned if they also have a room number greater than or equal to 300. They must match either <code class="literal">(mail=m*)</code> OR <code class="literal">(mail=n*)</code>, AND, in addition, must also have <code class="literal">(roomNumber &gt;= 300)</code>.</p><p>Once Bob performs the search, with the base DN, scope, attributes, and filter, he will receive a response from the server that will contain a list of records that look something like this:<a class="indexterm" id="id115"/>
</p><div><pre class="programlisting">dn:cn=Matt B,dc=example,dc=com
mail: mattb@example.com
cn: Matt B
cn: Matthew B
telephoneNumber: +1 555 555 55555

dn: cn=Melanie K,dc=example,dc=com
mail: melaniek@example.com
cn: Melanie K
elephoneNumber: +1 555 555 4444</pre></div><p>The search returns everything in appearing in the subtree below the DN <code class="literal">dc=example,dc=com</code> that matches our filter. The returned records only have the DN and the attributes that we specified: <code class="literal">mail</code>, <code class="literal">cn</code>, and <code class="literal">telephoneNumber</code>.</p><p>In our most complex filter, we used the <code class="literal">roomNumber</code> attribute. Why isn't it present in the records above? Even though it was used in the filter the attribute value would not be returned in the response unless we requested it.</p><p>Before going on, there is one last thing to mention about searching. During a search the entire request is checked against the list of access controls.</p><p>If an ACL specifies that Bob does not have access to the <code class="literal">telephoneNumber</code> attribute, then the search will return the same DNs but without the <code class="literal">telephoneNumber</code> attribute. Similarly, if an ACL denied Bob access to the records of certain people in the directory, then the server would send back the results for only those that Bob does have permission to see.</p><p>The server will not give Bob any indication that some information has been withheld because of an ACL.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec11"/>More Operations: Additions, Modifications, and Deletions</h3></div></div></div><p>In our illustration of Bob's search for email addresses we covered only binding and searching. Of course, LDAP supports adding, modifying, and deleting, as well. All three of these also require that the user first bind. And all three of these are also subject to ACL restrictions.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec01"/>The Addition Operation</h4></div></div></div><a class="indexterm" id="id116"/><a class="indexterm" id="id117"/><p>In an addition operation a new record is added to the server. In this case the client will have to provide a new (and unique) DN, and set of attribute/value pairs. The attribute/value pairs must include a list of object classes to which the entry belongs. For example, if the entry is going to be a new user with a user ID and an email account, then the modification would have to include at least three object class attribute/value pairs.</p><p>An entire record for a user to be added might look something like this:</p><div><pre class="programlisting">dn: uid=bjensen,dc=exaple,dc=com
cn: Barbara Jensen
mail: bjensen@example.com
uid: bjensen
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec02"/>The Modification Operation</h4></div></div></div><a class="indexterm" id="id118"/><a class="indexterm" id="id119"/><p>Modification acts on a particular record, specified by DN. Any number of changes can be done on a single record in one modification request.</p><p>For a particular record, a modification operation can add, replace, or remove attributes. And it can combine operations in the same request. That is, it can remove one attribute and replace another attribute in one request. Let's see these attributes:<a class="indexterm" id="id120"/>
</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An <strong>add</strong> request takes an attribute name and one or more values. It will add those values to the existing set of values for that attribute. For example, consider a record like this:<a class="indexterm" id="id121"/><div><pre class="programlisting">  dn: cn=Matt,dc=example,dc=com
  cn: Matt
  telephoneNumber: 1 555 555 1234
  telephoneNumber: 1 555 555 4321
  objectClass: person</pre></div><p>If we want to modify this record by adding <code class="literal">cn: Matthew</code>, the result will look like this:</p><div><pre class="programlisting">  dn: cn=Matt,dc=example,dc=com
  cn: Matt
  cn: Matthew
  telephoneNumber: 1 555 555 1234
  telephoneNumber: 1 555 555 4321
  objectClass: person</pre></div><p>Modification operations are processed in an "all or nothing" fashion. When multiple modifications are sent in one request, either they all succeed, or they all fail.</p></li><li class="listitem" style="list-style-type: disc"><a class="indexterm" id="id122"/>A <strong>replace</strong> request also takes an attribute and one or more values. But the list of values replaces the existing values. For example, if Matt relocated and his telephone number changed, then replacing with the new attribute <code class="literal">telephoneNumber</code>: <code class="literal">1 555 555 6543</code> would result in a record that looked like this:<div><pre class="programlisting">  dn: cn=Matt,dc=example,dc=com
  cn: Matt
  cn: Matthew
  telephoneNumber: 1 555 555 6543
  objectClass: person</pre></div><p>The new number is added and the old numbers are removed.</p></li><li class="listitem" style="list-style-type: disc">A <strong>delete</strong> <a class="indexterm" id="id123"/>request also takes an attribute and a list of values. It deletes only the values for an attribute that are specified in the list of values. For example, deletion of <code class="literal">cn: Matthew</code> would give us the following record:<div><pre class="programlisting">  dn: cn=Matt,dc=example,dc=com
  cn: Matt
  telephoneNumber: 1 555 555 6543
  objectClass: person</pre></div><p>Only the matching CN was removed. If, however, a delete request only specifies the attribute (with no values), then all instances of that attribute will be removed.</p></li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec03"/>The Delete Operation</h4></div></div></div><a class="indexterm" id="id124"/><a class="indexterm" id="id125"/><p>Finally, an entire LDAP record can be deleted. Like modifications, deletion operates on a particular record, the record's DN. During a delete operation, the entire record is removed from the directory—the DN and all attributes.</p><p>Only records that do not have children can be deleted from the directory. If an entry has children, the children must be removed from the directory (or relocated to another part of the tree) before the parent entry can be removed.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec12"/>Infrequent Operations</h3></div></div></div><p>There are a few operations that clients can call, but that tend to be used less than binding, searching, adding, modifying, and deleting. Three that we will look at just briefly are <strong>ModifyDN</strong>, <strong>Compare</strong>, and <strong>Extended Operation</strong>.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec04"/>The ModifyDN Operation</h4></div></div></div><a class="indexterm" id="id126"/><a class="indexterm" id="id127"/><p>ModifyDN is used in cases where the DN for a record must be changed. Generally, DNs should not be changed frequently as they are intended to be used as unique and stable locators within a directory tree. However, it is not difficult to envision cases where a DN needs to be changed. The following figure displays a (full) DN:</p><div><img alt="The ModifyDN Operation" src="img/1021_03_01.jpg"/></div><p>A (full) DN is composed of two parts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First<a class="indexterm" id="id128"/>, there is the part specific to the immediate record, called the <strong>Relative DN</strong> or the <strong>RDN</strong>. For example, in the DN <code class="literal">cn=Matt,dc=example,dc=com</code>, the RDN is the <code class="literal">cn=Matt</code> part.</li><li class="listitem" style="list-style-type: disc">Second, there is the part that refers to the parent record of the DN. It is specific to this record. The <code class="literal">dc=example,dc=com</code> part  in the same example points to the parent of this record.</li></ul></div><p>Given the DN, we know how far down the directory tree this record is. It is one layer below the root of the tree—the base DN (<code class="literal">dc=example,dc=com</code>).</p><p>The ModifyDN operation provides a way to change just the RDN or the entire DN. Changing the latter equates to moving the record to another part of the directory tree.</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec05"/>The Compare Operation</h4></div></div></div><a class="indexterm" id="id129"/><a class="indexterm" id="id130"/><p>A Compare operation takes a DN and an attribute value assertion (attribute = value), and checks to see if that attribute assertion is true or false. For example, if the client supplies the DN <code class="literal">cn=Matt,dc=example,dc=com</code> and the attribute value assertion <code class="literal">cn=Matthew</code>, then the server will return <em>true</em> if the record has an attribute <code class="literal">cn</code> with the value <code class="literal">Matthew</code>, or <em>false</em> otherwise. This operation can be faster (and also more secure) than fetching a record and doing the comparison on the client side.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>In OpenLDAP ACLs, the <code class="literal">auth</code> permission setting (as well as the <code class="literal">=x</code> permission setting that we will look at in the next chapter) allows the Compare operation to be used, but does not allow the attribute value to be returned in a search. The <code class="literal">read</code> permission (<code class="literal">=xw</code>) allows both the Compare operation and the return of the attribute value in search results.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec06"/>The Extended Operation</h4></div></div></div><a class="indexterm" id="id131"/><a class="indexterm" id="id132"/><p>Finally, OpenLDAP implements the LDAP v.3 Extended Operation, which makes it possible for a server to implement custom operations.</p><p>The exact syntax of an Extended Operation will depend on the implementation of the extension. The supported Extended Operations are listed in the root DSE under the <code class="literal">supportedExtension</code> attribute. Take a look at the root DSE at the end of Chapter 2. In that record there are two extended operations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">1.3.6.1.4.1.4203.1.11.1: This <strong>Modify Password extension</strong> is defined in RFC 3062 (<a class="ulink" href="http://www.rfc-editor.org/rfc/rfc3062.txt">http://www.rfc-editor.org/rfc/rfc3062.txt</a>). This extension provides an operation for updating a password in the directory.</li><li class="listitem" style="list-style-type: disc">1.3.6.1.4.1.4203.1.11.3: This <strong>Who Am I? extension</strong> is defined in RFC 4532 (<a class="ulink" href="http://www.rfc-editor.org/rfc/rfc4532.txt">http://www.rfc-editor.org/rfc/rfc4532.txt</a>). This extension makes it possible for the currently active DN to find out about itself from the server.</li></ul></div><p>Later in this chapter we will look at tools that use the Modify Password and the Who Am I? extensions.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec13"/>SLAPD Summary</h3></div></div></div><p>In this section we have looked at some of the operations that the SLAPD server makes available to the clients. We've looked at the most common operations (binding, searching, modifying, adding, and deleting). We've also looked at a few of the less-known operations like modifyDN, Compare, and Extended Operations as well.</p><p>By now you should have a good idea of what services the SLAPD server provides to clients. Clients can bind (or authenticate) to a SLAPD server and perform powerful searches of the directory. And through SLAPD the information in the directory tree can be maintained.</p><p>These concepts will be central to the rest of this chapter, and the rest of this book.</p><p>Next, we'll look at the SLURPD daemon, though we will not go into much detail.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>SLURPD</h2></div></div></div><a class="indexterm" id="id133"/><a class="indexterm" id="id134"/><p>SLAPD and SLURPD are the two daemons included in the OpenLDAP suite. Above, we looked at the SLAPD server. Now we will turn to the second daemon.</p><p>SLURPD, the Stand-alone LDAP Update Replication Daemon, is used less frequently than SLAPD, and is on its way to obsolescence. SLURPD provides one way of keeping multiple copies of an LDAP directory synchronized (see the discussion in Chapter 1). Basically it works by tracking the changes (additions, deletions, modifications) to a <em>master</em> SLAPD directory server. When a change is made to the master directory, SLURPD sends updates to all of the subordinate <em>slave</em> servers.</p><p>The SLURPD program, <code class="literal">slurpd</code>, is located at <code class="literal">/usr/sbin</code> (or <code class="literal">/usr/local/libexec</code>, if you compiled from source). In configurations where SLURPD is used, <code class="literal">slurpd</code> is typically started immediately after <code class="literal">slapd</code>. SLURPD does not have its own configuration file. It searches the <code class="literal">slapd.conf</code> file for configuration information.</p><p>In Chapter 7 we will look at the technology that will likely replace SLURPD: the LDAP Sync Replication capability that is built into recent (OpenLDAP 2.2 and later) versions of SLAPD.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Creating Directory Data</h1></div></div></div><a class="indexterm" id="id135"/><p>In the previous section we looked at the two LDAP daemons, SLAPD and SLURPD. But though we have a directory running already, we do not have any entries in our directory (other than the ones that are created by SLAPD, such as schema records and the root DSE).</p><p>In this section we will create a file for holding our LDAP data, and we will devise some directory entries to go in this file. In the next section we will load the data into the directory.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>The LDIF File Format</h2></div></div></div><a class="indexterm" id="id136"/><a class="indexterm" id="id137"/><p>Throughout this book we look at examples of LDAP records presented in plain text, with each line having an attribute description, followed by a colon and a value. The first line of the record is the DN, and usually the last lines of the record are the object class attributes:</p><div><pre class="programlisting">dn: uid=bjensen,dc=exaple,dc=com
cn: Barbara Jensen
mail: bjensen@example.com
uid: bjensen
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>This format is the standard way of representing LDAP directory entries in a text file. It is an example of a record written in the <strong>LDAP Data Interchange Format (LDIF)</strong>, version 1.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>The LDIF file format was developed as part of the University of Michigan LDAP server project. In 2000, LDIF version 1 was standardized in RFC 2849. The standard is available online at <a class="ulink" href="http://www.rfc-editor.org/rfc/rfc2849.txt">http://www.rfc-editor.org/rfc/rfc2849.txt</a>.</p></div></div><p>The LDIF standard defines a file format not only for representing the contents of a directory, but for representing certain LDAP operations, such as additions, changes, and deletions. In the section on the <code class="literal">ldapmodify</code> client, we will use LDIF to specify changes to records in the directory server, but right now we are interested in creating a file that represents the contents of our directory.<a class="indexterm" id="id138"/>
</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>LDIF is not the only directory file format. There is an XML-based directory markup language called <strong>DSML</strong> (<strong>Directory Services Markup Language</strong>). While there is a standardized DSML version 1, the project seems to have lost momentum to the extent that the official website, <a class="ulink" href="http://dsml.org">dsml.org</a>, is now gone. However, one Open Source DSML tools website hosts a mirror of the old <a class="ulink" href="http://dsml.org">dsml.org</a> site: <a class="ulink" href="http://www.dsmltools.org/dsml.org/">http://www.dsmltools.org/dsml.org/</a>.</p><p>The OpenLDAP suite does not directly support DSML.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec14"/>Anatomy of an LDIF File</h3></div></div></div><a class="indexterm" id="id139"/><p>An LDIF file consists of a list of records, each of which represents an entry in the directory. Each entry must have a DN (since any LDAP entry requires a DN), and then one or more attributes or change records (<code class="literal">add</code>, <code class="literal">modify</code>, <code class="literal">delete</code>, <code class="literal">modrdn</code>, <code class="literal">moddn</code>). For now we will confine ourselves to attributes, and put off discussion of change records until we discuss <code class="literal">ldapmodify</code>.</p><p>Records are separated by empty lines, and each record must begin with a DN:</p><div><pre class="programlisting"># First Document: "On Liberty" by J.S. Mill
dn: documentIdentifier=001,dc=example,dc=com
documentIdentifier: 001
documentTitle: On Liberty
documentAuthor: cn=John Stuart Mill,dc=example,dc=com
objectClass: document
objectClass: top

# Second Document: "Treatise on Human Nature" by David Hume
dn: documentIdentifier=002,dc=example,dc=com
documentIdentifier: 002
documentTitle: Treatise on Human Nature
documentAuthor: cn=David Hume,dc=example,dc=com
objectClass: document
objectClass: top</pre></div><p>Lines that begin with a pound or number sign (<code class="literal">#</code>) are treated as comments, and ignored. Note that the pound sign must be the first character on the line, not preceded by any whitespace characters.</p><p>While it is customary for records to end with the <code class="literal">objectClass</code> attributes, this is done because it is considered easier to read. There is no requirement to do so. The order of attributes in an LDIF record is inconsequential.</p><a class="indexterm" id="id140"/><p>An object class (which is defined in a schema definition) indicates what type or types of object the record represents. In the precvious example, the two records are both <code class="literal">documents</code>. The object class definition determines which attributes are required, and which are merely allowed. When authoring an LDIF file you will need to know which fields are required. The DN of any entry is, of course, required, as is the <code class="literal">objectclass</code> attribute. In the <code class="literal">top</code> object class, which represents the root of the schema hierarchy, there are no required fields other than <code class="literal">objectclass</code>. The <code class="literal">document</code> object class definition requires <code class="literal">documentIdentifier</code>, and allows eleven additional fields, including <code class="literal">documentTitle</code> (which takes a string value) and <code class="literal">documentAuthor</code> (which takes a DN value, pointing to another record in the directory).</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>
<strong>The Document Object Class</strong>
</p><a class="indexterm" id="id141"/><p>LDAP directories can model a variety of different types of objects. The <code class="literal">document</code> object class, used in the previous example, represents documents (such as books, papers, and manuals) in the directory. The schema for the <code class="literal">document</code> object class and the related <code class="literal">documentSeries</code> object class is contained in <code class="literal">cosine.schema</code> and defined in section 3.2 of RFC 4524 (<a class="ulink" href="ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt">ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt</a>). Schemas will be discussed at length in Chapter 6.</p></div></div><p>Let's look at the list of attributes for the document and documentSeries object classes:</p><div><img alt="Anatomy of an LDIF File" src="img/1021_03_02.jpg"/></div><p>Any attributes that are used in the DN but are not part of the directory's base DN must be present in the record. For example, consider the case where the base DN is <code class="literal">dc=example,dc=com</code>. An entry with the DN <code class="literal">cn=Matt,dc=example,dc=com</code> would have to have a <code class="literal">cn</code> attribute with the value <code class="literal">Matt</code>. In the previous examples, since <code class="literal">documentIdentifier</code> is used in the DN, there must be a matching <code class="literal">documentIdentifier</code> attribute in the record.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>In fact, the <code class="literal">document</code> object class requires the <code class="literal">documentIdentifier</code> attribute so, in this case, even if the attribute was not used in the DN, any document record would still need a <code class="literal">documentIdentifier</code>.</p></div></div><p>Likewise, an entry with the DN <code class="literal">cn=Matt,ou=Users,dc=example,dc=com</code> would have to have the attributes <code class="literal">cn:Matt</code> and <code class="literal">ou:Users</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec15"/>Representing Attribute Values in LDIF</h3></div></div></div><p>Not<a class="indexterm" id="id142"/> all attribute values are simple and short ASCII strings. LDIF provides facilities for encoding more complex types of data.</p><p>Sometimes attribute values won't fit on one line. If an attribute value is too long to fit on one line it can be continued on the next line, provided that the first character on the continued line is a whitespace character:</p><div><pre class="programlisting">dn: documentIdentifier=003,dc=example,dc=com
documentIdentifier: 003
<strong>documentTitle: An essay on the nature and conduct of the passions</strong>
<strong>     and affections with illustrations on the moral sense.</strong>
documentAuthor: cn=Francis Hutchison,dc=example,dc=com
objectClass: document
objectClass: top</pre></div><p>According to the RFC, an LDIF file can only contain characters in the ASCII character set. However, characters that are not in ASCII can be represented in LDIF using a base-64 encoded value. Entries whose value is base-64 encoded differ slightly. The attribute description is followed by two colons, instead of one:</p><div><pre class="programlisting">dn: documentIdentifier=004,dc=example,dc=com
documentIdentifier: 004
<strong>documentTitle:: bW9uYWRvbG9neQ==</strong>
documentAuthor: cn=G. W. Leibniz,dc=example,dc=com
objectClass: document
objectClass: top</pre></div><a class="indexterm" id="id143"/><p>You should consider base-64 encoding under the following circumstances:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the attribute value contains binary data (such as a JPEG photo).</li><li class="listitem" style="list-style-type: disc">When the character set is not ASCII. Generally, the directory data should be stored in UTF-8, but that means that in order to remain compliant to the LDIF standard, values should be base-64 encoded.</li><li class="listitem" style="list-style-type: disc">When there are line breaks or other non-printing characters within the value. (Note that for such values to be accepted the schema must allow these characters or the directory server will not allow them to be uploaded even if they are encoded.)</li><li class="listitem" style="list-style-type: disc">When the value begins with or ends with whitespace characters (that you want preserved), or begins with a colon (<code class="literal">:</code>) or a less-than sign (<code class="literal">&lt;</code>).</li></ul></div><p>Even DNs can be base-64 encoded, and you can use UTF-8 characters in a DN as long as the DN is base-64 encoded.</p><p>There are several UNIX/Linux utilities which can be used to base-64 encoded values. The most popular is the <code class="literal">uuencode</code> program that comes in the <code class="literal">sharutils</code> package. However, this program is not installed by default in Ubuntu. You can install it quickly from the command line with <code class="literal">apt-get</code>:</p><div><pre class="programlisting">
<strong>  $ sudo apt-get install sharutils</strong>
</pre></div><p>Once <code class="literal">sharutils</code> is installed you can encode a value with <code class="literal">uuencode</code>:</p><div><pre class="programlisting">$ echo -n " test" | uuencode -m name
begin-base64 644 name
IHRlc3Q=
====</pre></div><p>In this example we are converting the string <code class="literal">" test"</code> (note the leading white space) into a base-64 encoded string. This is done with a couple of commands on the command line (using the Bash shell in this example).</p><p>The <code class="literal">uuencode</code> command is typically used to encode files for attachment to an email message, so we have to do a little work to get it to operate the way we want. First, we <code class="literal">echo</code> the string that we want to encode. The <code class="literal">echo</code> program, by default, adds a newline character onto the end of the string that it echoes. We use the <code class="literal">-n</code> flag to prevent it from adding the newline character.</p><p>The string <code class="literal">" test"</code> is echoed to the standard output (<code class="literal">/dev/stdout</code>), and then piped (<code class="literal">|</code>) into the <code class="literal">uuencode</code> command. The <code class="literal">-m</code> flag instructs <code class="literal">uuencode</code> to use base-64 encoding, and the <code class="literal">name</code> string is used by <code class="literal">uuencode</code> to generate a name for the attachment. While this is useful when using <code class="literal">uuencode</code> to generate email attachements, it serves no purpose for us. Since we are not attaching this file to anything it doesn't really matter what you put there; <code class="literal">foo</code> would work equally as well.</p><a class="indexterm" id="id144"/><p>The <code class="literal">uuencode</code> program then prints three lines of output:</p><div><pre class="programlisting">begin-base64 644 name
<strong>IHRlc3Q=</strong>
====</pre></div><p>Only the second line of the code (highlighted one), the actual base-64 encoded value, matters to us. We can copy <code class="literal">IHRlc3Q=</code> and paste it into our LDIF file.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Another popular tool for base-64 encoding is <code class="literal">mimencode</code>, provided by the <code class="literal">metamail</code> package. Both the Perl and Python scripting languages have base-64 encoding tools as well.</p></div></div><p>In some cases, inserting a lengthy attribute value (such as the entire base-64 encoded image file, or even a lengthy bit of text) into the LDIF file would make the file too large to efficiently edit with a text editor. Even a small image file would be hundreds of characters long when base-64 encoded. Instead of inserting the base-64 encoded string directly into the file you can use a special file reference, and the contents of the file will be retrieved and loaded into the directory when the LDIF file is imported.</p><div><pre class="programlisting">dn: documentIdentifier=005,dc=example,dc=com
documentIdentifier: 005
documentTitle: Essays in Pragmatism
documentAuthor: cn=William James,dc=example,dc=com
<strong>description:&lt; file:///home/mbutcher/long-description.txt</strong>
objectClass: document
objectClass: top</pre></div><p>The highlighted line of code shows an example of inserting a reference to an external file.</p><p>There are two important features to note in this example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The left angle bracket (<code class="literal">&lt;</code>) character is used to indicate that the file should be imported. This character evokes the UNIX/Linux shell, which uses the left angle bracket for the same purpose.</li><li class="listitem" style="list-style-type: disc">The path to the file follows the standard <code class="literal">file://</code> URL scheme to represent the file path.</li></ul></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Note that in the file scheme, you will usually need three slashes at the beginning (<code class="literal">file:///path/to/file</code>) to indicate that there is no host field. RFC 3986 (<a class="ulink" href="ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt">ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt</a>) defines the general structures of URIs and URLs. <code class="literal">file://</code> is one particular URL scheme, and is roughly defined in section 3.1 of RFC 1738 (<a class="ulink" href="ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt">ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt</a>).</p></div></div><p>In cases where you have attribute values in multiple languages you can store language information along with the attribute description:</p><div><pre class="programlisting">dn: documentIdentifier=006,dc=example,dc=com
documentIdentifier: 006
<strong>documentTitle;lang-en: On Generation and Corruption</strong>
<strong>documentTitle;lang-la: De Generatione et Corruptione</strong>
documentAuthor: cn=Aristotle,dc=example,dc=com
objectClass: document
objectClass: top</pre></div><a class="indexterm" id="id145"/><p>The language information is stored in the directory, and clients will be able to use it to display the language appropriate to the locale.</p><p>This covers the basics of the LDIF file format, now we will move on and create an LDIF file to load into the directory.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Example.Com in LDIF</h2></div></div></div><p>Now<a class="indexterm" id="id146"/>
<a class="indexterm" id="id147"/>
<a class="indexterm" id="id148"/> we are ready to model our directory tree in an LDIF file. The first thing to do is to decide on a directory structure. We are going to represent an organization in our directory tree. Of course the possibilities for the types of trees you can model are boundless, but we will stick to those most commonly used for LDAP directories.</p><p>There are two popular ways of defining the roots of an organizational directory tree:</p><div><ol class="orderedlist arabic"><li class="listitem">The first is to create a root entry that indicates the official name of the organization and the geographic location (usually just the country) of the organization. Here are a few examples:<div><pre class="programlisting">  o=Arius Ltd.,c=UK
  
  o=Acme GmBH,c=DE
  
  o=Example.Com,c=US</pre></div><p>In each of these three examples, <code class="literal">o</code> represents the organization name, and <code class="literal">c</code> is the two-character country code.</p></li><li class="listitem">The second popular model is to use the organization's domain name. For example, if the company Airius has registered the <code class="literal">airus.co.uk</code> domain name, then the root DN would be composed of three <strong>domain component</strong> (<code class="literal">dc</code>) attributes:<div><pre class="programlisting">  dc=airius,dc=co,dc=uk</pre></div><p>Likewise, the other two records could be re-written using their respective domain components:</p><div><pre class="programlisting">
<a class="indexterm" id="id149"/>  dc=acme,dc=de
  
  dc=example,dc=com</pre></div></li></ol></div><p>Using the organization/country configuration has its advantages. Corporations with multiple domains may find this form more appealing. But the second form, relying upon domain components instead, has become much more prevalent. In most circumstances, I prefer the domain component form because it is more closely related to the way much information is referenced on the Internet.</p><p>Of course, there is no hard and fast rule about how exactly the DN must be structured, and you may find other base DN structures more appealing.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec16"/>Defining the Base DN Record</h3></div></div></div><p>Now<a class="indexterm" id="id150"/> that we have chosen a base DN style, let's begin building a directory for Example.Com. LDIF files are read sequentially, record by record. So, the base DN must come first, since all other records will refer to it in their DNs. Likewise, as we build the directory information tree, we will need to make sure that the parent entries always appear in the file before their children.</p><p>Our base DN looks like this:</p><div><pre class="programlisting">dn: dc=example,dc=com
description: Example.Com, your trusted non-existent corporation.
dc: example
o: Example.Com
objectClass: top
objectClass: dcObject
objectClass: organization</pre></div><p>Let's start from the bottom and work backwards through the example. The record has three object classes: <code class="literal">top</code>, <code class="literal">dcObject</code>, and <code class="literal">organization</code>. As we have seen already, the <code class="literal">top</code> object class is the root of the hierarchy of object classes, and all records within the directory are in the <code class="literal">top</code> object class.</p><p>Here is the figure displaying the object classes:</p><div><img alt="Defining the Base DN Record" src="img/1021_03_03.jpg"/></div><p>The<a class="indexterm" id="id151"/> <code class="literal">dcObject</code> object class simply describes domain components—pieces of a domain name. The domain <a class="ulink" href="http://www.packtpub.com">www.packtpub.com</a>, for example, has three domain components: <code class="literal">www</code>, <code class="literal">packtpub</code>, and <code class="literal">com</code>. Since we are using domain components in the DN, we need the <code class="literal">dcObject</code> class, which requires one attribute: <code class="literal">dc</code>.</p><p>You may notice that while in the DN there are two <code class="literal">dc</code> attributes (<code class="literal">dc=example</code> and <code class="literal">dc=com</code>), there is only one (<code class="literal">dc:example</code>) listed in the record. While it seems counter-intuitive at first glance, the reason is actually straightforward. The record is not describing the entire domain—just a single domain component (<code class="literal">example</code>). Like a DNS record, the parent component (<code class="literal">com</code>) refers to another entity somewhere else in a great big hierarchy.</p><p>So, each record that uses the <code class="literal">dcObject</code> object class can describe only one domain component, and hence have only one <code class="literal">dc</code> attribute in the record (though the DN may have multiple <code class="literal">dc</code> attributes, specifying in which part of the domain hierarchy this record resides).</p><p>But is the <code class="literal">dc=com</code> record supposed to be in our directory? Since the root of this directory (as specified in the <code class="literal">slapd.conf</code> file) is <code class="literal">dc=example,dc=com</code>, we would not expect to find the <code class="literal">dc=com</code> record within the database, as it is not under the <code class="literal">dc=example,dc=com</code> part of the tree (rather, <code class="literal">dc=com</code> is above, or superior to, this part of the tree).<a class="indexterm" id="id152"/>
</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>
<strong>Handling Requests for Records Outside the Directory Tree</strong>
</p><a class="indexterm" id="id153"/><p>What if a search request comes into our <code class="literal">Example.Com</code> directory for <code class="literal">dc=com</code>? Or what if we get a request for <code class="literal">dc=otherExample,dc=com</code>? These are records not expected to be in our directory. Using the referral directive in the <code class="literal">slapd.conf</code> file, you can direct requests of this sort to another server that might prove more authoritative on the matter. The syntax for the directive is <code class="literal">referral &lt;ldap URL&gt;</code>, for example: <code class="literal">referral ldap://root.openldap.org</code>.</p></div></div><p>Now we have specified what domain component our record describes. But we still need a little more. We can't just have a record with <code class="literal">top</code> and <code class="literal">dcObject</code> object classes for two reasons—one practical and the other technical.</p><p>Practically speaking, the record would not be particularly useful with just this sparse information, as it wouldn't really tell us about the base of the directory tree (other than that, it has a domain name).</p><p>Technically speaking, neither of the two object classes, <code class="literal">top</code> and <code class="literal">dcObject</code>, are sufficient for a complete record. The reason for this is that neither of these object classes are <strong>structural object classes</strong>, (<code class="literal">top</code> is abstract, and <code class="literal">dcObject</code> is auxiliary) and every record in the directory must have one object class that is considered the structural object class for that record. For a detailed explanation, as well as some useful information about structuring records, see Chapter 6.</p><p>What would make our base record more useful (and fulfill the record's requirement to have a structural object class)? The <code class="literal">organization</code> object class describes an organization, as the name suggests. It requires one field, <code class="literal">o</code> (or its synonym, <code class="literal">organizationName</code>), which is used to specify the (legal) name of the organization. Additionally the organization object class allows twenty-one optional fields that provide more detailed information about the organization, such as <code class="literal">postalAddress</code>, <code class="literal">telephoneNumber</code>, and <code class="literal">location</code>. In the previous example we used the <code class="literal">description</code> field, which is also among the twenty-one attributes allowed by the <code class="literal">organization</code> object class.</p><p>That is our base entry for our directory. It describes the record at the root of our directory <a class="indexterm" id="id154"/>information tree. Next we want to add some structure to our directory.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec17"/>Structuring the Directory with Organizational Units</h3></div></div></div><a class="indexterm" id="id155"/><a class="indexterm" id="id156"/><p>One of the strengths of LDAP's directory server model is its ability to represent data organized into hierarchies. In this section, we will use <strong>Organizational Units (OUs)</strong> to create a several subtrees beneath our <code class="literal">dc=example,dc=com</code> root.</p><p>Our Example.Com directory is intended primarily for holding user and account information. For that reason, we will want to use Organizational Units to create subtrees.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>If we were, for example, creating a directory of <code class="literal">document</code> records (as we did in the section entitled <em>The</em> <em>LDIF</em> <em>File</em> <em>Format</em>), instead of using OUs, we might instead use <code class="literal">documentSeries</code> records.</p></div></div><p>OpenLDAP does not provide a default OU subtree structure, so you will need to create your own. This can be done in many ways, but here we will see the two prominent theories of how OUs should be structured.</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec07"/>Theory 1: Directory as Organizational Chart</h4></div></div></div><p>The first theory is that the directory should be structured to represent the organizational chart of the organization you are modeling. For example, if the organization has three main units—Accounting, Human Resources (HR), and Information Technology (IT)—then you should have three OUs. Here is a figure for the same:</p><div><img alt="Theory 1: Directory as Organizational Chart" src="img/1021_03_04.jpg"/></div><p>In the given screenshot, each OU represents a unit in the organizational chart. Employees who work in Accounting will have their user accounts in the directory subtree <code class="literal">ou=Accounting,dc=example,dc=com</code>, while employees in IT will have accounts in <code class="literal">ou=IT,dc=example,dc=com</code>.</p><p>This method has some obvious advantages. Knowledge of how the organization works will help you locate information in the directory. Conversely, the directory will serve as a tool for understanding how the organization is structured. Organizational relationships between people or records in the directory will be more easily ascertained. For example, a glance<a class="indexterm" id="id157"/> at the record (or just the DN) of <code class="literal">uid=Marvin,ou=Accounting,dc=example,dc=com</code>, and you will know that Marvin works in the same department as Barbara.</p><p>There are a few things to consider before structuring your directory this way though:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, while organizational structures change—sometimes too frequently—relocating DNs within the directory is not an easy task (and in some cases requires deleting a record from one part of the tree and creating a similar version in another part of the tree).<p>If Barbara, the manager of Accounting, is transferred to Human Resources, her DN must change (to reflect the new OU). Some (older) backends do not allow DN changes, and so Barbara's Accounting record would need to be deleted, and then a new one created for her in the HR OU. Also, applications that stored the DN of the user would have to be reconfigured. Similarly, some employees may split their time between two departments. How would this case be handled?</p></li><li class="listitem" style="list-style-type: disc">A second consideration, and one that is not at all obvious, has to do with the technical use of the LDAP directory. If user records are spread throughout the directory tree, then applications will need to be smart enough to search all over the tree for user records.<p>This problem is usually solved by pre-authentication search techniques, such as binding as Anonymous or as a special authentication user, searching the directory for the account that will be used for authentication, and then binding as the correct account (if found). But not all clients (and not all directories, for that matter) allow pre-authentication searching. And pre-authentication searching can impose a bigger load on the server, whereas other techniques may be easier on the server.</p></li><li class="listitem" style="list-style-type: disc">A third consideration has to do with what other sorts of information you want to store in your directory. If you are using the directory primarily as a tool for modeling the organizational chart, then this particular method of structuring the directory will be ideal for you. You can track employees, assets (fleet vehicles, computers, and so on), and other resources within the directory, and <a class="indexterm" id="id158"/>locate their position in the organization.<p>But if the main purpose of the directory is to create a directory of users of IT services, then this structure will be less than ideal, requiring applications to do much more work to locate users (and in some cases, requiring users to know more about their LDAP accounts).</p></li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec08"/>Theory 2: Directory as IT Service</h4></div></div></div><p>The second theory is that the directory should be structured to represent the way your system (networks, servers, user applications) will need to access the records. In this case the structure of the LDAP directory should be optimized for use by such IT services. While the organizational chart technique groups records by their relation to the organization, this method groups records into functional units, where a position in the directory is determined primarily by the tasks that applications and services will require the directory to perform.</p><p>One common way to structure the directory is to split it into a unit for users, a unit for groups, and a unit for system-level records that applications need, but users will not require access to. Let's see an example:</p><div><img alt="Theory 2: Directory as IT Service" src="img/1021_03_05.jpg"/></div><p>In this case, all of the user accounts are under a particular subtree of the directory: <code class="literal">ou=Users,dc=example,dc=com</code>. Applications need only search in one part of the directory to find user accounts, and when the organization changes, the structure of the directory need not also change.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>There is nothing magical about using organizational units (OUs) for partitioning the directory information tree. You can use other record types, and other attributes (such as <code class="literal">cn</code>—common name) to divide a directory into multiple branches. Using OUs is traditional, though perhaps not the most appropriate in cases where the directory information tree does not model the organizational chart.</p></div></div><p>This<a class="indexterm" id="id159"/> method, Also has some drawbacks. First, the directory structure does not, by design, provide any overt clues to the structure of the organization. Of course organizational information, such as department IDs, can be stored in individual records, and so can be retrieved that way.</p><p>More importantly though, if the directory supports a large number of users, the <code class="literal">ou=Users</code> branch is going to have a lot of records. This is not necessarily a performance problem, but it can make browsing the directory (as opposed to searching the directory) a tedious process.</p><p>In some cases, this problem is mitigated by adding additional subtrees under the user's branch. Sometimes this is done by creating a hybrid configuration where <code class="literal">ou=User</code> has subtrees that represent departments in the organization, such as <code class="literal">ou=Accounting,ou=Users,dc=example,dc=com</code>. Sometimes other classification systems, such as alphabetical schemes, are used to handle this situation: <code class="literal">uid=matt,ou=m-p,ou=Users,dc=example,dc=com</code>.</p><p>But for small and medium-sized ones, a user's branch typically does not have any additional subtrees, which eases the process of integrating with other applications.</p><p>LDAP also has object classes designed to describe groups of records in the directory. Usually, it does not make sense to store these in with the user accounts, so they can be moved to a separate branch.</p><p>Finally, the System branch is used to store records for things like system accounts, mail servers, web servers, and other miscellaneous applications often need (or perform best with) their own LDAP accounts. But if it can be helped, they shouldn't be grouped in with user accounts.</p><p>I've outlined two different ways of structuring the directory information tree—one mirroring the organization, and the other facilitating IT services. But these are only two ways of structuring the directory. You may find that other structures meet your needs better. However, for our purposes, we will use the IT services structure as we continue to build our LDIF file.</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec09"/>Expressing<a class="indexterm" id="id160"/> the OUs in LDIF
</h4></div></div></div><p>Now we are ready to write out our chosen OUs in LDIF. We will create three OUs—Users, Groups, and System—as follows:</p><div><pre class="programlisting"># Subtree for users
dn: ou=Users,dc=example,dc=com
ou: Users
description: Example.Com Users
objectClass: organizationalUnit
# Subtree for groups
dn: ou=Groups,dc=example,dc=com
ou: Groups
description: Example.Com Groups
objectClass: organizationalUnit

# Subtree for system accounts
dn: ou=System,dc=example,dc=com
ou: System
description: Special accounts used by software applications.
objectClass: organizationalUnit</pre></div><p>The three OUs have the same structure.</p><p>Each OU must have the <code class="literal">organizationalUnit</code> object class. This object class has one required attribute: <code class="literal">ou</code>. Here is a figure displaying the <strong>organizationalUnit</strong>:</p><div><img alt="Expressingdirectory treedirectory, structuring the OUs in LDIF" src="img/1021_03_06.jpg"/></div><div><div><h3 class="title"><a id="note20"/>Note</h3><p>Note that the <code class="literal">objectClass: top</code> has been omitted from these records, as well as all of the following records in this chapter. All records are automatically assumed to be instances of the <code class="literal">top</code> object class, so it is not necessary to explicitly include the <code class="literal">objectClass: top</code> attribute.</p></div></div><p>The<a class="indexterm" id="id161"/> <code class="literal">description</code> attribute is optional and there are more than twenty additional (optional) attributes that can be added—most of which provide contact information of the organization unit, such as <code class="literal">telephoneNumber</code>, <code class="literal">postOfficeBox</code>, and <code class="literal">postalAddress</code>.</p><p>With our OUs in place we are ready to add a third tier to our directory tree. Before we start creating individual records let's get an overview of what this next tier will look like. Here is the directory tree structure with a group, a system account, and a pair of users:</p><div><img alt="Expressingdirectory treedirectory, structuring the OUs in LDIF" src="img/1021_03_07.jpg"/></div><p>This is the directory information tree that we will create in the remainder of this section. Next, we will continue building an LDIF file first by adding the users, followed by a system record, and then a group.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec18"/>Adding<a class="indexterm" id="id162"/> User Records
</h3></div></div></div><p>We will<a class="indexterm" id="id163"/> reserve the <code class="literal">Users</code> OU for records that describe people in the organization. In these accounts we want to store information about the user—things like first and last name, title, and department. Since the directory will also be a central resource for application information, we also want to store user ID, email address, and password.</p><p>A basic user record looks like this:</p><div><pre class="programlisting"># Barbara Jensen:
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: Barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword: secret
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>The user record for Barbara belongs to three object classes: <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code>. All three of these are structural object classes, where <code class="literal">inetOrgPerson</code> is  a child of the <code class="literal">organizationalPerson</code> class, which, in turn, is a child of the <code class="literal">person</code> object class. The attributes in Barbara's record are a mixture of the required and allowed attributes from the three object classes. The following figure displays the attributes in Barbara's record:</p><div><img alt="Addingdirectory treedirectory, structuring User Records" src="img/1021_03_08.jpg"/></div><p>Since <code class="literal">inetOrgPerson</code> inherits from <code class="literal">organizationalPerson</code>, a record that has the <code class="literal">inetOrgPerson</code> object class also must have the <code class="literal">organizationalPerson</code> object class. And <code class="literal">organizationalPerson</code> inherits from the <code class="literal">person</code> object class, so <code class="literal">person</code>, is also required.</p><p>This means that all of the <code class="literal">inetOrgPerson</code> records will require <code class="literal">cn</code> (the user's full name) and <code class="literal">sn</code> (the user's surname) attributes, as all <code class="literal">inetOrgPerson</code> records are also person records. It also means that the record can have any combination of the forty-nine optional attributes defined between the three object classes.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Since <code class="literal">uid</code> and <code class="literal">ou</code> attributes were used in the DN, they are effectively required attributes as well. Furthermore, OpenLDAP will require that the record have a <code class="literal">uid</code> attribute and an <code class="literal">ou</code> attribute that have values that match the values in the DN—in other words, since the <code class="literal">ou</code> in the DN is <code class="literal">Users</code>, the <code class="literal">ou</code> attribute in the record must have the value <code class="literal">Users</code>. This behavior is dictated by the LDAP standard.</p></div></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>
<strong>Different object classes, different schemas</strong>
</p><p>While <code class="literal">person</code> and <code class="literal">organizationalPerson</code> are defined in the core schema (<code class="literal">core.schema</code>), <code class="literal">inetOrgPerson</code> is defined in its own schema (<code class="literal">inetOrgPerson.schema</code>), and is standardized on its own in RFC 2798 (<a class="ulink" href="http://rfc-editor.org/rfc/rfc2798.txt">http://rfc-editor.org/rfc/rfc2798.txt</a>). The reason for this is largely historical: <code class="literal">person</code> and <code class="literal">organizationalPerson</code> were defined well before <code class="literal">inetOrgPerson</code> (and by different parties).</p></div></div><p>An <code class="literal">inetOrgPerson</code> record that utilizes more of the available attributes might look like this:</p><div><pre class="programlisting"># Ma<a class="indexterm" id="id164"/>tt Butcher
dn: uid=matt,ou=Users,dc=example,dc=com
ou: Users
# Name info:
uid: Matt
cn: Matt Butcher
sn: Butcher
givenName: Matt
givenName: Matthew
displayName: Matt Butcher
# Work Info:
title: Systems Integrator
description: Systems Integration and IT for Example.Com
employeeType: Employee
departmentNumber: 001
employeeNumber: 001-08-98
mail: mbutcher@example.com
mail: matt@example.com
roomNumber: 301
telephoneNumber: +1 555 555 4321
mobile: +1 555 555 6789
st: Illinois
l: Chicago
street: 1234 Cicero Ave.
# Home Info:
homePhone: +1 555 555 9876
homePostalAddress: 1234 home street $ Chicago, IL $ 60699-1234
# Misc:
userPassword: secret
preferredLanguage: en-us,en-gb
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>In this example we are still using the same three object classes, but have selected many more of the optional attributes. One thing that may stand out in both Barbara's and Matt's records, is that there are an awful lot of attributes used simply for specifying the name of the person; <code class="literal">cn</code>, <code class="literal">sn</code>, <code class="literal">givenName</code>, and <code class="literal">displayName</code> are all fields related to the person's name. What's the point in having so many? There are two benefits achieved by providing diverse name fields:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">This<a class="indexterm" id="id165"/> reduces the amount of guess work that an application has to do when parsing names. Names can be ambiguous—for instance, John Stuart Mill's surname is Mill, while Mary Stuart Masterson's surname is Stuart Masterson. Explicitly specifying such things can reduce ambiguity.</li><li class="listitem" style="list-style-type: disc">The different attributes allow additional information to be specified. Multiple <code class="literal">cn</code> and <code class="literal">givenName</code> values can specify different forms of a person's name, while <code class="literal">displayName</code> (which can only have one value, and cannot be used multiple times in the same record) ensures that the applications will consistently display the same name.</li></ul></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>
<strong>Common Names</strong>
</p><p>The <code class="literal">cn</code> field is used by many different object classes in the directory, many of which do not describe persons. For this reason, a <code class="literal">cn</code> does not always contain the full name of a person. Groups, devices, and documents are amongst the things that may use the <code class="literal">cn</code> (or <code class="literal">commonName</code>) attribute.</p></div></div><p>In the previous examples the <code class="literal">userPassword</code> field, which contains the person's password, is in plain text. When this file is loaded into the directory, the value will be base-64 encoded, but it will not be <em>encrypted</em>. It is not at all secure to store clear-text passwords in the directory (and base-64 encoding does not improve the security of the password). Later in this section we will look at the <code class="literal">ldappasswd</code> tool, which encrypts passwords before storing them in the directory. Production directories should always store the <code class="literal">userPassword</code> value in encrypted form.</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>You may notice that in the <code class="literal">homePostalAddress</code> field, dollar signs (<code class="literal">$</code>) are used where one would normally expect to see line breaks. OpenLDAP does not automatically convert these to line breaks. But use of the dollar sign is an older way of representing line breaks without using base-64 encoding. Typically, it is only used in postal address related fields—and it is up to implementing applications to correctly interpret the dollar signs.</p></div></div><p>Both of these examples use the <code class="literal">inetOrgPerson</code> object class as their primary structural object class. This is because these records describe a person and use the <code class="literal">uid</code> attribute (and use it as part of the DN). Additionally, <code class="literal">inetOrgPerson</code> provides a number of attributes that are useful for modern information infrastructures; <code class="literal">jpegPhoto</code>, <code class="literal">preferredLanguage</code>, and <code class="literal">displayName</code> (amongst others) are all intended to be used primarily<a class="indexterm" id="id166"/> by modern computer agents rather than humans. As it is standardized and widely deployed (LDAP servers from Sun to Microsoft use it), it is the preferred object class for describing people within an organization.</p><p>Thus far we have created a base DN entry, some organizational units, and a few users. Now we will add a record describing a system account.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec19"/>Adding System Records</h3></div></div></div><p>Some <a class="indexterm" id="id167"/>of the entries in our tree—entries that we will need—do not describe users, and so do not belong in the Users organizational unit (OU). Instead, we will put such special records in the <code class="literal">System</code> OU. Likewise, the entities we are describing are not people, and so using the <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code> object classes is not appropriate.</p><p>In this section we will create a new record for an account that will assist users in logging in. The function of the account will be described in detail in Chapter 4, but this account will need to be able to authenticate to the directory server and perform operations. But, again, this account is not for a specific person, and so it will not have personal data (like a surname or a given name).</p><p>Here's what our new system account, called <code class="literal">authenticate</code>, looks like:</p><div><pre class="programlisting"># Special Account for Authentication:
dn: uid=authenticate,ou=System,dc=example,dc=com
uid: authenticate
ou: System
description: Special account for authenticating users
userPassword: secret
objectClass: account
objectClass: simpleSecurityObject</pre></div><p>This record has two object classes: <code class="literal">account</code> and <code class="literal">simpleSecurityObject</code>. The first one, <code class="literal">account</code>, is the structural object class. An <code class="literal">account</code> object, which is defined in the Cosine schema (<code class="literal">cosine.schema</code>), describes an account used to access computers or networks. Let's have a look at the two object classes:</p><div><img alt="Adding System Records" src="img/1021_03_09.jpg"/></div><p>Our<a class="indexterm" id="id168"/> account, whose DN is <code class="literal">uid=authenticate,ou=System,dc=example,dc=com</code>, uses the <code class="literal">uid</code> attribute required by the <code class="literal">account</code> object class, as well as the <code class="literal">ou</code> and <code class="literal">description</code> fields from account. But the account object class does not have a field for storing a password. For that reason we need to add to the record the auxiliary object class <code class="literal">simpleSecurityObject</code>, which has one attribute: the required attribute <code class="literal">userPassword</code>.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Auxiliary object classes can be combined with any other structural or auxiliary object classes. While using multiple structural object classes in one record requires that the object classes be related (for example as <code class="literal">organizationalPerson</code> is a child of <code class="literal">person</code>), auxiliary object classes do not need to be related to the object classes with which they are used. In this case <code class="literal">simpleSecurityObject</code> has no direct relation to <code class="literal">account</code>. See Chapter 6 for a more detailed explanation.</p></div></div><p>By adding the <code class="literal">simpleSecurityObject</code> auxiliary object class, we have now made it possible for our <code class="literal">account</code> record to have a password. Again, in our example, we have specified the password (<code class="literal">userPassword: secret</code>) in clear text. It is not safe to store unencrypted passwords in the directory. For information on encrypting LDAP passwords, see the section on <code class="literal">ldappasswd</code> later in this chapter.</p><p>Now we have created some records under two of our three organizational units: Users and System. Next, we will add a group under the Groups OU.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec20"/>Adding Group Records</h3></div></div></div><p>The<a class="indexterm" id="id169"/> last record we will add to our LDIF file is a record that describes a group of DNs. Groups provide a flexible method for collecting similar DNs by whatever criterion is needed. The DNs in a group do not have to be structurally similar—they can have completely different attributes and object classes, and can describe completely different things (such as a document and a person). Thus, it is up to the directory administrators and directory applications as to what sorts of DNs will be grouped into any particular group.</p><p>In our case, we are going to create a group to represent our directory administrators, and all of the DNs that belong to this group are DNs for users (in the <code class="literal">Users</code> OU, and with the <code class="literal">inetOrgPerson</code> structural object class).</p><div><pre class="programlisting"># LDAP Admin Group:
dn: cn=LDAP Admins,ou=Groups,dc=example,dc=com
cn: LDAP Admins
ou: Groups
description: Users who are LDAP administrators
uniqueMember: uid=barbara,dc=example,dc=com
uniqueMember: uid=matt,dc=example,dc=com
objectClass: groupOfUniqueNames</pre></div><p>Our group has the DN <code class="literal">cn=LDAP Admins,ou=Groups,dc=example,dc=com</code>. Note that we use the <code class="literal">cn</code> attribute, rather than <code class="literal">uid</code>, to identify the group. That is because the <code class="literal">groupOfUniqueNames</code> object class does not allow a <code class="literal">uid</code> attribute (and <code class="literal">cn</code> is required).</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Usually, you should use the <code class="literal">groupOfNames</code> object class rather than <code class="literal">groupOfUniqueNames</code>, because <code class="literal">groupOfNames</code> is the default grouping object class in OpenLDAP. We use a <code class="literal">groupOfUniqueNames</code> here to exhibit some of the features of LDAP group management in thelater chapters.</p></div></div><p>A <code class="literal">groupOfUniqueNames</code> class is one of three grouping object classes defined in the core LDAP version 3 schema (<code class="literal">core.schema</code>). The other two are <code class="literal">groupOfNames</code> and <code class="literal">organizationalRole</code>.</p><p>These have been diplayed in the following figure:</p><div><img alt="Adding Group Records" src="img/1021_03_10.jpg"/></div><p>All<a class="indexterm" id="id170"/> three of these object classes are designed for collecting DNs. Each has an attribute that specifies the DN of a member of the group. In <code class="literal">groupOfNames</code>, the attribute is called, simply enough, <code class="literal">member</code>. The <code class="literal">groupOfUniqueNames</code> class, which does not differ in function from <code class="literal">groupOfNames</code>, uses <code class="literal">uniqueMember</code> as its membership attribute. The <code class="literal">organizationalRole</code> grouping class, which is intended to represent the group responsible for performing a particular role in the context of the organization, uses the <code class="literal">roleOccupant</code> attribute for membership.</p><p>In all three grouping object classes, the membership attribute (<code class="literal">member</code>, <code class="literal">uniqueMember</code>, or <code class="literal">roleOccupant</code>) can be specified multiple times, as we saw in the LDIF snippet for the <code class="literal">LDAP Admins</code> group.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>
<strong>What Kind of Group Should I Use?</strong>
</p><p>How do you decide whether to use a <code class="literal">groupOfNames</code>, <code class="literal">groupOfUniqueNames</code>, or <code class="literal">organizationalRole</code>? By default, it is best to use <code class="literal">groupOfNames</code>, as it is treated as the default grouping object class by OpenLDAP. The <code class="literal">organizationalRole</code> object class is intended to be used as a way of defining what a person does within an organization. The <code class="literal">groupOfUniqueNames</code> object class was intended for a different use from <code class="literal">groupOfNames</code>, but implementation-wise, they function identically on OpenLDAP.</p></div></div><p>The <code class="literal">groupOfUniqueNames</code> and <code class="literal">groupOfNames</code> object classes both allow the <code class="literal">owner</code> attribute, which can also be used more than once (to, for example, model cases where a group has two owners). An <code class="literal">owner</code> attribute holds the DN of the record that is considered the owner of the group.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>There is a fourth (but experimental) general purpose method for grouping in OpenLDAP, called <strong>dynlist</strong>/<strong>dyngroup</strong>. This uses a specific object class, the dynamic <strong>groupOfURLs</strong> grouping class, in conjunction with a special directory overlay. This method of grouping is expected to reach maturity in OpenLDAP 2.4.</p></div></div><p>In our example group, which is <code class="literal">groupOfUniqueNames</code>, we specified two <code class="literal">uniqueMember</code> attributes:</p><div><pre class="programlisting">uniqueMember: uid=barbara,dc=example,dc=com
uniqueMember: uid=matt,dc=example,dc=com</pre></div><p>Both of these DNs are members of the group. Note that SLAPD does not actively check to make sure that these DNs exist, nor does it automatically remove a DN from groups when<a class="indexterm" id="id171"/> the DN is removed from the directory.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>
<strong>Integrity Checking</strong>
</p><p>SLAPD can be configured to do integrity checking on records using the RefInt (Referential Integrity) overlay discussed in Chapter 5. This overlay can be used to make sure that group member DNs stay synchronized with the entries in the directory information tree.</p></div></div><p>Thus, directory administrators and directory applications must be careful to perform additional verification and cleanup when working with groups. When a DN is deleted from the directory, a directory-wide search for attributes that take DN values should be performed to make sure that attributes such as <code class="literal">member</code> and <code class="literal">roleOccupant</code> (and, for that matter, <code class="literal">seeAlso</code>) do not point to the newly-deleted DN.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>The Complete LDIF File</h2></div></div></div><p>Finally<a class="indexterm" id="id172"/>
<a class="indexterm" id="id173"/>, we have finished building our LDIF file. We will save it in a file named <code class="literal">basics.ldif</code>, since it contains the basic elements of our directory. Here is what it looks like:</p><div><pre class="programlisting"># This is the root of the directory tree
dn: dc=example,dc=com
description: Example.Com, your trusted non-existent corporation.
dc: example
o: Example.Com
objectClass: top
objectClass: dcObject
objectClass: organization

# Subtree for users
dn: ou=Users,dc=example,dc=com
ou: Users
description: Example.Com Users
objectClass: organizationalUnit

# Subtree for groups
dn: ou=Groups,dc=example,dc=com
ou: Groups
description: Example.Com Groups
objectClass: organizationalUnit

# Subtree for system accounts
dn: ou=System,dc=example,dc=com
ou: System
description: Special accounts used by software applications.
objectClass: organizationalUnit

##
## USERS
##

# Matt Butcher
dn: uid=matt,ou=Users,dc=example,dc=com
ou: Users
# Name info:
uid: matt
cn: Matt Butcher
sn: Butcher
givenName: Matt
givenName: Matthew
displayName: Matt Butcher
# Work Info:
title: Systems Integrator
description: Systems Integration and IT for Example.Com
employeeType: Employee
departmentNumber: 001
employeeNumber: 001-08-98
mail: mbutcher@example.com
mail: matt@example.com
roomNumber: 301
telephoneNumber: +1 555 555 4321
mobile: +1 555 555 6789
st: Illinois
l: Chicago
street: 1234 Cicero Ave.
# Home Info:
homePhone: +1 555 555 9876
homePostalAddress: 1234 home street $ Chicago, IL $ 60699-1234
# Misc:
userPassword: secret
preferredLanguage: en-us,en-gb
# Object Classes:
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson

#<a class="indexterm" id="id174"/> Barbara Jensen:
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword: secret
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson

# LDAP Admin Group:
dn: cn=LDAP Admins,ou=Groups,dc=example,dc=com
cn: LDAP Admins
ou: Groups
description: Users who are LDAP administrators
uniqueMember: uid=barbara,dc=example,dc=com
uniqueMember: uid=matt,dc=example,dc=com
objectClass: groupOfUniqueNames

# Special Account for Authentication:
dn: uid=authenticate,ou=System,dc=example,dc=com
uid: authenticate
ou: System
description: Special account for authenticating users
userPassword: secret
objectClass: account
objectClass: simpleSecurityObject</pre></div><p>In<a class="indexterm" id="id175"/> the next section, we will look at the OpenLDAP utilities, and we will use these utilities to load our LDIF file into the directory.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using the Utilities to Prepare the Directory</h1></div></div></div><p>So<a class="indexterm" id="id176"/>
<a class="indexterm" id="id177"/>
<a class="indexterm" id="id178"/> far in this chapter we have looked at the server operations, and created an LDIF file representing our initial directory information tree. In the remainder of this chapter we are going to look at two groups of tools. In this part we are going to look at the OpenLDAP utilities. In the next part we will look at the OpenLDAP clients.</p><p>Unlike the OpenLDAP clients, the utilities do not use the LDAP protocol to connect to a server and perform directory operations. Instead they work on a lower level, interacting directly with OpenLDAP directories and data files. The OpenLDAP suite includes eight utilities that perform administrative tasks. We will look at these tools as we go through the process of creating, loading, and verifying directory data.</p><p>The aim of this section is to explain the basic use of these utilities. Each utility has a handful of command-line flags that can be used to further modify the behavior of the utility. We will see some of the more useful flags, but if you want detailed information, you should consult the excellent OpenLDAP man pages.</p><p>In recent versions of OpenLDAP the utilities do not actually exist as stand-alone programs. Instead, they are all compiled into the <code class="literal">slapd</code> program, and symbolic links are created to point from the utility name to the <code class="literal">slapd</code> program. Using the <code class="literal">ls</code> command, we can look at the utilities to see how this is done:</p><div><pre class="programlisting">
<strong>  $ ls -og /usr/local/sbin</strong>
</pre></div><p>This is what we get:</p><div><pre class="programlisting">total 0
lrwxrwxrwx 1 16 2006-08-17 11:37 slapacl -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slapadd -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slapauth -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slapcat -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slapdn -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slapindex -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slappasswd -&gt; ../libexec/slapd
lrwxrwxrwx 1 16 2006-08-17 11:37 slaptest -&gt; ../libexec/slapd</pre></div><p>All eight of the utilities are just symbolic links to the <code class="literal">slapd</code> program. When <code class="literal">slapd</code> gets executed, it checks to see what program name was used when it was executed, and then it acts like that program. For example, when <code class="literal">slapd</code> is called as <code class="literal">slapadd</code>, it acts as a program for loading data into the directory. If it is called as <code class="literal">slaptest</code>, it acts as a program for verifying the format of and directives in the configuration file.</p><p>As we proceed through the description of the utilities we will cover them as if they were separate programs because that is how they are treated.</p><p>Since we created an LDIF file in the last part, we will begin this section by looking at the tool that loads the LDIF file into the directory backend.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>slapadd</h2></div></div></div><p>The<a class="indexterm" id="id179"/>
<a class="indexterm" id="id180"/>
<a class="indexterm" id="id181"/> <code class="literal">slapadd</code> program is used to load directory data, formated as LDIF files, directly into OpenLDAP. It is executed from within an operating system shell (for example a command prompt or shell script).</p><p>The <code class="literal">slapadd</code> program does not use the LDAP protocol to connect to a running server. Instead, it works directly with the OpenLDAP backend. For that reason, when you run <code class="literal">slapadd</code> you must first shut down the directory server. Otherwise, you may end up with conflicts between the <code class="literal">slapd</code> server process and the <code class="literal">slapadd</code> process as they both try to exclusively manage the same databases.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec21"/>When Should slapadd be Used?</h3></div></div></div><p>There<a class="indexterm" id="id182"/> are many tools for loading records into the directory, including the OpenLDAP client <code class="literal">ldapadd</code> (which connects to the server over the LDAP protocol and performs one or more add operations). So, how do we figure out which program to use under any particular set of circumstances? </p><p>Well, <code class="literal">slapadd</code> is intended to be used to load large amounts of directory data, generally for the purpose of creating a new directory, or restoring a directory from a backup. Because it requires that the directory be taken offline, this utility is not generally a good candidate for performing routine updates. The <code class="literal">ldapadd</code> program (discussed in the <em>Clients</em> section later in this chapter) is a much better candidate for that sort of operation.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec22"/>What Does slapadd Do?</h3></div></div></div><p>The<a class="indexterm" id="id183"/> <code class="literal">slapadd</code> utility reads the <code class="literal">slapd.conf</code> file (and any included files), loads the appropriate backend databases, and then reads LDIF data (usually from a file). As it reads the data, it verifies that all of the records are correctly constructed (that the DNs are in a tree that the server manages, that the records use the right attributes for their object classes, that all required fields are there, that the record is formatted correctly, and so on), and then it loads the records into the appropriate backend.</p><p>Since <code class="literal">slapadd</code> does not connect over the LDAP protocol, it does not require any authentication to the directory. It does, however, require write access to the directory database files. So <code class="literal">slapadd</code> is usually run from the shell of either the user that runs the directory<a class="indexterm" id="id184"/> (often <code class="literal">ldap</code> or <code class="literal">slapd</code>) or from the root account.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Loading the LDIF File</h3></div></div></div><p>In<a class="indexterm" id="id185"/> the previous part of this chapter we created an LDIF file containing a handful of records for our directory tree. Now we will load this LDIF file into our directory. This will take four steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stop the <code class="literal">slapd</code> server</li><li class="listitem" style="list-style-type: disc">Test the LDIF file with <code class="literal">slapadd</code></li><li class="listitem" style="list-style-type: disc">Load the directory with <code class="literal">slapadd</code></li><li class="listitem" style="list-style-type: disc">Restart the <code class="literal">slapd</code> server</li></ul></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec10"/>Stopping the Server</h4></div></div></div><p>We<a class="indexterm" id="id186"/> covered the process of starting and stopping the server at the end of Chapter 2. To summarize, though, we can stop a version installed from the Ubuntu package using the <code class="literal">invoke-rc.d</code> command:</p><div><pre class="programlisting">
<strong>  $ sudo invoke-rc.d slapd stop</strong>
</pre></div><p>With the version compiled from source (see <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>), this can be done by finding the <code class="literal">slapd</code> process ID and killing the process (or using the <code class="literal">killall</code> program):</p><div><pre class="programlisting">
<strong>  $ sudo kill `pgrep slapd`</strong>
</pre></div><p>Next, we need to make sure that the LDIF file we created in the last part is correctly formatted.</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec11"/>Running ldapadd in Test Mode</h4></div></div></div><p>Running<a class="indexterm" id="id187"/> in test mode before doing the actual load can greatly reduce the amount of time it takes to load a new LDIF file because it will help you catch LDIF errors before things get written to the directory. Normally <code class="literal">slapadd</code> adds records one at a time as it reads them. So if there are three records in a file, the first record will be added to the directory before the second or third records are read. If there is an error in a record later in the file, then the directory will be partially loaded, and you will either have to creatively alter the LDIF file or destroy the database and start again.</p><p>Using test mode, we can make sure that the LDIF file does not have any errors before we start loading records into the directory. This should just eliminate cases where an LDIF file is only partially imported because of bad records.</p><p>We can use the <code class="literal">slapadd</code> program to do this before we try to load the data into the directory:</p><div><pre class="programlisting">
<strong>  $ sudo slapadd -v -u -c -f /etc/ldap/slapd.conf -l /tmp/basics.ldif</strong>
</pre></div><p>This command uses five flags:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-v</code> flag: This puts the program into "verbose" mode, where it will print out extra information about what is happening (and, if the process fails, what led to the failure). Usually it is a good idea to run <code class="literal">slapadd</code> in verbose mode, especially when loading an untested LDIF file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-u</code> flag: This tells <code class="literal">slapadd</code> to run in test (or <em>dry-run</em>) mode. When this is enabled, <code class="literal">slapadd</code> will evaluate the file as if it were going to load the file into the directory, but it won't actually put any records in the directory.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code> flag: This tells <code class="literal">slapadd</code> to keep processing the file even if it hits a bad record. Using this flag, we can run through the file once and get a list of all of the records that are not correctly formatted.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-f</code> flag: This flag, which takes as an argument the path to the server's configuration file, specifies which configuration file should be used. In most cases you can omit this, and <code class="literal">slapadd</code> will just look in the default place (usually <code class="literal">/etc/ldap/slapd.conf</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">-l</code> flag: This points to the LDIF file we want to load. In this case we are loading the <code class="literal">basics.ldif</code> file, which is located in the system's <code class="literal">/tmp</code> directory.</li></ul></div><p>In<a class="indexterm" id="id188"/> cases where there is an error in the LDIF file, <code class="literal">slapadd</code> will print out some helpful information. For example, if we try to load an obviously broken file that looks like this:</p><div><pre class="programlisting"># This is the root of the directory tree
dn: dc=example,dc=com
description: Example.Com, your trusted non-existent corporation.
dc: example
o: Example.Com
objectClass: top
objectClass: dcObject
objectClass: organization

<strong>Broken</strong>

# Subtree for users
dn: ou=Users,dc=example,dc=com
ou: Users
<strong>ferble: glarp</strong>
description: Example.Com Users
objectClass: organizationalUnit</pre></div><p>In this file the broken lines are highlighted. When we run <code class="literal">slapadd</code>, we will get an error:</p><div><pre class="programlisting">added: "dc=example,dc=com"
str2entry: entry -1 has no dn
slapadd: could not parse entry (line=11)
&lt;= str2entry: str2ad(ferble): attribute type undefined
slapadd: could not parse entry (line=18)</pre></div><p>Here, <code class="literal">slapadd</code> tested our first record, <code class="literal">dc=example,dc=com</code>, without problems, but then encountered a line that did not begin with a DN (on line 11). It skipped that record. On line 18 it encountered another error: the <code class="literal">ferble</code> attribute is not defined by any of the object classes in the record.</p><p>When run successfully against the LDIF file we created earlier in this chapter, the output looks like this:</p><div><pre class="programlisting">$ sudo slapadd -v -u -c -f /etc/ldap/slapd.conf -l basics.ldif
added: "dc=example,dc=com"
added: "ou=Users,dc=example,dc=com"
added: "ou=Groups,dc=example,dc=com"
added: "ou=System,dc=example,dc=com"
added: "uid=matt,ou=Users,dc=example,dc=com"
added: "uid=barbara,ou=Users,dc=example,dc=com"
added: "cn=LDAP Admins,ou=Groups,dc=example,dc=com"
added: "uid=authenticate,ou=System,dc=example,dc=com"</pre></div><p>No errors. We are ready to proceed to the third step: importing the records into the directory.<a class="indexterm" id="id189"/>
</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec12"/>Importing the Records Using slapadd</h4></div></div></div><a class="indexterm" id="id190"/><p>To do the actual import of the records into the directory, we use the <code class="literal">slapadd</code> command with a subset of the flags used in the previous section. We omit the <code class="literal">-u</code> flag (for testing) and the <code class="literal">-c</code> flag (so that it doesn't continue if it encounters a bad record).</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p><strong>Using the -q flag</strong></p><p>To load the directory faster, you can add the <code class="literal">-q</code> flag, which turns off some of the time-consuming checks <code class="literal">slapadd</code> performs on the data. But before using this flag, make sure you test the LDIF data first (using the method just described). Otherwise you might end up with an unusable directory.</p></div></div><p>Now, the command looks like this:</p><div><pre class="programlisting">
<strong>  $ sudo slapadd -v -f /etc/ldap/slapd.conf -l basics.ldif</strong>
</pre></div><p>And, this is what we get as output:</p><div><pre class="programlisting">added: "dc=example,dc=com" (00000001)
added: "ou=Users,dc=example,dc=com" (00000002)
added: "ou=Groups,dc=example,dc=com" (00000003)
added: "ou=System,dc=example,dc=com" (00000004)
added: "uid=matt,ou=Users,dc=example,dc=com" (00000005)
added: "uid=barbara,ou=Users,dc=example,dc=com" (00000006)
added: "cn=LDAP Admins,ou=Groups,dc=example,dc=com" (00000007)
added: "uid=authenticate,ou=System,dc=example,dc=com" (00000008)</pre></div><p>Note that the output is just slightly different this time; at the end of each line, there is an ID number enclosed in parentheses. This ID number makes up part of the record's <code class="literal">entryCSN</code> attribute, which is used internally to monitor the record.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>As with many LDAP servers, OpenLDAP attaches special <strong>operational attributes</strong> to records. In these attributes, OpenLDAP stores directory-centric information about the record. We will talk about these more when we discuss the <code class="literal">slapcat</code> utility.<a class="indexterm" id="id191"/>
</p></div></div><p>We have just populated our directory with the eight records we created earlier in the chapter. We are now ready to start the directory.<a class="indexterm" id="id192"/>
</p></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec13"/>Restarting the Directory</h4></div></div></div><p>In Chapter 2 we discussed starting and stopping the directory. This can be done with the init script:</p><div><pre class="programlisting">
<strong>  $ sudo invoke-rc.d slapd start</strong>
</pre></div><p>Or, if you installed according to <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>, <code class="literal">slapd</code> can be run directly:</p><div><pre class="programlisting">
<strong>  $ sudo /usr/local/libexec/slapd</strong>
</pre></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec14"/>If Something Went Wrong...</h4></div></div></div><a class="indexterm" id="id193"/><p>It sometimes happens that midway through a <code class="literal">slapadd</code>, the program encounters an error—either in the LDIF file itself, or from some external consideration—and aborts the directory import part way through. In these cases you may need to start over. But merely re-running the <code class="literal">slapadd</code> operation will give errors like this (the error may vary depending on the backend you are using):</p><div><pre class="programlisting">$ sudo slapadd -v -f /usr/local/etc/openldap/slapd.conf -l 
    basics.ldif
=&gt; hdb_tool_entry_put: id2entry_add failed: DB_KEYEXIST: Key/data 
    pair already exists (-30996)
=&gt; hdb_tool_entry_put: txn_aborted! DB_KEYEXIST: Key/data pair 
    already exists (-30996)
slapadd: could not add entry dn="dc=example,dc=com" (line=9): 
    txn_aborted! DB_KEYEXIST: Key/data pair already exists (-30996)</pre></div><p>What is going on here?</p><p>What has happened is that some of the entries from the <code class="literal">basics.ldif</code> file have already been imported into the directory, but perhaps not all of them. There are various ways to attempt to work around this. You can try to prune the LDIF file down to just the records that haven't been added already. You can try to run the <code class="literal">slapadd</code> program in continuation mode (with the <code class="literal">-c</code> flag) and hope that all of the remaining records are added correctly.</p><p>But you may find that the best way of dealing with these cases is to simply destroy and rebuild the directory. While this sounds like a rather extreme measure, it has one distinct advantage over other methods: it avoids the problem of inconsistent records that can be caused with failed <code class="literal">slapadd</code> commands. Thus, it is often the best way of recovering from failed directory imports.<a class="indexterm" id="id194"/>
</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>Errors in the index files can also be induced by <code class="literal">slapadd</code> failures. If you decide not to destroy and recreate your directory after a failed <code class="literal">slapadd</code>, make sure you run the <code class="literal">slapindex</code> utility (covered later in this chapter) after loading new records to the directory.</p></div></div></div><div><div><div><div><h4 class="title"><a id="ch03lvl4sec15"/>Destroying and Recreating the Directory Files</h4></div></div></div><a class="indexterm" id="id195"/><a class="indexterm" id="id196"/><p>In most of the OpenLDAP backends that can be loaded with <code class="literal">slapadd</code>, the backend stores data somewhere on the file system or in a relational database. After a failed <code class="literal">slapadd</code> you may find that the best way to recover is to destroy all of the data in the underlying backend, and then start over.</p><p>Currently, we are using the <code class="literal">hdb</code> backend (see Chapter 2). The method used here will apply equally well to other BerkeleyDB backends (<code class="literal">bdb</code> and <code class="literal">ldbm</code> in <code class="literal">bdb</code> mode), and can be easily adapted to cover the (deprecated) <code class="literal">ldbm</code> with <code class="literal">gdbm</code> backend.</p><p>For other sorts of backends, such as those that use relational databases like PostgreSQL, or custom backends like <code class="literal">back-perl</code>, you will need to examine the documentation on those backends to determine the best way of clearing the records from the directory.</p><p>For the <code class="literal">hdb</code> and <code class="literal">bdb</code> backends, the directory data files are stored on the file system. In Ubuntu, these are located at <code class="literal">/var/lib/ldap</code>. If you followed the directions in <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>, the database files are located at <code class="literal">/usr/local/var/openldap-data/</code>.</p><p>Here's what the contents of the <code class="literal">/var/lib/ldap</code> directory look like:</p><div><pre class="programlisting">alock    __db.002    __db.005    dn2id.bdb    objectClass.bdb
cn.bdb    __db.003    DB_CONFIG    id2entry.bdb
__db.001    __db.004    DB_CONFIG.example    log.0000000001</pre></div><p>Here you can see all of the directory database files (which start with <code class="literal">__db.</code>), the directory index files (which end with <code class="literal">.bdb</code>), and the BerkeleyDB transaction logs (which begin with <code class="literal">log.</code>). There are a few other files in this directory, such as <code class="literal">alock</code> and <code class="literal">DB_CONFIG</code>, that we don't need to delete. To delete the files, we use <code class="literal">rm</code> with a list of expressions that match only the files we want to delete:</p><div><pre class="programlisting">
<strong>  $ sudo rm __db.* *.bdb log.*</strong>
</pre></div><p>This removes just the files we don't want. Now the directory should contain only a couple of files:</p><div><pre class="programlisting">alock    DB_CONFIG    DB_CONFIG.example</pre></div><p>That's all it takes to destroy the database. Now we can re-create the directory by loading the (corrected, if necessary) LDIF file with the <code class="literal">slapadd</code> command:</p><div><pre class="programlisting">
<strong>  $ sudo slapadd -v -l basics.ldif</strong>
</pre></div><p>And this message is returned:</p><div><pre class="programlisting">added: "dc=example,dc=com" (00000001)
added: "ou=Users,dc=example,dc=com" (00000002)
added: "ou=Groups,dc=example,dc=com" (00000003)
added: "ou=System,dc=example,dc=com" (00000004)
added: "uid=matt,ou=Users,dc=example,dc=com" (00000005)
added: "uid=barbara,ou=Users,dc=example,dc=com" (00000006)
added: "cn=LDAP Admins,ou=Groups,dc=example,dc=com" (00000007)
added: "uid=authenticate,ou=System,dc=example,dc=com" (00000008)</pre></div><p>That is all there is to destroying and recreating a directory.<a class="indexterm" id="id197"/>
<a class="indexterm" id="id198"/>
</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>slapindex</h2></div></div></div><a class="indexterm" id="id199"/><a class="indexterm" id="id200"/><a class="indexterm" id="id201"/><p>The next utility that we will examine is <code class="literal">slapindex</code>. This utility manages the index files for OpenLDAP backends that use indexes (such as <code class="literal">hdb</code>, <code class="literal">bdb</code>, and the deprecated <code class="literal">ldbm</code>).</p><p>OpenLDAP maintains a set of index files to expedite searching for records. These are stored outside of the main directory database, and as records are added, modified, and removed from the directory, the <code class="literal">slapd</code> server modifies the index files accordingly.</p><p>But in certain circumstances, the <code class="literal">slapd</code> server may not have sufficient information to know about changes it needs to make to the index files and, in those cases, the indexes will need to be rebuilt manually.</p><div><div><h3 class="title"><a id="note27"/>Note</h3><p>Like <code class="literal">slapadd</code>, <code class="literal">slapindex</code> should not be run while the server is running. Before running <code class="literal">slapindex</code>, you should stop <code class="literal">slapd</code>.</p></div></div><p>There are three common cases that require use of the <code class="literal">slapindex</code> command:<a class="indexterm" id="id202"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">When a utility, usually <code class="literal">slapadd</code>, is used to add records to an <em>existing</em> database.</li><li class="listitem">When the indexing directives in <code class="literal">slapd.conf</code> are changed, or new indexes are added (see Chapter 2 and the <em>Performance</em> <em>Tuning</em> section of Chapter 5).</li><li class="listitem">On other (rare) occasions, external conditions or failed <code class="literal">slapadd</code> commands may get the directory database and the directory indexes out of sync. The main symptom of this synchronization error is that searches using <code class="literal">ldapsearch</code> will fail to return records that are known to be in the directory.</li></ol></div><p>In these three cases, <code class="literal">slapindex</code> should be run:</p><div><pre class="programlisting">
<strong>  $ sudo slapindex -q -f /etc/ldap/slapd.conf</strong>
</pre></div><p>This will rebuild all of the indexes for the first database defined in <code class="literal">slapd.conf</code> (we only have one database defined).</p><p>The <code class="literal">-q</code> flag instructs slapindex to perform some additional checking operations, which will greatly expedite the process of re-indexing. Skipping such checks is generally safe with the <code class="literal">slapindex</code> utility, though it should only be done with great care when using <code class="literal">slapadd</code>.</p><p>The <code class="literal">-f</code> flag, which takes the path to a configuration file, specifies the <code class="literal">slapd</code> configuration file. If this flag is omitted (as we have done), <code class="literal">slapindex</code> will look in the default location for the <code class="literal">slapd.conf</code> file.</p><p>If you want to monitor the progress of <code class="literal">slapindex</code>, you can use the <code class="literal">-v</code> flag to turn on verbose output.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>slapcat</h2></div></div></div><a class="indexterm" id="id203"/><a class="indexterm" id="id204"/><a class="indexterm" id="id205"/><p>The <code class="literal">slapcat</code> program dumps the entire contents of a directory into an LDIF file. It is a convenient tool for creating a backup of the directory, and can also be useful for examining the data is in the directory.</p><p>Of course, there is a similar client application, <code class="literal">ldapsearch</code>, which can also dump the entire contents of the directory. How do you know when to use each? Since <code class="literal">ldapsearch</code> uses the LDAP protocol to contact the server, bind, and then run LDAP search operations, it incurs more overhead. <code class="literal">slapcat</code>, on the other hand, works directly with the backend. <code class="literal">ldapsearch</code> is limited by time and size limits, set both in the client configuration file, <code class="literal">ldap.conf</code>, and in the server's configuration in <code class="literal">slapd.conf</code> (see Chapter 2). The <code class="literal">ldapsearch</code> command is also limited by ACLs, while no ACLs are applied to <code class="literal">slapcat</code>.</p><p>Clearly then, for operations such as backing up the directory, <code class="literal">slapcat</code> ought to be used rather than <code class="literal">ldapsearch</code>.</p><p>As of version 2.3 of OpenLDAP, if you are using the <code class="literal">hdb</code> or <code class="literal">bdb</code> backends, you can safely run <code class="literal">slapcat</code> while <code class="literal">slapd</code> is running; there is no need to shutdown the directory server in order to make a backup copy.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The man page for <code class="literal">slapcat</code> in OpenLDAP incorrectly indicates that it is unsafe to run <code class="literal">slapcat</code> while the directory server is running. This is simply an artifact of the earlier versions of OpenLDAP (2.2 and earlier), in which <code class="literal">slapcat</code> could not be run while <code class="literal">slapd</code> was running. Note that it is still unsafe to run <code class="literal">slapcat</code> against an <code class="literal">ldbm</code> backend while <code class="literal">slapd</code> is running.</p></div></div><p>When we covered <code class="literal">slapadd</code> earlier in this chapter, we used that utility to load records in <code class="literal">basics.ldif</code> into the directory. Now we can use <code class="literal">slapcat</code> to view those records.</p><div><pre class="programlisting">
<strong>  $ sudo slapcat -l basics-out.ldif</strong>
</pre></div><p>The <code class="literal">-l</code> flag, which takes a path for an argument, indicates what file the output should be written to. In this case it is writing to the file <code class="literal">basics-out.ldif</code>. If <code class="literal">-l</code> is omitted, then the LDIF data will be sent to standard output, which will usually be printed straight to your screen.</p><p>As with the other utilities, the <code class="literal">-f</code> flag can be used to specify the path to the SLAPD configuration file. The <code class="literal">-a</code> flag, which takes an LDAP filter, can be used to specify a pattern that records must match before they are dumped to output. You can use this flag to dump just a subtree. For example, we could dump only records in the <code class="literal">Users</code> OU with this command:</p><div><pre class="programlisting">
<strong>  $ sudo slapcat -a "(entryDN:dnSubtreeMatch:=ou=Users,</strong>
<strong>                       dc=example,dc=com)"</strong>
</pre></div><p>This would return complete records for only the following three DNs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ou=Users,dc=example,dc=com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">uid=matt,ou=Users,dc=example,dc=com</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">uid=barbara,ou=Users,dc=example,dc=com</code></li></ul></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Operational Attributes</h3></div></div></div><a class="indexterm" id="id206"/><p>Let's take a closer look at the output for just the record of the base DN:</p><div><pre class="programlisting">$ sudo slapcat -a "(dc=example)"
dn: dc=example,dc=com
description: Example.Com, your trusted non-existent corporation.
dc: example
o: Example.Com
objectClass: top
objectClass: dcObject
objectClass: organization
<strong>structuralObjectClass: organization</strong>
<strong>entryUUID: b1a00a7c-c587-102a-9eb2-412127118751</strong>
<strong>creatorsName: cn=Manager,dc=example,dc=com</strong>
<strong>modifiersName: cn=Manager,dc=example,dc=com</strong>
<strong>createTimestamp: 20060821173908Z</strong>
<strong>modifyTimestamp: 20060821173908Z</strong>
<strong>entryCSN: 20060821173908Z#000000#00#000000</strong>
</pre></div><p>The highlighted attributes should look unfamiliar, as they did not exist in the original LDIF file that we created. These are internal <strong>operational attributes</strong> that OpenLDAP automatically maintains.</p><p>Different operational attributes play different roles in OpenLDAP, and these attributes may be useful for directory managers and LDAP-aware applications.</p><p>For example, the <code class="literal">creatorsName</code>, <code class="literal">modifiersName</code>, <code class="literal">createTimestamp</code>, and <code class="literal">modifyTimestamp</code> fields often come in useful. OpenLDAP automatically retains the <a class="indexterm" id="id207"/>following record-level information:</p><div><ol class="orderedlist arabic"><li class="listitem">When and by whom each record was created.</li><li class="listitem">When and by whom each record was last modified.</li></ol></div><p>The <code class="literal">entryUUID</code> attribute provides a <strong>Universally Unique Identifier (UUID)</strong> for a record, which serves as an identifier that is more stable than DN (which can change), and is supposed to be, according to the specification in RFC 4122 (<a class="ulink" href="http://rfc-editor.org/rfc/rfc4122.txt">http://rfc-editor.org/rfc/rfc4122.txt</a>), "an identifier unique across both space and time, with respect to the space of all UUIDs." See the <code class="literal">entryUUID</code> RFC at <a class="ulink" href="http://rfc-editor.org/rfc/rfc4530.txt">http://rfc-editor.org/rfc/rfc4530.txt</a>.</p><p>The <code class="literal">entryCSN</code> (<strong>Change Sequence Number</strong>) attribute is used by the SyncRepl replication provider to determine what records need to be synchronized between LDAP servers. We will see this in more detail in Chapter 7.</p><p>Finally, the attribute <code class="literal">structuralObjectClass</code> is added. This attribute specifies which of the object classes is to be treated as the structural object class. Recall that when we created our records for Matt and Barbara, each record had three object classes: <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code>. All three are structural object classes, and all three are related (<code class="literal">inetOrgPerson</code> is a child of <code class="literal">organizationalPerson</code>, which in turn is a child of <code class="literal">person</code>). But each record can have only one structural object class. As I noted above, the one farthest down the tree becomes the structural object class, and the others are treated, essentially, as abstract object classes. We can see this if we use <code class="literal">slapcat</code> to dump Barbara's record:</p><div><pre class="programlisting">$ sudo slapcat -a '(uid=barbara)'
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword:: e1BMQUlOfXNlY3JldA==
<strong>objectClass: person</strong>
<strong>objectClass: organizationalPerson</strong>
<strong>objectClass: inetOrgPerson</strong>
<strong>structuralObjectClass: inetOrgPerson</strong>
entryUUID: b1ae9916-c587-102a-9eb7-412127118751
creatorsName: cn=Manager,dc=example,dc=com
modifiersName: cn=Manager,dc=example,dc=com
createTimestamp: 20060821173908Z
modifyTimestamp: 20060821173908Z
<a class="indexterm" id="id208"/>entryCSN: 20060821173908Z#000005#00#000000</pre></div><p>Note that the <code class="literal">structuralObjectClass</code> attribute has the value <code class="literal">inetOrgPerson</code>.</p><p>At this point we've examined the <code class="literal">slapcat</code> tool, as well as the <code class="literal">slapindex</code> and <code class="literal">slapadd</code> tools. These three are the most often used utilities. But there are a few others that can come in handy in certain circumstances. So next, we will look at <code class="literal">slapacl</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>slapacl</h2></div></div></div><a class="indexterm" id="id209"/><a class="indexterm" id="id210"/><a class="indexterm" id="id211"/><p>Writing ACLs can be frustrating and difficult to test. In order to ease the process of testing the efficacy of ACLs in the <code class="literal">slapd.conf</code> file, the OpenLDAP suite includes a tool for testing ACLs directly. We will make greater use of this tool when we test ACLs in Chapter 4, but we will see an introduction to the utility here.</p><p>In Chapter 2, we added the following ACL to <code class="literal">slapd.conf</code>:</p><div><pre class="programlisting">access to attrs=userPassword
       by anonymous auth
       by self write
       by * none</pre></div><p>This ACL specifies that for any given record in the directory, if it has <code class="literal">userPassword</code>, the following rules should be applied to requests for access to that attribute:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">anonymou s</code> user should be able to authenticate using <code class="literal">userPassword</code>.</li><li class="listitem" style="list-style-type: disc">It should allow a DN the permissions to modify (and read) its own password.</li><li class="listitem" style="list-style-type: disc">It should deny all other DNs all access to this record's <code class="literal">userPassword</code>.</li></ul></div><p>That means that <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> should not be able to write a new <code class="literal">userPassword</code> value for <code class="literal">uid=barbara,ou=Users,dc=example,dc=com</code>. We can use the <code class="literal">slapacl</code> utility to test this:</p><div><pre class="programlisting">
<strong>  $ sudo slapacl -v -D "uid=matt,ou=Users,dc=example,dc=com" -b </strong>
<strong>       "uid=barbara,ou=Users,dc=example,dc=com" "userPassword/write"</strong>
</pre></div><p>This command might look daunting at first, but it is actually very simple. Let's look at the arguments in sequence:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-v</code> flag tuns on verbose output.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-D</code> flag is used to tell <code class="literal">slapacl</code> which DN is trying to access the directory. In this case, we said: <code class="literal">-D "uid=matt,ou=Users,dc=example,dc=com"</code>. That is, <code class="literal">slapacl</code> is testing to see if the DN for Matt can get access.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-b</code> flag indicates which record we want the given DN to try to access. In this case it is Barbara's DN, since we want to test if Matt can write Barbara's password: <code class="literal">-b "uid=barbara,ou=Users,dc=example,dc=com"</code>.</li><li class="listitem" style="list-style-type: disc">Finally, the last argument specifies what attribute we want to access, and what sort of privilege we are requesting. In this case, we want the <code class="literal">userPassword</code> attribute, and we want to see if Matt has <code class="literal">write</code> access to it (<code class="literal">"userPassword/write"</code>).</li></ul></div><p>So, in the end, we are testing to see if Matt's DN can write a new <code class="literal">userPassword</code> for Barbara's record. Here is the result of the <code class="literal">slapacl</code> command:</p><div><pre class="programlisting">authcDN: "uid=matt,ou=users,dc=example,dc=com"
write access to userPassword: DENIED</pre></div><p>That's the result we would expect. Because of this ACL, Matt cannot write to Barbara's <code class="literal">userPassword</code> attribute.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>slapauth</h2></div></div></div><a class="indexterm" id="id212"/><a class="indexterm" id="id213"/><a class="indexterm" id="id214"/><p>The <code class="literal">slapauth</code> tool is used to test SASL authentication to the directory. When an application attempts to bind using SASL, instead of specifying a complete DN (like <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code>), the application passes in a user ID (<code class="literal">u: matt</code>) along with a few other bits of information, such as a realm identifier and an authentication mechanism.</p><p>We will cover SASL authentication in Chapter 4. If you do not already have experience with SASL you may want to read on, and come back to this section after reading Chapter 4.</p><p>OpenLDAP can then take that information and use a regular expression to guess what DN that user belongs to. But it can be difficult to figure out what the regular expressions will look like. The slapauth tool is useful in testing what one particular SASL request will look like when OpenLDAP receives it.</p><p>For example, we could add the following SASL configuration directives to our <code class="literal">slapd.conf</code> file:</p><div><pre class="programlisting">authz-policy from
authz-regexp 
  "^uid=([^,]+).*,cn=auth$" 
  "uid=$1,ou=Users,dc=example,dc=com"</pre></div><p>The regular expression in <code class="literal">authz-regexp</code> should convert from a SASL authzID format to an LDAP DN:</p><div><pre class="programlisting">$ sudo slapauth -U "matt" -X "u: matt"
ID: &lt;matt&gt;
authcDN: &lt;uid=matt,ou=users,dc=example,dc=com&gt;
authzDN: &lt;uid=matt,ou=users,dc=example,dc=com&gt;
authorization OK</pre></div><p>The first parameter, <code class="literal">-U matt</code>, sends a test request with the SASL authcID of <code class="literal">matt</code>. The <code class="literal">-X "u: matt"</code> parameter sends a test request with the authzID <code class="literal">u: matt</code>. These should then output a correctly formatted DN, according the the regular expression in <code class="literal">authz-regexp</code>.</p><p>We will use <code class="literal">slapauth</code> more in Chapter 4 when we set up SASL authentication.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>slapdn</h2></div></div></div><a class="indexterm" id="id215"/><a class="indexterm" id="id216"/><a class="indexterm" id="id217"/><p>The <strong><code class="literal">slapdn</code></strong> tool is used to test whether a given DN is valid for this directory server. Specifically, it tests a DN against the defined schemas to make sure that the DN is valid.</p><p>Here are a few examples of <code class="literal">slapdn</code> in action:</p><div><pre class="programlisting">$ sudo slapdn 'cn=Foo,dc=example,dc=com'
DN: &lt;cn=Foo,dc=example,dc=com&gt; check succeeded
normalized: &lt;cn=foo,dc=example,dc=com&gt;
pretty: &lt;cn=Foo,dc=example,dc=com&gt;

$ sudo slapdn 'ou=New Unit,dc=example,dc=com'
DN: &lt;ou=New Unit,dc=example,dc=com&gt; check succeeded
normalized: &lt;ou=new unit,dc=example,dc=com&gt;
pretty: &lt;ou=New Unit,dc=example,dc=com&gt;</pre></div><p>In these two examples, the DNs checked out. <code class="literal">slapdn</code> tested the DNs, and then printed out the normalized version (all lowercase, extra spaces removed) and the pretty (originally formated) version.</p><p>Here's an example of a failure:</p><div><pre class="programlisting">$ sudo slapdn 'fakeAttr=test,dc=example,dc=com'
DN: &lt;fakeAttr=test,dc=example,dc=com&gt; check failed 21 
    (Invalid syntax)</pre></div><p>In this case no schema was found that had the attribute <code class="literal">fakeAttr</code>. Here's another failed case:</p><div><pre class="programlisting">$ sudo slapdn 'documentSeries=Series 18,dc=example,dc=com'
DN: &lt;documentSeries=Series 18,dc=example,dc=com&gt; check failed 21 
    (Invalid syntax)</pre></div><p>While <code class="literal">documentSeries</code> is defined in a schema it is an object class, not an attribute, and object class names cannot be used in constructing DNs.</p><p>The usefulness of the <code class="literal">slapdn</code> program is limited to only rare cases where you need to test a DN against a directory without being able to look at the <code class="literal">slapd.conf</code> file to find out what schemas are loaded (or, alternately, search the schemas using the <code class="literal">ldapsearch</code> program).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>slappasswd</h2></div></div></div><a class="indexterm" id="id218"/><a class="indexterm" id="id219"/><a class="indexterm" id="id220"/><p>The <code class="literal">slappasswd</code> utility is a tool for encrypting passwords according to schemes supported by OpenLDAP, such as the one described in RFC 2307 (<a class="ulink" href="http://rfc-editor.org/rfc/rfc2307.txt">http://rfc-editor.org/rfc/rfc2307.txt</a>).</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Storing and Using Passwords in OpenLDAP</h3></div></div></div><a class="indexterm" id="id221"/><a class="indexterm" id="id222"/><a class="indexterm" id="id223"/><a class="indexterm" id="id224"/><p>When we created our basic LDIF file, we used the <code class="literal">userPassword</code> attribute for storing passwords. For example, our authentication account record looked like this:</p><div><pre class="programlisting"># Special Account for Authentication:
dn: uid=authenticate,ou=System,dc=example,dc=com
uid: authenticate
ou: System
description: Special account for authenticating users
userPassword: secret
objectClass: account
objectClass: simpleSecurityObject</pre></div><p>The <code class="literal">userPassword</code> field has the password in plain text. When the value is loaded into the directory <code class="literal">userPassword</code> is encoded with base-64, and looks like this:</p><div><pre class="programlisting">userPassword:: c2VjcmV0</pre></div><p>But this is not encrypted—just encoded in an easily reversible way. While it might prevent the directory administrator from accidentally seeing the user's password, base-64 encoding will do nothing to prevent an attacker from figuring out the password.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Using the Python scripting language, you can easily encode and decode strings with the built-in <code class="literal">base64.b64encode()</code> and <code class="literal">base64.b64decode()</code> functions.</p></div></div><p>But OpenLDAP does not require you to store passwords in unencrypted text. In fact, it is best if you do not. OpenLDAP supports a number of one-way hashing algorithms that can be used to store the passwords in a way in which they cannot be decrypted.</p><p>The <code class="literal">slappasswd</code> program provides the tools to create a hashed value of a password. That hashed value can then be used in the <code class="literal">userPassword</code> field of an LDIF file.</p><p>OpenLDAP supports five different password hashing schemes: Crypt (<code class="literal">CRYPT</code>), Message Digest 5 (<code class="literal">MD5</code>), salted MD5 (<code class="literal">SMD5</code>), Secure Hashing Algorithm, the SHA-1 version (<code class="literal">SHA</code>), and Salted SHA (<code class="literal">SSHA</code>). By default, OpenLDAP uses the most secure of the available hashing algorithms: <code class="literal">SSHA</code>.</p><p>Passwords are stored in the <code class="literal">userPassword</code> field in a format according to section 5.3 of RFC 2307 (<a class="ulink" href="http://rfc-editor.org/rfc/rfc2307.txt">http://rfc-editor.org/rfc/rfc2307.txt</a>). An encrypted password looks like this:<a class="indexterm" id="id225"/>
<a class="indexterm" id="id226"/>
</p><div><pre class="programlisting">{SSHA}71xEB2E59cuoPEQLErY44bYMHwCCgbtR<a class="indexterm" id="id227"/>
<a class="indexterm" id="id228"/>
</pre></div><p>At the beginning of the password, the section in curly braces (<code class="literal">{}</code>) indicates which of the five password schemes was used. In this case it is the default SSHA algorithm. The remainder of the field is the digested hash of the password.</p><p>While the hashed password cannot be decrypted, when a user tries to bind to the server, OpenLDAP takes the password the user supplies and encrypts it using the same algorithm as the value (and same salt) of the value of <code class="literal">userPassword</code>. If the two hashed passwords match, then OpenLDAP logs the user on. If the two do not match, OpenLDAP responds with an error message indicating that authentication failed.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec26"/>Generating a Password with slappasswd</h3></div></div></div><a class="indexterm" id="id229"/><a class="indexterm" id="id230"/><p>Armed with this basic understanding of how passwords are used and stored, we can now look at the <code class="literal">slappasswd</code> program. This program can be used to encrypt a password and format it for insertion into an LDIF file. The command can be called with no arguments:</p><div><pre class="programlisting">$ slappasswd
New password: 
Re-enter new password: 
{SSHA}71xEB2E59cuoPEQLErY44bYMHwCCgbtR</pre></div><p>In this case, since no parameters were specified on the command line, <code class="literal">slappasswd</code> prompts for a password, and then prompts for verification of the password. Then, it prints out the encrypted value of the password. We can use this value in an LDIF record:</p><div><pre class="programlisting">dn: uid=nicholas,ou=Users,dc=example,dc=com
cn: Nicholas Malebranche
sn: Malebranche
uid: nicholas
ou: Users
userPassword: {SSHA}71xEB2E59cuoPEQLErY44bYMHwCCgbtR
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>In some cases, typing and retyping passwords may be too tedious, and a faster method of encrypting a number of passwords is preferred. You can either use the <code class="literal">-T</code> flag to point to a file containing a list of clear-text passwords to be hashed, or you can specify the password on the command line with the <code class="literal">-s</code> flag:<a class="indexterm" id="id231"/>
</p><div><pre class="programlisting">$ for i in  foo bar baz ; do slappasswd -s $i; done
{SSHA}p3zm8Sq/jgAMxYkniwnu+ym954qjIRiG
{SSHA}Fklv7m0n0wIw8sLQOe2IxDRsexZegzUT
{SSHA}FOLOLnR0fgmw7jP8p1WRQEJXoX3fJsyG</pre></div><p>In this shell command, each of the three clear-text passwords, <code class="literal">foo</code>, <code class="literal">bar</code>, and <code class="literal">baz</code>, are encrypted by <code class="literal">slappasswd</code>.<a class="indexterm" id="id232"/>
</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>On a multi-user system, other users may have access to your command history, and thus would be able to see these passwords in cleartext. Caution should be used when specifying passwords (or other sensitive information) on the command line.</p></div></div><p>By using the <code class="literal">-h</code> flag, you can specify which hashing algorithm <code class="literal">slappasswd</code> should use:</p><div><pre class="programlisting">$ slappasswd -h {MD5} -s test
{MD5}CY9rzUYh03PK3k6DJie09g==
$ slappasswd -h {SMD5} -s test
{SMD5}vWw5aAcoIbJ1PS9BMnp/KF5XS5g=
$ slappasswd -h {SHA} -s test
{SHA}qUqP5cyxm6YcTAhz05Hph5gvu9M=</pre></div><p>In the above commands, the same password, <code class="literal">test</code>, is encrypted using three different hashing schemes.</p><p>Next we will turn to the last OpenLDAP utility—<code class="literal">slaptest</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>slaptest</h2></div></div></div><a class="indexterm" id="id233"/><a class="indexterm" id="id234"/><a class="indexterm" id="id235"/><p>The <code class="literal">slaptest</code> utility is used for checking the format and directives used in the <code class="literal">slapd.conf</code> file (and any files included by <code class="literal">slapd.conf</code>).</p><p>Running <code class="literal">slaptest</code> is simple:</p><div><pre class="programlisting">
<strong>  $ slaptest -v -f /etc/ldap/slapd.conf</strong>
</pre></div><p>The <code class="literal">-v</code> flag turns on verbose output, and the <code class="literal">-f</code> flag, which takes one argument, specifies which configuration file to check. If <code class="literal">-f</code> is omitted, then the default <code class="literal">slapd.conf</code> file (usually <code class="literal">/etc/ldap/slapd.conf</code>) is checked.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>As noted in the previous chapter, the version of <code class="literal">slaptest</code> provided by Ubuntu Linux does not print warnings if a directive in <code class="literal">slapd</code> is unknown. This is non-standard behavior. Most of the time OpenLDAP is compiled with such warnings enabled.</p></div></div><p>If the configuration file is correctly formatted and the directives are all valid and operational, then <code class="literal">slaptest</code> will print out a basic success message:</p><div><pre class="programlisting">config file testing succeeded</pre></div><p>If anything goes wrong however, <code class="literal">slaptest</code> will print out diagnostic information. For example, if I add an include directive to <code class="literal">slapd.conf</code> that points to a file that does not exist, <code class="literal">slaptest</code> will print an error:</p><div><pre class="programlisting">$ sudo slaptest 
could not stat config file "/non/existent/file": No such file or 
    directory (2)
slaptest: bad configuration file!</pre></div><p>This output should be helpful for tracking down the problem in the configuration files. In this case it was caused by a line that looks like this:</p><div><pre class="programlisting">include /non/existent/file</pre></div><p>This is the last of the OpenLDAP utilities. Now we will turn to the client applications that are included with the OpenLDAP suite.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Performing Directory Operations Using the Clients</h1></div></div></div><a class="indexterm" id="id236"/><a class="indexterm" id="id237"/><p>There are a host of OpenLDAP clients, all stored at <code class="literal">/usr/bin</code> (or <code class="literal">/usr/local/bin</code> if you compiled according to <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>). The OpenLDAP clients communicate over the LDAP protocol. They are all standards-compliant, and follow the LDAPv3 protocol (which was last updated in June 2006).</p><p>While some of the clients provide the basic standardized LDAP operations, such as search, add, and delete, others implement one or more of the LDAP extensions. But since the suite of tools does follow the standards, these tools should work against any standards-compliant LDAP directory server.</p><p>In this part of the chapter we will take a brief look at each of the OpenLDAP clients and see how they can be used to interact with an LDAP server. We do not have the space to cover all of the details of each client, so we will focus on the most useful and common features of each client. The OpenLDAP man pages (which are installed with OpenLDAP) are detailed and informative, and they provide a good source of further information for these clients.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Most of the utilities in the last part required that the SLAPD server must not not be running. All of the tools in this section, however, connect to a SLAPD server. So make sure your server is running before trying the examples in this part.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Common Command-Line Flags</h2></div></div></div><a class="indexterm" id="id238"/><a class="indexterm" id="id239"/><p>All of the OpenLDAP clients are command-line applications that use UNIX-style flags to pass parameters to the program. For the sake of continuity common flags (like <code class="literal">-D</code>, <code class="literal">-b</code>, and <code class="literal">-H</code>) are used consistently across all of the clients.</p><p>In Chapter 2 we configured our directory server to handle basic directory operations. However, we did not configure it to use SASL authentication (which is covered in Chapter 4). To authenticate to the server we will be using what is called <strong>simple binding</strong>. In simple binding the client authenticates by sending a full DN and password to the server.</p><p>The clients require different command-line flags depending on whether they do a simple bind or a <strong>SASL bind</strong>. Now we will see those necessary for simple binding. Those flags needed for SASL binding are covered in Chapter 4.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Common Flags</h3></div></div></div><a class="indexterm" id="id240"/><p>There are command-line flags for the simple binding process. Some of the common flags are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-D</code>: The <code class="literal">-D</code> flag is used to specify the full DN of the user who will bind to the directory server (this is used for simple binding).</li><li class="listitem" style="list-style-type: disc"><code class="literal">-W</code>, <code class="literal">-w</code>, <code class="literal">-y</code>: Each of these flags indicates a different source for the password. Let's see them one by one:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-W</code> flag indicates that the user should be interactively prompted to enter a password.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-w</code> flag takes the password string for a value. We can use it to specify the password on the command line.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-y</code> flag takes a file name as an argument. It will use the contents of the file as a password. These flags are mutually exclusive—you can only use one of these per command.</li></ul></div><div><div><h3 class="title"><a id="note33"/>Note</h3><p>The <code class="literal">-y</code> flag uses the entire contents of a file for the password. This means that if there is a line break in the file, it will be treated like part of the password. To create a password file, you can use the <code class="literal">echo</code> command with the <code class="literal">-n</code> flag: <code class="literal">$ echo -n "secret" &gt; my_pw</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">-x</code>: The <code class="literal">-x</code> flag specifies that the client will use a simple bind. If this is not specified, the client will try a SASL bind.<a class="indexterm" id="id241"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">-H</code>, <code class="literal">-h</code>: These two flags provide different ways of specifying which host to connect to. <code class="literal">-H</code> takes an LDAP URL (<code class="literal">-H 'ldap://example.com:389'</code>). <code class="literal">-h</code> simply takes the host name (<code class="literal">-h example.com</code>), and can be used with <code class="literal">-p</code> to specify a port. Unless you do not have a choice, use <code class="literal">-H</code>. The <code class="literal">-h</code> flag is provided only for backward compatibility, and may disappear in future versions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-Z</code>: This flag is used to indicate that the client should issue a <strong>Start TLS</strong> command to the server, so that traffic is encrypted according to the TLS standard. But if TLS negotiation fails, the client will still continue to operate. Using two Z's (<code class="literal">-ZZ</code>) will make it mandatory that the traffic be encrypted. If negotiation fails, then the client will disconnect. TLS is covered in more detail in the next chapter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-b</code>: This is used to specify a base DN (<code class="literal">-b 'dc=example,dc=com'</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">-f</code>: The <code class="literal">-f</code> flag takes a filename as a parameter. The client will then read the contents of the file and build requests based on the contents of the file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-v</code>: This flag will turn on verbose output. It is useful when troubleshooting.</li></ul></div><p>These are the common flags used by the clients in the OpenLDAP suite. But these represent only a subset of the flags used by each client, as each client implements the flags needed to accomplish its task.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Setting Defaults in ldap.conf</h3></div></div></div><a class="indexterm" id="id242"/><p>In Chapter 2, in the section entitled <em>Configuring the LDAP Clients</em>, we looked at the <code class="literal">ldap.conf</code> file. In that file, we set some useful defaults. In particular we set these three:</p><div><pre class="programlisting">URI ldap://localhost
BASE dc=example,dc=com
BINDDN cn=Manager,dc=example,dc=com</pre></div><p>If you omit host settings (<code class="literal">-H</code>, <code class="literal">-h</code>), then the value of <code class="literal">URI</code> will be used. If the client needs a base DN, and none is set with the <code class="literal">-b</code> flag, then the value of <code class="literal">BASE</code> is used. Likewise, if the client uses simple binding (with <code class="literal">-x</code>), and doesn't specify a DN with <code class="literal">-D</code>, then the value of <code class="literal">BINDDN</code> will be used.</p><p>Since we have an <code class="literal">ldap.conf</code> file created already, many of the examples will omit the <code class="literal">-H</code> and <code class="literal">-b</code> flags.</p><p>While <code class="literal">ldap.conf</code> is shared by all clients, you can create a user-specific LDAP configuration file in your home directory. The LDAP clients will look for user-specific configuration files named <code class="literal">ldaprc</code> and <code class="literal">.ldaprc</code> in your home directory (<code class="literal">$HOME</code>).</p><p>Now we are ready to look at the client commands.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>ldapsearch</h2></div></div></div><a class="indexterm" id="id243"/><a class="indexterm" id="id244"/><a class="indexterm" id="id245"/><p>The first client we will look at is also the most often used tool: <code class="literal">ldapsearch</code>. As the name suggests, this is a tool for searching the directory information tree.</p><p>The <code class="literal">ldapsearch</code> client connects to the server, authenticates a user, and then (as that user) runs one or more <strong>search operations</strong>, returning the results in LDIF format. When it is done performing searches, it closes the connection and exits. Since <code class="literal">ldapsearch</code> is a network client it can be used to search both local directories or a remote directory server.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec29"/>A Simple Search</h3></div></div></div><a class="indexterm" id="id246"/><p>Let's take a look at a simple search command. In this command we will log in as the directory manager and request the record for the entry with the user ID <em>barbara</em>:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -W -D 'cn=Manager,dc=example,dc=com' -b \ </strong>
<strong>    'ou=Users,dc=example,dc=com' '(uid=barbara)'</strong>
</pre></div><p>Here is the result:</p><div><pre class="programlisting">Enter LDAP Password: 
# extended LDIF
#
# LDAPv3
# base &lt;ou=Users,dc=example,dc=com&gt; with scope subtree
# filter: (uid=barbara)
# requesting: ALL
#

# barbara, Users, example.com
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword:: c2VjcmV0
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1</pre></div><p>In this example we ran the <code class="literal">ldapsearch</code> command with four flags: <code class="literal">-x</code>, <code class="literal">-W</code>, <code class="literal">-D</code>, and <code class="literal">-b</code>. For a description of these flags see the <em>Common Command-Line Flags</em> section. In a nutshell though, <code class="literal">-x</code>, <code class="literal">-W</code>, and <code class="literal">-D</code> are all parameters used for authenticating to the directory. They instruct the client to bind to the directory with simple authentication (<code class="literal">-x</code>) as the DN specified by <code class="literal">-D</code> (the directory manager in this case), then prompt the user to enter a password interactively (<code class="literal">-W</code>).</p><p>The <code class="literal">-b</code> flag sets the base DN for the search. This is set to <code class="literal">ou=Users,dc=example,dc=com</code>. Given this, <code class="literal">ldapsearch</code> will start searching in the <code class="literal">Users</code> OU.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>If we had omitted the <code class="literal">-b</code> flag, the value of BASE in <code class="literal">ldap.conf</code> would have been used, which would have set the base DN to <code class="literal">dc=example,dc=com</code>.</p></div></div><p>After all of the command-line flags and their arguments, we specified an LDAP filter:</p><div><pre class="programlisting">(uid=barbara)</pre></div><p>This is the filter that the server will use for searching. We covered search filters in more detail earlier in this chapter, in the section entitled <em>The</em> <em>Search</em> <em>Operation</em>. In this case though, the search filter is straightforward: it matches only records that have the attribute named <code class="literal">uid</code> with the attribute value of <code class="literal">barbara</code>.</p><div><div><h3 class="title"><a id="note35"/>Note</h3><p>Many attributes have more than one name (these are properly called <strong>attribute descriptions</strong>). For example, the attribute that labels user IDs has the attribute descriptions <code class="literal">uid</code> and <code class="literal">userID</code>. In the case above, a search for <code class="literal">(uid=barbara)</code> will also match directory entries with and attribute of the form <code class="literal">userID: barbara</code>.</p></div></div><p>When this command is run, it will first prompt the user to enter a password (because of the <code class="literal">-W</code> flag), and then connect to the server and attempt to bind as the specified DN (<code class="literal">cn=Manager,dc=example,dc=com</code>). Then, if the bind is successful, it will request all records that match the filter, <code class="literal">(uid=barbara)</code>. As the example illustrates, the server will return the entire record of the user, or as much of it as the ACLs allow, in the case of a non-manager user.</p><p>The results are returned in LDIF format, with comments sprinkled throughout. The first set of comments provides basic information about the search:</p><div><pre class="programlisting"># extended LDIF
#
# LDAPv3
# base &lt;ou=Users,dc=example,dc=com&gt; with scope subtree
# filter: (userID=barbara)
# requesting: ALL
#</pre></div><p>The first line indicates that this record is in extended LDIF format. This is LDIF version 1.0, plus some comments. Beneath that, we get a summary of the search, including the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Version of LDAP used (v3)</li><li class="listitem" style="list-style-type: disc">What the base DN is (<code class="literal">ou=Users,dc=example,dc=com</code>).</li><li class="listitem" style="list-style-type: disc">What type of search will be performed. In this case, it is a <strong>subtree search</strong>, which means the server will look in all records beneath the base DN.</li><li class="listitem" style="list-style-type: disc">What the operating search filter is (<code class="literal">(userid=barbara)</code>).</li><li class="listitem" style="list-style-type: disc">What attributes the client wants returned. <code class="literal">ALL</code> indicates that the client wants all available attributes returned.</li></ul></div><p>The central part of the file contains the full record for Barbara. Beneath the record is a brief summary of the results:</p><div><pre class="programlisting">search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1</pre></div><p>The first line, <code class="literal">search</code>, indicates that we performed two search operations (one for binding and one to execute the filtered search).</p><p>The second, <code class="literal">result</code>, inidcates the result code that the server sent back. <code class="literal">0 Success</code> indicates that our search ran without encountering any errors.</p><p>The extended (and thus commented) results add some additional information. <code class="literal">numResponses</code> indicates that the server sent two responses back to the client (one for the bind, one for the search). And <code class="literal">numEntries</code> indicates how many entries were returned by the search. In this case there was only one—Barbara's record.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec30"/>Restricting Returned Fields</h3></div></div></div><a class="indexterm" id="id247"/><p>Sometimes we don't want to get a DN's entire record back. Instead, we just want a couple of attributes. This can be accomplished by specifying a list of attributes at the end of the command:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -b \ </strong>
<strong>          'ou=Users,dc=example,dc=com' -LLL '(userID=matt)' mail cn</strong>
</pre></div><p>Here is the result:</p><div><pre class="programlisting">dn: uid=matt,ou=Users,dc=example,dc=com
cn: Matt Butcher
mail: mbutcher@example.com
mail: matt@example.com</pre></div><p>Note that in this example we used the <code class="literal">-w secret</code> flag to specify the password on the command line. We also used the <code class="literal">-LLL</code> flag to suppress all of the extraneous comments printed in the LDIF output.</p><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Specifying the password on the command line can be a security risk. Other users on the system may be able to access this information through command-line histories (like the Bash shell's history feature) and operating system constructs (like the <code class="literal">/proc</code> file system in Linux).</p></div></div><p>In addition to the filter, <code class="literal">(userID=matt)</code>, I also added a list of attributes that I wanted returned: <code class="literal">cn</code> and <code class="literal">mail</code>. The returned record contained four lines: the <code class="literal">dn</code>, the two <code class="literal">mail</code> attributes, and the <code class="literal">cn</code> attribute. The DN is always returned.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec31"/>Requesting Operational Attributes</h3></div></div></div><a class="indexterm" id="id248"/><p>You may have noticed that the record returned for Barbara by <code class="literal">ldapsearch</code> is quite a bit different than the record returned by <code class="literal">slapcat</code>.</p><div><div><h3 class="title"><a id="note36"/>Note</h3><p>We covered <code class="literal">slapcat</code> in the part of this chapter entitled <em>Using the Utilities to Prepare the Directory</em>.</p></div></div><p>Let's compare the two. First, here's the <code class="literal">ldapsearch</code> output:</p><div><pre class="programlisting">$ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -b 
'ou=Users,dc=example,dc=com' -LLL '(userID=barbara)'
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword:: c2VjcmV0
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>Now, here's the <code class="literal">slapcat</code> output:<a class="indexterm" id="id249"/>
</p><div><pre class="programlisting">$ sudo slapcat -a '(uid=barbara)'
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword:: c2VjcmV0
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
structuralObjectClass: inetOrgPerson
entryUUID: bec561c4-c5b0-102a-81c0-81bc30f92d57
creatorsName: cn=Manager,dc=example,dc=com
modifiersName: cn=Manager,dc=example,dc=com
createTimestamp: 20060821223300Z
modifyTimestamp: 20060821223300Z
entryCSN: 20060821223300Z#000005#00#000000</pre></div><p>The output of <code class="literal">slapcat</code> has a host of additional attributes—namely the special operational attributes that the directory maintains internally. We can retrieve the operational attributes with <code class="literal">ldapsearch</code> either by specifying them by name along with the list of desired attributes, or by using the special plus sign (<code class="literal">+</code>) attribute list specifier at the end of the <code class="literal">ldapsearch</code> command:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -b </strong>
<strong>       'ou=Users,dc=example,dc=com' -LLL '(userID=barbara)' +</strong>
</pre></div><p>And, this is what we get:</p><div><pre class="programlisting">dn: uid=barbara,ou=Users,dc=example,dc=com
structuralObjectClass: inetOrgPerson
entryUUID: bec561c4-c5b0-102a-81c0-81bc30f92d57
creatorsName: cn=Manager,dc=example,dc=com
modifiersName: cn=Manager,dc=example,dc=com
createTimestamp: 20060821223300Z
modifyTimestamp: 20060821223300Z
entryCSN: 20060821223300Z#000005#00#000000
entryDN: uid=barbara,ou=Users,dc=example,dc=com
subschemaSubentry: cn=Subschema
hasSubordinates: FALSE<a class="indexterm" id="id250"/>
</pre></div><p>Specifying the <code class="literal">+</code> list does not return all attributes—only the operational attributes. To get all of the regular attributes and all of the operational attributes, you will need both the <code class="literal">+</code> specifier and the <code class="literal">*</code> (asterisk) specifier. The <code class="literal">*</code> specifier indicates that we want all of the standard attributes. This is the output:</p><div><pre class="programlisting">$ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -b 
     'ou=Users,dc=example,dc=com' -LLL '(userID=barbara)' '*' +
dn: uid=barbara,ou=Users,dc=example,dc=com
ou: Users
uid: barbara
sn: Jensen
cn: Barbara Jensen
givenName: Barbara
displayName: Barbara Jensen
mail: barbara@example.com
userPassword:: c2VjcmV0
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
structuralObjectClass: inetOrgPerson
entryUUID: bec561c4-c5b0-102a-81c0-81bc30f92d57
creatorsName: cn=Manager,dc=example,dc=com
modifiersName: cn=Manager,dc=example,dc=com
createTimestamp: 20060821223300Z
modifyTimestamp: 20060821223300Z
entryCSN: 20060821223300Z#000005#00#000000
entryDN: uid=barbara,ou=Users,dc=example,dc=com
subschemaSubentry: cn=Subschema
hasSubordinates: FALSE</pre></div><p>Now we have the complete list of attributes. Using this combination of arguments, we can generate LDIF files suitable for making backups (assuming the ACLs are not preventing access to something). While <code class="literal">slapcat</code> will outperform <code class="literal">ldapsearch</code> for this task, the fact that <code class="literal">ldapsearch</code> can run remotely over the network is attractive in many cases.</p><div><div><h3 class="title"><a id="note37"/>Note</h3><p>Note that in the given record, <code class="literal">ldapsearch</code> has returned three operational attributes that do not show up with <code class="literal">slapcat</code>: <code class="literal">entryDN</code>, <code class="literal">subschemaSubentry</code>, and <code class="literal">hasSubordinates</code>. These values are generated dynamically at runtime and do not exist in the LDAP backend. For that reason they are not exported with <code class="literal">slapcat</code>. Since they are generated dynamically, they are not useful values to back up.</p></div></div><p>It is also possible to run multiple queries in sequence using <code class="literal">ldapsearch</code>. This is done <a class="indexterm" id="id251"/>by using an external file to store filter information for multiple searches.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec32"/>Searching Using a File</h3></div></div></div><a class="indexterm" id="id252"/><p>The <code class="literal">ldapsearch</code> client can use a file to build and execute multiple queries. Let's say we have a plain text list of user IDs, and we want to get the last name for each user ID. The file, <code class="literal">userIDs.txt</code>, looks like this:</p><div><pre class="programlisting">matt
barbara</pre></div><p>We can use <code class="literal">ldapsearch</code> to dynamically build a filter and run a search for each user's surname. To do this, we use the <code class="literal">-f</code> flag, and point to the <code class="literal">userIDs.txt</code> file, and then we build a special filter. Here is the command line to be executed:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -b \</strong>
<strong>     'ou=Users,dc=example,dc=com' -w secret -f userIDs.txt '(uid=%s)' sn</strong>
</pre></div><p>Most of this should look familiar, by now. But notice the filter: <code class="literal">'(uid=%s)'</code>. This filter uses the special <code class="literal">%s</code> placeholder to indicate where the values from the file ought to be placed. As <code class="literal">ldapsearch</code> runs, it will read through the <code class="literal">userIDs.txt</code> file line by line, and with each line, it will execute a search, substituting the value of the line for <code class="literal">%s</code> in the filter. The results look like this:</p><div><pre class="programlisting"># extended LDIF
#
# LDAPv3
# base &lt;ou=Users,dc=example,dc=com&gt; with scope subtree
# filter pattern: (uid=%s)
# requesting: sn 
#

#
# filter: (uid=matt)
#
# matt, Users, example.com
dn: uid=matt,ou=Users,dc=example,dc=com
sn: Butcher

# search result
search: 2
result: 0 Success

# numResponses: 2
# numEntries: 1

#
# filter: (uid=barbara)
#
# barbara, Users, example.com
dn: uid=barbara,ou=Users,dc=example,dc=com
sn: Jensen

# search result
search: 3
result: 0 Success

# numResponses: 2
# numEntries: 1</pre></div><p>In this example the <code class="literal">ldapsearch</code> client actually ran two different search operations. It first expanded <code class="literal">(uid=%s)</code> to <code class="literal">(uid=matt)</code> and ran a search; then, it expanded <code class="literal">(uid=%s)</code> to <code class="literal">(uid=barbara)</code>, and ran another search. In each case, it returned only the <code class="literal">dn</code> (which is always returned for a match) and the requested <code class="literal">sn</code> attribute.</p><p>You can also create filters in a file, and have multiple search filters run. For example, we could create a file named <code class="literal">filters.txt</code> with the following lines:</p><div><pre class="programlisting">&amp;(ou=System)(objectClass=account)
&amp;(uid=b*)(ou=Users)</pre></div><p>Since each line will be inserted into a filter, we do not need the outer set of parentheses. Now we can use these lines to dynamically build filters with <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -D 'cn=Manager,dc=example,dc=com' -b \</strong>
<strong>      'dc=example,dc=com' -w secret -f filters.txt '(%s)' cn description</strong>
</pre></div><p>We will get this output:</p><div><pre class="programlisting"># extended LDIF
#
# LDAPv3
# base &lt;dc=example,dc=com&gt; with scope subtree
# filter pattern: (%s)
# requesting: cn description 
#

#
# filter: (&amp;(ou=System)(objectClass=account))
#
# authenticate, System, example.com
dn: uid=authenticate,ou=System,dc=example,dc=com
description: Special account for authenticating users

# search result
search: 2
result: 0 Success
<a class="indexterm" id="id253"/>
# numResponses: 2
# numEntries: 1

#
# filter: (&amp;(uid=b*)(ou=Users))
#
# barbara, Users, example.com
dn: uid=barbara,ou=Users,dc=example,dc=com
cn: Barbara Jensen
# search result
search: 3
result: 0 Success

# numResponses: 2
# numEntries: 1</pre></div><p>In this case the filter <code class="literal">(%s)</code> was expanded in the first case to <code class="literal">(&amp;(ou=System)(objectClass=account))</code>, and in the second case to <code class="literal">(&amp;(uid=b*)(ou=Users))</code>.</p><p>Using techniques like this it becomes possible to execute a number of complex searches with one command.</p><p>We will continue using the <code class="literal">ldapsearch</code> client throughout this book. Now that we have a basic idea as to how it works, we will move on to the next client in the OpenLDAP suite.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>ldapadd</h2></div></div></div><a class="indexterm" id="id254"/><a class="indexterm" id="id255"/><a class="indexterm" id="id256"/><p>This is a command-line program used for adding new entries to an LDAP directory. The <code class="literal">ldapadd</code> command is not actually a stand-alone client. It is just a link to the <code class="literal">ldapmodify</code> program. When <code class="literal">ldapmodify</code> sees that it has been called as <code class="literal">ldapadd</code>, it will assume that it should request that the server perform an <strong>add operation</strong>, instead of requesting a modify operation.</p><p>In the most simple case, <code class="literal">ldapadd</code> can be used to enter a new record from the command line:</p><div><pre class="programlisting">$ ldapadd -x -W -D 'cn=Manager,dc=example,dc=com'
Enter LDAP Password: </pre></div><p>Once we have been successfully authenticated, the cursor will move to the next line and wait for the input. We can directly enter a record. As soon as we hit <em>Enter</em> twice (creating a blank line, which indicates the end of a record), <code class="literal">ldapadd</code> will send the record to the server:</p><div><pre class="programlisting">
<strong>dn: uid=adam,ou=Users,dc=example,dc=com</strong>
<strong>cn: Adam Smith</strong>
<strong>sn: Smith</strong>
<strong>uid: adam</strong>
<strong>ou: Users</strong>
<strong>objectClass: person</strong>
<strong>objectClass: organizationalPerson</strong>
<strong>objectClass: inetOrgPerson</strong>

adding new entry "uid=adam,ou=Users,dc=example,dc=com"</pre></div><p>The highlighted portion is the text that we entered. It specifies one entire record (a record for a user named Adam Smith).</p><p>After we pressed the return key twice, inserting a blank line, the record was sent to the server. The client indicated that it was adding the record: <code class="literal">adding new entry "uid=adam,ou=Users,dc=example,dc=com"</code>. No error message followed. This means that the add was successful.</p><p>Once a record is added the cursor will move to a blank line, waiting for the <code class="literal">dn</code> attribute of the next record.</p><div><pre class="programlisting">
<strong>dn: cn=Foo,dc=example,dc=com</strong>
<strong>farble: gork</strong>
<strong>objectClass: account</strong>

adding new entry "cn=Foo,dc=example,dc=com"
ldap_add: Undefined attribute type (17)
        additional info: farble: attribute type undefined</pre></div><p>In this example the record that we entered (again, highlighted) contained an undefined attribute, and the server balked with the same error message. In cases where the server sends an error message, the <code class="literal">ldapadd</code> client prints the error message and exits. To re-enter the record you will have to re-run <code class="literal">ldapadd</code>.</p><p>But as long as new records are valid and the server does not report an error, <code class="literal">ldapadd</code> will continue prompting (or rather listening) for new records. When finished, use the <em>CTRL</em>-<em>C</em> key combination to exit the program.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec33"/>Adding Records from a File</h3></div></div></div><a class="indexterm" id="id257"/><p>While typing a record directly into the client may be useful on occasion, in most cases it is far more convenient (and less error prone) to create the records in a plain text file, and then load them all at once with the <code class="literal">ldapadd</code> program.</p><p>As usual, the records in the text file should be formated in LDIF. Here, for example, are the contents of the file <code class="literal">user_records.ldif</code>:</p><div><pre class="programlisting">dn: uid=david,ou=Users,dc=example,dc=com
cn: David Hume
sn: Hume
uid: david
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson

dn: uid=immanuel,ou=Users,dc=example,dc=com
cn: Immanuel Kant
sn: Kant
uid: immanuel
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>We can add all of the records in a file:</p><div><pre class="programlisting">$ ldapadd -x -w secret -D 'cn=Manager,dc=example,dc=com' -f \
     user_records.ldif
adding new entry "uid=david,ou=Users,dc=example,dc=com"

adding new entry "uid=immanuel,ou=Users,dc=example,dc=com"</pre></div><p>Just as when we added records interactively, here the absence of an error message indicates that the record was successfully added.</p><p>Next we will look at modifying records that already exist in the directory.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>ldapmodify</h2></div></div></div><a class="indexterm" id="id258"/><a class="indexterm" id="id259"/><a class="indexterm" id="id260"/><p>The <code class="literal">ldapmodify</code> program is used to modify an existing entry. It can add, change, and delete the attributes of a entries in the directory. It can also be used to add new entries (together with attributes for the entry).</p><p>Like <code class="literal">ldapadd</code>, <code class="literal">ldapmodify</code> can be run interactively. It can be used to add, modify, and remove records.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec34"/>Adding a Record with ldapmodify</h3></div></div></div><a class="indexterm" id="id261"/><p>The syntax for adding a record is almost identical in <code class="literal">ldapmodify</code> to that of <code class="literal">ldapadd</code>:</p><div><pre class="programlisting">
<strong>  $ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'</strong>
</pre></div><p>Here is the result:</p><div><pre class="programlisting">
dn: uid=nicholas,ou=Users,dc=example,dc=com
changetype: add
cn: Nicholas Malebranche
sn: Malebranche
uid: nicholas
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson

adding new entry "uid=nicholas,ou=Users,dc=example,dc=com"</pre></div><p>The only difference is the addition of the <code class="literal">changetype</code> instruction after the <code class="literal">dn</code>. This tells <code class="literal">ldapmodify</code> what sort of LDAP operation should be performed on this record.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>The <code class="literal">changetype</code> instruction is not an attribute, though it looks like one. It is not part of the record, but rather an instruction (in LDIF format) to tell the server what operation it should use.</p></div></div><p>There are four possible values for <code class="literal">changetype</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">modify</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">modrdn</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code></li></ul></div><p>Each of these corresponds to an LDAP operation. The <code class="literal">add</code> change-type is used to add a new record (essentially performing the same add operation as <code class="literal">ldapadd</code>). The <code class="literal">modify</code> change-type takes an existing record and modifies it in some way (for example, by adding, replacing, or removing attributes). The <code class="literal">modrdn</code> change-type changes the relative DN (or RDN) of a record. The <code class="literal">delete</code> change-type deletes the entire record from the directory server.<a class="indexterm" id="id262"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec35"/>Modifying Existing Records</h3></div></div></div><a class="indexterm" id="id263"/><p>Usually it is easier to add records with <code class="literal">ldapadd</code>. Where the <code class="literal">ldapmodify</code> client really shines is in its ability to modify existing records, adding, removing, or replacing attributes within a record.</p><p>Let's add a <code class="literal">givenName</code> field to one of the records we added in the last section:</p><div><pre class="programlisting">
<strong>  $ ldapmodify -x -W -D 'cn=Manager,dc=example,dc=com'</strong>
</pre></div><p>This gives the following output:</p><div><pre class="programlisting">
Enter LDAP Password: 
dn: uid=david,ou=Users,dc=example,dc=com
changetype: modify
add: givenName
givenName: David 

modifying entry "uid=david,ou=Users,dc=example,dc=com"</pre></div><p>Just as with <code class="literal">ldapadd</code>, once the authentication phase has been done, <code class="literal">ldapmodify</code> waits for a DN to be given. After the <code class="literal">dn</code> attribute is specified, the <code class="literal">changetype</code> should follow.</p><p>When using a <code class="literal">modify</code> change-type, as we do here, we must also specify exactly what attributes we are going to change, and how we will change them. The modify change-type is the only type that requires this further specification. Here is the figure displaying the several change-types:</p><div><img alt="Modifying Existing Records" src="img/1021_03_11.jpg"/></div><p>In this case, we want to add a new attribute to the the <code class="literal">uid=david</code>, <code class="literal">ou=Users</code>, <code class="literal">dc=example</code>, <code class="literal">dc=com</code> record. And the attribute we want to add is <code class="literal">givenName</code>. So, the line that specifies that we will add a <code class="literal">givenName</code> attribute reads <code class="literal">add: givenName</code>.</p><p>Next, we want to specify the attribute and attribute value:</p><div><pre class="programlisting">givenName: David</pre></div><p>Then, by hitting <em>Enter</em> twice, we indicate that the record is complete. Just as with <code class="literal">ldapadd</code>, <code class="literal">ldapmodify</code> indicates which record it is modifying. If the server does not return an error, <code class="literal">ldapmodify</code> will wait for another modify record.</p><p>The<a class="indexterm" id="id264"/> <code class="literal">add</code> modification type is one of three that <code class="literal">ldapmodify</code> supports. Operations can only be specified if the change-type is set to modify. The three modification types are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add</code>: Adds new attributes to an existing record</li><li class="listitem" style="list-style-type: disc"><code class="literal">replace</code>: Replaces existing attribute values with new attribute values</li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code>: Removes attributes from the record</li></ul></div><p>More than one of these operations can be done in a single transaction:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'
dn: uid=immanuel,ou=Users,dc=example,dc=com
changetype: modify
add: givenName
givenName: Manny
-
replace: cn
cn: Manny Kant

modifying entry "uid=immanuel,ou=Users,dc=example,dc=com"</pre></div><p>In this example we first add <code class="literal">givenName</code>, and then replace the existing <code class="literal">cn</code> value with a new one. Between the two modification requests we use a dash (<code class="literal">-</code>) to indicate that we are still working on the same record. Remember, a blank line indicates that we are done with the record. Now, if we look up the record with <code class="literal">ldapsearch</code>, it looks like this:</p><div><pre class="programlisting">$ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -LLL \
     '(uid=immanuel)'

dn: uid=immanuel,ou=Users,dc=example,dc=com
sn: Kant
uid: immanuel
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
givenName: Manny
cn: Manny Kant</pre></div><a class="indexterm" id="id265"/><p>The <code class="literal">cn</code> has been replaced, and the <code class="literal">givenName</code> attribute has been added.</p><p>If the modification is adding several attributes, rather than splitting the additions up using dashes, you can group them together:</p><div><pre class="programlisting">dn: uid=nicholas,ou=Users,dc=example,dc=com
changetype: modify
add: description title
description: This is a test
title: Cartesian philosopher</pre></div><p>Note that, in this case, the <code class="literal">add</code> line has two attribute names (<code class="literal">description</code> and <code class="literal">title</code>), followed by both attributes. And just as with <code class="literal">ldapadd</code>, we can put these change records into a plain text file, and then use the <code class="literal">-f</code> flag, which takes the path to a file, to have <code class="literal">ldapmodify</code> read the commands from the file instead of from the interactive prompt:</p><div><pre class="programlisting">$ ldapmodify -x -w secret -D 'cn=Manager,dc=example,dc=com' -f \
     change-nicholas.ldif 
modifying entry "uid=nicholas,ou=Users,dc=example,dc=com"</pre></div><p>Using the <code class="literal">modify</code> change-type we can delete an attribute:</p><div><pre class="programlisting">dn: uid=nicholas,ou=Users,dc=example,dc=com
changetype: modify
delete: title</pre></div><p>Deleting an attribute from the record has the result of deleting all of the attribute values from the record. For example, if Nicholas had two titles specified, the above would remove them both.</p><p>To delete just one specific attribute, the request must also name the attribute value to be deleted:</p><div><pre class="programlisting">dn: uid=nicholas,ou=Users,dc=example,dc=com
changetype: modify
delete: title
title: Cartesian philosopher</pre></div><p>That will delete any <code class="literal">title</code> attribute values that contain the exact string "Cartesian philosopher", leaving any other attribute values intact.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec36"/>
<a class="indexterm" id="id266"/>Modifying the Relative DN
</h3></div></div></div><p>The<a class="indexterm" id="id267"/> third change type is for modifying relative DNs—the portion of the DN that identifies the current record (see the discussion at the beginning of this chapter).</p><p>For example, we can change the RDN portion of the DN for our user <code class="literal">uid=immanuel,ou=Users,dc=example,dc=com</code>:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'
dn: uid=immanuel,ou=Users,dc=example,dc=com
changetype: modrdn
newrdn: uid=manny
deleteoldrdn: 0

modifying rdn of entry "uid=immanuel,ou=Users,dc=example,dc=com"
rename completed</pre></div><p>In this example, we use the <code class="literal">modrdn</code> change-type to instruct SLAPD to change the RDN portion of the user's DN. The <code class="literal">newrdn</code> instruction supplies the new RDN portion, and the <code class="literal">deleteoldrdn</code> instruction determines whether the old attribute value (<code class="literal">uid=immanuel</code>) will be deleted or retained. Setting <code class="literal">0</code> indicates that the old attribute value should not be deleted, while <code class="literal">1</code> will result in the old attribute value's removal.</p><p>Now, if we search for that user, we can observe the modification:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'cn=manager,dc=example,dc=com' -LL \
     '(sn=kant)' uid
Enter LDAP Password: 
version: 1

dn: uid=manny,ou=Users,dc=example,dc=com
uid: immanuel
uid: manny</pre></div><p>In some cases we don't want the old RDN attribute value to be kept. In such cases, setting the <code class="literal">deleteoldrdn</code> value to <code class="literal">1</code> will remove the old RDN attribute values:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'
dn: uid=manny,ou=Users,dc=example,dc=com
changetype: modrdn
newrdn: uid=immanuel
deleteoldrdn: 1

modifying rdn of entry "uid=manny,ou=Users,dc=example,dc=com"
rename completed</pre></div><p>This changes the RDN back to <code class="literal">uid=immanuel</code>, and since <code class="literal">deleteoldrdn</code> is set to <code class="literal">1</code>, the old UID value (<code class="literal">manny</code>) should be deleted. We can verify this with <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'cn=manager,dc=example,dc=com' -LL \ 
     '(sn=kant)' uid
Enter LDAP Password: 
version: 1

dn: uid=immanuel,ou=Users,dc=example,dc=com
uid: immanuel</pre></div><p>Note that, in addition to the changed DN, the old <code class="literal">uid</code> attribute value (<code class="literal">manny</code>) is no longer present in the record. It has been replaced.</p><p>We will take another look at modifying relative DNs when we examine the <code class="literal">ldapmodrdn</code> client.<a class="indexterm" id="id268"/>
</p><div><div><div><div><h4 class="title"><a id="ch03lvl4sec16"/>Moving a Record with modrdn</h4></div></div></div><a class="indexterm" id="id269"/><p>The <code class="literal">modrdn</code> change-type can be used for more than just changing the RDN. It can be used for changing a record's superior entry, essentially relocating a record within the directory information tree.</p><p>For this operation to work however, the backend database type must support this sort of modification. Currently, the only storage database that supports this is HDB. In Chapter 2, we set up <code class="literal">slapd.conf</code> to store the <code class="literal">dc=example,dc=com</code> tree in an HDB backend.</p><p>Now, we can issue a compound ModRDN operation, in which we change the record's RDN, and move the record to a different OU:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'
dn: uid=manny,ou=users,dc=example,dc=com
changetype: modrdn
newrdn: uid=immanuel
deleteoldrdn: 1
newsuperior: ou=system,dc=example,dc=com</pre></div><p>In this example, we change the user's UID from <code class="literal">manny</code> back to <code class="literal">immanuel</code>. Since <code class="literal">deleteoldrdn</code> is <code class="literal">1</code>, the old RDN (<code class="literal">uid=manny</code>) will be removed from the record.</p><p>The <code class="literal">newsuperior</code> instruction tells SLAPD what the new base portion of the DN ought to be. This will effectively move the record from the <code class="literal">ou=users</code> branch to the <code class="literal">ou=system</code> branch of our directory information tree.</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>Unlike modifying a user's RDN, changing a record's superior will not modify any of the fields in the record. Thus, our record above would still have the <code class="literal">ou=Users</code> attribute.</p></div></div><p>Again, we can use <code class="literal">ldapsearch</code> to see the newly modified record:</p><div><pre class="programlisting">
<strong>  $ ldapsearch -x -W -D 'cn=manager,dc=example,dc=com' -LL </strong>
<strong>       '(sn=kant)' uid</strong>
</pre></div><p>And, we get:</p><div><pre class="programlisting">
Enter LDAP Password: 
version: 1

dn: uid=immanuel,ou=system,dc=example,dc=com
uid: immanuel<a class="indexterm" id="id270"/>
</pre></div><p>Notice that not only has the <code class="literal">uid</code> changed, but also the <code class="literal">ou</code> in the DN.</p><p>In order to use the <code class="literal">newsuperior</code> instruction, you must first specify a <code class="literal">modrdn</code>. Thus, if we wanted to move the record for this user back to the users OU, we would still have to specify the user's new RDN.</p><p>So how do you move a record without changing the RDN?</p><p>Since the <code class="literal">modrdn</code> change-type does not require that the new RDN be different from the old one, a record can be moved with <code class="literal">modrdn</code> simply by setting the <code class="literal">newrdn</code> to be the same as the old RDN:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'
dn: uid=immanuel,ou=system,dc=example,dc=com
changetype: modrdn
newrdn: uid=immanuel
deleteoldrdn: 1
newsuperior: ou=users,dc=example,dc=com

modifying rdn of entry "uid=immanuel,ou=system,dc=example,dc=com"
rename completed</pre></div><p>In this case, <code class="literal">newrdn: uid=immanuel</code> does not actually change the RDN of the user. But this is necessary in order to change the superior.</p><p>The <code class="literal">newsuperior</code> instruction indicates that the record should be moved (back) to the <code class="literal">ou=users,dc=example,dc=com</code> tree. One last <code class="literal">ldapsearch</code> of this record shows us the results of that change:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'cn=manager,dc=example,dc=com' -LL 
     '(sn=kant)' uid
Enter LDAP Password: 
version: 1

dn: uid=immanuel,ou=users,dc=example,dc=com
uid: immanuel</pre></div><p>Once again, the record is back in the <code class="literal">Users</code> OU.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Deleting Entire Records</h3></div></div></div><a class="indexterm" id="id271"/><p>Finally, using the <code class="literal">delete</code> change-type, we can delete an entire record with <code class="literal">ldapmodify</code>:</p><div><pre class="programlisting">$ ldapmodify -w secret -x -D 'cn=Manager,dc=example,dc=com'

dn: uid=nicholas,ou=Users,dc=example,dc=com
changetype: delete

deleting entry "uid=nicholas,ou=Users,dc=example,dc=com"</pre></div><p>When deleting a record all we need to specify are the DN and the change-type.</p><p>Essentially, using the delete change-type performs the same task as is done using the <code class="literal">ldapdelete</code> client.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>ldapdelete</h2></div></div></div><a class="indexterm" id="id272"/><a class="indexterm" id="id273"/><a class="indexterm" id="id274"/><p>The <code class="literal">ldapdelete</code> tool is used to delete one or more records from the directory. It performs the same operation as the <code class="literal">delete</code> change-type used in <code class="literal">ldapmodify</code>.</p><p>If you want to delete a record with <code class="literal">ldapdelete</code>, you must know its DN. This tool will not search for, say, all records that have a specified address, and then delete them all.</p><p>The syntax of the <code class="literal">ldapdelete</code> command is simple:</p><div><pre class="programlisting">
<strong>  $ ldapdelete -x -w secret -D 'cn=Manager,dc=example,dc=com' \</strong>
<strong>      'uid=nicholas,ou=Users,dc=example,dc=com'</strong>
</pre></div><p>After the usual flags (<code class="literal">-x</code>, <code class="literal">-w</code>, <code class="literal">-D</code>), <code class="literal">ldapdelete</code> takes the DN that is to be deleted (this is the DN for <code class="literal">uid=nicholas</code> on the second line of the command). Upon execution it will request that the server delete the record. Assuming that the record exists and the user is allowed (by the server's ACLs) to delete the record, then the record will be removed from the directory.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>ldapcompare</h2></div></div></div><a class="indexterm" id="id275"/><a class="indexterm" id="id276"/><a class="indexterm" id="id277"/><p>This tool is used to ask the server whether a particular entry (identified by a DN) has a particular attribute that matches the attribute specified. If the entry does have a matching attribute, then <code class="literal">ldapcompare</code> returns <code class="literal">TRUE</code>. Otherwise, it returns <code class="literal">FALSE</code>.</p><p>Here is a pair of examples:</p><div><pre class="programlisting">$ ldapcompare -x -w secret -D 'cn=Manager,dc=example,dc=com' \
    'uid=david,ou=Users,dc=example,dc=com' 'givenName:David'
TRUE

$ ldapcompare -x -w secret -D 'cn=Manager,dc=example,dc=com' \
    'uid=david,ou=Users,dc=example,dc=com' 'cn:Dave Hume'
FALSE</pre></div><p>In the first example <code class="literal">ldapcompare</code> requested that the server examine the record for <code class="literal">uid=david,ou=Users,dc=example,dc=com</code> to see if it had the attribute <code class="literal">givenName</code> with the value <code class="literal">David</code>. The record did have an attribute <code class="literal">givenName: David</code>, and so the return value is <code class="literal">TRUE</code>.</p><p>The second example performed a similar compare on the same record; it looked for the attribute <code class="literal">cn</code> with the value <code class="literal">Dave Hume</code>. While the record does have a <code class="literal">cn</code> attribute, the value of that attribute is <code class="literal">David Hume</code>, not <code class="literal">Dave Hume</code>. So the server returned <code class="literal">FALSE</code>.</p><div><div><h3 class="title"><a id="tip15"/>Tip</h3><p>
<strong>Base-64 Encoding with ldapcompare</strong>
</p><p>In cases where the value to compare is not an ASCII string, you should base-64 encode the value and use the double colon syntax (<code class="literal">::</code>) that we used in our LDIF files. Example: <code class="literal">givenName::RGF2aWQ=</code>
</p></div></div><p>An LDAP compare operation is often much faster than a search operation. In cases where the same task can be accomplished with <code class="literal">ldapsearch</code> and <code class="literal">ldapcompare</code>, it is often more efficient to use <code class="literal">ldapcompare</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>ldapmodrdn</h2></div></div></div><a class="indexterm" id="id278"/><a class="indexterm" id="id279"/><a class="indexterm" id="id280"/><p>The <code class="literal">ldapmodrdn</code> client is used to change the Relative DN (RDN) portion of a DN. This client requests a ModifyDN operation. <code class="literal">ldapmodrdn</code> takes the full DN of an existing record, and the relative DN that should replace the existing RDN for the record:</p><div><pre class="programlisting">
<strong>  $ ldapmodrdn -x -w secret -D 'cn=Manager,dc=example,dc=com' </strong>
<strong>      'uid=immanuel,ou=Users,dc=example,dc=com' 'uid=manny'</strong>
</pre></div><p>This example requests that the RDN for <code class="literal">uid=immanual,ou=Users,dc=example,dc=com</code> be changed from <code class="literal">uid=immanuel</code> to <code class="literal">uid=manny</code>.</p><p>Now let's take a look at the record after the change. We will search by the <code class="literal">sn</code> field:</p><div><pre class="programlisting">$ ldapsearch -x -w secret -D 'cn=Manager,dc=example,dc=com' -LLL \ 
    '(sn=Kant)' uid

dn: uid=manny,ou=Users,dc=example,dc=com
uid: immanuel
uid: manny</pre></div><p>Here, the filter is looking for records with the surname <code class="literal">Kant</code> and requesting that only the <code class="literal">uid</code> attribute be returned. Recall that we did not ever add a <code class="literal">uid</code> attribute with the value <code class="literal">manny</code>—we only had <code class="literal">uid: immanuel</code>.</p><p>But looking at the results, we can see that not only has the DN been modified, but a new user ID attribute has been added for us. In some cases it is fine that the modification of the RDN results in adding (rather than replacing) an attribute value. But in other cases this is inconvenient or even illegal (because of the schema).</p><p>For example, we might have a record in the directory that describes a subtree of records that have to do with the company website. Such a record might look like this:</p><div><pre class="programlisting">dn: dc=www,dc=example,dc=com
dc: www
ou: Website
objectClass: organizationalUnit
objectClass: dcObject</pre></div><p>Now, say we wanted to change the RDN to point not to <code class="literal">www</code>, but to <code class="literal">web</code>. Using <code class="literal">ldapmodrdn</code> the way we did earlier would generate an error:</p><div><pre class="programlisting">$ ldapmodrdn -x -w secret -D 'cn=Manager,dc=example,dc=com' \
    'dc=www,dc=example,dc=com' 'dc=web'

Rename Result: Constraint violation (19)
Additional info: attribute 'dc' cannot have multiple values</pre></div><p>The reason for this error is that the schema definition for <code class="literal">dc</code> specifies that there can be only one <code class="literal">dc</code> attribute value per record.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>The <code class="literal">dc</code> (or <code class="literal">domainComponent</code>) attribute is defined in <code class="literal">core.schema</code>.</p></div></div><p>The solution to this problem is to use the <code class="literal">-r</code> flag for <code class="literal">ldapmodrdn</code>.</p><div><pre class="programlisting">
<strong>  $ ldapmodrdn -x -w secret -D 'cn=Manager,dc=example,dc=com' -r </strong>
<strong>      'dc=www,dc=example,dc=com' 'dc=web'</strong>
</pre></div><p>The <code class="literal">-r</code> flag causes <code class="literal">ldapmodrdn</code> to replace, rather than add, the existing attribute value. Now the resulting record looks like this:</p><div><pre class="programlisting">dn: dc=web,dc=example,dc=com
ou: Website
objectClass: organizationalUnit
objectClass: dcObject
dc: web</pre></div><p>There is only one <code class="literal">dc</code> attribute listed, and it has the newly set value, <code class="literal">web</code>.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Modifying the Superior DN with ldapmodrdn</h3></div></div></div><a class="indexterm" id="id281"/><p>Just as we saw earlier with the <code class="literal">modrdn</code> change-type for ldapmodify, we can change the superior DN (the base portion of a record's DN) with <code class="literal">ldapmodrdn</code>.</p><div><div><h3 class="title"><a id="tip16"/>Tip</h3><p>
<strong>The Right Backend</strong>
</p><p>Not all backends support this type of renaming. Currently, the HDB backend is the only storage backend to support changing the superior reference in a DN. Other non-storage backends (like <code class="literal">ldap</code>) may pass on these operations to the underlying storage mechanism, which in turn may or may not support this degree of renaming.</p></div></div><p>Also, as with the <code class="literal">modrdn</code> change type, <code class="literal">ldapmodrdn</code> must specify a replacement RDN even if that RDN is the same as the current one. In other words, an RDN is required, even if the RDN is not a new RDN. We will see an example of this below.</p><p>The <code class="literal">-s</code> flag for <code class="literal">ldapmodrdn</code> specifies the new superior DN. Thus, to move the entry <code class="literal">uid=barbara,ou=users,dc=example,dc=com</code> to the <code class="literal">ou=system</code> branch of the directory, we can use a command like this:</p><div><pre class="programlisting">
<strong>  ldapmodrdn -x -w secret -D 'cn=Manager,dc=example,dc=com' \</strong>
<strong>       -s "ou=system,dc=example,dc=com" -r \</strong>
<strong>          "uid=barbara,ou=users,dc=example,dc=com" "uid=barbara"</strong>
</pre></div><p>This is a long command, and it is thus broken up into three lines:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line contains the flags that handle binding to the directory, and these should be familiar by now.</li><li class="listitem" style="list-style-type: disc">The second line begins with the <code class="literal">-s</code> flag, which takes a DN for a parameter. This is the flag that specifies what the new superior DN will be. In this case, it is <code class="literal">ou=system,dc=example,dc=com</code>.<p>The <code class="literal">-r</code> flag, as we have seen before, instructs SLAPD to replace the old RDN with the new one.</p></li><li class="listitem" style="list-style-type: disc">On the third line is the DN for the entry we want to modify, <code class="literal">uid=barbar,ou=users,dc=example,dc=com</code>, and the new RDN. Since we want to keep the same RDN (but move the record to a new subtree), we set this last value to <code class="literal">uid=barbara</code>, which is the RDN that the existing record has.</li></ul></div><p>After we run this command we can see the results with <code class="literal">ldapsearch</code>:</p><div><pre class="programlisting">$ ldapsearch -x -W -D 'cn=manager,dc=example,dc=com' -LL 
    '(uid=barbara)' uid ou
Enter LDAP Password: 
version: 1

dn: uid=barbara,ou=system,dc=example,dc=com
ou: Users
uid: barbara<a class="indexterm" id="id282"/>
</pre></div><p>The base portion of Barbara's new record is now <code class="literal">ou=system,dc=example,dc=com</code>.</p><p>Just as with the <code class="literal">modrdn</code> changetype for <code class="literal">ldapmodify</code>, changing a superior entry will not change any attributes in the record. Thus, even though this record is now in the sytem OU, it still has the attribute <code class="literal">ou: Users</code>.</p><p>It is possible to construct Relative DNs that have more than one attribute value. For example, I can use a combination of <code class="literal">uid</code> and <code class="literal">l</code> (for location) in the RDN portion:</p><div><pre class="programlisting">dn: uid=matt+l=Chicago,ou=Users,dc=example,dc=com</pre></div><p>In such cases, the plus sign (<code class="literal">+</code>) is used to indicate that both the attribute are to be considered part of the RDN.</p><p>
<code class="literal">ldapmodrdn</code> is smart enough to handle these cases. It will add (or replace) all of the attributes used in the RDN.</p><p>In the case where the <code class="literal">-r</code> flag is specified, there are some things to be aware of. First, <code class="literal">ldapmodrdn</code> will replace all of the fields used in the new RDN. Second, if there is a value in the initial RDN that is removed from the RDN, then the attribute value will be removed from the record as well. For example, here is our starting record:</p><div><pre class="programlisting">dn: cn=Matt Butcher+l=Chicago,dc=example,dc=com
cn: Matt Butcher
sn: Butcher
l: Chicago
objectClass: person
objectClass: organizationalPerson</pre></div><p>Notice that the DN uses both the <code class="literal">cn</code> and the <code class="literal">l</code> attributes, both of which are present in the body of the record. Now, if we use <code class="literal">ldapmodrdn</code> with the <code class="literal">-r</code> flag and replace <code class="literal">cn=Matt Butcher+l=Chicago</code> with <code class="literal">cn=Matt Butcher</code>, the <code class="literal">l: Chicago</code> attribute will be removed from the record:</p><div><pre class="programlisting">dn: cn=Matt Butcher,dc=example,dc=com
sn: Butcher
objectClass: person
objectClass: organizationalPerson
cn: Matt Butcher</pre></div><p>So, when using <code class="literal">ldapmodrdn</code> with multi-attribute RDNs, be judicious when using the <code class="literal">-r</code> flag.<a class="indexterm" id="id283"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>ldappasswd</h2></div></div></div><a class="indexterm" id="id284"/><a class="indexterm" id="id285"/><a class="indexterm" id="id286"/><p>In the utilities section we looked at encrypting passwords with <code class="literal">slappasswd</code>. That tool was used to generate encrypted values for inclusion in LDIF files. The <code class="literal">ldappasswd</code> client, in contrast, connects to the server and changes a password value in the directory. If needed it can be used to automatically generate a password, as well.</p><p>Unlike <code class="literal">ldapadd</code> and <code class="literal">ldapmodify</code>, which use the LDAP v.3 standard Add and Modify operations, the <code class="literal">ldappasswd</code> client uses an extension operation—the <strong>LDAP Password Modify Extended Operation</strong> as defined in RFC 3062 (<a class="ulink" href="http://rfc-editor.org/rfc/rfc3062.txt">http://rfc-editor.org/rfc/rfc3062.txt</a>).</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>When loading passwords from an LDIF file, or from <code class="literal">ldapadd</code> or <code class="literal">ldapmodify</code>, if you send the server a cleartext password, the password will be stored in the directory in an unencrypted string. This is not safe. You should either use <code class="literal">slappasswd</code> to generate an encrypted password for inclusion in an LDIF, or you should use <code class="literal">ldappasswd</code> to set the password.</p></div></div><p>As long as the ACLs permit, a user can change her or his password with the <code class="literal">ldappasswd</code> client:</p><div><pre class="programlisting">$ ldappasswd -x -W -S -D 'uid=matt,ou=Users,dc=example,dc=com'
New password: 
Re-enter new password: 
Enter LDAP Password: 

Result: Success (0)</pre></div><p>The <code class="literal">-S</code> flag is the only new flag used here. It indicates that <code class="literal">ldappasswd</code> should prompt the user to enter (and re-enter) a new password. The <code class="literal">-W</code> flag, as you may recall, prompts the user to enter a current password interactively.</p><p>The order in which the user enters the passwords differs from the norm. The user is prompted to first enter and re-enter a new password, and then to enter the current password.</p><p>It is also possible for an administrator (or one with write permissions to the <code class="literal">userPassword</code> attribute of a given record) to change a password for another user:</p><div><pre class="programlisting">$ ldappasswd -x -w secret -D 'cn=Manager,dc=example,dc=com' -s secret \ 'uid=barbara,ou=Users,dc=example,dc=com'

Result: Success (0)</pre></div><p>In this case the directory manager is changing the value of the <code class="literal">userPassword</code> attribute for <code class="literal">uid=barbara,ou=Users,dc=example,dc=com</code>. Rather than using <code class="literal">-S</code> and entering the password at an interactive prompt, the password has been specified on the command line: <code class="literal">-s secret</code>.</p><p>The password, when changed through <code class="literal">ldappasswd</code>, is automatically encrypted by the server before it is stored in the record:</p><div><pre class="programlisting"># barbara, Users, example.com
dn: uid=barbara,ou=Users,dc=example,dc=com
userPassword:: e1NTSEF9UzFTUnQ1bkkvcHZGOGt3UklVU3J3TkRHZHFSS3hOQ1Y=</pre></div><p>If we decode the <code class="literal">userPassword</code> value, it reads: <code class="literal">{SSHA}S1SRt5nI/pvF8kwRIUSrwNDGdqRKxNCV</code>. The password is stored in an irreversible SSHA hash.</p><div><div><h3 class="title"><a id="tip17"/>Tip</h3><p>
<strong>Setting the Default Encryption Scheme</strong>
</p><p>You can specify which encryption scheme the server should choose when encrypting passwords. To specify the algorithm, use the <code class="literal">password-hash</code> directive in <code class="literal">slapd.conf</code>. Example: <code class="literal">password-hash {SMD5}</code>
</p></div></div><p>Finally, <code class="literal">ldappasswd</code> can request that the server generate a strong password for that DN. If no flag is set that indicates, the source of the password (for example <code class="literal">-s</code>, <code class="literal">-S</code>, or <code class="literal">-T</code>), then <code class="literal">ldappasswd</code> requests that one be generated. Here is the request:</p><div><pre class="programlisting">$ ldappasswd -x -w secret -D 'cn=Manager,dc=example,dc=com'  \
    'uid=barbara,ou=Users,dc=example,dc=com'

New password: dS9R4Kvc
Result: Success (0)</pre></div><p>The server responded to this request with a generated password, <code class="literal">New password: dS9R4Kvc</code>, which has already been encrypted and stored in the <code class="literal">userPassword</code> attribute on the server.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>ldapwhoami</h2></div></div></div><a class="indexterm" id="id287"/><a class="indexterm" id="id288"/><a class="indexterm" id="id289"/><p>The last client in the OpenLDAP suite is <code class="literal">ldapwhoami</code>. This client provides a client implementation of the <strong>"Who am I?" Extended Operation</strong>. This operation provides information about the DN who is currently bound to the directory.</p><p>The <code class="literal">ldapwhoami</code> command simply requires enough information to authenticate to the directory server:</p><div><pre class="programlisting">$ ldapwhoami -x -w secret -D 'cn=Manager,dc=example,dc=com'

dn:cn=Manager,dc=example,dc=com
Result: Success (0)</pre></div><p>As you can see from this example, all this client does is reply with the DN of the user we connected with. This tool comes in useful when debugging SASL authentication, which does not require a DN to connect. We will look at SASL configuration in the next chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter we have taken a closer look at the tools in the OpenLDAP suite. We began by looking at the SLAPD and SLURPD servers. In particular, we looked at the major LDAP operations, such as bind, search, add, modify, and delete.</p><p>Next we created a basic directory information tree in an LDIF file. In doing this, we familiarized ourselves with LDIF—the text format for representing LDAP directory data.</p><p>From there we looked at the utilities and clients in the OpenLDAP suite. Along the way, we loaded our directory information tree from LDIF into the directory, and then added to and modified that data.</p><p>At this point you should be comfortable working with the tools included in OpenLDAP. In the next chapter we are going to return to the SLAPD server and take a close look at LDAP security.</p></div></body></html>