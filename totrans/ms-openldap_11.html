<html><head></head><body><div class="appendix" title="Appendix&#xA0;C.&#xA0;Useful LDAP Commands"><div class="titlepage"><div><div><h1 class="title"><a id="appC"/>Appendix C. Useful LDAP Commands</h1></div></div></div><a class="indexterm" id="id895"/><p>In the course of this book we looked at all the command line tools that come in the OpenLDAP distribution. But the scope of this book requires the discussion of each of these tools briefly. There are some advanced uses of these tools that can come in handy at times. In this appendix I have provided examples of such uses.</p><p>In this appendix, we will cover</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting information about the directory using <code class="literal">ldapsearch</code></li><li class="listitem" style="list-style-type: disc">Creating backups of the directory using two different strategies</li><li class="listitem" style="list-style-type: disc">Rebuilding a BDB/HDB database</li></ul></div><div class="section" title="Getting Information about the Directory"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec58"/>Getting Information about the Directory</h1></div></div></div><p>Many LDAP servers provide information about their configuration and functional abilities. This information is stored in such a way that LDAP clients can directly access it using a search operation. For example, a client can fetch the <span class="strong"><strong>root DSE</strong></span> record to find out <a class="indexterm" id="id896"/>the basic capabilities of the server. It can also access the <span class="strong"><strong>subschema</strong></span> of the server and find out what object classes, syntaxes, matching rules, and attributes are supported.</p><div class="section" title="The Root DSE"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec110"/>The Root DSE</h2></div></div></div><a class="indexterm" id="id897"/><p>The <span class="strong"><strong>root DSE (DSA-Specific Entry</strong></span>, where <span class="strong"><strong>DSA </strong></span>stands for <span class="strong"><strong>Directory Service Agent</strong></span>) is a special entry that provides information about the server itself. The DN of the root DSE is an empty string (""). To retrieve it we need a carefully-crafted LDAP search that will set an empty search base and then retrieve that root entry:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ ldapsearch -x -LLL -b '' -s base -W -D \</strong></span>
<span class="strong"><strong>       'cn=Manager,dc=example,dc=com' '+'</strong></span>
</pre></div><p>Note that the base is set to an empty string, and the search scope is limited to the base record. These parameters combined have the effect of requesting only the record that has an empty DN. Also, since most of the attributes in the root DSE are operational attributes, we need to specify <code class="literal">'+'</code> at the end of the search.</p><p>The results of running this search look something like this:</p><div class="informalexample"><pre class="programlisting">dn:
structuralObjectClass: OpenLDAProotDSE
configContext: cn=config
namingContexts: dc=example,dc=com
supportedControl: 2.16.840.1.113730.3.4.18
supportedControl: 2.16.840.1.113730.3.4.2
supportedControl: 1.3.6.1.4.1.4203.1.10.1
supportedControl: 1.2.840.113556.1.4.319
supportedControl: 1.2.826.0.1.334810.2.3
supportedControl: 1.2.826.0.1.3344810.2.3
supportedControl: 1.3.6.1.1.13.2
supportedControl: 1.3.6.1.1.13.1
supportedControl: 1.3.6.1.1.12
supportedExtension: 1.3.6.1.4.1.1466.20037
supportedExtension: 1.3.6.1.4.1.4203.1.11.1
supportedExtension: 1.3.6.1.4.1.4203.1.11.3
supportedFeatures: 1.3.6.1.1.14
supportedFeatures: 1.3.6.1.4.1.4203.1.5.1
supportedFeatures: 1.3.6.1.4.1.4203.1.5.2
supportedFeatures: 1.3.6.1.4.1.4203.1.5.3
supportedFeatures: 1.3.6.1.4.1.4203.1.5.4
supportedFeatures: 1.3.6.1.4.1.4203.1.5.5
supportedLDAPVersion: 3
supportedSASLMechanisms: NTLM
supportedSASLMechanisms: DIGEST-MD5
supportedSASLMechanisms: CRAM-MD5
entryDN:
subschemaSubentry: cn=Subschema<a class="indexterm" id="id898"/>
</pre></div><p>Among other things, this record gives us information about what controls, features, and extensions are understood by and enabled on the server. For example, there is a <code class="literal">supportedFeature</code> line that reads: </p><div class="informalexample"><pre class="programlisting">supportedExtension: 1.3.6.1.4.1.4203.1.11.1</pre></div><p>This line indicates that this LDAP server supports an LDAPv3 extension for <span class="strong"><strong>Change Password</strong></span> operations as defined in RFC 3062 (<a class="ulink" href="http://www.rfc-editor.org/rfc/rfc3062.txt">http://www.rfc-editor.org/rfc/rfc3062.txt</a>).</p><p>Using this information, a well-crafted LDAP client would be able to perform a server-side Change Password operation instead of changing the password on the client side and then using a Modify operation to send the change to the server.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note166"/>Note</h3><p>The advantage of the Change Password operation is in the server's storage. If the client changes a password through a Modify operation it must know in advance what types of encryption are supported on the server, it must do the encrypting itself, and then submit the encrypted password to the server. Usually, it is better to have the client securely contacting the server (over TLS, for example), and then using a Change Password operation so that the server can do the storage.</p></div></div><p>The root DSE record also points to the configuration (<code class="literal">cn=config</code>) and subschema (<code class="literal">cn=subschema</code>) records.<a class="indexterm" id="id899"/>
</p></div><div class="section" title="The Subschema Record"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec111"/>The Subschema Record</h2></div></div></div><a class="indexterm" id="id900"/><p>The subschema record is stored in <code class="literal">cn=subschema</code>. This record contains detailed information about the schemas supported by the server, including what types of matching rules it has available, what sort of syntaxes are allowed in <a class="indexterm" id="id901"/>attributes, and what attributes and object classes are recognized by the server.</p><p>This information can be used by client applications to correctly craft records or searches, and then correctly interpret the responses.</p><p>The subschema record can be retrieved with <code class="literal">ldapsearch</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  ldapsearch -x -LLL -b 'cn=subschema' -s base -W \</strong></span>
<span class="strong"><strong>      -D 'cn=Manager,dc=example,dc=com'  '+'</strong></span>
</pre></div><p>In this example we request the desired record by setting the base DN to <code class="literal">cn=config</code>, and then requesting a search type of <code class="literal">base</code> (<code class="literal">-b</code> <code class="literal">'cn=subschema'</code> <code class="literal">-s</code> <code class="literal">base</code>). This returns the exact record with the DN <code class="literal">cn=subschema</code>.</p><p>Also, most of the attributes we want are operational attributes, which means they will not be returned in a normal search, so at the end we specify <code class="literal">'+'</code> to indicate that we want the operational attributes.</p><p>The record returned looks like this:</p><div class="informalexample"><pre class="programlisting">dn: cn=Subschema
structuralObjectClass: subentry
createTimestamp: 20061216235843Z
modifyTimestamp: 20061216235843Z
ldapSyntaxes: ( 1.3.6.1.1.16.1 DESC 'UUID' )
ldapSyntaxes: ( 1.3.6.1.1.1.0.1 DESC 'RFC2307 Boot Parameter' )
<span class="strong"><strong># ... lots of lines removed</strong></span>
objectClasses: ( 2.16.840.1.113730.3.2.2 NAME 'inetOrgPerson' 
  DESC 'RFC2798: Internet Organizational Person' 
  SUP organizationalPerson STRUCTURAL 
  MAY ( audio $ businessCategory $ carLicense $ departmentNumber $
  displayName $ employeeNumber $ employeeType $ givenName $
  homePhone $ homePostalAddress $ initials $ jpegPhoto $ 
  labeledURI $ mail $ manager $ mobile $ o $ pager $ photo $ 
  roomNumber $ secretary $ uid $ userCertificate $
  x500uniqueIdentifier $ preferredLanguage $ userSMIMECertificate $
  userPKCS12 ) )
objectClasses: ( 1.3.6.1.4.1.4203.666.11.1.4.2.1.2 NAME  
  'olcHdbConfig' DESC 'HDB backend configuration' 
  SUP olcDatabaseConfig STRUCTURAL 
  MUST olcDbDirectory 
  MAY ( olcDbCacheSize $ olcDbCheckpoint $ olcDbConfig $ olcDbNoSync
        $ olcDbDirtyRead $ olcDbIDLcacheSize $ olcDbIndex $
        olcDbLinearIndex $ olcDbLockDetect $ olcDbMode $ 
        olcDbSearchStack $ olcDbShmKey $ olcDbCacheFree ) )
entryDN: cn=Subschema
subschemaSubentry: cn=Subschema</pre></div><p>A subschema record contains all of the schema information and thus, it may be well over a thousand lines.<a class="indexterm" id="id902"/>
</p><p>Subschema records can be particularly useful to learn about what schemas a server supports, or when developing and debugging custom schemas, as discussed in Chapter 6.</p></div><div class="section" title="The Configuration Record"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec112"/>The Configuration Record</h2></div></div></div><a class="indexterm" id="id903"/><p>An experimental feature of OpenLDAP 2.3 (and one that will probably reach production quality in OpenLDAP 2.4) is the ability to store the LDAP configuration inside of the directory. To do this you must first re-create your configuration in LDIF format using a special configuration schema, and instruct SLAPD to read its configuration from this new LDIF file.</p><p>The configuration is stored inside of the directory with the DN <code class="literal">cn=config</code>. It can be accessed with a search similar to the one used in the previous section:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  ldapsearch -x -LLL -b 'cn=config' -s base -W \</strong></span>
<span class="strong"><strong>      -D 'cn=Manager,dc=example,dc=com'  '*'</strong></span>
</pre></div><p>In OpenLDAP 2.3, not all of the overlays and features of OpenLDAP work correctly with this new configuration style, and that is a significant drawback to its use. But improving this alternate configuration mechanism is a priority for development in OpenLDAP 2.4.</p><p>What might be the advantages of storing your configuration in the directory? Here are a few:<a class="indexterm" id="id904"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Easy access to configuration information through <code class="literal">ldapsearch</code> and other LDAP clients.</li><li class="listitem" style="list-style-type: disc">The ability to edit configuration information through directory tools like <code class="literal">ldapmodify</code>.</li><li class="listitem" style="list-style-type: disc">Replication support for SLAPD configuration. You may be able to use SyncRepl to synchronize directory configurations across the network.</li></ul></div><p>If you would like to implement the new LDAP-based configuration file format, you can learn about it in the LDAP Administrators Guide at the OpenLDAP site: <a class="ulink" href="http://www.openldap.org/doc/admin23/slapdconf2.html">http://www.openldap.org/doc/admin23/slapdconf2.html</a>.</p></div></div></div>
<div class="section" title="Making a Directory Backup"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec59"/>Making a Directory Backup</h1></div></div></div><a class="indexterm" id="id905"/><p>There are two common strategies for backing up the contents of your directory. One is to make a backup of the directory database. The other is to dump the contents of the directory into an LDIF file.</p><div class="section" title="A Backup Copy of the Directory Database"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec113"/>A Backup Copy of the Directory Database</h2></div></div></div><a class="indexterm" id="id906"/><p>Different backends locate the contents of the directory in different locations. For example, the BDB and HDB backends store data in special Berkeley DB database files. SQL-based backends store the information in a relational database management system. Special backends like the LDAP and Perl backends may not store data at all, but might simply access other sources.</p><p>Each of these backends will require a different backup procedure. Here we will just look at backing up BDB and HDB databases—the types we've used throughout the book.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note167"/>Note</h3><p>This method is not portable. BDB/HDB files are version sensitive. Each new release of OpenLDAP (or of Berkeley DB) may use different structures for these databases, so this backup method only works when the backup and the restore are done on the same software versions.</p></div></div><p>In Ubuntu these database files are located at <code class="literal">/var/lib/ldap</code>. All of the files in this directory, including the indexes (those that end with the <code class="literal">bdb</code> extension), the main database files (<code class="literal">__db.???</code>) and the log files (<code class="literal">log.??????????</code>). It is also a good idea to make a copy of the <code class="literal">DB_CONFIG</code> file, though it rarely changes and does not store any directory data.</p><p>When backing up these files it is best to stop SLAPD. Here's a very simple example using common shell tools:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo invoke-rc.d slapd stop</strong></span>
<span class="strong"><strong>  $ sudo cp -a /var/lib/ldap/* /usr/local/backup/ldap/</strong></span>
<span class="strong"><strong>  $ sudo invoke-rc.d slapd start</strong></span>
</pre></div><p>This will stop SLAPD and copy all of the files at <code class="literal">/var/lib/ldap/</code> to <code class="literal">/usr/local/backup/ldap/</code>. Then, SLAPD will be started again.</p></div><div class="section" title="An LDIF Backup File"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec114"/>An LDIF Backup File</h2></div></div></div><a class="indexterm" id="id907"/><p>The second, and more portable, strategy for backing up the directory is to dump the contents of the directory to an LDIF file. There are several distinct advantages to this approach:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There is no need to stop SLAPD</li><li class="listitem" style="list-style-type: disc">The output is more portable, and data can be moved from one database backend to another, and from one OpenLDAP version to another</li></ul></div><p>There is less redundant data, so backup files are much smaller than the BDB/HDB files.To make an LDIF backup file of the contents of a directory server with only one database (that is, it has only one directory root), the command is simple:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slapcat -l /usr/local/backup/my_directory.ldif</strong></span>
</pre></div><p>This command uses <code class="literal">slapcat</code> to dump the contents of the directory, in the LDIF format, into the file <code class="literal">/usr/local/backup/my_directory.ldif</code>. It can be loaded back into the directory using the <code class="literal">slapdadd</code> tool discussed in Chapter 3.</p><p>If your directory contains more than one directory information tree, you will need to run the <code class="literal">slapcat</code> routine once for each server, using the <code class="literal">-b</code> flag to identify the suffix (base DN) of the directory information tree you want to dump:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ cd /usr/local/backup</strong></span>
<span class="strong"><strong>  $ sudo slapcat -b "dc=example,dc=com" -l example_com.ldif </strong></span>
<span class="strong"><strong>  $ sudo slapcat -b "dc=test,dc=net" -l test_net.ldif</strong></span>
</pre></div><p>In this example we backup each directory into its own LDIF file.</p></div></div>
<div class="section" title="Rebuilding a Database (BDB, HDB)"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec60"/>Rebuilding a Database (BDB, HDB)</h1></div></div></div><a class="indexterm" id="id908"/><p>Sometimes it is necessary to rebuild a backend database. This process differs depending on the database backend. For instance, with a SQL backend, it might entail dumping, dropping, and re-creating tables in the database.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note168"/>Note</h3><p>Moving to a new server and transferring contents to a new slave server are also processes similar to rebuilding a database, and the differences are mentioned within the text here.</p></div></div><p>The most commonly-used backends for OpenLDAP are the HDB and BDB backends (both based on the Berkeley DB lightweight database). In this section, I want to cover the process of rebuilding these databases.</p><p>This process consists of five steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Stop SLAPD</li><li class="listitem">Dump the directory data into a file</li><li class="listitem">Delete the old directory files</li><li class="listitem">Create a new database</li><li class="listitem">Start SLAPD</li></ol></div><p>None of these steps is particularly difficult. In fact, for a small to medium-sized directory, this process can be done in less than ten minutes.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note1100"/>Note</h3><p><span class="strong"><strong>Moving from Server to Server</strong></span></p><p>Moving a directory from one server to another is done by a process very similar to that described here. Only step three, as mentioned later, differs. In this case, instead of deleting directory files, the LDIF file would be transferred from the original server to the new server. Steps one and two would be run on the original server, and steps four and five would be done on the new server.</p></div></div><div class="section" title="Step 1: Stop the Server"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec115"/>Step 1: Stop the Server</h2></div></div></div><a class="indexterm" id="id909"/><p>The purpose of stopping the server is to prevent additional changes to the directory information tree while we are working on it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note169"/>Note</h3><p>If you are just dumping the contents of a master directory to import into a shadow server that will use SyncRepl, you need not stop the server. Any changes that happen after the directory has been dumped will be retrieved by the shadow server during its first LDAP synchronization operation.</p></div></div><p>This can be done either by killing the server's process ID, or by running the startup script with the stop command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo invoke-rc.d slapd stop</strong></span>
</pre></div><p>Now that the server is stopped, we can dump the database.</p></div><div class="section" title="Step 2: Dump the Database"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec116"/>Step 2: Dump the Database</h2></div></div></div><a class="indexterm" id="id910"/><p>In Chapter 3 I covered the OpenLDAP utilities. One of the tools I discussed was the <code class="literal">slapcat</code> program, which is a tool for dumping the contents of the directory into an LDIF file. That is the program we will use in this step.</p><p>Why use <code class="literal">slapcat</code> instead of an <code class="literal">ldapsearch</code>? There are two reasons.</p><p>First, <code class="literal">slapcat</code> preserves all of the attributes (and records for that matter) that the LDAP server uses, including the operational attributes that are stored. (Those operational attributes that are generated at runtime are not generated by <code class="literal">slapcat</code>, and that is good. We wouldn't want to import those, anyway.)</p><p>Second, <code class="literal">slapcat</code> accesses the database directly, instead of opening an LDAP connection to the server. That means that ACLs, time and size limits, and other by products of the LDAP connection are not evaluated, and hence will not alter the data.</p><p>The BDB/HDB database is stored in a small set of files located at <code class="literal">/var/lib/ldap</code> (or <code class="literal">/usr/local/var/openldap-data</code> if you built from source). Usually access to those files is restricted to only the ID of the SLAPD user. By default this is <code class="literal">root</code> or <code class="literal">ldap</code>. In order to extract information using <code class="literal">slapcat</code>, you will need to have access to those files.</p><p>We have this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slapcat -l /tmp/backup.ldif</strong></span>
</pre></div><p>This command executes <code class="literal">slapcat</code> as root. The <code class="literal">-l</code> flag is used to pass in the name of the <a class="indexterm" id="id911"/>output file. In this case the file <code class="literal">backup.ldif</code> will be created in the <code class="literal">/tmp</code> directory.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note170"/>Note</h3><p>You may prefer putting the LDIF file in a folder other than <code class="literal">/tmp</code>, especially if you plan on keeping the LDIF file for more than a few minutes.</p></div></div><p>In most cases the <code class="literal">-l</code> flag is the only one you will need. If you have more than one backend and you only want to dump one, you can use the <code class="literal">-n</code> flag to specify which backend to dump.</p><p>Once the <code class="literal">slapcat</code> is complete, we are done with this step.</p><p>Before continuing however, you may want to check the contents of the LDIF file to make sure that it is not corrupt. Do this before deleting the database files.</p></div><div class="section" title="Step 3: Delete the Old Database Files"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec117"/>Step 3: Delete the Old Database Files</h2></div></div></div><a class="indexterm" id="id912"/><p>If you are re-building a database you will want to delete the old database files before building new ones.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note171"/>Note</h3><p>You do not need to do this if you are either migrating from an old server to a new server or configuring SyncRepl shadow servers.</p></div></div><p>These files are stored at <code class="literal">/var/lib/ldap</code> (or <code class="literal">/usr/local/var/openldap-data</code> if you built from source). However, not all of the files in that directory should be deleted. We only want to delete:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The index files: files that end in '<code class="literal">.bdb</code>'.</li><li class="listitem" style="list-style-type: disc">The main database files: files named <code class="literal">__db.???</code>, where the question marks are replaced by numbers in sequence (<code class="literal">__db.001</code>, <code class="literal">__db.002</code>, and so on).</li><li class="listitem" style="list-style-type: disc">The <code class="literal">alock</code> file: a file used internally for storing locking information. (Usually, this can be left with no negative consequences, but if SLAPD crashed, this can be left in an unstable state.)</li><li class="listitem" style="list-style-type: disc">The BDB log files: files named <code class="literal">log.??????????</code>, where the ten question marks are replaced by numbers in sequence: <code class="literal">log.0000000001</code>, <code class="literal">log.0000000002</code>, and so on.</li></ul></div><p>There is one file we definitely do not want to delete. This is our database configuration file, <code class="literal">DB_CONFIG</code>. Deleting it would cause the BDB engine to use its default settings, which are not tuned to our needs, and generally cause OpenLDAP to perform poorly.</p><p>So, to delete the files, we can do the following:</p><div class="informalexample"><pre class="programlisting">$ cd /var/lib/ldap
$ sudo rm __db.* *.bdb alock log.*</pre></div><p>To reduce the risk of data loss, you may want to backup the <code class="literal">__db.*</code>, <code class="literal">*.bdb</code>, and <code class="literal">log.*</code> files before removing them. Or instead of doing an <code class="literal">rm</code>, you may use <code class="literal">mv</code> to move the files to a different location:<a class="indexterm" id="id913"/>
</p><div class="informalexample"><pre class="programlisting">$ cd /var/lib/ldap
$ sudo mkdir backup/
$ sudo mv *.bdb log.* alock __db.* backup/ </pre></div><p>Now the database directory has been cleared. We are ready to create new database files.</p></div><div class="section" title="Step 4: Create a New Database"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec118"/>Step 4: Create a New Database</h2></div></div></div><a class="indexterm" id="id914"/><p>The new database can be created and populated with the data all in one step, using the <code class="literal">slapadd</code> utility that we covered in Chapter 3. Still in the OpenLDAP data directory, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slapadd -l /tmp/backup.ldif</strong></span>
</pre></div><p>This will create all of the necessary files, import the LDIF file, and handle all of the data indexing as well.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note172"/>Note</h3><p>If you are running your LDAP server as a user other than root (and it is a good idea to do so), you will also need to use <code class="literal">chown</code> to change the ownership on all of the files at <code class="literal">/var/lib/ldap</code> to be owned by the SLAPD userID: <code class="literal">sudo</code> <code class="literal">chown</code> <code class="literal">openldap</code> <code class="literal">*.bdb</code> <code class="literal">log.*</code> <code class="literal">__db.*</code>.</p></div></div><p>All we need to do now is restart the server.</p></div><div class="section" title="Step 5: Restart SLAPD"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec119"/>Step 5: Restart SLAPD</h2></div></div></div><a class="indexterm" id="id915"/><p>If you stopped the server in step 1 you will need to restart it.</p><p>Restart the server in one of the usual ways. Using the init script is usually the best way:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo invoke-rc.d slapd start</strong></span>
</pre></div><p>That's all there is to it. Now you should have SLAPD running with a fresh copy of the database.</p></div><div class="section" title="Troubleshooting Rebuilds"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec120"/>Troubleshooting Rebuilds</h2></div></div></div><a class="indexterm" id="id916"/><p>As long as the LDIF file exported with <code class="literal">slapcat</code> is good, there is not much that can go wrong in this process. Even if you have to delete and recreate several times, as long as the LDIF file is safe, no important data is at risk.</p><p>If SLAPD is running as a user other than <code class="literal">root</code>, the main problem with importing is usually the permissions on the database files at <code class="literal">/var/lib/ldap</code>. Permissions on the configuration files in <code class="literal">/etc/ldap</code> directory may also be the source of SLAPD failures. Make sure they are owned by the appropriate user.</p><p>When switching versions of OpenLDAP, occasionally an old LDIF file will not be valid in the new server (this happened between OpenLDAP 2.0 and OpenLDAP 2.2, and again between 2.2 and 2.3; it could happen again in the future). While the standard schemas are fairly stable over time, operational attributes, which are not usually standardized, are more volatile, and do change from release to release.</p><p>Often, the fix will be tweaking records in the LDIF file to match the attributes used in new version. One other common issue has to do with starting up the server. Sometimes, when using the init script, you will not be able to get the server to start, but no informative message will be sent to the console or the log files. (One common reason for the failure to start is the permissions issue I noted earlier).</p><p>A good first step in solving startup problems is to run <code class="literal">slapd</code> from the command line, with debugging enabled: <code class="literal">sudo slapd -d trace</code>.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Summary</h1></div></div></div><p>In this appendix we looked at a couple of useful commands, including some designed to get detailed information about the directory server itself. Also, we saw two ways of making directory backups, and examined the process of rebuilding a directory database.</p></div></body></html>