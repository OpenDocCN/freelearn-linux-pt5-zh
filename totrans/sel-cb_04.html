<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating a Desktop Application Policy</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Researching the application's logical design</li><li class="listitem" style="list-style-type: disc">Creating a skeleton policy</li><li class="listitem" style="list-style-type: disc">Setting context definitions</li><li class="listitem" style="list-style-type: disc">Defining application role interfaces</li><li class="listitem" style="list-style-type: disc">Testing and enhancing the policy</li><li class="listitem" style="list-style-type: disc">Ignoring permissions we don't need</li><li class="listitem" style="list-style-type: disc">Creating application resource interfaces</li><li class="listitem" style="list-style-type: disc">Adding conditional policy rules</li><li class="listitem" style="list-style-type: disc">Adding build-time policy decisions</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Introduction</h1></div></div></div><p>Up until now, we've modified and enhanced existing policies and interacted with the SELinux subsystem through the available administrative commands. But, in order to truly benefit from the protection measures that SELinux provides, we need to create our own policies for applications that would otherwise run with either too many privileges, or not run at all.</p><p>Desktop applications are<a id="id269" class="indexterm"/> a good example. The end user domains (<code class="literal">unconfined_t</code> for policies which support unconfined domains, and <code class="literal">user_t</code>, <code class="literal">staff_t</code>, and the like for the other policies) have many privileges assigned to them to allow generic applications to be executed while remaining in the user domain.</p><p>This has a huge downside: vulnerabilities within desktop applications or malfunctioning applications can create havoc with the users' files and resources, potentially exposing information to malicious users. If all end user applications run within the same domain, then we cannot talk about a least privilege environment. After all, this single user domain then has to<a id="id270" class="indexterm"/> have the sum of all privileges needed by various applications.</p><p>In this chapter, we will create a desktop application policy for Microsoft Skype™, a popular text messaging, voice, and video call application, which also runs on Linux systems, but is proprietary and thus its code cannot be reviewed to find what it might do. Confining this application ensures that the application can only perform the actions we allow it to do.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Researching the application's logical design</h1></div></div></div><p>Before <a id="id271" class="indexterm"/>embarking on a policy development spree, we need to look at the application's behavior and logical design. We will get to know the application and its interactions as we begin to model this into the SELinux policy.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec88"/>How to do it…</h2></div></div></div><p>To prepare an SELinux policy for the application, let's first look at how the application behaves:</p><div><ol class="orderedlist arabic"><li class="listitem">Look into the files and directories that the application will interact with and write down the privileges that the application needs. Try to structure access based on the functionalities of the application.</li><li class="listitem">Figure out which network resources are required by the application, which ports does the application bind (listen) to (if any), and which ports does it need to connect to.</li><li class="listitem">If the application needs to interact with other SELinux domains (processes), how does this interaction look (or what is it for)?</li><li class="listitem">Does the application require specific hardware access or other kernel-provided resources?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec89"/>How it works…</h2></div></div></div><p>Gathering information on at least these four resources (files, network, applications, and hardware/kernel) helps us to start with a skeleton policy file. In the end, we might have a schematic representation of these resources, as shown in the following diagram:</p><div><img src="img/9669OS_04_01.jpg" alt="How it works…"/></div><p>Let's look at how this works out for our example.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec21"/>Files and directories</h3></div></div></div><p>There <a id="id272" class="indexterm"/>are three main file accesses needed for the Skype™ application.</p><p>The first is <a id="id273" class="indexterm"/>its own, user-specific configuration, which is stored at <code class="literal">~/.Skype/</code>. This will contain all settings for the application, including contact list, chat history, and more. In SELinux, user-specific configuration entries are labeled as <code class="literal">*_home_t</code> and marked as user home content, allowing the end user to still manage these resources.</p><p>The<a id="id274" class="indexterm"/> second<a id="id275" class="indexterm"/> consists of the generic user files, which our application needs access to in order to upload or download files. This can be any end user file, although some distributions create specific support for this (such as through a <code class="literal">~/Downloads/</code> location).</p><p>The third consists of the general resources of the Unix system that are available for the application. This access is needed for the application to load the necessary libraries. During application policy development, this is often not mentioned, as it is a default access provided to all applications.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec22"/>Network resources</h3></div></div></div><p>The application needs to interact with network resources through its messaging, voice, and video chat functionality.</p><p>In <a id="id276" class="indexterm"/>general, we know that the application<a id="id277" class="indexterm"/> needs to connect to the central Skype™ infrastructure for all centrally managed services, such as authentication, directory searches, and more. This connection will be through TCP.</p><p>Next to the central infrastructure, the application will also connect to the Skype™ instances of other users for direct communication. This connection will be through both TCP and UDP (as UDP is more common for video and voice).</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec23"/>Processes</h3></div></div></div><p>As the <a id="id278" class="indexterm"/>application is a graphical application, we know <a id="id279" class="indexterm"/>that it needs to interact with the X11 server running on the workstation. As we will see in the recipes in this chapter, this automatically requires a set of types and permissions to be assigned to the application.</p><p>Other than that, there are no specific interactions with other domains.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec24"/>Hardware and kernel resources</h3></div></div></div><p>Finally, on<a id="id280" class="indexterm"/> the hardware level, the application<a id="id281" class="indexterm"/> will need access to the video and sound devices (for the webcam and voice call functionality, respectively).</p><p>The <a id="id282" class="indexterm"/>application will also need to use the user<a id="id283" class="indexterm"/> terminals in case of errors (so that the error message can be displayed).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>Creating a skeleton policy</h1></div></div></div><p>With the<a id="id284" class="indexterm"/> logical setup now in place, we can draft a skeleton policy. This policy will be a translation from the logical setup we encountered to SELinux policy rules.</p><p>The entire policy is written in a <code class="literal">myskype.te</code> file. The final result of this set of recipes is also available through the download pack of this book as a reference.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec90"/>How to do it…</h2></div></div></div><p>We start with a base skeleton that we can enhance later. This skeleton is developed as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">We start with the declaration of the various types. From the design, we can deduce four types:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">skype_t</code> as the main process domain</li><li class="listitem" style="list-style-type: disc"><code class="literal">skype_exec_t</code> as the label for the Skype executable(s)</li><li class="listitem" style="list-style-type: disc"><code class="literal">skype_home_t</code> for the user configuration files and directories of the <code class="literal">skype_t</code> domain</li><li class="listitem" style="list-style-type: disc"><code class="literal">skype_tmpfs_t</code> is needed for shared memory and the X11 interaction</li></ul></div><p>The code to deduce these four types is as follows:</p><div><pre class="programlisting">policy_module(myskype, 0.1)

attribute_role skype_roles;

type skype_t;
type skype_exec_t;
userdom_user_application_domain(skype_t, skype_exec_t)
role skype_roles types skype_t;

type skype_home_t;
userdom_user_home_content(skype_home_t)

type skype_tmpfs_t;
userdom_user_tmpfs_file(skype_tmpfs_t);</pre></div></li><li class="listitem">Next, we <a id="id285" class="indexterm"/>write up the policy rules for accessing the various types, starting with the manage rights on <code class="literal">~/.Skype/</code>:<div><pre class="programlisting"># Allow manage rights on ~/.Skype
manage_dirs_pattern(skype_t, skype_home_t, skype_home_t)
manage_files_pattern(skype_t, skype_home_t, skype_home_t)
userdom_user_home_dir_filetrans(skype_t, skype_home_t, dir, ".Skype")</pre></div></li><li class="listitem">We enable the <code class="literal">X11</code> access and shared memory. This is a common set of privileges that need to be assigned to X11-enabled applications:<div><pre class="programlisting"># Shared memory (also needed for X11)
manage_files_pattern(skype_t, skype_tmpfs_t, skype_tmpfs_t)
manage_lnk_files_pattern(skype_t, skype_tmpfs_t, skype_tmpfs_t)
manage_fifo_files_pattern(skype_t, skype_tmpfs_t, skype_tmpfs_t)
manage_sock_files_pattern(skype_t, skype_tmpfs_t, skype_tmpfs_t)
fs_tmpfs_filetrans(skype_t, skype_tmpfs_t, { file lnk_file fifo_file sock_file })

# Application is an X11 application
xserver_user_x_domain_template(skype, skype_t, skype_tmpfs_t)</pre></div></li><li class="listitem">Next, we <a id="id286" class="indexterm"/>write down the network access rules, as follows:<div><pre class="programlisting"># Network access
corenet_tcp_bind_generic_node(skype_t)
corenet_udp_bind_generic_node(skype_t)
# Central skype services
corenet_tcp_connect_http_port(skype_t)
corenet_tcp_connect_all_unreserved_ports(skype_t)
# Listen for incoming communication
corenet_tcp_bind_all_unreserved_ports(skype_t)
corenet_udp_bind_all_unreserved_ports(skype_t)</pre></div></li><li class="listitem">Finally, we have the device accesses:<div><pre class="programlisting"># Voice and video calls
dev_read_sound(skype_t)
dev_read_video_dev(skype_t)
dev_write_sound(skype_t)
dev_write_video_dev(skype_t)
# Terminal (tty) output
userdom_use_user_terminals(skype_t)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec91"/>How it works…</h2></div></div></div><p>In the skeleton policy, we start with the SELinux policy rules that we know will be necessary. If we are somewhat uncertain about one or more rules, it is perfectly fine to comment them out for starters and enable those as we move on to the testing phase in the <em>Testing and enhancing the policy</em> recipe later.</p><p>The skeleton starts off with the type declarations, which focus on the resources of the application. We then enhance the application domain with the proper privileges towards these resources. After the resource access, we look at the X11 privileges and finish with the network interaction of the application.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec25"/>Type declarations</h3></div></div></div><p>The first <a id="id287" class="indexterm"/>part of any policy is the declaration of types and roles. We <a id="id288" class="indexterm"/>first create a role attribute called <code class="literal">skype_roles</code> to which the <code class="literal">skype_t</code> SELinux domain is granted. This role attribute will then be assigned to the users who are allowed to call the application. Next, we list the various SELinux types that the policy will provide and also give those types a specific meaning. For instance, the <code class="literal">skype_t</code> and <code class="literal">skype_exec_t</code> types are given the proper meaning through the <code class="literal">userdom_user_application_domain</code> template. This template looks like the following:</p><div><pre class="programlisting">interface(`userdom_user_application_domain',`
        application_domain($1, $2)
        ubac_constrained($1)
')</pre></div><p>The <code class="literal">application_domain</code> template, which is called from within <code class="literal">userdom_user_application_domain</code>, has the following definition:</p><div><pre class="programlisting">interface(`application_domain',`
        application_type($1)
        application_executable_file($2)
        domain_entry_file($1, $2)
')</pre></div><p>This<a id="id289" class="indexterm"/> results in the <code class="literal">skype_t</code> domain to be marked as<a id="id290" class="indexterm"/> an application type (a true domain), whereas <code class="literal">skype_exec_t</code> is an executable file, which can be used as an entry point to the <code class="literal">skype_t</code> domain. Finally, <code class="literal">skype_t</code> is marked as <code class="literal">ubac_constrained</code>, which is used in case of <strong>User-based access control</strong> (<strong>UBAC</strong>), where access to resources is not only governed through<a id="id291" class="indexterm"/> the types and its access vectors, but also through the SELinux user. In other words, if the SELinux user, <code class="literal">userX_u</code>, would somehow be able to access the processes of another SELinux user (<code class="literal">userY_u</code>), then the <code class="literal">skype_t</code> domain will not be reachable as the UBAC constraints would come in action, preventing any interaction between the two.</p><p>All <code class="literal">userdom_user_*</code> templates mark the associated resources as UBAC constrained, together <a id="id292" class="indexterm"/>with the true file type association, so <code class="literal">userdom_user_tmpfs_file</code> marks the file not only as a <code class="literal">tmpfs_t</code> file (the type used for shared memory), but also makes it UBAC constrained.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec26"/>Managing files and directories</h3></div></div></div><p>Next, we <a id="id293" class="indexterm"/>provide the access rights to files and resources. In <a id="id294" class="indexterm"/>the example, we limit access to <code class="literal">~/.Skype/</code> only and automatically mark <code class="literal">~/.Skype/</code> as <code class="literal">skype_home_t</code> when it is created inside a user home directory (through <code class="literal">userdom_user_home_dir_filetrans</code>), even though we identified the need to manage user content files as well. This is because we need to make a policy design decision here—do we want the application to have full access to all user resources or would we rather limit the access? And inversely, do we want other applications that can access user content to access Skype™ user (configuration) data?</p><p>If we do not want the application to access any user content, then we do not need to add any rules: the policy will only allow search rights through the user home directory (in order to locate <code class="literal">~/.Skype/</code>) and deny everything else.</p><p>If we <a id="id295" class="indexterm"/>would like to grant the application access to the<a id="id296" class="indexterm"/> user content, we can add in the following calls:</p><div><pre class="programlisting">userdom_manage_user_home_content_files(skype_t)
userdom_manage_user_home_content_dirs(skype_t)</pre></div><p>This will <a id="id297" class="indexterm"/>grant full manage rights on user files and directories to the <code class="literal">skype_t</code> domain.</p><p>In the Gentoo Linux policy, additional types have been made available to provide a finer-grained access control to user files. These types map to the <strong>XDG Base Directory Specification</strong> (<strong>XDGBDS</strong>) as provided by the Free Desktop community, and include the <code class="literal">xdg_downloads_home_t</code> type. End users can mark files and directories as <code class="literal">xdg_downloads_home_t</code> and allow applications to have selective access to user files, without risking that these applications have access to the more private files of that user.</p><p>In Gentoo, this means that the following call can be added to the policy:</p><div><pre class="programlisting">xdg_manage_downloads_home(skype_t)</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec27"/>X11 and shared memory</h3></div></div></div><p>When <a id="id298" class="indexterm"/>an application needs to interact with the X11 server (as a client application), much of this interaction is done through shared memory. In Linux, shared <a id="id299" class="indexterm"/>memory can be interpreted as files on a tmpfs mount (think <code class="literal">/dev/shm/</code>) although other shared memory constructions are still possible without tmpfs.</p><p>In SELinux, policy<a id="id300" class="indexterm"/> developers want to make sure that this <a id="id301" class="indexterm"/>shared memory is labeled specifically for the domain. For this, they create a type with <code class="literal">_tmpfs_t</code> as the suffix. In our example, this is <code class="literal">skype_tmpfs_t</code>. Of course, we need to grant manage rights on the shared memory (for all classes that will be used) to the <code class="literal">skype_t</code> domain. In case of X11 interaction, these are files, symbolic links, FIFOs, and sockets.</p><p>Next to the manage rights, we also include a file transition: whenever <code class="literal">skype_t</code> creates a file, symbolic link, FIFO, or socket in a <code class="literal">tmpfs_t</code> labeled location, then this resource should be automatically labeled <code class="literal">skype_tmpfs_t</code>. This is done through the <code class="literal">fs_tmpfs_filetrans</code> call.</p><p>Finally, we use <code class="literal">xserver_user_x_domain_template</code> that contains all the SELinux privileges necessary for both the X11 client as well as X11 server to interact with each other. This template uses a prefix argument (the first argument, which we provided as <code class="literal">skype</code>), which will be used to create an X11 resource type called <code class="literal">skype_input_xevent_t</code>. Similar to what we've seen for web servers (where an <code class="literal">apache_content_template</code> call was used), this template gives an easy approach to automatically build additional types and enable the X11 support.</p><p>Next to <a id="id302" class="indexterm"/>the prefix, the domain itself is passed (<code class="literal">skype_t</code>) and <a id="id303" class="indexterm"/>the <a id="id304" class="indexterm"/>label used for<a id="id305" class="indexterm"/> the shared memory (<code class="literal">skype_tmpfs_t</code>) are passed on as those are needed for the X11 server support.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec28"/>The network access</h3></div></div></div><p>For the <a id="id306" class="indexterm"/>network access, we start by providing the <code class="literal">skype_t</code> domain with bind privileges on a TCP socket and its IP address (which is represented by <code class="literal">node_t</code>).</p><p>Next, we<a id="id307" class="indexterm"/> allow the <code class="literal">skype_t</code> domain to connect to the central Skype™ services, which are available on HTTPS port <code class="literal">443</code> (authentication) and various seemingly random high TCP ports (network nodes). The HTTP target port is identified as an <code class="literal">http_port_t</code> type, the others are for the unreserved ports.</p><p>Finally, we allow the <code class="literal">skype_t</code> domain to listen for incoming communications. By default, this is on a high TCP port for messages and state information, while for voice and video chat, this is through UDP.</p><p>A simple way to identify the necessary types is to look at the <code class="literal">netstat</code> output, as it shows us what ports a process is listening on, the protocol family (TCP or UDP), as well as which ports it is connecting to:</p><div><pre class="programlisting">
<strong>~$ netstat -naput | grep skype</strong>
<strong>tcp  0  0 0.0.0.0:34431  0.0.0.0:*  LISTEN  8160/skype</strong>
<strong>tcp  0  0 10.221.44.241:40650  111.221.77.150:40008  ESTABLISHED  8160/skype</strong>
<strong>…</strong>
<strong>udp  0  0 0.0.0.0:34302  0.0.0.0:*    8160/skype</strong>
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec92"/>There's more...</h2></div></div></div><p>The <a id="id308" class="indexterm"/>access to the sound and video devices is trivial, but during the design, it is very well possible that many more accesses are already identified (as ours is just an example). As we continue developing policies, writing a skeleton policy will become more trivial.</p><p>A great source for learning more about the policies is to look for an existing policy of a similar application, or an application that has certain functionalities that resemble the functionalities offered by the application we're writing a policy for. For Skype™, we could look at the policy of Gift (a peer-to-peer file sharing application), which is an end user, graphical application with peer-to-peer communication flows, supporting uploading and downloading files.</p><p>After all, SELinux policies are a write-down of what the expected behavior is of a domain. If another application has the same or similar behavior, then its policy will be very similar too.</p><p>In the <a id="id309" class="indexterm"/>previous example, we grouped the permissions together based on the functional need. However, the coding style for SELinux policy files, as mentioned by the reference policy, uses a different grouping, so make sure that if the policy would be sent upstream, this coding style is followed instead.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec93"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For <a id="id310" class="indexterm"/>more information about the XDGBDS, see <a class="ulink" href="http://standards.freedesktop.org/basedir-spec/latest/">http://standards.freedesktop.org/basedir-spec/latest/</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Setting context definitions</h1></div></div></div><p>The next <a id="id311" class="indexterm"/>step in the policy development is to mark its resources with the proper file contexts. This will label the files of the application correctly, making sure that the SELinux policy makes the right decisions.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec94"/>How to do it…</h2></div></div></div><p>To update the file context definitions, follow the next set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">myskype.fc</code> file and add in the definition for <code class="literal">~/.Skype/</code>:<div><pre class="programlisting">HOME_DIR/\.Skype(/.*)?  gen_context(system_u:object_r:skype_home_t,s0)</pre></div></li><li class="listitem">Next, add in the definitions for the <code class="literal">skype</code> binaries:<div><pre class="programlisting">/opt/skype/skype  --  gen_context(system_u:object_r:skype_exec_t,s0)
/opt/bin/skype  --  gen_context(system_u:object_r:skype_exec_t,s0)
/usr/bin/skype  --  gen_context(system_u:object_r:skype_exec_t,s0)</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec95"/>How it works…</h2></div></div></div><p>The definitions for the binaries are standard, path-based context declarations. The one for the user home directory, however, is special.</p><p>As can be seen from the example, the path starts with <code class="literal">HOME_DIR</code>. This is a special variable used by SELinux libraries, which automatically maps to all Linux users' home directories. Rather than creating a <code class="literal">/home/[^/]*/\.Skype(/.*)?</code> context directly, which has the design problem that home directories on other locations (such as <code class="literal">/export/home/user/</code>) will not match, the SELinux libraries will check the home directories of all real users (with a user ID starting at <code class="literal">500</code>, although this is configurable) and for<a id="id312" class="indexterm"/> each different home root directory (<code class="literal">/home/</code> is the most commonly used one), it will generate the proper contexts.</p><p>The result of this operation is stored as the <code class="literal">file_contexts.homedirs</code> file inside <code class="literal">/etc/selinux/mcs/contexts/files/</code> and is automatically created during policy build (through the <code class="literal">genhomedircon</code> command).</p><p>Next to <code class="literal">HOME_DIR</code>, other supported variables are <code class="literal">HOME_ROOT</code> (which represents the home root path) and <code class="literal">ROLE</code> (which is the first role associated with a user).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Defining application role interfaces</h1></div></div></div><p>Finally, before<a id="id313" class="indexterm"/> testing the policy, we need to create a role interface and assign it to the user domain that will be used to test (and run) the application. If we don't create a role interface and assign it to a user domain, then the user domain will either have no privileges to execute the application at all, or the application will run with the user context rather than the newly defined <code class="literal">skype_t</code> domain. If the user domain isn't unconfined, then chances are that the application will fail.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec96"/>How to do it…</h2></div></div></div><p>Role interfaces are the gateways of a policy. They ensure that domains and SELinux users can interact with the application and that the set of privileges for a particular application are coherent.</p><p>We create such an interface in the <code class="literal">.if</code> file and then assign this interface to a user domain in order to test the interface:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">myskype.if</code> file with the following interface in it:<div><pre class="programlisting">interface(`skype_role',`
  gen_require(`
    type skype_t, skype_exec_t, skype_tmp_t, skype_home_t;
  ')
  # Allow the skype_t domain for the user role
  roleattribute $1 skype_roles;
  # Allow domain transition for user domain to skype_t
  domtrans_pattern($2, skype_exec_t, skype_t)
  # Interact with skype process
  ps_process_pattern($2, skype_t)
  allow $2 skype_t:process { ptrace signal_perms };
  # Manage skype file resources
  manage_dirs_pattern($2, skype_home_t, skype_home_t)
  manage_files_pattern($2, skype_home_t, skype_home_t)
  manage_lnk_files_pattern($2, skype_home_t, skype_home_t)
  # Allow user to relabel the resources if needed
  relabel_dirs_pattern($2, skype_home_t, skype_home_t)
  relabel_files_pattern($2, skype_home_t, skype_home_t)
  relabel_lnk_files_pattern($2, skype_home_t, skype_home_t)
')</pre></div></li><li class="listitem">Create a <a id="id314" class="indexterm"/>policy for the user domain (for instance, <code class="literal">myunprivuser.te</code>) that grants regular users access to the <code class="literal">skype_t</code> domain, by assigning the user domain the <code class="literal">skype_role</code> call:<div><pre class="programlisting">policy_module(myunprivuser, 1.0)
gen_require(`
  type user_t;
  role user_r;
')
optional_policy(`
  skype_role(user_r, user_t)
')</pre></div></li><li class="listitem">Build both policies and load them. Then, relabel the <code class="literal">skype</code> binary files (and possibly preexisting <code class="literal">~/.Skype/</code> locations):<div><pre class="programlisting">
<strong>~# restorecon /opt/skype/bin/skype /opt/bin/skype /usr/bin/skype</strong>
<strong>~# restorecon -RF /home/user/.Skype</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec97"/>How it works…</h2></div></div></div><p>Although we have defined all the rules for the <code class="literal">skype_t</code> domain that we think are needed (in the next recipe, the policy will be extended until it really works), we have not defined the rules yet to allow a user domain to actually execute the <code class="literal">skype_exec_t</code> binaries and have the process run in the <code class="literal">skype_t</code> domain.</p><p>To accomplish that, we need to ensure that a domain transition occurs to the <code class="literal">skype_t</code> domain when the user executes <code class="literal">skype_exec_t</code>. This is handled by the <code class="literal">domtrans_pattern</code> call. But before we allow the domain transition, we first need to allow the <code class="literal">skype_t</code> domain for the user role, which is done through the <code class="literal">roleattribute</code> call.</p><p>Until now, we focused primarily on type enforcement rules (that is, granting privileges to SELinux domains based on the label of the target resource). In order to allow certain users to run an application, the application domain itself needs to be granted to the user role. This is supported through SELinux's <strong>role-based access control</strong> <strong>(RBAC</strong>) model. This <a id="id315" class="indexterm"/>RBAC model ensures that a certain domain (<code class="literal">skype_t</code>, in our example) can only be used by the roles we configure it for (<code class="literal">user_r</code>, in our example). Other roles, such as DBA roles (<code class="literal">dbadm_r</code>) might have no need for running the Skype™ application, so they will not be granted access to the <code class="literal">skype_t</code> domain.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Not granting a domain does not necessarily prevent the application from executing within the user domain itself. To accomplish that, we need to make sure that the executable file type cannot be executed by other roles. Instead of using <code class="literal">userdom_user_application_domain</code> for the <code class="literal">skype_t</code> and <code class="literal">skype_exec_t</code> types (which would assign a generic executable attribute to the <code class="literal">skype_exec_t</code> type), we would use something similar to the following:</p><div><pre class="programlisting">application_type(skype_t)
files_type(skype_exec_t)
allow skype_t skype_exec_t:file { entrypoint mmap_file_perms ioctl lock };
ubac_constrained(skype_t)</pre></div></div></div><p>As the<a id="id316" class="indexterm"/> user domain, which needs to be able to execute Skype™, also needs to manage the <code class="literal">skype_home_t</code> files (in case, manual intervention in <code class="literal">~/.Skype/</code> is needed or to make backups), we grant it both manage privileges as well as relabel privileges. The relabel privileges are needed when, for instance, a backup is restored.</p><p>For the user domain, we then call the <code class="literal">skype_role</code> interface we just created. In the example, we used the <code class="literal">optional_policy</code> statement. This allows policy modules to be loaded even when one of the calls cannot be resolved or is not supported.</p><p>Suppose we need to unload the <code class="literal">myskype</code> module. Without the <code class="literal">optional_policy</code> statement, the <code class="literal">myunprivuser</code> module would need to be unloaded as well, even though this policy module might contain other rules that are important for the user domain to work correctly (in the example, we only called the <code class="literal">skype_role</code> interface, but after some time, the module might call many other interfaces as well). If we don't unload the module and no <code class="literal">optional_policy</code> statements are used, then SELinux will warn the administrator about unresolved dependencies between the modules.</p><p>With <a id="id317" class="indexterm"/>the <code class="literal">optional_policy</code> statement, the SELinux tools know that the call might become unresolvable, in which case, the entire block (everything inside the <code class="literal">optional_policy</code> block) will be ignored while the module remains loaded.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec98"/>There's more...</h2></div></div></div><p>At the beginning of the recipe, we mentioned that unconfined user domains will be able to execute the application without a domain transition. This is to be expected, as the entire idea behind unconfined domains is that they are, well, unconfined.</p><p>It is considered a bad practice to, in general, create domain transitions from an unconfined domain to confined domains. Only in very specific circumstances do domain transitions from an unconfined domain to confined domains make sense (such as when the <a id="id318" class="indexterm"/>target domain is used to confine potentially vulnerable applications, such as a sandbox domain).</p><p>From a security perspective, it makes more sense to confine users immediately and use the proper domain transitions between (confined) user domains and the application domains.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Testing and enhancing the policy</h1></div></div></div><p>With the <a id="id319" class="indexterm"/>policy ready and loaded, it is time to start testing the application from a user's perspective, while keeping an eye on the audit logs (for denials) and application output.</p><p>Testing the<a id="id320" class="indexterm"/> application is an important phase of policy development and will also be the most time consuming task. During testing, several functional features of the application will be tried and the resulting permissions (SELinux-wise) will need to be added to the policy.</p><p>In previous recipes, such as <em>Creating a skeleton policy</em>, we enabled a set of permissions based on other policies and common sense. However, these permissions have not been validated and tested yet. In this recipe, we will assert that the permissions are truly needed, as we do not want to create a policy with too many rights associated with it.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec99"/>How to do it…</h2></div></div></div><p>Testing policies is a repetitive task. Every try-out means that the AVC denials leading up to the start need to be discarded (as we do not want to include privileges not related to the test) after which the application is tested and the results are documented. Depending on how the application acts, new policy rules are added to the policy:</p><div><ol class="orderedlist arabic"><li class="listitem">Write down the current timestamp or create a reference point inside the audit logs (for instance, by reloading the SELinux policy), so we know from which point in the audit logs we need to look at the audit events:<div><pre class="programlisting">
<strong>~# semodule -R</strong>
</pre></div></li><li class="listitem">As an end user, start the application (from a terminal window) and watch what happens.</li><li class="listitem">Write down the error that is displayed (if any):<div><pre class="programlisting">
<strong>~$ skype</strong>
<strong>skype: error while loading shared libraries: cannot restore segment prot after reloc: Permission denied</strong>
</pre></div></li><li class="listitem">Look into the denials as displayed in the audit logs:<div><pre class="programlisting">
<strong>~# ausearch -m avc -ts recent</strong>
</pre></div></li><li class="listitem">For each first denial or denial related to the error shown earlier, try to enhance the policy with the proper call and try again.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec100"/>How it works…</h2></div></div></div><p>In this <a id="id321" class="indexterm"/>phase, we are enhancing the policy step by step. Some policy<a id="id322" class="indexterm"/> developers like to run the application in permissive mode (either by running the entire system in permissive mode or by marking this particular domain as a permissive domain), registering all accesses performed (through the AVC denials) and enhancing the policy based on that information. Although this might give a faster working policy, these developers will also risk that they add too many privileges to a policy, something that is very difficult to challenge and change later.</p><p>Instead, we let SELinux prevent accesses and look at how the application reacts. Based on the error logging of the application or the behavior of the application and the AVC denial(s) seen through the logs, we can have a good picture of what privileges are really needed.</p><p>For instance, simultaneously with the error presented in the example, the following denial occurred:</p><div><pre class="programlisting">type=AVC msg=audit(1398930752.113:608): avc: denied { execmod } for pid=8943 comm="skype" path="/opt/bin/skype" dev="dm-2" ino=801 scontext=user_u:user_r:skype_t:s0 tcontext=user_u:user_r:skype_exec_t:s0 tclass=file</pre></div><p>It is important that we focus on the first set of denials that occur and not on all denials shown. It is very likely that denials shown after the first set of denials are from error handling routines, either by the application or the system in general, which would never be triggered in the first place if the proper permissions are granted to the domain. Trying to grant those privileges as well would result in a too broadly defined set of permissions.</p><p>The preceding denial shown would result in the following addition to the policy:</p><div><pre class="programlisting"># Error 'cannot restore segment prot after reloc'
allow skype_t skype_exec_t:file execmod;</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Ignoring permissions we don't need</h1></div></div></div><p>After<a id="id323" class="indexterm"/> repeated testing, we will have a policy that works, even though denials might still show up in the audit logs. In order not to alarm any administrator, we might want to disable auditing of those specific denials (while, of course, ensuring that critical access vectors are still logged by the audit daemon).</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec101"/>How to do it…</h2></div></div></div><p>In order to disable logging of certain denials that do not influence an application's behavior, trigger the denial and then register the <code class="literal">dontaudit</code> statements as explained in the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">For each denial shown in the audit logs, we need to find the corresponding <code class="literal">dontaudit</code> rule set. Consider the following instance:<div><pre class="programlisting">type=AVC msg=audit(1398936489.877:2464): avc: denied { search } for pid=8241 comm="skype" name="modules" dev="dm-0" ino=1322041 scontext=user_u:user_r:skype_t:s0 tcontext=user_u:object_r:user_home_t:s0 tclass=dir</pre></div></li><li class="listitem">Search through the SELinux policies for <code class="literal">dontaudit</code> statements on this matter:<div><pre class="programlisting">
<strong>~$ sefindif dontaudit.*user_home_t.*search</strong>
<strong>interface(`userdom_dontaudit_search_user_home_content',`</strong>
<strong>  dontaudit $1 user_home_t:dir search_dir_perms;</strong>
</pre></div></li><li class="listitem">Add in the interface call to the policy, rebuild the policy, and then reload it. Repeat until all cosmetic denials are no longer visible.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec102"/>How it works…</h2></div></div></div><p>Many operations performed by applications can be seen as cosmetic—although in the example, the application really performs the searches through the user files, they are not needed for the application to function correctly. For instance, it might be searching through the entire directory until it finds its own files, which it does have access to.</p><p>By adding the <code class="literal">dontaudit</code> statements for these operations, we ensure that the audit logs stay clean.</p><p>In case of problems, the administrator can still disable the <code class="literal">dontaudit</code> statements in the policy, revealing every denial that SELinux has triggered (even those that are explicitly marked as <code class="literal">dontaudit</code>):</p><div><pre class="programlisting">
<strong>~# semodule -DB</strong>
</pre></div><p>To re-enable the <code class="literal">dontaudit</code> statements, rebuild and reload the policy:</p><div><pre class="programlisting">
<strong>~# semodule -B</strong>
</pre></div><p>In certain situations, there might not be an interface related to <code class="literal">dontaudit</code> available. In that case, create a new interface (as part of an SELinux policy module) with the <code class="literal">dontaudit</code> rules defined in it. For instance, for a <code class="literal">dontaudit</code> rule set to ignore getting the <a id="id324" class="indexterm"/>attributes of <code class="literal">mozilla_home_t</code> content, we would create a <code class="literal">mymozilla</code> policy module with the <code class="literal">mozilla_dontaudit_getattr_home</code> interface declared in it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Creating application resource interfaces</h1></div></div></div><p>Our <a id="id325" class="indexterm"/>application policy is almost ready for deployment. However, it currently is mainly end user focused, and there are no ways of interacting with the <code class="literal">skype_t</code> domain (or other resources managed by the <code class="literal">skype</code> module) except through the <code class="literal">skype_role</code> interface.</p><p>In this recipe, we'll add an interface for reading <code class="literal">skype_home_t</code>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec103"/>How to do it…</h2></div></div></div><p>Alongside the <code class="literal">skype_role</code> interface that we created in the <em>Defining application role interfaces</em> recipe, we need to create additional resource interfaces so that other domains can easily interact with the newly created policy:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">myskype.if</code> file and add in the following content:<div><pre class="programlisting">interface(`skype_read_home',`
  gen_require(`
    type skype_home_t;
  ')
  userdom_search_user_home_dirs($1)
  allow $1 skype_home_t:dir list_dir_perms;
  allow $1 skype_home_t:file read_file_perms;
  allow $1 skype_home_t:lnk_file read_lnk_file_perms;
')</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec104"/>How it works…</h2></div></div></div><p>The recipe itself is simple—for each interaction with resources managed by the <code class="literal">skype</code> module, we need to create an interface that can be called by other modules.</p><p>Each interface should be complete. For instance, in order to read the <code class="literal">skype_home_t</code> content, a domain will first need to be able to search through the user's home directory (<code class="literal">user_home_dir_t</code>, which is not the same as <code class="literal">user_home_t</code> as the former is the type for the home directory while the latter is for its contents); hence, the call to <code class="literal">userdom_search_user_home_dirs</code>.</p><p>Then, the necessary privileges are assigned to the domain. As we do not provide any class identifier in the interface name, the interface will grant read access to all (significant) classes related to the <code class="literal">skype_home_t</code> type.</p><p>If we only want to grant read access to files (and not to the <code class="literal">directory</code> class), then the interface would be called <code class="literal">skype_read_home_files</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Adding conditional policy rules</h1></div></div></div><p>We can <a id="id326" class="indexterm"/>further fine-tune our policy with conditionals. Some of the access vectors identified earlier might not be necessary in all circumstances, so it makes sense to make them optional and configurable through SELinux Booleans.</p><p>Two of the identified access vectors that are candidates for configurable policies are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accessing the video and sound devices (in order to reduce the risk of malware or vulnerabilities in the application to access the webcam or sound device and spy on the unsuspecting users)</li><li class="listitem" style="list-style-type: disc">Accessing all user content (instead of only the <code class="literal">skype_home_t</code> content)</li></ul></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec105"/>How to do it…</h2></div></div></div><p>The following set of steps allows us to make the policy more flexible for the administrators to handle by introducing Booleans. These Booleans modify the behavior of the policy and are added to a policy.</p><div><ol class="orderedlist arabic"><li class="listitem">Inside <code class="literal">myskype.te</code>, create the definitions for both Booleans. This is usually done before the type declarations:<div><pre class="programlisting">gen_tunable(skype_use_audio, false)
gen_tunable(skype_use_video, false)
gen_tunable(skype_manage_user_content, false)</pre></div></li><li class="listitem">Inside the policy, group the statements that we want to trigger through the Booleans:<div><pre class="programlisting">tunable_policy(`skype_use_audio',`
  dev_read_sound(skype_t)
  dev_write_sound(skype_t)
')
tunable_policy(`skype_use_video',`
  dev_read_video_dev(skype_t)
  dev_write_video_dev(skype_t)
')
tunable_policy(`skype_manage_user_content',`
  userdom_manage_user_home_content_dirs(skype_t)
  userdom_manage_user_home_content_files(skype_t)
')</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec106"/>How it works…</h2></div></div></div><p>The <code class="literal">gen_tunable</code> declarations will generate Booleans that administrators can toggle on the system. The <a id="id327" class="indexterm"/>first argument of each declaration is the name of the Boolean to be created, while the second argument sets the default value of the Boolean.</p><p>Once<a id="id328" class="indexterm"/> Booleans are defined, the <code class="literal">tunable_policy</code> statements allow for grouping the statement calls that need to be made configurable.</p><p>It is possible to have rules enabled when a Boolean is disabled as well. For instance, for the <code class="literal">skype_manage_user_content</code> one, the following code can be used:</p><div><pre class="programlisting">tunable_policy(`skype_manage_user_content',`
  # boolean enabled
  userdom_manage_user_home_content_dirs(skype_t)
  userdom_manage_user_home_content_files(skype_t)
  ',`
  # boolean disabled
  userdom_dontaudit_manage_user_home_content_dirs(skype_t)
  userdom_dontaudit_read_user_home_content_files(skype_t)
  …
')</pre></div><p>Booleans can also be combined, as shown in the following code:</p><div><pre class="programlisting">tunable_policy(`use_nfs_home_dirs &amp;&amp; skype_manage_user_content',` … ')</pre></div><p>In such situations, the policy group rules will only take effect if both the Booleans are enabled.</p><p>It is also possible to only enable rules if a Boolean is not set, as shown in the next line of code:</p><div><pre class="programlisting">tunable_policy(`!use_nfs_home_dirs',` … ')</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec107"/>There's more...</h2></div></div></div><p>Tunable policies are a powerful extension to SELinux. However, there are some caveats to this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It is not simple to make the description of SELinux Booleans available to the administrator. The descriptions are defined through in-policy comments, but this is not used for custom modules—a full policy build needs to be made in order to generate the <code class="literal">policy.xml</code> file that contains all descriptions.</li><li class="listitem" style="list-style-type: disc">It is not possible to assign attributes within a <code class="literal">tunable_policy</code> group. Instead, policy developers will need to make the permissions related to the attribute configurable (if possible) or not assign the attribute at all.</li><li class="listitem" style="list-style-type: disc">It is not possible to use named file transitions within a <code class="literal">tunable_policy</code> group. In general, that doesn't matter that much—there are a few situations where a named file transition would depend on a Boolean, but these situations do occur.</li><li class="listitem" style="list-style-type: disc">It is<a id="id329" class="indexterm"/> not possible to have the <code class="literal">optional_policy</code> statements within a <code class="literal">tunable_policy</code> group. Instead, wrap the <code class="literal">tunable_policy</code> call with an <code class="literal">optional_policy</code> statement first. It might be needed to create multiple blocks if a single Boolean would trigger multiple policy calls that warrant the use of an <code class="literal">optional_policy</code> block.</li></ul></div><p>Efforts are being made to remove these shortcomings from the SELinux subsystem though.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Adding build-time policy decisions</h1></div></div></div><p>The last <a id="id330" class="indexterm"/>enhancement we might want to look at is build-time policy decisions. Unlike SELinux Booleans, these are policy blocks that are enabled (or disabled) based on build parameters. We have encountered a few of these in the past already, namely <code class="literal">enable_mcs</code>, <code class="literal">enable_mls</code> as well as distribution selection parameters, such as <code class="literal">distro_gentoo</code> or <code class="literal">distro_redhat</code>.</p><p>In this recipe, we will enable the <code class="literal">xdg_manage_downloads_home</code> call but only when the policy is built for a Gentoo system.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec108"/>How to do it…</h2></div></div></div><p>Build-time decisions are added to the policy using the <code class="literal">ifdef</code> statements, as can be seen through the next set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">myskype.te</code> and add in the following block of code:<div><pre class="programlisting">ifdef(`distro_gentoo',`
  xdg_manage_downloads_home(skype_t)
')</pre></div></li><li class="listitem">Rebuild the policy. On a Gentoo system, we can confirm that the access is now granted through <code class="literal">sesearch</code>, whereas other distributions probably don't even know the <code class="literal">xdg_downloads_home_t</code> type:<div><pre class="programlisting">
<strong>~$ sesearch -s skype_t -t xdg_downloads_home_t -A</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec109"/>How it works…</h2></div></div></div><p>The reference policy build system automatically defines a couple of parameters that can be used by the <code class="literal">ifdef</code> macros. The build system uses definitions inside the <code class="literal">build.conf</code> file available at <code class="literal">/usr/share/selinux/mcs/include/</code> or <code class="literal">/usr/share/selinux/devel/include/</code> to generate such parameters.</p><p>For instance, the distribution parameter in <code class="literal">build.conf</code> is set as follows:</p><div><pre class="programlisting">DISTRO ?= gentoo</pre></div><p>Inside <code class="literal">Makefile</code>, this is converted into an <code class="literal">M4PARAM</code> setting:</p><div><pre class="programlisting">ifneq ($(DISTRO),)
        M4PARAM += -D distro_$(DISTRO)
endif</pre></div><p>Through <a id="id331" class="indexterm"/>these <code class="literal">M4</code> parameters, we can then use the <code class="literal">ifdef</code> statements to query the existence of these parameters and make build-time decisions.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec110"/>There's more...</h2></div></div></div><p>It is possible to add our own set of parameters. For this, we set the <code class="literal">M4PARAM</code> environment variable before we call the <code class="literal">make</code> command (used while building the policy modules).</p><p>For instance, to support the <code class="literal">debug</code> statements, we could set the following in the policy:</p><div><pre class="programlisting">ifdef(`debug',` … ')</pre></div><p>During policy build, we can enable these statements as follows:</p><div><pre class="programlisting">
<strong>~$ export M4PARAM="-D debug"</strong>
<strong>~$ make mypolicy.pp</strong>
</pre></div></div></div></body></html>