<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Setting Up a Home Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Setting Up a Home Server</h1></div></div></div><p>Since you are now familiar with creating an entire root filesystem from scratch, it is a good time to create something a little more complex. Granted that a desktop can be quite useful by itself, but very often, a desktop OS on these kinds of ARM development boards might be a little too slow. However, these devices are very useful for low-power home servers.</p><p>The term home server is used here, as <a id="id188" class="indexterm"/>most services are useful to a person at home, but using a Cubieboard in a colocation center and getting it to function as a web server and mail server, for example, also works quite well. However, when doing that, security does come to mind. Security is not strongly addressed in this chapter, as it is a subject that requires a lot of attention and strong knowledge of security, both of which are out of the scope of this book. It has to be said that these instructions are not specific to a Cubieboard at all, and there are obviously many more services that could be thought of.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Accessing the Cubieboard remotely</li><li class="listitem" style="list-style-type: disc">Learning how to start, stop, and restart services</li><li class="listitem" style="list-style-type: disc">Adding and removing a service to be started at boot</li><li class="listitem" style="list-style-type: disc">Automatically running tasks at scheduled times</li><li class="listitem" style="list-style-type: disc">Set up various services (Squid, Apache, Samba, transmission, and ownCloud)</li></ul></div><div class="section" title="Prerequisites for the home server board"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Prerequisites for the home server board</h1></div></div></div><p>In this chapter, several <a id="id189" class="indexterm"/>software packages will be installed upon the previous Debian or Ubuntu installation. If this installation has seen too much wear and tear due to experimentation, it is recommended to go over <a class="link" href="ch04.html" title="Chapter 4. Manually Installing an Alternative Operating System">Chapter 4</a>, <span class="emphasis"><em>Manually Installing an Alternative Operating System</em></span>, again.</p><p>It is wise to skip the final segment, where a graphical desktop environment is installed, as it will serve no purpose in this<a id="id190" class="indexterm"/> chapter. The initial Fedora installation on the SD card can also be reused, but it is up to you to identify the differences between these distributions.</p></div></div>
<div class="section" title="Accessing the server remotely"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Accessing the server remotely</h1></div></div></div><p>Most of the time, if not<a id="id191" class="indexterm"/> all the time, the Cubieboard has been accessed via a serial console, or directly via the keyboard and mouse while it is connected to a monitor. This works fine, but after the setting up and tinkering is done, it might be interesting to get it to sit in a different room where it can perform its task unattended. It could even be possible to have several boards running in a dataserver, for example, where remote access might become crucial. Thus, having remote access is very useful.</p><p>The most common and well-established way to connect to a Debian or Ubuntu machine is via an <code class="literal">ssh</code> server. Installing an <code class="literal">ssh</code> server<a id="id192" class="indexterm"/> is simple; just use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install openssh-server</strong></span>
</pre></div><p>Just as with UART access, PuTTY can be used for <code class="literal">ssh</code> access. However, the important thing here is to set the connection type to <code class="literal">ssh</code>. The port should be set to <code class="literal">22</code> by default, and the correct IP or hostname needs to be used. See the following screenshot for an example of this:</p><div class="mediaobject"><img src="graphics/1572OS_05_01.jpg" alt="Accessing the server remotely"/></div><p>If you are using an <a id="id193" class="indexterm"/>existing Linux command line, <code class="literal">ssh</code> can be invoked quite easily, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1572OS_05_09.jpg" alt="Accessing the server remotely"/></div><p>The first time you connect to a host, the <code class="literal">ssh</code> fingerprint is displayed followed by a question as to <a id="id194" class="indexterm"/>whether you are sure you want to connect. In this case, it is safe to accept the proposal to continue.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>When connecting over the Internet, it is recommended that you always verify the key. If someone messed around with the server or tried to perform a man-in-the-middle attack, this key will no longer match, and you will know that something is wrong.</p></div></div><p>After entering the password, the familiar <code class="literal">packt@PacktPublishing:~$</code> command prompt will appear.</p></div>
<div class="section" title="Interacting with services"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Interacting with services</h1></div></div></div><p>On a server, it is <a id="id195" class="indexterm"/>quite common to start, stop, or restart a service. This is not only while trying to fix a problem, but also sometimes to reload a configuration, for example. It might be that a service is used to run only occasionally but not every time during booting. For these purposes, the so-called startup scripts are available. When a service is installed, usually, a script to control its behavior is placed at <code class="literal">/etc/init.d</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>For a server, it usually makes sense to configure networking either statically or via a DHCP server directly in the <code class="literal">interfaces</code> file. This to ensure networking is always available, as a graphical desktop is often not installed.</p></div></div><p>Let us take the networking script, for example. It is responsible for bringing up a network device, but only those configured at <code class="literal">/etc/networking/interfaces</code>. Refer to <a class="link" href="ch04.html" title="Chapter 4. Manually Installing an Alternative Operating System">Chapter 4</a>, <span class="emphasis"><em>Manually Installing an Alternative Operating System</em></span>, on how to properly set up a network<a id="id196" class="indexterm"/> configuration; it is assumed that <code class="literal">eth0</code> is configured in this way.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Stopping the networking service will deactivate all the networking interfaces! While this does not have to be a problem, be careful when using this command if you're using the connection remotely.</p></div></div></div>
<div class="section" title="Starting, stopping, restarting, or reloading a service"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Starting, stopping, restarting, or reloading a service</h1></div></div></div><p>To<a id="id197" class="indexterm"/> stop the <a id="id198" class="indexterm"/>network interface, issue the <a id="id199" class="indexterm"/>following command. If you are logged in as root, which is not recommended, omit the <code class="literal">sudo</code> command.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo /etc/init.d/networking stop</strong></span>
<span class="strong"><strong>Deconfiguring network interfaces...done.</strong></span>
</pre></div><p>Similarly, the network interface<a id="id200" class="indexterm"/> can be started again using the <code class="literal">start</code> parameter, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo /etc/init.d/networking start</strong></span>
<span class="strong"><strong>Configuring network interfaces...</strong></span>
</pre></div><p>The same can be done using the <code class="literal">restart</code> or <code class="literal">reload</code> parameter, where <code class="literal">reload</code> forces the service to reload its configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>Some distributions, such as Ubuntu, might use upstart or even SystemD. Sometimes, scripts are left behind in the <code class="literal">/etc/init.d</code> directory that can be used as described previously, but this is not always the case, and thus it might be required to get familiar with SystemD or upstart.</p></div></div></div>
<div class="section" title="Adding or removing a service from the boot up"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Adding or removing a service from the boot up</h1></div></div></div><p>Sometimes, it <a id="id201" class="indexterm"/>is required to always make a service start during boot time. For example, in the previous chapter, <code class="literal">lightdm</code>
<a id="id202" class="indexterm"/> was installed to<a id="id203" class="indexterm"/> provide a graphical login service. This service was automatically added to be started during booting. Preventing <code class="literal">lightdm</code> from starting during booting any longer can be accomplished using the <code class="literal">update-rc.d</code> command. Passing the optional <code class="literal">-f</code> flag forces removal, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo update-rc.d -f lightdm remove</strong></span>
<span class="strong"><strong>update-rc.d: using dependency based boot sequencing</strong></span>
</pre></div><p>The graphical login manager will now no longer be started after a reboot using the preceding section to stop <code class="literal">lightdm</code> immediately; a reboot is then not even needed.</p><p>Adding a service is <a id="id204" class="indexterm"/>quite similar; instead of asking it to be removed from the boot time services, the default keyword asks that the service be started during booting, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo update-rc.d lightdm defaults</strong></span>
<span class="strong"><strong>update-rc.d: using dependency based boot sequencing</strong></span>
</pre></div><p>Defaults indicate<a id="id205" class="indexterm"/> that all the default runlevel services should be started or stopped. A Linux system has various runlevels, and you are encouraged to read more about it.</p><p>After each reboot, <code class="literal">lightdm</code> will be started. The preceding section was all specific to Debian. Ubuntu, however, has backwards-compatible scripts for most services in <code class="literal">/etc/init.d</code> and can be used as described previously.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>As mentioned in the earlier chapter, both Debian's SystemV and Ubuntu's upstart will, in time, be replaced by SystemD or both. It is up to you to learn more about SystemD when the time comes.</p></div></div></div>
<div class="section" title="Running scheduled tasks automatically"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Running scheduled tasks automatically</h1></div></div></div><p>It is often necessary <a id="id206" class="indexterm"/>to have certain tasks run at scheduled intervals. Think of downloading and updating a virus database, for example. For this purpose, Linux systems are equipped with a program called <span class="strong"><strong>Cron</strong></span>. Cron <a id="id207" class="indexterm"/>normally runs in the background and checks whether it was given any jobs to run at a certain time. While it is up to you to get to know Cron in detail, by default on Debian, Cron makes running Cron-jobs very easy by supplying four directories in <code class="literal">/etc</code>, namely, <code class="literal">cron.hourly</code>, <code class="literal">cron.daily</code>, <code class="literal">cron.weekly</code>, and <code class="literal">cron.monthly</code>. From the names, it should be obvious what their intentions are. Placing an executable file here makes Cron run the command hourly, daily, weekly, or monthly.</p><p>A simple example is to ask <code class="literal">apt-get</code> to update its local database every day; a simple script can be created for this purpose. Using the editor as root, create a new file called <code class="literal">apt-update</code> in <code class="literal">/etc/cron.daily/</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo nano /etc/cron.daily/apt-get</strong></span>
<span class="strong"><strong>#!/bin/sh</strong></span>
<span class="strong"><strong>apt-get update</strong></span>
</pre></div><p>The first line is important, as it tells the system that this is a shell script, or rather, that <code class="literal">/bin/sh</code> needs to be used to execute the lines in the rest of the file. Cron runs all its jobs in <code class="literal">/etc/cron.*</code> by root by default, so there is no need to prepend it with <code class="literal">sudo</code>.</p><p>With the file saved, it is important to give it the permission to execute. By default, it is just a text file. Cron will <a id="id208" class="indexterm"/>only execute files with the proper permissions. This is easily fixed using <code class="literal">chmod</code> to mark this newly created script executable, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo chmod u+x /etc/cron.daily/apt-update</strong></span>
</pre></div><p>It needs to be said, however, that while <a id="id209" class="indexterm"/>this was a very useful example, Debian and Ubuntu by default update the apt repository on a daily basis. So, while this serves well as an example, it is recommended that you clean it up afterwards, as shown in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo rm /etc/cron.daily/apt-update</strong></span>
</pre></div></div>
<div class="section" title="Setting up a proxy server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Setting up a proxy server</h1></div></div></div><p>When <a id="id210" class="indexterm"/>bandwidth is <a id="id211" class="indexterm"/>scarce and has to be shared with multiple members of a household, and on top of that, a reduction of ads is desired, a proxy server can offer a solution. Additionally, it allows Internet access without complicated firewall rules; just configure the browser to use the proxy. In the following subsections, the steps to set up a proxy server are explained.</p><div class="section" title="Installing Squid"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec24"/>Installing Squid</h2></div></div></div><p>The <a id="id212" class="indexterm"/>proxy server <a id="id213" class="indexterm"/>used in this book is called Squid, and as you learned from the previous chapter, it can be installed easily with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install squid</strong></span>
</pre></div><p>Squid in <a id="id214" class="indexterm"/>Debian comes with a reasonable default configuration file at <code class="literal">/etc/squid/squid.conf</code>. Using nano or any other editor, the file can be opened and examined. The squid configuration file is very heavy on comments, working as a guide or manual.</p><p>By default, Squid will only listen to the traffic on connections that it thinks are from the internal network. The lines starting with <code class="literal">acl localnet</code> followed by the internal network, IP-range, indicates this. It should be noted that an additional <code class="literal">localnet</code> line can be added, but be careful—adding an IP-range internal network that is not local can mean that the proxy is accessible worldwide, so do be careful when experimenting here. This, however, only defines the <code class="literal">localnet</code>; it has not been granted access yet. Searching through <code class="literal">squid.conf</code>, a commented section reading the following command will be found:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#http_access allow localnet</strong></span>
</pre></div><p>This line allows HTTP access where the source originates from <code class="literal">localnet</code>, which we just learned about, <a id="id215" class="indexterm"/>and which was defined as the internal network range. You can uncomment it by removing the hashtag, or the number sign; this grants <a id="id216" class="indexterm"/>access to the so-called <code class="literal">localnet</code> line, and after restarting Squid, the proxy should now allow usage from the internal network.</p></div><div class="section" title="Setting up a caching proxy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec25"/>Setting up a caching proxy</h2></div></div></div><p>A proxy server<a id="id217" class="indexterm"/> can temporarily store frequently accessed data so that it only needs to be downloaded over an Internet connection once. This can, in certain cases, greatly reduce bandwidth usage; for example, imagine that a household of five computers with all of them requiring to download a certain update file. If all the five computers download this update via the proxy, the proxy only downloads this the first time the file is requested. The moment a second computer requests that same file, the proxy would offer its internally stored file making the download much faster and not burden the Internet connection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>By default, Squid uses a cache of 100 MB only. Take a look at the <code class="literal">cache_dir</code> parameter to learn more about this.</p></div></div><p>Squid does not require any additional configuration to function as a caching proxy. After it has been installed, it is automatically started and configured to be started upon a reboot. To change any of these behaviors, refer to the earlier two subsections.</p><div class="section" title="Configuring a browser to use the proxy"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Configuring a browser to use the proxy</h3></div></div></div><p>Without covering every <a id="id218" class="indexterm"/>browser or every operating system out there, at least one example will be shown here. In this case, we choose Mozilla Firefox. To configure the browser to use the proxy, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, open the <span class="strong"><strong>Preferences</strong></span> option, which, depending on the operating system used, is under <span class="strong"><strong>Edit</strong></span> or under <span class="strong"><strong>Tools</strong></span>.</li><li class="listitem">In the preference screen, navigate to the <span class="strong"><strong>Advanced</strong></span> tab, and from there, to the <span class="strong"><strong>Network</strong></span> tab. The first button on the right reads <span class="strong"><strong>Settings</strong></span>, and it holds the network configuration, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1572OS_05_02.jpg" alt="Configuring a browser to use the proxy"/></div></li><li class="listitem">In the <span class="strong"><strong>Settings</strong></span> dialog, select <span class="strong"><strong>Manual proxy configuration</strong></span>, which will enable the edit boxes.</li><li class="listitem">For the<a id="id219" class="indexterm"/> <span class="strong"><strong>HTTP Proxy</strong></span>, the hostname or the IP address needs to be entered. The default port for Squid is <span class="strong"><strong>3128</strong></span>.</li><li class="listitem">Finally, the <span class="strong"><strong>Use this proxy server for all protocols</strong></span> option can be safely enabled, as Squid covers them all, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1572OS_05_03.jpg" alt="Configuring a browser to use the proxy"/></div></li><li class="listitem">If the IP <a id="id220" class="indexterm"/>address is unknown, it can be obtained using the <code class="literal">ifconfig</code> command on the Cubieboard where Squid is running. In this case, the IP address is <code class="literal">192.168.0.10</code>, as shown here:<div class="mediaobject"><img src="graphics/1572OS_05_04.jpg" alt="Configuring a browser to use the proxy"/></div></li></ol></div><p>It is not strictly required to use <code class="literal">sudo</code> to access the <code class="literal">ifconfig</code> information. Most of the time, it can be accessed via its full path, <code class="literal">/sbin/ifconfig</code> in this case, without requiring elevated privileges. Additionally, <code class="literal">ifconfig</code> might be replaced by the <code class="literal">ip addr</code> command on certain distributions.</p><p>Starting a web-surfing session <a id="id221" class="indexterm"/>should now go via the proxy. Manual configuration of a proxy is not strictly required. As seen here, there is the <span class="strong"><strong>Use system proxy settings</strong></span> or <span class="strong"><strong>Auto-detect proxy settings for this network</strong></span> option. When using the first option, whatever is configured by and for the operating system is used as the default proxy by the browser. The latter option is used if the proxy settings can be detected via the so-called <a id="id222" class="indexterm"/>WPAD, which is up to the reader to learn more about and can be<a id="id223" class="indexterm"/> found at <a class="ulink" href="http://en.wikipedia.org/wiki/Web_Proxy_Autodiscovery_Protocol">http://en.wikipedia.org/wiki/Web_Proxy_Autodiscovery_Protocol</a>. Both of these options, however, are not covered here.</p></div></div><div class="section" title="Setting up a blocking proxy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec26"/>Setting up a blocking proxy</h2></div></div></div><p>One of the <a id="id224" class="indexterm"/>advantages of using a proxy is that certain sites can be easily blocked. Let us say the sites <code class="literal">hotmail.com</code>, <code class="literal">ebay.com</code>, and <code class="literal">live.com</code> need to be blocked. This list of domain names will have to be stored somewhere, for example, <code class="literal">blocked.domains.acl</code> in the <code class="literal">/etc/squid</code> directory. To do this, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start editing the file and add those names, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo nano /etc/squid/blocked.domains.acl</strong></span>
<span class="strong"><strong>hotmail.com</strong></span>
<span class="strong"><strong>ebay.com</strong></span>
<span class="strong"><strong>live.com</strong></span>
</pre></div></li><li class="listitem">Next, go to a very specific section in the configuration file, as the order does matter. Find the section called <code class="literal"># TAG: acl</code>, and scroll beyond the big commented section where the <code class="literal">acl</code> tag gets documented. The <code class="literal">acl localnet</code> definitions will show up as seen in the earlier <span class="emphasis"><em>Installing Squid</em></span> section. Just before the next section starts, find <code class="literal"># TAG: http_access</code> and add the following line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>acl blockeddomain dstdomain "/etc/squid/blocked.domains.acl"</strong></span>
</pre></div><p>In short, under the section called <code class="literal">acl</code>, a new item will be added, just before the <code class="literal">http_access</code> section. Here, Squid is instructed to create an <code class="literal">acl</code> called <span class="emphasis"><em>blocked domain</em></span> and mark the domains as destination domains from the file just created. So now there should be a list of <code class="literal">acls</code> with the blocked domain one being last.</p></li><li class="listitem">Immediately following<a id="id225" class="indexterm"/> the <code class="literal">acl</code> section, the <code class="literal">http_access</code> section starts. Here, the order is crucial. Just above the sections where the localhost and <code class="literal">localnet</code> were allowed, the following command needs to be added:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>http_access deny blockeddomain</strong></span>
</pre></div><p>The reason is that, first, things get denied, such as the blocked domains, and then localhost and <code class="literal">localnet</code> are granted access to what is left. Finally, everything else gets blocked for those that have not been allowed anything.</p></li><li class="listitem">Using the <code class="literal">restart</code> command you learned earlier in this chapter, Squid can be restarted and will now refuse to load all the content from the mentioned sites.</li></ol></div><p>Taking this example a step further, it would be nice to block all domains that do nothing but serve ads. While creating a file to list all these domains is of course a valid solution, it becomes quite tedious to list all domains and all of its permutations. Squid can instead do regular expressions on a list, making things a lot easier. To do this, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As before, create a file named <code class="literal">squid.adservers</code>, and enter the following regular expression. It's okay if you don't understand what any of it means; it's only an example for now.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>(^|\.)wikia-ads\.wikia\.com$</strong></span>
</pre></div></li><li class="listitem">After saving the file, open <code class="literal">squid.conf</code>, and just like before, add the following lines to the appropriate sections:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>acl ads dstdom_regex -i "/etc/squid/squid.adservers"</strong></span>
<span class="strong"><strong>http_access deny ads</strong></span>
</pre></div></li><li class="listitem">Squid is instructed to create a list following the file, but this time using a regular expression for the destination domain list. Again, Squid will then deny all HTTP access to the domains in the list ads, which in this case is <code class="literal">wikia-ads.wikia.com</code>.</li></ol></div><p>Manually, adding<a id="id226" class="indexterm"/> regular expressions for each and every ad-network can be tiresome, especially when trying to maintain them. Luckily, a group of people maintains a list of known ad-servers<a id="id227" class="indexterm"/> that can be used without too much work; the list can be found at <a class="ulink" href="http://pgl.yoyo.org/adservers/">http://pgl.yoyo.org/adservers/</a>. Someone was even kind enough to provide a script that can be used to download the list and prepare it to be used with Squid. Download the following file using <code class="literal">wget</code>, as seen in the following example:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ wget http://pgl.yoyo.org/adservers/scripts/squid/update-squid-adservers.txt</strong></span>
</pre></div><p>Before being able to use this script, it does require minor modification. To do this, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the file, find <code class="literal">listurl</code>, and replace it as shown here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>listurl='http://pgl.yoyo.org/adservers/serverlist.php?hostformat=squid-dstdom-regex&amp;mimetype=plaintext'</strong></span>
</pre></div></li><li class="listitem">Also, double-check the target file parameter, for it will have to match what was used on the ad's <code class="literal">acl</code> rule that was defined as shown here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>targetfile='/etc/squid/squid.adservers'</strong></span>
</pre></div></li><li class="listitem">After saving the file, it can be run as root, and it will download an up-to-date list of ad-servers and reload this data into Squid. Make use of <code class="literal">sh</code> here, as <code class="literal">sh</code> is run as root and it is told to run the script as if it were a shell script:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo sh update-squid-adservers.txt</strong></span>
<span class="strong"><strong>Reloading Squid configuration files.</strong></span>
<span class="strong"><strong>done.</strong></span>
<span class="strong"><strong>packt@PacktPublishing:~$</strong></span>
</pre></div></li><li class="listitem">To double-check whether all this worked accordingly, open the target file, probably <code class="literal">/etc/squid.adservers</code> by default, unless adjusted as suggested earlier.</li><li class="listitem">One final step is to have this script update on a monthly basis. Using the earlier section on how<a id="id228" class="indexterm"/> to set up a Cron-job should make this task easy.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Using the <code class="literal">cp</code> command, the file can be copied to the appropriate directory. It is probably a wise idea to drop the <code class="literal">.txt</code> extension when copying.</p></div></div></li></ol></div></div></div>
<div class="section" title="Setting up a web server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Setting up a web server</h1></div></div></div><p>A <a id="id229" class="indexterm"/>personal web server is something that a lot of people<a id="id230" class="indexterm"/> involved in Linux have. Setting up one properly is, however, a topic worth of an entire book. In this section, only the most basic of steps will be covered for you to get started. By no means is it complete or secure, as we will rely on the default settings that Debian or Ubuntu ship with in their packages.</p><p>There are several well-known web servers, but without a doubt, the most well-known is the following Apache web server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install apache2</strong></span>
</pre></div><p>As before, Debian will automatically start Apache, and it can be used right away. Using a web browser by typing the IP or hostname, such as <code class="literal">http://192.168.0.10</code> which was used earlier, into the URL bar will open the following window:</p><div class="mediaobject"><img src="graphics/1572OS_05_10.jpg" alt="Setting up a web server"/></div><p>The file being served is from <code class="literal">/var/www/index.html</code>. Feel free to edit this document or even <a id="id231" class="indexterm"/>entirely<a id="id232" class="indexterm"/> replace it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>It might be useful to give the web developer access rights to this directory and its files. Quite often, there is a group associated with the <code class="literal">webroot</code> directory. Admins often even create several groups for the various webroots they might have. For simplicity's sake, the user and group is set to our example user, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo chown -R packt:packt /var/www</strong></span>
</pre></div></div></div></div>
<div class="section" title="Setting up a file server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Setting up a file server</h1></div></div></div><p>Editing<a id="id233" class="indexterm"/> the <a id="id234" class="indexterm"/>files directly on the Cubieboard can be tiresome for sure. Even when using the previously installed Xfce desktop, once it is placed at a remote location, accessing the files remotely will be quite useful. It might be the case that the media files are desired to be shared throughout the household.</p><p>There are two approaches to this situation. With the <code class="literal">ssh</code> server installed earlier in this chapter, any modern Linux desktop environment has the ability to access files via <code class="literal">ssh</code>. While this works well, it is left to the reader as an exercise. What this section will focus on is installing and setting up Samba as a file server. To do this, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The files shared via Samba are accessible via many operating systems and in many devices it can be easily installed, as shown here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install samba</strong></span>
</pre></div></li><li class="listitem">After Samba has been installed, it is probably a good idea to create a directory that will be shared using the <code class="literal">mkdir</code> command. It can be called <code class="literal">mediafiles</code> and lives in the root of the filesystem, as shown here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ mkdir /mediafiles</strong></span>
</pre></div></li><li class="listitem">Using an editor, open the Samba configuration file at <code class="literal">/etc/samba/smb.conf</code>, as shown in the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo nano /etc/samba/smb.conf</strong></span>
</pre></div></li><li class="listitem">One variable that probably should be changed is the so-called workgroup; this is the name of the network that Samba will try to join:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Change this to the workgroup/NT-domain name your Samba server </strong></span>
<span class="strong"><strong># will part of</strong></span>
<span class="strong"><strong>   workgroup = PacktNet</strong></span>
</pre></div></li><li class="listitem">The other thing that needs to be added at the bottom of the file is a section where the previously created directory is being shared, as shown here:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[mediafiles]</strong></span>
<span class="strong"><strong>   comment = Shared media files</strong></span>
<span class="strong"><strong>   read only = no</strong></span>
<span class="strong"><strong>   path = /mediafiles</strong></span>
<span class="strong"><strong>   guest ok = yes</strong></span>
</pre></div></li></ol></div><p>Security-wise, this<a id="id235" class="indexterm"/> is not the best protection, as everybody is allowed to read and write to the media files and no valid account is required to access these files. There is one final barrier, however, and that is the permissions left on the directory. Samba will run on the media files as the user tries to access this directory.</p><p>Since this share <a id="id236" class="indexterm"/>is being used as a guest user, or no user, the permissions will be applied when reading the directory media files.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Using <code class="literal">chmod</code> to change the permission to allow everybody to read and write makes it possible that this share can be used by everybody, as shown in the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo chmod o+rw /mediafiles/</strong></span>
</pre></div><p>Within a home network, this is not a problem. Protecting things better, however, is a good exercise left to the reader. Samba<a id="id237" class="indexterm"/> is a great suite offering a whole lot more than just file sharing. Learn <a id="id238" class="indexterm"/>more at <a class="ulink" href="http://www.samba.org/">http://www.samba.org/</a>.</p></li><li class="listitem">After saving these changes, Samba needs to be restarted.</li><li class="listitem">Using a file browser on a desktop, there should be a network workgroup called <a id="id239" class="indexterm"/>PacktNet, as <a id="id240" class="indexterm"/>was defined for the workgroup, and in that network, amongst other possible hosts, there should be <code class="literal">PacktPublishing</code>, the name of the host, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1572OS_05_05.jpg" alt="Setting up a file server"/></div></li><li class="listitem">Finally, within <code class="literal">PacktPublishing</code>, the freshly <a id="id241" class="indexterm"/>shared <a id="id242" class="indexterm"/>directory <code class="literal">mediafiles</code> will become visible.<div class="mediaobject"><img src="graphics/1572OS_05_06.jpg" alt="Setting up a file server"/></div></li></ol></div></div>
<div class="section" title="Setting up a torrent server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Setting up a torrent server</h1></div></div></div><p>Torrents <a id="id243" class="indexterm"/>are a common way of sharing data. Many <a id="id244" class="indexterm"/>Linux distribution ISO files are shared via torrents. Having a dedicated server dealing with torrents without having the main PC turned on is also very useful. It has to be noted, however, that some storage for that torrent data is required. Having all data on a SD card is probably not wise. Have a look at the following command to install transmission, a torrent server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install transmission-daemon</strong></span>
</pre></div><p>After the transmission is installed, it will need to be configured if the remote administration is desired. By default, the remove administration feature will only listen on the localhost. Using <code class="literal">sudo</code>, the configuration file should be opened, and two <a id="id245" class="indexterm"/>items, <code class="literal">rpc-password</code> and <code class="literal">rpc-whitelist</code>, need to be changed. The <code class="literal">rpc-whitelist</code> item<a id="id246" class="indexterm"/> determines which hosts can access the server, and the <code class="literal">rpc-password</code> item determines which password was used by any clients connecting to the server, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo nano /var/lib/transmission-daemon/info/settings.json</strong></span>
<span class="strong"><strong>    "rpc-password": "mysecretpassword",</strong></span>
<span class="strong"><strong>    "rpc-whitelist": "127.0.0.1,192.168.*.*",</strong></span>
</pre></div><p>The default <a id="id247" class="indexterm"/>password set is an encrypted hash, but when <a id="id248" class="indexterm"/>modifying it, a regular plain-text password can be used. This seems like a security problem, and it is, but only very briefly. Upon being told to reload its configuration file, the transmission will read the password, encrypt it, and rewrite the configuration file.</p><p>Transmission needs to be reloaded because if the transmission is restarted, it will not re-read the configuration file but will rewrite configuration file on exit. The rest of the defaults should be satisfactory though it might be wise to double-check that <code class="literal">rpc-authentication-required</code> is set to <code class="literal">true</code> and that <code class="literal">rpc-enabled</code> is also <code class="literal">true</code>. Additionally, the <code class="literal">rpc-username</code> variable can be changed to something memorable, but do remember to use the new username in the remainder of this chapter, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo /etc/init.d/transmission-daemon reload</strong></span>
<span class="strong"><strong>Reloading bittorrent daemon: transmission-daemon.</strong></span>
</pre></div><p>Once the transmission is reloaded, a web browser can be used to browse to the IP address or the hostname on port <code class="literal">9091</code> and can be further configured from there, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1572OS_05_07.jpg" alt="Setting up a torrent server"/></div><p>The web interface<a id="id249" class="indexterm"/> is really nice and very usable, and there are various transmission clients that can<a id="id250" class="indexterm"/> remotely connect. They work as if the client ran locally but talk to the transmission-daemon running on the network. One such program is called<a id="id251" class="indexterm"/> <code class="literal">transmission-remote-gtk</code>. For Android, for example, there exists an application called <a id="id252" class="indexterm"/>
<span class="strong"><strong>Transdroid</strong></span>.</p></div>
<div class="section" title="Setting up a personal cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Setting up a personal cloud</h1></div></div></div><p>The<a id="id253" class="indexterm"/> cloud <a id="id254" class="indexterm"/>is where everything is these days. However, a lot of people are not happy with storing everything in the cloud on a random server. Luckily, there is something called ownCloud. This is a<a id="id255" class="indexterm"/> web service that lets you have your own personal cloud.</p><p>For this book, ownCloud will be installed using the SQLite database. For very light, single user workloads, SQLite will be fine.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>A more serious, multiuser installation would strongly benefit from using PostgreSQL or even MySQL; however, those systems are far more complex to set up and work with. After getting more comfortable with Linux in general, this can be an exciting exercise to the reader.</p></div></div><p>Installing <span class="strong"><strong>Mail Transport Agent</strong></span> (<span class="strong"><strong>MTA</strong></span>)<a id="id256" class="indexterm"/> is suggested by ownCloud; However, installing MTA is also beyond the scope here. To bypass the installation of any MTA, a fake package called <code class="literal">lsb-invalid-mta</code> exists, which can be installed as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install lsb-invalid-mta</strong></span>
</pre></div><p>Unfortunately, as <a id="id257" class="indexterm"/>of the time of writing this book, the<a id="id258" class="indexterm"/> ownCloud package is not yet available for Debian Wheezy, but it is for later versions. Also, Ubuntu has had it available in its repositories for a while now. In some cases, such as the ownCloud package, it is available in a different repository—the backports repository. This was covered already in the previous chapter, where the apt repository was mentioned. Adding the backports repository can be done by adding the following line. Again, use an appropriate mirror if you can. In the following example, the <code class="literal">nl</code> mirror is used:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>deb http://ftp.nl.debian.org/debian wheezy-backports main</strong></span>
</pre></div><p>Remember to update the apt database after adding the backports repository. There are a few dependencies of the SQLite variant of ownCloud that were put in a metapackage called <code class="literal">owncloud-sqlite</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install owncloud-sqlite</strong></span>
</pre></div><p>With the ownCloud SQLite dependencies installed, it is time to install ownCloud itself. Unfortunately, the ownCloud package, by default, wants to install a few suggested packages for a database. In the case of Debian Wheezy, it will always want to try to install the MySQL database even though a different database will be used.</p><p>To remedy this, we introduce a new options to <code class="literal">apt-get</code>, <code class="literal">–no-install-suggests</code>, and <code class="literal">–no-install-recommends</code>, which, as the names suggest, do not install any suggested or recommended packages. But even that will not prevent the full installation of MySQL. By adding <code class="literal">mysql-server-</code> (notice the dash at the end of the list of packages to be installed), apt will not install MySQL Server, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>packt@PacktPublishing:~$ sudo apt-get install –no-install-suggests – no-install-recommends owncloud mysql-server-</strong></span>
</pre></div><p>At the time of writing this book, the ownCloud package in the <code class="literal">wheezy-backports</code> repository is broken. At least a certain version of <code class="literal">php-getid3</code>, which is not available in the standard repositories, is required by ownCloud, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>owncloud : Depends: php-getid3 (&gt;= 1.9.5~) but 1.9.3-1+deb7u1 is to be installed</strong></span>
</pre></div><p>This package, however, is <a id="id259" class="indexterm"/>also available in the <code class="literal">wheezy-backports</code> repository, but apt needs to be instructed to install it specifically from there. The <code class="literal">-t</code> parameter tells apt to install a package from a specific repository, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@PacktPublishing:~$ sudo apt-get -t wheezy-backports install php-getid3</strong></span>
</pre></div><p>It might be <a id="id260" class="indexterm"/>required to install this or other packages from the <code class="literal">backports</code> repository as a dependency of ownCloud. Using a web browser, navigate to the IP or hostname of the server, and the ownCloud setup wizard will display the following screenshot:</p><div class="mediaobject"><img src="graphics/1572OS_05_08.jpg" alt="Setting up a personal cloud"/></div><p>By logging <a id="id261" class="indexterm"/>in for the <a id="id262" class="indexterm"/>first time, an administrative account will be created. Initial setup might take a little while, after which ownCloud is ready for use.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Summary</h1></div></div></div><p>While this chapter had nothing specific for the Cubieboard, it did teach some basic administration tasks and used them to set up some basic but useful services for a home server. While there are many more interesting services to think of, such as a DHCP server (<code class="literal">ics</code>), a printer server (<code class="literal">cups</code>), or a DNS server (<code class="literal">bind</code>), on top of that, one can build a device and incorporate it with the web server and control a light switch via a web page.</p><p>The next chapter will work on upgrading the bootloader and the kernel, two reasonably easy tasks.</p></div></body></html>