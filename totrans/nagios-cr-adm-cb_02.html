<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Working with Commands and Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Commands and Plugins</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finding a plugin</li><li class="listitem" style="list-style-type: disc">Installing a plugin</li><li class="listitem" style="list-style-type: disc">Removing a plugin</li><li class="listitem" style="list-style-type: disc">Customizing an existing command</li><li class="listitem" style="list-style-type: disc">Using an alternative check command for a host</li><li class="listitem" style="list-style-type: disc">Writing a new plugin from scratch</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Introduction</h1></div></div></div><p>Nagios Core is perhaps best thought of less as a monitoring tool, and more as a monitoring framework. Its modular design can use any kind of program which returns appropriate values based on some kind of check, such as a <code class="literal">check_command</code> plugin for a host or service. This is where the concepts of commands and plugins come into play.</p><p>For Nagios Core, a <a id="id79" class="indexterm"/>
<a id="id80" class="indexterm"/>
<span class="strong"><strong>plugin</strong></span> is any program that can be used to gather information about a host or service. To ensure that a host was responding to PING requests, we'd use a plugin, such as <code class="literal">check_ping</code>, which when run against a hostname or address—whether by Nagios Core or not—would return a status code to whatever called it, based on whether a response was received to the PING request within a certain period of time. This status code and any accompanying message is what Nagios Core uses to establish what state a host or service is in.</p><p>Plugins are generally just like any other program on a Unix-like system; they can be run from the command line, are subject to permissions and owner restrictions, can be written in any programming language, and can take parameters and options to modify how they work. Most importantly, they are entirely separate from Nagios Core itself (even if programmed by the same people), and the way that they're used by the application can be changed.</p><p>To allow for additional flexibility in how plugins are used, Nagios Core uses these programs according to the terms of a command definition. A command for a specific plugin defines the way in which that plugin is used, including its location in the filesystem, any parameters it should be passed, and any other options. In particular, parameters and options often include thresholds for <code class="literal">WARNING</code> and <code class="literal">CRITICAL</code> states.</p><p>Nagios Core is usually downloaded and installed along a set of <a id="id81" class="indexterm"/>plugins called <a id="id82" class="indexterm"/>
<span class="strong"><strong>Nagios Plugins</strong></span>, available at <a class="ulink" href="http://www.nagiosplugins.org/">http://www.nagiosplugins.org/</a>, which this book assumes you have installed. These plugins were chosen because, as a set, they cover the most common needs for a monitoring infrastructure quite well, including checks for common services, such as web, mail services, and DNS services, as well as more generic checks, such as whether a TCP or UDP port is accessible and open on a server. It's likely that for most of our monitoring needs, we won't need any other plugins; but if we do, Nagios Core makes it possible to use existing plugins in novel ways using custom command definitions, adding third-party plugins written by contributors on the Nagios Exchange website, or even writing custom plugins ourselves from scratch in some special cases.</p></div></div>
<div class="section" title="Finding a plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Finding a plugin</h1></div></div></div><p>In this recipe, we'll follow a good procedure for finding a plugin appropriate to a specific monitoring task. We'll start by checking to see if an existing plugin is already available to do just what we need. If we can't find one, <a id="id83" class="indexterm"/>we'll check to see if we can use another more generic plugin to solve the problem. If we still find that nothing suits, we'll visit Nagios Exchange and search for an appropriate plugin there.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec52"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already, and you'll need to have a particular service on one of those hosts, which you're not sure how to monitor.</p><p>We'll use a simple problem as an example; we have a server named <code class="literal">troy.naginet</code> that runs an <code class="literal">rsync</code> process that listens on port <code class="literal">873</code>. We're already monitoring the host's network connectivity via <code class="literal">PING</code>, but we'd like to have Nagios Core check whether the <code class="literal">rsync</code> server is available and listening at all times, in case it crashes while running or doesn't start up when the system is rebooted.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec53"/>How to do it...</h2></div></div></div><p>We can find a new plugin appropriate to any monitoring task as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Firstly, since we have the Nagios Core <a id="id84" class="indexterm"/>Plugins set installed, we'll check to see if any of the plugins available in it apply directly to our problem. We'll start by visiting <code class="literal">/usr/local/nagios/libexec</code> on our Nagios Core server, and getting a directory listing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
<span class="strong"><strong># ls</strong></span>
<span class="strong"><strong>check_apt       check_ide_smart     check_nntp      check_simap</strong></span>
<span class="strong"><strong>check_breeze    check_ifoperstatus  check_nntps     check_smtp</strong></span>
<span class="strong"><strong>check_by_ssh    check_ifstatus      check_nt        check_spop</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>There's a long list of plugins there, but none of them look like <code class="literal">check_rsync</code> or <code class="literal">check_backup</code>, so it doesn't quite seem like there's a plugin in the core to do exactly what we need.</p></li><li class="listitem">However, there is a plugin called <code class="literal">check_tcp</code>. A web search for its name pulls up its manual page on the Nagios Plugins website as the first result, and a description of what it does:<p><span class="emphasis"><em>"This plugin tests TCP connections with the specified host (or unix socket)."</em></span></p><p>We need to do more than just check the port, so this doesn't quite suit us either.</p></li><li class="listitem">A web search for <code class="literal">check_rsync</code>, which would be an appropriate name for the plugin, turns up a page on the Nagios Exchange website with a plugin named exactly that. We've found an appropriate plugin now:<div class="mediaobject"><img src="graphics/5566_02_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec54"/>How it works...</h2></div></div></div><p>If all we needed to do was check that <code class="literal">rsync</code> was listening on port <code class="literal">873</code>, and we didn't really need to monitor any of its actual function, then the <code class="literal">check_tcp</code> plugin might actually suffice. However, in our case, we might need to find a way to not only check that a port is open, but also check that a specific <a id="id85" class="indexterm"/>directory or <code class="literal">rsync</code> module<a id="id86" class="indexterm"/> is accessible.</p><p>Reading the description for <code class="literal">check_rsync</code>, it looks like it has the exact functionality we need, checking that a certain <code class="literal">rsync</code> module is available on the server. At this point, we could download the plugin and follow its installation instructions.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec55"/>There's more...</h2></div></div></div><p>This recipe is intended to highlight that in addition to having a capable set of plugins as a part of the Nagios Core Plugins set, the documentation available online on the Nagios Core Plugins website at <a class="ulink" href="http://nagiosplugins.org/">http://nagiosplugins.org/</a> and the other plugins available on Nagios Exchange<a id="id87" class="indexterm"/> at <a class="ulink" href="http://exchange.nagios.org/">http://exchange.nagios.org/</a> make it relatively straightforward to find an appropriate plugin for the particular monitoring problem we need to solve.</p><p>Note that when we download third-party plugins, it's important to check that we trust the plugin to do what we need it to. <a id="id88" class="indexterm"/>
<span class="strong"><strong>Nagios Exchange</strong></span> is a moderated community with a coding standard, but the plugins are provided at our own risk; if we don't understand what a plugin does, we should be wary of installing it or using it without reading its code, its documentation, and its reviews.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec56"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing a plugin</em></span>, <span class="emphasis"><em>Removing a plugin</em></span>, and <span class="emphasis"><em>Writing a new plugin from scratch</em></span> recipes in this chapter</li></ul></div></div></div>
<div class="section" title="Installing a plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Installing a plugin</h1></div></div></div><p>In this recipe, we'll install a custom plugin that we retrieved from Nagios Exchange onto a Nagios Core server, so that we can use it as a Nagios <a id="id89" class="indexterm"/>Core command and hence check a service with it.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec57"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already, and have found an appropriate plugin to install, to solve some particular monitoring need. Your Nagios Core server should have internet connectivity to allow you to download the plugin directly from the website.</p><p>In this example we'll use <code class="literal">check_rsync</code>, which is available on the Web at <a class="ulink" href="http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details">http://exchange.nagios.org/directory/Plugins/Network-Protocols/Rsync/check_rsync/details</a>.</p><p>This particular plugin is quite simple, consisting of a single Perl script with very basic dependencies. If you want to install this script as an example, then the server will also need to have a Perl interpreter installed; it's installed in <code class="literal">/usr/bin/perl</code> on many systems.</p><p>This example will also include directly testing a server running an <code class="literal">rsync</code> daemon called <code class="literal">troy.naginet</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec58"/>How to do it...</h2></div></div></div><p>We can download and install a new plugin as <a id="id90" class="indexterm"/>
<a id="id91" class="indexterm"/>follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the URL for the download link for the most recent version of the <code class="literal">check_rsync</code> plugin:<div class="mediaobject"><img src="graphics/5566_02_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Navigate to the plugins directory for the <a id="id92" class="indexterm"/>Nagios Core server. The default location is <code class="literal">/usr/local/nagios/libexec</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
</pre></div></li><li class="listitem">Download the plugin using <code class="literal">wget</code> into a <a id="id93" class="indexterm"/>file called <code class="literal">check_rsync</code>. It's important to surround the URL in quotes:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># wget 'http://exchange.nagios.org/components/com_mtree/attachment.php?link_id=307&amp;cf_id=29' -O check_rsync</strong></span>
</pre></div></li><li class="listitem">Make the plugin executable using <code class="literal">chmod</code> and <code class="literal">chown</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chown nagios.nagios check_rsync</strong></span>
<span class="strong"><strong># chmod 0770 check_rsync</strong></span>
</pre></div></li><li class="listitem">Run the plugin directly with no arguments to check that it runs, and to get usage instructions. It's a good idea to test it as the <code class="literal">nagios</code> user using <code class="literal">su</code> or <code class="literal">sudo</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ ./check_rsync</strong></span>
<span class="strong"><strong>Usage: check_rsync -H &lt;host&gt; [-p &lt;port&gt;] [-m &lt;module&gt;[,&lt;user&gt;,&lt;password&gt;] [-m &lt;module&gt;[,&lt;user&gt;,&lt;password&gt;]...]]</strong></span>
</pre></div></li><li class="listitem">Try running the plugin directly against a host running <code class="literal">rsync</code>, to see if it works and reports a status:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./check_rsync -H troy.naginet</strong></span>
<span class="strong"><strong>Output normally starts with the status determined, with any extra information after a colon:</strong></span>
<span class="strong"><strong>OK: Rsync is up</strong></span>
</pre></div></li></ol></div><p>If all of this works, then the plugin is now installed and working correctly.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec59"/>How it works...</h2></div></div></div><p>Because Nagios Core plugins are programs in themselves, installing a <a id="id94" class="indexterm"/>plugin amounts to saving a program or script into an appropriate directory; in this case, <code class="literal">/usr/local/nagios/libexec</code>, where all the other plugins live. It's then available to be used the same way as any other plugin.</p><p>The next step once the plugin is working is defining a command in the Nagios Core configuration for it, so that it can be used to monitor hosts and/or services. This can be done with the <span class="emphasis"><em>Creating a new command</em></span> recipe in this chapter.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec60"/>There's more...</h2></div></div></div><p>If we inspect the Perl script, we can see a little bit of how it works. It works like any other Perl script, except for the fact that its return values are defined in a hash table called <code class="literal">%ERRORS</code>, and the return values it chooses depend on what happens when it tries to check the <code class="literal">rsync</code> process. This is the most important part of implementing a plugin for Nagios Core.</p><p>Installation procedures for different plugins vary. In particular, many plugins are written in languages such as C, and hence need be compiled. One such plugin is the popular <code class="literal">check_nrpe</code>. Rather than simply being saved into a directory and made executable, these sorts of plugins often follow the usual pattern of configuration, compilation, and installation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ./configure</strong></span>
<span class="strong"><strong>$ make</strong></span>
<span class="strong"><strong># make install</strong></span>
</pre></div><p>For many plugins that are built in this style, the last step in that process will often install the compiled plugin into the appropriate directory for us. In general, if instructions are included with the plugin, then it pays to read them so that we can ensure we install it correctly.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec61"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Finding a plugin</em></span>, <span class="emphasis"><em>Removing a plugin</em></span>, and <span class="emphasis"><em>Creating a new command</em></span> recipes in this chapter</li></ul></div></div></div>
<div class="section" title="Removing a plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Removing a plugin</h1></div></div></div><p>In this recipe, we'll remove a plugin that we no longer need as part of our Nagios Core installation. Perhaps it's not working correctly, <a id="id95" class="indexterm"/>the service it monitors is no longer available, or there are security or licensing concerns with its usage.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec62"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already, and have a plugin that you would like to remove from the server. In this instance, we'll remove the now unneeded <code class="literal">check_rsync</code> plugin from our Nagios Core server.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec63"/>How to do it...</h2></div></div></div><p>We can remove a plugin from our Nagios Core instance as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove any part of the configuration that uses the plugin, including hosts or services that use it for <code class="literal">check_command</code>, and command definitions that refer to the program. As an example, the following definition for a command would no longer work after we removed the <code class="literal">check_rsync</code> plugin:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_rsync
    command_line  $USER1$/check_rsync -H $HOSTADDRESS$
}</pre></div><p>Using a tool such as <code class="literal">grep</code> can be a good way to find mentions of the command and plugin:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># grep -R check_rsync /usr/local/nagios/etc</strong></span>
</pre></div></li><li class="listitem">Change directory on the Nagios Core server to wherever the plugins are kept. The default location is <code class="literal">/usr/local/nagios/libexec</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
</pre></div></li><li class="listitem">Delete the plugin with the <code class="literal">rm</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># rm check_rsync</strong></span>
</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec64"/>How it works...</h2></div></div></div><p>Nagios Core plugins are simply external programs that the server uses to perform checks of hosts and services. If a plugin is no longer wanted, all that needs to be done is to remove references to it in our configuration, if any, and then delete the plugin program from <code class="literal">/usr/local/nagios/libexec</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec65"/>There's more...</h2></div></div></div><p>Usually there's not any harm in leaving the plugin's program on the server even if Nagios Core isn't using it. It doesn't slow anything down or <a id="id96" class="indexterm"/>cause any other problems, and it may be needed later. Nagios Core plugins are generally quite small programs, and should not really cause disk space concerns on a modern server.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec66"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Finding a plugin</em></span>, <span class="emphasis"><em>Installing a plugin</em></span>, and <span class="emphasis"><em>Creating a new command</em></span> recipes in this chapter</li></ul></div></div></div>
<div class="section" title="Creating a new command"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Creating a new command</h1></div></div></div><p>In this recipe, we'll create a new command for a plugin that was just installed into the <code class="literal">/usr/local/nagios/libexec</code> directory on the Nagios Core server. This will define the way in which Nagios Core should use the plugin, and thereby allow it to <a id="id97" class="indexterm"/>
<a id="id98" class="indexterm"/>be used as part of a service definition.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec67"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already, and have a plugin installed for which you'd like to define a new command. This will allow you to use it as part of a service definition. In this instance, we'll define a command for an installed <code class="literal">check_rsync</code> plugin.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec68"/>How to do it...</h2></div></div></div><p>We can define a new command in our configuration as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the objects configuration for Nagios Core. The default location is <code class="literal">/usr/local/nagios/etc/objects</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the <code class="literal">commands.cfg</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi commands.cfg</strong></span>
</pre></div></li><li class="listitem">At the bottom of the file, add the following command definition:<div class="informalexample"><pre class="programlisting">define command {
    command_name  check_rsync
<span class="strong"><strong>    command_line  $USER1$/check_rsync -H $HOSTADDRESS$</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>If the validation passes and the server restarts successfully, we should be able to use the <code class="literal">check_rsync</code> command in a service definition.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec69"/>How it works...</h2></div></div></div><p>The configuration we added to the <code class="literal">commands.cfg</code> file defines a new command called <code class="literal">check_rsync</code>, which defines a method for using the plugin of the same name to monitor a service. This enables us to use <code class="literal">check_rsync</code> as a <a id="id99" class="indexterm"/>
<a id="id100" class="indexterm"/>value for the <code class="literal">check_command</code> directive in a service declaration, which might look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            troy.naginet
    service_description  RSYNC
<span class="strong"><strong>    check_command        check_rsync</strong></span>
}</pre></div><p>Only two directives are required for command definitions, and we've defined both:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">command_name</code>: This defines the unique name with which we can reference the command when we use it in host or service definitions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">command_line</code>: This defines the command line that should be executed by Nagios Core to make the appropriate check.</li></ul></div><p>This particular command line also uses two macros:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$USER1$</code>: This expands to <code class="literal">/usr/local/nagios/libexec</code>, the location of the plugin binaries, including <code class="literal">check_rsync</code>. It is defined in the sample configuration in the file <code class="literal">/usr/local/nagios/etc/resource.cfg</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTADDRESS$</code>: This expands to the address of any host for which this command is used as a host or service definition.</li></ul></div><p>So if we used the command in a service checking the <code class="literal">rsync</code> server on <code class="literal">troy.naginet</code>, then the completed command might look similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_rsync -H troy.naginet</strong></span>
</pre></div><p>We could run this straight from the command line <a id="id101" class="indexterm"/>
<a id="id102" class="indexterm"/>ourselves as the nagios user to see what kind of results it returns:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_rsync -H troy.naginetOK: Rsync is up</strong></span>
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec70"/>There's more...</h2></div></div></div><p>A plugin can be used for more than one command. If we had a particular <code class="literal">rsync</code> module to check with the configured name of <code class="literal">backup</code>, we could write another command called <code class="literal">check_rsync_backup</code>
<a id="id103" class="indexterm"/>, as follows, to check this module is available:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_rsync_backup
<span class="strong"><strong>    command_line  $USER1$/check_rsync -H $HOSTADDRESS$ -m backup</strong></span>
}</pre></div><p>Or if one or more of our <code class="literal">rsync</code> servers was running on an alternate port, say port <code class="literal">5873</code>, then we could define a separate command, <code class="literal">check_rsync_altport</code>, for that:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_rsync_altport
<span class="strong"><strong>    command_line  $USER1$/check_rsync -H $HOSTADDRESS$ -p 5873</strong></span>
}</pre></div><p>Commands can thus be defined as precisely as we need them to be. We explore this in more detail in the <span class="emphasis"><em>Customizing an existing command</em></span> recipe in this chapter.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec71"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Installing a plugin</em></span> and <span class="emphasis"><em>Customizing an existing command</em></span> recipes in this chapter</li></ul></div></div></div>
<div class="section" title="Customizing an existing command"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Customizing an existing command</h1></div></div></div><p>In this recipe, we'll customize an existing command definition. There are a number of reasons why you might want to do this, but a common one is if a check is "overzealous", sending notifications for <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> states, which aren't actually terribly worrisome. It can also be useful if a check is too "forgiving" <a id="id104" class="indexterm"/>
<a id="id105" class="indexterm"/>and doesn't detect actual problems with hosts or services. </p><p>Another reason is to account for peculiarities in your own network. For example, if you run HTTP daemons on a large number of hosts on the alternative port <code class="literal">8080</code> that you need to check, it would be convenient to have a <code class="literal">check_http_altport</code> command<a id="id106" class="indexterm"/> available. We can do this by copying and altering the definition for the vanilla <code class="literal">check_http</code> command.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec72"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already. You should also already be familiar with the relationship between services, commands, and plugins.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec73"/>How to do it...</h2></div></div></div><p>We can customize an existing command definition as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the objects configuration for Nagios Core. The default location is <code class="literal">/usr/local/nagios/etc/objects</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the <code class="literal">commands.cfg</code> file, or any file which is at an appropriate location for the <code class="literal">check_http</code> command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi commands.cfg</strong></span>
</pre></div></li><li class="listitem">Find the definition for the <code class="literal">check_http</code> command. In a default Nagios Core configuration, it should look similar to the following:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># 'check_http' command_definition</strong></span>
<span class="strong"><strong>define command {</strong></span>
<span class="strong"><strong>    command_name  check_http</strong></span>
<span class="strong"><strong>    command_line  $USER1$/check_http -H $HOSTADDRESS$ $ARG1$</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Copy this definition into a new definition directly below it and alter it to look similar to the following code snippet, renaming the command and adding a new option to its command line:<div class="informalexample"><pre class="programlisting"># 'check_http_altport' command_definition
define command {
<span class="strong"><strong>    command_name  check_http_altport</strong></span>
<span class="strong"><strong>    command_line  $USER1$/check_http -H $HOSTADDRESS$ -p 8080 $ARG1$</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>If the validation passed and the server restarted successfully, we should now be able to use the <code class="literal">check_http_altport</code> command, which is based on the original <code class="literal">check_http</code> command, in a service definition.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec74"/>How it works...</h2></div></div></div><p>The configuration we added to the <code class="literal">commands.cfg</code> file reproduces the command definition for <code class="literal">check_http</code>, but changes it in two ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It renames the command from <code class="literal">check_http</code> to <code class="literal">check_http_alt</code>, which is necessary to distinguish the commands from one another. Command names in Nagios Core, just like host names, <a id="id107" class="indexterm"/><a id="id108" class="indexterm"/>must be unique.</li><li class="listitem" style="list-style-type: disc">It adds the option <code class="literal">-p 8080</code> to the command-line call, specifying the time when the call to <code class="literal">check_http</code> is made. The check will be made using TCP port <code class="literal">8080</code>, rather than the default value for TCP port <code class="literal">80</code>.</li></ul></div><p>The <code class="literal">check_http_alt</code> command<a id="id109" class="indexterm"/> can now be used as a check command in the same way as a <code class="literal">check_http</code> command. For example, a service definition that checks whether the <code class="literal">sparta.naginet</code> host is running an HTTP daemon on port <code class="literal">8080</code> might look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
<span class="strong"><strong>    service_description  HTTP_8080</strong></span>
<span class="strong"><strong>    check_command        check_http_alt</strong></span>
}</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec75"/>There's more... </h2></div></div></div><p>This recipe's title implies that we should customize the existing commands by editing them in place, and indeed, this works fine if we really do want to do things this way. Instead of copying the command definition, we could just add the <code class="literal">-p 8080</code> or another customization to the command line and change the original command.</p><p>However, this is bad practice in most cases, mostly because it could break the existing monitoring and be potentially confusing to other administrators of the Nagios Core server. If we have a special case for monitoring—in this case, checking a non-standard port for HTTP—then it's wise to create a whole new command based on the existing one with the customizations we need.</p><p>There is no limit to the number of commands you can define, so you can be very liberal in defining as many alternative commands as you need. It's a good idea to give them instructive names that say something about what they do, as well as to add explanatory comments to the configuration file. You can add a <a id="id110" class="indexterm"/>
<a id="id111" class="indexterm"/>comment to the file by prefixing it with a <code class="literal">#</code> character:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># 'check_http_altport' command_definition. This is to keep track of</strong></span>
<span class="strong"><strong># servers that have panels running on alternative ports.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>define command {</strong></span>
<span class="strong"><strong>    command_name  check_http_altport</strong></span>
<span class="strong"><strong>    command_line  $USER1$/check_http -H $HOSTADDRESS$ -p 8080 $ARG1$</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec76"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new service</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li></ul></div></div></div>
<div class="section" title="Using an alternative check command for hosts"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using an alternative check command for hosts</h1></div></div></div><p>In this recipe, we'll learn how to deal with a slightly tricky case in network monitoring—monitoring a server that doesn't respond to <a id="id112" class="indexterm"/>PING, but still provides some network service that requires checking.</p><p>It's good practice to allow PING where you can, as it's one of the stipulations in <span class="strong"><strong>RFC 1122</strong></span> and a very useful diagnostic tool not just for monitoring, but also for troubleshooting. However, sometimes servers that are accessed only by a few people might be configured not to respond to these messages, perhaps for reasons of secrecy. It's quite common for domestic routers to be configured this way.</p><p>Another very common reason for this problem, and the example we'll address here, is checking servers that are behind an <span class="strong"><strong>IPv4 NAT</strong></span> firewall. It's not possible to address the host directly via an <span class="strong"><strong>RFC1918</strong></span> address, such as <code class="literal">192.168.1.20</code>, from the public Internet. Pinging the public interface of the router therefore doesn't tell us whether the host for which it is translating addresses is actually working.</p><p>However, port <code class="literal">22</code> for SSH is forwarded from the outside to <a id="id113" class="indexterm"/>this server, and it's this service that we need to check for availability.</p><div class="mediaobject"><img src="graphics/5566_02_03.jpg" alt="Using an alternative check command for hosts"/></div><p>We'll do this by checking whether the host is up through an SSH check, since we can't PING it from the outside as we normally would.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec77"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already. You should also already be familiar with the relationship between services, commands, and plugins.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec78"/>How to do it...</h2></div></div></div><p>We can specify an alternative check method for a host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the objects configuration for Nagios Core. The default location is <code class="literal">/usr/local/nagios/etc/objects</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Find the file that contains the host definition for the host that won't respond to PING, and edit it. In this example, our <code class="literal">crete.naginet</code> host is the one we want to edit:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi crete.naginet.cfg</strong></span>
</pre></div></li><li class="listitem">Change or define the <code class="literal">check_command</code> parameter of the host to the command that we want to use for the check instead of the usual <code class="literal">check-host-alive</code> or <code class="literal">check_ping</code> plugin. In this case, we want to use <code class="literal">check_ssh</code>. The resulting host definition <a id="id114" class="indexterm"/>might look similar to the following code snippet:<div class="informalexample"><pre class="programlisting">define host {
    use            linux-server
    host_name      crete.naginet
    alias          crete
    address        10.128.0.23
    check_command  check_ssh
}</pre></div><p>Note that defining <code class="literal">check_command</code> still works even if we're using a host template, such as <code class="literal">generic-host</code> or <code class="literal">linux-server</code>. It's a good idea to check that the host will actually respond to our check as we expect it to:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ /usr/local/nagios/libexec/check_ssh -H 10.128.0.23</strong></span>
<span class="strong"><strong>SSH OK - OpenSSH_5.5p1 Debian-6+squeeze1 (protocol 2.0)</strong></span>
</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, the next scheduled host check for the <code class="literal">crete.naginet</code> server should show the host as <code class="literal">UP</code>, because it was checked with the <code class="literal">check_ssh</code> command<a id="id115" class="indexterm"/> and not the usual <code class="literal">check-host-alive</code> command.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec79"/>How it works</h2></div></div></div><p>The configuration we added for the <code class="literal">crete.naginet</code> host uses <code class="literal">check_ssh</code> to check whether the host is <code class="literal">UP</code>, rather than a check that uses PING. This is appropriate because the only public service accessible from <code class="literal">crete.naginet</code> is its SSH service.</p><div class="mediaobject"><img src="graphics/5566_02_04.jpg" alt="How it works"/></div><p>The <code class="literal">check_ssh</code> command<a id="id116" class="indexterm"/> is normally used to check whether a service is available, rather than a host. However, Nagios Core allows us to use it as a host check command as well. Most service commands work this way; you could check a web server behind NAT in the same way with <code class="literal">check_http</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec80"/>There's more...</h2></div></div></div><p>Note that for completeness' sake, it would also be appropriate to monitor the NAT router via PING, or some other check appropriate to its public address. That way, if the host check for the SSH server fails, we can check to see if the NAT router in front of it is still available, which assists in troubleshooting whether the <a id="id117" class="indexterm"/>problem is with the server or with the NAT router in front of it. You can make this setup even more useful by making the NAT router a parent host for the SSH server behind it, explained in the <span class="emphasis"><em>Creating a network host hierarchy</em></span> recipe in <a class="link" href="ch08.html" title="Chapter 8. Managing Network Layout">Chapter 8</a>, <span class="emphasis"><em>Understanding the Network Layout</em></span>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec81"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring SSH for any host</em></span> and <span class="emphasis"><em>Checking an alternative SSH port</em></span> recipes in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <span class="emphasis"><em>Monitoring Methods</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a network host hierarchy</em></span> and <span class="emphasis"><em>Establishing a host dependency</em></span> recipes in <a class="link" href="ch08.html" title="Chapter 8. Managing Network Layout">Chapter 8</a>, <span class="emphasis"><em>Understanding the Network Layout</em></span></li></ul></div></div></div>
<div class="section" title="Writing a new plugin from scratch"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Writing a new plugin from scratch</h1></div></div></div><p>Even given the very useful standard plugins in the Nagios Plugins set, and the large number of custom plugins available on Nagios Exchange, occasionally as our monitoring setup grows more refined, we may find that there is some service or property of a host that we would like to check, but for which there doesn't seem to be any suitable plugin available. Every network is different, and sometimes the <a id="id118" class="indexterm"/>plugins that others have generously donated their time to make for the community don't quite cover all your bases. Generally, the more specific your monitoring requirements get, the less likely it is that there's a plugin available that does exactly what you need.</p><p>In this example, we'll deal with a very particular problem that we'll assume can't be dealt with effectively by any known Nagios Core plugins, and we'll write one ourselves using Perl. Here's the example problem:</p><p>Our Linux security team wants to be able to automatically check whether any of our servers are running kernels that have known exploits. However, they're not worried about every vulnerable kernel, only specific versions. They have provided us with the version numbers of three kernels having small vulnerabilities that they're not particularly worried about but that do need patching, and one they're extremely worried about.</p><p>Let's say the minor vulnerabilities are in the kernels with version numbers <code class="literal">2.6.19</code>, <code class="literal">2.6.24</code>, and <code class="literal">3.0.1</code>. The serious vulnerability is in the kernel with version number <code class="literal">2.6.39</code>. Note that the version numbers in this case are arbitrary and don't necessarily reflect any real kernel vulnerabilities!</p><p>The team could log in to all of the servers individually to check them, but the servers are of varying ages and access methods, and managed by different people. They would also have to check manually more than once, because it's possible that a naive administrator could upgrade to a kernel that's known to be vulnerable in an older release, and they also might want to add other vulnerable kernel numbers for checking later on.</p><p>So, the team have asked us to solve the problem with Nagios Core monitoring, and we've decided the best way to do it is to write our own plugin, <code class="literal">check_vuln_kernel</code>, which checks the output of <code class="literal">uname</code> for a kernel version string, and then does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If it's one of the slightly vulnerable kernels, then it will return a <code class="literal">WARNING</code> state, so that we can let the security team know that they should address it when they're next able to.</li><li class="listitem" style="list-style-type: disc">If it's the highly vulnerable kernel version, then it will return a <code class="literal">CRITICAL</code> state, so that the security team knows a patched kernel needs to be installed immediately.</li><li class="listitem" style="list-style-type: disc">If <code class="literal">uname</code> gives an error or output we don't understand, then it will return an <code class="literal">UNKNOWN</code> state, alerting the team to a bug in the plugin or possibly more serious problems with the server.</li><li class="listitem" style="list-style-type: disc">Otherwise, it returns an <code class="literal">OK</code> state, confirming that the kernel is not known to be a vulnerable one.</li><li class="listitem" style="list-style-type: disc">Finally, they want to be able to see at a glance in the Nagios Core monitoring what the kernel version is, and whether it's vulnerable or not.</li></ul></div><p>For the purposes of this example, we'll only monitor the Nagios Core server itself, but via NRPE we'd be able to install this plugin on the other servers that require this monitoring, where they'll work just as well. You should see the <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span> to learn how to do this.</p><p>While this problem is very specific, we'll approach it in a <a id="id119" class="indexterm"/>very general way, which you'll be able to adapt to any solution where it's required for a Nagios plugin to:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Run a command and pull its output into a variable.</li><li class="listitem">Check the output for the presence or absence of certain patterns.</li><li class="listitem">Return an appropriate status based on those tests.</li></ol></div><p>All that means is that if you're able to do this, you'll be able to effectively monitor anything on a server from Nagios Core!</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec82"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server running with a few hosts and services configured already. You should also already be familiar with the relationship between services, commands, and plugins. You should also have Perl installed.</p><p>This will be a rather long recipe that ties in a lot of Nagios Core concepts. You should be familiar with all the following concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining new hosts and services, and how they relate to one another</li><li class="listitem" style="list-style-type: disc">Defining new commands, and how they relate to the plugins they call</li><li class="listitem" style="list-style-type: disc">Installing, testing, and using Nagios Core plugins</li></ul></div><p>Some familiarity with Perl would also be helpful, but is not required. We'll include comments to explain what each block of code is doing in the plugin.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec83"/>How to do it...</h2></div></div></div><p>We can write, test, and implement our example <a id="id120" class="indexterm"/>plugin as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the directory containing the plugin binaries for Nagios Core. The default location is <code class="literal">/usr/local/nagios/libexec</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/libexec</strong></span>
</pre></div></li><li class="listitem">Start editing a new file called <code class="literal">check_vuln_kernel</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi check_vuln_kernel</strong></span>
</pre></div></li><li class="listitem">Include the following code in it; take note of the comments, which explain what each block of code is doing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#!/usr/bin/env perl</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Use strict Perl style and report potential problems to help us write this</strong></span>
<span class="strong"><strong># securely and portably.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>use strict;</strong></span>
<span class="strong"><strong>use warnings;</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Include the Nagios utils.pm file, which includes definitions for the return</strong></span>
<span class="strong"><strong># statuses that are appropriate for each level: OK, WARNING, CRITICAL, and</strong></span>
<span class="strong"><strong># UNKNOWN. These will become available in the %ERRORS hash.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>use lib "/usr/local/nagios/libexec";</strong></span>
<span class="strong"><strong>use utils "%ERRORS";</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Define a pattern that matches any kernel vulnerable enough so that if we find</strong></span>
<span class="strong"><strong># it we should return a CRITICAL status.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>my $critical_pattern = "^(2\.6\.39)[^\\d]";</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Same again, but for kernels that only need a WARNING status.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>my $warning_pattern = "^(2\.6\.19|2\.6\.24|3\.0\.1)[^\\d]";</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Run the command uname with option -r to get the kernel release version, put</strong></span>
<span class="strong"><strong># the output into a scalar $release, and trim any newlines or whitespace</strong></span>
<span class="strong"><strong># around it.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>chomp(my $release = qx|/bin/uname -r|);</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># If uname -r exited with an error status, that is, anything greater than 1,</strong></span>
<span class="strong"><strong># then there was a problem and we need to report that as the UNKNOWN status</strong></span>
<span class="strong"><strong># defined by Nagios Core's utils.pm.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>if ($? != 0) {</strong></span>
<span class="strong"><strong>    exit $ERRORS{UNKNOWN};</strong></span>
<span class="strong"><strong>}</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Check to see if any of the CRITICAL patterns are matched by the release</strong></span>
<span class="strong"><strong># number. If so, print the version number and exit, returning the appropriate</strong></span>
<span class="strong"><strong># status.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>if ($release =~ m/$critical_pattern/) {</strong></span>
<span class="strong"><strong>    printf "CRITICAL: %s\n", $release;</strong></span>
<span class="strong"><strong>    exit $ERRORS{CRITICAL};</strong></span>
<span class="strong"><strong>}</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># Same again, but for WARNING patterns.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>if ($release =~ m/$warning_pattern/) {</strong></span>
<span class="strong"><strong>    printf "WARNING: %s\n", $release;</strong></span>
<span class="strong"><strong>    exit $ERRORS{WARNING};</strong></span>
<span class="strong"><strong>}</strong></span>

<span class="strong"><strong>#</strong></span>
<span class="strong"><strong># If we got this far, then uname -r worked and didn't match any of the</strong></span>
<span class="strong"><strong># vulnerable patterns, so we'll print the kernel release and return an OK</strong></span>
<span class="strong"><strong># status.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>printf "OK: %s\n", $release;</strong></span>
<span class="strong"><strong>exit $ERRORS{OK};</strong></span>
</pre></div></li><li class="listitem">Make the plugin owned by the <code class="literal">nagios</code> user and executable with <code class="literal">chmod</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chown nagios.nagios check_vuln_kernel# chmod 0770 check_vuln_kernel</strong></span>
<span class="strong"><strong>Run the plugin directly to test it:</strong></span>
<span class="strong"><strong># sudo -s -u nagios</strong></span>
<span class="strong"><strong>$ ./check_vuln_kernel</strong></span>
<span class="strong"><strong>OK: 2.6.32-5-686</strong></span>
</pre></div></li></ol></div><p>We should now be able to use the plugin in a command, and hence in a service check, just like any other command. Note that the code for this plugin is included in the code bundle of this book for your convenience.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec84"/>How it works...</h2></div></div></div><p>The code we added in the new plugin file <code class="literal">check_vuln_kernel</code> is actually quite simple:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It runs <code class="literal">uname -r</code> to get the version number of the kernel.</li><li class="listitem">If that didn't work, it exits with a status of <code class="literal">UNKNOWN</code>.</li><li class="listitem">If the version number matches anything in a <a id="id121" class="indexterm"/>pattern containing critical version numbers, it exits with a status of <code class="literal">CRITICAL</code>.</li><li class="listitem">If the version number matches anything in a pattern containing warning version numbers, it exits with a status of <code class="literal">WARNING</code>.</li><li class="listitem">Otherwise, it exits with a status of <code class="literal">OK</code>.</li></ol></div><p>It also prints the status as a string, along with the kernel version number, if it was able to retrieve one.</p><p>We might set up a command definition for this plugin as follows:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_vuln_kernel
    command_line  $USER1$/check_vuln_kernel
}</pre></div><p>In turn, we might set up a service definition for that command as follows:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  local-service
    host_name            localhost
    service_description  VULN_KERNEL
<span class="strong"><strong>    check_command        check_vuln_kernel</strong></span>
}</pre></div><p>If the kernel was not vulnerable, the service's appearance in the web interface might look similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/5566_02_05.jpg" alt="How it works..."/></div><p>However, if the monitoring server itself happened to be running a vulnerable kernel, then it might look more similar to the following screenshot (and send consequent notifications, if configured to do so):</p><div class="mediaobject"><img src="graphics/5566_02_06.jpg" alt="How it works..."/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec85"/>There's more...</h2></div></div></div><p>This may be a simple plugin, but its structure can be generalized to all sorts of monitoring tasks. If we can figure out the correct logic to return the status we want in an appropriate programming language, then we can write a plugin to do basically anything.</p><p>A plugin like this could just as effectively be written in C for improved performance, but we'll assume for simplicity's sake that high performance for the plugin is not required. Instead, we can use a language that's better suited for quick ad hoc scripts like this one; in this case, we use Perl. The file <code class="literal">utils.sh</code>, also in <code class="literal">/usr/local/nagios/libexec</code>, allows us to write in shell script if we'd prefer that.</p><p>If you write a plugin that you think could be generally useful for the Nagios community at large, then please consider putting it under a free software license and submitting it to the Nagios Exchange, so that others can benefit from your work. Community contribution and support is what has made Nagios Core such a great monitoring platform in such wide use.</p><p>Any plugin you publish in this way should conform to the Nagios Plugin Development Guidelines. At the time of writing, these are available at <a class="ulink" href="http://nagiosplug.sourceforge.net/developer-guidelines.html">http://nagiosplug.sourceforge.net/developer-guidelines.html</a>.</p><p>Finally, you should note that the method of including <code class="literal">utils.pm</code>, used in this example, may be deprecated in future versions of Nagios Core. <a id="id122" class="indexterm"/>It is used here for simplicity's sake. The new method of including it in Perl is done with a CPAN module called <code class="literal">Nagios::Plugin</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec86"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new command</em></span> and <span class="emphasis"><em>Customizing an existing command</em></span> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new service recipe</em></span> in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, a</em></span><span class="emphasis"><em>nd Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring local services on a remote machine with NRPE</em></span> recipe in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span></li></ul></div></div></div></body></html>