- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Linux Shell and Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux shell 和文件系统
- en: Understanding the **Linux filesystem**, **file management** fundamentals, and
    the basics of the **Linux shell** and **command-line interface** (**CLI**) is
    essential for a modern-day Linux professional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 **Linux 文件系统**、**文件管理** 基础知识，以及 **Linux shell** 和 **命令行界面** (**CLI**) 的基本知识，对于现代
    Linux 专业人员来说至关重要。
- en: In this chapter, you will learn how to use the Linux shell and some of the most
    common commands in Linux. You will learn about the structure of a basic Linux
    command and how the Linux filesystem is organized. We’ll explore various commands
    for working with files and directories. Along the way, we’ll introduce you to
    the most common command-line text editors. We hope that by the end of this chapter,
    you’ll be comfortable using the Linux CLI and be ready for future, more advanced
    explorations. This chapter will set the foundation for using the Linux shell,
    and for more information about the shell, go to [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164),
    *Linux* *Shell Scripting*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 Linux shell 和一些 Linux 中最常用的命令。您将了解一个基本的 Linux 命令的结构，以及 Linux 文件系统的组织方式。我们将探索处理文件和目录的各种命令。过程中，我们还将介绍最常用的命令行文本编辑器。希望通过本章的学习，您能够熟练使用
    Linux CLI，为以后更深入的学习做好准备。本章将为使用 Linux shell 打下基础，关于 shell 的更多信息，请访问 [*第 8 章*](B19682_08.xhtml#_idTextAnchor164)，*Linux*
    *Shell 脚本编写*。
- en: 'We’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Introducing the Linux shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Linux shell
- en: The Linux filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 文件系统
- en: Working with files and directories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文件和目录
- en: Using text editors to create and edit files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本编辑器创建和编辑文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a working installation of a standard Linux distribution,
    on either server, desktop, PC, or **Virtual Machine** (**VM**). Our examples and
    case studies use the Ubuntu and Fedora platforms, but the commands and examples
    explored are equally suitable for any other Linux distribution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要在标准 Linux 发行版的工作环境中进行安装，支持服务器、桌面、PC 或 **虚拟机** (**VM**) 平台。我们的示例和案例研究使用 Ubuntu
    和 Fedora 平台，但所探讨的命令和示例同样适用于任何其他 Linux 发行版。
- en: Introducing the Linux shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Linux shell
- en: 'Linux has its roots in the Unix operating system, and one of its main strengths
    is the command-line interface. In the old days, this was called *the shell*. In
    `sh` command. The shell is a program that has two streams: an *input stream* and
    an *output stream*. The input is a command given by the user, and the output is
    the result of that command, or an interpretation of it. In other words, the shell
    is the primary interface between the user and the machine.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 起源于 Unix 操作系统，其中一个主要优势是命令行界面。以前，这被称为 *shell*。在 `sh` 命令中，shell 是一个程序，它有两个流：*输入流*
    和 *输出流*。输入是用户输入的命令，而输出是该命令的结果或其解释。换句话说，shell 是用户与机器之间的主要接口。
- en: The main shell in major Linux distributions is called **Bash**, which is an
    acronym for **Bourne Again Shell**, named after Steve Bourne, the original creator
    of the shell in UNIX. Alongside Bash, there are other shells available in Linux,
    such as **ksh**, **tcsh**, and **zsh**. In this chapter and throughout the book,
    we will cover the Bash shell, as it is the most widely used shell in modern Linux
    distributions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 Linux 发行版中的默认 shell 称为 **Bash**，它是 **Bourne Again Shell** 的缩写，命名来源于 UNIX
    中原始 shell 的创建者 Steve Bourne。除了 Bash，Linux 中还提供了其他几种 shell，如 **ksh**、**tcsh** 和
    **zsh**。在本章及全书中，我们将主要讨论 Bash shell，因为它是现代 Linux 发行版中最广泛使用的 shell。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Distributions such as Debian, Ubuntu, Fedora, CentOS Stream, RHEL, openSUSE,
    SLE, and Linux Mint, just to name a few, use the *Bash* shell by default. Other
    distributions, such as Kali Linux, have switched to *zsh* by default. Manjaro
    offers zsh on some editions. For those who use macOS, you should know that zsh
    has been the default shell for some years now. Nevertheless, you can install any
    shell you want on Linux and make it your default one. In general, shells are pretty
    similar, as they do the same thing, but they add different *extras* to usability
    and features. If you are interested in a specific shell, feel free to use it and
    test out the differences between others.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: One shell can be assigned to each user. Users on the same system can use different
    shells. One way to check the default shell is by accessing the `/etc/passwd` file.
    More details about this file and user accounts will be discussed in [*Chapter
    4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users and Groups*. For now, it
    is important to know where to look for the default shell. In this file, the last
    characters from each line represent the user’s default shell. The `/etc/passwd`
    file has the users listed on each line, with details about their **process identification
    number** (**PID**), **group identification number** (**GID**), username, home
    directory, and basic shell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the default shell for each user, execute the following command by using
    your user’s name (in our case, it is `packt`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be a list of the contents of the `/etc/passwd` file. Depending
    on the number of users you have on your system, you will see all of them, each
    one on a separate line. An easier way to see the *current shell* is by running
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This shows what exactly is running your command, which in the case of the CLI
    is the shell. The `$0` part is a `echo $0` command on Ubuntu and on Debian:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Commands used to see the running shell](img/Figure_02.01_B19682.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Commands used to see the running shell
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, running the `echo $0` command gives us different outputs but
    with the same message: the running shell is Bash. If you have other shells that
    you prefer, you can easily assign another shell to your user, if you already have
    it installed. However, if you know Bash, you will be comfortable with all the
    other available shells.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '*The Linux shell is case-sensitive*. This means that everything you type inside
    the command line should respect this. For example, the `cat` command used earlier
    used lowercase. If you type `Cat` or `CAT`, the shell will not recognize it as
    being a command. The same rule applies to file paths. You will notice that default
    directories in your home directory use uppercase for the first letter, as in `~/Documents`,
    `~/Downloads`, and so on. Those names are different from `~/documents` or `~/downloads`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use Linux commands and the shell in addition
    to learning about its filesystem. You will learn about software management in
    [*Chapter 3*](B19682_03.xhtml#_idTextAnchor075), thus showing you how to install
    another shell now would mean that we will get ahead of ourselves. We want you
    to slowly but steadily build your Linux knowledge, so we will show you in the
    next chapter how to install a new shell. For now, Bash is sufficient, and we will
    use it throughout the book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see all the shells that are installed on your system, you can
    run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our case, the output with all the installed shells (by default) in Ubuntu
    Server 22.04.2 LTS is shown in the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The shells available by default in Ubuntu](img/Figure_02.02_B19682.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The shells available by default in Ubuntu
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: This will show you all the shells installed. You can use any of those or can
    install new ones as we will show you in [*Chapter 3*](B19682_03.xhtml#_idTextAnchor075).
    Also, in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), when we work with user
    accounts, you will get to learn how you can change a user’s shell.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The following section will introduce you to shell connection types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Establishing the shell connection
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can make two different types of connections to the shell: `tty` and `pts`.
    The name `tty` stands for **teletypewriter**, which was a type of terminal used
    at the beginning of computing. This connection is considered a native one, with
    ports that are direct connections to your computer. The link between the user
    and the computer is mainly found to be through a keyboard, which is considered
    to be a native terminal device.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The `pts` connection is generated by SSH or Telnet types of links. Its name
    stands for `ssh` or `xterm`. It is the slave of the `pty`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will further explore the connections to virtual terminals
    available in Linux.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Virtual consoles/terminals
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The terminal was thought of as a device that manages the input strings (which
    are commands) between a process and other I/O devices such as a keyboard and a
    screen. There are also **pseudo terminals**, which are emulated terminals that
    behave the same way as a **classical terminal**. The difference is that it does
    not interact with devices directly, as it is all emulated by the Linux kernel,
    which transmits the I/O to a program called the shell.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '`tty1`, `tty2`, `tty3,` `tty4`, `tty5`, and `tty6`, respectively, on your computer.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explain this using an Ubuntu 22.04.2 LTS Server VM installation, but
    it is identical in Rocky Linux too. After starting the VM and being prompted to
    log in with your username and password, the first line on the screen will be something
    similar to the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you press any of the preceding key combinations, you will see your terminal
    change from `tty1` to any of the other `tty` instances. For example, if you press
    *Ctrl* + *Alt* + *F6*, you will see this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we were using the server edition of Ubuntu, we did not have the GUI installed.
    But if you were to use a desktop edition, you will be able to use *Ctrl* + *Alt*
    + *F7* to enter `X graphical` mode, for example. The `neptune` string is the name
    we gave to our virtual machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If you are not able to use the preceding keyboard combinations, there is a dedicated
    command for changing virtual terminals. The command is called `chvt` and has the
    syntax `chvt N`. Even though we have not discussed shell commands yet, we will
    show you an example of how to use them and other related commands. This action
    can only be performed by an administrator account or by using `sudo`. Briefly,
    `sudo` stands for *superuser do* and allows any user to run programs with administrative
    privileges or with the privileges of another user (more details about this in
    [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will use Ubuntu to show you how to change virtual
    terminals. First, we will see which virtual terminal we are currently using to
    change it to another one without using the *Ctrl* + *Alt* + *Fn* keys.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The `who` command will show you information about the users currently logged
    in to the computer. In our case, as we are connected through SSH to our virtual
    machine, it will show that the user `packt` is currently using pseudo-terminal
    zero (`pts/0`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we were to run the same command in the console of the virtual machine directly,
    we would have the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It shows that the user is connected to both the virtual terminal 1 (`tty1`)
    and also through SSH from our host operating system to the virtual machine (`pts/0`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Now, by using the `chvt` command, we will show you how to change to the sixth
    virtual terminal. After running `sudo chvt 6`, you will be prompted to provide
    your password and immediately be switched to virtual terminal number six. Running
    `who` once more will show you all logged-in users and the virtual terminals they
    use. In our case will be `pts/0`, `tty2`, and `tty6`. Please take into consideration
    that your output could be different, as in different virtual terminal numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what types of shell connections are established, let us learn
    about the shell’s prompt in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The command-line prompt
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **command-line prompt** or **shell prompt** is the place where you type
    in the commands. Usually, the command prompt will show the username, hostname,
    present working directory, and a symbol that indicates the type of user running
    the shell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example from the Ubuntu 22.04.2 LTS Server edition (similar to Debian):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example from the Fedora 37 server (similar to Rocky Linux, RHEL,
    or AlmaLinux):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a short explanation of the prompt:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '`packt` is the name of the user currently logged in'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saturn` and `localhost` are the hostnames'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~` represents the home directory (it is called a tilde)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` shows that the user is a regular user (when you are logged in as an administrator,
    the sign changes into a hashtag, `#`)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, when using openSUSE, you will notice that the prompt is different than
    the ones in Ubuntu/Debian and Fedora/RHEL. The following is an example of the
    prompt while running the Leap 15.4 server edition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, there is no dollar sign (`$`) or hashtag (`#`), only a greater
    than sign (`>`). This might be confusing at first, but when you will use the root
    user, the sign will eventually change to the hashtag (`#`). The following is an
    example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s look at the shell command types next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Shell command types
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shells work with `type` command. For example, you can check what type of command
    `cd` (change directory) is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output shows that the `cd` command is an internal one, built inside the
    shell. If you are curious, you could find out the types of other commands that
    we will show you in the following sections by writing type in front of the command’s
    name. Let us see some more examples in the following image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Different types of commands in Linux](img/Figure_02.03_B19682.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Different types of commands in Linux
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know some of the types of Linux commands, let us dissect the command’s
    structure and learn about its components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the command structure
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already used some commands, but we did not explain the structure of
    a Linux command. We will do that now for you to be able to understand how to use
    commands. In a nutshell, Unix and Linux commands have the following form:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The command’s name
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command’s options
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command’s arguments
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the shell, you will have a general structure such as the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A suitable example would be the use of the `ls` command (`ls` comes from a *list*).
    This command is one of the most-used commands in Linux. It lists files and directories
    and can be used with both options and arguments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We can use `ls` in its simplest form, without options or arguments. It lists
    the contents of your present working directory (`pwd`). In our case, it is the
    home directory, indicated by the `~` tilde character in the shell’s prompt (see
    *Figure 2**.10*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ls` command with the `-l` option (lowercase L) uses a long listing format,
    giving you extra information about files and directories from your present working
    directory (`pwd`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Using the ls command with both options and attributes](img/Figure_02.04_B19682.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Using the ls command with both options and attributes
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used `ls -l ~/Documents/` to show the contents
    of the `~/Documents` directory. Shown here is a way to use the command with both
    options and attributes, without changing our present working directory to `~/Documents`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will show you how to use the manual pages available
    by default in Linux.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Consulting the manual
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any Linux system administrator’s best friend is the manual. Each command in
    Linux has a manual page that gives the user detailed information about its use,
    options, and attributes. If you know the command you want to learn more about,
    simply use the `man` command to explore. For the `ls` command, for example, you
    use `man ls`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The manual organizes its command information into different sections, with each
    section being named by convention to be the same on all distributions. Briefly,
    those sections are `name`, `synopsis`, `configuration`, `description`, `options`,
    `exit status`, `return value`, `errors`, `environment`, `files`, `versions`, `conforming
    to`, `notes`, `bugs`, `example`, `authors`, `copyright`, and `see also`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the manual pages, almost all commands in Linux have a `-help` option.
    You can use this for quick reference.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the `help` and `man` pages, you can check each command’s
    help or manual page. Try the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you use the manual, keep in mind that it is not a step-by-step how-to guide.
    It is technical documentation that might be confusing at first. Our advice is
    to use the `man` pages as much as you can. Before you search for anything on the
    internet, try to read the manual first. This will be a good exercise, and you
    will become proficient with Linux commands in no time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Consider the manual your friend, similar to the textbooks you used in high school
    or college. It will give you first-hand information when you most need it. If
    you take into consideration situations where outside internet access is limited,
    with no access to search engines, the built-in manual will be your best companion.
    Learn to use its powers to your advantage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will learn about the Linux filesystem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The Linux filesystem
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `/ (root)` filesystem and another the `/home` filesystem. Or, there can
    be just one that contains all filesystems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Generally, using one filesystem per partition is considered to be good practice
    by allowing for logical maintenance and management. As everything in Linux is
    a file, physical devices such as hard drives, DVD drives, USB devices, and floppy
    drives are treated as files too. In this section, you will learn about the directory
    structure, how to work with files, and some very useful editing techniques from
    the command line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Directory structure
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux uses a `` `/` ``) at the base of the filesystem. From that point, all
    the branches (directories) spread throughout the filesystem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The **Filesystem Hierarchy Standard** (**FHS**) defines the structure of Unix-like
    filesystems. However, Linux filesystems also contain some directories that aren’t
    yet defined by the standard.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Linux filesystem from the command line
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Feel free to explore the filesystem yourself by using the `tree` command. In
    Fedora Linux, it is already installed, but if you use Ubuntu, you will have to
    install it by using the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`tree`命令自由地探索文件系统。在Fedora Linux中，`tree`已预安装，但如果你使用Ubuntu，需要使用以下命令进行安装：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Do not be afraid to explore the filesystem, because no harm will be done just
    by looking around. You can use the `ls` command to list the contents of directories,
    but `tree` offers different graphics. The following image shows you the differences
    between the outputs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕探索文件系统，因为单纯浏览是不会造成任何损害的。你可以使用`ls`命令列出目录的内容，但`tree`提供了不同的图形化显示。以下图像展示了两者输出的区别：
- en: '![Figure 2.5 – Comparing the output of ls -la commands and tree -a commands](img/Figure_02.05_B19682.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 比较`ls -la`命令和`tree -a`命令的输出](img/Figure_02.05_B19682.jpg)'
- en: Figure 2.5 – Comparing the output of ls -la commands and tree -a commands
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 比较`ls -la`命令和`tree -a`命令的输出
- en: 'The `tree` command has different options available, and you can learn about
    them by using the manual. Let us use the `tree` command by invoking the `-L` option,
    which tells the command how many levels down to go, and the last attribute states
    which directory to start with. In our example, the command will go down one level,
    starting from the `root` directory, represented by the forward slash as an argument
    (see *Figure 2**.12*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`命令有不同的选项，你可以通过手册了解它们。我们将使用`tree`命令并调用`-L`选项，这告诉命令应该向下查看多少级目录，最后的属性则指定从哪个目录开始。在我们的示例中，命令将从`root`目录开始，向下查看一级，该目录由正斜杠作为参数表示（见*图
    2.12*）：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start exploring the directories from the structure by using the `tree` command,
    as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`tree`命令开始探索目录结构，如下所示：
- en: '![Figure 2.6 – The tree command with option and argument on Ubuntu](img/Figure_02.06_B19682.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 在Ubuntu上使用带选项和参数的`tree`命令](img/Figure_02.06_B19682.jpg)'
- en: Figure 2.6 – The tree command with option and argument on Ubuntu
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 在Ubuntu上使用带选项和参数的`tree`命令
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that some of the directories you are about to open will contain a large
    number of files and/or other directories, which will clutter your terminal window.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，某些你即将打开的目录中将包含大量文件和/或其他目录，这将使你的终端窗口变得杂乱无章。
- en: 'The following are the directories that exist on almost all versions of Linux.
    Here’s a quick overview of the Linux root filesystem:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几乎所有版本的Linux上都存在的目录。以下是Linux根文件系统的快速概览：
- en: '`/`: Root directory. The root for all other directories.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：根目录。所有其他目录的根目录。'
- en: '`/bin`: Essential command binaries. The place where binary programs are stored.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：必要的命令二进制文件。存储二进制程序的位置。'
- en: '`/boot`: Static files of the boot loader. The place where the kernel, bootloader,
    and `initramfs` are stored.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：引导加载程序的静态文件。存储内核、引导加载程序和`initramfs`的位置。'
- en: '`/dev`: Device files. Nodes to the device equipment, a kernel device list.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备文件。指向设备设备节点，是内核设备列表。'
- en: '`/etc`: Host-specific system configuration. Essential config files for the
    system, boot time loading scripts, `crontab`, `fstab` device storage tables, `passwd`
    user accounts file.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：特定主机的系统配置。系统的必要配置文件、启动时加载的脚本、`crontab`、`fstab`设备存储表、`passwd`用户帐户文件。'
- en: '`/home`: user Home directory. The place where the user’s files are stored.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`：用户的主目录。存储用户文件的位置。'
- en: '`/lib`: Essential shared libraries and kernel modules. Shared libraries are
    similar to **Dynamic Link Library** (**DLL**) files in Windows.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：必要的共享库和内核模块。共享库类似于Windows中的**动态链接库**（**DLL**）文件。'
- en: '`/media`: Mount point for removable media. For external devices and USB external
    media.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media`：可移动媒体的挂载点。用于外部设备和USB外部媒体。'
- en: '`/mnt`: Mount point for mounting a filesystem temporarily. Used for legacy
    systems.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt`：用于临时挂载文件系统的挂载点。用于旧版系统。'
- en: '`/opt`: Add-on application software packages. The place where *optional* software
    is installed.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/opt`：附加应用程序软件包。安装*可选*软件的位置。'
- en: '`/proc`: Virtual filesystem managed by the kernel. a special directory structure
    that contains files essential for the system.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：由内核管理的虚拟文件系统。一个包含系统所需文件的特殊目录结构。'
- en: '`/sbin`: Essential system binaries. Vital programs for the system’s operation.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：必要的系统二进制文件。系统运行所需的重要程序。'
- en: '`/srv`: Data for services provided by this system.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/srv`：本系统提供的服务的数据。'
- en: '`/tmp`: Temporary files.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：临时文件。'
- en: '`/usr`: Secondary hierarchy. The largest directory in Linux that contains support
    files for regular system users:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：次级层级。Linux 中最大的目录，包含普通系统用户所需的支持文件：'
- en: '`/usr/bin` – system-executable files'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/bin` – 系统可执行文件'
- en: '`/usr/lib` – shared libraries from `/usr/bin`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/lib` – 来自 `/usr/bin` 的共享库'
- en: '`/usr/local` – source compiled programs not included in the distribution'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/local` – 源代码编译的程序，不包括在发行版中'
- en: '`/usr/sbin` – specific system administration programs'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/sbin` – 特定的系统管理程序'
- en: '`/usr/share` – data shared by the programs in `/usr/bin` such as config files,
    icons, wallpapers or sound files'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share` – 程序在 `/usr/bin` 中共享的数据，例如配置文件、图标、壁纸或音频文件'
- en: '`/usr/share/doc` – documentation for the system-wide files'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share/doc` – 系统范围文件的文档'
- en: '`/var`: Variable data. Only data that is modifiable by the user is stored here,
    such as databases, printing spool files, user mail, and others; `/var/log` – contains
    log files that register system activity'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：可变数据。只有用户可修改的数据存储在这里，例如数据库、打印缓存文件、用户邮件等；`/var/log` – 包含记录系统活动的日志文件'
- en: Next, we’re going to learn how to work with these files and directories.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何操作这些文件和目录。
- en: Working with files and directories
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件和目录
- en: Remember that everything in Linux is a file. A directory is a file too. As such,
    it is essential to know how to work with them. Working with files in Linux implies
    the use of several commands for basic file and directory operations, file viewing,
    file creation, file location, file properties, and linking. Some of the commands,
    which will not be covered here, have uses closely related to files. These will
    be covered in the following section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Linux 中一切都是文件。目录也是文件。因此，了解如何操作它们是至关重要的。在 Linux 中操作文件意味着使用多个命令来执行基本的文件和目录操作，如文件查看、文件创建、文件定位、文件属性和链接。一些命令虽然在此不会详细介绍，但与文件密切相关，接下来的章节将涵盖它们。
- en: Understanding file paths
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件路径
- en: Each file in the FHS has a *path*. The path is the file’s location represented
    in an easily readable representation. In Linux, all the files are stored in the
    root directory by using the FHS as a standard to organize them. Relations between
    files and directories inside this system are expressed through the forward-slash
    character (`/`). Throughout computing history, this was used as a symbol that
    described addresses. Paths are, in fact, addresses for files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: FHS 中的每个文件都有一个*路径*。路径是文件位置的易读表示。在 Linux 中，所有文件都存储在根目录下，使用 FHS 作为标准来组织它们。系统内文件和目录之间的关系通过正斜杠字符（`/`）表示。在计算机历史上，正斜杠被用作描述地址的符号。路径实际上是文件的地址。
- en: There are two types of paths in Linux, relative ones and absolute ones. An **absolute
    path** always starts with the root directory and follows the branches of the system
    up to the desired file. A **relative path** always refers to the **present working
    directory** (**pwd**) and represents the relative path to it. Thus, a relative
    path is always a path that is relative to your present working directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中有两种路径类型，相对路径和绝对路径。**绝对路径**总是以根目录开始，并沿着系统的分支直到所需的文件。**相对路径**总是指向**当前工作目录**（**pwd**），并表示到该目录的相对路径。因此，相对路径总是相对于当前工作目录的路径。
- en: 'For example, let us refer to an existing file from our home directory, a file
    called `poem`. Being inside the home directory, and our `pwd` command being the
    `home` directory for `packt`, the absolute path of the file called `poem` would
    be as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们从主目录引用一个现有的文件，名为 `poem`。如果我们在主目录内，并且 `pwd` 命令显示为 `packt` 的主目录，那么名为 `poem`
    的文件的绝对路径将如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we were to show the contents of that file using the `cat` command, for example,
    we would use the command with the absolute path:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 `cat` 命令查看该文件的内容，例如，我们可以使用带有绝对路径的命令：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The relative path to the same file would be relative to `pwd`, so in our case,
    where we’re already inside the home directory, using the `cat` command would be
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个文件的相对路径是相对于 `pwd` 的，因此在我们的例子中，如果我们已经在主目录内，使用 `cat` 命令将是这样的：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The absolute path is useful to know about when you work with files. After some
    practice, you will come to learn the paths to the most-used files. For example,
    one file that you will need to learn the path for is the `passwd` file. It resides
    in the `/etc` directory. Thus, when you will refer to it, you will use its absolute
    path, `/etc/passwd`. Using a relative path to that file would imply that you are
    either inside its parent directory or somewhere close in the FHS.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Working with relative paths involves knowing two special characters used to
    work with the FHS. One special character is the dot (`.`), and it refers to the
    current directory. The other is two consecutive dots (`..`) and refers to the
    parent directory of the current directory. When working with relative paths, make
    sure that you always check what directory you are in. Use the `pwd` command to
    show your present working directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of working with relative paths is when you are already inside
    the parent directory and need to refer to it. If you need to see the accounts
    list from your system, which is stored inside the `passwd` file, you can refer
    to it by using a relative path. For this exercise, we are inside our home directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Using the relative path of a file](img/Figure_02.07_B19682.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Using the relative path of a file
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Here, we first check our present working directory with the `pwd` command, and
    the output will be our home directory’s path, `/home/packt`. Secondly, we try
    to show the contents of the `passwd` file using the `cat` command right from the
    home directory, but the output will be an error message saying that there is no
    such file or directory inside our home directory. We used the relative path, which
    is always relative to our present working directory, hence the error. Thirdly,
    we use the double-consecutive dots special characters to refer to the file with
    its relative path. In this case, the command is `cat ../../etc/passwd`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Always use the *Tab* key on your keyboard for autocompletion and to check whether
    the path you typed is correct or not. In the preceding example, we typed `../../etc`
    and pressed *Tab*, which autocompleted with a forward slash. Then, we typed the
    first two letters of the file we were looking for and pressed *Tab* again. This
    showed us a list of files inside the `/etc` directory that started with `pa`.
    Seeing that `passwd` was in there, we knew that the path was right, so we typed
    two more `s` characters and pressed *Tab* again. This completed the command for
    us and we pressed *Enter*/*Return* to execute the command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'The path in the final command is relative to our home directory and it translates
    as follows: *concatenate the file with the* `passwd` *name that is located in
    the* `/etc` *directory in the parent directory (first two dots) of the parent
    directory (second two dots) of our current directory (home)*. Therefore, the `/etc/passwd`
    absolute path is translated into a relative path to our home directory like this:
    `../../etc/passwd`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to learn about basic file operations in Linux.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Basic file operations
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Daily, as a system administrator, you will manipulate files. This includes creating,
    copying, moving, listing, deleting, linking, and so on. The basic commands for
    these operations have already been discussed throughout this chapter, but now
    it is time to get into more detail about their use, options, and attributes. Some
    more advanced commands will be detailed in the following sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Creating files
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are situations when you will need to `touch` command. When you use it,
    it will create a new file with you as the file owner and with a size of zero,
    because it is an empty file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we create a new file called `new-report` inside the
    `~/``packt/` directory:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Using the touch command to create and alter files](img/Figure_02.08_B19682.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Using the touch command to create and alter files
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The `touch` command is also used to change the modification time of a file
    without changing the file itself. Notice the difference between the initial time
    when we first created the `new-report` file and the new time after using the `touch`
    command on it. You can also change the access time by using the `-a` option of
    the `touch` command. By default, the long listing of the `ls` command shows only
    the modification/creation time. If you want to see the access time, there is the
    `atime` parameter you can use with the `- time` option. See the example used in
    the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Using touch to alter the access time](img/Figure_02.09_B19682.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Using touch to alter the access time
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The modification, creation, and access time stamps are very useful, especially
    when using commands such as `find`. They give you a more *granular* search pattern.
    We will get back to this command with more examples in future sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Files can also be created by using redirection and the `echo` command. `echo`
    is a command that prints the string given as a parameter to the standard output
    (the screen). The output of the `echo` command can be written directly to a file
    by using the output redirection:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Using echo with output redirection](img/Figure_02.10_B19682.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Using echo with output redirection
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we redirected the text from the `echo` command to
    the presentation file. It did not exist at the beginning, so it was automatically
    created by the command. The first `echo` command added a line to the file by using
    the `>` operator. The second `echo` command appended a new line of text to the
    end of the file, by using the `>>` operator.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Listing files
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already used some examples with the `ls` command before, so you are
    somewhat familiar with it. We covered the `-l` option as an example of the command’s
    structure. Thus, we will not cover it any further here. We will explore new options
    for this essential and useful command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '`ls -lh`: The `-l` option lists the files in an extended format, while the
    `-h` option shows the size of the file in a human-readable format, with the size
    in kilobytes or megabytes rather than bytes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -la`: The `-a` option shows all the files, including hidden ones. Combined
    with the `-l` option, the output will be a list of all the files and their details.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -ltr`: The `-t` option sorts files by their modification time, showing
    the newest first. The `-r` option reverses the order of the sort.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls – lS`: The `-S` option sorts the files by their size, with the largest
    file first.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ls -R`: The `-R` option shows the contents of the current or specified directory
    in recursive mode.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method used frequently for listing files and directories is called `ls -la`
    command. Let’s look at it in detail here, even though we will discuss this thoroughly
    in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of a long listing used on our home directory can be seen in *Figure
    2**.11*, when we compared the output of `ls -la` with the output of the `tree`
    command. The following code snippet is a short example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the output, the first row after the command shows the number of blocks inside
    the directory listed. After that, each line represents one file or subdirectory,
    with the following detailed information:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character is the type of the file: `d` for the directory, `:` for
    the file, `l` for a link, `c` for the character device, and `b` for the block
    device'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following nine characters represent the permissions (detailed in [*Chapter
    4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hard link for that file (see the *Working with links* subsection in this
    chapter)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The owner’s PID and GID (details in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing Users* *and Groups*)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the file (the number depends on whether it is in human-readable
    format or not)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last modification time of the file
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the file or directory
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two lines are a reference to itself (the dot) and to the parent directory
    (the two dots from the second line).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The next section will teach you how to copy and move files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Copying and moving files
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To copy files in Linux, the `cp` command is used. The `mv` command moves files
    around the filesystem. This command is also used to rename files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy a file, you can use the `cp` command in the simplest way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `source_file_path` is the name of the file to be copied, and `destination_file_path`
    is the name of the destination file. You can also copy multiple files inside a
    directory that already exists. If the destination directory does not exist, the
    shell will signal to you that the target is not a directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at some variations of these commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`cp -a`: The `-a` option copies an entire directory hierarchy in recursive
    mode by preserving all the attributes and links. In the following example, we
    copied the entire `dir1` directory that we previously created inside our home
    directory, to a newly created directory called `backup_dir1` by using the `-``a`
    option:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Using the copy command with the -a option](img/Figure_02.11_B19682.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Using the copy command with the -a option
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '`cp -r`: This option is similar to `-a`, but it does not preserve attributes,
    only symbolic links.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp -p`: The `-p` option retains the file’s permissions and timestamps. Otherwise,
    just by using `cp` in its simplest form, copies of the files will be owned by
    your user with a timestamp of the time you did the copy operation.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp -R`: The `-R` option allows you to copy a directory recursively. In the
    following example, we will use the `ls` command to show you the contents of the
    `~/packt/` directory, and then the `cp -R` command to copy the contents of the
    `/files` directory to the `/new-files` one. The `/new-files` directory did not
    exist. The `cp -R` command created it:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Using the cp -R command](img/Figure_02.12_B19682.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Using the cp -R command
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving files around is done with the `mv` command. It is either used to move
    files and directories from one destination to another or to rename a file. The
    following is an example in which we rename `files1` into `old-files1` using the
    `mv` command: `mv` `files1 old-files1`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: There are many other options that you could learn about just by visiting the
    manual pages. Feel free to explore them and use them in your daily tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Working with links
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Links are a compelling option in Linux. They can be used as a means of protection
    for the original files, or just as a tool to keep multiple copies of a file without
    having separate hard copies. Consider it as a tool to create alternative names
    for the same file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ln` command can be used to do this and create two types of links:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hard links
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those two links are different types of files that point to the original file.
    A **symbolic link** is a physical file that points to the original file; they
    are linked and have the same content. Also, it can span different filesystems
    and physical media, meaning that it can link to original files that are on other
    drives or partitions with different types of filesystems. The command used is
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is an example in which we listed the contents of the `~/packt` directory
    and then created a symbolic link to the `new-report` file using the `ln -s` command
    and then listed the contents again:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Using symbolic links](img/Figure_02.13_B19682.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Using symbolic links
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the link created is named `new-report-link` and is visually
    represented with an `->` arrow that shows the original file that it points to.
    You can also distinguish the difference in size between the two files, the link
    and the original one. The permissions are different too. This is a way to know
    that they are two *different* physical files. To double-check that they are different
    physical files, you can use the `ls -i` command to show the `new-report` and `new-report-link`
    have different inodes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Comparing the inodes for the symbolic link and original file](img/Figure_02.14_B19682.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Comparing the inodes for the symbolic link and original file
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know where the link points to and you do not want to use `ls
    -l`, there is the `readlink` command. It is available in both Ubuntu and CentOS.
    The output of the command will simply be the name of the file that the symbolic
    link points to. It only works in the case of symbolic links:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, you can see that the output shows that the `new-report-link`
    file is a symbolic link to the file named `new-report`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, a `ln` without any options:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following example, we created a hard link for the `new-report` file,
    and we named it `new-report-ln`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Working with hard links](img/Figure_02.15_B19682.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Working with hard links
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In the output, you will see that they have the same size and the same inode,
    and after altering the original file using `echo` and output redirection, the
    changes were available to both files. The two files have a different representation
    than symbolic links. They appear as two different files in your listing, with
    no visual aids to show which file is pointed to. Essentially, a hard link is linked
    to the inode of the original file. You can see it as a new name for a file, similar
    to but not identical to renaming it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Linux, you have the remove (`rm`) command for deleting files. In its simplest
    form, the `rm` command is used without an option. For more control over how you
    delete items, you could use the `-i`, `-f`, and `-``r` options:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`rm -i`: This option enables interactive mode by asking you for acceptance
    before deleting:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Removing a file interactively](img/Figure_02.16_B19682.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Removing a file interactively
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we deleted `art-file` by using the `-i` option. When
    asked to interact, you have two options. You can approve the action by typing
    `y` (yes), or `n` (no) to cancel the action.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '`rm -f` : The `-f` option deletes the file by force, without any interaction
    from the user:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Force remove a file](img/Figure_02.17_B19682.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Force remove a file
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We deleted the `new-report-link` file created earlier by using the `rm -f` command.
    It did not ask for our approval and deleted the file directly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`rm -r`: This option deletes the files in recursive mode, and it is used to
    delete multiple files and directories. For example, we will try to delete the
    `new-files` directory. When using the `rm` command in its simplest way, the output
    will show an error saying that it cannot delete a directory. But when used with
    the `-r` option, the directory is deleted right away:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Remove a directory recursively](img/Figure_02.18_B19682.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Remove a directory recursively
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: We advise *extra caution* when using the `rm` command. The most destructive
    mode is to use `rm -rf`. This will delete files, directories, and anything without
    warning. Pay attention as there is no going back from this. Once used, the damage
    will be done.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, removing files is a one-way street, with no turning back.
    This makes the process of deleting files a very important one, and a backup before
    a deletion could save you a lot of unnecessary stress.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Creating directories
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Linux, you can create a new directory with the `mkdir` command. In the following
    example, we will create a new directory called `development`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you want to create more directories and sub-directories at once, you will
    need to use the `-p` option (`p` from the parent), as shown in the following figure:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Creating parent directories](img/Figure_02.19_B19682.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: Figure 2.19 – Creating parent directories
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Directories are files too in Linux, only that they have special attributes.
    They are essential to organizing your filesystem. For more options with this useful
    tool, feel free to visit the manual pages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Deleting directories
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Linux command for removing directories is called `rmdir`. It is designed
    to default by deleting only empty directories. Let’s see what happens if we try
    to delete a directory that is not empty:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Using the rmdir command](img/Figure_02.20_B19682.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Figure 2.20 – Using the rmdir command
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: This is a precautionary measure from the shell, as deleting a directory that
    is not empty could have disastrous consequences, as we’ve seen when using the
    `rm` command. The `rmdir` command does not have a `-i` option such as `rm`. The
    only way to delete the directory using the `rmdir` command is to delete files
    inside it first manually. However, the `rm -r` command shown earlier is still
    useful and more versatile when deleting directories.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to work with directories in Linux, we will proceed to
    show you commands for file viewing.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Commands for file viewing
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As everything in Linux is a file, being able to view and work with file contents
    is an essential asset for any system administrator. In this section, we will learn
    commands for file viewing, as almost all files contain text that, at some point,
    should be readable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The cat command
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This command was used in some of our previous examples in this chapter. It
    is short for *concatenate* and is used to print the contents of the file to the
    screen. We have used `cat` several times during this chapter, but here is yet
    another example. We have two existing files, one called `new-report` and the other
    called `users`. Let us show you how to use `cat` in the following image:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Example of using the cat command](img/Figure_02.21_B19682.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 2.21 – Example of using the cat command
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we first used the command to show the contents of only one
    file, the one called `new-report`. The second command was used to show the contents
    of two files at once, both `new-report` and `users`. The `cat` command is showing
    the contents of both on the screen. Both files are located in the same directory,
    which is also the user’s working directory. If you would like to concatenate the
    contents of files that are not inside your present working directory, you would
    need to use their absolute path.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` command has several options available, which we will not cover here,
    as most of the time, its purest form will be the most used. For more details,
    see the manual pages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The less command
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when a file has so much text that it will cover many screens,
    and it will be difficult to view on your terminal using just `cat`. This is where
    the `less` command is handy. It shows one screen at a time. How much a screen
    means, it all depends on the size of your terminal window. Let’s take, for example,
    the `/etc/passwd` file. It could have multiple lines that you would not be able
    to fit in just one screen. You could use the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you press *Enter*, the contents of the file will be shown on your screen.
    To navigate through it, you could use the following keys:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Space bar: Move forward one screen'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Enter*: Move forward one line'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*b*: Move backward one screen'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/*: Enter search mode; this searches forward in your file'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*?*: Search mode; this searches backward in your file'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*v*: Edit your file with the default editor'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*g*: Jump to the beginning of the file'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift* + *g*: Jump to the end of the file'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*q*: Exit the output.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `less` command has a multitude of options that could be used. We advise
    you to consult the manual pages to find out more information about this command.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The head command
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This command is handy when you only want to print to the screen the beginning
    (the head) of a text file. By default, it will print only the first 10 lines of
    the file. You can use the same `/etc/passwd` file for the head exercise and execute
    the following command. Watch what happens. It prints the first 10 lines and then
    exits the command, taking you back to the shell prompt:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One useful option of this command is to print more or less than 10 lines of
    the file. For this, you can use the `-n` argument or simply just `–` with the
    number of lines you want to print. For the `/etc/passwd` file, we will first use
    the head command without any options, and then we will use it with the number
    of lines argument, as shown in the following figure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Using the head command](img/Figure_02.22_B19682.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: Figure 2.22 – Using the head command
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Many other options that this command provides can prove useful for your work
    as a system administrator, but we will not cover them here. Feel free to explore
    them yourself.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The tail command
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `tail` command is similar to the `head` command, only it prints the last
    10 lines of a file, by default. You can use the same `-n` argument as for the
    head command, to see a specific number of lines from the end of a file. However,
    the `tail` command is commonly used for actively watching log files that are constantly
    changing. It can print the last lines of the file as other applications are writing
    to it. Take, for example, the following line:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the `-f` option will make the command watch the `/var/log/syslog` file
    as it is being written. It will show you the contents of the file on the screen
    effectively. The `-f` option will cause the tail command to stop during a log
    rotation, and in this case, the `-F` option should be used instead. When using
    the `-F` option, the command will continue to show the output even during a log
    rotation. To exit that screen, you will need to press *Ctrl* + *C* to go back
    to the shell prompt. The following is an example of the output of the previous
    command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The use of tail command for real-time log  file observation](img/Figure_02.23_B19682.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Figure 2.23 – The use of tail command for real-time log file observation
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us learn how to view file properties in Linux.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Commands for file properties
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There could be times when just viewing the contents of a file is not enough,
    and you need extra information about that file. There are other handy commands
    that you could use, and we describe them in the following sections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The stat command
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `stat` command gives you more information than the `ls` command does. The
    example in the following figure shows a comparison between the `ls` and `stat`
    outputs for the same file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Using the stat command](img/Figure_02.24_B19682.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
- en: Figure 2.24 – Using the stat command
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The `stat` command gives you more information about the name, size, number of
    blocks, type of file, inode, number of links, permissions, UID and GID, and `atime`,
    `mtime`, and `ctime`. To find out more information about it, please refer to the
    Linux manual pages.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: The file command
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This command simply reports on the type of file. Here is an example of a text
    file and a command file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Using the file command](img/Figure_02.25_B19682.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: Figure 2.25 – Using the file command
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Linux does not rely on file extensions and types as some other operating systems
    do. In this respect, the `file` command determines the file type more by its contents
    than anything else.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Commands for configuring file ownership and permissions
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux, `chown` command. When setting up group ownership, you determine the
    permissions for everyone in that group. This is set up using the `chgrp` command.
    When it comes to other users, the reference is to everyone else on that system,
    someone who did not create the file, so it is not the owner, and who does not
    belong to the owner’s group. Other is also known as, or referred to as the world.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides setting user ownership, the system must know how to determine user
    behavior, and it does that through the use of `ls -``l` command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Long listing output](img/Figure_02.26_B19682.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure 2.26 – Long listing output
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, you see two different types of permissions for the
    files inside our home directory. Each line has 12 characters reserved for special
    attributes and permissions. Out of those 12, only 10 are used in the preceding
    examples. Nine of them represent the permissions, and the first one is the file
    type. There are three easy-to-remember abbreviations for permissions:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '`r` is for `read` permission'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` is for `write` permission'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` is for `execute` permission'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` is for no permission'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nine characters are divided into three regions, each consisting of three
    characters. The first three characters are reserved for user permissions, the
    following three characters are reserved for group permissions, and the last three
    characters represent other, or global permissions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'File types also have their codes, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`d`: The letter `d` shows that it is a directory'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: The hyphen shows that it is a file'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`l`: The letter `l` shows that it is a symbolic link'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: The letter `p` shows that it is a named pipe; a special file that facilitates
    the communication between programs'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: The letter `s` shows that it is a socket, similar to the pipe but with
    bi-directional and network communications'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: The letter `b` shows that it is a block device; a file that corresponds
    to a hardware device'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: The letter `c` shows that it is a character device; similar to a block
    device'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The permission string is a 10-bit string. The first bit is reserved for the
    file type. The next nine bits determine the permissions by dividing them into
    3-bit packets. Each packet is expressed by an **octal number** (because an octal
    number has three bytes). Thus, permissions are represented using a power of two:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '`read` is 2 ^ 2 (two to the power of two), which equals 4'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write` is 2 ^ 1 (two to the power of one), which equals 2'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute` is 2 ^ 0 (two to the power of zero), which equals 1'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this respect, file permissions should be represented according to the following
    diagram:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – File permissions explained](img/Figure_02.27_B19682.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: Figure 2.27 – File permissions explained
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you have the permissions shown as a string of nine
    characters, just like you would see them in the `ls -la` output. The row is divided
    into three different sections, one for owner/user, one for group, and one for
    other/world. These are shown in the first two rows. The other two rows show you
    the types of permissions (`read`, `write`, and `execute`) and the octal numbers
    in the following paragraph.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This is useful as it relates the octal representations to the character representations
    of permissions. Thus, if you were to translate a permission shown as `rwx r-x`
    into octal, based on the preceding diagram, you could easily say it is `755`.
    This is because, for the first group, the owner, you have all of them active (`rwx`),
    which translates into *4+2+1=7*. For the second group, you have only two permissions
    active, `r` and `x`, which translates into *4+1=5*. Finally, for the last group,
    you have also two permissions active, similar to the second group (`r` and `x`),
    which translates to *4+1=5*. Now you know that the permission in the octal is
    `755`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, you should try to translate into octal the following permissions:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '`rwx rwx`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwx r-x`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwx r-x - - -`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rwx - - - - - -`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw-` `rw- rw-`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw- rw- r - -`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw- rw- - - -`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw- r- -` `r- -`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw- r- - - - -`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw- - - - - - -`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r - - - - - - - -`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: There are some other vital commands such as `umask`, `chown`, `chmod`, and `chgrp`,
    which are used to change or set the default creation mode, owner, mode (access
    permissions), and group, respectively. They will be briefly introduced here as
    they involve setting the file’s properties, but for a more detailed description,
    please refer to [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users*
    *and Groups*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Commands for file compression, uncompression, and archiving
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Linux, the standard tool for archiving is called `tar`, from tape archive.
    It was initially used in Unix to write files to external tape devices for archiving.
    Nowadays, in Linux, it is also used to write to a file in a compressed format.
    Other popular formats, apart from `tar` archives, are `gzip` and `bzip` for compressed
    archives, together with the popular `zip` from Windows. Now let’s look at the
    `tar` command in detail.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The tar command for compressing and un-compressing
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This command is used with options and does not offer compression by default.
    To use compression, we would need to use specific options. Here are some of the
    most useful arguments available for `tar`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '`tar -c`: Creates an archive'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -r`: Appends files to an already existing archive'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -u`: Appends only changed files to an existing archive'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -A`: Appends an archive to the end of another archive'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -t`: Lists the contents of the archive'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -x`: Extracts the archive contents'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -z`: Uses `gzip` compression for the archive'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -j`: Uses `bzip2` compression for the archive'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -v`: Uses verbose mode by printing extra information on the screen'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -p`: Restores original permission and ownership for the extracted files'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tar -f`: Specifies the name of the output file'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a chance that in your daily tasks, you will have to use these arguments
    in combination with each other.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create an archive of the `files` directory, we used the `-cvf`
    arguments combined, as shown here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Using the tar command](img/Figure_02.28_B19682.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
- en: Figure 2.28 – Using the tar command
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'The archive created is not compressed. To use compression, we would need to
    add the `-z` or `-j` arguments. Next, we will use the `-z` option for the `gzip`
    compression algorithm. See the following example and compare the size of the two
    archive files. As a general rule, it is advised to use an extension for such files:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Compressing a tar archive using gzip](img/Figure_02.29_B19682.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Figure 2.29 – Compressing a tar archive using gzip
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'To uncompress a tar archive, you can use the `-x` option (shown at the beginning
    of this subsection). For example, let us uncompress the `files-archive.tar` file
    that we created earlier in this subsection, and also add a target directory for
    the uncompressed files to be added to by using the `-C` option. The target directory
    needs to be created beforehand. To do this, we will use the following commands:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will extract the files from the archive and add them to the uncompressed-directory
    directory. To uncompress a `gzip`-compressed archive, for example, `files-archive-gzipped.tar.gz`,
    we will add the `-z` option to the ones already used in the previous command,
    as shown in the following snippet:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There you go, now you know how to archive and unarchive files in Linux. There
    are other useful archiving tools in Linux, but `tar` is still the most commonly
    used one. Feel free to explore the others or other useful options for `tar`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Commands for locating files
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Locating files in Linux is an essential task for any system administrator. As
    Linux systems contain vast numbers of files, finding files might be an intimidating
    task. Nevertheless, you have handy tools at your disposal, and knowing how to
    use them will be one of your greatest assets. Among these commands, we will discuss
    `locate`, `which`, `whereis`, and `find` in the following sections.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The locate command
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `locate` command is not installed by default on Ubuntu. To install it,
    use the following command to create an index of all the file locations on your
    system:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Thus, when you execute the command, it searches for your file inside the database.
    It uses the `updatedb` command as its partner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to use the locate command, you should execute `updatedb` to
    update the location database. After you do that, you can start locating files.
    In the following example, we will locate any file that has `new-report` in its
    name:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – Using the locate command](img/Figure_02.30_B19682.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: Figure 2.30 – Using the locate command
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to search for a file with a more generic name, such as `presentation`,
    the output would be too long and irrelevant. Here is an example where we used
    output redirection to a file and the `wc` (word count) command to show only the
    number of lines, words, and bytes of the file to the standard output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – Using the locate command with output redirection and the wc
    command](img/Figure_02.31_B19682.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: Figure 2.31 – Using the locate command with output redirection and the wc command
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, the resulting file has eight lines. This means that
    there were eight files located that have the string `presentation` in their name.
    The exact number is used for the words inside the file, as there are no spaces
    between the paths, so every line is detected as a single word. Also, the resulting
    file has 663 bytes. Feel free to experiment with other strings. For more options
    for the `locate` command, please refer to the Linux manual pages.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The which command
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This command locates an executable file (program or command) in the shell’s
    search path. For example, to locate the `ls` command, type the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You see that the output is the path of the `ls` command: `/usr/bin/ls`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try it with the `cd` command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will see that there is no output. This is because the `cd` command is built
    inside the shell and has no other location for the command to show.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The whereis command
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This command finds *only* executable files, documentation files, and source
    code files. Therefore, it might not find what you want, so use it with caution:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – Using the whereis command](img/Figure_02.32_B19682.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: Figure 2.32 – Using the whereis command
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the output for the `cd` command shows nothing relevant, as it is
    a built-in shell command. As for the `ls` command, the output shows the location
    of the command itself and the location of the manual pages.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: The find command
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This command is one of the most powerful commands in Linux. It can search for
    files in directories and subdirectories based on certain criteria. It has more
    than 50 options. Its main drawback is the syntax, as it is somehow different from
    other Linux commands. The best way to learn how the `find` command works is by
    example. This is why we will show you a large number of examples using this command,
    hoping that you will become proficient in using it. To see its powerful options,
    please refer to the manual pages.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: The following is a series of exercises using the `find` command, that we thought
    would be useful for you to know. We will provide the commands to use, but we will
    not provide you with all the resulting outputs, as some can be fairly long.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Find, inside the root directory, all the files that have the `e100` string
    in the name and print them to the standard output:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Find, inside the root directory, all the files that have the `file` string
    in their name and are of type `file`, and print the results to the standard output:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Find all the files that have the `print` string in their name, by looking only
    inside the `/opt`, `/usr`, and `/``var` directories:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find all the files in the root directory that have the `.``conf` extension:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Find all the files in the root directory that have the `file` string in their
    name and no extension:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Find, in the root directory, all the files with the following extensions: `.c`,
    `.sh`, and `.py`, and add the list to a file named `findfile`:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Find, in the root directory, all the files with the `.c` extension, sort them,
    and add them to a file:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Find all the files in the root directory, with the permission set to `0664`:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Find all the files in the root directory that are read-only (have read-only
    permission) for their owner:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find all the files in the root directory that are executable:'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Find all the files inside the root directory that were modified two days ago:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Find all the files in the root directory that have been accessed in the last
    two days:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Find all the files that have been modified in the last two to five days:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Find all the files that have been modified in the last 10 minutes:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Find all the files that have been created in the last 10 minutes:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Find all the files that have been accessed in the last 10 minutes:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Find all the files that are 5 MB in size:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Find all the files that have a size between 5 and 10 MB:'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Find all the empty files and empty directories:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Find all the largest files in the `/etc` directory and print to the standard
    output the first five. Please take into account that this command could be very
    resource heavy. Do not try to do this for your entire root directory, as you might
    run out of system memory:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Find the smallest first five files in `/``etc` directory:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Feel free to experiment with as many types of find options as you want. The
    command is very permissive and powerful. Use it with caution.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Commands for text manipulation
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`grep`, `tee`, and the more powerful ones such as `sed` and `awk`. However,
    we will come back to those commands in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164),
    when we will show you how to create and use scripts. In this section, we will
    only give you a hint on how to use them on the command line.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: The grep command
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is one of the most powerful commands in Linux. It is also an extremely
    useful one. It has the power to search for strings inside text files. It has many
    powerful options too:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '`grep -v`: Show the lines that are not according to the search criteria'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -l`: Show only the filenames that match the criteria'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -L`: Show only the lines that do *not* comply with the criteria'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -c`: A counter that shows the number of lines matching the criteria'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -n`: Show the line number where the string was found'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -i`: Searches are case insensitive'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -r`: Search recursively inside a directory structure'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -R`: Search recursively inside a directory structure *AND* follow all
    symbolic links'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -E`: Use extended regular expressions'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep -F`: Use a strict list of strings instead of regular expressions'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of how to use the `grep` command:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Find out the last time the `sudo` command was used:'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Search for the `packt` string inside text files from the `/``etc` directory:'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Show the exact line where the match was found:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you don’t want to see the filename of each file where the match was found,
    use the `-h` option. Then, `grep` will only show you the lines where the match
    was found:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To show only the name of the file where the match was found, use `-l`:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Most likely, `grep` will be used in combination with shell pipes. Here are
    some examples:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see only the directories from your current working directory,
    you could pipe the `ls` command output to `grep`. In the following example, we
    listed only the lines that start with the letter `d`, which represent directories:'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you want to display the model of your CPU, you could use the following command:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will find `grep` to be one of your closest friends as a Linux system administrator,
    so don’t be afraid to dig deeper into its options and hidden gems.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The tee command
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This command is very similar to the `cat` command. Basically, it does the same
    thing, by copying the standard input to standard output with no alteration, but
    it also copies that into one or more files.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use the `wc` command to count the number of lines
    inside the `/etc/passwd/` file. We pipe the output to the `tee` command using
    the `-a` option (append if the file already exists), which writes it to a new
    file called `no-users` and prints it to the standard output at the same time.
    We then use the `cat` command to double-check the contents of the new file:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33 – Using the tee command](img/Figure_02.33_B19682.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
- en: Figure 2.33 – Using the tee command
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: The `tee` command is more of an underdog of file-manipulating commands. While
    it is quite powerful, its use can easily be overlooked. Nevertheless, we encourage
    you to use its powers as often as you can.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will show you how to use text editors from the
    command line in Linux.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Using text editors to create and edit files
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux has several command-line text editors that you can use. There are **nano**,
    **Emacs**, and **Vim**, among others. Those are the most used ones. There are
    also **Pico**, **JOE**, and **ed** as text editors that are less frequently used
    than the aforementioned ones. We will cover Vim, as there is a very good chance
    that you will find it on any Linux system that you work with. Nevertheless, the
    current trend is to replace Vim with nano as the default text editor. Ubuntu,
    for example, does not have Vim installed by default, but CentOS does. Fedora is
    currently looking to make nano the default text editor. Therefore, you might want
    to learn nano, but for legacy purposes, Vim is a very useful tool to know.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Using Vim to edit text files
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Vim** is the improved version of **vi**, the default text editor from Unix.
    It is a very powerful editing tool. This power comes with many options that can
    be used to ease your work, and this can be overwhelming. In this sub-section,
    we will introduce you to the basic commands of the text editor, just enough to
    help you be comfortable using it.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Vim is a mode-based editor, as its operation is organized around different
    modes. In a nutshell, those modes are as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '`command` mode is the default mode, waiting for a command'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert` mode is the text insert mode'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace` mode is the text replace mode'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search` mode is the special mode for searching a document'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see how we can switch between these modes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Switching between modes
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you first open Vim, you will be introduced to an empty editor that only
    shows information about the version used and a few help commands. You are in `command`
    mode. This means that Vim is waiting for a command to operate.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: To activate `insert` mode, press *I* on your keyboard. You will be able to start
    inserting text at the current position of your cursor. You can also press *A*
    (for append) to start editing to the right of your cursor’s position. Both *I*
    and *A* will activate `insert` mode. To exit the current mode, press the *Esc*
    key. It will get you back to `command` mode.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: If you open a file that already has text in it, while in `command` mode, you
    can navigate the file using your arrow keys. As Vim inherited the vi workflow,
    you can also use *H* (to move left), *J* (to move down), *K* (to move up), and
    *L* (to move right). Those are legacy keys from a time when terminal keyboards
    did not have separate arrow keys.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: While still in `command` mode (the default mode), you can activate `replace`
    mode by pressing *R* on your keyboard. You can replace the character that is right
    at the position of your cursor.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: While in `command` mode, `search` mode is activated by pressing the */* key.
    Once in your mode, you can start typing a search string and then press *Enter*.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: There is also `last line` mode, or `ex command` mode. This mode is activated
    by pressing *:*. This is an extended mode where commands such as `w` for saving
    the file, `q` for quitting, or `wq` for saving and quitting at the same time.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Basic Vim commands
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with Vim implies that you are comfortable with using keyboard shortcuts
    for using basic commands. We will guide you to the Vim documentation page ([https://vimdoc.sourceforge.net/](https://vimdoc.sourceforge.net/))
    for all the commands available, and we will give you a quick glimpse of the most
    useful ones in the following image:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.34 – Basic Vim commands](img/Figure_02.34_B19682.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: Figure 2.34 – Basic Vim commands
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Vim can be quite intimidating for newcomers to Linux. There is no shame if you
    prefer other editors, as there are plenty to choose from. Now, we will show you
    a glimpse of nano.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The nano text editor
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vim is a powerful text editor and knowing how to use it is an important thing
    for any system administrator. Nevertheless, other text editors are equally powerful
    and even easier to use.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the case with `.bashrc` file by using the `$EDITOR` variable. However,
    in Ubuntu, you can check the default editor on your system by using the following
    command:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.35 – Checking the default text editor on Ubuntu](img/Figure_02.35_B19682.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
- en: Figure 2.35 – Checking the default text editor on Ubuntu
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: You can invoke the nano editor by using the `nano` command on Ubuntu/Debian
    and Fedora/Rocky Linux or openSUSE. When you type the command, the nano editor
    will open, with a very straightforward interface that can be easier to use than
    Vim or Emacs for example. Feel free to use your preferred text editor.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with the most commonly used commands
    in Linux. You now know how to manage (create, delete, copy, and move) files, how
    the filesystem is organized, how to work with directories, and how to view file
    contents. You now understand the shell and basic permissions. The skills you have
    learned will help you manage files in any Linux distribution and edit text files.
    You have learned how to work with Vim, one of the most widely used command-line
    text editors in Linux. Those skills will help you to learn how to use other text
    editors such as nano and Emacs. You will use these skills in almost every chapter
    of this book, as well as in your everyday job as a system administrator.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to manage packages, including how to
    install, remove, and query packages in both Debian and Red Hat-based distributions.
    This skill is important for any administrator and must be part of any basic training.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our second chapter, we covered the Linux filesystem and the basic commands
    that will serve as the foundation for the entire book. Here are some questions
    for you to test your knowledge and for further practice:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: What is the command that creates a compressed archive with all the files inside
    the `/etc` directory that use the `.``conf` extension?
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tar` command just as shown in this chapter.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: What is the command that lists the first five files inside `/etc` and sorts
    them by dimension in descending order?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`find` combined with `sort` and `head`.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: What command creates a hierarchical directory structure?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mkdir` just as shown in this chapter.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: What is the command that searches for files with three different extensions
    inside the root?
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`find` command.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Find out which commands inside Linux have the **Set owner User ID** (**SUID**)
    set up.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`find` command with the `-``perm` parameter.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Which command is used to create a file with 1,000 lines of randomly generated
    words (one word per line)?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`shuf` command (not shown in this chapter).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Perform the same exercise as before, but this time generate a file with 1,000
    randomly generated numbers.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`for` loop.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: How do you find out when `sudo` was last used and which commands were executed
    by it?
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`grep` command.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, please refer to
    the following Packt titles:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '*Fundamentals of Linux*, by *Oliver Pelz*'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Ubuntu Server – Fourth Edition*, by *Jay LaCroix*'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
