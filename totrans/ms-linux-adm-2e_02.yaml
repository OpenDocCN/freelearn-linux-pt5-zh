- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Linux Shell and Filesystem
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux shell 和文件系统
- en: Understanding the **Linux filesystem**, **file management** fundamentals, and
    the basics of the **Linux shell** and **command-line interface** (**CLI**) is
    essential for a modern-day Linux professional.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 **Linux 文件系统**、**文件管理** 基础知识，以及 **Linux shell** 和 **命令行界面** (**CLI**) 的基本知识，对于现代
    Linux 专业人员来说至关重要。
- en: In this chapter, you will learn how to use the Linux shell and some of the most
    common commands in Linux. You will learn about the structure of a basic Linux
    command and how the Linux filesystem is organized. We’ll explore various commands
    for working with files and directories. Along the way, we’ll introduce you to
    the most common command-line text editors. We hope that by the end of this chapter,
    you’ll be comfortable using the Linux CLI and be ready for future, more advanced
    explorations. This chapter will set the foundation for using the Linux shell,
    and for more information about the shell, go to [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164),
    *Linux* *Shell Scripting*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 Linux shell 和一些 Linux 中最常用的命令。您将了解一个基本的 Linux 命令的结构，以及 Linux 文件系统的组织方式。我们将探索处理文件和目录的各种命令。过程中，我们还将介绍最常用的命令行文本编辑器。希望通过本章的学习，您能够熟练使用
    Linux CLI，为以后更深入的学习做好准备。本章将为使用 Linux shell 打下基础，关于 shell 的更多信息，请访问 [*第 8 章*](B19682_08.xhtml#_idTextAnchor164)，*Linux*
    *Shell 脚本编写*。
- en: 'We’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主要主题：
- en: Introducing the Linux shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Linux shell
- en: The Linux filesystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 文件系统
- en: Working with files and directories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作文件和目录
- en: Using text editors to create and edit files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文本编辑器创建和编辑文件
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires a working installation of a standard Linux distribution,
    on either server, desktop, PC, or **Virtual Machine** (**VM**). Our examples and
    case studies use the Ubuntu and Fedora platforms, but the commands and examples
    explored are equally suitable for any other Linux distribution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要在标准 Linux 发行版的工作环境中进行安装，支持服务器、桌面、PC 或 **虚拟机** (**VM**) 平台。我们的示例和案例研究使用 Ubuntu
    和 Fedora 平台，但所探讨的命令和示例同样适用于任何其他 Linux 发行版。
- en: Introducing the Linux shell
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Linux shell
- en: 'Linux has its roots in the Unix operating system, and one of its main strengths
    is the command-line interface. In the old days, this was called *the shell*. In
    `sh` command. The shell is a program that has two streams: an *input stream* and
    an *output stream*. The input is a command given by the user, and the output is
    the result of that command, or an interpretation of it. In other words, the shell
    is the primary interface between the user and the machine.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 起源于 Unix 操作系统，其中一个主要优势是命令行界面。以前，这被称为 *shell*。在 `sh` 命令中，shell 是一个程序，它有两个流：*输入流*
    和 *输出流*。输入是用户输入的命令，而输出是该命令的结果或其解释。换句话说，shell 是用户与机器之间的主要接口。
- en: The main shell in major Linux distributions is called **Bash**, which is an
    acronym for **Bourne Again Shell**, named after Steve Bourne, the original creator
    of the shell in UNIX. Alongside Bash, there are other shells available in Linux,
    such as **ksh**, **tcsh**, and **zsh**. In this chapter and throughout the book,
    we will cover the Bash shell, as it is the most widely used shell in modern Linux
    distributions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 Linux 发行版中的默认 shell 称为 **Bash**，它是 **Bourne Again Shell** 的缩写，命名来源于 UNIX
    中原始 shell 的创建者 Steve Bourne。除了 Bash，Linux 中还提供了其他几种 shell，如 **ksh**、**tcsh** 和
    **zsh**。在本章及全书中，我们将主要讨论 Bash shell，因为它是现代 Linux 发行版中最广泛使用的 shell。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Distributions such as Debian, Ubuntu, Fedora, CentOS Stream, RHEL, openSUSE,
    SLE, and Linux Mint, just to name a few, use the *Bash* shell by default. Other
    distributions, such as Kali Linux, have switched to *zsh* by default. Manjaro
    offers zsh on some editions. For those who use macOS, you should know that zsh
    has been the default shell for some years now. Nevertheless, you can install any
    shell you want on Linux and make it your default one. In general, shells are pretty
    similar, as they do the same thing, but they add different *extras* to usability
    and features. If you are interested in a specific shell, feel free to use it and
    test out the differences between others.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Debian、Ubuntu、Fedora、CentOS Stream、RHEL、openSUSE、SLE 和 Linux Mint 等发行版默认使用 *Bash*
    Shell。其他一些发行版，如 Kali Linux，已默认切换到 *zsh*。Manjaro 在某些版本中提供 zsh。对于使用 macOS 的用户，你应该知道
    zsh 已成为默认 Shell 已有几年了。不过，你可以在 Linux 上安装任何你想要的 Shell，并将其设置为默认 Shell。一般来说，Shell
    功能非常相似，因为它们做的是相同的事情，但在可用性和功能上有所不同。如果你对某个特定的 Shell 感兴趣，可以随意使用它，并测试与其他 Shell 的差异。
- en: One shell can be assigned to each user. Users on the same system can use different
    shells. One way to check the default shell is by accessing the `/etc/passwd` file.
    More details about this file and user accounts will be discussed in [*Chapter
    4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users and Groups*. For now, it
    is important to know where to look for the default shell. In this file, the last
    characters from each line represent the user’s default shell. The `/etc/passwd`
    file has the users listed on each line, with details about their **process identification
    number** (**PID**), **group identification number** (**GID**), username, home
    directory, and basic shell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都可以分配一个 Shell。系统中的不同用户可以使用不同的 Shell。检查默认 Shell 的一种方法是访问 `/etc/passwd` 文件。关于这个文件和用户账户的更多细节将在
    [*第 4 章*](B19682_04.xhtml#_idTextAnchor090)中讨论，*管理用户和组*。现在，重要的是知道如何查找默认的 Shell。在此文件中，每行的最后字符表示该用户的默认
    Shell。`/etc/passwd` 文件列出了每个用户的信息，包括 **进程标识号** (**PID**)、**组标识号** (**GID**)、用户名、主目录和基本
    Shell。
- en: 'To see the default shell for each user, execute the following command by using
    your user’s name (in our case, it is `packt`):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个用户的默认 Shell，请使用你用户的用户名执行以下命令（在我们的例子中是 `packt`）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output should be a list of the contents of the `/etc/passwd` file. Depending
    on the number of users you have on your system, you will see all of them, each
    one on a separate line. An easier way to see the *current shell* is by running
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是 `/etc/passwd` 文件内容的列表。根据你系统中用户的数量，你将看到所有用户的信息，每个用户占一行。查看 *当前 Shell* 的一个更简单的方法是运行以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This shows what exactly is running your command, which in the case of the CLI
    is the shell. The `$0` part is a `echo $0` command on Ubuntu and on Debian:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了究竟是什么在运行你的命令，在命令行界面（CLI）的情况下，就是 Shell。`$0` 部分是 Ubuntu 和 Debian 上的 `echo
    $0` 命令：
- en: '![Figure 2.1 – Commands used to see the running shell](img/Figure_02.01_B19682.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 查看正在运行的 Shell 的命令](img/Figure_02.01_B19682.jpg)'
- en: Figure 2.1 – Commands used to see the running shell
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 查看正在运行的 Shell 的命令
- en: 'As you can see, running the `echo $0` command gives us different outputs but
    with the same message: the running shell is Bash. If you have other shells that
    you prefer, you can easily assign another shell to your user, if you already have
    it installed. However, if you know Bash, you will be comfortable with all the
    other available shells.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，运行 `echo $0` 命令给出的输出不同，但传递的信息是一样的：正在运行的 Shell 是 Bash。如果你有其他喜欢的 Shell，你可以很容易地为你的用户分配另一个
    Shell，前提是你已经安装了它。不过，如果你了解 Bash，那么你将能够轻松使用其他所有可用的 Shell。
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '*The Linux shell is case-sensitive*. This means that everything you type inside
    the command line should respect this. For example, the `cat` command used earlier
    used lowercase. If you type `Cat` or `CAT`, the shell will not recognize it as
    being a command. The same rule applies to file paths. You will notice that default
    directories in your home directory use uppercase for the first letter, as in `~/Documents`,
    `~/Downloads`, and so on. Those names are different from `~/documents` or `~/downloads`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Linux Shell 是区分大小写的*。这意味着你在命令行中输入的每个命令都必须遵循这一规则。例如，之前使用的 `cat` 命令是小写的。如果你输入
    `Cat` 或 `CAT`，Shell 将无法识别它是一个有效的命令。这个规则同样适用于文件路径。你会注意到，默认的目录在你的主目录中使用大写字母作为首字母，例如
    `~/Documents`、`~/Downloads` 等等。这些名称与 `~/documents` 或 `~/downloads` 是不同的。'
- en: In this chapter, you will learn how to use Linux commands and the shell in addition
    to learning about its filesystem. You will learn about software management in
    [*Chapter 3*](B19682_03.xhtml#_idTextAnchor075), thus showing you how to install
    another shell now would mean that we will get ahead of ourselves. We want you
    to slowly but steadily build your Linux knowledge, so we will show you in the
    next chapter how to install a new shell. For now, Bash is sufficient, and we will
    use it throughout the book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Linux命令和终端，同时了解其文件系统。关于软件管理，您将在[*第3章*](B19682_03.xhtml#_idTextAnchor075)中学习，因此现在讲解如何安装新终端会让我们提前讨论。我们希望您能够逐步稳步地建立Linux知识，因此我们将在下一章向您展示如何安装新终端。现在，Bash已经足够了，我们将在全书中使用它。
- en: 'If you want to see all the shells that are installed on your system, you can
    run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看系统上已安装的所有终端，可以运行以下命令：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our case, the output with all the installed shells (by default) in Ubuntu
    Server 22.04.2 LTS is shown in the following image:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，Ubuntu Server 22.04.2 LTS中所有已安装的终端（默认设置）如下图所示：
- en: '![Figure 2.2 – The shells available by default in Ubuntu](img/Figure_02.02_B19682.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – Ubuntu 默认提供的终端](img/Figure_02.02_B19682.jpg)'
- en: Figure 2.2 – The shells available by default in Ubuntu
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – Ubuntu 默认提供的终端
- en: This will show you all the shells installed. You can use any of those or can
    install new ones as we will show you in [*Chapter 3*](B19682_03.xhtml#_idTextAnchor075).
    Also, in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), when we work with user
    accounts, you will get to learn how you can change a user’s shell.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有已安装的终端。您可以使用这些终端中的任何一个，或者像我们将在[*第3章*](B19682_03.xhtml#_idTextAnchor075)中所示的那样安装新的终端。此外，在[*第4章*](B19682_04.xhtml#_idTextAnchor090)中，当我们处理用户帐户时，您将学习如何更改用户的终端。
- en: The following section will introduce you to shell connection types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍终端连接类型。
- en: Establishing the shell connection
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立终端连接
- en: 'We can make two different types of connections to the shell: `tty` and `pts`.
    The name `tty` stands for **teletypewriter**, which was a type of terminal used
    at the beginning of computing. This connection is considered a native one, with
    ports that are direct connections to your computer. The link between the user
    and the computer is mainly found to be through a keyboard, which is considered
    to be a native terminal device.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种不同的方式连接到终端：`tty`和`pts`。`tty`代表**电传打字机**，它是计算机早期使用的一种终端类型。这种连接被视为本地连接，其端口是与计算机直接连接的。用户与计算机之间的链接通常通过键盘来实现，键盘被认为是本地终端设备。
- en: The `pts` connection is generated by SSH or Telnet types of links. Its name
    stands for `ssh` or `xterm`. It is the slave of the `pty`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`pts`连接是通过SSH或Telnet类型的连接生成的。它的名称代表`ssh`或`xterm`，是`pty`的从属设备。'
- en: In the next section, we will further explore the connections to virtual terminals
    available in Linux.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步探讨Linux中可用的虚拟终端连接。
- en: Virtual consoles/terminals
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟控制台/终端
- en: The terminal was thought of as a device that manages the input strings (which
    are commands) between a process and other I/O devices such as a keyboard and a
    screen. There are also **pseudo terminals**, which are emulated terminals that
    behave the same way as a **classical terminal**. The difference is that it does
    not interact with devices directly, as it is all emulated by the Linux kernel,
    which transmits the I/O to a program called the shell.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 终端被认为是一个管理输入字符串（即命令）与其他I/O设备（如键盘和屏幕）之间的设备。还有**伪终端**，它是模拟终端，行为与**经典终端**相同。不同之处在于，它不会直接与设备交互，因为这一切都由Linux内核模拟，并将I/O传输给一个叫做shell的程序。
- en: '`tty1`, `tty2`, `tty3,` `tty4`, `tty5`, and `tty6`, respectively, on your computer.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`tty1`、`tty2`、`tty3`、`tty4`、`tty5`和`tty6`，分别在您的计算机上。'
- en: 'We will explain this using an Ubuntu 22.04.2 LTS Server VM installation, but
    it is identical in Rocky Linux too. After starting the VM and being prompted to
    log in with your username and password, the first line on the screen will be something
    similar to the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以Ubuntu 22.04.2 LTS Server虚拟机安装为例进行解释，但在Rocky Linux中也是相同的。启动虚拟机后，提示输入用户名和密码时，屏幕上的第一行将显示类似以下内容：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you press any of the preceding key combinations, you will see your terminal
    change from `tty1` to any of the other `tty` instances. For example, if you press
    *Ctrl* + *Alt* + *F6*, you will see this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下任何前述的键盘组合，你将看到终端从 `tty1` 切换到其他 `tty` 实例。例如，如果你按下 *Ctrl* + *Alt* + *F6*，你将看到以下内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we were using the server edition of Ubuntu, we did not have the GUI installed.
    But if you were to use a desktop edition, you will be able to use *Ctrl* + *Alt*
    + *F7* to enter `X graphical` mode, for example. The `neptune` string is the name
    we gave to our virtual machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用的是 Ubuntu 的服务器版本，所以没有安装图形界面。但是，如果你使用的是桌面版，你将能够使用 *Ctrl* + *Alt* + *F7*
    进入 `X 图形` 模式。例如，`neptune` 字符串是我们为虚拟机起的名字。
- en: If you are not able to use the preceding keyboard combinations, there is a dedicated
    command for changing virtual terminals. The command is called `chvt` and has the
    syntax `chvt N`. Even though we have not discussed shell commands yet, we will
    show you an example of how to use them and other related commands. This action
    can only be performed by an administrator account or by using `sudo`. Briefly,
    `sudo` stands for *superuser do* and allows any user to run programs with administrative
    privileges or with the privileges of another user (more details about this in
    [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法使用前述的键盘组合，可以使用专门的命令来更改虚拟终端。这个命令叫做 `chvt`，其语法是 `chvt N`。虽然我们还没有讨论 shell
    命令，但我们会给你展示如何使用它们以及其他相关命令的示例。此操作只能由管理员账户执行，或者通过 `sudo` 使用。简而言之，`sudo` 代表 *superuser
    do*，它允许任何用户以管理员权限或其他用户的权限运行程序（有关更多细节，请参阅 [*第 4 章*](B19682_04.xhtml#_idTextAnchor090)，*管理用户*
    *和组*）。
- en: In the following example, we will use Ubuntu to show you how to change virtual
    terminals. First, we will see which virtual terminal we are currently using to
    change it to another one without using the *Ctrl* + *Alt* + *Fn* keys.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用 Ubuntu 向你展示如何更改虚拟终端。首先，我们将查看当前使用的是哪个虚拟终端，然后在不使用 *Ctrl* + *Alt*
    + *Fn* 键的情况下切换到另一个虚拟终端。
- en: 'The `who` command will show you information about the users currently logged
    in to the computer. In our case, as we are connected through SSH to our virtual
    machine, it will show that the user `packt` is currently using pseudo-terminal
    zero (`pts/0`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`who` 命令将显示当前登录计算机的用户信息。在我们的例子中，由于我们是通过 SSH 连接到虚拟机，它将显示用户 `packt` 当前正在使用伪终端零（`pts/0`）：'
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we were to run the same command in the console of the virtual machine directly,
    we would have the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们直接在虚拟机的控制台中运行相同的命令，输出将是以下内容：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It shows that the user is connected to both the virtual terminal 1 (`tty1`)
    and also through SSH from our host operating system to the virtual machine (`pts/0`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示用户同时连接到虚拟终端 1（`tty1`）和通过 SSH 从宿主操作系统连接到虚拟机（`pts/0`）。
- en: Now, by using the `chvt` command, we will show you how to change to the sixth
    virtual terminal. After running `sudo chvt 6`, you will be prompted to provide
    your password and immediately be switched to virtual terminal number six. Running
    `who` once more will show you all logged-in users and the virtual terminals they
    use. In our case will be `pts/0`, `tty2`, and `tty6`. Please take into consideration
    that your output could be different, as in different virtual terminal numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过使用 `chvt` 命令，我们将向你展示如何切换到第六个虚拟终端。运行 `sudo chvt 6` 后，你将被提示输入密码，并立即切换到第六个虚拟终端。再次运行
    `who` 将显示所有已登录的用户及其使用的虚拟终端。在我们的例子中将是 `pts/0`、`tty2` 和 `tty6`。请注意，你的输出可能不同，因为虚拟终端的编号不同。
- en: Now that we know what types of shell connections are established, let us learn
    about the shell’s prompt in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有哪些类型的 shell 连接，接下来我们将在下一节学习 shell 提示符的相关内容。
- en: The command-line prompt
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令行提示符
- en: The **command-line prompt** or **shell prompt** is the place where you type
    in the commands. Usually, the command prompt will show the username, hostname,
    present working directory, and a symbol that indicates the type of user running
    the shell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行提示符** 或 **shell 提示符** 是你输入命令的地方。通常，命令提示符会显示用户名、主机名、当前工作目录和一个表示正在运行 shell
    的用户类型的符号。'
- en: 'Here is an example from the Ubuntu 22.04.2 LTS Server edition (similar to Debian):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Ubuntu 22.04.2 LTS 服务器版的示例（与 Debian 类似）：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example from the Fedora 37 server (similar to Rocky Linux, RHEL,
    or AlmaLinux):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Fedora 37 服务器的示例（与 Rocky Linux、RHEL 或 AlmaLinux 类似）：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is a short explanation of the prompt:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对提示符的简短解释：
- en: '`packt` is the name of the user currently logged in'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packt` 是当前登录用户的用户名'
- en: '`saturn` and `localhost` are the hostnames'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saturn` 和 `localhost` 是主机名'
- en: '`~` represents the home directory (it is called a tilde)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~` 代表家目录（它被称为波浪符）'
- en: '`$` shows that the user is a regular user (when you are logged in as an administrator,
    the sign changes into a hashtag, `#`)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` 表示用户是一个普通用户（当您以管理员身份登录时，符号会变成井号 `#`）'
- en: 'Also, when using openSUSE, you will notice that the prompt is different than
    the ones in Ubuntu/Debian and Fedora/RHEL. The following is an example of the
    prompt while running the Leap 15.4 server edition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用 openSUSE 时，您会注意到提示符与 Ubuntu/Debian 和 Fedora/RHEL 的提示符不同。以下是运行 Leap 15.4
    服务器版时的提示符示例：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, there is no dollar sign (`$`) or hashtag (`#`), only a greater
    than sign (`>`). This might be confusing at first, but when you will use the root
    user, the sign will eventually change to the hashtag (`#`). The following is an
    example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有美元符号 (`$`) 或井号 (`#`)，只有大于符号 (`>`)。刚开始可能会有些困惑，但当您使用 root 用户时，符号最终会变成井号
    (`#`)。以下是一个示例：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s look at the shell command types next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 shell 命令类型。
- en: Shell command types
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Shell 命令类型
- en: 'Shells work with `type` command. For example, you can check what type of command
    `cd` (change directory) is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 使用 `type` 命令。例如，您可以检查 `cd`（更改目录）是什么类型的命令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output shows that the `cd` command is an internal one, built inside the
    shell. If you are curious, you could find out the types of other commands that
    we will show you in the following sections by writing type in front of the command’s
    name. Let us see some more examples in the following image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示 `cd` 命令是一个内部命令，它内置在 shell 中。如果你感兴趣，你可以通过在命令名前加上 `type` 来了解我们将在接下来的章节中展示的其他命令类型。接下来我们可以通过以下图像查看更多示例：
- en: '![Figure 2.3 – Different types of commands in Linux](img/Figure_02.03_B19682.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – Linux 中不同类型的命令](img/Figure_02.03_B19682.jpg)'
- en: Figure 2.3 – Different types of commands in Linux
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – Linux 中不同类型的命令
- en: Now that you know some of the types of Linux commands, let us dissect the command’s
    structure and learn about its components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道一些 Linux 命令的类型，让我们分析命令的结构并了解其组成部分。
- en: Explaining the command structure
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释命令结构
- en: 'We have already used some commands, but we did not explain the structure of
    a Linux command. We will do that now for you to be able to understand how to use
    commands. In a nutshell, Unix and Linux commands have the following form:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过一些命令，但我们没有解释 Linux 命令的结构。现在我们将为您讲解，以便您能够理解如何使用这些命令。简而言之，Unix 和 Linux
    命令有以下形式：
- en: The command’s name
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的名称
- en: The command’s options
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的选项
- en: The command’s arguments
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的参数
- en: 'Inside the shell, you will have a general structure such as the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中，您将看到类似以下的结构：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A suitable example would be the use of the `ls` command (`ls` comes from a *list*).
    This command is one of the most-used commands in Linux. It lists files and directories
    and can be used with both options and arguments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的例子是使用 `ls` 命令（`ls` 来自 *list*）。这个命令是 Linux 中最常用的命令之一，它用于列出文件和目录，并且可以与选项和参数一起使用。
- en: We can use `ls` in its simplest form, without options or arguments. It lists
    the contents of your present working directory (`pwd`). In our case, it is the
    home directory, indicated by the `~` tilde character in the shell’s prompt (see
    *Figure 2**.10*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用最简单的 `ls` 命令，既不加选项也不加参数。它会列出当前工作目录（`pwd`）的内容。在我们的例子中，它是家目录，在 shell 提示符中由
    `~` 波浪符表示（见 *图 2.10*）。
- en: 'The `ls` command with the `-l` option (lowercase L) uses a long listing format,
    giving you extra information about files and directories from your present working
    directory (`pwd`):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `-l` 选项（小写 L）的 `ls` 命令使用长格式列出，提供关于当前工作目录（`pwd`）中文件和目录的更多信息：
- en: '![Figure 2.4 – Using the ls command with both options and attributes](img/Figure_02.04_B19682.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 使用 `ls` 命令结合选项和属性](img/Figure_02.04_B19682.jpg)'
- en: Figure 2.4 – Using the ls command with both options and attributes
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 使用 `ls` 命令结合选项和属性
- en: In the preceding example, we used `ls -l ~/Documents/` to show the contents
    of the `~/Documents` directory. Shown here is a way to use the command with both
    options and attributes, without changing our present working directory to `~/Documents`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `ls -l ~/Documents/` 来显示 `~/Documents` 目录的内容。这里展示了一种使用命令结合选项和属性的方式，而不需要将当前工作目录切换到
    `~/Documents`。
- en: In the following section, we will show you how to use the manual pages available
    by default in Linux.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将向你展示如何使用 Linux 中默认提供的手册页面。
- en: Consulting the manual
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查阅手册
- en: Any Linux system administrator’s best friend is the manual. Each command in
    Linux has a manual page that gives the user detailed information about its use,
    options, and attributes. If you know the command you want to learn more about,
    simply use the `man` command to explore. For the `ls` command, for example, you
    use `man ls`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每位 Linux 系统管理员的好伙伴就是手册。每个 Linux 命令都有一个手册页面，向用户提供有关其使用、选项和属性的详细信息。如果你知道想要了解的命令，直接使用
    `man` 命令进行查阅。例如，要查看 `ls` 命令的手册，你可以使用 `man ls`。
- en: The manual organizes its command information into different sections, with each
    section being named by convention to be the same on all distributions. Briefly,
    those sections are `name`, `synopsis`, `configuration`, `description`, `options`,
    `exit status`, `return value`, `errors`, `environment`, `files`, `versions`, `conforming
    to`, `notes`, `bugs`, `example`, `authors`, `copyright`, and `see also`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 手册将命令信息组织成不同的章节，每个章节都按约定命名，在所有发行版中都是一样的。简要地说，这些章节包括 `name`、`synopsis`、`configuration`、`description`、`options`、`exit
    status`、`return value`、`errors`、`environment`、`files`、`versions`、`conforming to`、`notes`、`bugs`、`example`、`authors`、`copyright`
    和 `see also`。
- en: Similar to the manual pages, almost all commands in Linux have a `-help` option.
    You can use this for quick reference.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于手册页面，几乎所有的 Linux 命令都有一个 `-help` 选项。你可以利用这个选项来进行快速查阅。
- en: 'For more information about the `help` and `man` pages, you can check each command’s
    help or manual page. Try the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `help` 和 `man` 页面的信息，你可以查阅每个命令的帮助或手册页面。尝试以下命令：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you use the manual, keep in mind that it is not a step-by-step how-to guide.
    It is technical documentation that might be confusing at first. Our advice is
    to use the `man` pages as much as you can. Before you search for anything on the
    internet, try to read the manual first. This will be a good exercise, and you
    will become proficient with Linux commands in no time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用手册时，请记住它并不是一本逐步操作的指南。它是技术文档，刚开始时可能会让人感到困惑。我们的建议是尽可能多地使用 `man` 页面。在你去互联网搜索任何内容之前，先试着阅读手册。这将是一个很好的练习，并且你将很快熟练掌握
    Linux 命令。
- en: Consider the manual your friend, similar to the textbooks you used in high school
    or college. It will give you first-hand information when you most need it. If
    you take into consideration situations where outside internet access is limited,
    with no access to search engines, the built-in manual will be your best companion.
    Learn to use its powers to your advantage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 把手册当作你的朋友，类似于你在高中或大学时使用的教科书。它将在你最需要的时候提供第一手信息。如果你考虑到在某些情况下无法访问互联网，也无法使用搜索引擎，内建的手册将是你最好的伙伴。学会利用它的功能，充分发挥它的优势。
- en: In the following section, you will learn about the Linux filesystem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，你将了解 Linux 文件系统。
- en: The Linux filesystem
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 文件系统
- en: The `/ (root)` filesystem and another the `/home` filesystem. Or, there can
    be just one that contains all filesystems.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ (root)` 文件系统和另一个 `/home` 文件系统。或者，可能只有一个文件系统包含所有的文件系统。'
- en: Generally, using one filesystem per partition is considered to be good practice
    by allowing for logical maintenance and management. As everything in Linux is
    a file, physical devices such as hard drives, DVD drives, USB devices, and floppy
    drives are treated as files too. In this section, you will learn about the directory
    structure, how to work with files, and some very useful editing techniques from
    the command line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，按每个分区使用一个文件系统被认为是良好的做法，它有助于逻辑上的维护和管理。由于 Linux 中的一切都是文件，硬盘、DVD 驱动器、USB 设备和软盘驱动器等物理设备也被视作文件。在本节中，你将了解目录结构，如何操作文件，以及一些非常有用的命令行编辑技巧。
- en: Directory structure
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录结构
- en: Linux uses a `` `/` ``) at the base of the filesystem. From that point, all
    the branches (directories) spread throughout the filesystem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 在文件系统的基础处使用`` `/` ``)。从此位置开始，所有的分支（目录）都向文件系统扩展。
- en: The **Filesystem Hierarchy Standard** (**FHS**) defines the structure of Unix-like
    filesystems. However, Linux filesystems also contain some directories that aren’t
    yet defined by the standard.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统层次标准**（**FHS**）定义了类似 Unix 系统文件系统的结构。然而，Linux 文件系统还包含一些标准未定义的目录。'
- en: Exploring the Linux filesystem from the command line
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行探索 Linux 文件系统
- en: 'Feel free to explore the filesystem yourself by using the `tree` command. In
    Fedora Linux, it is already installed, but if you use Ubuntu, you will have to
    install it by using the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`tree`命令自由地探索文件系统。在Fedora Linux中，`tree`已预安装，但如果你使用Ubuntu，需要使用以下命令进行安装：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Do not be afraid to explore the filesystem, because no harm will be done just
    by looking around. You can use the `ls` command to list the contents of directories,
    but `tree` offers different graphics. The following image shows you the differences
    between the outputs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕探索文件系统，因为单纯浏览是不会造成任何损害的。你可以使用`ls`命令列出目录的内容，但`tree`提供了不同的图形化显示。以下图像展示了两者输出的区别：
- en: '![Figure 2.5 – Comparing the output of ls -la commands and tree -a commands](img/Figure_02.05_B19682.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 比较`ls -la`命令和`tree -a`命令的输出](img/Figure_02.05_B19682.jpg)'
- en: Figure 2.5 – Comparing the output of ls -la commands and tree -a commands
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 比较`ls -la`命令和`tree -a`命令的输出
- en: 'The `tree` command has different options available, and you can learn about
    them by using the manual. Let us use the `tree` command by invoking the `-L` option,
    which tells the command how many levels down to go, and the last attribute states
    which directory to start with. In our example, the command will go down one level,
    starting from the `root` directory, represented by the forward slash as an argument
    (see *Figure 2**.12*):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`命令有不同的选项，你可以通过手册了解它们。我们将使用`tree`命令并调用`-L`选项，这告诉命令应该向下查看多少级目录，最后的属性则指定从哪个目录开始。在我们的示例中，命令将从`root`目录开始，向下查看一级，该目录由正斜杠作为参数表示（见*图
    2.12*）：'
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Start exploring the directories from the structure by using the `tree` command,
    as shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`tree`命令开始探索目录结构，如下所示：
- en: '![Figure 2.6 – The tree command with option and argument on Ubuntu](img/Figure_02.06_B19682.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 在Ubuntu上使用带选项和参数的`tree`命令](img/Figure_02.06_B19682.jpg)'
- en: Figure 2.6 – The tree command with option and argument on Ubuntu
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 在Ubuntu上使用带选项和参数的`tree`命令
- en: Important note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that some of the directories you are about to open will contain a large
    number of files and/or other directories, which will clutter your terminal window.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，某些你即将打开的目录中将包含大量文件和/或其他目录，这将使你的终端窗口变得杂乱无章。
- en: 'The following are the directories that exist on almost all versions of Linux.
    Here’s a quick overview of the Linux root filesystem:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几乎所有版本的Linux上都存在的目录。以下是Linux根文件系统的快速概览：
- en: '`/`: Root directory. The root for all other directories.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`：根目录。所有其他目录的根目录。'
- en: '`/bin`: Essential command binaries. The place where binary programs are stored.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：必要的命令二进制文件。存储二进制程序的位置。'
- en: '`/boot`: Static files of the boot loader. The place where the kernel, bootloader,
    and `initramfs` are stored.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：引导加载程序的静态文件。存储内核、引导加载程序和`initramfs`的位置。'
- en: '`/dev`: Device files. Nodes to the device equipment, a kernel device list.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备文件。指向设备设备节点，是内核设备列表。'
- en: '`/etc`: Host-specific system configuration. Essential config files for the
    system, boot time loading scripts, `crontab`, `fstab` device storage tables, `passwd`
    user accounts file.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：特定主机的系统配置。系统的必要配置文件、启动时加载的脚本、`crontab`、`fstab`设备存储表、`passwd`用户帐户文件。'
- en: '`/home`: user Home directory. The place where the user’s files are stored.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`：用户的主目录。存储用户文件的位置。'
- en: '`/lib`: Essential shared libraries and kernel modules. Shared libraries are
    similar to **Dynamic Link Library** (**DLL**) files in Windows.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：必要的共享库和内核模块。共享库类似于Windows中的**动态链接库**（**DLL**）文件。'
- en: '`/media`: Mount point for removable media. For external devices and USB external
    media.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media`：可移动媒体的挂载点。用于外部设备和USB外部媒体。'
- en: '`/mnt`: Mount point for mounting a filesystem temporarily. Used for legacy
    systems.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt`：用于临时挂载文件系统的挂载点。用于旧版系统。'
- en: '`/opt`: Add-on application software packages. The place where *optional* software
    is installed.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/opt`：附加应用程序软件包。安装*可选*软件的位置。'
- en: '`/proc`: Virtual filesystem managed by the kernel. a special directory structure
    that contains files essential for the system.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：由内核管理的虚拟文件系统。一个包含系统所需文件的特殊目录结构。'
- en: '`/sbin`: Essential system binaries. Vital programs for the system’s operation.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：必要的系统二进制文件。系统运行所需的重要程序。'
- en: '`/srv`: Data for services provided by this system.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/srv`：本系统提供的服务的数据。'
- en: '`/tmp`: Temporary files.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：临时文件。'
- en: '`/usr`: Secondary hierarchy. The largest directory in Linux that contains support
    files for regular system users:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：次级层级。Linux 中最大的目录，包含普通系统用户所需的支持文件：'
- en: '`/usr/bin` – system-executable files'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/bin` – 系统可执行文件'
- en: '`/usr/lib` – shared libraries from `/usr/bin`'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/lib` – 来自 `/usr/bin` 的共享库'
- en: '`/usr/local` – source compiled programs not included in the distribution'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/local` – 源代码编译的程序，不包括在发行版中'
- en: '`/usr/sbin` – specific system administration programs'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/sbin` – 特定的系统管理程序'
- en: '`/usr/share` – data shared by the programs in `/usr/bin` such as config files,
    icons, wallpapers or sound files'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share` – 程序在 `/usr/bin` 中共享的数据，例如配置文件、图标、壁纸或音频文件'
- en: '`/usr/share/doc` – documentation for the system-wide files'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share/doc` – 系统范围文件的文档'
- en: '`/var`: Variable data. Only data that is modifiable by the user is stored here,
    such as databases, printing spool files, user mail, and others; `/var/log` – contains
    log files that register system activity'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：可变数据。只有用户可修改的数据存储在这里，例如数据库、打印缓存文件、用户邮件等；`/var/log` – 包含记录系统活动的日志文件'
- en: Next, we’re going to learn how to work with these files and directories.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何操作这些文件和目录。
- en: Working with files and directories
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件和目录
- en: Remember that everything in Linux is a file. A directory is a file too. As such,
    it is essential to know how to work with them. Working with files in Linux implies
    the use of several commands for basic file and directory operations, file viewing,
    file creation, file location, file properties, and linking. Some of the commands,
    which will not be covered here, have uses closely related to files. These will
    be covered in the following section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在 Linux 中一切都是文件。目录也是文件。因此，了解如何操作它们是至关重要的。在 Linux 中操作文件意味着使用多个命令来执行基本的文件和目录操作，如文件查看、文件创建、文件定位、文件属性和链接。一些命令虽然在此不会详细介绍，但与文件密切相关，接下来的章节将涵盖它们。
- en: Understanding file paths
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解文件路径
- en: Each file in the FHS has a *path*. The path is the file’s location represented
    in an easily readable representation. In Linux, all the files are stored in the
    root directory by using the FHS as a standard to organize them. Relations between
    files and directories inside this system are expressed through the forward-slash
    character (`/`). Throughout computing history, this was used as a symbol that
    described addresses. Paths are, in fact, addresses for files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: FHS 中的每个文件都有一个*路径*。路径是文件位置的易读表示。在 Linux 中，所有文件都存储在根目录下，使用 FHS 作为标准来组织它们。系统内文件和目录之间的关系通过正斜杠字符（`/`）表示。在计算机历史上，正斜杠被用作描述地址的符号。路径实际上是文件的地址。
- en: There are two types of paths in Linux, relative ones and absolute ones. An **absolute
    path** always starts with the root directory and follows the branches of the system
    up to the desired file. A **relative path** always refers to the **present working
    directory** (**pwd**) and represents the relative path to it. Thus, a relative
    path is always a path that is relative to your present working directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中有两种路径类型，相对路径和绝对路径。**绝对路径**总是以根目录开始，并沿着系统的分支直到所需的文件。**相对路径**总是指向**当前工作目录**（**pwd**），并表示到该目录的相对路径。因此，相对路径总是相对于当前工作目录的路径。
- en: 'For example, let us refer to an existing file from our home directory, a file
    called `poem`. Being inside the home directory, and our `pwd` command being the
    `home` directory for `packt`, the absolute path of the file called `poem` would
    be as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们从主目录引用一个现有的文件，名为 `poem`。如果我们在主目录内，并且 `pwd` 命令显示为 `packt` 的主目录，那么名为 `poem`
    的文件的绝对路径将如下所示：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we were to show the contents of that file using the `cat` command, for example,
    we would use the command with the absolute path:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 `cat` 命令查看该文件的内容，例如，我们可以使用带有绝对路径的命令：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The relative path to the same file would be relative to `pwd`, so in our case,
    where we’re already inside the home directory, using the `cat` command would be
    like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个文件的相对路径是相对于 `pwd` 的，因此在我们的例子中，如果我们已经在主目录内，使用 `cat` 命令将是这样的：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The absolute path is useful to know about when you work with files. After some
    practice, you will come to learn the paths to the most-used files. For example,
    one file that you will need to learn the path for is the `passwd` file. It resides
    in the `/etc` directory. Thus, when you will refer to it, you will use its absolute
    path, `/etc/passwd`. Using a relative path to that file would imply that you are
    either inside its parent directory or somewhere close in the FHS.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径在操作文件时非常有用。经过一段时间的实践，你将会学会如何访问最常用的文件路径。例如，你需要学习的一个文件路径是`passwd`文件，它位于`/etc`目录中。因此，当你引用它时，你将使用它的绝对路径`/etc/passwd`。如果使用相对路径来引用该文件，则意味着你要么已经在其父目录中，要么在FHS中某个靠近的地方。
- en: Working with relative paths involves knowing two special characters used to
    work with the FHS. One special character is the dot (`.`), and it refers to the
    current directory. The other is two consecutive dots (`..`) and refers to the
    parent directory of the current directory. When working with relative paths, make
    sure that you always check what directory you are in. Use the `pwd` command to
    show your present working directory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对路径涉及到了解两个用于操作FHS（文件层次结构）的特殊字符。第一个特殊字符是点（`.`），它表示当前目录。另一个是两个连续的点（`..`），它表示当前目录的父目录。在使用相对路径时，确保始终检查你所在的目录。使用`pwd`命令可以显示你当前的工作目录。
- en: 'A good example of working with relative paths is when you are already inside
    the parent directory and need to refer to it. If you need to see the accounts
    list from your system, which is stored inside the `passwd` file, you can refer
    to it by using a relative path. For this exercise, we are inside our home directory:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相对路径的一个好例子是，当你已经在父目录中，并且需要引用它时。如果你需要查看系统中的账户列表，而这些信息存储在`passwd`文件中，你可以通过相对路径引用它。在这个例子中，我们处在我们的主目录中：
- en: '![Figure 2.7 – Using the relative path of a file](img/Figure_02.07_B19682.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 使用文件的相对路径](img/Figure_02.07_B19682.jpg)'
- en: Figure 2.7 – Using the relative path of a file
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 使用文件的相对路径
- en: Here, we first check our present working directory with the `pwd` command, and
    the output will be our home directory’s path, `/home/packt`. Secondly, we try
    to show the contents of the `passwd` file using the `cat` command right from the
    home directory, but the output will be an error message saying that there is no
    such file or directory inside our home directory. We used the relative path, which
    is always relative to our present working directory, hence the error. Thirdly,
    we use the double-consecutive dots special characters to refer to the file with
    its relative path. In this case, the command is `cat ../../etc/passwd`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过`pwd`命令检查当前的工作目录，输出将是我们的主目录路径，即`/home/packt`。接着，我们尝试从主目录直接显示`passwd`文件的内容，使用的是`cat`命令，但输出将是一个错误信息，表示在主目录中没有这样的文件或目录。我们使用了相对路径，而相对路径始终是相对于当前的工作目录，因此出现了错误。接下来，我们使用了两个连续点的特殊字符来通过相对路径引用该文件。在这种情况下，命令是`cat
    ../../etc/passwd`。
- en: Tip
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the *Tab* key on your keyboard for autocompletion and to check whether
    the path you typed is correct or not. In the preceding example, we typed `../../etc`
    and pressed *Tab*, which autocompleted with a forward slash. Then, we typed the
    first two letters of the file we were looking for and pressed *Tab* again. This
    showed us a list of files inside the `/etc` directory that started with `pa`.
    Seeing that `passwd` was in there, we knew that the path was right, so we typed
    two more `s` characters and pressed *Tab* again. This completed the command for
    us and we pressed *Enter*/*Return* to execute the command.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用键盘上的*Tab*键进行自动补全，并检查你输入的路径是否正确。在前面的例子中，我们输入了`../../etc`并按下了*Tab*，它自动补全为一个斜杠。然后，我们输入了文件名的前两个字母并再次按下*Tab*。这时，它展示了`/etc`目录中所有以`pa`开头的文件列表。看到`passwd`文件在其中后，我们确认路径正确，于是再输入两个`s`字符并按下*Tab*。这时，命令就自动完成了，我们按下*Enter*/*Return*键来执行命令。
- en: 'The path in the final command is relative to our home directory and it translates
    as follows: *concatenate the file with the* `passwd` *name that is located in
    the* `/etc` *directory in the parent directory (first two dots) of the parent
    directory (second two dots) of our current directory (home)*. Therefore, the `/etc/passwd`
    absolute path is translated into a relative path to our home directory like this:
    `../../etc/passwd`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最终命令中的路径是相对于我们的主目录的，它的翻译如下：*将文件与名为* `passwd` *的文件连接，该文件位于* `/etc` *目录中，该目录位于我们当前目录（主目录）的父目录（第一个两个点）和父目录的父目录（第二个两个点）中*。因此，`/etc/passwd`
    的绝对路径被转换为相对于我们主目录的相对路径，如下所示：`../../etc/passwd`。
- en: Next, we are going to learn about basic file operations in Linux.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习 Linux 中的基本文件操作。
- en: Basic file operations
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本文件操作
- en: Daily, as a system administrator, you will manipulate files. This includes creating,
    copying, moving, listing, deleting, linking, and so on. The basic commands for
    these operations have already been discussed throughout this chapter, but now
    it is time to get into more detail about their use, options, and attributes. Some
    more advanced commands will be detailed in the following sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，你每天都会操作文件。这包括创建、复制、移动、列出、删除、链接等操作。这些操作的基本命令在本章中已经讨论过，现在是时候深入了解它们的使用、选项和属性了。接下来的章节将详细介绍一些更高级的命令。
- en: Creating files
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文件
- en: There are situations when you will need to `touch` command. When you use it,
    it will create a new file with you as the file owner and with a size of zero,
    because it is an empty file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要使用 `touch` 命令。当你使用它时，它会创建一个新的文件，文件所有者是你，且文件大小为零，因为它是一个空文件。
- en: 'In the following example, we create a new file called `new-report` inside the
    `~/``packt/` directory:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将在 `~/``packt/` 目录下创建一个名为 `new-report` 的新文件：
- en: '![Figure 2.8 – Using the touch command to create and alter files](img/Figure_02.08_B19682.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 使用 touch 命令创建和修改文件](img/Figure_02.08_B19682.jpg)'
- en: Figure 2.8 – Using the touch command to create and alter files
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 使用 touch 命令创建和修改文件
- en: 'The `touch` command is also used to change the modification time of a file
    without changing the file itself. Notice the difference between the initial time
    when we first created the `new-report` file and the new time after using the `touch`
    command on it. You can also change the access time by using the `-a` option of
    the `touch` command. By default, the long listing of the `ls` command shows only
    the modification/creation time. If you want to see the access time, there is the
    `atime` parameter you can use with the `- time` option. See the example used in
    the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 命令还用于更改文件的修改时间，而不更改文件本身。请注意，当我们首次创建 `new-report` 文件时的初始时间与使用 `touch`
    命令之后的时间之间的差异。你还可以通过使用 `touch` 命令的 `-a` 选项来更改访问时间。默认情况下，`ls` 命令的长格式列表仅显示修改/创建时间。如果你想查看访问时间，可以使用
    `- time` 选项中的 `atime` 参数。请参见下面的示例：'
- en: '![Figure 2.9 – Using touch to alter the access time](img/Figure_02.09_B19682.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 使用 touch 命令修改访问时间](img/Figure_02.09_B19682.jpg)'
- en: Figure 2.9 – Using touch to alter the access time
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 使用 touch 命令修改访问时间
- en: The modification, creation, and access time stamps are very useful, especially
    when using commands such as `find`. They give you a more *granular* search pattern.
    We will get back to this command with more examples in future sections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 修改、创建和访问时间戳非常有用，特别是在使用 `find` 等命令时。它们为你提供了更 *细致* 的搜索模式。我们将在未来的章节中通过更多示例回到这个命令。
- en: 'Files can also be created by using redirection and the `echo` command. `echo`
    is a command that prints the string given as a parameter to the standard output
    (the screen). The output of the `echo` command can be written directly to a file
    by using the output redirection:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用重定向和 `echo` 命令来创建文件。`echo` 是一个将作为参数传递的字符串打印到标准输出（屏幕）的命令。`echo` 命令的输出可以通过使用输出重定向直接写入文件：
- en: '![Figure 2.10 – Using echo with output redirection](img/Figure_02.10_B19682.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 使用 echo 命令与输出重定向](img/Figure_02.10_B19682.jpg)'
- en: Figure 2.10 – Using echo with output redirection
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 使用 echo 命令与输出重定向
- en: In the preceding example, we redirected the text from the `echo` command to
    the presentation file. It did not exist at the beginning, so it was automatically
    created by the command. The first `echo` command added a line to the file by using
    the `>` operator. The second `echo` command appended a new line of text to the
    end of the file, by using the `>>` operator.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将 `echo` 命令的文本重定向到演示文件中。该文件最初并不存在，因此由命令自动创建。第一个 `echo` 命令使用 `>` 操作符向文件中添加了一行内容。第二个
    `echo` 命令使用 `>>` 操作符将新的一行文本追加到文件末尾。
- en: Listing files
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出文件
- en: 'We have already used some examples with the `ls` command before, so you are
    somewhat familiar with it. We covered the `-l` option as an example of the command’s
    structure. Thus, we will not cover it any further here. We will explore new options
    for this essential and useful command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经用过一些 `ls` 命令的示例，所以你对它有一定的了解。我们将 `-l` 选项作为命令结构的示例进行讲解，因此这里不再赘述。我们将探讨一些新的选项，这些选项对于这个基本而有用的命令非常重要：
- en: '`ls -lh`: The `-l` option lists the files in an extended format, while the
    `-h` option shows the size of the file in a human-readable format, with the size
    in kilobytes or megabytes rather than bytes.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -lh`：`-l` 选项以扩展格式列出文件，而 `-h` 选项以人类可读的格式显示文件大小，单位为千字节或兆字节，而不是字节。'
- en: '`ls -la`: The `-a` option shows all the files, including hidden ones. Combined
    with the `-l` option, the output will be a list of all the files and their details.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -la`：`-a` 选项显示所有文件，包括隐藏文件。与 `-l` 选项结合使用时，输出将是一个包含所有文件及其详细信息的列表。'
- en: '`ls -ltr`: The `-t` option sorts files by their modification time, showing
    the newest first. The `-r` option reverses the order of the sort.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -ltr`：`-t` 选项按修改时间排序文件，最新的文件排在最前面。`-r` 选项则是将排序顺序反转。'
- en: '`ls – lS`: The `-S` option sorts the files by their size, with the largest
    file first.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls –lS`：`-S` 选项按文件大小排序，最大的文件排在最前面。'
- en: '`ls -R`: The `-R` option shows the contents of the current or specified directory
    in recursive mode.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -R`：`-R` 选项以递归模式显示当前目录或指定目录的内容。'
- en: A method used frequently for listing files and directories is called `ls -la`
    command. Let’s look at it in detail here, even though we will discuss this thoroughly
    in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的列出文件和目录的方法是 `ls -la` 命令。让我们在这里详细看看它，尽管我们将在[*第 4 章*](B19682_04.xhtml#_idTextAnchor090)《用户与组管理》中详细讨论这个问题。
- en: 'One example of a long listing used on our home directory can be seen in *Figure
    2**.11*, when we compared the output of `ls -la` with the output of the `tree`
    command. The following code snippet is a short example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在家目录中使用长列表的一种示例可以在*图 2.11*中看到，当我们将 `ls -la` 的输出与 `tree` 命令的输出进行比较时。以下是一个简短的示例：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the output, the first row after the command shows the number of blocks inside
    the directory listed. After that, each line represents one file or subdirectory,
    with the following detailed information:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，命令后的第一行显示了目录中块的数量。之后，每一行代表一个文件或子目录，并显示以下详细信息：
- en: 'The first character is the type of the file: `d` for the directory, `:` for
    the file, `l` for a link, `c` for the character device, and `b` for the block
    device'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字符表示文件类型：`d` 代表目录，`:` 代表文件，`l` 代表链接，`c` 代表字符设备，`b` 代表块设备。
- en: The following nine characters represent the permissions (detailed in [*Chapter
    4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users* *and Groups*)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的九个字符表示文件的权限（详细内容见[*第 4 章*](B19682_04.xhtml#_idTextAnchor090)《用户与组管理》）。
- en: The hard link for that file (see the *Working with links* subsection in this
    chapter)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件的硬链接（请参阅本章中的*处理链接*小节）。
- en: The owner’s PID and GID (details in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing Users* *and Groups*)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件所有者的 PID 和 GID（详细内容见[*第 4 章*](B19682_04.xhtml#_idTextAnchor090)《用户与组管理》）。
- en: The size of the file (the number depends on whether it is in human-readable
    format or not)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的大小（该数字取决于是否采用人类可读格式）。
- en: The last modification time of the file
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的最后修改时间。
- en: The name of the file or directory
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件或目录的名称
- en: The first two lines are a reference to itself (the dot) and to the parent directory
    (the two dots from the second line).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行分别是对自身（点）和父目录（第二行中的两个点）的引用。
- en: The next section will teach you how to copy and move files.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将教你如何复制和移动文件。
- en: Copying and moving files
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制和移动文件
- en: To copy files in Linux, the `cp` command is used. The `mv` command moves files
    around the filesystem. This command is also used to rename files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，`cp` 命令用于复制文件。`mv` 命令用于在文件系统中移动文件。这个命令也可以用来重命名文件。
- en: 'To copy a file, you can use the `cp` command in the simplest way:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文件，你可以使用最简单的 `cp` 命令：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, `source_file_path` is the name of the file to be copied, and `destination_file_path`
    is the name of the destination file. You can also copy multiple files inside a
    directory that already exists. If the destination directory does not exist, the
    shell will signal to you that the target is not a directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`source_file_path` 是要复制的文件名，`destination_file_path` 是目标文件名。你也可以复制一个已存在目录中的多个文件。如果目标目录不存在，shell
    会提示你目标不是一个目录。
- en: 'Now let’s look at some variations of these commands:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看这些命令的一些变体：
- en: '`cp -a`: The `-a` option copies an entire directory hierarchy in recursive
    mode by preserving all the attributes and links. In the following example, we
    copied the entire `dir1` directory that we previously created inside our home
    directory, to a newly created directory called `backup_dir1` by using the `-``a`
    option:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -a`：`-a` 选项以递归模式复制整个目录层次结构，同时保留所有的属性和链接。在以下示例中，我们使用 `-a` 选项将之前在主目录中创建的
    `dir1` 目录完整复制到新创建的 `backup_dir1` 目录中：'
- en: '![Figure 2.11 – Using the copy command with the -a option](img/Figure_02.11_B19682.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 使用带有 -a 选项的复制命令](img/Figure_02.11_B19682.jpg)'
- en: Figure 2.11 – Using the copy command with the -a option
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 使用带有 -a 选项的复制命令
- en: '`cp -r`: This option is similar to `-a`, but it does not preserve attributes,
    only symbolic links.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -r`：这个选项类似于`-a`，但它不保留文件属性，仅保留符号链接。'
- en: '`cp -p`: The `-p` option retains the file’s permissions and timestamps. Otherwise,
    just by using `cp` in its simplest form, copies of the files will be owned by
    your user with a timestamp of the time you did the copy operation.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -p`：`-p` 选项保留文件的权限和时间戳。否则，使用最简单形式的 `cp` 命令进行复制时，文件副本将归当前用户所有，并且时间戳为你进行复制操作时的时间。'
- en: '`cp -R`: The `-R` option allows you to copy a directory recursively. In the
    following example, we will use the `ls` command to show you the contents of the
    `~/packt/` directory, and then the `cp -R` command to copy the contents of the
    `/files` directory to the `/new-files` one. The `/new-files` directory did not
    exist. The `cp -R` command created it:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp -R`：`-R` 选项允许你递归复制一个目录。在以下示例中，我们将使用 `ls` 命令显示 `~/packt/` 目录的内容，然后使用 `cp
    -R` 命令将 `/files` 目录的内容复制到 `/new-files` 目录。`/new-files` 目录之前并不存在。`cp -R` 命令创建了它：'
- en: '![Figure 2.12 – Using the cp -R command](img/Figure_02.12_B19682.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – 使用 cp -R 命令](img/Figure_02.12_B19682.jpg)'
- en: Figure 2.12 – Using the cp -R command
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – 使用 cp -R 命令
- en: 'Moving files around is done with the `mv` command. It is either used to move
    files and directories from one destination to another or to rename a file. The
    following is an example in which we rename `files1` into `old-files1` using the
    `mv` command: `mv` `files1 old-files1`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 移动文件是通过 `mv` 命令完成的。它用于将文件和目录从一个位置移动到另一个位置，或者用于重命名文件。以下是一个示例，我们使用 `mv` 命令将 `files1`
    重命名为 `old-files1`：`mv files1 old-files1`。
- en: There are many other options that you could learn about just by visiting the
    manual pages. Feel free to explore them and use them in your daily tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选项，你可以通过查阅手册页面来了解它们。随时可以探索它们，并将它们应用到你的日常任务中。
- en: Working with links
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理链接
- en: Links are a compelling option in Linux. They can be used as a means of protection
    for the original files, or just as a tool to keep multiple copies of a file without
    having separate hard copies. Consider it as a tool to create alternative names
    for the same file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 链接在 Linux 中是一个非常有用的选项。它们可以用来保护原始文件，或者作为一种工具，避免需要多个文件的独立副本。可以将它视为为同一文件创建不同名称的工具。
- en: 'The `ln` command can be used to do this and create two types of links:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`ln` 命令可用于创建两种类型的链接：'
- en: Symbolic links
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号链接
- en: Hard links
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接
- en: 'Those two links are different types of files that point to the original file.
    A **symbolic link** is a physical file that points to the original file; they
    are linked and have the same content. Also, it can span different filesystems
    and physical media, meaning that it can link to original files that are on other
    drives or partitions with different types of filesystems. The command used is
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种链接是不同类型的文件，指向原始文件。**符号链接**是一个指向原始文件的物理文件；它们是链接的并且具有相同的内容。此外，符号链接可以跨越不同的文件系统和物理介质，这意味着它可以链接到存储在其他驱动器或分区上的原始文件，且文件系统类型不同。使用的命令如下：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is an example in which we listed the contents of the `~/packt` directory
    and then created a symbolic link to the `new-report` file using the `ln -s` command
    and then listed the contents again:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，我们列出了`~/packt`目录的内容，然后使用`ln -s`命令为`new-report`文件创建了一个符号链接，并再次列出了目录内容：
- en: '![Figure 2.13 – Using symbolic links](img/Figure_02.13_B19682.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 使用符号链接](img/Figure_02.13_B19682.jpg)'
- en: Figure 2.13 – Using symbolic links
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 使用符号链接
- en: 'You can see that the link created is named `new-report-link` and is visually
    represented with an `->` arrow that shows the original file that it points to.
    You can also distinguish the difference in size between the two files, the link
    and the original one. The permissions are different too. This is a way to know
    that they are two *different* physical files. To double-check that they are different
    physical files, you can use the `ls -i` command to show the `new-report` and `new-report-link`
    have different inodes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，创建的链接名为`new-report-link`，并且通过`->`箭头的视觉表示，指向了原始文件。你还可以看出两个文件之间的大小差异，链接和原始文件的权限也不同。这表明它们是两个*不同*的物理文件。为了进一步确认它们是不同的物理文件，你可以使用`ls
    -i`命令查看`new-report`和`new-report-link`的inode不同：
- en: '![Figure 2.14 – Comparing the inodes for the symbolic link and original file](img/Figure_02.14_B19682.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 比较符号链接和原始文件的inode](img/Figure_02.14_B19682.jpg)'
- en: Figure 2.14 – Comparing the inodes for the symbolic link and original file
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 比较符号链接和原始文件的inode
- en: 'If you want to know where the link points to and you do not want to use `ls
    -l`, there is the `readlink` command. It is available in both Ubuntu and CentOS.
    The output of the command will simply be the name of the file that the symbolic
    link points to. It only works in the case of symbolic links:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道链接指向哪里，而又不想使用`ls -l`，可以使用`readlink`命令。它在Ubuntu和CentOS中都可用。该命令的输出将只是符号链接所指向的文件名。它只在符号链接的情况下有效：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, you can see that the output shows that the `new-report-link`
    file is a symbolic link to the file named `new-report`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到输出显示`new-report-link`文件是指向名为`new-report`的文件的符号链接。
- en: 'In contrast, a `ln` without any options:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`ln`命令如果没有任何选项：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following example, we created a hard link for the `new-report` file,
    and we named it `new-report-ln`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们为`new-report`文件创建了一个硬链接，并将其命名为`new-report-ln`：
- en: '![Figure 2.15 – Working with hard links](img/Figure_02.15_B19682.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – 使用硬链接](img/Figure_02.15_B19682.jpg)'
- en: Figure 2.15 – Working with hard links
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – 使用硬链接
- en: In the output, you will see that they have the same size and the same inode,
    and after altering the original file using `echo` and output redirection, the
    changes were available to both files. The two files have a different representation
    than symbolic links. They appear as two different files in your listing, with
    no visual aids to show which file is pointed to. Essentially, a hard link is linked
    to the inode of the original file. You can see it as a new name for a file, similar
    to but not identical to renaming it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，你会看到它们具有相同的大小和相同的inode，且在使用`echo`和输出重定向更改原始文件后，两个文件都能看到这些更改。这两个文件与符号链接的表示方式不同。它们在你的目录列表中会显示为两个不同的文件，且没有任何视觉标识来显示哪个文件被指向。实质上，硬链接是与原始文件的inode相连接的。你可以将其视为文件的新名称，类似于但不完全相同于重命名文件。
- en: Deleting files
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'In Linux, you have the remove (`rm`) command for deleting files. In its simplest
    form, the `rm` command is used without an option. For more control over how you
    delete items, you could use the `-i`, `-f`, and `-``r` options:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，删除文件可以使用`rm`命令。在最简单的形式下，`rm`命令是没有选项的。如果你想更精确地控制删除方式，可以使用`-i`、`-f`和`-r`选项：
- en: '`rm -i`: This option enables interactive mode by asking you for acceptance
    before deleting:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -i`：此选项启用交互模式，在删除前会要求你确认：'
- en: '![Figure 2.16 – Removing a file interactively](img/Figure_02.16_B19682.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.16 – 交互式删除文件](img/Figure_02.16_B19682.jpg)'
- en: Figure 2.16 – Removing a file interactively
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.16 – 交互式删除文件
- en: In the preceding example, we deleted `art-file` by using the `-i` option. When
    asked to interact, you have two options. You can approve the action by typing
    `y` (yes), or `n` (no) to cancel the action.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用 `-i` 选项删除了 `art-file`。在要求互动时，你有两个选择。你可以通过输入 `y` （是）来批准该操作，或者输入
    `n` （否）来取消该操作。
- en: '`rm -f` : The `-f` option deletes the file by force, without any interaction
    from the user:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -f` ：`-f` 选项会强制删除文件，无需用户互动：'
- en: '![Figure 2.17 – Force remove a file](img/Figure_02.17_B19682.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.17 – 强制删除文件](img/Figure_02.17_B19682.jpg)'
- en: Figure 2.17 – Force remove a file
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.17 – 强制删除文件
- en: We deleted the `new-report-link` file created earlier by using the `rm -f` command.
    It did not ask for our approval and deleted the file directly.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `rm -f` 命令删除了之前创建的 `new-report-link` 文件。该命令没有要求我们的确认，直接删除了文件。
- en: '`rm -r`: This option deletes the files in recursive mode, and it is used to
    delete multiple files and directories. For example, we will try to delete the
    `new-files` directory. When using the `rm` command in its simplest way, the output
    will show an error saying that it cannot delete a directory. But when used with
    the `-r` option, the directory is deleted right away:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -r` ：此选项以递归模式删除文件，用于删除多个文件和目录。例如，我们将尝试删除 `new-files` 目录。使用最简单的 `rm` 命令时，输出会显示错误，表示无法删除目录。但当与
    `-r` 选项一起使用时，目录会立即被删除：'
- en: '![Figure 2.18 – Remove a directory recursively](img/Figure_02.18_B19682.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.18 – 递归删除目录](img/Figure_02.18_B19682.jpg)'
- en: Figure 2.18 – Remove a directory recursively
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.18 – 递归删除目录
- en: Important note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We advise *extra caution* when using the `rm` command. The most destructive
    mode is to use `rm -rf`. This will delete files, directories, and anything without
    warning. Pay attention as there is no going back from this. Once used, the damage
    will be done.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用 `rm` 命令时要*格外小心*。最具破坏性的方法是使用 `rm -rf`。这将毫不警告地删除文件、目录及任何内容。请注意，一旦执行了此操作，无法恢复，后果将是不可挽回的。
- en: Most of the time, removing files is a one-way street, with no turning back.
    This makes the process of deleting files a very important one, and a backup before
    a deletion could save you a lot of unnecessary stress.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，删除文件是单向操作，无法回头。这使得删除文件的过程非常重要，在删除之前进行备份可以帮你避免许多不必要的压力。
- en: Creating directories
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建目录
- en: 'In Linux, you can create a new directory with the `mkdir` command. In the following
    example, we will create a new directory called `development`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，你可以使用 `mkdir` 命令创建新目录。在以下示例中，我们将创建一个名为 `development` 的新目录：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you want to create more directories and sub-directories at once, you will
    need to use the `-p` option (`p` from the parent), as shown in the following figure:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想一次创建多个目录和子目录，你需要使用 `-p` 选项（`p` 来自父目录），如以下图所示：
- en: '![Figure 2.19 – Creating parent directories](img/Figure_02.19_B19682.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.19 – 创建父目录](img/Figure_02.19_B19682.jpg)'
- en: Figure 2.19 – Creating parent directories
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.19 – 创建父目录
- en: Directories are files too in Linux, only that they have special attributes.
    They are essential to organizing your filesystem. For more options with this useful
    tool, feel free to visit the manual pages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，目录也是文件，只是它们具有特殊的属性。它们对于组织文件系统至关重要。如需了解更多此有用工具的选项，欢迎查阅手册页面。
- en: Deleting directories
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除目录
- en: 'The Linux command for removing directories is called `rmdir`. It is designed
    to default by deleting only empty directories. Let’s see what happens if we try
    to delete a directory that is not empty:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中删除目录的命令是 `rmdir`。它默认只删除空目录。让我们看看如果尝试删除一个非空目录会发生什么：
- en: '![Figure 2.20 – Using the rmdir command](img/Figure_02.20_B19682.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 使用 rmdir 命令](img/Figure_02.20_B19682.jpg)'
- en: Figure 2.20 – Using the rmdir command
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 使用 rmdir 命令
- en: This is a precautionary measure from the shell, as deleting a directory that
    is not empty could have disastrous consequences, as we’ve seen when using the
    `rm` command. The `rmdir` command does not have a `-i` option such as `rm`. The
    only way to delete the directory using the `rmdir` command is to delete files
    inside it first manually. However, the `rm -r` command shown earlier is still
    useful and more versatile when deleting directories.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 shell 的一种预防性措施，因为删除一个非空目录可能会产生灾难性的后果，正如我们在使用`rm`命令时所看到的那样。`rmdir`命令不像`rm`那样有`-i`选项。使用`rmdir`命令删除目录的唯一方法是先手动删除目录中的文件。然而，前面展示的`rm
    -r`命令在删除目录时仍然有用且更具灵活性。
- en: Now that you know how to work with directories in Linux, we will proceed to
    show you commands for file viewing.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何在 Linux 中操作目录了，我们将继续展示文件查看命令。
- en: Commands for file viewing
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件查看命令
- en: As everything in Linux is a file, being able to view and work with file contents
    is an essential asset for any system administrator. In this section, we will learn
    commands for file viewing, as almost all files contain text that, at some point,
    should be readable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 中的一切都是文件，能够查看和操作文件内容是任何系统管理员的必备技能。在这一节中，我们将学习文件查看命令，因为几乎所有的文件都包含文本，某个时刻这些文本都应该是可读的。
- en: The cat command
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`cat`命令'
- en: 'This command was used in some of our previous examples in this chapter. It
    is short for *concatenate* and is used to print the contents of the file to the
    screen. We have used `cat` several times during this chapter, but here is yet
    another example. We have two existing files, one called `new-report` and the other
    called `users`. Let us show you how to use `cat` in the following image:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在本章之前的一些示例中已经使用过。它是*concatenate*（拼接）的缩写，用来将文件内容打印到屏幕上。我们在本章中已经多次使用了`cat`，这里再举一个例子。我们有两个现有文件，一个叫`new-report`，另一个叫`users`。让我们通过以下图示来展示如何使用`cat`：
- en: '![Figure 2.21 – Example of using the cat command](img/Figure_02.21_B19682.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 使用`cat`命令的示例](img/Figure_02.21_B19682.jpg)'
- en: Figure 2.21 – Example of using the cat command
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 使用`cat`命令的示例
- en: In this example, we first used the command to show the contents of only one
    file, the one called `new-report`. The second command was used to show the contents
    of two files at once, both `new-report` and `users`. The `cat` command is showing
    the contents of both on the screen. Both files are located in the same directory,
    which is also the user’s working directory. If you would like to concatenate the
    contents of files that are not inside your present working directory, you would
    need to use their absolute path.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用命令显示了仅一个文件`new-report`的内容。第二个命令则用来同时显示两个文件`new-report`和`users`的内容。`cat`命令将这两个文件的内容显示在屏幕上。两个文件都位于同一目录中，也就是用户的工作目录。如果你想拼接那些不在当前工作目录中的文件内容，你需要使用它们的绝对路径。
- en: The `cat` command has several options available, which we will not cover here,
    as most of the time, its purest form will be the most used. For more details,
    see the manual pages.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令有多个可用选项，我们这里不作详细介绍，因为在大多数情况下，它最纯粹的形式是最常用的。更多详情请参阅手册页。'
- en: The less command
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`less`命令'
- en: 'There are times when a file has so much text that it will cover many screens,
    and it will be difficult to view on your terminal using just `cat`. This is where
    the `less` command is handy. It shows one screen at a time. How much a screen
    means, it all depends on the size of your terminal window. Let’s take, for example,
    the `/etc/passwd` file. It could have multiple lines that you would not be able
    to fit in just one screen. You could use the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，文件的内容太多，会占据多个屏幕，单纯用`cat`命令在终端上查看很困难。这时，`less`命令就派上用场了。它一次只显示一个屏幕的内容。一个屏幕显示多少内容，取决于你的终端窗口的大小。以`/etc/passwd`文件为例，它可能包含多行内容，无法完全显示在一个屏幕上。你可以使用以下命令：
- en: '[PRE25]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you press *Enter*, the contents of the file will be shown on your screen.
    To navigate through it, you could use the following keys:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下*Enter*时，文件的内容将显示在你的屏幕上。要在其中浏览，你可以使用以下按键：
- en: 'Space bar: Move forward one screen'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格键：向前移动一个屏幕
- en: '*Enter*: Move forward one line'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Enter*: 向前移动一行'
- en: '*b*: Move backward one screen'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*b*: 向后移动一个屏幕'
- en: '*/*: Enter search mode; this searches forward in your file'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/*: 进入搜索模式；在文件中向前搜索'
- en: '*?*: Search mode; this searches backward in your file'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*?*: 搜索模式；在文件中向后搜索'
- en: '*v*: Edit your file with the default editor'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v*: 使用默认编辑器编辑文件'
- en: '*g*: Jump to the beginning of the file'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*g*: 跳转到文件开头'
- en: '*Shift* + *g*: Jump to the end of the file'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shift* + *g*：跳转到文件末尾'
- en: '*q*: Exit the output.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*：退出输出。'
- en: The `less` command has a multitude of options that could be used. We advise
    you to consult the manual pages to find out more information about this command.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 命令有许多可以使用的选项。我们建议你查阅手册页，了解更多关于该命令的信息。'
- en: The head command
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: head 命令
- en: 'This command is handy when you only want to print to the screen the beginning
    (the head) of a text file. By default, it will print only the first 10 lines of
    the file. You can use the same `/etc/passwd` file for the head exercise and execute
    the following command. Watch what happens. It prints the first 10 lines and then
    exits the command, taking you back to the shell prompt:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想将文本文件的开头（头部）打印到屏幕时，这个命令非常有用。默认情况下，它只会打印文件的前 10 行。你可以使用相同的 `/etc/passwd`
    文件来进行 head 操作，并执行以下命令。观察发生的情况。它会打印前 10 行，然后退出命令，带你回到 shell 提示符：
- en: '[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One useful option of this command is to print more or less than 10 lines of
    the file. For this, you can use the `-n` argument or simply just `–` with the
    number of lines you want to print. For the `/etc/passwd` file, we will first use
    the head command without any options, and then we will use it with the number
    of lines argument, as shown in the following figure:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的一个有用选项是打印文件的多行或少行。为此，你可以使用 `-n` 参数，或者直接使用 `–` 后跟你想打印的行数。对于 `/etc/passwd`
    文件，我们首先使用没有任何选项的 head 命令，然后使用带有行数参数的命令，如下图所示：
- en: '![Figure 2.22 – Using the head command](img/Figure_02.22_B19682.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 使用 head 命令](img/Figure_02.22_B19682.jpg)'
- en: Figure 2.22 – Using the head command
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 使用 head 命令
- en: Many other options that this command provides can prove useful for your work
    as a system administrator, but we will not cover them here. Feel free to explore
    them yourself.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提供的许多其他选项对于作为系统管理员的工作非常有用，但我们在此不会涵盖它们。你可以自行探索。
- en: The tail command
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tail 命令
- en: 'The `tail` command is similar to the `head` command, only it prints the last
    10 lines of a file, by default. You can use the same `-n` argument as for the
    head command, to see a specific number of lines from the end of a file. However,
    the `tail` command is commonly used for actively watching log files that are constantly
    changing. It can print the last lines of the file as other applications are writing
    to it. Take, for example, the following line:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail` 命令与 `head` 命令类似，只不过它默认打印文件的最后 10 行。你可以使用与 head 命令相同的 `-n` 参数，以查看文件末尾的特定行数。然而，`tail`
    命令通常用于实时监视不断变化的日志文件。它可以在其他应用程序写入文件时打印文件的最后几行。例如，考虑以下行：'
- en: '[PRE27]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the `-f` option will make the command watch the `/var/log/syslog` file
    as it is being written. It will show you the contents of the file on the screen
    effectively. The `-f` option will cause the tail command to stop during a log
    rotation, and in this case, the `-F` option should be used instead. When using
    the `-F` option, the command will continue to show the output even during a log
    rotation. To exit that screen, you will need to press *Ctrl* + *C* to go back
    to the shell prompt. The following is an example of the output of the previous
    command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-f` 选项将使该命令在写入 `/var/log/syslog` 文件时进行监视。它将有效地在屏幕上显示文件内容。`-f` 选项会导致 tail
    命令在日志轮换时停止，这时应该使用 `-F` 选项。使用 `-F` 选项时，命令会在日志轮换期间继续显示输出。要退出该屏幕，你需要按 *Ctrl* + *C*
    返回到 shell 提示符。以下是前述命令输出的示例：
- en: '![Figure 2.23 – The use of tail command for real-time log  file observation](img/Figure_02.23_B19682.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.23 – 使用 tail 命令进行实时日志文件观察](img/Figure_02.23_B19682.jpg)'
- en: Figure 2.23 – The use of tail command for real-time log file observation
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.23 – 使用 tail 命令进行实时日志文件观察
- en: Next, let us learn how to view file properties in Linux.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解如何在 Linux 中查看文件属性。
- en: Commands for file properties
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件属性命令
- en: There could be times when just viewing the contents of a file is not enough,
    and you need extra information about that file. There are other handy commands
    that you could use, and we describe them in the following sections.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，仅查看文件内容是不够的，你可能需要该文件的额外信息。还有其他一些实用的命令可以使用，我们将在接下来的部分中介绍它们。
- en: The stat command
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: stat 命令
- en: 'The `stat` command gives you more information than the `ls` command does. The
    example in the following figure shows a comparison between the `ls` and `stat`
    outputs for the same file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat` 命令提供比 `ls` 命令更多的信息。下面的示例展示了对于同一文件，`ls` 和 `stat` 输出的对比：'
- en: '![Figure 2.24 – Using the stat command](img/Figure_02.24_B19682.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.24 – 使用 stat 命令](img/Figure_02.24_B19682.jpg)'
- en: Figure 2.24 – Using the stat command
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.24 – 使用 stat 命令
- en: The `stat` command gives you more information about the name, size, number of
    blocks, type of file, inode, number of links, permissions, UID and GID, and `atime`,
    `mtime`, and `ctime`. To find out more information about it, please refer to the
    Linux manual pages.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat`命令可以提供有关文件名、大小、块数、文件类型、inode、链接数、权限、UID 和 GID，以及`atime`、`mtime`和`ctime`的更多信息。如需了解更多信息，请参考
    Linux 手册页。'
- en: The file command
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件命令
- en: 'This command simply reports on the type of file. Here is an example of a text
    file and a command file:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只是报告文件的类型。这里有一个文本文件和一个命令文件的示例：
- en: '![Figure 2.25 – Using the file command](img/Figure_02.25_B19682.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.25 – 使用 file 命令](img/Figure_02.25_B19682.jpg)'
- en: Figure 2.25 – Using the file command
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.25 – 使用 file 命令
- en: Linux does not rely on file extensions and types as some other operating systems
    do. In this respect, the `file` command determines the file type more by its contents
    than anything else.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 不像其他操作系统那样依赖文件扩展名和类型。在这方面，`file`命令更侧重于根据文件内容来确定文件类型，而非其他。
- en: Commands for configuring file ownership and permissions
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件所有权和权限的命令
- en: In Linux, `chown` command. When setting up group ownership, you determine the
    permissions for everyone in that group. This is set up using the `chgrp` command.
    When it comes to other users, the reference is to everyone else on that system,
    someone who did not create the file, so it is not the owner, and who does not
    belong to the owner’s group. Other is also known as, or referred to as the world.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，使用`chown`命令。当设置组所有权时，你可以为该组中的所有人确定权限。这是通过使用`chgrp`命令来设置的。至于其他用户，指的是该系统中其他任何人，即那些没有创建文件、不是文件所有者并且不属于文件所有者所在组的人。其他用户也被称为“世界”。
- en: 'Besides setting user ownership, the system must know how to determine user
    behavior, and it does that through the use of `ls -``l` command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置用户所有权，系统还必须知道如何确定用户行为，而它是通过使用`ls -l`命令来实现的：
- en: '![Figure 2.26 – Long listing output](img/Figure_02.26_B19682.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.26 – 长格式列出输出](img/Figure_02.26_B19682.jpg)'
- en: Figure 2.26 – Long listing output
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.26 – 长格式列出输出
- en: 'In the preceding examples, you see two different types of permissions for the
    files inside our home directory. Each line has 12 characters reserved for special
    attributes and permissions. Out of those 12, only 10 are used in the preceding
    examples. Nine of them represent the permissions, and the first one is the file
    type. There are three easy-to-remember abbreviations for permissions:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你会看到我们家目录中的文件有两种不同类型的权限。每行都有12个字符，分别用于特殊属性和权限。在这12个字符中，前10个被用于前面的示例。九个字符表示权限，第一个字符表示文件类型。权限有三个容易记住的缩写：
- en: '`r` is for `read` permission'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`表示`读`权限'
- en: '`w` is for `write` permission'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`表示`写`权限'
- en: '`x` is for `execute` permission'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`表示`执行`权限'
- en: '`-` is for no permission'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`表示没有权限'
- en: The nine characters are divided into three regions, each consisting of three
    characters. The first three characters are reserved for user permissions, the
    following three characters are reserved for group permissions, and the last three
    characters represent other, or global permissions.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这九个字符被分为三个区域，每个区域由三个字符组成。前三个字符用于用户权限，接下来的三个字符用于组权限，最后三个字符代表其他权限，或称全局权限。
- en: 'File types also have their codes, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型也有它们的代码，具体如下：
- en: '`d`: The letter `d` shows that it is a directory'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：字母`d`表示这是一个目录'
- en: '`-`: The hyphen shows that it is a file'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：连字符表示这是一个文件'
- en: '`l`: The letter `l` shows that it is a symbolic link'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：字母`l`表示这是一个符号链接'
- en: '`p`: The letter `p` shows that it is a named pipe; a special file that facilitates
    the communication between programs'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：字母`p`表示这是一个命名管道；一个特殊文件，方便程序间的通信'
- en: '`s`: The letter `s` shows that it is a socket, similar to the pipe but with
    bi-directional and network communications'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：字母`s`表示这是一个套接字，类似于管道，但具有双向和网络通信功能'
- en: '`b`: The letter `b` shows that it is a block device; a file that corresponds
    to a hardware device'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：字母`b`表示这是一个块设备；一个对应硬件设备的文件'
- en: '`c`: The letter `c` shows that it is a character device; similar to a block
    device'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：字母`c`表示这是一个字符设备；类似于块设备'
- en: 'The permission string is a 10-bit string. The first bit is reserved for the
    file type. The next nine bits determine the permissions by dividing them into
    3-bit packets. Each packet is expressed by an **octal number** (because an octal
    number has three bytes). Thus, permissions are represented using a power of two:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 权限字符串是一个10位的字符串。第一位用于文件类型。接下来的九位通过分成3位一组来表示权限。每组由一个**八进制数**表示（因为八进制数有三位）。因此，权限是用二的幂来表示的：
- en: '`read` is 2 ^ 2 (two to the power of two), which equals 4'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read` 是 2 ^ 2（2 的幂），等于 4'
- en: '`write` is 2 ^ 1 (two to the power of one), which equals 2'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write` 是 2 ^ 1（1 的幂），等于 2'
- en: '`execute` is 2 ^ 0 (two to the power of zero), which equals 1'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute` 是 2 ^ 0（零的幂），等于 1'
- en: 'In this respect, file permissions should be represented according to the following
    diagram:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，文件权限应按以下图示表示：
- en: '![Figure 2.27 – File permissions explained](img/Figure_02.27_B19682.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.27 – 文件权限解释](img/Figure_02.27_B19682.jpg)'
- en: Figure 2.27 – File permissions explained
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.27 – 文件权限解释
- en: In the preceding diagram, you have the permissions shown as a string of nine
    characters, just like you would see them in the `ls -la` output. The row is divided
    into three different sections, one for owner/user, one for group, and one for
    other/world. These are shown in the first two rows. The other two rows show you
    the types of permissions (`read`, `write`, and `execute`) and the octal numbers
    in the following paragraph.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图示中，权限以九个字符的字符串显示，正如你在 `ls -la` 输出中看到的那样。该行被分为三个部分，一个是用户/所有者的权限，一个是组的权限，另一个是其他/世界的权限。这些信息在前两行中展示。其他两行展示了权限的类型（`read`、`write`
    和 `execute`），以及下文中提到的八进制数。
- en: This is useful as it relates the octal representations to the character representations
    of permissions. Thus, if you were to translate a permission shown as `rwx r-x`
    into octal, based on the preceding diagram, you could easily say it is `755`.
    This is because, for the first group, the owner, you have all of them active (`rwx`),
    which translates into *4+2+1=7*. For the second group, you have only two permissions
    active, `r` and `x`, which translates into *4+1=5*. Finally, for the last group,
    you have also two permissions active, similar to the second group (`r` and `x`),
    which translates to *4+1=5*. Now you know that the permission in the octal is
    `755`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为它将八进制表示与字符表示的权限关联起来。因此，如果你将一个权限表示为 `rwx r-x` 转换为八进制，依据前面的图示，你可以轻松地说它是
    `755`。这是因为，对于第一个组，即所有者，你有所有权限（`rwx`），这转换为 *4+2+1=7*。对于第二个组，你只有两个权限是激活的，`r` 和 `x`，这转换为
    *4+1=5*。最后，对于第三组，你也有两个权限是激活的，类似于第二组（`r` 和 `x`），这也转换为 *4+1=5*。现在你知道，该权限的八进制表示是
    `755`。
- en: 'As an exercise, you should try to translate into octal the following permissions:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你应该尝试将以下权限转换为八进制：
- en: '`rwx rwx`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx rwx`'
- en: '`rwx r-x`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx r-x`'
- en: '`rwx r-x - - -`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx r-x - - -`'
- en: '`rwx - - - - - -`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx - - - - - -`'
- en: '`rw-` `rw- rw-`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw-` `rw- rw-`'
- en: '`rw- rw- r - -`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw- rw- r - -`'
- en: '`rw- rw- - - -`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw- rw- - - -`'
- en: '`rw- r- -` `r- -`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw- r- -` `r- -`'
- en: '`rw- r- - - - -`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw- r- - - - -`'
- en: '`rw- - - - - - -`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw- - - - - - -`'
- en: '`r - - - - - - - -`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r - - - - - - - -`'
- en: Important note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: There are some other vital commands such as `umask`, `chown`, `chmod`, and `chgrp`,
    which are used to change or set the default creation mode, owner, mode (access
    permissions), and group, respectively. They will be briefly introduced here as
    they involve setting the file’s properties, but for a more detailed description,
    please refer to [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090), *Managing Users*
    *and Groups*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他重要的命令，如 `umask`、`chown`、`chmod` 和 `chgrp`，分别用于更改或设置默认创建模式、所有者、模式（访问权限）和组。它们将在此简要介绍，因为它们涉及到设置文件的属性，但要了解更详细的描述，请参考[*第4章*](B19682_04.xhtml#_idTextAnchor090)，*用户*和*组的管理*。
- en: Commands for file compression, uncompression, and archiving
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件压缩、解压缩和归档的命令
- en: In Linux, the standard tool for archiving is called `tar`, from tape archive.
    It was initially used in Unix to write files to external tape devices for archiving.
    Nowadays, in Linux, it is also used to write to a file in a compressed format.
    Other popular formats, apart from `tar` archives, are `gzip` and `bzip` for compressed
    archives, together with the popular `zip` from Windows. Now let’s look at the
    `tar` command in detail.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，标准的归档工具叫做 `tar`，即磁带归档。最初用于 Unix 中将文件写入外部磁带设备进行归档。如今，在 Linux 中，它也用于将文件以压缩格式写入文件。除了
    `tar` 归档格式，其他常用的压缩归档格式包括 `gzip` 和 `bzip`，以及 Windows 系统中的流行格式 `zip`。现在我们来详细了解一下
    `tar` 命令。
- en: The tar command for compressing and un-compressing
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于压缩和解压的 tar 命令
- en: 'This command is used with options and does not offer compression by default.
    To use compression, we would need to use specific options. Here are some of the
    most useful arguments available for `tar`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令需要与选项一起使用，默认情况下不提供压缩功能。要使用压缩，我们需要使用特定的选项。以下是 `tar` 提供的一些最有用的选项：
- en: '`tar -c`: Creates an archive'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -c`：创建归档文件'
- en: '`tar -r`: Appends files to an already existing archive'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -r`：将文件追加到已有的归档文件中'
- en: '`tar -u`: Appends only changed files to an existing archive'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -u`：只将已更改的文件追加到现有的归档文件中'
- en: '`tar -A`: Appends an archive to the end of another archive'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -A`：将归档追加到另一个归档的末尾'
- en: '`tar -t`: Lists the contents of the archive'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -t`：列出归档文件的内容'
- en: '`tar -x`: Extracts the archive contents'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -x`：提取归档文件内容'
- en: '`tar -z`: Uses `gzip` compression for the archive'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -z`：使用 `gzip` 压缩归档文件'
- en: '`tar -j`: Uses `bzip2` compression for the archive'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -j`：使用 `bzip2` 压缩归档文件'
- en: '`tar -v`: Uses verbose mode by printing extra information on the screen'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -v`：使用详细模式，在屏幕上打印额外的信息'
- en: '`tar -p`: Restores original permission and ownership for the extracted files'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -p`：恢复提取文件的原始权限和所有权'
- en: '`tar -f`: Specifies the name of the output file'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -f`：指定输出文件的名称'
- en: There is a chance that in your daily tasks, you will have to use these arguments
    in combination with each other.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常任务中，你可能会需要将这些选项组合使用。
- en: 'For example, to create an archive of the `files` directory, we used the `-cvf`
    arguments combined, as shown here:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个 `files` 目录的归档文件，我们可以将 `-cvf` 选项组合使用，示例如下：
- en: '![Figure 2.28 – Using the tar command](img/Figure_02.28_B19682.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.28 – 使用 tar 命令](img/Figure_02.28_B19682.jpg)'
- en: Figure 2.28 – Using the tar command
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.28 – 使用 tar 命令
- en: 'The archive created is not compressed. To use compression, we would need to
    add the `-z` or `-j` arguments. Next, we will use the `-z` option for the `gzip`
    compression algorithm. See the following example and compare the size of the two
    archive files. As a general rule, it is advised to use an extension for such files:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的归档文件未压缩。要使用压缩，我们需要添加 `-z` 或 `-j` 选项。接下来，我们将使用 `-z` 选项来进行 `gzip` 压缩。请参见以下示例，并比较两个归档文件的大小。一般来说，建议为此类文件使用扩展名：
- en: '![Figure 2.29 – Compressing a tar archive using gzip](img/Figure_02.29_B19682.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.29 – 使用 gzip 压缩 tar 文件](img/Figure_02.29_B19682.jpg)'
- en: Figure 2.29 – Compressing a tar archive using gzip
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.29 – 使用 gzip 压缩 tar 文件
- en: 'To uncompress a tar archive, you can use the `-x` option (shown at the beginning
    of this subsection). For example, let us uncompress the `files-archive.tar` file
    that we created earlier in this subsection, and also add a target directory for
    the uncompressed files to be added to by using the `-C` option. The target directory
    needs to be created beforehand. To do this, we will use the following commands:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压一个 tar 归档文件，你可以使用 `-x` 选项（如本小节开头所示）。例如，我们可以解压我们在本小节前面创建的 `files-archive.tar`
    文件，并使用 `-C` 选项指定解压后的文件存放目标目录。目标目录需要事先创建。我们将使用以下命令：
- en: '[PRE28]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will extract the files from the archive and add them to the uncompressed-directory
    directory. To uncompress a `gzip`-compressed archive, for example, `files-archive-gzipped.tar.gz`,
    we will add the `-z` option to the ones already used in the previous command,
    as shown in the following snippet:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从归档中提取文件，并将它们添加到未压缩目录中。例如，要解压一个 `gzip` 压缩的归档文件，如 `files-archive-gzipped.tar.gz`，我们将添加
    `-z` 选项，并结合前面的命令使用，示例如下：
- en: '[PRE29]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There you go, now you know how to archive and unarchive files in Linux. There
    are other useful archiving tools in Linux, but `tar` is still the most commonly
    used one. Feel free to explore the others or other useful options for `tar`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，现在你知道如何在 Linux 中归档和解压文件了。Linux 中还有其他有用的归档工具，但 `tar` 仍然是最常用的。你可以自由探索其他工具或
    `tar` 的其他有用选项。
- en: Commands for locating files
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找文件的命令
- en: Locating files in Linux is an essential task for any system administrator. As
    Linux systems contain vast numbers of files, finding files might be an intimidating
    task. Nevertheless, you have handy tools at your disposal, and knowing how to
    use them will be one of your greatest assets. Among these commands, we will discuss
    `locate`, `which`, `whereis`, and `find` in the following sections.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中查找文件是任何系统管理员的重要任务。由于 Linux 系统包含大量文件，查找文件可能是一个让人头疼的任务。不过，你手头有许多有用的工具，学会如何使用它们将是你最大的资产之一。在接下来的章节中，我们将讨论
    `locate`、`which`、`whereis` 和 `find` 等命令。
- en: The locate command
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: locate 命令
- en: 'The `locate` command is not installed by default on Ubuntu. To install it,
    use the following command to create an index of all the file locations on your
    system:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`locate` 命令在 Ubuntu 中默认未安装。要安装它，请使用以下命令创建系统上所有文件位置的索引：'
- en: '[PRE30]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Thus, when you execute the command, it searches for your file inside the database.
    It uses the `updatedb` command as its partner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你执行该命令时，它会在数据库中搜索你的文件。它使用 `updatedb` 命令作为辅助工具。
- en: 'Before starting to use the locate command, you should execute `updatedb` to
    update the location database. After you do that, you can start locating files.
    In the following example, we will locate any file that has `new-report` in its
    name:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 locate 命令之前，你应该先执行 `updatedb` 来更新位置数据库。更新后，你可以开始定位文件。在以下示例中，我们将定位任何文件，其名称中包含
    `new-report`：
- en: '![Figure 2.30 – Using the locate command](img/Figure_02.30_B19682.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.30 – 使用 locate 命令](img/Figure_02.30_B19682.jpg)'
- en: Figure 2.30 – Using the locate command
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.30 – 使用 locate 命令
- en: 'If we were to search for a file with a more generic name, such as `presentation`,
    the output would be too long and irrelevant. Here is an example where we used
    output redirection to a file and the `wc` (word count) command to show only the
    number of lines, words, and bytes of the file to the standard output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们搜索一个更通用的文件名，例如 `presentation`，输出会过长且不相关。以下是一个示例，我们使用了输出重定向到文件并使用 `wc`（字数统计）命令仅显示文件的行数、单词数和字节数：
- en: '![Figure 2.31 – Using the locate command with output redirection and the wc
    command](img/Figure_02.31_B19682.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.31 – 使用 locate 命令并进行输出重定向和 wc 命令](img/Figure_02.31_B19682.jpg)'
- en: Figure 2.31 – Using the locate command with output redirection and the wc command
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.31 – 使用 locate 命令并进行输出重定向和 wc 命令
- en: In the preceding output, the resulting file has eight lines. This means that
    there were eight files located that have the string `presentation` in their name.
    The exact number is used for the words inside the file, as there are no spaces
    between the paths, so every line is detected as a single word. Also, the resulting
    file has 663 bytes. Feel free to experiment with other strings. For more options
    for the `locate` command, please refer to the Linux manual pages.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，结果文件有八行。这意味着找到了八个文件，它们的文件名中包含字符串 `presentation`。确切的数字是针对文件中的单词，因为路径之间没有空格，所以每一行都会被检测为一个单独的单词。此外，结果文件的大小是
    663 字节。你可以尝试使用其他字符串。有关 `locate` 命令的更多选项，请参考 Linux 手册页面。
- en: The which command
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: which 命令
- en: 'This command locates an executable file (program or command) in the shell’s
    search path. For example, to locate the `ls` command, type the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令用于定位 shell 搜索路径中的可执行文件（程序或命令）。例如，要定位 `ls` 命令，输入以下内容：
- en: '[PRE31]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You see that the output is the path of the `ls` command: `/usr/bin/ls`.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到输出是 `ls` 命令的路径：`/usr/bin/ls`。
- en: 'Now try it with the `cd` command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用 `cd` 命令：
- en: '[PRE32]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You will see that there is no output. This is because the `cd` command is built
    inside the shell and has no other location for the command to show.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到没有任何输出。这是因为 `cd` 命令是内建的 shell 命令，没有其他位置可以显示该命令。
- en: The whereis command
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: whereis 命令
- en: 'This command finds *only* executable files, documentation files, and source
    code files. Therefore, it might not find what you want, so use it with caution:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令*仅*查找可执行文件、文档文件和源代码文件。因此，它可能无法找到你想要的文件，请谨慎使用：
- en: '![Figure 2.32 – Using the whereis command](img/Figure_02.32_B19682.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.32 – 使用 whereis 命令](img/Figure_02.32_B19682.jpg)'
- en: Figure 2.32 – Using the whereis command
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 – 使用 whereis 命令
- en: Once again, the output for the `cd` command shows nothing relevant, as it is
    a built-in shell command. As for the `ls` command, the output shows the location
    of the command itself and the location of the manual pages.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`cd` 命令的输出没有显示任何相关内容，因为它是一个内建的 shell 命令。至于 `ls` 命令，输出显示了该命令本身的位置以及手册页面的位置。
- en: The find command
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: find 命令
- en: This command is one of the most powerful commands in Linux. It can search for
    files in directories and subdirectories based on certain criteria. It has more
    than 50 options. Its main drawback is the syntax, as it is somehow different from
    other Linux commands. The best way to learn how the `find` command works is by
    example. This is why we will show you a large number of examples using this command,
    hoping that you will become proficient in using it. To see its powerful options,
    please refer to the manual pages.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令是 Linux 中最强大的命令之一。它可以根据特定的标准在目录和子目录中查找文件，具有超过 50 个选项。它的主要缺点是语法，因为它与其他 Linux
    命令有所不同。学习 `find` 命令的最佳方法是通过示例。因此，我们将通过大量示例来展示这个命令，希望你能熟练掌握它的使用。要了解它的强大选项，请参考手册页。
- en: The following is a series of exercises using the `find` command, that we thought
    would be useful for you to know. We will provide the commands to use, but we will
    not provide you with all the resulting outputs, as some can be fairly long.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些使用 `find` 命令的练习，我们认为这些对你非常有用。我们将提供使用的命令，但不会提供所有的输出结果，因为有些结果可能非常长。
- en: 'Find, inside the root directory, all the files that have the `e100` string
    in the name and print them to the standard output:'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录下查找所有文件名中包含`e100`字符串的文件，并将它们打印到标准输出：
- en: '[PRE33]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Find, inside the root directory, all the files that have the `file` string
    in their name and are of type `file`, and print the results to the standard output:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录下查找所有文件名中包含`file`字符串且类型为`file`的文件，并将结果打印到标准输出：
- en: '[PRE34]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Find all the files that have the `print` string in their name, by looking only
    inside the `/opt`, `/usr`, and `/``var` directories:'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有文件名中包含`print`字符串的文件，仅在`/opt`、`/usr` 和 `/var` 目录中查找：
- en: '[PRE35]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find all the files in the root directory that have the `.``conf` extension:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有扩展名为 `.conf` 的文件：
- en: '[PRE36]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Find all the files in the root directory that have the `file` string in their
    name and no extension:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有文件名中包含`file`字符串且没有扩展名的文件：
- en: '[PRE37]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Find, in the root directory, all the files with the following extensions: `.c`,
    `.sh`, and `.py`, and add the list to a file named `findfile`:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中查找所有具有以下扩展名的文件：`.c`、`.sh` 和 `.py`，并将列表添加到名为 `findfile` 的文件中：
- en: '[PRE38]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Find, in the root directory, all the files with the `.c` extension, sort them,
    and add them to a file:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根目录中查找所有 `.c` 扩展名的文件，对其进行排序，并将其添加到一个文件中：
- en: '[PRE39]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Find all the files in the root directory, with the permission set to `0664`:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有权限设置为 `0664` 的文件：
- en: '[PRE40]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Find all the files in the root directory that are read-only (have read-only
    permission) for their owner:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有所有者具有只读权限的文件：
- en: '[PRE41]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Find all the files in the root directory that are executable:'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有可执行的文件：
- en: '[PRE42]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Find all the files inside the root directory that were modified two days ago:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中所有在两天前修改过的文件：
- en: '[PRE43]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Find all the files in the root directory that have been accessed in the last
    two days:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找根目录中在过去两天内被访问过的所有文件：
- en: '[PRE44]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Find all the files that have been modified in the last two to five days:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有在过去两到五天内修改过的文件：
- en: '[PRE45]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Find all the files that have been modified in the last 10 minutes:'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有在过去 10 分钟内修改过的文件：
- en: '[PRE46]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Find all the files that have been created in the last 10 minutes:'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有在过去 10 分钟内创建的文件：
- en: '[PRE47]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Find all the files that have been accessed in the last 10 minutes:'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有在过去 10 分钟内被访问过的文件：
- en: '[PRE48]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Find all the files that are 5 MB in size:'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有大小为 5 MB 的文件：
- en: '[PRE49]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Find all the files that have a size between 5 and 10 MB:'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有大小在 5 MB 到 10 MB 之间的文件：
- en: '[PRE50]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Find all the empty files and empty directories:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有空文件和空目录：
- en: '[PRE51]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Find all the largest files in the `/etc` directory and print to the standard
    output the first five. Please take into account that this command could be very
    resource heavy. Do not try to do this for your entire root directory, as you might
    run out of system memory:'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找`/etc`目录中所有最大的文件，并将前五个打印到标准输出。请注意，这个命令可能会占用大量系统资源。不要尝试对整个根目录执行此操作，因为可能会耗尽系统内存：
- en: '[PRE52]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Find the smallest first five files in `/``etc` directory:'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找 `/etc` 目录中最小的前五个文件：
- en: '[PRE53]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Feel free to experiment with as many types of find options as you want. The
    command is very permissive and powerful. Use it with caution.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试你想要的所有类型的 `find` 选项。这个命令非常灵活且强大，但使用时需要小心。
- en: Commands for text manipulation
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本处理命令
- en: '`grep`, `tee`, and the more powerful ones such as `sed` and `awk`. However,
    we will come back to those commands in [*Chapter 8*](B19682_08.xhtml#_idTextAnchor164),
    when we will show you how to create and use scripts. In this section, we will
    only give you a hint on how to use them on the command line.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`、`tee`以及更强大的命令如`sed`和`awk`。不过，我们将在[*第8章*](B19682_08.xhtml#_idTextAnchor164)中再次介绍这些命令，当时我们会向你展示如何创建和使用脚本。在本节中，我们只会给你一些如何在命令行中使用它们的提示。'
- en: The grep command
  id: totrans-458
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`grep`命令'
- en: 'This is one of the most powerful commands in Linux. It is also an extremely
    useful one. It has the power to search for strings inside text files. It has many
    powerful options too:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Linux中最强大的命令之一，也是非常实用的命令。它具有在文本文件中搜索字符串的能力，且有许多强大的选项：
- en: '`grep -v`: Show the lines that are not according to the search criteria'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -v`：显示不符合搜索条件的行'
- en: '`grep -l`: Show only the filenames that match the criteria'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -l`：仅显示符合条件的文件名'
- en: '`grep -L`: Show only the lines that do *not* comply with the criteria'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -L`：仅显示*不*符合条件的行'
- en: '`grep -c`: A counter that shows the number of lines matching the criteria'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -c`：一个计数器，显示符合条件的行数'
- en: '`grep -n`: Show the line number where the string was found'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -n`：显示找到字符串的行号'
- en: '`grep -i`: Searches are case insensitive'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -i`：搜索不区分大小写'
- en: '`grep -r`: Search recursively inside a directory structure'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -r`：在目录结构中递归搜索'
- en: '`grep -R`: Search recursively inside a directory structure *AND* follow all
    symbolic links'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -R`：在目录结构中递归搜索*并*跟踪所有符号链接'
- en: '`grep -E`: Use extended regular expressions'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -E`：使用扩展正则表达式'
- en: '`grep -F`: Use a strict list of strings instead of regular expressions'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep -F`：使用严格的字符串列表而不是正则表达式'
- en: 'Here are some examples of how to use the `grep` command:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`grep`命令的一些示例：
- en: 'Find out the last time the `sudo` command was used:'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找最后一次使用`sudo`命令的时间：
- en: '[PRE54]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Search for the `packt` string inside text files from the `/``etc` directory:'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/etc`目录中的文本文件中搜索`packt`字符串：
- en: '[PRE55]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Show the exact line where the match was found:'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示匹配结果所在的确切行：
- en: '[PRE56]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you don’t want to see the filename of each file where the match was found,
    use the `-h` option. Then, `grep` will only show you the lines where the match
    was found:'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不想看到每个文件中找到匹配项的文件名，可以使用`-h`选项。然后，`grep`只会显示找到匹配项的行：
- en: '[PRE57]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To show only the name of the file where the match was found, use `-l`:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅显示找到匹配项的文件名，可以使用`-l`：
- en: '[PRE58]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Most likely, `grep` will be used in combination with shell pipes. Here are
    some examples:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`很可能与Shell管道一起使用。以下是一些示例：'
- en: 'If you want to see only the directories from your current working directory,
    you could pipe the `ls` command output to `grep`. In the following example, we
    listed only the lines that start with the letter `d`, which represent directories:'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想查看当前工作目录中的目录，可以将`ls`命令的输出通过管道传给`grep`。在以下示例中，我们只列出了以字母`d`开头的行，这些行代表目录：
- en: '[PRE59]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you want to display the model of your CPU, you could use the following command:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想显示你的CPU型号，可以使用以下命令：
- en: '[PRE60]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You will find `grep` to be one of your closest friends as a Linux system administrator,
    so don’t be afraid to dig deeper into its options and hidden gems.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Linux系统管理员，你会发现`grep`是你最亲密的朋友之一，所以不要害怕深入了解它的选项和隐藏的宝藏。
- en: The tee command
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: tee命令
- en: This command is very similar to the `cat` command. Basically, it does the same
    thing, by copying the standard input to standard output with no alteration, but
    it also copies that into one or more files.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令与`cat`命令非常相似。基本上，它做的事情是将标准输入复制到标准输出而不做任何更改，但它还会将这些内容复制到一个或多个文件中。
- en: 'In the following example, we use the `wc` command to count the number of lines
    inside the `/etc/passwd/` file. We pipe the output to the `tee` command using
    the `-a` option (append if the file already exists), which writes it to a new
    file called `no-users` and prints it to the standard output at the same time.
    We then use the `cat` command to double-check the contents of the new file:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用`wc`命令来统计`/etc/passwd/`文件中的行数。我们将输出通过管道传给`tee`命令，并使用`-a`选项（如果文件已经存在，则追加），该命令将输出写入名为`no-users`的新文件，并同时打印到标准输出。然后，我们使用`cat`命令再次检查新文件的内容：
- en: '![Figure 2.33 – Using the tee command](img/Figure_02.33_B19682.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.33 – 使用tee命令](img/Figure_02.33_B19682.jpg)'
- en: Figure 2.33 – Using the tee command
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 – 使用tee命令
- en: The `tee` command is more of an underdog of file-manipulating commands. While
    it is quite powerful, its use can easily be overlooked. Nevertheless, we encourage
    you to use its powers as often as you can.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee` 命令是文件操作命令中的“黑马”。虽然它非常强大，但其使用往往容易被忽视。尽管如此，我们鼓励你尽可能多地使用它的强大功能。'
- en: In the following section, we will show you how to use text editors from the
    command line in Linux.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将展示如何在 Linux 的命令行中使用文本编辑器。
- en: Using text editors to create and edit files
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文本编辑器创建和编辑文件
- en: Linux has several command-line text editors that you can use. There are **nano**,
    **Emacs**, and **Vim**, among others. Those are the most used ones. There are
    also **Pico**, **JOE**, and **ed** as text editors that are less frequently used
    than the aforementioned ones. We will cover Vim, as there is a very good chance
    that you will find it on any Linux system that you work with. Nevertheless, the
    current trend is to replace Vim with nano as the default text editor. Ubuntu,
    for example, does not have Vim installed by default, but CentOS does. Fedora is
    currently looking to make nano the default text editor. Therefore, you might want
    to learn nano, but for legacy purposes, Vim is a very useful tool to know.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有多个命令行文本编辑器可供使用。包括 **nano**、**Emacs** 和 **Vim** 等等，它们是使用最多的。还有 **Pico**、**JOE**
    和 **ed** 等编辑器，相比前面提到的，使用频率较低。我们将重点介绍 Vim，因为几乎可以确定你在使用的任何 Linux 系统中都会找到它。然而，目前的趋势是用
    nano 取代 Vim 作为默认文本编辑器。例如，Ubuntu 默认没有安装 Vim，但 CentOS 安装了 Vim。Fedora 目前也在尝试将 nano
    作为默认文本编辑器。因此，你可能需要学习 nano，但出于遗留原因，Vim 仍然是一个非常有用的工具。
- en: Using Vim to edit text files
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Vim 编辑文本文件
- en: '**Vim** is the improved version of **vi**, the default text editor from Unix.
    It is a very powerful editing tool. This power comes with many options that can
    be used to ease your work, and this can be overwhelming. In this sub-section,
    we will introduce you to the basic commands of the text editor, just enough to
    help you be comfortable using it.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vim** 是 **vi** 的改进版，后者是 Unix 系统中的默认文本编辑器。Vim 是一个非常强大的编辑工具。这种强大伴随着许多可以简化工作的选项，可能让人感到不知所措。在这一小节中，我们将向你介绍文本编辑器的基本命令，足以帮助你熟练使用它。'
- en: 'Vim is a mode-based editor, as its operation is organized around different
    modes. In a nutshell, those modes are as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: Vim 是一个基于模式的编辑器，它的操作是围绕不同的模式组织的。简而言之，这些模式如下：
- en: '`command` mode is the default mode, waiting for a command'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command` 模式是默认模式，等待执行命令。'
- en: '`insert` mode is the text insert mode'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert` 模式是文本插入模式'
- en: '`replace` mode is the text replace mode'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace` 模式是文本替换模式'
- en: '`search` mode is the special mode for searching a document'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search` 模式是用于搜索文档的特殊模式。'
- en: Let’s see how we can switch between these modes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何在这些模式之间切换。
- en: Switching between modes
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在不同模式之间切换
- en: When you first open Vim, you will be introduced to an empty editor that only
    shows information about the version used and a few help commands. You are in `command`
    mode. This means that Vim is waiting for a command to operate.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开 Vim 时，你将看到一个空白的编辑器，里面仅显示所用版本信息和一些帮助命令。你处于 `command` 模式。这意味着 Vim 正在等待命令的操作。
- en: To activate `insert` mode, press *I* on your keyboard. You will be able to start
    inserting text at the current position of your cursor. You can also press *A*
    (for append) to start editing to the right of your cursor’s position. Both *I*
    and *A* will activate `insert` mode. To exit the current mode, press the *Esc*
    key. It will get you back to `command` mode.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活 `insert` 模式，按下键盘上的 *I* 键。你将能够在光标当前位置开始插入文本。你也可以按 *A* 键（追加模式）开始在光标位置的右侧编辑。*I*
    和 *A* 都会激活 `insert` 模式。要退出当前模式，按下 *Esc* 键，这样你就会回到 `command` 模式。
- en: If you open a file that already has text in it, while in `command` mode, you
    can navigate the file using your arrow keys. As Vim inherited the vi workflow,
    you can also use *H* (to move left), *J* (to move down), *K* (to move up), and
    *L* (to move right). Those are legacy keys from a time when terminal keyboards
    did not have separate arrow keys.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开一个已有文本的文件，在 `command` 模式下，你可以使用箭头键浏览文件。由于 Vim 继承了 vi 的工作流，你还可以使用 *H*（向左移动）、*J*（向下移动）、*K*（向上移动）和
    *L*（向右移动）。这些是来自早期终端键盘的传统按键，那时的键盘没有独立的箭头键。
- en: While still in `command` mode (the default mode), you can activate `replace`
    mode by pressing *R* on your keyboard. You can replace the character that is right
    at the position of your cursor.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然处于 `command` 模式下（默认模式），你可以通过按键盘上的 *R* 来激活 `replace` 模式。在这个模式下，你可以替换光标所在位置的字符。
- en: While in `command` mode, `search` mode is activated by pressing the */* key.
    Once in your mode, you can start typing a search string and then press *Enter*.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在`command`模式下，按下*/*键可以激活`search`模式。进入该模式后，你可以开始输入搜索字符串，然后按*Enter*键。
- en: There is also `last line` mode, or `ex command` mode. This mode is activated
    by pressing *:*. This is an extended mode where commands such as `w` for saving
    the file, `q` for quitting, or `wq` for saving and quitting at the same time.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`last line`模式，或称为`ex command`模式。按下*:*键可以激活此模式。这是一个扩展模式，可以执行诸如`w`保存文件，`q`退出，或`wq`同时保存并退出等命令。
- en: Basic Vim commands
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本Vim命令
- en: 'Working with Vim implies that you are comfortable with using keyboard shortcuts
    for using basic commands. We will guide you to the Vim documentation page ([https://vimdoc.sourceforge.net/](https://vimdoc.sourceforge.net/))
    for all the commands available, and we will give you a quick glimpse of the most
    useful ones in the following image:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vim意味着你需要熟练使用键盘快捷键来执行基本命令。我们将引导你访问Vim的文档页面（[https://vimdoc.sourceforge.net/](https://vimdoc.sourceforge.net/)）查看所有可用的命令，并且我们会在下图中快速展示一些最有用的命令：
- en: '![Figure 2.34 – Basic Vim commands](img/Figure_02.34_B19682.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.34 – 基本Vim命令](img/Figure_02.34_B19682.jpg)'
- en: Figure 2.34 – Basic Vim commands
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.34 – 基本Vim命令
- en: Vim can be quite intimidating for newcomers to Linux. There is no shame if you
    prefer other editors, as there are plenty to choose from. Now, we will show you
    a glimpse of nano.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux新手来说，Vim可能相当令人畏惧。如果你更喜欢其他编辑器也没有关系，因为有很多选择。现在，我们将向你展示nano的简要介绍。
- en: The nano text editor
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: nano文本编辑器
- en: Vim is a powerful text editor and knowing how to use it is an important thing
    for any system administrator. Nevertheless, other text editors are equally powerful
    and even easier to use.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Vim是一个强大的文本编辑器，学会如何使用它对任何系统管理员来说都非常重要。然而，其他文本编辑器同样强大，且使用起来更加简单。
- en: 'This is the case with `.bashrc` file by using the `$EDITOR` variable. However,
    in Ubuntu, you can check the default editor on your system by using the following
    command:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`$EDITOR`变量，这是`.bashrc`文件的情况。然而，在Ubuntu中，你可以通过以下命令查看系统上的默认编辑器：
- en: '![Figure 2.35 – Checking the default text editor on Ubuntu](img/Figure_02.35_B19682.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.35 – 检查Ubuntu上的默认文本编辑器](img/Figure_02.35_B19682.jpg)'
- en: Figure 2.35 – Checking the default text editor on Ubuntu
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.35 – 检查Ubuntu上的默认文本编辑器
- en: You can invoke the nano editor by using the `nano` command on Ubuntu/Debian
    and Fedora/Rocky Linux or openSUSE. When you type the command, the nano editor
    will open, with a very straightforward interface that can be easier to use than
    Vim or Emacs for example. Feel free to use your preferred text editor.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Ubuntu/Debian和Fedora/Rocky Linux或openSUSE上使用`nano`命令来调用nano编辑器。当你输入该命令时，nano编辑器将打开，界面非常简洁，比Vim或Emacs等编辑器更容易使用。你可以随时使用你喜欢的文本编辑器。
- en: Summary
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with the most commonly used commands
    in Linux. You now know how to manage (create, delete, copy, and move) files, how
    the filesystem is organized, how to work with directories, and how to view file
    contents. You now understand the shell and basic permissions. The skills you have
    learned will help you manage files in any Linux distribution and edit text files.
    You have learned how to work with Vim, one of the most widely used command-line
    text editors in Linux. Those skills will help you to learn how to use other text
    editors such as nano and Emacs. You will use these skills in almost every chapter
    of this book, as well as in your everyday job as a system administrator.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学会了如何使用Linux中最常用的命令。你现在知道如何管理（创建、删除、复制和移动）文件，了解了文件系统的组织方式，学会了如何操作目录，并查看文件内容。你现在理解了shell和基本权限。你所学到的技能将帮助你管理任何Linux发行版中的文件，并编辑文本文件。你已经学会了如何使用Vim，这是Linux中最广泛使用的命令行文本编辑器之一。这些技能将帮助你学习如何使用其他文本编辑器，如nano和Emacs。你将在本书的几乎每一章中使用这些技能，并且在你作为系统管理员的日常工作中也会使用到它们。
- en: In the next chapter, you will learn how to manage packages, including how to
    install, remove, and query packages in both Debian and Red Hat-based distributions.
    This skill is important for any administrator and must be part of any basic training.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何管理软件包，包括如何在Debian和基于Red Hat的发行版中安装、删除和查询软件包。这项技能对任何管理员都很重要，必须成为任何基础培训的一部分。
- en: Questions
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'In our second chapter, we covered the Linux filesystem and the basic commands
    that will serve as the foundation for the entire book. Here are some questions
    for you to test your knowledge and for further practice:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第二章中，我们介绍了 Linux 文件系统及基本命令，这些将构成整本书的基础。这里有一些问题供你测试自己的知识，并进行进一步练习：
- en: What is the command that creates a compressed archive with all the files inside
    the `/etc` directory that use the `.``conf` extension?
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个压缩归档，包含 `/etc` 目录下所有 `.``conf` 扩展名文件的命令是什么？
- en: '`tar` command just as shown in this chapter.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar` 命令，如本章所示。'
- en: What is the command that lists the first five files inside `/etc` and sorts
    them by dimension in descending order?
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出 `/etc` 目录下前五个文件并按尺寸降序排序的命令是什么？
- en: '`find` combined with `sort` and `head`.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令与 `sort` 和 `head` 结合使用。'
- en: What command creates a hierarchical directory structure?
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建层级目录结构的命令是什么？
- en: '`mkdir` just as shown in this chapter.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir` 命令，如本章所示。'
- en: What is the command that searches for files with three different extensions
    inside the root?
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找根目录下具有三种不同扩展名的文件的命令是什么？
- en: '`find` command.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 命令。'
- en: Find out which commands inside Linux have the **Set owner User ID** (**SUID**)
    set up.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 Linux 中哪些命令设置了 **设置所有者用户 ID**（**SUID**）。
- en: '`find` command with the `-``perm` parameter.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 `-``perm` 参数的 `find` 命令。
- en: Which command is used to create a file with 1,000 lines of randomly generated
    words (one word per line)?
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于创建一个包含 1,000 行随机生成的单词（每行一个单词）的文件？
- en: '`shuf` command (not shown in this chapter).'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuf` 命令（本章未展示）。'
- en: Perform the same exercise as before, but this time generate a file with 1,000
    randomly generated numbers.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行与之前相同的操作，但这次生成一个包含 1,000 个随机生成数字的文件。
- en: '`for` loop.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环。'
- en: How do you find out when `sudo` was last used and which commands were executed
    by it?
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查找上次使用 `sudo` 的时间以及通过它执行的命令？
- en: '`grep` command.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令。'
- en: Further reading
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about what was covered in this chapter, please refer to
    the following Packt titles:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解本章所涉及内容的更多信息，请参考以下 Packt 出版的书籍：
- en: '*Fundamentals of Linux*, by *Oliver Pelz*'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux 基础知识*，作者：*Oliver Pelz*'
- en: '*Mastering Ubuntu Server – Fourth Edition*, by *Jay LaCroix*'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握 Ubuntu 服务器 – 第四版*，作者：*Jay LaCroix*'
