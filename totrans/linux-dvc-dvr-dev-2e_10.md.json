["```\nCPU <--platform bus-->i2c adapter<---i2c bus---> i2c slave\n```", "```\nstruct i2c_adapter {\n    struct module *owner;\n    const struct i2c_algorithm *algo;\n    [...]\n};\n```", "```\nstruct i2c_algorithm {\n    int (*master_xfer)(struct i2c_adapter *adap,\n                       struct i2c_msg *msgs, int num);\n    int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,\n              unsigned short flags, char read_write,\n              u8 command, int size, \n              union i2c_smbus_data *data);\n    /* To determine what the adapter supports */\n    u32 (*functionality)(struct i2c_adapter *adap);\n[...]\n};\n```", "```\n#define I2C_FUNC_I2C              0x00000001\n#define I2C_FUNC_10BIT_ADDR       0x00000002\n#define I2C_FUNC_SMBUS_BYTE   (I2C_FUNC_SMBUS_READ_BYTE | \\\n                         I2C_FUNC_SMBUS_WRITE_BYTE)\n#define I2C_FUNC_SMBUS_BYTE_DATA \\\n                      (I2C_FUNC_SMBUS_READ_BYTE_DATA | \\\n                       I2C_FUNC_SMBUS_WRITE_BYTE_DATA)\n#define I2C_FUNC_SMBUS_WORD_DATA \\\n                     (I2C_FUNC_SMBUS_READ_WORD_DATA | \\\n                      I2C_FUNC_SMBUS_WRITE_WORD_DATA)\n#define I2C_FUNC_SMBUS_BLOCK_DATA \\\n                     (I2C_FUNC_SMBUS_READ_BLOCK_DATA | \\\n                      I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)\n#define I2C_FUNC_SMBUS_I2C_BLOCK \\\n                     (I2C_FUNC_SMBUS_READ_I2C_BLOCK | \\\n                      I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)\n```", "```\nstruct i2c_client {\n    unsigned short flags;\n    unsigned short addr;\n    char name[I2C_NAME_SIZE];\n    struct i2c_adapter *adapter;\n    struct device dev;\n    int irq;\n};\n```", "```\nstruct i2c_driver {\n    unsigned int class;\n    /* Standard driver model interfaces */\n    int (*probe)(struct i2c_client *client,\n                  const struct i2c_device_id *id);\n    int (*remove)(struct i2c_client *client);\n    int (*probe_new)(struct i2c_client *client);\n    void (*shutdown)(struct i2c_client *client);\n    struct device_driver driver;\n    const struct i2c_device_id *id_table;\n};\n```", "```\nstruct i2c_msg { \n    __u16 addr; \n    __u16 flags; \n#define I2C_M_TEN 0x0010 \n#define I2C_M_RD 0x0001 \n    __u16 len; \n    __u8 * buf; \n};\n```", "```\nint i2c_transfer(struct i2c_adapter *adap,\n              struct i2c_msg *msg, int num);\n```", "```\nstatic int i2c_read_bytes(struct i2c_client *client, \n                          u8 cmd, u8 *data, u8 data_len)\n{\n    struct i2c_msg msgs[2];\n    int ret;\n    u8 *buffer;\n    buffer = kzalloc(data_len, GFP_KERNEL);\n    if (!buffer)\n        return -ENOMEM;;\n    msgs[0].addr = client->addr;\n    msgs[0].flags = client->flags;\n    msgs[0].len = 1;\n    msgs[0].buf = &cmd;\n    msgs[1].addr = client->addr;\n    msgs[1].flags = client->flags | I2C_M_RD;\n    msgs[1].len = data_len;\n    msgs[1].buf = buffer;\n    ret = i2c_transfer(client->adapter, msgs, 2);\n    if (ret < 0)\n        dev_err(&client->adapter->dev,\n                 \"i2c read failed\\n\");\n    else\n        memcpy(data, buffer, data_len);\n    kfree(buffer);\n    return ret;\n}\n```", "```\nstatic int i2c_read_bytes(struct i2c_client *client, \n                          u8 cmd, u8 *data, u8 data_len)\n{\n    struct i2c_msg msgs[2];\n    int ret;\n    u8 *buffer;\n    buffer = kzalloc(data_len, GFP_KERNEL);\n    if (!buffer)\n        return -ENOMEM;;\n    msgs[0].addr = client->addr;\n    msgs[0].flags = client->flags;\n    msgs[0].len = 1;\n    msgs[0].buf = &cmd;\n    ret = i2c_transfer(client->adapter, msgs, 1);\n    if (ret < 0) {\n        dev_err(&client->adapter->dev, \n                \"i2c read failed\\n\");\n        kfree(buffer);\n        return ret;\n    }\n    msgs[1].addr = client->addr;\n    msgs[1].flags = client->flags | I2C_M_RD;\n    msgs[1].len = data_len;\n    msgs[1].buf = buffer;\n    ret = i2c_transfer(client->adapter, &msgs[1], 1);\n    if (ret < 0)\n        dev_err(&client->adapter->dev, \n                \"i2c read failed\\n\");\n    else\n        memcpy(data, buffer, data_len);\n    kfree(buffer);\n    return ret;\n}\n```", "```\nint i2c_master_send(struct i2c_client *client,\n             const char *buf, int count);\nint i2c_master_recv(struct i2c_client *client,\n             char *buf, int count);\n```", "```\nstatic int i2c_read_bytes(struct i2c_client *client, \n                          u8 cmd, u8 *data, u8 data_len)\n{\n    struct i2c_msg msgs[2];\n    int ret;\n    u8 *buffer;\n    buffer = kzalloc(data_len, GFP_KERNEL);\n    if (!buffer)\n        return -ENOMEM;;\n    ret = i2c_master_send(client, &cmd, 1);\n    if (ret < 0) {\n        dev_err(&client->adapter->dev, \n                \"i2c read failed\\n\");\n        kfree(buffer);\n        return ret;\n    }\n    ret = i2c_master_recv(client, buffer, data_len);\n    if (ret < 0)\n        dev_err(&client->adapter->dev, \n                \"i2c read failed\\n\");\n    else\n        memcpy(data, buffer, data_len);\n    kfree(buffer);\n    return ret;\n}\n```", "```\ns32 i2c_smbus_read_byte_data(struct i2c_client *client, \n                             u8 command);\ns32 i2c_smbus_write_byte_data(struct i2c_client *client,\n                               u8 command, u8 value);\ns32 i2c_smbus_read_word_data(struct i2c_client *client, \n                             u8 command);\ns32 i2c_smbus_write_word_data(struct i2c_client *client,\n                              u8 command, u16 value);\ns32 i2c_smbus_read_block_data(struct i2c_client *client,\n                              u8 command, u8 *values);\ns32 i2c_smbus_write_block_data(struct i2c_client *client,\n                               u8 command, u8 length, \n                               const u8 *values);\n```", "```\nstruct mcp23016 {\n    struct i2c_client   *client;\n    struct gpio_chip    chip;\n    struct mutex        lock;\n};\n[...]\nstatic int mcp23016_set(struct mcp23016 *mcp,\n             unsigned offset, intval)\n{\n    s32 value;\n    unsigned bank = offset / 8;\n    u8 reg_gpio = (bank == 0) ? GP0 : GP1;\n    unsigned bit = offset % 8;\n    value = i2c_smbus_read_byte_data(mcp->client, \n                                     reg_gpio);\n    if (value >= 0) {\n        if (val)\n            value |= 1 << bit;\n        else\n            value &= ~(1 << bit);\n        return i2c_smbus_write_byte_data(mcp->client,\n                                         reg_gpio, value);\n    } else\n        return value;\n}\n```", "```\nint foo_probe(struct i2c_client *client,\n            const struct i2c_device_id *id)\n```", "```\nint probe(struct i2c_client *client)\n```", "```\n#define CHIP_ID 0x13\n#define DA311_REG_CHIP_ID  0x000f\nstatic int fake_i2c_probe(struct i2c_client *client)\n{\n    int err;\n    int ret;\n    if (!i2c_check_functionality(client->adapter,\n            I2C_FUNC_SMBUS_BYTE_DATA))\n        return -EIO;\n    /* read family id */\n    ret = i2c_smbus_read_byte_data(client, REG_CHIP_ID);\n    if (ret != CHIP_ID)\n        return (ret < 0) ? ret : -ENODEV;\n    /* register with other frameworks */\n    [...]\n    return 0;\n}\n```", "```\nstatic int remove(struct i2c_device *client)\n```", "```\nstatic int mc9s08dz60_remove(struct i2c_client *client)\n{\n    struct mc9s08dz60 *mc9s;\n    /* We retrieve our private data */\n    mc9s = i2c_get_clientdata(client);\n   /* Which hold gpiochip we want to work on */\n    return gpiochip_remove(&mc9s->chip);\n}\n```", "```\nint i2c_add_driver(struct i2c_driver *drv);\nvoid i2c_del_driver(struct i2c_driver *drv);\n```", "```\nstatic int __init foo_init(void)\n{\n    [...] /*My init code */\n      return i2c_add_driver(&foo_driver);\n}\nmodule_init(foo_init);\nstatic void __exit foo_cleanup(void)\n{\n    [...] /* My clean up code */\n      i2c_del_driver(&foo_driver);\n}\nmodule_exit(foo_cleanup);\n```", "```\nmodule_i2c_driver(foo_driver);\n```", "```\nstruct i2c_device_id {\n   char name[I2C_NAME_SIZE];\n   kernel_ulong_t driver_data;\n};\n```", "```\nstruct of_device_id {\n[...]\n    char  compatible[128];\n    const void *data;\n};\n```", "```\n#define ID_FOR_FOO_DEVICE  0\n#define ID_FOR_BAR_DEVICE  1 \nstatic struct i2c_device_id foo_idtable[] = {\n   { \"foo\", ID_FOR_FOO_DEVICE },\n   { \"bar\", ID_FOR_BAR_DEVICE },\n   { },\n};\nMODULE_DEVICE_TABLE(i2c, foo_idtable);\n```", "```\nstatic const struct of_device_id foobar_of_match[] = {\n        { .compatible = \"packtpub,foobar-device\" },\n        { .compatible = \"packtpub,barfoo-device\" },\n        {},\n};\nMODULE_DEVICE_TABLE(of, foobar_of_match);\n```", "```\nstatic struct i2c_driver foo_driver = {\n    .driver         = {\n        .name   = \"foo\",\n        /* The below line adds Device Tree support */\n        .of_match_table = of_match_ptr(foobar_of_match),\n    },\n    .probe          = fake_i2c_probe,\n    .remove         = fake_i2c_remove,\n    .id_table       = foo_idtable,\n};\n```", "```\n&i2c2 { /* Phandle of the bus node */\n    pcf8523: rtc@68 {\n        compatible = \"nxp,pcf8523\";\n        reg = <0x68>;\n    };\n    eeprom: ee24lc512@55 { /* eeprom device */\n        compatible = \"labcsmart,ee24lc512\";\n        reg = <0x55>;\n    };\n};\n```", "```\n#include <linux/i2c-dev.h>\n#include <i2c/smbus.h>\n#include <linux/i2c.h>\n```", "```\n    unsigned long funcs;\n    if (ioctl(file, I2C_FUNCS, &funcs) < 0)\n            return -errno;\n    if (!(funcs & I2C_FUNC_SMBUS_QUICK)) {\n        /* Oops, SMBus write_quick) not available! */\n        exit(1);\n    }\n    /* Now it is safe to use SMBus write_quick command */\n    ```", "```\n    struct i2c_rdwr_ioctl_data {\n      struct i2c_msg *msgs; /* ptr to array of messages */\n      int nmsgs; /* number of messages to exchange */\n    }\n    ```", "```\n    int ret;\n    uint8_t buf [5] = {regaddr, '0x55', '0x65', \n                       '0x88', '0x14'};\n    struct i2c_msg messages[] = {\n        {\n            .addr = dev,\n            .buf = buf,\n            .len = 5, /* buf size is 5 */\n        },\n    };\n    struct i2c_rdwr_ioctl_data payload = {\n        .msgs = messages,\n        .nmsgs = sizeof(messages) \n                 /sizeof(messages[0]),\n    };\n    ret = ioctl(file, I2C_RDWR, &payload);\n```", "```\n    struct i2c_smbus_ioctl_data {\n        __u8 read_write;\n        __u8 command;\n        __u32 size;\n        union i2c_smbus_data __user *data;\n    };\n    ```", "```\n    uint8_t buf [5] = {'0x55', '0x65', '0x88'};\n    struct i2c_smbus_ioctl_data payload = {\n        .read_write = I2C_SMBUS_WRITE,\n        .size = I2C_SMBUS_WORD_DATA,\n        .command = regaddr,\n        .data = (void *) buf,\n    };\n    ret = ioctl (fd, I2C_SLAVE_FORCE, dev);\n    if (ret < 0)\n        /* handle errors */\n    ret = ioctl (fd, I2C_SMBUS, &payload);\n    if (ret < 0)\n        /* handle errors */\n```", "```\n__s32 i2c_smbus_write_quick(int file, __u8 value);\n__s32 i2c_smbus_read_byte(int file);\n__s32 i2c_smbus_write_byte(int file, __u8 value);\n__s32 i2c_smbus_read_byte_data(int file, __u8 command);\n__s32 i2c_smbus_write_byte_data(int file, __u8 command,\n                                 __u8 value);\n__s32 i2c_smbus_read_word_data(int file, __u8 command);\n__s32 i2c_smbus_write_word_data(int file, __u8 command,\n                                 __u16 value);\n__s32 i2c_smbus_read_block_data(int file, __u8 command,\n                                 __u8 *values);\n__s32 i2c_smbus_write_block_data(int file, __u8 command,\n                              __u8 length, __u8 *values);\n```"]