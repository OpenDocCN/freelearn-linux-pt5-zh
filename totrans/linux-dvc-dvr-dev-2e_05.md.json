["```\n$ ls -la /dev\ncrw-------  1 root root    254,     0 août  22 20:28 gpiochip0\ncrw-------  1 root root    240,     0 août  22 20:28 hidraw0\n[...]\nbrw-rw----  1 root disk    259,     0 août  22 20:28 nvme0n1\nbrw-rw----  1 root disk    259,     1 août  22 20:28 nvme0n1p1\nbrw-rw----  1 root disk    259,     2 août  22 20:28 nvme0n1p2\n[...]\ncrw-rw----+ 1 root video    81,     0 août  22 20:28 video0\ncrw-rw----+ 1 root video    81,     1 août  22 20:28 video1\n```", "```\nstruct cdev {\n    struct kobject kobj;\n    struct module *owner;\n    const struct file_operations *ops;\n    dev_t dev;\n[...]\n};\n```", "```\nstruct file_operations {\n   struct module *owner;\n   loff_t (*llseek) (struct file *, loff_t, int);\n   ssize_t (*read) (struct file *, char __user *,\n                     size_t, loff_t *);\n   ssize_t (*write) (struct file *, const char __user *,\n                     size_t, loff_t *);\n   unsigned int (*poll) (struct file *,\n                         struct poll_table_struct *);\n   int (*mmap) (struct file *, struct vm_area_struct *);\n   int (*open) (struct inode *, struct file *);\n   int (*flush) (struct file *, fl_owner_t id);\n   long (*unlocked_ioctl) (struct file *, unsigned int,\n                           unsigned long);\n   int (*release) (struct inode *, struct file *);\n   int (*fsync) (struct file *, loff_t, loff_t,\n                 int datasync);\n   int (*flock) (struct file *, int, struct file_lock *);\n   [...]\n};\n```", "```\nstruct inode {\n    [...]\n    union {\n        struct pipe_inode_info  *i_pipe;\n        struct cdev    *i_cdev;\n        char           *i_link;\n        unsigned       i_dir_seq;\n    };\n    [...]\n}\n```", "```\nstruct file {\n[...]\n   struct path f_path;\n   struct inode *f_inode;\n   const struct file_operations *f_op;\n   loff_t f_pos;\n   void *private_data;\n[...]\n}\n```", "```\n#define MINORBITS    20\n#define MINORMASK    ((1U << MINORBITS) - 1)\n#define MAJOR(dev)    ((unsigned int) ((dev) >> MINORBITS))\n#define MINOR(dev)    ((unsigned int) ((dev) & MINORMASK))\n#define MKDEV(ma,mi)  (((ma) << MINORBITS) | (mi))\n```", "```\nint register_chrdev_region(dev_t first, unsigned int count,\n                           char *name);\n```", "```\nint alloc_chrdev_region(\n                      dev_t *dev, unsigned int firstminor,\n                      unsigned int count, char *name);\n```", "```\nvoid cdev_init(struct cdev *cdev,\n               const struct file_operations *fops);\nint cdev_add (struct cdev * p, dev_t dev, unsigned count);\n```", "```\nvoid cdev_del(struct cdev *);\n```", "```\nstruct device * device_create(struct class *class,\n                              struct device *parent,\n                              dev_t devt,\n                              void *drvdata, \n                              const char *fmt, ...)\n```", "```\nstruct class * class_create(struct module * owner,\n                            const char * name);\n```", "```\n#define EEP_NBANK 8\n#define EEP_DEVICE_NAME \"eep-mem\"\n#define EEP_CLASS \"eep-class\"\nstatic struct class *eep_class;\nstatic struct cdev eep_cdev[EEP_NBANK];\nstatic dev_t dev_num;\nstatic int __init my_init(void)\n{\n    int i;\n    dev_t curr_dev;\n    /* Request for a major and EEP_NBANK minors */\n    alloc_chrdev_region(&dev_num, 0, EEP_NBANK, \n                        EEP_DEVICE_NAME);\n    /* create our device class, visible in /sys/class */\n    eep_class = class_create(THIS_MODULE, EEP_CLASS);\n    /* Each bank is represented as a character device (cdev) */\n    for (i = 0; i < EEP_NBANK; i++) {\n        /* bind file_operations to the cdev */\n        cdev_init(&my_cdev[i], &eep_fops);\n        eep_cdev[i].owner = THIS_MODULE;\n        /* Device number to use to add cdev to the core */\n        curr_dev = MKDEV(MAJOR(dev_num),\n                          MINOR(dev_num) + i);\n        /* Make the device live for the users to access */\n        cdev_add(&eep_cdev[i], curr_dev, 1);\n        /* create a node for each device */\n        device_create(eep_class,\n              NULL,     /* no parent device */\n              curr_dev,\n              NULL,     /* no additional data */\n              EEP_DEVICE_NAME \"%d\", i); /* eep-mem[0-7] */\n    }\n    return 0;\n}\n```", "```\nfor (i = 0; i < EEP_NBANK; i++) {\n    device_destroy(eep_class,\n              MKDEV(MAJOR(dev_num), (MINOR(dev_num) +i)));\n    cdev_del(&eep_cdev[i]);\n}\nclass_unregister(eep_class);\nclass_destroy(eep_class);\nunregister_chrdev_region(chardev_devt, EEP_NBANK);\n```", "```\nunsigned long copy_from_user(void *to,\n               const void __user *from, unsigned long n)\nunsigned long copy_to_user(void __user *to,\n               const void *from, unsigned long n)\n```", "```\nint (*open) (struct inode *inode, struct file *filp);\n```", "```\nstruct pcf2127 {\n    struct cdev cdev;\n    unsigned char *sram_data;\n    struct i2c_client *client;\n    int sram_size;\n    [...]\n};\n```", "```\nstatic unsigned int sram_major = 0;\nstatic struct class *sram_class = NULL;\nstatic int sram_open(struct inode *inode,\n                     struct file *filp)\n{\n    unsigned int maj = imajor(inode);\n    unsigned int min = iminor(inode);\n    struct pcf2127 *pcf = NULL;\n    pcf = container_of(inode->i_cdev,\n                        struct pcf2127, cdev);\n    pcf->sram_size = SRAM_SIZE;\n    if (maj != sram_major || min < 0 ){\n        pr_err (\"device not found\\n\");\n        return -ENODEV; /* No such device */\n    }\n    /* prepare the buffer if the device is\n     * opened for the first time\n       */\n    if (pcf->sram_data == NULL) {\n        pcf->sram_data =\n                  kzalloc(pcf->sram_size, GFP_KERNEL);\n        if (pcf->sram_data == NULL) {\n            pr_err(\"memory allocation failed\\n\");\n            return -ENOMEM;\n        }\n    }\n    filp->private_data = pcf;\n    return 0;\n}\n```", "```\nstatic int sram_release(struct inode *inode,\n                        struct file *filp)\n{\n    struct pcf2127 *pcf = NULL;\n    pcf = container_of(inode->i_cdev,\n                        struct pcf2127, cdev);\n    mutex_lock(&device_list_lock);\n    filp->private_data = NULL;\n    /* last close? */\n    pcf2127->users--;\n    if (!pcf2127->users) {\n        kfree(tx_buffer);\n        kfree(rx_buffer);\n        tx_buffer = NULL;\n        rx_buffer = NULL;\n        [...]\n        if (any_other_dynamic_struct)\n            kfree(any_other_dynamic_struct);\n    }\n    mutex_unlock(&device_list_lock);\n    return 0;\n}\n```", "```\nssize_t(*write)(struct file *filp, const char __user *buf,\n                size_t count, loff_t *pos);\n```", "```\n/* if trying to Write beyond the end of the file,\n * return error. \"filesize\" here corresponds to the size\n * of the device memory (if any)\n */\nif (*pos >= filesize) return –EINVAL;\n```", "```\n/* filesize corresponds to the size of device memory */\nif (*pos + count > filesize) \n    count = filesize - *pos;\n```", "```\n/* convert pos into valid address */\nvoid *from = pos_to_address(*pos); \n```", "```\nif (copy_from_user(dev->buffer, buf, count) != 0){\n    retval = -EFAULT;\n    goto out;\n}\n/* now move data from dev->buffer to physical device */\nwrite_error = device_write(dev->buffer, count);\nif (write_error)\n    return –EFAULT;\n/* Increase the current position of the cursor in the file,\n * according to the number of bytes written and finally,\n * return the number of bytes copied\n */\n*pos += count;\nreturn count;\n```", "```\nssize_t \neeprom_write(struct file *filp, const char __user *buf,\n             size_t count, loff_t *f_pos)\n{\n    struct eeprom_dev *eep = filp->private_data;\n    int part_origin = PART_SIZE * eep->part_index;\n    int register_address;\n    ssize_t retval = 0;\n    /* step (1) */\n    if (*f_pos >= eep->part_size) \n        /* Can't write beyond the end of a partition. */\n        return -EINVAL;\n    /* step (2) */\n    if (*pos + count > eep->part_size)\n        count = eep->part_size - *pos;\n    /* step (3) */\n    register_address = part_origin + *pos;\n    /* step(4) */\n    /* Copy data from user space to kernel space */\n    if (copy_from_user(eep->data, buf, count) != 0)\n        return -EFAULT;\n    /* step (5) */\n    /* perform the write to the device */\n    if (write_to_device(register_address, buff, count)\n        < 0){\n        pr_err(\"i2c_transfer failed\\n\");  \n        return –EFAULT;\n     }\n    /* step (6) */\n    *f_pos += count;\n    return count;\n}\n```", "```\nssize_t (*read) (struct file *filp, char __user *buf,\n                 size_t count, loff_t *pos);\n```", "```\nif (*pos >= filesize)\n    return 0; /* 0 means EOF */\n```", "```\nif (*pos + count > filesize)\n    count = filesize – (*pos);\n```", "```\n/* convert pos into valid address */\nvoid *from = pos_to_address (*pos); \nsent = copy_to_user(buf, from, count);\nif (sent)\n    return –EFAULT;\n*pos += count;\nreturn count;\n```", "```\nssize_t  eep_read(struct file *filp, char __user *buf,\n                  size_t count, loff_t *f_pos)\n{\n    struct eeprom_dev *eep = filp->private_data;\n    if (*f_pos >= EEP_SIZE) /* EOF */\n        return 0;\n    if (*f_pos + count > EEP_SIZE)\n        count = EEP_SIZE - *f_pos;\n    /* Find location of next data bytes */\n    int part_origin  =  PART_SIZE * eep->part_index;\n    int eep_reg_addr_start  =  part_origin + *pos;\n    /* perform the read from the device */\n    if (read_from_device(eep_reg_addr_start, buff, count)\n        < 0){\n        pr_err(\"i2c_transfer failed\\n\");  \n        return –EFAULT;\n    } \n    /* copy from kernel to user space */\n    if(copy_to_user(buf, dev->data, count) != 0)\n        return -EIO;\n    *f_pos += count;\n    return count;\n}\n```", "```\nloff_t(*llseek) (struct file *filp, loff_t offset,\n                 int whence);\n```", "```\nswitch( whence ){\n    case SEEK_SET:/* relative from the beginning of file */\n        newpos = offset; /* offset become the new position */\n        break;\n    case SEEK_CUR: /* relative to current file position */\n        /* just add offset to the current position */\n        newpos = file->f_pos + offset;\n        break;\n    case SEEK_END: /* relative to end of file */\n        newpos = filesize + offset;\n        break;\n    default:\n        return -EINVAL;\n}\n/* Check whether newpos is valid **/\nif ( newpos < 0 )\n    return –EINVAL;\n/* Update f_pos with the new position */\nfilp->f_pos = newpos;\n/* Return the new file-pointer position */\nreturn newpos;\n```", "```\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <stdio.h>\n#define CHAR_DEVICE \"foo\"\nint main(int argc, char **argv)\n{\n    int fd = 0;\n    char buf[20];\n    if ((fd = open(CHAR_DEVICE, O_RDONLY)) < -1)\n        return 1;\n    /* Read 20 bytes */\n    if (read(fd, buf, 20) != 20)\n        return 1;\n    printf(\"%s\\n\", buf);\n    /* Move the cursor to ten time relative to\n     * its actual position\n     */\n    if (lseek(fd, 10, SEEK_CUR) < 0)\n        return 1;\n    if (read(fd, buf, 20) != 20) \n        return 1;\n    printf(\"%s\\n\",buf);\n    /* Move the cursor seven time, relative from\n     * the beginning of the file\n     */\n    if (lseek(fd, 7, SEEK_SET) < 0)\n        return 1;\n    if (read(fd, buf, 20) != 20)\n        return 1;\n    printf(\"%s\\n\",buf);\n    close(fd);\n    return 0;\n}\n```", "```\njma@jma:~/work/tutos/sources$ cat toto \nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\njma@jma:~/work/tutos/sources$ ./seek \nLorem ipsum dolor si\nnsectetur adipiscing\npsum dolor sit amet,\njma@jma:~/work/tutos/sources$\n```", "```\nunsigned int (*poll) (struct file *, struct poll_table_struct *);\n```", "```\nvoid poll_wait(struct file * filp,\n               wait_queue_head_t * wait_address, poll_table *p)\n```", "```\n#include <linux/poll.h>\n/* declare a wait queue for each event type (read, write ...) */\nstatic DECLARE_WAIT_QUEUE_HEAD(my_wq);\nstatic DECLARE_WAIT_QUEUE_HEAD(my_rq);\nstatic unsigned int eep_poll(struct file *file,\n                             poll_table *wait)\n{\n    unsigned int reval_mask = 0;\n    poll_wait(file, &my_wq, wait);\n    poll_wait(file, &my_rq, wait);\n    if (new_data_is_ready)\n        reval_mask |= (POLLIN | POLLRDNORM);\n    if (ready_to_be_written)\n       reval_mask |= (POLLOUT | POLLWRNORM);\n    return reval_mask;\n}\n```", "```\nwake_up_interruptible(&my_rq); /* Ready to read */\n/* set flag accordingly in case poll is called */\nnew_data_is_ready = true;\nwake_up_interruptible(&my_wq); /* Ready to be written to */\nready_to_be_written = true;\n```", "```\n#include <unistd.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/select.h>\n#define NUMBER_OF_BYTE 100\n#define CHAR_DEVICE \"/dev/packt_char\"\nchar data[NUMBER_OF_BYTE];\nint main(int argc, char **argv)\n{\n    int fd, retval;\n    ssize_t read_count;\n    fd_set readfds;\n    fd = open(CHAR_DEVICE, O_RDONLY);\n    if(fd < 0)\n        /* Print a message and exit*/\n        [...]\n    while(1){ \n        FD_ZERO(&readfds);\n        FD_SET(fd, &readfds);\n       ret = select(fd + 1, &readfds, NULL, NULL, NULL);\n        /* From here, the process is already notified */\n        if (ret == -1) {\n            fprintf(stderr, \"select: an error ocurred\");\n            break;\n        }\n\n        /* we are interested in one file only */\n        if (FD_ISSET(fd, &readfds)) {\n            read_count = read(fd, data, NUMBER_OF_BYTE);\n            if (read_count < 0)\n                /* An error occurred. Handle this */\n                [...]\n            if (read_count != NUMBER_OF_BYTE)\n                /* We have read less than needed bytes */\n                [...] /* handle this */\n            else\n            /* Now we can process the data we have read */\n            [...]\n        }\n    }    \n    close(fd);\n    return EXIT_SUCCESS;\n}\n```", "```\nlong ioctl(struct file *f, unsigned int cmd,\n           unsigned long arg);\n```", "```\n_IO(MAGIC, SEQ_NO)\n_IOR(MAGIC, SEQ_NO, TYPE)\n_IOW(MAGIC, SEQ_NO, TYPE)\n_IORW(MAGIC, SEQ_NO, TYPE)\n```", "```\n#ifndef PACKT_IOCTL_H\n#define PACKT_IOCTL_H\n/* We need to choose a magic number for our driver,\n * and sequential numbers for each command:\n */\n#define EEP_MAGIC 'E'\n#define ERASE_SEQ_NO 0x01\n#define RENAME_SEQ_NO 0x02\n#define GET_FOO 0x03\n#define GET_SIZE 0x04\n/*\n * Partition name must be 32 byte max\n */\n#define MAX_PART_NAME 32\n/*\n * Now let's define our ioctl numbers:\n */\n#define EEP_ERASE _IO(EEP_MAGIC, ERASE_SEQ_NO)\n#define EEP_RENAME_PART _IOW(EEP_MAGIC, RENAME_SEQ_NO, \\\n                             unsigned long)\n#define EEP_GET_FOO  _IOR(EEP_MAGIC, GET_FOO, \\\n                          struct my_struct *)\n#define EEP_GET_SIZE _IOR(EEP_MAGIC, GET_SIZE, int *)\n#endif\n```", "```\n#include \"eep_ioctl.h\"\nstatic long eep_ioctl(struct file *f, unsigned int cmd,\n                      unsigned long arg)\n{\n    int part;\n    char *buf = NULL;\n    int size = 2048;\n    switch(cmd){\n        case EEP_ERASE:\n            erase_eepreom();\n            break;\n        case EEP_RENAME_PART:\n            buf = kmalloc(MAX_PART_NAME, GFP_KERNEL);\n            copy_from_user(buf, (char *)arg,\n                            MAX_PART_NAME);\n            rename_part(buf);\n            break;\n        case EEP_GET_SIZE:\n            if (copy_to_user((int*)arg,\n                           &size, sizeof(int)))\n                return -EFAULT;\n            break;\n        default:\n            return –ENOTTY;\n    }\n    return 0;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include \"eep_ioctl.h\" /* our ioctl header file */\nint main()\n{\n    int size = 0;\n    int fd;\n    char *new_name = \"lorem_ipsum\";\n    fd = open(\"/dev/eep-mem1\", O_RDWR);\n    if (fd < 0){\n        printf(\"Error while opening the eeprom\\n\");\n        return 1;\n    }\n    /* ioctl to erase partition */\n    ioctl(fd, EEP_ERASE);\n    /* call to get partition size */\n    ioctl(fd, EEP_GET_SIZE, &size);\n    /* rename partition */\n    ioctl(fd, EEP_RENAME_PART, new_name);  \n    close(fd);\n    return 0;\n}\n```"]