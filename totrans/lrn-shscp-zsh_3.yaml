- en: Chapter 3. Advanced Editing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：高级编辑
- en: In this chapter, we are taking a step forward from basic zsh usage and diving
    into the more advanced features of the command line. We will be getting close
    and personal with the zsh line editor, understanding how it works and why zsh
    needs it's very own input editor. We will discover new ways of accessing and tapping
    into the shell's history and learn some new command line editing tricks in order
    to speed up most of our regular tasks and avoid repeating ourselves to boredom.
    Finally, we will discover that there's really no need to be limited to a single
    line of text while using zsh.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从基础的 zsh 使用方法迈出一步，深入探讨命令行的更高级功能。我们将亲密接触并了解 zsh 行编辑器，理解它是如何工作的，以及为什么
    zsh 需要专门的输入编辑器。我们将探索新的方法来访问并利用 shell 的历史记录，并学习一些新的命令行编辑技巧，以便加快我们大部分常规任务的处理速度，避免重复劳动造成的乏味。最后，我们将发现，使用
    zsh 时，实际上并不需要局限于单行文本。
- en: Zsh line editor
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zsh 行编辑器
- en: 'In the previous chapter, we learned how to access the shell''s history and
    how to use some special escape sequences in order to access its records. Nevertheless,
    we assumed that the only way for us to review previous history entries was by
    using the arrow-up and down keys on the keyboard and loop through them sequentially.
    Well, as you can imagine, it''s time we got acquainted with another of zsh''s
    great features: the zsh line editor.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何访问 shell 的历史记录，以及如何使用一些特殊的转义序列来访问这些记录。然而，我们假设查看先前历史记录的唯一方法是使用键盘上的上箭头和下箭头键，按顺序浏览它们。嗯，正如你可以想象的那样，是时候了解
    zsh 另一个强大功能了：zsh 行编辑器。
- en: Unlike other shells—I'm looking at you, Bash—zsh does not depend on GNU's `readline`
    library, rolling instead with its own version of a command line editor that boasts
    most of the bells and whistles you'd expect to find in a full-fledged application.
    The zsh line editor, or ZLE in short, allows you to define your own key bindings
    (a combination of key presses) and set of custom keymaps (collections of key bindings)
    in addition to extending predefined entries. ZLE is also a key module of zsh,
    and is present in any interactive shell you use. Luckily, zsh is smart enough
    to know when not to load ZLE, thus avoiding extra resources if ZLE is not required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他 shell 不同——我在说你，Bash——zsh 并不依赖于 GNU 的 `readline` 库，而是使用自己的命令行编辑器版本，这个编辑器具备了你期望在一个完善应用程序中找到的大部分功能。zsh
    行编辑器，简称 ZLE，允许你定义自己的键绑定（按键组合）和自定义键映射集（键绑定的集合），此外还可以扩展预定义的条目。ZLE 还是 zsh 的一个关键模块，任何交互式
    shell 中都会存在它。幸运的是，zsh 足够聪明，知道在不需要 ZLE 时避免加载它，从而节省不必要的资源。
- en: Getting to know ZLE
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 ZLE
- en: By now, you have been using zsh long enough to notice that some things just
    seem odd; like when you press a key, say *PageUp*, you are bound to see some arcane
    glyphs, same as trying to use the *Ctrl* + left-arrow shortcut to move the cursor
    between words. As it stands, ZLE is the one in charge of knowing what these symbols
    mean and what behavior is linked to them, a task we need to set up via key bindings.
    We can even group our collection of keybinds under the same name and use different
    collections for altogether different purposes such as *Home* to move to the beginning
    of the line when editing commands or selecting the first entry when searching
    through history. But first, let's take advantage of what's already defined in
    a default installation of zsh and the vanilla ZLE.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经使用 zsh 足够长的时间，开始注意到有些事情似乎有些奇怪；比如当你按下一个键时，比如 *PageUp*，你肯定会看到一些神秘的符号，就像使用
    *Ctrl* + 左箭头快捷键在单词之间移动光标时一样。实际上，ZLE 就是负责理解这些符号的含义以及与之相关的行为的，我们需要通过键绑定来设置这一任务。我们甚至可以将一组键绑定按相同名称分组，并为完全不同的用途使用不同的集合，例如使用
    *Home* 键在编辑命令时移动到行首，或者在浏览历史记录时选择第一个条目。但首先，让我们利用 zsh 默认安装和原始 ZLE 中已经定义的内容。
- en: Working with keymaps
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键映射
- en: On its own, ZLE comes with some handy bindings in order to cater to Emacs and
    vi users, some of the most popular editors out there. ZLE supports both vi *insert*
    and *read* modes, but defaults to Emacs as this seems to be the most user-friendly
    mapping for new users.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ZLE 本身提供了一些便捷的绑定，以便满足 Emacs 和 vi 用户的需求，它们是最流行的编辑器之一。ZLE 支持 vi *插入*模式和 *读取*模式，但默认使用
    Emacs，因为这对于新用户来说似乎是最友好的映射。
- en: You can access it at any time by typing `bindkey` `-e` in the command line.
    We will be using the Emacs keybinds throughout this book, but feel free to roll
    with the vi mode if you feel more comfortable with it. You can always go back
    to Emacs mode by typing `bindkey` `-e` into your terminal. Whatever you choose,
    keep in mind that ZLE works only in interactive shell sessions, and that you will
    need to add your different configuration entries and bindings to your `.zshrc`
    file as they will be needed to be set for each session.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时通过在命令行中输入 `bindkey` `-e` 来访问它。我们将在本书中使用 Emacs 键绑定，但如果你对 vi 模式更为熟悉，也可以选择使用
    vi 模式。你可以随时通过在终端中输入 `bindkey` `-e` 来返回 Emacs 模式。不论你选择哪种模式，请记住，ZLE 只在交互式 shell
    会话中工作，你需要将不同的配置条目和绑定添加到 `.zshrc` 文件中，因为它们需要在每个会话中设置。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Zsh relies on your environment variables `$EDITOR` and `$VISUAL` in order to
    guess—make an educated guess, that is—which keybind it will default ZLE to. However,
    note that names such as `vile`, which contain the string `vi`, will trigger the
    use of vi keymap. You can add your own safety net of sorts, simply by adding `bindkey
    -e` in your `.zshrc` file to avoid possible conflicts and explicitly setting the
    layout.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Zsh 根据你的环境变量 `$EDITOR` 和 `$VISUAL` 来猜测——准确地说，是做出一个合理的猜测——它将默认使用哪个 ZLE 键绑定。然而，请注意，像
    `vile` 这样的名字，它包含 `vi` 字符串，会触发使用 vi 键映射。你可以通过在 `.zshrc` 文件中添加 `bindkey -e` 来设置自己的安全网，以避免可能的冲突并显式设置键盘布局。
- en: 'For example, in order to default each new session to the Emacs mode, open up
    your `.zshrc` and append the following line:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了将每个新会话默认设置为 Emacs 模式，打开你的 `.zshrc` 文件并附加以下行：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Having a default set in your startup files does not mean you have to commit
    to it at all times though. You can switch between vi and Emacs modes respectively,
    simply by typing the following line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动文件中设置默认值并不意味着你必须一直使用它。你可以通过输入以下命令在 vi 和 Emacs 模式之间切换：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By using the `e` or `v` options, you are telling `bindkey` to link the provided
    `emacs` or `viins` keymaps to the `main` alias, which in turn gets loaded by default
    during startup. If anything goes awry, ZLE will default to `.safe`, which is a
    very constrained mode that provides you with the bare essentials. In such cases,
    your best shot at jumping out of the frying pan is by typing things such as `bindkey
    -e` and pressing *return* in order to switch keybinds. As you might expect then,
    using `.safe` spells trouble with your configuration and thus, is a binding you
    really don't want to see that often.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `e` 或 `v` 选项，你是在告诉 `bindkey` 将提供的 `emacs` 或 `viins` 键映射链接到 `main` 别名，后者将在启动时默认加载。如果发生错误，ZLE
    会默认使用 `.safe` 模式，这是一个非常受限的模式，仅提供最基本的功能。在这种情况下，你最好的办法是通过输入 `bindkey -e` 并按 *return*
    键来切换键绑定。正如你可能预料的那样，使用 `.safe` 模式意味着你的配置出现了问题，因此，这种绑定你真的不希望频繁看到。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As vi users might expect, zsh provides two keymaps for vi: `viins` and `vicmd`.
    Be careful when tinkering with those though, as defaulting to `vicmd` will leave
    you without the ability to insert any kind of text.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 vi 用户可能预期的那样，zsh 提供了两个 vi 键映射：`viins` 和 `vicmd`。不过要小心修改这些设置，因为默认使用 `vicmd`
    会导致你无法插入任何文本。
- en: Basic editing
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本编辑
- en: Now that we have set our default key mapping to Emacs, we can start discussing
    some of its more interesting features such as keyboard shortcuts that speed up
    your tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将默认键映射设置为 Emacs，可以开始讨论一些更有趣的功能，比如能加速任务的键盘快捷键。
- en: 'The following table contains some useful Emacs mappings:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含一些有用的 Emacs 映射：
- en: '| *Ctrl* + *A* | Moves the cursor to the beginning of the line |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *A* | 将光标移动到行首 |'
- en: '| *Ctrl* + *E* | Moves the cursor to the end of the line |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *E* | 将光标移动到行尾 |'
- en: '| *Ctrl* + *W* | Deletes the whole word backwards from the cursor location
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *W* | 删除光标位置前的整个单词 |'
- en: '| *Esc* + *B* | Moves the cursor backwards one word |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *B* | 将光标向后移动一个单词 |'
- en: '| *Esc* + *F* | Moves the cursor forward one word |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *F* | 将光标向前移动一个单词 |'
- en: '| *Ctrl* + *D* | Deletes a character (moves forward) / lists completions /
    logs out |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *D* | 删除一个字符（向前移动）/ 列出补全项 / 登出 |'
- en: '| *Ctrl* + *U* | Deletes the whole line |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *U* | 删除整行 |'
- en: '| *Ctrl* + *K* | Kills (or deletes) until the end of the line |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *K* | 删除到行尾的内容 |'
- en: '| *Esc* + *D* | Deletes one word on the right of the cursor |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *D* | 删除光标右侧的一个单词 |'
- en: '| *Esc* + *Backspace* | Deletes one word on the right of the cursor |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *Backspace* | 删除光标右侧的一个单词 |'
- en: '| *Ctrl* + *Y* | Yanks the last killed word |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *Y* | 拉取最后一个删除的单词 |'
- en: '| *Esc* + *Y* | Switches the last yanked word |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *Y* | 切换最后一次拉取的单词 |'
- en: '| *Ctrl* + *T* | Transposes two characters |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *T* | 转置两个字符 |'
- en: '| *Esc* + *T* | Transposes two words |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| *Esc* + *T* | 转置两个单词 |'
- en: '| *Ctrl* + *R* | Incremental search backwards |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *R* | 向后增量搜索 |'
- en: '| *Ctrl* + *S* | Incremental search forwards (automatically enables `NO_FLOW_CONTROL`
    option) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| *Ctrl* + *S* | 向前增量搜索（自动启用 `NO_FLOW_CONTROL` 选项） |'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your keyboard and input configuration, you could replace the *Esc*
    + button sequences with what is commonly known as the Meta key. This is usually
    mapped to the *Alt* key; however, we'll refer to these kinds of mappings with
    the *Esc* + sequences throughout this text, since they sport the same behavior
    and are arguably more portable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的键盘和输入配置，你可以将 *Esc* + 按键序列替换为通常所说的 Meta 键。这个键通常映射到 *Alt* 键；然而，本文中我们将使用 *Esc*
    + 按键序列来指代这些映射，因为它们具有相同的行为，且更具可移植性。
- en: Going back and forth with words
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在单词之间来回跳转
- en: 'The *Esc* + *B* and *Esc* + *F* bindings are tightly related to the `WORDCHARS`
    shell variable. This is zsh''s way of knowing where any given word begins, although
    the definition of "word" might be rather peculiar for those coming from other
    shells. Particularly, the `WORDCHARS` shell variable defaults to… well, see it
    for yourself:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Esc* + *B* 和 *Esc* + *F* 绑定键与 `WORDCHARS` shell 变量密切相关。这是 zsh 判断给定单词开始位置的一种方式，尽管对于来自其他
    shell 的用户来说，“单词”的定义可能相当特殊。特别地，`WORDCHARS` shell 变量默认值是……嗯，看看你自己就明白了：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See those symbols? These are also considered as part of any given word (besides
    alphanumeric characters, that is). What's important to keep in mind here is the
    rather bipolar behavior of the shell; a character is either part of a word, or
    it isn't. Keep this in mind when using sequences such as *Esc* + *B* or *Esc*
    + *F*, and remember you can always override the `WORDCHARS` definition in those
    rare occasions where it might be required.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这些符号了吗？这些也被认为是单词的一部分（除了字母数字字符）。在这里需要记住的是 shell 的二元行为；一个字符要么是单词的一部分，要么不是。在使用
    *Esc* + *B* 或 *Esc* + *F* 这样的快捷键时请记住这一点，并且在那些特殊情况下，你总是可以覆盖 `WORDCHARS` 的定义。
- en: Yanking and transposing text
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉取和转置文本
- en: You might have noticed the terms *yanking* and *transposing* in the shortcuts
    table and immediately addressed your thoughts with a healthy dose of what? So
    let's expand a bit more on that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到在快捷键表中有 *yanking* 和 *transposing* 这些术语，可能立即想到了“什么？”这种疑问。所以让我们来进一步解释一下。
- en: 'Transposing (*Ctrl* + *T*) might be a fancy name, but rest assured its functionality
    is nowhere near as complicated to understand as it sounds. Put simply, transposing
    a character will swap its place with the one immediately following it on the right,
    making it march valiantly towards the end of the line, one place at a time. Once
    there, it''ll only swap positions with the character immediately before it. This
    might be a bit confusing, so let''s get going with an example as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 转置（*Ctrl* + *T*）可能是个花哨的名字，但请放心，其功能远没有听起来那么复杂。简单来说，转置一个字符会将它与右边紧挨着的字符交换位置，使其勇敢地向行尾移动，一次交换一个位置。一旦到达行尾，它只会与前一个字符交换位置。这可能有些困惑，我们通过一个例子来说明：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s not right. Let''s edit our previous history entry:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这不对。让我们编辑一下之前的历史记录：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now move your prompt on top of `a`—the more straightforward way of doing this
    is by hitting the end-of-the line shortcut, *Ctrl* + *E*—and hit the transpose
    shortcut, *Ctrl* + *T*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将光标移到 `a` 上——最直接的方法是按行尾快捷键 *Ctrl* + *E*——然后按下转置快捷键 *Ctrl* + *T*。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`a` and `c` switched places. Progress! Now go back one char to the left, placing
    your cursor on top of `a` again and, again hit the transpose shortcut.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 和 `c` 交换了位置。进展！现在再回退一个字符，光标重新定位到 `a` 上，然后再次按下转置快捷键。'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Success! As we'll see in [Chapter 5](ch05.html "Chapter 5. Completion"), *Completion*,
    automatic completion will amend most of these silly mistakes; however, transposing
    comes in really handy on those occasions when you mistype things like parameter
    flags or URLs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！正如我们将在[第 5 章](ch05.html "第 5 章 完成")中看到的，*自动补全*将修正这些愚蠢的错误；然而，在你输入诸如参数标志或 URL
    之类的错误时，转置功能就非常有用了。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A mistyped `git push` sentence can be easily fixed by simply navigating to `u`
    in `psuh` and hitting transpose.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 错误输入的 `git push` 命令可以通过简单地导航到 `psuh` 中的 `u` 并按下转置快捷键来轻松修复。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The same rules apply to the word transposing mechanism (*Esc* + *T*). The only
    difference, as you might have guessed already, is that it works with whole words
    instead of just chars.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于单词交换机制 (*Esc* + *T*)。唯一的不同，正如你可能已经猜到的，它作用于整个单词，而不仅仅是字符。
- en: 'As the old saying goes, actions speak louder than words, so the following is
    another example, this time by transposing words:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如古老的谚语所说，行动胜于言辞，以下是另一个例子，这次是通过交换单词来演示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whoops! Got that completely backwards, time for some *Esc* + *T*. Put your prompt's
    cursor right on top of `hello` and hit the transpose shortcut.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！完全弄反了，赶紧来一个 *Esc* + *T*。将光标放在 `hello` 上，按下交换位置的快捷键。
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sure enough, this will give the *Backspace* key a much-deserved vacation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，这将让 *Backspace* 键得到了应得的休假。
- en: 'Yanking seems a bit harder to explain, but basically boils down to inserting
    a word you previously deleted by any of the kill shortcuts (*Ctrl* + *W*, *Ctrl*
    + *U*, *Ctrl* + *K*, *Esc* + *D*, *Esc* + *Backspace*). It works as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 粘贴操作看起来有点难以解释，但基本上就是插入你之前通过任一 kill 快捷键删除的单词（*Ctrl* + *W*、*Ctrl* + *U*、*Ctrl*
    + *K*、*Esc* + *D*、*Esc* + *Backspace*）。其工作原理如下：
- en: Start typing your command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开始输入你的命令。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Realize you made a mistake, and kill the offending part. In this example, we
    use *Esc* + *Backspace* to delete the `hello` string.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到你犯了个错误，然后删除错误的部分。在这个例子中，我们使用 *Esc* + *Backspace* 删除 `hello` 字符串。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now move the cursor one word backwards, using the *Esc* + *B* bind.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 *Esc* + *B* 快捷键将光标向后移动一个单词。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And yank the `hello` string into the line by pressing *Ctrl* + *Y* (note that
    in this particular case, you will need to add an extra space between both the
    words and the `_` character is there to show where the prompt cursor should be).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过按 *Ctrl* + *Y* 将 `hello` 字符串粘贴到当前行（请注意，在此情况下，你需要在单词之间加一个额外的空格，`_` 字符表示光标应放置的位置）。
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After using the *Ctrl* + *Y* shortcut for yanking, you can call the *Esc* +
    *Y* shortcut to swap between previously deleted words. The shell you see retains
    up to 10 deleted words in memory, in case you need to use them again. This sort
    of "deleted words clipboard" is popularly known as the kill ring due to its behavior—you
    will swap each of the killed words up to the last, and then start again from the
    very first by repeatedly pressing *Esc* + *Y*. However, note that pressing *Ctrl*
    + *Y* again will only insert a new previously yanked word.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 *Ctrl* + *Y* 快捷键进行粘贴后，你可以通过 *Esc* + *Y* 快捷键来在之前删除的单词之间切换。你所看到的 shell 会保留最多
    10 个删除的单词，以防你需要再次使用它们。这种“删除单词剪贴板”因其行为被称为 kill ring —— 你会交换每个已删除的单词直到最后一个，然后通过反复按
    *Esc* + *Y* 从第一个开始重新循环。然而，注意再次按 *Ctrl* + *Y* 只会插入一个新的先前粘贴的单词。
- en: Revisiting history
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾历史
- en: As you might have noticed in the Emacs shortcuts table, there are quite a few
    shortcuts we can use to work with history. So let's put ZLE to better use and
    build on the *History expansion* section from [Chapter 2](ch02.html "Chapter 2. Alias
    and History"), *Alias and History*, with our newly learned bindings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在 Emacs 快捷键表中注意到的那样，我们可以使用相当多的快捷键来操作历史记录。那么，让我们更好地利用 ZLE，并结合我们新学到的绑定，进一步扩展
    [第 2 章](ch02.html "第 2 章. 别名与历史") 中的 *历史扩展* 部分。
- en: Turns out we can use *Esc* + *<* to go to the very beginning of our history
    file, that is, the first entry of our log. Likewise, pressing *Esc* + *>* will
    deliver us to the end of the history file. However, that's hardly convenient for
    larger history logs. What we really need is to perform an incremental search.
    *Ctrl* + *R* is the default provided mechanism in zsh, and this will show us a
    prompt in which we can type to use as an immediate search filter. The more you
    type, the more precise the match is.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 原来我们可以使用 *Esc* + *<* 跳到历史文件的最开始，也就是日志的第一个条目。同样，按 *Esc* + *>* 可以将我们送到历史文件的末尾。不过，这对于较大的历史日志并不方便。我们真正需要的是执行增量搜索。*Ctrl*
    + *R* 是 zsh 提供的默认机制，它会显示一个提示框，你可以在其中输入以作为即时搜索过滤器。你输入的越多，匹配就越精确。
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Start typing and once you have found the history entry you were looking for,
    you can either go ahead and press *return* to execute it, or the left-arrow/right-arrow
    key to edit the selected entry. You can exit this mode at any time by pressing
    *Ctrl* + *G*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 开始输入，一旦找到你想要的历史记录条目，你可以按 *return* 执行它，或者按左箭头/右箭头键编辑选中的条目。你可以随时通过按 *Ctrl* + *G*
    退出此模式。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The incremental search mode has its own keymap, conveniently called `isearch`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 增量搜索模式有自己的键映射，称为 `isearch`。
- en: It's very likely that your terminal is set to use the *Ctrl* + *Q* and *Ctrl*
    + *S* combinations for flow control, respectively stopping and resuming any output
    to the terminal. In order to avoid overlapping the default `history-search-forward`
    binding (also *Ctrl* + *S*), zsh offers the `NO_FLOW_CONTROL` option, which can
    be set in your startup files.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你的终端设置了使用*Ctrl* + *Q*和*Ctrl* + *S*组合键来进行流控，分别用于停止和恢复终端输出。为了避免与默认的`history-search-forward`绑定（也就是*Ctrl*
    + *S*）冲突，zsh提供了`NO_FLOW_CONTROL`选项，可以在启动文件中进行设置。
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will safely disable such behavior within the shell (other programs can
    depend on flow control normally) and thus, is the recommended way of using *Ctrl*
    + *S*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安全地禁用终端内的该行为（其他程序通常依赖于流控），因此，使用*Ctrl* + *S*时建议采用这种方式。
- en: Advanced editing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级编辑
- en: So far we have discovered our way around the command line and started to get
    the hang of ZLE. It's time we kick it up a notch though, so we can see what the
    line editor is really capable of.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经掌握了命令行的基本操作，并且开始习惯ZLE的使用。现在是时候更进一步，看看行编辑器到底能做什么了。
- en: ZLE-related options
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZLE相关选项
- en: 'This chapter wouldn''t be complete without some options for us to tinker with
    now, would it? The following are some things to try if you are looking to modify
    ZLE''s default behavior:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一些选项让我们现在来调试一下，这一章怎么能算完呢？以下是一些可以尝试的内容，如果你想修改ZLE的默认行为：
- en: '`NO_BEEP`: This option skips beeping on errors.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_BEEP`: 该选项可以跳过错误时的蜂鸣提示。'
- en: '`OVERSTRIKE`: This defaults the editor to the insert mode. The way it works
    is that each new character replaces the one to the immediate right, instead of
    displacing it one position to the right as default.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OVERSTRIKE`: 该选项将编辑器默认设置为插入模式。其工作原理是每输入一个新字符，它会替换当前光标右侧的字符，而不是像默认设置那样将其推移到右边一个位置。'
- en: '`SINGLELINEZLE`: It turns off multiline editing. No, I''m not on drugs. This
    could be used as a reminder of darker times.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINGLELINEZLE`: 关闭多行编辑。不，我没有吸毒。这可以作为一种提醒，提醒我们曾经度过的黑暗时光。'
- en: Sprinkle some of these on your startup files (namely, `.zshrc`) and you'll be
    all set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些选项添加到你的启动文件（特别是`.zshrc`）中，你就完成了设置。
- en: Defining your own keymaps
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义你自己的键映射
- en: Besides the Emacs and vi mode-setting options, the `bindkey` built-in allows
    you to create your own keymaps and alias them by using a couple of simple options.
    Namely, the `-N` flag will let you define a new keymap on the fly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Emacs和vi模式设置选项外，`bindkey`内置命令还允许你创建自己的键映射，并使用几个简单的选项将它们定义为别名。特别是，`-N`标志让你可以即时定义一个新的键映射。
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Or even create one based on an existing one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者基于现有的配置创建一个新的。
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can then alias your new keymap with the `-A` option by simply issuing the
    following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以通过简单地输入以下命令，使用`-A`选项将新的键映射定义为别名：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating the alias `mymacs` for the existing `mycoolmap` keybind will allow
    you to eventually use `bindkey -D mycoolmap` to delete it without the fear of
    losing your settings. Turns out that both aliases are treated as separate keybinds;
    thus, deleting one does not affect the other. This proves useful during the time
    you are experimenting with bindings and wish to start from scratch, or just wish
    to have a backup of sorts for when things go awry. Be careful when naming your
    aliases though, as any existing keybind will be immediately replaced by the new
    alias if their names are the same!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为现有的`mycoolmap`键绑定创建别名`mymacs`，可以让你在以后使用`bindkey -D mycoolmap`删除它，而无需担心丢失设置。事实证明，这两个别名被视为独立的键绑定；因此，删除其中一个不会影响另一个。这在你尝试修改绑定时非常有用，尤其是在你希望从头开始，或者只是希望有一个备份，以防设置出现问题。不过要小心命名你的别名，因为如果它们的名称相同，任何现有的键绑定都会立即被新的别名替换！
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should avoid naming your own keymaps starting with the dot `.` character
    as future editions of zsh might eventually ship with conflicting namespaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免命名自己的键映射以点符号`.`开头，因为zsh的未来版本可能会带有冲突的命名空间。
- en: The `bindkey` command also has quite a few other options at its disposal. Of
    particular interest when populating your startup files are the listing options.
    Namely, `l` and `L` allow you to list the available keymaps in different formats.
    By typing `bindkey -l`, you can quickly have a look at the currently available
    keymaps, while issuing `bindkey -lL` will format the output as a series of the
    `bindkey` commands.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`bindkey`命令还有许多其他可用的选项。特别是在填充启动文件时，列出选项很有用。具体来说，`l`和`L`允许你以不同格式列出可用的键映射。通过输入`bindkey
    -l`，你可以快速查看当前可用的键映射，而输入`bindkey -lL`则会将输出格式化为一系列`bindkey`命令。'
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also use this option in order to check if a particular keymap is a
    link:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用此选项来检查某个特定的键映射是否是链接：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This tells you that, as expected, `mymacs` is an alias for the `mycoolmap` keymap
    we defined earlier on. By using the `-lL` option to check the `main` alias, you
    have a practical way of determining the keymap currently in use.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你，正如预期的那样，`mymacs`是我们之前定义的`mycoolmap`键映射的别名。通过使用`-lL`选项来检查`main`别名，你就有了一个实用的方法来确定当前正在使用的键映射。
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, you can use the `-L` option to have a list of all your current bindings,
    including those of a built-in keymap, formatted in a way you can use within your
    scripts:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`-L`选项列出所有当前绑定的键，包括内置键映射的绑定，并将其格式化为可以在脚本中使用的方式：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just copy and paste the output into your startup files and you have the foundation
    for your custom keymap. It's just a matter of replacing the action or shortcut
    keys with something that better suits your needs, and you are done. Handy, isn't
    it?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将输出复制并粘贴到启动文件中，你就有了自定义键映射的基础。你只需将操作或快捷键替换为更适合你需求的内容，完成即可。很方便，不是吗？
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can use the `read` utility in order to figure out the actual escape sequence
    your terminal emulator is sending to the shell; just call `read` and then input
    the sequence you want to try out. For example, the following is what *Ctrl* +
    back-arrow is sending on my system:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`read`工具来找出终端仿真器发送给shell的实际转义序列；只需调用`read`，然后输入你想尝试的序列。例如，以下是*Ctrl* + back-arrow在我的系统上发送的内容：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Some keys such as *Backspace* might require you to use the `-k` option, which
    allows you to specify the number of characters to read. Used by itself, it'll
    default to one.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些键，例如*Backspace*，可能需要你使用`-k`选项，这样你可以指定要读取的字符数。单独使用时，它将默认读取一个字符。
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now (press *Backspace*.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在（按下*Backspace*键）。
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Keep in mind that you can exit the `read` command at any time by pressing *Ctrl*
    + *C*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以随时通过按下*Ctrl* + *C*来退出`read`命令。
- en: 'Emacs users will find themselves at home with the *Esc* + *X* sequence. By
    pressing *Esc* followed by the key *X*, ZLE greets you with an `execute` prompt.
    You can then start typing in your commands and even use the *Tab* key for auto-completion
    help. For example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Emacs用户会发现自己对*Esc* + *X*组合键非常熟悉。按下*Esc*，然后按*X*键，ZLE会向你展示`execute`提示符。然后你可以开始输入命令，甚至可以使用*Tab*键来获得自动补全帮助。例如：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The reason we used *Ctrl* + *A* is for the prompt to be at the beginning of
    the line, just before the rest of the string.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*Ctrl* + *A*的原因是为了让提示符出现在行的最开始位置，紧跟其后的字符串之前。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you can exit the `execute` prompt at any time by using the *Ctrl*
    + *G* sequence.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你可以随时通过使用*Ctrl* + *G*组合键退出`execute`提示符。
- en: As the astute reader might have noticed, there are quite a few ways of achieving
    the same behavior, but that's partially missing the point of the `execute` sequence.
    It is there simply to allow you to do things you would normally not do (either
    because of an awkward shortcut or lack of muscle memory); execute it and its completion
    mechanism will make recalling commands a snap.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如敏锐的读者可能注意到的那样，确实有许多方法可以实现相同的行为，但这在某种程度上偏离了`execute`序列的重点。它的存在仅仅是为了让你做一些平时不会做的事情（可能是因为快捷键不便或缺乏肌肉记忆）；执行它及其完成机制将使得回忆命令变得轻而易举。
- en: 'In the same vein as `execute`, `where-is`—which is unbound to any sequence
    by default—will show you how to perform any given command. Just call `execute`,
    type `where-is` (you can use Tab for completion just as before) and press *return*.
    This time you will be greeted with the `Where is:` prompt, where you can also
    use completion to list any command you are after. Press *return* for ZLE to show
    you the sequence bound to the said command. For example, we can use `where-is`
    to find an alternative shortcut to our `capitalize-word` example as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与`execute`类似，`where-is`——默认情况下没有绑定任何序列——将向你展示如何执行给定的命令。只需调用`execute`，输入`where-is`（就像之前一样，你可以使用Tab进行自动补全），然后按下*return*键。这时，你将看到`Where
    is:`提示符，你也可以使用补全来列出你需要的命令。按下*return*键，ZLE将显示绑定到该命令的序列。例如，我们可以使用`where-is`来找到我们`capitalize-word`示例的替代快捷键，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Well, look at that. Turns out we can capitalize the word immediately after the
    prompt by using the *Esc* + *C* combination.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看这个。原来我们可以通过使用*Esc* + *C*组合键，在提示符后立即将单词首字母大写。
- en: Don't call them widgets
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别叫它们小部件
- en: There comes a time in the life of any eager zsh learner to talk about widgets.
    It's time you and me had that talk already.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个渴望学习zsh的学生都会经历谈论小部件的时刻。是时候你我一起谈谈它了。
- en: Ever wondered how all those keybindings and special actions are put together
    and work marvelously? Well, we have widgets to thank for that. See, zsh likes
    to delegate responsibilities whenever it can, and widgets are a prime example
    of that; instead of having to deal with handling every little action performed
    by key sequences (similar to those defined in your keymaps), zsh relies on widgets
    to do the actual work. Think of them as small functions designed to carry out
    a simple mission. I, on the other hand, like to think of them as those sneaky
    gnomes that make magic happen in the kitchen whenever I'm not around.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经想过所有那些键绑定和特殊动作是如何组合在一起并完美运行的吗？嗯，我们得感谢小部件。看看，zsh喜欢在能委派责任的地方就委派，而小部件就是一个典型的例子；它不需要处理每一个由按键序列执行的小动作（类似于你在键映射中定义的那些），而是依赖小部件来做实际的工作。把它们想象成执行简单任务的小函数。另一方面，我更喜欢把它们想象成那些在厨房里悄悄施展魔法的小矮人，只要我不在场。
- en: ZLE comes with quite a few built-in widgets, each boasting two names, a vanilla
    name and a hidden name, which is simply defined as the normal name and preceded
    by a dot `.` character. Hidden names are there just to signal that they can't
    be rebound to a different widget (thus creating a backup copy that's always available
    in case your keybind definitions go awry).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ZLE自带了相当多的内置小部件，每个小部件都有两个名称，一个是常规名称，另一个是隐藏名称，隐藏名称就是在常规名称前加上一个点（`.`）字符。隐藏名称的存在仅仅是为了表示它们不能被重新绑定到其他小部件（从而创建一个备份副本，确保在你的键绑定定义出错时始终可用）。
- en: As you might have guessed, that's not the whole deal; widgets can be user-defined
    or defined by other modules (such as ZLE or the built-in FTP client, `zftp`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，这并不是全部；小部件可以是用户自定义的，也可以由其他模块（如ZLE或内置的FTP客户端`zftp`）定义。
- en: Defining your own widgets
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义你自己的小部件
- en: Defining your own widgets doesn't get more complicated than calling `zle -N`
    with your widget's name on it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 定义你自己的小部件并不会比用`zle -N`命令调用小部件的名称更复杂。
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The previous example, a slight variation from one of the suggestions available
    at the zsh wiki site ([http://zshwiki.org](http://zshwiki.org)), binds the *Esc*
    + *T* combination to the built-in tetris module, so you can spend those idle times
    on the command line a bit more entertained.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子稍微改编自zsh wiki网站的建议之一（[http://zshwiki.org](http://zshwiki.org)），将*Esc* +
    *T*组合键绑定到内置的tetris模块，这样你就可以在命令行的空闲时光中更加娱乐。
- en: 'Let''s go over it, line by line:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析一下：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is the good old `autoload` module, which handles the loading of different
    modules and functions across the shell. In this particular case, we're importing
    the `tetris` module for later use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是老掉牙的`autoload`模块，用于处理在shell中加载不同的模块和函数。在这个特定的例子中，我们正在导入`tetris`模块以供后续使用。
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is where the magic actually happens; we're defining the new widget by calling
    ZLE with the `-N` option and telling it that the name for our new widget is `tetris`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是魔法真正发生的地方；我们通过调用ZLE并使用`-N`选项，告诉它我们新小部件的名称是`tetris`，来定义新的小部件。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that hidden names are special for widgets, so refrain from using
    names starting with a dot (`.)`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，隐藏名称对于小部件来说是特殊的，因此避免使用以点（`.`）开头的名称。
- en: 'We wrap up the definition simply by binding our newly defined widget to the
    *Esc* + *T* shortcut on the keyboard:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将新定义的小部件绑定到键盘上的*Esc* + *T*快捷键，简单地完成了定义：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the bold **tetris** call there refers to the widget we defined and
    not the actual `tetris` module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**tetris**的粗体调用指的是我们定义的小部件，而不是实际的`tetris`模块。
- en: 'Now, to actually see this in action, you''ll have to either add it to your
    `.zshrc` file or save it as a separate file and source it from `.zshrc`, just
    as we''ve done before. So go ahead and save this as `.zsh_tetris` in your `$HOME`
    folder, and source it from `.zshrc` by adding the following line:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了实际看到它的效果，你必须将其添加到你的`.zshrc`文件中，或者将其保存为单独的文件并从`.zshrc`中引用，就像我们之前做的那样。所以，去吧，把它保存为`.zsh_tetris`到你的`$HOME`文件夹中，并通过添加以下行从`.zshrc`引用它：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now go ahead and type *Esc* + *T* to enjoy your new widget.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下*Esc* + *T*组合键，享受你新的小部件。
- en: '![Defining your own widgets](img/2937OS_03_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![定义你自己的小部件](img/2937OS_03_01.jpg)'
- en: Just some Tetris. Yes, I'm rusty.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 只是玩了几局俄罗斯方块。是的，我有点生疏了。
- en: Special variables
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊变量
- en: Some special variables that are available in ZLE should come in handy when defining
    your own widgets for editing and/or manipulating the command line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在ZLE中，有些特殊变量在定义你自己的小部件以编辑和/或操作命令行时会派上用场。
- en: 'The following list contains some of the most commonly used references:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含了一些最常用的引用：
- en: '`CURSOR`: This is the current position of the cursor on the command line.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CURSOR`：这是当前光标在命令行上的位置。'
- en: '`BUFFER`: This contains the current editing buffer and can span multiple lines.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUFFER`：这是当前编辑缓冲区的内容，可以跨越多行。'
- en: '`LBUFFER`/`RBUFFER`: These are the contents to the left and right of the current
    cursor, respectively. They too can span multiple lines.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LBUFFER`/`RBUFFER`：分别表示当前光标左侧和右侧的内容。它们也可以跨越多行。'
- en: '`PREBUFFER`: This contains the buffer already read when editing a continuation
    line.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREBUFFER`：这是编辑续行时已经读取的缓冲区内容。'
- en: '`WIDGET`: This gives the name of the widget currently in use by the editor.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WIDGET`：这是当前编辑器正在使用的小部件的名称。'
- en: By using these variables you can, for example, know precisely which character
    is currently under the cursor by simply using the `${BUFFER[CURSOR]}` expression.
    This might as well read as "the value of the `BUFFER` array for the `CURSOR` position"
    (remember, `CURSOR` is just a number that tells which column the prompt is at).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些变量，你可以例如通过简单地使用`${BUFFER[CURSOR]}`表达式来精确知道当前光标下的字符是什么。这也可以理解为“`BUFFER`数组中`CURSOR`位置的值”（记住，`CURSOR`只是一个数字，表示提示符所在的列）。
- en: Your first function
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个函数
- en: You can achieve even more complex behavior by defining your own functions. Each
    time the widget is executed, it'll call the corresponding function. Let's kick
    it up a notch with our second widget.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义自己的函数来实现更复杂的行为。每次小部件执行时，它都会调用相应的函数。让我们用第二个小部件把它提升到一个新层次。
- en: 'For the following example, we''ll work with a variant of the excellent `rationalize-dot`
    widget, as presented on the ZSH-LOVERS'' manpage ([http://grml.org/zsh/zsh-lovers.html](http://grml.org/zsh/zsh-lovers.html)):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将使用一个改进版的优秀`rationalize-dot`小部件，正如在ZSH-LOVERS的man页中展示的那样（[http://grml.org/zsh/zsh-lovers.html](http://grml.org/zsh/zsh-lovers.html)）：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And now let's go ahead and go over it line by line.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐行讲解它。
- en: 'Firstly, we''re defining our own function here, called `rationalize-dot`. The
    way we declare a function is simply a matter of giving it a special name, followed
    by parentheses as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在这里定义了自己的函数，叫做`rationalize-dot`。声明函数的方法很简单，就是给它起一个特殊的名字，后跟圆括号，如下所示：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The curly braces `{}` you see there are the delimiters of the function body;
    whatever lays between them is considered part of the function, just like the `my_code`
    stub in the preceding example.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的花括号`{}`是函数体的定界符；它们之间的内容视为函数的一部分，就像前面示例中的`my_code`占位符。
- en: 'Alternatively, you can also define functions using the reserved keyword `function`
    and using a slight variation of the previous syntax as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以使用保留关键字`function`来定义函数，并略微变化之前的语法，如下所示：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we trade the parentheses for the preceding function keyword.
    Otherwise, both syntaxes represent the same thing and are interchangeable. So
    pick whatever floats your boat.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将圆括号换成了前面的函数关键字。否则，两种语法表示的是相同的内容，可以互换使用。所以，随便选择一个你喜欢的方式。
- en: Likewise, calling a function doesn't get any more complicated than explicitly
    writing its name; `my_function`, in this particular case.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，调用一个函数并不会比明确写出它的名称更复杂；在这个例子中就是`my_function`。
- en: 'Back to the `rationalize-dot` example, the second line there is an `if` statement,
    the most basic control flow mechanism provided by the shell. When used in its
    full glory, an `if` statement will resemble the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`rationalize-dot`的例子，第二行是一个`if`语句，这是shell提供的最基本的控制流机制。用最完整的形式时，`if`语句将类似于如下：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In its most basic form, `if` statements test for a Boolean condition, an expression
    or command that resolves as either true or false (or has an exit status to indicate
    this), and takes action accordingly. Whatever is not suitable for the first clause,
    the `else` part will gladly take care of as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，`if`语句测试一个布尔条件，即一个表达式或命令，结果为真或假（或具有表示这一点的退出状态），并据此采取相应的行动。对于第一个条件不适用的部分，`else`部分将会处理如下：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the `fi` at the end? Think of the first `if` as an opening brace `{`
    character, and the `fi` as the closing one `}`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结尾的`fi`吗？把第一个`if`当作是一个打开的花括号`{`，而`fi`就是闭合的花括号`}`。
- en: The previous sample will test the condition `condition`, if it evaluates to
    something that is true, our mock function will call the `do_a_barrel_roll` code.
    If `condition` is not true (what is popularly known as false), then the `else`
    block gets called, and dutifully issues an `echo "can't do it"` command.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例会测试条件`condition`，如果其评估为真，我们的模拟函数将调用`do_a_barrel_roll`代码。如果`condition`不为真（即通常所说的假），那么`else`块将被调用，并负责发出`echo
    "can't do it"`命令。
- en: The `elif` statement simply means "else, if" and is used to evaluate further
    conditions. You can add as many `elif` clauses as the options you have, but be
    careful when traversing down that road; neat code becomes wild spaghetti in a
    matter of keystrokes if not properly tamed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`语句意味着“否则，如果”，用于进一步评估条件。你可以根据选项的数量添加尽可能多的`elif`子句，但在遍历这个过程时要小心；如果不恰当地处理，整洁的代码会迅速变成混乱的“意大利面”代码。'
- en: In the `rationalize-dot` example, the `if` statement tests whether the `LBUFFER`
    variable matches the expression `*..`, which actually means "has the user typed
    anything followed by two periods?". If that's the case, then append a `/..` expression
    to the buffer variable. Otherwise, just let the `else` statement handle it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rationalize-dot`的例子中，`if`语句会检查`LBUFFER`变量是否匹配表达式`*..`，实际上是“用户是否输入了某些内容并跟着两个句号？”如果是这样，那么将`/..`表达式追加到缓冲区变量中。否则，让`else`语句来处理它。
- en: 'As per the `else` block, it''ll just add an actual period to the buffer:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`else`块，它只会向缓冲区添加一个实际的句号：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This might not seem a logical decision at first, until we move into the following
    lines:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能看起来并不合逻辑，直到我们进入接下来的几行：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first one is the standard widget declaration we've seen before, but the
    binding immediately after it is what makes the `rationalize-dot` function require
    the `else` statement to add a period. As it's called on each dot press (the keybinding
    it's being assigned), this requires you to behave as an actual period key if the
    user hasn't typed anything yet.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是我们之前见过的标准小部件声明，但紧接其后的绑定使得`rationalize-dot`函数需要`else`语句来添加一个句号。因为它在每次按下句号键时被调用（即它所绑定的快捷键），所以如果用户还没有输入任何内容，它就需要像一个实际的句号键那样表现。
- en: As before, you can go ahead and add this to your `.zshrc` (or any other module
    that gets sourced by it) and take it out for a spin; just type `...` and see what
    happens after that third dot gets pressed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如同之前一样，你可以将其添加到`.zshrc`文件中（或其他任何由其加载的模块），然后进行测试；只需输入`...`，看看按下第三个句号后会发生什么。
- en: As we'll see later in [Chapter 5](ch05.html "Chapter 5. Completion"), *Completion*,
    you can also let the shell source functions automatically by extending or adding
    them to your `$fpath` variable.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将在[第五章](ch05.html "第五章：补全")中看到的，*补全*，你还可以通过扩展或将它们添加到你的`$fpath`变量中，让 shell
    自动加载函数。
- en: This is particularly useful in combination with the `cd` command and an unhealthy
    dose of nested folders.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这在与`cd`命令和大量嵌套文件夹结合使用时尤其有用。
- en: Want to go further? You'll find tons of predefined built-in widgets for customizing
    your keybindings in the `zshzle(1)` manpage's *STANDARD WIDGETS* section. Just
    type `man zshzle` to get started.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 想更进一步吗？你会在`zshzle(1)`手册页的*标准小部件*部分找到大量用于自定义快捷键绑定的预定义内建小部件。只需输入`man zshzle`来开始。
- en: Working with regions
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用区域
- en: Continuing the legacy of Emacs' inherited behavior, you can set regions in the
    command line by holding *Ctrl* and pressing the Space bar. This will trigger a
    region selection mechanism that you can expand with the arrow keys, which works
    just as if you were clicking and dragging your mouse to highlight text.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 继续延续 Emacs 继承的行为，你可以通过按住*Ctrl*键并按下空格键来设置命令行中的区域。这将触发一个区域选择机制，你可以通过箭头键进行扩展，就像你用鼠标点击并拖动来高亮文本一样。
- en: So, why bother with regions? You could, for example, mark a region via the *Ctrl*
    + Space bar sequence and then perform a command on top of it (similar to `capitalize-word`
    we saw earlier), or even mix-in the previously mentioned `execute-command` to
    call a function that has no keybind. Overall, these few niceties straight from
    Emacs give ZLE (and of course, zsh) the versatility to behave almost like a full-fledged
    editor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用区域呢？举个例子，你可以通过*Ctrl* + 空格键组合标记一个区域，然后在其上执行一个命令（类似于我们之前看到的`capitalize-word`），或者甚至将前面提到的`execute-command`混合进来，调用一个没有绑定的函数。总体来说，这些来自
    Emacs 的小细节使得 ZLE（当然，还有 zsh）具备了几乎像一个完整编辑器一样的多功能性。
- en: Multiline editing
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行编辑
- en: At this point, it should be no surprise to learn that zsh is smart enough to
    notice when you aren't done with a line. Unlike most other shells though, zsh
    is also capable of suggesting what might be missing, or even allowing you to use
    multiple rows of lines for entering your commands. Unlike traditional continuation
    where you put a `\` character at the end of the line and press *return* to continue
    on the one immediately below, ZLE will greet you with the `$PS2` prompt and add
    more of context information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，得知zsh足够聪明，能够识别你是否完成了一行的输入，应该不会感到惊讶。不过，与大多数其他shell不同，zsh还能够建议你可能缺少的内容，甚至允许你使用多行输入命令。不同于传统的续行方式，在那种方式中你在行末加上`\`字符并按*回车*继续输入下一行，ZLE会用`$PS2`提示符迎接你，并且添加更多的上下文信息。
- en: 'On most flavors of Bourne-derived shells, you can use the following line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Bourne衍生的shell中，你可以使用以下命令：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Press *return* (notice there is absolutely nothing after the `\` char).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按*回车*（注意在`\`字符后面什么也没有）。
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Press *return* again, and it''ll work just like the `ls -a` command. Zsh will
    give you a bit more context as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次按*回车*，它将像`ls -a`命令一样工作。Zsh会给你更多的上下文信息，像这样：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `$PS2` prompt (the alternative/second prompt) is called in order to signal
    that the shell is waiting for the rest of the double-quote assignment. Go ahead
    and wrap it up as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`$PS2`提示符（备用/第二个提示符）会被调用，用来表示shell在等待剩余的双引号赋值。继续并按如下方式完成：'
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There''s more to multiline editing than alternative prompts though. You can
    use the *Esc* + *return* shortcut to add a new continuation line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 多行编辑不仅仅是备用提示符那么简单。你可以使用*Esc* + *回车*快捷键来添加一个新的继续行：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And press *return* to see both the lines execute sequentially, just as though
    it were a script. Keep in mind that you are not limited to just two lines and
    can add as many lines as you want.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 再次按*回车*，你将看到两行代码按顺序执行，就像它们是一个脚本一样。记住，你不只限于两行，你可以添加任意多的行。
- en: This sorcery owes its powers to the `self-insert-unmeta` command, whose job
    consists simply of inserting a carriage return character into the line. So now
    you know that each time you press *Esc* + *return*, you are actually using a shortcut
    to the `self-insert-unmeta` command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这项魔法的力量归功于`self-insert-unmeta`命令，它的作用仅仅是将回车符插入到行中。所以现在你知道，每次按下*Esc* + *回车*，你实际上是在使用`self-insert-unmeta`命令的快捷方式。
- en: 'Besides the obvious "being different" feeling, what''s really convenient about
    the *Esc* + *return* method is that you can move across lines as you please by
    using the arrow keys. To top it off, each multiline entry is treated as a whole
    line. Just press the up-arrow and you will see the block you previously typed
    come back to life for you to edit. While we are at it, I''d like you to meet the
    `push-line-or-edit` command, which allows you to convert a previously typed block
    of lines into a single block whenever you are on a continuation (otherwise it''ll
    behave like a normal push-line command). It works more or less as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的“不同”的感觉之外，*Esc* + *回车*方法的真正便利之处在于，你可以通过使用箭头键在行间随意移动。更棒的是，每个多行输入会被当作一整行处理。只需按上箭头，你会看到你之前输入的代码重新回到屏幕上，供你编辑。既然我们在讲这个，我还想让你了解一下`push-line-or-edit`命令，它允许你在继续输入时将之前输入的一块行转换成一个单独的块（否则它将像普通的push-line命令一样工作）。它大致是这样工作的：
- en: 'Start entering your function in the command line, pressing *return* after the
    first `if` line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中开始输入你的函数，在第一个`if`语句之后按*回车*：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And stop right there. Realize you have made a terrible mistake with the condition
    clause of the `if` statement (apart from the extremely simple logic… but hey,
    this is an example). Unfortunately, you can't scroll back to the previous line
    with the up-arrow button as you have already pressed *return* and that would trigger
    the history search behavior, so what's next? Well, `push-line-or-edit`, of course.
    Hit *Esc* + *X* in order to execute a command, and type `push-line-or-edit` (you
    can use the *Tab* key for completion) and press *return*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 停下来。意识到你在`if`语句的条件子句中犯了一个严重的错误（除了那个极其简单的逻辑...但嘿，这是一个示例）。不幸的是，由于你已经按下了*回车*，你无法通过上箭头按钮滚动回上一行，这会触发历史搜索行为，那么接下来该怎么办呢？当然是`push-line-or-edit`。按下*Esc*
    + *X*来执行一个命令，输入`push-line-or-edit`（你可以使用*Tab*键进行自动补全），然后按下*回车*。
- en: 'The prompt will change to a traditional one (ditching the `then>` indicator
    from the continuation line), and you will have a new buffer filled with all your
    previously typed lines which, of course, you can edit at will as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符将变为传统样式（去掉了续行中的`then>`指示符），你将拥有一个新缓冲区，里面填充了你之前输入的所有行，当然，你可以像这样随意编辑：
- en: '[PRE48]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Seeing how much better a push-line `push-line-or-edit` is, it''s of course
    advisable to bind it to the default `push-line` shortcut, either `^q` or `\eq`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了`push-line-or-edit`有多么优越，显然建议将其绑定到默认的`push-line`快捷键，`^q` 或 `\eq`：
- en: '[PRE49]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And now you can either use the *Ctrl* + *Q* or *Esc* + *Q* shortcuts to edit
    a whole block as if it were a single line. As with the `history-search-forward`
    binding we saw earlier (which defaulted to *Ctrl* + *S*), *Ctrl* + *Q* will require
    the `NO_FLOW_CONTROL` option to be set so as not to conflict with the terminal
    driver's behavior.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用*Ctrl* + *Q* 或 *Esc* + *Q* 快捷键来编辑整个块，就像它是单行一样。与我们之前看到的`history-search-forward`绑定（默认是*Ctrl*
    + *S*）类似，*Ctrl* + *Q* 需要设置`NO_FLOW_CONTROL`选项，以避免与终端驱动程序的行为冲突。
- en: 'This whole thing started with `push-line-or-edit`,so it seems fair we got to
    discuss the actual `push-line` bit. This will be the default behavior when you
    are not on a continuation line. Just type your commands as usual, but do not press
    *return*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都始于`push-line-or-edit`，所以看起来我们应该讨论一下实际的`push-line`部分。当你不在续行时，这将是默认行为。只需像往常一样输入命令，但不要按*return*键：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Realize you are in the wrong directory, call our newly bound `push-line-or-edit`
    command via *Ctrl* + *Q*, and the prompt will be cleared for you as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到自己进入了错误的目录后，通过*Ctrl* + *Q*调用我们新绑定的`push-line-or-edit`命令，提示符会被清空，如下所示：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now use `cd` to go to the folder you were trying to list, and watch the buffer
    come back to life:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`cd`进入你想列出的文件夹，看看缓冲区如何重新激活：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As soon as you execute a line, the prompt gets populated with the line you were
    editing prior to calling `push-line`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你执行了一行命令，提示符会填充你在调用`push-line`之前编辑的行。
- en: Putting it all together
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有内容整合在一起
- en: As we saw earlier, a peculiar aspect of ZLE is that it has access to the shell's
    history, which of course means we can use some of the niceties we have learned
    in order to further improve how we work with it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，ZLE的一个特殊之处在于它能够访问Shell的历史记录，这当然意味着我们可以利用一些我们学到的技巧，进一步改善与历史记录的互动。
- en: 'A neat way of taking advantage of the up/down arrow keys is via the `history-beginning-search`
    commands. We could define our own mappings in order to add some extra kick to
    the default behavior as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 利用上下箭头键的一种巧妙方法是通过`history-beginning-search`命令。我们可以定义自己的映射，以便为默认行为添加一些额外的增强，示例如下：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that the `\e` escape sequence could also be replaced by `^[`, thus leaving
    the bindings as `^[[A` and `^[[B` respectively.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`\e`转义序列也可以用`^[`替代，这样绑定就分别变为`^[[A`和`^[[B`。
- en: Now, if you have an empty prompt and press the up-arrow key, it'll work by retrieving
    the most recent entry in the history as usual. However, as soon as you type something
    and press the up arrow key, it'll autocomplete with your most recent entry that
    matches with what's typed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你有一个空的提示符并按上箭头键，它会像往常一样检索历史记录中的最近条目。然而，一旦你输入内容并按上箭头键，它会自动补全与输入匹配的最近条目。
- en: 'As an example, type the following pressing *return* after each line:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，输入以下内容，在每一行后按*return*键：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now go ahead and press the up-arrow key. The natural backwards-scrolling sequence
    should be as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按上箭头键。自然的向后滚动序列应如下所示：
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Press *Ctrl* + *G* to exit the search mode. Now type `ec` and press the up
    arrow key:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *G*退出搜索模式。现在输入`ec`并按上箭头键：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This comes in really handy during those times when you forget about a line mid-sentence
    and don't want to perform a search or discard the current line. Just remember
    to add your bindings into your startup files if you want to keep these kinds of
    changes between sessions!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在你忘记了一行内容并且不想进行搜索或丢弃当前行时，这非常有用。只需记住，如果你希望在会话之间保留这些更改，必须将绑定添加到启动文件中！
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we took a deep dive into what goes on between the prompt and
    the shell by the time you press *return*. We discovered some new tricks to work
    with history and tamed the default shortcuts by creating our own keymaps and bindings.
    As if this wasn't enough, you now know we are no longer limited to just working
    with one line, and that mistakes and distractions can easily be solved by a couple
    of keystrokes without us re-typing the whole line.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了在你按下*回车*之前，提示符与 shell 之间发生了什么。我们发现了一些新的技巧来处理历史记录，并通过创建自己的键位映射和绑定，征服了默认的快捷键。就像这还不够一样，你现在知道我们不再仅限于处理一行文本，错误和干扰也能通过几个按键轻松解决，而不必重新输入整行内容。
- en: 'Okay, I''ll admit it, we have been pretty busy in this chapter. So here''s
    a chance to catch your breath while we go over everything we''ve covered in this
    sprint. What we have done is:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我承认，在这一章我们确实很忙。所以现在是时候稍微休息一下了，让我们回顾一下在这一节课中所涵盖的内容。我们做了以下几点：
- en: Learned that zsh is made out of various modules, and got acquainted with ZLE
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解到 zsh 是由多个模块组成的，并熟悉了 ZLE
- en: Used key maps for editing text and learned about various shortcuts to improve
    our productivity in the command line
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键位映射来编辑文本，学习了各种快捷键，提升了在命令行中的工作效率
- en: Defined our own custom keymaps and worked with various regions and multiline
    prompts
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了我们自己的自定义键位映射，并与不同的区域和多行提示进行了互动
- en: Learned about widgets, special functions that carry out every little task in
    the editor
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解了小部件，这些是执行编辑器中每个小任务的特殊函数
- en: Written our first sample widgets to further extend the functionality of the
    editor and improve our shell experience
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写了我们的第一个示例小部件，进一步扩展了编辑器的功能，提升了我们的 shell 使用体验
- en: Learned about functions and control flow via the `if` statements
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `if` 语句了解了函数和控制流
- en: Finally, we learned that both modules and functions have special access to different
    parts of the shell, and we can do things such as hooking up ZLE widgets to keybindings
    in order to search the history.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们了解到模块和函数都有特别的权限，可以访问 shell 的不同部分，我们可以做一些操作，比如将 ZLE 小部件与键位绑定连接起来，以便搜索历史记录
- en: Not a bad day I'd say. Now, let's head into the next chapter, where we'll learn
    about Globbing and filename generation, another of those features where zsh really
    shines. If you thought you had learned how to type less with ZLE in this chapter,
    wait until you see braces and qualifiers in action. Keep those elbows greased
    and that confidence up though, as there's still much more waiting for us to right
    around the corner.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 说一天不算糟吧。接下来，让我们进入下一章，在这一章中我们将学习关于 Globbing 和文件名生成的内容，这也是 zsh 在其中大放异彩的特性之一。如果你以为在这一章里通过
    ZLE 学会了如何减少打字量，等你见识了大括号和限定符的实际应用后，你会更加惊讶。不过，保持你的自信和活力，因为前方还有更多的内容等着我们。
