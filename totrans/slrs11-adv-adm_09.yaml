- en: Chapter 9. Configuring the Syslog and Monitoring Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the performance on Oracle Solaris 11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about two important topics: syslog and performance
    monitoring. The former is an essential task for daily administration and is very
    appropriate for resolving the following possible events and problems that occur
    in Oracle Solaris 11\. Configuring syslog is very similar to other UNIX flavors,
    but there will be particular details that are exclusively related to Oracle Solaris.'
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the syslog framework means discussing a very important part of
    the system that is responsible for event messages. Any security problem, hardware
    change and problem, kernel event, or general issues will be recorded in logfiles.
    Additionally, applications will log their messages in logfiles. The syslog framework
    plays a special role if we are working with forensic analysis. Syslog framework
    has a central role. Logs are also important when we investigate a malware's attack.
    If we have to create a troubleshooting process, once more, the records saved and
    managed by the syslog framework are vital. This is the real importance of the
    syslog framework because its responsibility is to forward any kind of message
    to the logfiles, according to the category and severity of the message.
  prefs: []
  type: TYPE_NORMAL
- en: The latter topic, performance monitoring, introduces us to a complete and new
    world where it would be possible to write a whole book on the subject. The idea
    here is to learn about the main fundamentals and commands to help find out performance
    problems in the system. The gathered metrics can be used for a tuning task where
    the main goal is to improve the performance and try to keep the same hardware.
    This is useful because managers do not want to spend money buying an unnecessary
    and expensive hardware when eventually, only some modifications in the system
    will be enough.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The syslog framework is one of the most important features of Oracle Solaris
    11, because its goal is to log all the events that occur in each second. These
    records can be used to investigate any suspicious behavior on the system. Like
    most books, we will not delve into unnecessary details and theory about syslog.
    The main idea here is to show how the syslog can be configured, monitored, and
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires two virtual machines (VirtualBox or VMware) named `solaris11-1`
    and `solaris11-2`, both running Oracle Solaris 11 with at least 2 GB RAM, and
    a network interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syslog framework is composed of a main daemon (`syslogd`) and its respective
    configuration file (`/etc/syslog.conf`). To gather details about the associated
    syslog service, we have to execute the following SMF administration commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned about the syslog service, there''s a configuration file named
    `/etc/syslog.conf`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file is straight and has only two columns, selector and target,
    both separated by **tabs** (not spaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'The selector column is composed of two components in the `facility.level` format,
    and the syntax is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `facility` component determines the class or category of message (KERN,
    USER, MAIL, DAEMON, AUTH, NEWS, UUCP, CRON, AUDIT, LOCAL 0-7, and *), and the
    `level` component means the priority (EMERG, ALERT, CRIT, ERROR, WARNING, NOTICE,
    INFO, and DEBUG, in the descending order). Additionally, the target column is
    the destination of the message, where the destination can be a device file, file,
    user, or host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now see some practical examples of the `/etc/syslog.conf` configuration
    file with its respective syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*.err;kern.notice;auth.notice /dev/sysmsg`: All messages with an error (`err`)
    priority (the facility doesn''t matter), any kernel facility messages with a priority
    equal to or higher than `notice` (`notice`, `warning`, `error`, `critical`, `alert`,
    and `emergency`), and any authentication (`auth`) facility message with a priority
    equal to or higher than `notice` are sent to `/devsysmsg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.err;kern.debug;daemon.notice;mail.crit /var/adm/messages`: All messages
    with a `debug` priority (the facility doesn''t matter), any kernel facility message
    with a `debug` level or higher, any `daemon` facility message with `notice` priority
    or higher, and all mail facility messages with `critical` priority or higher are
    sent to the `/var/adm/messages` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.alert;kern.err;daemon.err alexandre`: In this example, all messages with
    priority equal to or higher than `alert`, messages with facility equal to `kernel`
    and priority error (`err`) or higher, and messages with facility equal to `daemon`
    and priority error (`err`) or higher are sent to the `alexandre` user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.emerg *`: In this line, all messages with priority level equal to or higher
    than `emerg` are sent to every user that is logged on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local7.alert @solaris11-2`: Any message with the `local7` facility and priority
    level equal to or higher than `alert` is sent to another host (`solaris11-2`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``mail.debug ifdef(`LOGHOST'', /var/log/syslog, @loghost)``: This is a nice
    example because any message with the facility equal to `mail` and priority level
    equal to `debug` or higher can be sent to two different destinations specified
    in the `/etc/hosts` file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `LOGHOST` variable (as shown earlier) is set (defined in the same line)
    to the localhost, the `mail.debug` messages are sent to the `/var/log/syslog`
    file. However, if the `LOGHOST` keyword is set to another host (for example, `solaris11-2
    machine`), then the `mail.debug` message is sent to the `solaris11-2` machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `/etc/hosts` file is used to specify these special hostnames, we can
    verify an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `loghost` is configured to the localhost (`solaris11-1`), so any
    message with facility equal to `mail` and priority level equal to `debug` must
    be sent to the `/var/adm/message` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'From these examples, you can note some of the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: A message can be sent to two or more different places, as seen in the first
    two examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a message is sent to another host, such as the last configuration line's
    example, the target host must have a similar line to handle the arriving message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change in the `/etc/syslog.conf` file requires restarting the syslog service
    (`svcadm restart svc:/system/system-log:default` and `svcadm restart svc:/system/system-log:default`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a real test. In the `solaris11-1` system, edit the `/etc/syslog.conf`
    file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `solaris11-2` system in the `/etc/hosts` file on the `solaris11-1`
    machine, and make sure that it''s accessible from the `solaris11-1` system, as
    shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `solaris11-1` system, refresh the syslog service by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the syslog configuration doesn''t take effect for some reason, you can restart
    it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On another system (`solaris11-2`), we have to include the following line at
    end of the `/etc/syslog.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As this file doesn''t exist, we can create it as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a property from the `system-log:default` service named `log_from_remote`,
    and it should be set to `true` to allow remote hosts (`solaris11-1`) to log any
    message into the `solaris11-2` system. Nonetheless, the big issue is that this
    parameter is usually configured to `false`. Additionally, a configuration file
    (`/etc/default /syslog`) also controls the remote logging behavior, as shown in
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at the details. If this `LOG_FROM_REMOTE` variable (from
    the `/etc/default/syslogd` file) is set to `YES` or `NO`, the `log_from_remote`
    property (from the `system-log:default` service) is enabled or disabled, respectively.
    However, if the `LOG_FROM_REMOTE` variable is commented out (as shown in the previous
    file), the value of the `log_from_remote` property (from the `system-log:default`
    service) takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to make our lives easier, we are going to enable the `log_from_remote`
    property, without touching the `/etc/default/syslogd` configuration file, and
    restart the service, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the same `solaris11-2` system, we have to follow `/var/adm/new_messages`
    to confirm if the message from `solaris11-1` arrives, using the next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `solaris11-1` system, it is time to test the configuration, and we can
    use the `logger` command that generates a message with the facility and level
    specified, using the `-p` option. In this case, we are going to generate the `Alexandre
    Borges` message that will be classified as `local7` and with priority level `emerg`.
    According to the `/etc/syslog.conf` configuration file, the message will be sent
    to the `solaris11-2` host. Once it is there, the message will be sent to the `/var/adm/new_messages`
    file, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And we''re done! Returning to the `solaris11-2` host, we are able to confirm
    that the message has arrived by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is perfect! Everything worked as expected!
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceeding with the explanation about logging, some network services have their
    own log configuration, and the best way to understand this is by taking a look
    at another practical example. For example, pick the telnet service and examine
    its configuration using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are able to see in the previous output, the `tcp_trace` property is set
    to `false`, and this way, no telnet message is sent to the syslog service. It
    is possible to change this default behavior by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the telnet events, we must execute a telnet operation from the `solaris11-2`
    system and check the `/var/adm/messages` file in the `solaris11-1` host, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the solaris11-1 host, verify the `/var/adm/`message''s file log content
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It worked! However, why do messages from services that were configured using
    `tcp_trace=true` go to the `/var/adm/message` file? Because all the messages that
    originated from this attribute are classified as `daemon.notice` (remember the
    `facility.severity` syntax), and according to the `/etc/syslog.conf` file, we
    have the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of configuring the logging capacity in each network service, we can
    configure the logging feature for all network services, using a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the network services that are controlled by the `inetadm` framework
    are configured to log to the `system-log:default` service according to the `/etc/syslog.conf`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We learned how to configure the logging service in Oracle Solaris 11 using the
    `system-log:default` service (the `syslogd` daemon) and its respective configuration
    file (`/etc/syslog.conf`). Additionally, we saw how to configure the logging feature
    for network services that are controlled by the `inetadm` framework.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the performance on Oracle Solaris 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are working in an environment with many available resources, without
    doubt, it is easier to administer all systems. However, how can we handle critical
    systems that run Oracle Solaris 11 with few free resources? How can we find and
    monitor these rare resources on Oracle Solaris 11?
  prefs: []
  type: TYPE_NORMAL
- en: The performance and tuning subject on Oracle Solaris is a very long and dense
    topic to be explained in a complete way; it deserves an entire book dedicated
    to all its details. However, we will learn enough monitor details and commands
    that will motivate you to study this topic deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe requires a virtual machine (VirtualBox or VMware) that runs Oracle
    Solaris 11 with 2 GB RAM at least. It is recommended that the system has two or
    more processors or cores.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fundamentally, Oracle Solaris 11 is composed of CPU, RAM, and I/O devices, and
    there are many ways to monitor the system. Furthermore, there are some parameters
    that are very important, so it's appropriate to start our studies by examining
    the memory subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to enable the system to collect the `sar` statistics, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using either the `prtconf` or the `lgrpinfo` command, we can find out the total
    installed memory. In addition, by executing the `pagesize` command, we can find
    the page size of a page in memory, and finally, we can use `sar –r` to get the
    free memory and swap space, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, the `freemem` column is the average number of available
    pages (4K in this case), and the `freeswap` column means the average number of
    disk blocks designed for page swapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The free memory (in pages of 4 KB) can also be obtained using a very smart
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical way to get the free swap space is using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we should remember that free space is shown in sectors (512 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a different way, free swap information can be obtained from **Modular
    Debugger** (**MDB**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the same MDB can provide us with lots of information about the
    memory status by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the amount of memory used by kernel (`Kernel`), amount of
    memory used by data from **ZFS** **File Data** (**ZFS**), and the number of anonymous
    pages (a sum of heap, stack, shared memory, and copy on write pages) in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The page cache (stored on virtual memory) is made by all the recently read and
    written regular filesystem data (file and directory data) other than ZFS (the
    ZFS data is on **Adaptive Replacement** **Cache** (**ARC**)). As we mentioned
    earlier, regular ZFS filesystem data is stored on the page cache because mmap
    ZFS data also stays there.
  prefs: []
  type: TYPE_NORMAL
- en: Free (`freelist`) is the real amount of free memory without any connection to
    the processes and files. The cache list is the number of unmapped file pages on
    the free list.
  prefs: []
  type: TYPE_NORMAL
- en: The basic and rough working of page cache is that any necessary filesystem data
    is fetched on the `segmap` cache.
  prefs: []
  type: TYPE_NORMAL
- en: The `Segmap` cache is a kind of first-level cache or staging area, where recent
    pages that were read from the filesystem (`UFS`, `VxFS`, `NFS`, and `QFS`) are
    kept into pages of kernel's virtual memory to be copied to user space buffers.
    Nevertheless, if the information is not found on the `segmap` cache, the kernel
    tries to find the requested data on `cachelist` (unmapped filesystem pages). Additionally,
    the `segmap` cache is not used by the ZFS filesytem. An interesting concept is
    that `freelist` is linked to `cachelist`, showing that when some free page of
    memory is necessary, first, the kernel tries to take pages from `freelist`, but
    if it isn't possible, the kernel takes a page of memory from `cachelist`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, only for completeness, the `segmap` cache statistics could be found
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kstat` command is also appropriate to show complementary page system information.
    Remember that a page size in memory is 4 KB, and it can be found by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An additional and interesting note: `availrmem` is the amount of unlocked memory
    available for allocation. Furthermore, if we take the same `kstat` command, it
    is possible to get system-wide page statistics, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'From this huge output, some parameters stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`anonfree`: This defines heap and stack pages that were released after these
    pages have been paged out to the disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anopgin`: This defines heap and stack pages paged in from the disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anonpgout`: This defines heap and stack pages paged out from the swap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maj_fault`: This defines the number of operations where the page has been
    found on the disk because it wasn''t on memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pgswapin`: This defines the number of pages swapped in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pgswapout`: This defines the number of pages swapped out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returning to general memory statistics, there is a known command named `vmstat`
    (which uses the `–p` option to report paging activity) that can disclose useful
    details, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This output brings to us some interesting information about `swap` (the available
    swap space in KB) and `free` (amount of free memory). There are other critical
    parameters such as `sr` (number of pages scanned per second during an operation
    to find enough free memory), `api` (anonymous page-ins), and `apo` (anonymous
    page-outs). Usually, an `sr` value (scan rate) above zero indicates problems with
    lack of memory, and a high value of either the `api` or `apo` value indicates
    low memory and a high number of operations to and from the swap. Additionally,
    as anonymous page-in operations have a bad impact on the system''s performance,
    we could use the DTrace tool to find all the executables that make many page-in
    operations by running either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: root@solaris11-1:~# **dtrace -n 'vminfo:::anonpgin { @[pid, execname] = count();
    }'**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: root@solaris11-1:~# **dtrace -n 'vminfo:::pgpgin { @pg[execname] = sum(arg0);
    }'**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we find what executable is causing a performance impact, it is time to
    decide what we can do. Eventually, it could be necessary to move the offending
    application to another system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an interesting way to verify that a process is facing problems with
    memory, using the `prstat` command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, the options we used here were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-m`: This reports microstate process accounting information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: This prints new reports below previous reports instead of overprinting
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L`: This reports statistics for each **light-weight process** (**LWP**).
    By default, the `prstat` command reports only the number of LWPs for each process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DFL column represents the percentage of time the process has spent processing
    data page faults, in other words, lack of enough memory. Ideally, this value should
    be zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'For daily administration, we are used to executing the `vmstat` command to
    gather information about virtual memory, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Some cool columns are `w` (number of swapped-out threads), `swap` (free swap
    space in KBs), `free` (free memory, including page cache and free lists in KB),
    `re` (number of reclaimed pages from page cache), `pi` and `po` (KB of page paged
    in and out, respectively), and `sr` (pages scanned in memory for available pages).
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice variation from the preceding command is `vmstat –s` (displays the total
    number of various system events since boot), as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'I have highlighted the main statistics from this `vmstat –s` output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pages swapped in`: This refers to the number of pages swapped in (from swap
    to memory). The ideal value is zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pages swapped out`: This refers to the number of pages swapped out (from memory
    to swap). The ideal value is zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reclaims from free list`: This refers to the total of the reclaimed pages
    from the free page cache inside the free list. Reclaimed pages are pages of memory
    that were released because of space shortage, but they still were not used for
    other processes nor paged out to swap. A high value can evince lack of memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`major faults`: This refers to the number of pages not found on physical memory;
    these pages were fetched on disk. The ideal value is close to zero.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`total name lookups`: Every time a file is opened, its pathname is stored in
    a special place named **Directory Name Lookup Cache** (**DNLC**). These statistics
    show us how many times the kernel found the directory path in cache (DNLC), and
    it does not have to fetch this information on disk. Values above 90 percent are
    great! Another way to get information about DNLC is using `kstat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to gather specialized DNLC cache information by executing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to calculate the efficiency of DNLC, which is (*hits/(hits +
    misses)) * 100*. Therefore, according to the previous output, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: DNLC's efficiency = (2439710/ (2439710 + 408555) * 100 = 85,67 percent
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting interpretation from the previous output, every hundred times
    we start searching for directory path information on disk, 85 times, this information
    is found in a DNLC cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another clever method to get DNLC statistics is using the `sar` command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `iget/s` column shows us how many requests for the `inode` directory path
    were not found on `DNLC`. Zero is an ideal value for this column. Nonetheless,
    if the `iget/s` value is not equal to zero, we can change the `ncsize` parameter
    to improve this statistic by changing the `/etc/system` file, as shown in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `ncsize` parameter defines the number of entries in the directory name look-up
    cache (DNLC), and this parameter is used by UFS, NFS, and ZFS to cache elements
    of path names that have been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the value is dynamically calculated using the formula *(4 * (v.v_proc
    + maxusers) + 320) + (4 * (v.v_proc + maxusers) + 320) / 100*. Additionally, the
    current value is found by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When talking about DNLC, another hot topic arises; this is the buffer cache.
    The buffer cache holds the metadata for inodes, which have directory path information
    on DNLC. The buffer cache statistics are obtained by running a command, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `%rcache` and `%wcache` columns tell us about the percentage of times metadata
    information was found in the buffer cache for the read/write operations, respectively.
    Very good values are `%rcache`, which should be more than 90 percent, and `%wcache`,
    which should be more than 70 percent.
  prefs: []
  type: TYPE_NORMAL
- en: 'While managing memory performance, a final critical issue is to know if a physical
    error occurred, such as fault memory or an ECC error. In this case, we can verify
    that the memory and all other hardware components in system are working well by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, there are no errors on my machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A huge concern when trying to tune the performance on Oracle Solaris 11 is
    the CPU. Eventually, the potential performance problem in the system is that the
    CPU is not able to attend all requests on time. For example, the `vmstat` command
    helps us identify if the operating system shows a CPU bottleneck by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `kthr:r` column means the total number of ready threads on the run queue
    (sum of the dispatches queues) that wait for CPUs. A constant value above the
    sum of the core processors or CPUs can represent a processor bottleneck, and dividing
    the `kthr:r`/number of CPUs or cores is a good way to compare CPU performance
    among servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the DTraceToolkit, we have the `dispqlen.d` script that shows each CPU
    or core dispatch queue that indicates any case of CPU saturation. Fortunately,
    it is not the case in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar command that shows a similar output to the `kthr:r` column from `vmstat`
    is the `runq-sz` column from `sar –q`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `%runocc` file explains the average run queue occupancy that helps us identify
    the eventual burst in the run queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the `vmstat` output, other useful fields are `cpu: us` (user time—how
    much time the CPU spends processing user threads), `cpu:sy` (system time—how much
    time the CPU spends processing kernel threads and system calls), and `cpu:id`
    (idle time—percentage of time that CPUs are waiting for runnable threads). A practical
    way to evaluate potential CPU problems is by considering that a good balance between
    user time (`cpu:us`) and system time (`cpu:sy`) is about 90/10 (depending on applications
    running on the system). Additionally, an upper limit is 70/30, at maximum (limit).
    Any system showing values different from these ranges deserves an investigation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the previous columns can be viewed in a similar way by executing commands
    such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Keeping the focus on system time and user time, the next command traces what
    processes are on the CPU, what user code they are running, and what kernel functions
    are running on the CPU (system time). Therefore, if we need to know what processes
    are running on the CPU, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `sched` process (the Oracle Solaris scheduler) is taking most
    of the CPU's time. Additionally, the `Java` and `Xorg` processes also take a considerable
    amount of the CPU's time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find which processes are taking more user time (to run the user code) from
    the CPU, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: According to the output, the `firefox` process takes more of the CPU's time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the same line, it is feasible to obtain the top kernel functions
    that are on the CPU (the `%sys` time) by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The CPU saturation is also examined when managing processing through the `prstat`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, we can see a total of 120 processes; 830 lwps; and
    0.12, 0.11, 0.13 load averages. The `LAT` (latency) column means the amount of
    time that processes are waiting for the CPU, and a constant value above 1 deserves
    a detailed investigation. If some process or thread has an inappropriate value,
    Oracle Solaris offers ways to delve into the details of the problem. For example,
    the `java` process presents a latency (`LAT`) value equal to 0.7 (this is a very
    low value, and it would not be worth investigating in a real case), but if we
    want to gather details about all its threads, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be possible to verify the stack for a particular thread by executing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `lwp_cond_wait` and `_lwp_cond_timedwait` functions usually wait for the
    occurrence of a condition represented by an LWP condition variable. In this case,
    both are looking for a CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, the `mpstat` command can help us distinguish the load among CPUs,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `minf` (minor fault—pages that were not found on cache and were fetched
    on memory), `mjf` (major fault—pages that were not found on memory and were fetched
    on disk), `xcal` (cross call), and `intr` (number of interrupts received by the
    CPU). It is appropriate to say that `cross-calls` are calls between CPUs or cores
    that execute a specific low-level function. Additionally, `cross-calls` are also
    necessary to keep the cache coherent due to a stale entry in a cache from a CPU.
    Usually, `cross-calls` are originated from a requirement of releasing memory as
    performed by functions such as `kmen_free ()`. An interrupt (the `intr` column)
    is used by the kernel when it needs another processor to perform work on its behalf,
    such as preempting a dispatcher (a thread signal, a thread that runs on another
    processor to enter the kernel mode) to deliver a signal to interrupt a thread
    on another processor and to start/stop a `/proc` thread on a different processor.
    The `mpstat` command itself doesn''t show us the performance bottleneck, but it
    helps us have a general understanding of a system, as shown earlier. For example,
    continuing the preceding example, it''s possible to list how many cross calls
    a process executed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The procedure of running common monitor commands such as `mpstat`, `sar`, `vmstat`,
    and `iostat` followed by a detailed DTrace investigation is a typical approach
    to finding what is the offending application or process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will change the focus to I/O performance. Perhaps the most fundamental
    command to analyze potential problems with the I/O is the `iostat` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The output shows statistics for each disk. The used options are `–n` (uses logical
    names), `-x` (shows extended statistics), `-e` (shows error statistics), and `–z`
    (does not show lines without activity). Furthermore, some columns are very important,
    such as `wait` (average number of transactions that are in queue and waiting for
    the disk), `actv` (number of transactions being processed), `wsvc_t` (average
    time that a transaction spends on the I/O wait queue), and `%b` (percentage of
    time that the disk is active). From this explanation, the `wait` column deserves
    attention because it is a metric of disk saturation, and ideally, it should always
    be equal to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'A really good tool (from the DTraceToolkit) is the `iotop.d` script that prints
    I/O details ordered by processes and shows I/O sizes (`BYTES` column), as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We could remove the `–P` option to prevent the output from rolling and refreshing
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have to monitor network interfaces and look for network bottleneck,
    so there are good tools to accomplish this task. For example, the `netstat` command
    is a simple and effective command to gather network information and analyze if
    collision is happening, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There is another fantastic tool named `nicstat` that can help us find potential
    bottleneck on network. However, it is an external tool, and to install it is a
    bit convoluted. However, it is necessary to download the `nicstat` tool from [http://sourceforge.net/projects/nicstat/files/](http://sourceforge.net/projects/nicstat/files/).
    Moreover, it would be nice to download the latest version (with more features),
    but we will need to compile it.
  prefs: []
  type: TYPE_NORMAL
- en: During this demonstration, I used the version from [http://sourceforge.net/projects/nicstat/files/latest/download?source=files](http://sourceforge.net/projects/nicstat/files/latest/download?source=files)
    (nicstat-src-1.95.tar.gz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we download the package, we have to open it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Nonetheless, we have a problem this time; it is necessary for a compiler to
    create the `nicstat` binary! Go to [http://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/index-jsp-141149.html](http://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/index-jsp-141149.html)
    to get Oracle Solaris Studio 12.3, and click on [http://pkg-register.oracle.com](http://pkg-register.oracle.com)
    to download the version for Oracle Solaris 11 x86\. From there, we will be requested
    to create personal SSL certificates to gain access to restricted repositories
    with packages such as Oracle Solaris Studio and Oracle Solaris Cluster. Therefore,
    click on the **Request Certificate** link. You will be redirected to a page to
    download both the key and certificate. It is suggested that you save both in the
    `/root/Downloads` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Oracle Solaris Studio installs a very interesting tool named `er_kernel` to
    profile only the kernel or both the kernel and the load we are running. There
    is more information (including examples) about the `er_kernel` tool on [http://docs.oracle.com/cd/E18659_01/html/821-1379/afahw.html](http://docs.oracle.com/cd/E18659_01/html/821-1379/afahw.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are required to install both the key and certificate to
    include the new publisher (`solarisstudio`) in the system, to test if we''re able
    to list the Oracle Solaris Studio files, and then, to install the Oracle Solaris
    Studio, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is nice! As the Oracle Solaris Studio is installed out of the system''s
    executable path, we have to include it in the `PATH` variable by running the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Return to the `nicstat` directory and compile it by executing the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the fantastic `nicstat` tool! First, list the available
    interfaces using the `nicstat` tool, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nicstat` tool has several options, and they are listed by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the available options, the following command brings us an extended
    output, without zeroed lines and separate `%rUtil` and `%wUtil` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The most important columns from the `nicstat` tool are `rAvs` (average size
    of packets received), `wAvs` (average size of packets transmitted), `%Util` (maximum
    utilization of the interface), and `Sat` (errors per second seen for the interface,
    and this can be a clue that the interface might be approaching saturation).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, administrators can gather statistics from a specific network interface
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, the columns have the following meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LINK`: This refers to the name of the data link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPACKETS`: Number of packets received on this link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RBYTES`: Number of bytes received on this link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IERRORS`: Number of input errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPACKETS`: Number of packets sent on this link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OBYTES`: Number of bytes sent on this link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OERRORS`: Number of output errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the recipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter explained how to configure the syslog framework to record messages
    and events from the system. Additionally, we gave you a brief introduction to
    monitoring the performance of the Oracle Solaris 11 system using several commands
    such as `vmstat`, `sar`, `prstat`, `kstat`, `mdb`, `iostat`, and so on. We also
    used other tools such as DTrace and DTraceToolkit scripts to measure the performance
    on the Oracle Solaris 11 system.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Solaris Performance and Tools: DTrace and MDB Techniques for Solaris 10 and
    OpenSolaris*; *Richard McDougall*, *Jim Mauro*, *Brendan Gregg*; *Prentice Hall*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Solaris* *Internals: Solaris 10 and OpenSolaris Kernel Architecture (2nd Edition)*;
    *Richard McDougall*, *Jim Mauro*; *Prentice Hall*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://solarisinternals.com/wiki/index.php/Solaris_Internals_and_Performance_FAQ](http://solarisinternals.com/wiki/index.php/Solaris_Internals_and_Performance_FAQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Systems Performance: Enterprise and the Cloud*; *Brendan Gregg*; *Prentice
    Hall*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.brendangregg.com/sysperfbook.html](http://www.brendangregg.com/sysperfbook.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DTraceToolkit website at [http://www.brendangregg.com/dtracetoolkit.html](http://www.brendangregg.com/dtracetoolkit.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Brendan Gregg website at [http://www.brendangregg.com/](http://www.brendangregg.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dtrace.org website at [http://dtrace.org/blogs/](http://dtrace.org/blogs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
