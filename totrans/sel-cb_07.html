<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Choosing the Confinement Level"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Choosing the Confinement Level</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finding common resources</li><li class="listitem" style="list-style-type: disc">Defining common helper domains</li><li class="listitem" style="list-style-type: disc">Documenting common privileges</li><li class="listitem" style="list-style-type: disc">Granting privileges to all clients</li><li class="listitem" style="list-style-type: disc">Creating a generic application domain</li><li class="listitem" style="list-style-type: disc">Building application-specific domains using templates</li><li class="listitem" style="list-style-type: disc">Using fine-grained application domain definitions</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec61"/>Introduction</h1></div></div></div><p>During the development of additional policies, developers can opt to use a very fine-grained policy model, a domain-per-application model, or a coarse-grained, functionality-based policy model. The relationship between these confinement models is shown in the following diagram:</p><div class="mediaobject"><img src="graphics/9669OS_07_01.jpg" alt="Introduction"/></div><p>In very fine-grained policies, multiple domains are defined, so functionally different processes <a id="id471" class="indexterm"/>of the same application are all running in their own specialized SELinux domain. A coarse-grained policy, on the other hand, allows<a id="id472" class="indexterm"/> to have different applications with a similar functionality run with the same context. Application-level policies are somewhere in the middle: they focus on one domain (or a very small set of domains) for one application.</p><p>Most policies are developed using a <span class="strong"><strong>one domain per application</strong></span> principle. Still, the choice of<a id="id473" class="indexterm"/> development patterns in policy development reflects the confinement level of an application, as shared, coarse-grained policies might allow for more interaction between applications and resources than intended, whereas, a fine-grained policy is much harder to develop and maintain.</p><p>When we look at a functional level, we usually focus on shared resources or resources that cannot be tied to a particular application. An example is the <code class="literal">mta</code> SELinux policy, which manages the main infrastructure-related shared content such as e-mail aliases (<code class="literal">etc_mail_t</code>), user mailboxes (<code class="literal">mail_home_rw_t</code>), e-mail spool files (<code class="literal">mail_spool_t</code>), and more.</p></div></div>
<div class="section" title="Finding common resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec62"/>Finding common resources</h1></div></div></div><p>During <a id="id474" class="indexterm"/>policy development, some of the resources used by the policy are or could be shared with other policies. If that is the case, a functionality-driven policy module is created in which those common resources are placed. This allows other policies to use these resources and assign the right permissions through the interfaces declared in the functionality-driven policy.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec148"/>How to do it…</h2></div></div></div><p>Most of the <a id="id475" class="indexterm"/>work in this recipe is to figure out what resources are shared. This is done by completing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Look for common files and directories that might be shared with other applications and whose ownership is not specifically tied to an application, but is more functional in nature. For these resources, declare them in a functionality-driven policy.</li><li class="listitem">Check whether there are devices used that are functionally related to the policy but not to a specific application in particular.</li><li class="listitem">Validate if there is specific user-provided content that is functionally related but not tied to a particular application, and where the default user content types (such as <code class="literal">user_home_t</code>) are better not used. These resources need to be declared in the functionality-driven policy and probably made customizable as well:<div class="informalexample"><pre class="programlisting">type public_content_t; # customizable
files_type(public_content_t)</pre></div></li><li class="listitem">Create the proper interfaces to handle or interact with these common resources:<div class="informalexample"><pre class="programlisting">interface(`miscfiles_read_public_files',`
  gen_require(`
    type public_content_t;
  ')
  read_files_pattern($1, public_content_t, public_content_t)
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec149"/>How it works…</h2></div></div></div><p>Functionality-driven policy modules handle common resources for multiple applications and policies. Some example policies that handle the functional resources for multiple applications are the mail transfer agent policy (<code class="literal">mta</code>) and the web server policy (<code class="literal">apache</code>). Although the web server policy was originally intended to be purely for the Apache HTTPd, it has since evolved into a more functionality-driven policy supporting a large amount of web server technologies.</p><div class="section" title="Shared file locations"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec43"/>Shared file locations</h3></div></div></div><p>A helpful<a id="id476" class="indexterm"/> method for finding out what resources are considered to<a id="id477" class="indexterm"/> be functional in nature (rather than application-specific) is to imagine switching one application in favor of another. What resource types would remain the same if we switch from one system logger (say <code class="literal">syslog-ng</code>) to another (say <code class="literal">rsyslog</code>), or from Courier-IMAP to Cyrus? Having knowledge of multiple similar applications helps in finding out where (or what) the shared locations are.</p><p>However, having similar functional requirements doesn't necessarily make them shared. The locations should also remain the same (or at least be consistent and on well-known locations). Consider database files: the database files for PostgreSQL and SQLite databases both have the same functional purpose, but it makes no sense to label them both with the same label. Database files are specific to a particular database implementation and require specific labels, so with every potential common resource, make sure that the resource itself can be shared across multiple implementations.</p><p>Device nodes are a nice example to consider for a functionality-driven policy. An example device type definition would look like the following:</p><div class="informalexample"><pre class="programlisting">type cachefiles_device_t;
dev_node(cachefiles_device_t)</pre></div><p>Devices are usually shared across multiple applications. Most devices are defined in the <code class="literal">devices.te</code> policy module with the proper interfaces being declared to allow access to the device (such as <code class="literal">dev_rw_cachefiles</code> for read/write access to the previously mentioned <code class="literal">cachefiles_device_t</code> type). Not all files in <code class="literal">/dev/</code> are such device files though.</p><p>Consider the <code class="literal">/dev/log</code> socket, which is used to send log events to the system logger. This socket, which is available regardless of the system logger being used, is made available through the following logging SELinux policy module:</p><div class="informalexample"><pre class="programlisting">type devlog_t;
files_type(devlog_t)
mls_trusted_object(devlog_t)</pre></div><p>The <code class="literal">mls_trusted_object</code> interface makes the device (labeled <code class="literal">devlog_t</code>) accessible for all security levels in an MLS-enabled policy.</p></div><div class="section" title="User content and customizable types"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec44"/>User content and customizable types</h3></div></div></div><p>User-provided <a id="id478" class="indexterm"/>content is also important to consider. For instance, for <a id="id479" class="indexterm"/>e-mail-related daemons, a user's <code class="literal">.forward</code> file (which tells<a id="id480" class="indexterm"/> the <a id="id481" class="indexterm"/>system where to forward the e-mails of the user) is available in his or her home directory and is definitely not owned by a particular application. Hence, its label (<code class="literal">mail_home_t</code>) is tied to a functionality-driven policy (<code class="literal">mta</code>).</p><p>Don't forget to mark user content as user content through the <code class="literal">userdom_user_home_content</code> interface; otherwise, end users will not be able to label or manipulate these files:</p><div class="informalexample"><pre class="programlisting">type mail_home_t;
userdom_user_home_content(mail_home_t)</pre></div><p>Some user <a id="id482" class="indexterm"/>content is also best marked as customizable. A <span class="strong"><strong>customizable type</strong></span>, when <a id="id483" class="indexterm"/>assigned to a resource, is ignored during standard <a id="id484" class="indexterm"/>relabel operations (usually performed by the system administrator) and as such, the resource label will not be changed back to what the <a id="id485" class="indexterm"/>SELinux configuration files have defined. This is particularly useful for resources whose path is not a fixed location and usually not made part of the SELinux file context definitions.</p><p>If the administrator does a forced relabel operation, then the file context is reset, even if the current type assigned to the resource is a customizable type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# restorecon -R -F /home/*</strong></span>
</pre></div><p>In a modular policy development, there is no notation available to mark a type as being a customizable type. To do this, the type needs to be added to the <code class="literal">customizable_types</code> file in <code class="literal">/etc/selinux/mcs/contexts/</code>.</p><p>Marking files with a customizable type is a solution when the path of the resource isn't fixed. The <code class="literal">.forward</code> file has a fixed path, so there is no need for customizable content. User content that should be publicly accessible, however, (marked as <code class="literal">public_content_t</code> or <code class="literal">public_content_rw_t</code>) does not have a fixed path; hence, those types are (by default) marked as customizable.</p><p>When full policy development is done (for instance, through the Linux distribution policy or because the developer controls the entire policy and not just additional modules), then the <code class="literal"># customizable</code> comment can be placed behind the type declaration, as can be seen from the following example of the CVS policy module:</p><div class="informalexample"><pre class="programlisting">type cvs_data_t; # customizable
files_type(cvs_data_t)</pre></div><p>The reference policy build system will then automatically add the type to the <code class="literal">customizable_types</code> file during the build process.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec150"/>There's more...</h2></div></div></div><p>Other common resources that can be considered are the TCP and UDP ports. Indeed, network-facing applications bind to one or more ports, which are usually the same for applications sharing the same functionality.</p><p>However, the TCP and UDP ports cannot be declared inside SELinux policy modules; instead, they need to be labeled as part of the base policy. Updating a base policy, however, is either done by the Linux distribution maintainers or the upstream reference policy <a id="id486" class="indexterm"/>project. The <a id="id487" class="indexterm"/>basic rule is that the <a id="id488" class="indexterm"/>ports<a id="id489" class="indexterm"/> are named after the service they are generally used by:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ getent services 6667</strong></span>
<span class="strong"><strong>ircd    6667/tcp</strong></span>
<span class="strong"><strong>~$ seinfo --portcon=6667</strong></span>
<span class="strong"><strong>portcon tcp 6667 system_u:object_r:ircd_port_t</strong></span>
</pre></div></div></div>
<div class="section" title="Defining common helper domains"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec63"/>Defining common helper domains</h1></div></div></div><p>Next to <a id="id490" class="indexterm"/>the common resources, some applications share the same set of helper commands. The <code class="literal">sendmail</code> command is a nice example <a id="id491" class="indexterm"/>of this, which is executed by a large set of domains (usually, applications that need to send e-mails without using the SMTP protocol themselves). The <code class="literal">sendmail</code> application is well understood and most MTA applications support it for command-line e-mail sending operations.</p><p>Supporting such helper domains is usually done through a functionality-driven policy.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec151"/>How to do it…</h2></div></div></div><p>Creating helper domains is similar to creating regular application domains, but the use of attributes allows the policy to be very flexible and usable by the application-specific policy modules developed further. Let's look at the MTA definition as an example of how this can be accomplished:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Define an attribute for the command type:<div class="informalexample"><pre class="programlisting">attribute mta_exec_type;</pre></div></li><li class="listitem">Create a proper label type for the command, and assign it the <code class="literal">mta_exec_type</code> attribute:<div class="informalexample"><pre class="programlisting">type sendmail_exec_t, mta_exec_type;
application_executable_file(sendmail_exec_t);</pre></div></li><li class="listitem">Configure an application domain for the command:<div class="informalexample"><pre class="programlisting">type system_mail_t;
application_domain(system_mail_t, sendmail_exec_t)</pre></div></li><li class="listitem">If the application is for system purposes, assign the domain to the <code class="literal">system_r</code> role:<div class="informalexample"><pre class="programlisting">role system_r types system_mail_t</pre></div></li><li class="listitem">If the application is meant to be executed by end users, do not forget to include a <code class="literal">_run</code> or <code class="literal">_role</code> interface.</li><li class="listitem">Make<a id="id492" class="indexterm"/> an interface callable by third-party application domains to allow them to interact with the helper application:<div class="informalexample"><pre class="programlisting">interface(`mta_send_mail',`
  gen_require(`
    attribute mta_exec_type;
    type system_mail_t;
  ')
  corecmd_search_bin($1)
  domtrans_pattern($1, mta_exec_type, system_mail_t)
')</pre></div></li><li class="listitem">Make another interface allowing specific policies to mark their own helper executables usable for the same purpose (as they might not always use the same type):<div class="informalexample"><pre class="programlisting">interface(`mta_agent_executable',`
  gen_require(`
    attribute mta_exec_type;
  ')
  typeattribute $1 mta_exec_type;
  application_executable_file($1)
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec152"/>How it works…</h2></div></div></div><p>Helper domains are meant to provide reusable functionality across multiple implementations. To support the flexibility of having multiple implementations, attributes are usually assigned to the types so that extensions can be easily created.</p><p>Consider the <code class="literal">sendmail</code> example again. Most implementations will have the command-line <code class="literal">sendmail</code> application marked as <code class="literal">sendmail_exec_t</code>. However, there are implementations whose <code class="literal">sendmail</code> binary has many more features, especially when called from the implementation processes themselves. Some implementations even have the file as a symbolic link to a more generic e-mail-handler application.</p><p>The Exim implementation, for instance, uses <code class="literal">exim_exec_t</code> instead of using <code class="literal">sendmail_exec_t</code>. With the use of the attributes, the Exim policy module can just call the proper interface (<code class="literal">mta_agent_executable</code>, in this case), so third-party applications can still execute the command (even though it is <code class="literal">exim_exec_t</code> and not <code class="literal">sendmail_exec_t</code>) and have it behave as expected (that is, with a transition to the <code class="literal">user_mail_t</code> or <code class="literal">system_mail_t</code> domain as expressed by the MTA policy):</p><div class="informalexample"><pre class="programlisting">type exim_exec_t;
mta_mailserver(exim_t, exim_exec_t)
mta_agent_executable(exim_exec_t)</pre></div><p>Attributes <a id="id493" class="indexterm"/>allow other domains to interact with the newly defined type without having to update the policy modules that define these domains. This is because those domains are granted execute rights on all types that have the <code class="literal">mta_exec_type</code> attribute assigned, and will invoke a domain transition to the <code class="literal">system_mail_t</code> helper domain when they execute such a file. This privilege is provided through the <code class="literal">mta_send_mail</code> interface, which is a good example of a helper domain interface to be assigned to other domains:</p><div class="informalexample"><pre class="programlisting">interface(`mta_send_mail',`
  gen_require(`
    type system_mail_t;
    attribute mta_exec_type;
  ')
  corecmd_search_bin($1)
  domtrans_pattern($1, mta_exec_type, system_mail_t)
  allow $1 mta_exec_type:lnk_file read_lnk_file_perms;
')</pre></div></div></div>
<div class="section" title="Documenting common privileges"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec64"/>Documenting common privileges</h1></div></div></div><p>Next to<a id="id494" class="indexterm"/> the helper domains, most functionality-driven policies also group privileges that can be assigned to domains. Such privileges could be to not only manage the common resources, but also to extend other domains with functional requirements as managed by the common policy.</p><p>All e-mail daemons need to be able to bind to the proper TCP ports, handle user mailboxes, and so on. By bundling these common privileges on the functional policy level, any evolution pertaining to the policy can be immediately granted to all domains inheriting privileges from the functional policy, rather than having to update each domain individually.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec153"/>How to do it…</h2></div></div></div><p>Common privileges can be found in a wide variety. How common privileges are assigned depends on the use case. The following method, based on the e-mail server definition in the MTA policy, provides a flexible approach to this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an attribute for the functional domain to which common privileges are granted:<div class="informalexample"><pre class="programlisting">attribute mailserver_domain;</pre></div></li><li class="listitem">Define <a id="id495" class="indexterm"/>an interface where the attribute is assigned to a specified domain:<div class="informalexample"><pre class="programlisting">interface(`mta_mailserver',`
  gen_require(`
    attribute mailserver_domain;
  ')
  typeattribute $1 mailserver_domain;
')</pre></div></li><li class="listitem">Build an interface that assigns the functionally related common privileges to the specified argument. It should not assign attributes though! This is done with the following code:<div class="informalexample"><pre class="programlisting">interface(`mta_mailserver_privs,`
  gen_require(`
    type mail_home_t;
  ')
  allow $1 mail_home_t:file read_file_perms;
   …
')</pre></div></li><li class="listitem">Now, use the newly created interface to grant the proper permissions on the attribute:<div class="informalexample"><pre class="programlisting">mta_mailserver_privs(mailserver_domain)</pre></div></li><li class="listitem">If a specific application always has to inherit the privileges, assign the attribute to it:<div class="informalexample"><pre class="programlisting">mta_mailserver(exim_t)</pre></div></li><li class="listitem">If a specific application, however, optionally inherits the privileges, use the domain interface:<div class="informalexample"><pre class="programlisting">tunable_policy(`nginx_enable_mailproxy',`
  mta_mailserver_privs(nginx_t)
')</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec154"/>How it works…</h2></div></div></div><p>When assigning privileges to a domain, there are two approaches that can be taken: either the privileges are assigned to an attribute (which is then associated with a domain) or the privileges are directly assigned to the domain. Which one to pick depends on how the policy is going to be used. Due to restrictions in policy development, it is not possible to optionally (that is, triggered through SELinux Booleans) assign attributes. Any attempt to do so will result in a build failure, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ make mymodule.pp</strong></span>
<span class="strong"><strong>Compiling mcs mymodule module</strong></span>
<span class="strong"><strong>checkmodule: loading policy configuration from tmp/mymodule.tmp</strong></span>
<span class="strong"><strong>mymodule.te:23:ERROR 'syntax error' at token 'typeattribute' on line 1309:</strong></span>
<span class="strong"><strong>#line 23</strong></span>
<span class="strong"><strong>  typeattribute $1 mta_exec_type;</strong></span>
<span class="strong"><strong>checkmodule: error(s) encountered while parsing configuration</strong></span>
</pre></div><p>As a result, whenever <a id="id496" class="indexterm"/>permissions can be granted optionally (through SELinux Booleans), policy developers will have to make sure that the permissions are granted directly (instead of assigning an attribute to the domain).</p><p>However, in most cases, using attributes for domains makes sense. The policy itself does not increase in size that much (as rules remain on an attribute level) and administrators can easily query which domains participate in the functional approach:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# seinfo -amailserver_domain -x</strong></span>
<span class="strong"><strong>  mailserver_domain</strong></span>
<span class="strong"><strong>    system_mail_t</strong></span>
<span class="strong"><strong>    exim_t</strong></span>
<span class="strong"><strong>    courier_smtpd_t</strong></span>
</pre></div><p>Granting the permissions through an interface also allows us to quickly look at the impact of assigning an attribute, as we can then use the <code class="literal">seshowif</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seshowif mta_mailserver_privs</strong></span>
</pre></div><p>The example given uses a server-domain approach, but the same can be done for a client.</p></div></div>
<div class="section" title="Granting privileges to all clients"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec65"/>Granting privileges to all clients</h1></div></div></div><p>The <a id="id497" class="indexterm"/>approach of using interfaces to aggregate privileges not <a id="id498" class="indexterm"/>only benefits domains that have the same functional purpose, but also clients. By combining the privileges for the set of clients, it is possible to enhance client privileges by only updating the interface rather than having to update all the clients' policy modules.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec155"/>How to do it…</h2></div></div></div><p>Create a client interface that can be assigned to all clients of a particular functional purpose. The following steps extend an example policy with antimalware support:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the antimalware generic policy, create an <code class="literal">avcheck_client</code> attribute:<div class="informalexample"><pre class="programlisting">attribute avcheck_client;</pre></div></li><li class="listitem">Create the interface that assigns the attribute to a client domain:<div class="informalexample"><pre class="programlisting">interface(`av_check_client',`
  gen_require(`
    attribute avcheck_client;
  ')
  typeattribute $1 avcheck_client;
')</pre></div></li><li class="listitem">Create <a id="id499" class="indexterm"/>the interface that assigns the common <a id="id500" class="indexterm"/>privileges for client domains:<div class="informalexample"><pre class="programlisting">interface(`av_check_client_privs',`
  …
')</pre></div></li><li class="listitem">In the created interface, add the privileges that need to be assigned to all client domains. For instance, to enable a domain transition for the ClamAV <code class="literal">check</code> command, the following code is used:<div class="informalexample"><pre class="programlisting">optional_policy(`
  clamav_domtrans_check($1)
')</pre></div></li><li class="listitem">All domains that act as a client are either assigned the <code class="literal">av_check_client</code> (if the attribute can be assigned) or <code class="literal">av_check_client_privs</code> interface.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec156"/>How it works…</h2></div></div></div><p>Suppose a new antimalware policy is developed for ClamAV, and we want the clients to be able to execute the <code class="literal">clamav_check_exec_t</code> applications and transition them to the <code class="literal">clamav_check_t</code> domain. Instead of updating all clients with a <code class="literal">clamav_domtrans_check</code> call, we only do this in the generic antimalware policy's <code class="literal">av_check_client_privs</code> interface, as follows:</p><div class="informalexample"><pre class="programlisting">optional_policy(`
  clamav_domtrans_check($1)
')</pre></div><p>This ensures that all proper domains— not only those with the <code class="literal">avcheck_client</code> attribute—get the necessary privileges assigned.</p><p>Another example that uses this principle is the PulseAudio policy. An interface called <code class="literal">pulseaudio_client_domain</code> is made available and should be used by PulseAudio clients. Whenever the permissions for a PulseAudio client need to be updated, then the policy developer only needs to update the <code class="literal">pulseaudio_client_domain</code> interface instead of all client policy modules.</p><p>Such an approach makes policy development much more flexible and efficient, as developers <a id="id501" class="indexterm"/>do not need to update all possible client <a id="id502" class="indexterm"/>domains with the added privileges.</p></div></div>
<div class="section" title="Creating a generic application domain"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec66"/>Creating a generic application domain</h1></div></div></div><p>In <a id="id503" class="indexterm"/>some situations, it makes sense to create a generic application domain, even though multiple implementations exist for the same functionality. Examples are the Java domain (which works for all the popular Java™ implementations) and init domain. When this occurs, carefully consider whether the generic application domain will always be sufficient, or whether specific application domains might come into play later. When this isn't clear, make sure that the policy being developed is flexible enough to cater both situations.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec157"/>How to do it…</h2></div></div></div><p>In order to create a generic application policy that is still flexible with respect to potential specific policies that would be developed later, follow the upcoming set of steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Identify the permissions that are (almost) always applicable to the functional domain, regardless of the implementation.</li><li class="listitem">Assign those permissions to a <span class="emphasis"><em>base</em></span> implementation. For instance, for Java™ implementations, assign permissions as follows:<div class="informalexample"><pre class="programlisting">attribute javadomain;
# Minimal permissions
java_base_runtime_domain(javadomain);

type java_t;
# Assigns javadomain attribute
java_base_runtime(java_t);</pre></div></li><li class="listitem">Add permissions that are applicable to at least one (or a few) of the implementations to the standard type. In our example, this would be to <code class="literal">java_t</code>. This ensures that <code class="literal">java_t</code> is generally usable for most Java™ implementations.</li><li class="listitem">Add the proper file contexts to allow most implementations to benefit from the generic application policy:<div class="informalexample"><pre class="programlisting">/usr/lib/bin/java[^/]*  --  gen_context(system_u:object_r:java_exec_t,s0)
/opt/(.*/)?bin/java[^/]*  --  gen_context(system_u:object_r:java_exec_t,s0)</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec158"/>How it works…</h2></div></div></div><p>With the given implementation, most Java™ implementations on an SELinux-enabled system will run, when executed, in the generic <code class="literal">java_t</code> domain: their executables are all marked as <code class="literal">java_exec_t</code> through generic file context expressions, and the <code class="literal">java_t</code> domain<a id="id504" class="indexterm"/> holds not only the set of least privileges for Java™ domains (as granted through the <code class="literal">javadomain</code> attribute that gets them from the <code class="literal">java_base_runtime_privs</code> interface), but also those privileges that are common for quite a few implementations. This means that the <code class="literal">java_t</code> domain has more privileges than needed in most cases, as it has to support a broad set of Java™ implementations.</p><p>However, when a specific implementation will be created with a different policy profile than the existing <code class="literal">java_t</code> domain, policy developers can easily mark this domain as a Java domain, inheriting the permissions that are necessary for every Java™ implementation (for instance, because they are mandated through the specifications of Java™) while staying clear from the other permissions that are granted to the generic <code class="literal">java_t</code> domain:</p><div class="informalexample"><pre class="programlisting">type icedtea_java_t;
java_base_runtime(icedtea_java_t)</pre></div><p>By creating a more specific file context definition, the executable of the newly created type will get this label assigned (as the other expressions are more generic, and the SELinux utilities use a <span class="emphasis"><em>most specific definition first</em></span> approach):</p><div class="informalexample"><pre class="programlisting">/opt/icedtea7/bin/java  --  gen_context(system_u:object_r:icedtea_java_exec_t,s0)</pre></div><p>Building a proper set of least privilege rules is not easy and requires experience in policy development. If uncertain, it might be a good idea to use SELinux Booleans, such as used by the (generic) <code class="literal">cron</code> policy:</p><div class="informalexample"><pre class="programlisting"># Support extra rules for fcron
gen_tunable(fcron_crond, false)
…
tunable_policy(`fcron_crond',`
  allow admin_crontab_t self:process setfscreate;
')</pre></div><p>Through this approach, specific implementations can still benefit from the generic policy declaration, if the amount of additional permissions is small. As the policy is enhanced with other implementation details, the need for the <code class="literal">tunable_policy</code> statement might be removed or a specific implementation for <code class="literal">fcron</code> can be developed separately.</p></div></div>
<div class="section" title="Building application-specific domains using templates"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec67"/>Building application-specific domains using templates</h1></div></div></div><p>Specific <a id="id505" class="indexterm"/>domains have the advantage that they can contain those privileges needed by the domain, and no more. As there <a id="id506" class="indexterm"/>are no other application implementations using the specific domain, the privileges can be tailored to the needs of the application.</p><p>In certain situations though, it might be beneficial to automatically generate the types together with the basic permissions. Generating types is done through templates (rather than interfaces, although the underlying implementation of interfaces and templates is quite similar). The approach and development method is aligned with interface definitions and should pose no difficulties for developers to understand.</p><p>An example to consider with templates would be to automatically create system <code class="literal">cron</code> job domains for individual applications. Through a template, we can automatically create the domain, executable type, and temporary resource types as well as properly document the interactions of that domain with the main <code class="literal">cron</code> daemon (which is needed for communicating job failures or success, handling output, logging, and so on).</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec159"/>How to do it…</h2></div></div></div><p>Creating templates is similar to creating interfaces. To create templates, the following approach can be used:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start with a skeleton template inside the <code class="literal">.if</code> file, but call it <code class="literal">template</code> instead of <code class="literal">interface</code>:<div class="informalexample"><pre class="programlisting">template(`cron_system_job_template',`
  …
')</pre></div></li><li class="listitem">Add in the following type declarations:<div class="informalexample"><pre class="programlisting">type $1_cronjob_t;
type $1_cronjob_exec_t;
application_domain($1_cronjob_t, $1_cronjob_exec_t)

type $1_cronjob_tmp_t;
files_tmp_file($1_cronjob_tmp_t)</pre></div></li><li class="listitem">Grant the proper interactions between the main daemon and the newly defined types that are still inside the template definition:<div class="informalexample"><pre class="programlisting">allow crond_t $1_cronjob_t:fd use;
allow crond_t $1_cronjob_t:key manage_key_perms;
domtrans_pattern(crond_t, $1_cronjob_exec_t, $1_cronjob_t)
…</pre></div></li><li class="listitem">In the application policy, call the template so that the new types are created. For instance, to create the <code class="literal">cron</code> job domains for Puppet, add the following code to <code class="literal">puppet.te</code>:<div class="informalexample"><pre class="programlisting">cron_system_job_template(puppet)</pre></div></li><li class="listitem">Enhance the (now available) <code class="literal">puppet_cronjob_t</code> domain with the permissions needed:<div class="informalexample"><pre class="programlisting">allow puppet_cronjob_t …</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec160"/>How it works…</h2></div></div></div><p>The <a id="id507" class="indexterm"/>use of templates has been<a id="id508" class="indexterm"/> discussed earlier in the chapter on web server content. Indeed, the <code class="literal">apache_content_template</code> definition, too, is a template that creates additional types and documents the interaction between the newly created types and the (main) web server domain.</p><p>The use of templates allows for rapid policy development as well as properly isolated permission handling. When the main application evolves and requires additional permissions with respect to the specific application domains, or certain permissions are no longer needed, then only the template needs to be adjusted. All that is needed to apply the changes is to rebuild the SELinux policy modules, without any need to alter their individual source files.</p><p>It is a best practice to use prefix and/or suffix notations for template-provided types and to end the name of the template with <code class="literal">_template</code>. In theory, it is perfectly possible to create a template that creates the specified type(s) without any prefix and postfix expressions, instead requiring the various types to be passed on one at a time:</p><div class="informalexample"><pre class="programlisting">cron_system_job_template(puppet_cronjob_t, puppet_cronjob_exec_t, puppet_cronjob_tmp_t)</pre></div><p>However, this approach is inflexible under the following circumstances:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If additional types need to be supported, then the interface API itself (the number of arguments passed to it and their meaning) needs to be altered, which makes such changes incompatible with earlier releases. This is important because there might be policy developers who are using this interface without their policy being available in the repository that we're developing in, so we cannot refactor this code ourselves.</li><li class="listitem" style="list-style-type: disc">If a type is no longer needed, then either the interface API itself needs to be changed (making it incompatible with earlier releases) or the interface will be made to ignore a particular type (which easily becomes a development nightmare).</li><li class="listitem" style="list-style-type: disc">Developers will continuously need to look at the order and meaning of the types in order not to mistakenly have the executable type marked as a domain and vice versa.</li></ul></div><p>Such an <a id="id509" class="indexterm"/>approach would also<a id="id510" class="indexterm"/> make it possible to create confusing type definitions:</p><div class="informalexample"><pre class="programlisting">cron_system_job_template(puppetjob_t, pj_exec_t, ptmp_t)</pre></div><p>Through such an approach, developers and administrators would lose sight over the relation between types.</p><p>Using proper prefix and postfix notations allows for a simplified management. The use of a template such as <code class="literal">cron_system_job_template</code> easily informs developers that there will be several types matching <code class="literal">*_cronjob_t</code>, <code class="literal">*_cronjob_exec_t</code>, and <code class="literal">*_cronjob_tmp_t</code>. Policy developers and system administrators easily learn that these are related with each other.</p></div></div>
<div class="section" title="Using fine-grained application domain definitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Using fine-grained application domain definitions</h1></div></div></div><p>The<a id="id511" class="indexterm"/> use of templates earlier in this chapter is a start to support more fine-grained application domain definitions. Instead of running a workload inside the same domain as the main application, specific types are created that are meant to optimize the interaction between one domain and another, ensuring that the permissions granted to a particular domain remain small and manageable.</p><p>Using fine-grained application domains goes a step further, having processes of the same application run inside their own specific domains. This is not always possible (not all applications use multiple, distinct processes), but when it is, using fine-grained domains provides an even more secure environment, where each task runs with just the permissions needed for that individual task, even though the application, in general, needs more permissions.</p><p>An example implementation of fine-grained <a id="id512" class="indexterm"/>application domain definitions is the postfix policy, which will be used as an example in this recipe. The Postfix e-mail server is well documented and its architecture has been quite stable, making it a prime candidate for a fine-grained policy development approach.</p><p>However, when fine-grained application domains are used, policy development and maintenance itself becomes harder. Individual interaction changes between processes (which might be the case with newer versions of an application) require policy updates much more often than when all processes run within the same SELinux domain.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec161"/>How to do it…</h2></div></div></div><p>The following checks can be taken to see whether fine-grained application domains make sense or not:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Does the application architecture use multiple processes, with each process having a distinct functional task? If not, then creating fine-grained application domains will not help much as every domain will have the same permissions anyhow.</li><li class="listitem">Are<a id="id513" class="indexterm"/> there processes with different access vectors (and thus are vulnerable to different threats than others)? For instance, whether some processes are directly accessible through the network whereas others are local? If so, then using fine-grained application domains might make sense to reduce the impact in case of the vulnerability exploitation.</li><li class="listitem">Is there an interaction between a subset of the processes with other domains (not managed through the same application), whereas the other processes do not need to interact with these domains? If so, then using fine-grained application domains might make sense to limit exposure of resources to other applications.</li><li class="listitem">Does the application support different roles that might need to interact with some (but not all) of the processes? A single full-application administrator might still need administrative privileges to all processes and resources, but other roles might not have this requirement. Using fine-grained application domains allows for fine-grained roles as well.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec162"/>How it works…</h2></div></div></div><p>Supporting fine-grained application domains is usually done for risk mitigation. But besides risk mitigation, it also provides advantages in role management as well as a more efficient approach to managing types that are inherited from the domain.</p><div class="section" title="Reducing exploit risks"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec45"/>Reducing exploit risks</h3></div></div></div><p>Consider <a id="id514" class="indexterm"/>a part of the Postfix architecture, as shown in the next diagram:</p><div class="mediaobject"><img src="graphics/9669OS_07_02.jpg" alt="Reducing exploit risks"/></div><p>The <span class="strong"><strong>smtpd</strong></span> daemon<a id="id515" class="indexterm"/> handles the reception of an e-mail through the <span class="strong"><strong>network</strong></span>, and <a id="id516" class="indexterm"/>as such, is more <a id="id517" class="indexterm"/>prone to remote vulnerability exploits than to locally running <a id="id518" class="indexterm"/>processes<a id="id519" class="indexterm"/> such as the <span class="strong"><strong>cleanup</strong></span> process or even the <span class="strong"><strong>qmgr</strong></span> process.</p><p>By limiting resource access of the <span class="strong"><strong>smtpd</strong></span> daemon to just the resources it needs, exploits that would attempt to access the queues (resources not usually accessed by <span class="strong"><strong>smtpd</strong></span> but used by <span class="strong"><strong>qmgr</strong></span>) would fail as the least privilege approach used in the <span class="strong"><strong>smtpd</strong></span> domain (<code class="literal">postfix_smtpd_t</code>) disallows access to the <span class="strong"><strong>maildrop</strong></span> queues (<code class="literal">postfix_spool_maildrop_t</code>).</p><p>Proper risk reduction is only possible if the resources of the application (such as the specific queues) are also defined in a fine-grained manner. If the application has multiple configuration files and these configuration files are read by different functional processes, then the configuration files should be labeled more specifically as well (for instance, configuration files for routing and configuration files for network settings).</p><p>If the application resources are labeled in a generic fashion, we risk that all fine-grained domains have the same rights towards the generic resources, making it more plausible for a vulnerable application to be exploited with larger consequences to the entire application architecture.</p></div><div class="section" title="Role management"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec46"/>Role management</h3></div></div></div><p>Using<a id="id520" class="indexterm"/> fine-grained application<a id="id521" class="indexterm"/> domains goes further than just mitigation of exploits. With individual domains, role access can be granted to users allowing them to take specific actions without requiring full application privileges.</p><p>For instance, operator roles can be created that allow manipulation of the Postfix deferred queue and signaling of the <code class="literal">qmgr</code> process without granting those users any specific rights towards the other processes. Assuming the user domain for this role is <code class="literal">postoper_t</code>, this would be accomplished as follows:</p><div class="informalexample"><pre class="programlisting">postfix_signal_qmgr(postoper_t)
postfix_manage_maildrop(postoper_t)</pre></div></div><div class="section" title="Type inheritance and transitions"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec47"/>Type inheritance and transitions</h3></div></div></div><p>When<a id="id522" class="indexterm"/> a domain creates new<a id="id523" class="indexterm"/> resources, these resources are assigned a type based on the label <a id="id524" class="indexterm"/>of the domain as well as<a id="id525" class="indexterm"/> the transitions defined in the SELinux policy. A process that is launched by a domain by default (that is, when no transitions are defined in the policy) inherits the label of the parent domain, while a file created inside a directory by default inherits the type of that parent directory. In the case of labeled network support, the packets are labeled based on the parent socket label.</p><p>Sometimes the creation of a resource cannot be tied to a parent domain or parent resource, making it impossible for SELinux to deduce the label to assign to this resource. For this reason, <span class="strong"><strong>initial SIDs</strong></span> are provided by the SELinux policy. These tell the SELinux subsystem what <a id="id526" class="indexterm"/>the default label is for such resources if no label can be deduced.</p><p>For instance, the initial SIDs for a (TCP/UDP) port and for a file are as follows:</p><div class="informalexample"><pre class="programlisting">sid port gen_context(system_u:object_r:port_t,s0)
sid file gen_context(system_u:object_r:unlabeled_t,s0)</pre></div><p>The definition of initial SIDs is part of the base SELinux policy and cannot be altered using SELinux policy modules. Luckily, there is little reason for SELinux developers to ever touch the initial SID definitions.</p><p>These label inheritance rules are important in a fine-grained application domain design. Applications that use multiple processes also tend to use resources such as shared memory for <span class="strong"><strong>inter-process communication</strong></span> (<span class="strong"><strong>IPC</strong></span>). When all processes run with the same domain, the<a id="id527" class="indexterm"/> shared memory is also labeled the same (such as <code class="literal">postgresql_tmpfs_t</code> for the PostgreSQL managed shared memory) as a file transition would be put in place:</p><div class="informalexample"><pre class="programlisting"># /dev/shm/ shared memory
type postgresql_$1_tmpfs_t;
files_tmpfs_file(postgresql_$1_tmpfs_t)
…
fs_tmpfs_filetrans(postgresql_$1_t, postgresql_$1_tmpfs_t, file)</pre></div><p>When using multiple domain definitions, it is possible that shared memory segments are labeled differently as well (depending on which process creates the shared memory segments, of course), so even IPC can then be properly governed. Separate file transitions would be <a id="id528" class="indexterm"/>put in place <a id="id529" class="indexterm"/>depending on the domain that is creating a shared memory segment.</p><p>Next to<a id="id530" class="indexterm"/> file transitions, policy developers <a id="id531" class="indexterm"/>can also introduce domain transitions (which changes the label of the newly created process) using the <code class="literal">domtrans_pattern</code> definition. Inside the Postfix policy, this is used to create the fine-grained process architecture:</p><div class="informalexample"><pre class="programlisting">domtrans_pattern(postfix_master_t, postfix_postqueue_exec_t, postfix_postqueue_t)
domtrans_pattern(postfix_master_t, postfix_showq_exec_t, postfix_showq_t)</pre></div><p>Such domain transitions can also be supported through the interfaces, as we've seen in the earlier chapters, such as the <code class="literal">postfix_domtrans_smtp</code> interface:</p><div class="informalexample"><pre class="programlisting">interface(`postfix_domtrans_smtp',`
  gen_require(`
    type postfix_smtp_t, postfix_smtp_exec_t;
  ')
  corecmd_search_bin($1)
  domtrans_pattern($1, postfix_smtp_exec_t, postfix_smtp_t)
')</pre></div><p>A third transition type that SELinux supports is the dynamic domain transition. Such SELinux policy rules inform the SELinux subsystem that a process can change its own type dynamically—without needing to execute a file. This does require the application to be SELinux-aware (that is, be able to interact with the SELinux subsystem itself). For instance, inside the FTP policy, the following interface is made available to support domains dynamically transitioning to the <code class="literal">anon_sftpd_t</code> domain:</p><div class="informalexample"><pre class="programlisting">interface(`ftp_dyntrans_anon_ftpd',`
  gen_require(`
    type anon_sftpd_t;
  ')
  dyntrans_pattern($1, anon_sftpd_t)
')</pre></div><p>In our Postfix example, we used the <code class="literal">/dev/shm/</code> shared memory, but there is also POSIX shared memory, which is governed through the <code class="literal">shm</code> class. This shared memory inherits the label from the domain itself, so if two applications (such as <code class="literal">postfix_pickup_t</code> and <code class="literal">postfix_cleanup_t</code>) use POSIX shared memory, then the target label is inherited from the process that creates the shared memory region:</p><div class="informalexample"><pre class="programlisting">allow postfix_pickup_t postfix_cleanup_t:shm rw_shm_perms;</pre></div><p>Without <a id="id532" class="indexterm"/>fine-grained <a id="id533" class="indexterm"/>access <a id="id534" class="indexterm"/>controls, this would all be handled by a single domain (say <code class="literal">postfix_t</code>) and <a id="id535" class="indexterm"/>shared memory access controls would be very limited.</p></div></div></div></body></html>