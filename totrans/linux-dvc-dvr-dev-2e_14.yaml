- en: '*Chapter 11*: Implementing Direct Memory Access (DMA) Support'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：实现直接内存访问（DMA）支持'
- en: '**Direct Memory Access** (**DMA**) is a feature of computer systems that allows
    devices to access the main system memory without CPU intervention, allowing the
    CPU to focus on other tasks. Examples of its usage include network traffic acceleration,
    audio data, or video frame grabbing, and its use is not limited to a particular
    domain. The peripheral responsible for managing the DMA transactions is the DMA
    controller, which is present in the majority of modern processors and microcontrollers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接内存访问**（**DMA**）是计算机系统的一项功能，允许设备在无需 CPU 干预的情况下访问主系统内存，从而使 CPU 能专注于其他任务。它的应用包括网络流量加速、音频数据或视频帧抓取，其使用范围不限于特定领域。负责管理
    DMA 事务的外设是 DMA 控制器，现代大多数处理器和微控制器中都有该控制器。'
- en: 'The feature works in the following manner: When the driver needs to transfer
    a block of data, the driver sets up the DMA controller with the source address,
    the destination address, and the total number of bytes to copy. The DMA controller
    then transfers the data from the source to the destination automatically, without
    stealing CPU cycles. When the number of bytes remaining reaches zero, the block
    transfer ends, and the driver is notified.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的工作原理如下：当驱动程序需要传输一块数据时，驱动程序设置 DMA 控制器，指定源地址、目标地址以及需要复制的字节总数。然后，DMA 控制器会自动将数据从源地址传输到目标地址，而无需占用
    CPU 的周期。当剩余的字节数达到零时，数据块传输结束，驱动程序会收到通知。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: DMA does not always mean copy is going to be faster. It does not bring direct
    speed performance gains, but first, a true background operation, which leaves
    the CPU available to do other stuff, and then, performance gains due to sustaining
    the CPU cache/prefetcher state during DMA operation (which likely would be garbled
    when using plain old memcpy, executed on the CPU itself).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 并不总是意味着复制操作会更快。它不会直接带来性能提升，但首先，它提供了一个真正的后台操作，释放 CPU 去处理其他任务；其次，在 DMA 操作过程中，由于保持了
    CPU 缓存/预取器的状态，性能上会有所提升（如果使用普通的 memcpy，并由 CPU 执行，可能会导致状态紊乱）。
- en: 'This chapter will deal with coherent and non-coherent DMA mappings, as well
    as coherency issues, the DMA engine''s API, and DMA and DT bindings. More precisely,
    we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将处理一致性和非一致性 DMA 映射，以及一致性问题、DMA 引擎的 API 和 DMA 与 DT 绑定。更具体地说，我们将涵盖以下主题：
- en: Setting up DMA mappings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 DMA 映射
- en: Introduction to the concept of completion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成概念介绍
- en: Working with the DMA engine's API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DMA 引擎的 API
- en: Putting it all together – Single-buffer DMA mapping
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 综合起来——单缓冲区 DMA 映射
- en: A word on cyclic DMA
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于循环 DMA 的说明
- en: Understanding DMA and DT bindings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DMA 和 DT 绑定
- en: Setting up DMA mappings
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 DMA 映射
- en: For any type of DMA transfer, you need to provide source and destination addresses,
    as well as the number of words to transfer. In the case of peripheral DMA, this
    peripheral's FIFO acts as either the source or the destination, depending on the
    transfer direction. When the peripheral acts as the source, the destination address
    is a memory location (internal or external). When the peripheral acts as the destination,
    the source address is a memory location (internal or external).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型的 DMA 传输，您需要提供源地址、目标地址以及要传输的字数。在外设 DMA 的情况下，这个外设的 FIFO 会作为源或目标，取决于传输方向。当外设作为源时，目标地址是一个内存位置（内部或外部）。当外设作为目标时，源地址是一个内存位置（内部或外部）。
- en: In other words, a DMA transfer requires suitable memory mappings. This is what
    we will discuss in the following sections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，DMA 传输需要适当的内存映射。接下来的章节将详细讨论这一点。
- en: The concept of cache coherency and DMA
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存一致性与 DMA 的概念
- en: On a CPU equipped with a cache, copies of recently accessed memory areas are
    cached, even memory areas mapped for DMA. The reality is that memory shared between
    two independent devices is generally the source of cache coherency issues. Cache
    incoherency stems from the fact that other devices may not be aware of an update
    from another device writing. On the other hand, cache coherency ensures that every
    write operation appears to occur instantaneously, meaning that all devices sharing
    the same memory region see exactly the same sequence of changes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在配备缓存的CPU上，最近访问的内存区域会被缓存，包括为DMA映射的内存区域。事实上，两个独立设备之间共享的内存通常是缓存一致性问题的根源。缓存不一致性来源于其他设备可能没有意识到另一个设备的写操作。另一方面，缓存一致性确保每个写操作看起来都像是瞬间发生的，这意味着所有共享同一内存区域的设备看到的是完全相同的变化顺序。
- en: 'A well-explained situation of coherency issues is illustrated in the following
    excerpt from the third edition of *Linux Device Drivers (LDD3)*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在《*Linux设备驱动程序（LDD3）*》第三版的以下摘录中，详细阐述了缓存一致性问题的情形：
- en: '"Let us imagine a CPU equipped with a cache and an external memory that can
    be accessed directly by devices using DMA. When the CPU accesses the location
    X in the memory, the current value will be stored in the cache. Subsequent operations
    on X will update the cached copy of X, but not the external memory version of
    X, assuming a write-back cache. If the cache is not flushed to the memory before
    the next time a device tries to access X, the device will receive a stale value
    of X. Similarly, if the cached copy of X is not invalidated when a device writes
    a new value to the memory, then the CPU will operate on a stale value of X."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “让我们假设一台CPU配备了缓存，并且外部内存可以通过DMA直接访问。当CPU访问内存中的位置X时，当前的值将被存储在缓存中。随后的对X的操作将更新X的缓存副本，但不会更新X在外部内存中的版本，假设是写回缓存。如果缓存没有在设备下次尝试访问X之前刷新到内存，设备将接收到X的过时值。同样地，如果当设备写入新值到内存时缓存副本没有失效，CPU将对X的过时值进行操作。”
- en: 'There are two ways to address this issue:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有两种方法：
- en: A hardware-based solution. Such systems are coherent systems.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于硬件的解决方案。这种系统是一致性的系统。
- en: A software-based solution, where the OS is responsible for ensuring cache coherency.
    Such systems are non-coherent systems.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于软件的解决方案，操作系统负责确保缓存一致性。这种系统是非一致性的系统。
- en: Now that we are aware of the caching aspects of DMA, let's move a step forward
    and learn how to perform memory mappings for DMA.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了DMA的缓存方面，让我们向前迈一步，学习如何执行DMA的内存映射。
- en: Memory mappings for DMA
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMA的内存映射
- en: Memory buffers allocated for DMA purposes must be mapped accordingly. A DMA
    mapping consists of allocating a memory buffer suitable for DMA and generating
    a bus address for this buffer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为DMA目的分配的内存缓冲区必须进行适当的映射。DMA映射包括分配一个适合DMA的内存缓冲区，并为该缓冲区生成一个总线地址。
- en: We distinguish between two types of DMA mappings – **coherent DMA mappings**
    and **streaming DMA mappings**. The former automatically addresses cache coherency
    issues, making it a good candidate for reuse over several transfers without unmapping
    in between transfers. This may entail considerable overhead on some platforms
    and, anyways, keeping memory synced has a cost. The streaming mapping has a lot
    of constraints in terms of coding and does not automatically address coherency
    issues, although there is a solution for that, which consists of several function
    calls between each transfer. Coherent mapping usually exists for the life of the
    driver, whereas one streaming mapping is usually unmapped once the DMA transfer
    completes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们区分两种类型的DMA映射——**一致性DMA映射**和**流式DMA映射**。前者自动解决缓存一致性问题，使其成为多个传输中无需在传输之间取消映射而重复使用的好候选方案。这可能会在一些平台上带来相当大的开销，而且，保持内存同步本身就有成本。流式映射在编码方面有很多限制，并且不会自动解决一致性问题，尽管有一个解决方案，它由每次传输之间的多个函数调用组成。一致性映射通常在驱动程序的生命周期内存在，而一个流式映射通常在DMA传输完成后会被取消映射。
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to use streaming mapping when you can, and coherent mapping
    when you must. You should consider using coherent mapping if the buffer is accessed
    unpredictably by the CPU or the DMA controller since memory will always be synced.
    Otherwise, you should use streaming mapping because you know exactly when you
    need to access the buffer, in which case you'll first flush the cache (thereby
    syncing the buffer) before accessing the buffer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在可以时使用流式映射，在必须时使用一致性映射。如果缓冲区会被 CPU 或 DMA 控制器不可预测地访问，你应该考虑使用一致性映射，因为内存始终会被同步。否则，你应该使用流式映射，因为你确切知道何时需要访问缓冲区，在这种情况下，你会先刷新缓存（从而同步缓冲区），然后再访问缓冲区。
- en: 'The main header to include for handling DMA mappings is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 DMA 映射的主要头文件是：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, depending on the mapping, different APIs can be used. Before going
    further in the API, we need to understand the operations that are performed during
    DMA mappings:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，根据映射的不同，可以使用不同的 API。在进一步讨论 API 之前，我们需要理解在 DMA 映射过程中执行的操作：
- en: Assuming the device supports DMA, if the driver sets up a buffer using `kmalloc()`,
    it will get a virtual address (let's call this *X*), which points nowhere yet.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设设备支持 DMA，如果驱动程序使用`kmalloc()`设置缓冲区，它将获得一个虚拟地址（我们称之为*X*），但此时该地址尚未指向任何地方。
- en: The virtual memory system (helped by the **MMU**, the **Memory Management Unit**)
    will map *X* to a physical address (let's call this *Y*) in the system's RAM,
    assuming there is still free memory available.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟内存系统（由 **MMU**，即**内存管理单元**协助）将 *X* 映射到系统 RAM 中的物理地址（我们称之为 *Y*），前提是系统中仍有可用的空闲内存。
- en: Because DMA does not flow through the CPU virtual memory system, the driver
    can use virtual address *X* to access the buffer at this point, but the device
    itself cannot.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DMA 不通过 CPU 虚拟内存系统流动，驱动程序可以使用虚拟地址 *X* 来访问此时的缓冲区，但设备本身不能。
- en: In some simple systems (those without I/O MMU), the device can do DMA directly
    to physical the address *Y*. But in many others, devices see the main memory through
    the lenses of the I/O MMU; thus, there is I/O MMU hardware that translates DMA
    addresses to physical addresses, for example, it translates *Z* to *Y*.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一些简单系统（没有 I/O MMU 的系统）中，设备可以直接对物理地址 *Y* 进行 DMA。但在许多其他系统中，设备通过 I/O MMU 观察主内存；因此，存在将
    DMA 地址转换为物理地址的 I/O MMU 硬件，例如，它将 *Z* 转换为 *Y*。
- en: 'This is where the DMA API intervenes:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这时 DMA API 介入：
- en: The driver can pass a virtual address *X* to a function such as `dma_map_single()`
    (which we will look at later in this chapter, in The *Single-buffer mapping* section),
    which sets up any appropriate I/O MMU mapping and returns the DMA address *Z.*
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序可以将虚拟地址 *X* 传递给类似于 `dma_map_single()` 的函数（我们将在本章的 *单缓冲区映射* 部分中讨论），该函数设置任何适当的
    I/O MMU 映射并返回 DMA 地址 *Z*。
- en: The driver then instructs the device to do DMA into *Z*.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序接着指示设备执行 DMA 操作到 *Z*。
- en: The I/O MMU finally maps it to the buffer at address *Y* in the system's RAM.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O MMU 最终将其映射到系统 RAM 中地址为 *Y* 的缓冲区。
- en: Now that the concept of memory mapping for DMA has been introduced, we can start
    creating mappings, starting with the easiest ones – the coherent DMA mappings.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了用于 DMA 的内存映射概念，我们可以开始创建映射，从最简单的一致性 DMA 映射开始。
- en: Creating coherent DMA mappings
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一致性的 DMA 映射
- en: 'Such mappings are most often used for long-lasting, bi-directional I/O buffers.
    The following function sets up a coherent mapping:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射通常用于持久性双向 I/O 缓冲区。以下函数设置了一个一致性的映射：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function is responsible for both the allocation and the mapping of the
    buffer. It returns a kernel virtual address for that buffer, which is `size` bytes
    wide and accessible by the CPU. The `size` parameter may be misleading as it is
    first given to `get_order()` APIs to get the page order that corresponds to this
    size. Consequently, this mapping is at least page-sized, and the number of pages
    the power of 2\. `dev` is your device structure. The third argument is an output
    parameter that points to the associated bus address. Memory allocated for the
    mapping is guaranteed to be physically contiguous, and flags determine how memory
    should be allocated, which is usually `GFP_KERNEL`, or `GFP_ATOMIC` in an atomic
    context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责缓冲区的分配和映射。它返回一个内核虚拟地址，该地址对应于该缓冲区，宽度为`size`字节，并且CPU可以访问。`size`参数可能会引起误解，因为它首先传递给`get_order()`
    API，以获得与此大小对应的页面顺序。因此，这个映射至少是页面大小的，并且页面数量是2的幂。`dev`是你的设备结构。第三个参数是一个输出参数，指向相关的总线地址。为映射分配的内存保证是物理连续的，标志决定了内存应如何分配，通常是`GFP_KERNEL`，或者在原子上下文中是`GFP_ATOMIC`。
- en: 'Do note that this mapping is said to be the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个映射称为以下内容：
- en: Consistent (coherent) because the buffer content is always the same across all
    subsystems (either the device or the CPU)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性（coherent）是因为缓冲区内容在所有子系统中始终相同（无论是设备还是CPU）。
- en: Synchronous, because a write by either the device or the CPU can immediately
    be read without worrying about cache coherency
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步，因为设备或CPU的写入可以立即读取，而无需担心缓存一致性。
- en: 'To release the mapping, you can use the following API:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放映射，可以使用以下API：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding prototype, `cpu_addr` and `dma_handle` correspond to the kernel
    virtual address and bus address returned by `dma_alloc_coherent()`. Those two
    parameters are required by the MMU (which returned the virtual address) and the
    I/O MMU (which returned the bus address) to release their mappings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`cpu_addr`和`dma_handle`分别对应由`dma_alloc_coherent()`返回的内核虚拟地址和总线地址。这两个参数是MMU（返回虚拟地址）和I/O
    MMU（返回总线地址）释放其映射时所需的。
- en: Creating streaming DMA mappings
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建流式DMA映射
- en: 'Streaming DMA mapping memory buffers are typically mapped right before the
    transmission and unmapped afterward. Such mappings have more constraints and differ
    from coherent mappings for the following reasons:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 流式DMA映射内存缓冲区通常在传输之前映射，传输之后取消映射。这种映射有更多的约束，并且与一致性映射不同，原因如下：
- en: Mappings need to function with a buffer that has previously been allocated dynamically.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射需要与先前动态分配的缓冲区一起工作。
- en: Mappings may accept several non-contiguous and scattered buffers.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可以接受多个不连续且分散的缓冲区。
- en: For read transactions (device to CPU), buffers belong to the device, not to
    the CPU. Before the CPU can use the buffers, they should be unmapped first (after
    `dma_unmap_{single,sg}()`), or `dma_sync_{single,sg}_for_cpu()` must be invoked
    on those buffers. The main reason for this is caching purposes.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于读事务（设备到CPU），缓冲区属于设备，而不是CPU。在CPU使用这些缓冲区之前，应先取消映射（在`dma_unmap_{single,sg}()`之后），或者必须在这些缓冲区上调用`dma_sync_{single,sg}_for_cpu()`。这样做的主要原因是为了缓存目的。
- en: For write transactions (CPU to device), the driver should place data in the
    buffer before establishing the mapping.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于写事务（CPU到设备），驱动程序应在建立映射之前将数据放入缓冲区。
- en: The transfer direction has to be specified, and the data should move and should
    be used only based on this direction.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须指定传输方向，并且数据应该按照该方向进行移动和使用。
- en: 'There are two forms of streaming mapping:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 流式映射有两种形式：
- en: Single-buffer mapping, which allows one physically contiguous buffer mapping
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单缓冲区映射，允许映射一个物理连续的缓冲区
- en: Scatter/gather mapping, which allows several buffers to be passed (scattered
    over memory)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散射/聚集映射，允许传递多个缓冲区（分散在内存中）
- en: 'For both mappings, the transfer direction should be specified by a symbol of
    the `enum dma_data_direction` type, defined in `include/linux/dma-direction.h`,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种映射，传输方向应通过`enum dma_data_direction`类型的符号来指定，定义在`include/linux/dma-direction.h`中，如下所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding excerpt, each element is quite self-explanatory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的摘录中，每个元素都相当自解释。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Coherent mappings implicitly have a direction attribute setting set with `DMA_BIDIRECTIONAL`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性映射隐式地设置了一个方向属性，值为`DMA_BIDIRECTIONAL`。
- en: Now that we are aware of the two streaming DMA mapping methods, we can get the
    details of their implementations, starting with the single-buffer mappings.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了两种流式 DMA 映射方法，我们可以深入了解它们的实现，首先从单缓冲区映射开始。
- en: Single-buffer mapping
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单缓冲区映射
- en: 'Single-buffer mapping is a streaming mapping for occasional transfer. You can
    set up such a mapping using the `dma_map_single()` function, which has the following
    definition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单缓冲区映射是一种偶尔传输的流式映射。你可以使用`dma_map_single()`函数设置这样的映射，该函数具有以下定义：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The direction should be either `DMA_TO_DEVICE`, `DMA_FROM_DEVICE`, or `DMA_BIDIRECTIONAL`,
    respectively, when the CPU is the source (it writes to the device), when the CPU
    is the destination (it reads from the device), or when access is bi-directional
    for this mapping (implicitly used in coherent mappings). `dev` is the underlying
    `device` structure for your hardware device, `ptr` is an output parameter, and
    is the kernel virtual address of the buffer. This function returns an element
    of the `dma_addr_t` type, which is the bus address returned by the I/O MMU (if
    present) for the device so that the device can DMA into. You should use `dma_mapping_error()`
    (which must return `0` if no error occurred) to check whether the mapping returned
    a valid address and not go further in case of an error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当 CPU 是源（它写入设备）、CPU 是目标（它从设备读取）或该映射的访问是双向的（在一致性映射中隐式使用）时，方向应分别为`DMA_TO_DEVICE`、`DMA_FROM_DEVICE`或`DMA_BIDIRECTIONAL`。`dev`是你硬件设备的底层`device`结构，`ptr`是一个输出参数，是缓冲区的内核虚拟地址。此函数返回`dma_addr_t`类型的元素，这是
    I/O MMU（如果存在）返回的设备总线地址，以便设备能够进行 DMA 操作。你应该使用`dma_mapping_error()`（如果没有错误发生，必须返回`0`）来检查映射是否返回了有效地址，并且如果发生错误，不要继续操作。
- en: 'Such mapping can be released by the following function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射可以通过以下函数释放：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The other mapping is scatter/gather mappings, since memory buffers are spread
    (scattered) over the system on allocation and gathered by the driver.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种映射是散列/收集映射，因为内存缓冲区在分配时被分散（散布）到系统中，并由驱动程序收集。
- en: Scatter/gather mappings
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 散列/收集映射
- en: 'Scatter/gather mappings are a special type of streaming DMA mapping that allow
    the transfer of several memory buffers in a single shot, instead of mapping each
    buffer individually and transferring them one by one. Suppose you have several
    buffers that might not be physically contiguous, all of which need to be transferred
    at the same time to or from the device. This situation may occur due to the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 散列/收集映射是一种特殊类型的流式 DMA 映射，允许在一次操作中传输多个内存缓冲区，而不是逐个映射每个缓冲区并依次传输它们。假设你有多个缓冲区，它们可能在物理上并不连续，但需要同时传输到设备或从设备传输。这种情况可能会由于以下原因发生：
- en: A `readv` or `writev` system call
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`readv`或`writev`系统调用
- en: A disk I/O request
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个磁盘 I/O 请求
- en: Or simply a list of pages or a vmalloced region
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者仅仅是一个页面列表或一个 vmalloc 区域
- en: 'Before you can issue such a mapping, you must set up an array of scatter elements,
    each of which should describe the mapping of an individual buffer. A scatter element
    is abstracted in the kernel as an instance of `struct scatterlist`, defined as
    follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以发出这种映射之前，你必须设置一个散列元素数组，每个元素应描述单个缓冲区的映射。散列元素在内核中被抽象为`struct scatterlist`的实例，定义如下：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To set up a scatter list mapping, you should do the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个散列列表映射，你应当执行以下操作：
- en: Allocate your scattered buffers.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配你的散布缓冲区。
- en: Create an array of scatter elements, initialize this array using `sg_init_table()`
    on it, and fill this array with allocated memory using `sg_set_buf()`. Note that
    each scatter element entry must be of page size, except the last one, which may
    not respect this rule.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个散列元素数组，使用`sg_init_table()`初始化该数组，并使用`sg_set_buf()`将已分配的内存填充到此数组中。请注意，每个散列元素条目必须是页面大小，最后一个元素除外，最后一个元素可能不遵循此规则。
- en: Call `dma_map_sg()` on the scatter list.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在散列列表上调用`dma_map_sg()`。
- en: Once done with DMA, call `dma_unmap_sg()` to unmap the scatter list.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA 操作完成后，调用`dma_unmap_sg()`取消映射散列列表。
- en: 'The following is a diagram that describes most of the concepts of the scatter
    list:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述散列列表大部分概念的图示：
- en: '![Figure 11.1 – Scatter/gather memory organization'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 散列/收集内存组织'
- en: '](img/B17934_11_001.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_11_001.jpg)'
- en: Figure 11.1 – Scatter/gather memory organization
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 散列/收集内存组织
- en: While it is possible to DMA the content of several buffers individually, scatter/gather
    makes it possible to DMA the whole list at once by sending the pointer to the
    scatter list array to the device, along with its length, which is the number of
    entries in the array.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以单独进行 DMA 操作每个缓冲区的内容，但散列/聚集（scatter/gather）使得可以通过将散列列表数组的指针和其长度（数组中的条目数）一起发送到设备，来一次性进行
    DMA 操作整个列表。
- en: 'The prototypes of `sg_init_table()`, `sg_set_buf()`, and `dma_map_sg()` are
    as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sg_init_table()`、`sg_set_buf()` 和 `dma_map_sg()` 的原型如下：'
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding APIs, `sgl` is the `scatterlist` array to initialize and `nents`
    is the number of entries in this array. `sg_set_buf()` sets a `scattlerlist` entry
    to point at given data. In its parameters, `sg` is the `scatterlist` entry, `data`
    is the buffer corresponding to the entry, and `buflen` is the size of the buffer.
    `dma_map_sg()` returns the number of elements in the list that have been successfully
    mapped, which means it must never be less than zero. In the event of an error,
    this function returns zero.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 API 中，`sgl` 是要初始化的 `scatterlist` 数组，`nents` 是该数组中的条目数量。`sg_set_buf()` 将
    `scatterlist` 条目设置为指向给定数据。在其参数中，`sg` 是 `scatterlist` 条目，`data` 是与该条目对应的缓冲区，`buflen`
    是缓冲区的大小。`dma_map_sg()` 返回已成功映射的列表中元素的数量，这意味着它永远不会小于零。如果发生错误，此函数将返回零。
- en: 'The following is a code sample that demonstrates the principle of scatter/gather
    mapping:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示散列/聚集映射原理的代码示例：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The same rules described in the single-buffer mapping section apply to scatter/gather.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在散列/聚集映射中，单缓冲区映射部分中描述的相同规则也适用于散列/聚集。
- en: 'To unmap the list, you must use `dma_unmap_sg()`, which has the following definition:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消映射列表，必须使用 `dma_unmap_sg()`，其定义如下：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`dev` is a pointer to the same device that has been used for mapping, `sg`
    is the scatter list (actually a pointer to the first element in the list) to be
    unmapped, `dir` is the DMA direction, which should map the mapping direction,
    and `nents` is the number of elements in the list.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev` 是指向已用于映射的相同设备的指针，`sg` 是要取消映射的散列列表（实际上是指向列表中第一个元素的指针），`dir` 是 DMA 方向，应该映射映射方向，`nents`
    是列表中元素的数量。'
- en: 'The following is an example that unmaps the previous implementation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是取消映射前一个实现的示例：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we used the same parameters that we used during the
    mapping.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了与映射过程中相同的参数。
- en: Implicit and explicit cache coherency for streaming mapping
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 流式映射的隐式和显式缓存一致性
- en: In either streaming mapping, `dma_map_single()`/`dma_unmap_single()` and `dma_map_sg()`/`dma_unmap_sg()`
    pairs take care of cache coherency when they are invoked. In the case of outgoing
    DMA transfer (CPU to device, `DMA_TO_DEVICE` direction flag set), since data must
    be in buffers before establishing the mapping, `dma_map_sg()`/`dma_map_single()`
    will handle cache coherency. In the case of device to CPU (`DMA_FROM_DEVICE` direction
    flag set), the mappings must be released first before the CPU can access the buffers.
    This is because `dma_unmap_single()`/`dma_unmap_sg()` implicitly take care of
    cache coherency as well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何流式映射中，`dma_map_single()`/`dma_unmap_single()` 和 `dma_map_sg()`/`dma_unmap_sg()`
    成对调用时，会处理缓存一致性。在外向 DMA 传输（从 CPU 到设备，设置 `DMA_TO_DEVICE` 方向标志）情况下，由于数据必须在建立映射之前就位于缓冲区中，`dma_map_sg()`/`dma_map_single()`
    将处理缓存一致性。在设备到 CPU 的情况（设置 `DMA_FROM_DEVICE` 方向标志），必须首先释放映射，然后 CPU 才能访问缓冲区。这是因为
    `dma_unmap_single()`/`dma_unmap_sg()` 也会隐式处理缓存一致性。
- en: However, if you need to use the same streaming DMA region numerous times and
    touch the data in between the DMA transfers, the buffer must be synced properly
    so that the device and CPU see the most up-to-date and correct copy of the DMA
    buffer. To avoid cache coherency issues, the driver must call `dma_sync_{single,sg}_for_device()`
    right before starting a DMA transfer from the RAM to the device (after you have
    put data in the buffer and before actually giving the buffer to the hardware).
    This function call will flush, if necessary, the cache lines corresponding to
    the DMA buffer. Similarly, the driver should not access the memory buffer immediately
    after completing the DMA transfer from the device to the RAM; instead, before
    reading the buffer, the driver should call `dma_sync_{single,sg}_for_cpu()`, which
    invalidates the associated hardware cache lines if necessary. In other words,
    when the source buffer is the device memory, the cache should be invalidated (cache
    data is not dirty as nothing has been written by the CPU to any buffer), whereas
    if the source is RAM (the destination is the device memory), this means the CPU
    may have written some data to the source buffer and the data may be in the cache
    line, hence the cache should be flushed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你需要多次使用相同的流式 DMA 区域，并在 DMA 传输之间访问数据，缓冲区必须正确同步，以便设备和 CPU 都能看到 DMA 缓冲区的最新正确副本。为了避免缓存一致性问题，驱动程序必须在从
    RAM 向设备启动 DMA 传输之前（在将数据放入缓冲区并实际将缓冲区交给硬件之前）调用 `dma_sync_{single,sg}_for_device()`。这个函数调用会在必要时刷新与
    DMA 缓冲区对应的缓存行。类似地，驱动程序在完成从设备到 RAM 的 DMA 传输后不应立即访问内存缓冲区；相反，在读取缓冲区之前，驱动程序应调用 `dma_sync_{single,sg}_for_cpu()`，如果需要，它将使相关硬件缓存行失效。换句话说，当源缓冲区是设备内存时，应使缓存失效（缓存数据并不脏，因为
    CPU 没有向任何缓冲区写入数据）；而如果源是 RAM（目标是设备内存），这意味着 CPU 可能已经向源缓冲区写入了一些数据，并且这些数据可能在缓存行中，因此缓存应被刷新。
- en: 'The following are the prototypes of those syncing APIs:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些同步 API 的原型：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In all of the preceding APIs, the direction parameter must remain the same as
    the direction specified during the mapping of the corresponding buffer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的所有 API 中，方向参数必须与映射相应缓冲区时指定的方向保持一致。
- en: In this section, we have learned to set up streaming DMA mappings. Now that
    we are done with mappings, let's introduce the concept of completion, which is
    used to notify a DMA transfer completion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经学习了如何设置流式 DMA 映射。现在我们完成了映射的部分，接下来介绍完成概念，用于通知 DMA 传输完成。
- en: Introduction to the concept of completion
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成概念介绍
- en: This section will briefly describe completion and the necessary part of its
    API that the DMA transfer uses. For a complete description, feel free to have
    a look at the kernel documentation at `Documentation/scheduler/completion.txt`.
    In kernel programming, a typical practice is to start some activity outside of
    the current thread and then wait for it to finish. Completions are good alternatives
    to waitqueues or sleeping APIs while waiting for a very commonly occurring process
    to complete. Completion variables are implemented using wait queues, with the
    only difference being that they make the developer's life easier as it does not
    require the wait queue to be maintained, which makes it very easy to see the intent
    of the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要描述完成以及 DMA 传输使用的必要 API 部分。有关完整描述，请随时查看 `Documentation/scheduler/completion.txt`
    中的内核文档。在内核编程中，典型的做法是启动当前线程外的某些活动，然后等待其完成。完成是等待非常常见的过程完成时，等待队列或休眠 API 的良好替代方案。完成变量使用等待队列来实现，唯一的区别是它们使开发者的工作变得更简单，因为不需要维护等待队列，这使得代码的意图非常清晰易懂。
- en: 'Working with completion requires this header:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完成时需要这个头文件：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A completion variable is represented in the kernel as an instance of struct
    completion structures that can be initialized statically as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成变量在内核中表示为一个结构体 `completion` 的实例，可以像下面这样静态初始化：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Dynamic allocation of an initialization is done as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分配初始化可以如下进行：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the driver initiates work whose completion must be awaited (a DMA transaction
    in our case), it just has to pass the completion event to the `wait_for_completion()`
    function, which has the following prototype:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序启动必须等待完成的工作（在我们这里是 DMA 事务）时，它只需要将完成事件传递给 `wait_for_completion()` 函数，该函数的原型如下：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When the completion occurs, the driver can wake the waiters using one of the
    following APIs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成发生时，驱动程序可以使用以下 API 之一唤醒等待者：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`complete()` will wake up only one waiting task, while `complete_all()` will
    wake up every task waiting for that event. Completions are implemented in such
    a way that they will work properly even if `complete()` is called before `wait_for_completion()`
    is.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`complete()` 只会唤醒一个等待的任务，而 `complete_all()` 会唤醒所有等待该事件的任务。完成操作是以一种确保即使在 `wait_for_completion()`
    之前调用 `complete()` 时也能正常工作的方式实现的。'
- en: In this section, we have learned to implement a completion callback to notify
    the completeness status of a DMA transfer. Now that we are comfortable with all
    the common concepts of the DMA, we can start applying these concepts using the
    DMA engine APIs, which will also help us better understand how things work once
    everything is put together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经学会了实现一个完成回调，以通知 DMA 传输的完成状态。现在我们已经掌握了 DMA 的所有常见概念，可以开始使用 DMA 引擎 API
    来应用这些概念，这也有助于我们更好地理解当一切合并在一起时，事物是如何运作的。
- en: Working with the DMA engine's API
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DMA 引擎的 API
- en: The DMA engine is a generic kernel framework used to develop DMA controller
    drivers and leverage this controller from the consumer side. Through this framework,
    the DMA controller driver exposes a set of channels that can be used by client
    devices. This framework then makes it possible for client drivers (also called
    slaves) to request and use DMA channels from the controller to issue DMA transfers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 引擎是一个通用的内核框架，用于开发 DMA 控制器驱动程序并从消费端利用该控制器。通过这个框架，DMA 控制器驱动程序暴露出一组可以供客户端设备使用的通道。这个框架使得客户端驱动（也称为从属驱动）能够请求并使用来自控制器的
    DMA 通道来发起 DMA 传输。
- en: 'The following diagram is the layering, showing how this framework is integrated
    with the Linux kernel:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了这一框架的分层结构，显示了该框架如何与 Linux 内核集成：
- en: '![Figure 11.2 – DMA engine framework'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – DMA 引擎框架'
- en: '](img/B17934_11_002.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_11_002.jpg)'
- en: Figure 11.2 – DMA engine framework
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – DMA 引擎框架
- en: 'Here we will simply walk through that (slave) API, which is applicable for
    slave DMA usage only. The mandatory header here is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简单介绍该（从属）API，仅适用于从属 DMA 使用。这里的强制性头文件如下：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The slave DMA usage is straightforward, and consists of the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从属 DMA 的使用是直接的，包括以下步骤：
- en: Informing the kernel about the device's DMA addressing capabilities.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知内核设备的 DMA 地址能力。
- en: Requesting a DMA channel.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求 DMA 通道。
- en: If successful, configuring this DMA channel.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，配置这个 DMA 通道。
- en: Preparing or configuring a DMA transfer. At this step, a transfer descriptor
    that represents the transfer is returned.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备或配置 DMA 传输。在此步骤中，返回一个表示传输的传输描述符。
- en: Submitting the DMA transfer using the descriptor. The transfer is then added
    to the controller's pending queue corresponding to the specified channel. This
    step returns a special cookie that you can use to check the progression of the
    DMA activity.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用描述符提交 DMA 传输。然后，传输被添加到控制器的待处理队列中，等待指定通道的处理。此步骤返回一个特殊的 cookie，你可以用它来检查 DMA
    活动的进展。
- en: Starting the DMA transfers on the specified channel so that, if the channel
    is idle, the first transfer in the queue is started.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定通道上启动 DMA 传输，以便当通道空闲时，队列中的第一个传输开始。
- en: Now that we are aware of the steps needed to implement a DMA transfer, let's
    learn the data structures involved in the DMA engine framework before using the
    corresponding APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了实现 DMA 传输所需的步骤，让我们在使用相应的 API 之前，先了解 DMA 引擎框架中涉及的数据结构。
- en: A brief introduction to the DMA controller interface
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简要介绍 DMA 控制器接口
- en: 'The usage of DMA in Linux consists of two parts: the controllers, which perform
    memory transfer (without the CPU intervening), and the channels, which are the
    ways by which client drivers (that is, DMA-capable drivers) submit jobs to controllers.
    It goes without saying that both the controller and its channels are tightly coupled
    because the former exposes the latter to clients.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中 DMA 的使用包括两个部分：控制器，执行内存传输（不需要 CPU 介入），以及通道，客户端驱动（即支持 DMA 的驱动）通过通道向控制器提交任务。无需多言，控制器和其通道是紧密耦合的，因为前者向客户端暴露后者。
- en: Although this chapter targets DMA client drivers, for the sake of understandability,
    we will be introducing some controller data structures and APIs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章面向 DMA 客户端驱动，但为了便于理解，我们将介绍一些控制器数据结构和 API。
- en: The DMA controller data structure
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DMA 控制器数据结构
- en: 'The DMA controller is abstracted in the Linux kernel as an instance of `struct
    dma_device`. On its own, the controller is useless without clients, which would
    use the channels it exposes. Moreover, the controller driver must expose callbacks
    for channel configuration, as specified in its data structure, which has the following
    definition:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: DMA控制器在Linux内核中作为`struct dma_device`的一个实例进行抽象。仅凭控制器本身，若没有客户端使用它暴露的通道，则控制器是无用的。此外，控制器驱动必须暴露用于通道配置的回调，正如其数据结构中所指定的那样，该数据结构具有以下定义：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The complete definition of this data structure is available in `include/linux/dmaengine.h`.
    For this chapter, only fields of our interest have been listed. Their meanings
    are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据结构的完整定义可在`include/linux/dmaengine.h`中找到。本章节仅列出了我们关注的字段。它们的含义如下：
- en: '`chancnt`: Specifies how many DMA channels are supported by this controller'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chancnt`：指定该控制器支持多少个DMA通道'
- en: '`channels`: The list of `struct dma_chan` structures, which corresponds to
    the DMA channels exposed by this controller'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels`：`struct dma_chan`结构的列表，表示该控制器暴露的DMA通道'
- en: '`privatecnt`: How many DMA channels are requested by `dma_request_channel()`,
    which is the DMA engine API to request a DMA channel'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`privatecnt`：由`dma_request_channel()`请求的DMA通道数量，`dma_request_channel()`是DMA引擎API用于请求DMA通道'
- en: '`cap_mask`: One or more `dma_capability` flags, representing the capabilities
    of this controller'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap_mask`：一个或多个`dma_capability`标志，表示该控制器的能力'
- en: 'The following are the possible values:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的值：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As an example, this element is set in the i.MX DMA controller driver as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，这个元素在i.MX DMA控制器驱动中设置如下：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`src_addr_widths`: The bit mask of source address widths that the device supports.
    This width must be supplied in bytes; for example, if the device supports a width
    of `4`, the mask should be set to `BIT(4)`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_addr_widths`：设备支持的源地址宽度的位掩码。此宽度必须以字节为单位提供；例如，如果设备支持`4`的宽度，则掩码应设置为`BIT(4)`。'
- en: '`dst_addr_widths`: The bit mask of destination address widths that the device
    supports.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dst_addr_widths`：设备支持的目标地址宽度的位掩码。'
- en: '`directions`: The bit mask of slave directions supported by the device. Because
    `enum dma_transfer_direction` does not include a bit flag for each type, the DMA
    controller should set `BIT(<TYPE>)` and the same should be checked by the controller
    as well.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directions`：设备支持的从属方向的位掩码。由于`enum dma_transfer_direction`中没有为每种类型定义一个位标志，DMA控制器应设置`BIT(<TYPE>)`，且控制器也应检查相同的内容。'
- en: 'It is set in the i.MX SDMA controller driver as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它在i.MX SDMA控制器驱动中设置如下：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`device_alloc_chan_resources`: Allocates resources and returns the number of
    allocated descriptors. Invoked by the DMA engine core when requesting a channel
    on this controller.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_alloc_chan_resources`：分配资源并返回分配的描述符数量。由DMA引擎核心在请求该控制器的通道时调用。'
- en: '`device_free_chan_resources`: A callback allowing the release of the DMA channel''s
    resources.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_free_chan_resources`：一个回调，允许释放DMA通道的资源。'
- en: While the preceding was a generic callback, the following is a controller callback
    that depends on the controller capabilities and that must be provided if the associated
    capability bit masks are set in `cap_mask`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前述为通用回调，以下是依赖于控制器能力的控制器回调，只有在`cap_mask`中设置了相关能力位掩码时，必须提供此回调。
- en: '`device_prep_dma_memcpy` prepares a memcpy operation. If `DMA_MEMCPY` is set
    in `cap_mask`, then this element must be set. For each flag set, the corresponding
    callback must be provided, otherwise controller registration will fail. This is
    the case for all `device_prep_*` callbacks.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memcpy`准备一个memcpy操作。如果`DMA_MEMCPY`在`cap_mask`中设置，则此元素必须设置。对于每个设置的标志，必须提供相应的回调，否则控制器注册将失败。所有`device_prep_*`回调都如此。'
- en: '`device_prep_dma_xor`: Prepares an XOR operation.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_xor`：准备一个XOR操作。'
- en: '`device_prep_dma_xor_val`: Prepares an xor validation operation.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_xor_val`：准备一个异或验证操作。'
- en: '`device_prep_dma_memset`: Prepares a memset operation.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memset`：准备一个memset操作。'
- en: '`device_prep_dma_memset_sg`: Prepares a memset operation over a scatter list.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memset_sg`：准备一个在散列表上进行memset操作。'
- en: '`device_prep_dma_interrupt`: Prepares an end of chain interrupt operation.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_interrupt`：准备一个链终止中断操作。'
- en: '`device_prep_slave_sg`: Prepares a slave DMA operation.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_slave_sg`：准备一个从属DMA操作。'
- en: '`device_prep_dma_cyclic`: Prepares a cyclic DMA operation. Such a DMA operation
    is frequently used in audio or UART drivers. A buffer of size `buf_len` is required
    by the function. The callback function will be called after `period_len` bytes
    have been transferred. We discuss such DMAs in the *A word on cyclic DMA* section.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_cyclic`：准备一个循环 DMA 操作。此类 DMA 操作通常用于音频或 UART 驱动程序。该函数需要一个大小为
    `buf_len` 的缓冲区。每当传输 `period_len` 字节后，将调用回调函数。我们将在 *关于循环 DMA* 部分讨论此类 DMA。'
- en: '`device_prep_interleaved_dma`: Transfers expression in a generic way.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_interleaved_dma`：以通用方式传输表达式。'
- en: '`device_config`: Pushes a new configuration to a channel, with a return value
    of `0` in the event of success or an error code otherwise.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_config`：将新的配置推送到通道，成功时返回 `0`，否则返回错误代码。'
- en: '`device_pause`: Pauses any current transfer on a channel and returns `0` or
    if the pausing is effective, or an error code otherwise.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_pause`：暂停通道上的任何当前传输，并返回 `0`（如果暂停有效），否则返回错误代码。'
- en: '`device_resume`: Resumes any previously paused transfer on a channel. It returns
    `0` or an error code otherwise.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_resume`：恢复之前暂停的通道上的任何传输。返回 `0`，否则返回错误代码。'
- en: '`device_terminate_all`: A callback used to abort all the transfers on a channel,
    and which returns `0` in the event of success or an error code otherwise.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_terminate_all`：一个回调，用于中止通道上的所有传输，并在成功时返回 `0`，否则返回错误代码。'
- en: '`device_synchronize`: A callback allowing synchronization of the termination
    of a transfer to the current context.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_synchronize`：一个回调函数，用于将传输结束的同步操作与当前上下文对接。'
- en: '`device_tx_status`: Polls for transaction completion. The optional `txstate`
    parameter can be used to obtain a struct containing auxiliary transfer status
    information; otherwise, the call will just return a simple status code.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_tx_status`：轮询事务是否完成。可选的 `txstate` 参数可用于获取包含附加传输状态信息的结构体；否则，该调用将仅返回一个简单的状态代码。'
- en: '`device_issue_pending`: A mandatory callback that pushes pending transactions
    to hardware. This is the backend of the `dma_async_issue_pending()` API.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_issue_pending`：一个强制性的回调，用于将待处理的事务推送到硬件。这是 `dma_async_issue_pending()`
    API 的后端实现。'
- en: While most drivers make a direct invocation of these callbacks (through `dma_chan->dma_dev->device_prep_dma_*`),
    you should be using the `dmaengine_prep_*` DMA engine APIs, which additionally
    do some sanity checks before invoking the appropriate callback. For example, for
    memory to memory, the driver should use the `device_prep_dma_memcpy()` wrapper.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数驱动程序直接调用这些回调函数（通过 `dma_chan->dma_dev->device_prep_dma_*`），但你应该使用 `dmaengine_prep_*`
    DMA 引擎 API，这些 API 在调用相应回调之前会进行一些有效性检查。例如，对于内存到内存的传输，驱动程序应使用 `device_prep_dma_memcpy()`
    包装函数。
- en: The DMA channel data structure
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DMA 通道数据结构
- en: 'A DMA channel is how a client driver submits DMA transactions (I/O data transfers)
    to the DMA controller. The way it works, a DMA-capable driver (client driver)
    requests one or more channels, reconfigures this channel, and asks the controller
    to use this channel to perform the submitted DMA transfer. A channel is defined
    as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 通道是客户端驱动程序提交 DMA 事务（I/O 数据传输）给 DMA 控制器的方式。其工作原理是：支持 DMA 的驱动程序（客户端驱动程序）请求一个或多个通道，重新配置该通道，并要求控制器使用此通道执行已提交的
    DMA 传输。通道定义如下：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can see a DMA channel as a highway for I/O data transfer. The following
    are the meanings of each element in this data structure:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 DMA 通道看作是用于 I/O 数据传输的高速公路。以下是该数据结构中每个元素的含义：
- en: '`device`: This is a pointer to the DMA device (the controller) that supplies
    this channel. This field can never be `NULL` if the channel has been requested
    successfully because a channel always belongs to a controller.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device`：指向提供此通道的 DMA 设备（控制器）的指针。如果通道成功请求，字段绝不应为 `NULL`，因为一个通道始终属于一个控制器。'
- en: '`slave`: This is a pointer to the underlying `struct device` structure for
    the device using this channel (its driver is a client driver).'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slave`：指向使用此通道的设备底层 `struct device` 结构的指针（其驱动程序为客户端驱动程序）。'
- en: '`cookie`: This represents the last cookie value returned to the client by this
    channel.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`：表示该通道返回给客户端的最后一个 cookie 值。'
- en: '`Completed_cookie`: The last completed cookie for this channel.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Completed_cookie`：此通道的最后一个完成的 cookie。'
- en: The complete definition of this data structure can be found in `include/linux/dmaengine.h`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据结构的完整定义可以在 `include/linux/dmaengine.h` 文件中找到。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the DMA engine framework, a cookie is nothing but a DMA transaction identifier
    that allows the status and progression of the transaction it identifies to be
    checked.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DMA 引擎框架中，cookie 只是一个 DMA 事务标识符，允许检查它标识的事务的状态和进展。
- en: DMA transaction descriptor data structure
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DMA 事务描述符数据结构
- en: 'A transaction descriptor does nothing other than characterize and describe
    a DMA transaction (or DMA transfer by abuse of language). Such a descriptor is
    represented in the kernel using a `struct dma_async_tx_descriptor` data structure,
    which has the following definition:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 事务描述符除了描述和表征 DMA 事务（或在语言滥用下称为 DMA 传输）外没有其他功能。这样的描述符在内核中使用`struct dma_async_tx_descriptor`数据结构表示，其定义如下：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The meanings of each element we have retained in this data structure are set
    out here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个数据结构中保留的每个元素的含义在这里列出：
- en: '`cookie`: A tracking cookie for this transaction. It allows the progression
    of this transaction to be checked.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookie`：此事务的跟踪 cookie。它允许检查此事务的进展。'
- en: '`chan`: The target channel for this operation.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chan`：此操作的目标通道。'
- en: '`callback`: A function that should be called once this operation is complete.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback`：一旦操作完成，应调用的函数。'
- en: '`callback_param`: This is given as a parameter of the callback function.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callback_param`：作为回调函数的参数传递。'
- en: You can find the complete data structure description in `include/linux/dmaengine.h`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`include/linux/dmaengine.h`中找到完整的数据结构描述。
- en: Handling device DMA addressing capabilities
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理设备的 DMA 地址能力
- en: The kernel considers that your device can handle 32-bit DMA addressing by default.
    However, the DMA memory address range your device can access may be limited, and
    this may be due to manufacturer or historical reasons. Some devices, for example,
    may only support the low order 24-bits of addressing. This limitation originated
    from the ISA bus, which was 24-bits wide and where DMA buffers could only live
    in the bottom 16 MB of the system's memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 内核默认认为你的设备可以处理 32 位 DMA 地址。然而，设备能够访问的 DMA 内存地址范围可能是有限的，这可能是由于制造商或历史原因。例如，一些设备可能只支持地址的低
    24 位。这一限制源于 ISA 总线，ISA 总线是 24 位宽，并且 DMA 缓冲区只能位于系统内存的底部 16 MB 区域。
- en: Nevertheless, you can use the concept of a DMA mask to inform the kernel of
    such limitations, which aims to inform the kernel of your device's DMA addressing
    capabilities.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用 DMA 掩码的概念来告知内核这种限制，目的是通知内核你的设备的 DMA 地址能力。
- en: 'This can be achieved using `dma_set_mask_and_coherent()`, which has the following
    prototype:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`dma_set_mask_and_coherent()`来实现，其原型如下：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding function will set the same mask for both streaming mappings and
    coherent mappings given that the DMA API guarantees that the coherent DMA mask
    can be set to the same or smaller than the streaming DMA mask.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数会为流式映射和一致性映射设置相同的掩码，因为 DMA API 保证一致性 DMA 掩码可以设置为与流式 DMA 掩码相同或更小。
- en: 'However, for special requirements, you can use either `dma_set_mask()` or `dma_set_coherent_mask()`
    to set the mask accordingly. These APIs have the following prototypes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于特殊需求，你可以使用`dma_set_mask()`或`dma_set_coherent_mask()`来相应地设置掩码。这些 API 的原型如下：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In these functions, `dev` is the underlying device structure, while `mask` is
    a bit mask describing which bits of an address your device supports, which you
    can specify using the `DMA_BIT_MASK` macro along with the actual bit order.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些函数中，`dev`是底层设备结构，而`mask`是描述设备支持的地址位的位掩码，可以使用`DMA_BIT_MASK`宏和实际的位顺序来指定。
- en: Both `dma_set_mask()` and `dma_set_coherent_mask()` return zero to indicate
    that the device can perform DMA properly on the machine given the address mask
    specified. Any other return value would be an error, meaning that the given mask
    is too small to be supportable on the given system. In such a failure case, you
    can either fall back to non-DMA mode for data transfer in your driver or, if the
    DMA was mandatory, simply disable the feature in the device that required support
    for DMA or even not probe the device at all.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma_set_mask()`和`dma_set_coherent_mask()`都返回零，表示在给定的地址掩码下，设备可以在机器上正确执行 DMA。任何其他返回值都表示错误，意味着给定的掩码太小，无法在该系统上支持。在这种失败的情况下，你可以在驱动程序中回退到非
    DMA 模式进行数据传输，或者如果 DMA 是强制性的，直接禁用设备中需要 DMA 支持的功能，甚至完全不探测该设备。'
- en: 'It is recommended that your driver prints a kernel warning (`dev_warn()` or
    `pr_warn()`) message when setting the DMA mask fails. The following is an example
    of pseudo-code for a sound card:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 DMA 掩码失败时，建议驱动程序打印内核警告（`dev_warn()` 或 `pr_warn()`）消息。以下是一个声卡的伪代码示例：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we have used the `DMA_BIT_MASK` macro to define the
    DMA mask. Then, we have disabled the features for which DMA support was mandatory
    when the required DMA mask was not supported. In either case, a warning is printed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `DMA_BIT_MASK` 宏来定义 DMA 掩码。然后，当所需的 DMA 掩码不被支持时，我们禁用了必须支持 DMA 的功能。在任何情况下，都会打印警告。
- en: Requesting a DMA channel
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求 DMA 通道
- en: 'A channel is requested using `dma_request_channel()`. Its prototype is as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `dma_request_channel()` 请求一个通道。它的原型如下：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding, the mask must be a bit mask that represents the capabilities
    the channel must satisfy. It is essentially used to specify the type of transfer
    the driver needs to perform, which must be supported in `dma_device.cap_mask`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，掩码必须是一个位掩码，表示通道必须满足的能力。它本质上用于指定驱动程序需要执行的传输类型，该类型必须在 `dma_device.cap_mask`
    中得到支持。
- en: 'The `dma_cap_zero()` and `dma_cap_set()` functions are used to clear the mask
    and set the capability we need; for example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma_cap_zero()` 和 `dma_cap_set()` 函数用于清除掩码并设置所需的能力；例如：'
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`fn` is a callback pointer whose type has the following definition:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`fn` 是一个回调指针，其类型具有以下定义：'
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Actually, `dma_requaest_channel()` walks through the available DMA controllers
    in the system (`dma_device_list`, defined in `drivers/dma/dmaengine.c`) and for
    each of them, it looks for a channel that corresponds to the request. If the `filter_fn`
    parameter (which is optional) is `NULL`, `dma_request_channel()` will simply return
    the first channel that satisfies the capability mask. Otherwise, when the mask
    parameter is insufficient for specifying the necessary channel, you can use the
    `filter_fn` routine as a filter so that each available channel in the system will
    be given to this callback for acceptance or not. The kernel calls the `filter_fn`
    routine once for each free channel in the system. Upon seeing a suitable channel,
    `filter_fn` should return `DMA_ACK`, which will tag the given channel to be the
    return value from `dma_request_channel()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`dma_request_channel()` 会遍历系统中可用的 DMA 控制器（`dma_device_list`，定义在 `drivers/dma/dmaengine.c`
    中），并为每个控制器查找与请求匹配的通道。如果 `filter_fn` 参数（可选）为 `NULL`，则 `dma_request_channel()` 会直接返回第一个满足能力掩码的通道。否则，当掩码参数不足以指定所需的通道时，可以使用
    `filter_fn` 例程作为过滤器，这样系统中的每个可用通道都会被传递给此回调函数，以供接受与否。内核会为系统中每个空闲的通道调用一次 `filter_fn`
    例程。当发现合适的通道时，`filter_fn` 应返回 `DMA_ACK`，这将标记给定的通道为 `dma_request_channel()` 的返回值。
- en: 'A channel allocated through this interface is exclusive to the caller until
    `dma_release_channel()` is called. It has the following definition:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此接口分配的通道在调用 `dma_release_channel()` 之前是独占的。其定义如下：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This API releases the DMA channel and makes it available for request by other
    clients.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 释放 DMA 通道并使其可以被其他客户端请求。
- en: 'By way of additional information, available DMA channels on a system can be
    listed in user space using the `ls /sys/class/dma/` command as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加信息，可以使用 `ls /sys/class/dma/` 命令在用户空间列出系统中可用的 DMA 通道，如下所示：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding snippet, the `chan<chan-index>` channel name is concatenated
    with the DMA controller, `dma<dma-index>`, to which it belongs. Whether a channel
    is in use or not can be seen by printing the `in_use` file value in the corresponding
    channel directory as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`chan<chan-index>` 通道名称与其所属的 DMA 控制器 `dma<dma-index>` 连接。通过打印相应通道目录中的
    `in_use` 文件值，可以查看一个通道是否正在使用，如下所示：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding, we can see, for example, that `dma0chan1` is in use, while
    `dma0chan6` is not.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到，`dma0chan1` 正在使用中，而 `dma0chan6` 并未使用。
- en: Configuring the DMA channel
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 DMA 通道
- en: 'For the DMA transfer to operate normally on a channel, a client-specific configuration
    must be applied to this channel. Thereby, the DMA engine framework allows this
    configuration by using a `struct dma_slave_config` data structure, which represents
    the runtime configuration of a DMA channel. This allows clients to specify parameters
    such as the DMA direction, DMA addresses (source and destination), bus width,
    and DMA burst lengths, for the peripheral. This configuration is then applied
    to the underlying hardware using the `dmaengine_slave_config()` function, which
    is defined as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让DMA传输在通道上正常工作，必须对该通道应用特定客户端的配置。因此，DMA引擎框架通过使用`struct dma_slave_config`数据结构来允许此配置，该结构表示DMA通道的运行时配置。这使得客户端能够指定例如DMA方向、DMA地址（源和目标）、总线宽度和DMA突发长度等参数，以适应外设。然后，这一配置通过`dmaengine_slave_config()`函数应用于底层硬件，函数定义如下：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `chan` parameter represents the DMA channel to configure, and `config` is
    the configuration to be applied.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`chan`参数表示要配置的DMA通道，而`config`是要应用的配置。'
- en: 'To better fine-tune this configuration, we must look at the `struct dma_slave_config`
    structure, which is defined as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地微调这个配置，我们需要查看定义如下的`struct dma_slave_config`结构：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here is the meaning of each element in the structure:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是结构体中每个元素的含义：
- en: '`direction` indicates whether the data should go in or out on this slave channel,
    right now. The possible values are as follows:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`指示数据是否应在此从设备通道中流入或流出。目前的可能值如下：'
- en: '[PRE35]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`src_addr`: This is the physical address (the bus address actually) of the
    buffer where the DMA slave data should be read (RX). This element is ignored if
    the source is memory. `dst_addr` is the physical address (the bus address) of
    the buffer where the DMA slave data should be written (TX), which is ignored if
    the source is memory. `src_addr_width` is the width in bytes of the source (RX)
    register where the DMA data should be read. If the source is memory, this may
    be ignored depending on the architecture. In the same manner, `dst_addr_width`
    is the same as `src_addr_width`, but for the destination target (TX).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_addr`：这是DMA从设备读取数据的缓冲区的物理地址（实际上是总线地址）。如果源是内存，则此元素会被忽略。`dst_addr`是DMA将数据写入的缓冲区的物理地址（总线地址），如果源是内存，则会被忽略。`src_addr_width`是源（RX）寄存器的宽度，以字节为单位，DMA数据应从中读取。如果源是内存，具体是否适用将取决于架构。同样，`dst_addr_width`与`src_addr_width`相同，但用于目标（TX）。'
- en: 'Any bus width must be one of the following enumerations:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 任何总线宽度必须是以下枚举值之一：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`src_maxburs`: This is the maximum number of words that can be sent to the
    device in a single burst (consider words as units of the `src_addr_width` member,
    not bytes). On I/O peripherals, typically half the FIFO depth is used so that
    it does not overflow. On memory sources, this may or may not be applicable. `dst_maxburst`
    is similar to `src_maxburst`, but it is used for the destination target.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_maxburs`：这是可以在单个突发中发送到设备的最大字数（将字视为`src_addr_width`成员的单位，而不是字节）。在I/O外设上，通常使用FIFO深度的一半，以防溢出。在内存源上，这可能适用，也可能不适用。`dst_maxburst`与`src_maxburst`类似，但它用于目标设备。'
- en: 'The following is an example of DMA channel configuration:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是DMA通道配置的示例：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding excerpt, `dma_request_channel()` is used to request a DMA channel,
    which is then configured using `dmaengine_slave_config()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`dma_request_channel()`被用来请求一个DMA通道，接着通过`dmaengine_slave_config()`对其进行配置。
- en: Configuring the DMA transfer
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置DMA传输
- en: This step allows the type of transfer to be defined. A DMA transfer is configured
    (or should we say prepared) thanks to one of the `device_prep_dma_*` callbacks
    of the controller associated with the DMA channel to which the transfer will be
    submitted. Each of these APIs returns a transfer descriptor, represented by the
    `struct dma_async_tx_descriptor` data structure, which can be used later for customization
    before submitting the transfer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步允许定义传输的类型。通过与DMA通道关联的控制器的`device_prep_dma_*`回调函数来配置（或者说准备）DMA传输。每个这些API返回一个传输描述符，表示为`struct
    dma_async_tx_descriptor`数据结构，可以在稍后提交传输之前用于定制。
- en: 'For a memory-to-memory transfer, for example, you should be using the `device_prep_dma_memcpy`
    callback, as in the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存到内存的传输，例如，你应该使用`device_prep_dma_memcpy`回调函数，如以下代码所示：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code sample, we dereference the controller callback for invocation
    while we could have checked for its existence first. However, for sanity and portability
    reasons, it is recommended to use the `dmaengine_prep_*` DMA engine APIs instead
    of invoking the controller callback directly. Our `tx_desc` assignation will then
    have the following form:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们直接调用了控制器回调，虽然我们本可以先检查其是否存在。然而，出于合理性和可移植性考虑，建议使用 `dmaengine_prep_*`
    DMA 引擎 API，而不是直接调用控制器回调。我们的 `tx_desc` 赋值将具有以下形式：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This last approach is safer and portable regarding the controller data structure
    that may be subject to changes.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在涉及可能发生变化的控制器数据结构时更安全且具有可移植性。
- en: Additionally, the client driver can use the `callback` element of the `dma_async_tx_descriptor`
    structure (returned by the `dmaengine_prep_*` function) to supply a completion
    callback.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，客户端驱动可以使用 `dma_async_tx_descriptor` 结构的 `callback` 元素（由 `dmaengine_prep_*`
    函数返回）来提供完成回调。
- en: Submitting the DMA transfer
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交 DMA 传输
- en: 'To put the transaction in the driver pending queue, `dmaengine_submit()` is
    used, which has the following prototype:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将事务放入驱动程序待处理队列中，使用 `dmaengine_submit()`，它具有以下原型：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This API is the frontend of the controller''s `device_issue_pending` callback.
    This function returns a cookie that you can use to check the progression of DMA
    activity through other DMA engines. To check whether the returned cookie is valid,
    you can use the `dma_submit_error()` helper, as we will see in the example. Assuming
    the completion callback has not yet been provided, it can be set up before submitting
    the transfer, as in the following excerpt:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 API 是控制器 `device_issue_pending` 回调的前端。此函数返回一个 cookie，你可以使用它来通过其他 DMA 引擎检查
    DMA 活动的进展。为了检查返回的 cookie 是否有效，你可以使用 `dma_submit_error()` 辅助函数，正如我们在示例中将看到的那样。如果尚未提供完成回调，可以在提交传输之前进行设置，如下摘录所示：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding excerpt is quite short and self-explanatory. For a parameter to
    be passed to the callback, it must be set in the descriptor's `callback_param`
    field. It can be a device state structure, for example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的摘录非常简短且易于理解。要传递给回调的参数必须设置在描述符的 `callback_param` 字段中。它可以是一个设备状态结构，例如。
- en: Note
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An interrupt (from the DMA controller) is raised after each DMA transfer has
    been completed, after which the next transfer in the queue is initiated and a
    tasklet is activated. If the client driver has provided a completion callback,
    the tasklet will call it when it is scheduled. Thus, the completion callback runs
    in an interrupt context.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 DMA 传输完成后，DMA 控制器会产生一个中断，之后队列中的下一个传输将被启动，并激活一个任务。若客户端驱动提供了完成回调，则当任务被调度时，任务将调用该回调。因此，完成回调在中断上下文中运行。
- en: Issuing pending DMA requests and waiting for callback notification
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发起待处理的 DMA 请求并等待回调通知
- en: 'Starting the transaction is the last step of the DMA transfer setup. Transactions
    in the pending queue of a channel are activated by calling `dma_async_issue_pending()`
    on that channel. If the channel is idle, then the first transaction in the queue
    is started and subsequent ones are queued up. Upon completion of a DMA operation,
    the next one in the queue is started and a tasklet triggered. This tasklet is
    in charge of calling the client driver completion callback routine for notification,
    if set:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 启动事务是 DMA 传输设置的最后一步。通过调用 `dma_async_issue_pending()` 在该通道上激活待处理队列中的事务。如果通道空闲，则队列中的第一个事务将被启动，随后的事务将排队。DMA
    操作完成后，下一个事务会启动，并触发任务。该任务负责在设置了回调的情况下调用客户端驱动的完成回调例程以进行通知：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This function is a wrapper around the controller''s `device_issue_pending`
    callback. An example of its usage would look like the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是控制器 `device_issue_pending` 回调的封装。其用法示例如下所示：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `wait_for_completion()` function will block, putting the current task to
    sleep until our DMA callback gets called to update (complete) our completion variable
    in order to resume the blocked code. It is a good alternative to `while (!done)
    msleep(SOME_TIME);`. The following is an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_for_completion()` 函数会阻塞，将当前任务挂起，直到我们的 DMA 回调被调用，更新（完成）我们的完成变量，以便恢复被阻塞的代码。这是
    `while (!done) msleep(SOME_TIME);` 的一个很好的替代方案。以下是一个示例：'
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is all in our DMA transfer implementation. When the completion callback
    returns, the main code will resume and continue its normal workflow.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都在我们的 DMA 传输实现中。当完成回调返回时，主代码将恢复并继续正常工作流程。
- en: Now that we have gone through the DMA engine APIs, we can summarize the knowledge
    in a complete example, as we see in the next section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 经过DMA引擎API的讲解后，我们可以通过一个完整的示例来总结这些知识，如下节所示。
- en: Putting it all together – Single-buffer DMA mapping
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容汇集在一起——单缓冲区DMA映射
- en: Let's consider the following case where we would like to map a single buffer
    (streaming mapping) and DMA data from the source, `src`, to the destination, `dst`.
    We will use a character device so that any write operation in this device will
    trig the DMA and any read operation will compare both the source and destination
    to check whether they match.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望映射一个单一缓冲区（流式映射），并将数据从源`src`通过DMA传输到目标`dst`。我们将使用一个字符设备，这样在该设备中进行任何写操作时都会触发DMA，而任何读操作都会对比源和目标是否匹配。
- en: 'First, let''s enumerate the header files required to pull the necessary APIs:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们列出所需的头文件以便调用必要的API：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now define some global variables for the driver:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为驱动程序定义一些全局变量：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding, `wbuf` represents the source buffer, and `rbuf` represents
    the destination buffer. Since our implementation is based on a character device,
    `gMajor` and `dma_test_class` are used to represent the major number and the class
    of the character device.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`wbuf`代表源缓冲区，`rbuf`代表目标缓冲区。由于我们的实现是基于字符设备的，`gMajor`和`dma_test_class`用于表示字符设备的主设备号和类别。
- en: 'Because DMA mappings need to be given a device structure as the first parameter,
    let''s create a dummy one:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DMA映射需要提供设备结构作为第一个参数，我们来创建一个虚拟的设备结构：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Because we have used a static device, we set the device's DMA mask in the device
    structure. In a platform driver, we would have used `dma_set_mask_and_coherent()`
    to achieve that.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是静态设备，我们在设备结构中设置了设备的DMA掩码。在平台驱动中，我们会使用`dma_set_mask_and_coherent()`来实现这一点。
- en: 'The time has come to implement our first file operation, the `open` method,
    which in our case, simply allocates buffers:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实现我们第一个文件操作——`open`方法的时候了，在我们的案例中，这个方法只是简单地分配缓冲区：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding character device''s open operation does nothing other than allocate
    the buffer that will be used for our transfer. These buffers will be freed when
    the device file is closed, which will result in invoking our device''s release
    function, implemented as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的字符设备的`open`操作除了分配将用于我们传输的缓冲区外，什么也不做。这些缓冲区将在设备文件关闭时被释放，这将导致调用我们设备的释放函数，具体实现如下：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We arrive at the implementation of the `read` method. This method will simply
    add an entry to the kernel message buffer, reporting the result of the DMA operation.
    It is implemented as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了`read`方法的实现。这个方法将简单地向内核消息缓冲区添加一条记录，报告DMA操作的结果。它的实现如下：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now comes the DMA-related part. We first implement the completion callback,
    which does nothing other than invoke `complete()` on our completion structure
    and add a trace in the kernel log buffer. It is implemented as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入与DMA相关的部分。我们首先实现完成回调，这个回调仅仅是调用`complete()`函数在我们的完成结构上，并在内核日志缓冲区中添加一条跟踪信息。其实现如下：
- en: '[PRE51]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The choice has been made to implement all the DMA logic in the write method.
    There is no technical reason behind this choice. A user is free to adapt the code
    architecture, based on the following implementation:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定在`write`方法中实现所有的DMA逻辑。做出这个选择没有技术上的原因。用户可以根据以下实现自由地调整代码架构：
- en: '[PRE52]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding, there are variables we will require in order to perform our
    memory-to-memory DMA transfer.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有些变量是我们执行内存到内存DMA传输时需要的。
- en: 'Now that our variables are defined, we initialize the source buffer with some
    content that will later be copied to the destination with the DMA operation:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的变量已经定义好了，我们就用一些内容初始化源缓冲区，这些内容稍后会通过DMA操作被复制到目标缓冲区：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The source buffer is ready, and we can now start the DMA-related code. At this
    first step, we initialize capabilities and request a DMA channel:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 源缓冲区已经准备好，我们现在可以开始与DMA相关的代码。在第一步中，我们初始化能力并请求一个DMA通道：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding, the channel could have also registered with `dma_m2m_chan
    = dma_request_chan_by_mask(&dma_m2m_mask);`. The advantage of using this method
    is that only the mask has to be specified in a parameter, and the driver need
    not bother with other arguments.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，通道也可以通过`dma_m2m_chan = dma_request_chan_by_mask(&dma_m2m_mask);`来注册。使用这种方法的好处是，只需要在参数中指定掩码，驱动程序就不需要关心其他参数。
- en: 'In the second step, we set slave- and controller-specific parameters, and then
    we create the mappings for both source and destination buffers:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们设置从设备和控制器特定的参数，然后为源缓冲区和目标缓冲区创建映射：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In the third step, we grab a descriptor for the transaction:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们获取事务的描述符：
- en: '[PRE56]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Calling `dmaengine_prep_dma_memcpy()` results in invoking `dma_m2m_chan->device->device_prep_dma_memcpy()`.
    It is, however, recommended to use the DMA engine method since it is more portable.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`dmaengine_prep_dma_memcpy()`会触发`dma_m2m_chan->device->device_prep_dma_memcpy()`。然而，建议使用DMA引擎方法，因为它更加便携。
- en: 'In the fourth step, we submit the DMA transaction:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步中，我们提交DMA事务：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that the transaction has been submitted, we can move to the fifth and final
    step, where we issue pending DMA requests and wait for callback notification:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在事务已被提交，我们可以进入第五步，也是最后一步，我们发起待处理的DMA请求，并等待回调通知：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At this point in the code, the DMA transaction has run until completion, and
    we can check whether source and destination buffers have the same content. However,
    before accessing the buffers, they must be synced; luckily, the unmapping methods
    perform an implicit buffer sync:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这一点，DMA事务已经完成，我们可以检查源缓冲区和目标缓冲区是否具有相同的内容。然而，在访问缓冲区之前，它们必须先同步；幸运的是，解除映射方法会隐式执行缓冲区同步：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding write operation, we have gone through the five steps required
    to perform our DMA transfer: requesting a DMA channel; configuring this channel;
    preparing a DMA transfer; submitting this transfer; and then triggering the transfer
    providing a completion callback in the meantime.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的写操作中，我们经历了执行DMA传输所需的五个步骤：请求DMA通道；配置该通道；准备DMA传输；提交该传输；然后触发传输并在此过程中提供完成回调。
- en: 'After we are done with operation definitions, we can set up a file operation
    data structure as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 完成操作定义后，我们可以设置文件操作数据结构，具体如下：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that the file operation has been set up, we can implement the module''s
    `init` function, where we create and register the character device as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件操作已设置完成，我们可以实现模块的`init`函数，在其中创建并注册字符设备，具体如下：
- en: '[PRE61]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The module initialization will create and register a character device. This
    operation must be reverted when the module is unloaded, that is, in the module''s
    `exit` method, implemented as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 模块初始化将创建并注册一个字符设备。当模块卸载时，必须撤销此操作，即在模块的`exit`方法中，具体实现如下：
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At this point, we can register our module''s init and exit methods with the
    driver core and provide metadata for our module. This is done as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以将模块的初始化和退出方法注册到驱动核心，并为模块提供元数据。操作步骤如下：
- en: '[PRE63]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The full code is available in the repository of the book in the `chapter-12/`
    directory.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在书籍的仓库中找到，位于`chapter-12/`目录下。
- en: Now that we are familiar with the DMA engine APIs and have summarized our skills
    in a concrete example, we can discuss a particular DMA transfer, the Cyclic DMA,
    mostly used in UART drivers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了DMA引擎API，并通过具体示例总结了我们的技能，我们可以讨论一种特定的DMA传输模式——循环DMA，它主要用于UART驱动程序。
- en: A word on cyclic DMA
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于循环DMA
- en: 'Cyclic mode is a particular DMA transfer mode where an I/O peripheral drives
    the data transaction, triggering transfers repeatedly on a periodic basis. While
    dealing with callbacks that the DMA controller can expose, we have seen `dma_device.device_prep_dma_cyclic`,
    which is the backend for `dmaengine_prep_dma_cyclic()`, which has the following
    prototype:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 循环模式是一种特殊的DMA传输模式，在这种模式下，I/O外设驱动数据事务，定期触发数据传输。在处理DMA控制器可能暴露的回调时，我们看到了`dma_device.device_prep_dma_cyclic`，它是`dmaengine_prep_dma_cyclic()`的后端，具有以下原型：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding API takes in five parameters: `chan`, which is the allocated
    DMA channel structure; `buf_addr`, the handle to the mapped DMA buffer; `buf_len`,
    which is the size of the DMA buffer; `period_len`, the size of one cyclic period;
    `dir`, the direction of the DMA transfer; and `flags`, the control flags for this
    transfer. In the event of success, this function returns a DMA channel descriptor
    structure, which can be used to assign a completion function to the DMA transfer.
    Most of the time, `flags` correspond to `DMA_PREP_INTERRUPT`, which means that
    the DMA transfer callback should be invoked upon each cycle completion.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 API 接受五个参数：`chan`，分配的 DMA 通道结构；`buf_addr`，映射的 DMA 缓冲区的句柄；`buf_len`，DMA 缓冲区的大小；`period_len`，一个循环周期的大小；`dir`，DMA
    传输的方向；`flags`，此传输的控制标志。如果成功，该函数返回一个 DMA 通道描述符结构，可用于为 DMA 传输分配完成函数。大多数情况下，`flags`
    对应于 `DMA_PREP_INTERRUPT`，这意味着每次周期完成时都应调用 DMA 传输回调函数。
- en: Cyclic mode is mostly used in TTY drivers, where the data is fed into a **First
    In First Out** (**FIFO**) ring buffer. In this mode, the allocated DMA buffer
    is divided into periods equal in size (often referenced as cyclic periods) so
    that every time one such transfer is finished, the callback function is invoked.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 循环模式主要用于 TTY 驱动程序，其中数据被输入到一个**先进先出**（**FIFO**）环形缓冲区。在这种模式下，分配的 DMA 缓冲区被划分为大小相等的周期（通常称为循环周期），以便每次完成一次传输时，回调函数都会被调用。
- en: 'The callback function that has been implemented is used to keep track of the
    state of the ring buffer and buffer management is implemented using the kernel
    ring buffer API (so you need to include `<linux/circ_buf.h>`):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的回调函数用于跟踪环形缓冲区的状态，缓冲区管理则使用内核环形缓冲区 API 实现（因此需要包含 `<linux/circ_buf.h>`）：
- en: '![Figure 11.3 – Cyclic DMA ring buffer'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 循环 DMA 环形缓冲区'
- en: '](img/B17934_11_003.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_11_003.jpg)'
- en: Figure 11.3 – Cyclic DMA ring buffer
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 循环 DMA 环形缓冲区
- en: The following is an example from the Atmel serial driver in `drivers/tty/serial/atmel_serial.c`,
    which demonstrates this principle of cyclic DMA quite well.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `drivers/tty/serial/atmel_serial.c` 中的一个例子，展示了循环 DMA 的原理。
- en: 'The driver first prepares the DMA resources as in the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序首先准备 DMA 资源，具体如下：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: For the sake of readability, error checking has been omitted. The function starts
    by setting the appropriate DMA capability mask (using `dma_set_cap()`) before
    requesting the DMA channel. After the channel has been requested, the mapping
    (a streaming one) is created and the channel is configured using `dmaengine_slave_config()`.
    Thereafter, a cyclic DMA transfer descriptor is obtained thanks to `dmaengine_prep_dma_cyclic()`
    and `DMA_PREP_INTERRUPT` is there to instruct the DMA engine core to invoke the
    callback at the end of each cycle transfer. The descriptor obtained is then configured
    with the callback along with its parameter before being submitted to the DMA controller
    using `dmaengine_submit()` and fired with `dma_async_issue_pending()`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，省略了错误检查。该函数首先设置适当的 DMA 能力掩码（使用 `dma_set_cap()`），然后请求 DMA 通道。请求通道后，创建映射（一个流式映射），并使用
    `dmaengine_slave_config()` 配置通道。随后，通过 `dmaengine_prep_dma_cyclic()` 获取一个循环 DMA
    传输描述符，`DMA_PREP_INTERRUPT` 用于指示 DMA 引擎核心在每个周期的传输结束时调用回调函数。获取的描述符在提交给 DMA 控制器之前，会与回调函数及其参数一起配置，并通过
    `dmaengine_submit()` 提交，并通过 `dma_async_issue_pending()` 激活。
- en: 'The `atmel_complete_rx_dma()` callback will schedule a tasklet whose handler
    is `atmel_tasklet_rx_func()` and which will invoke the real DMA completion callback,
    `atmel_rx_from_dma()`, implemented as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`atmel_complete_rx_dma()` 回调将调度一个任务，该任务的处理函数是 `atmel_tasklet_rx_func()`，它将调用真正的
    DMA 完成回调 `atmel_rx_from_dma()`，实现如下：'
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the DMA completion callback, we can see that before the buffer is being accessed
    by the CPU, `dma_sync_sg_for_cpu()` is invoked to invalidate the corresponding
    hardware cache lines. Then, some ring buffers and TTY-related operations are performed
    (respectively, reading the received data and forwarding it to the TTY layer).
    And finally, the buffer is given back to the device after `dma_sync_sg_for_device()`
    is invoked.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DMA 完成回调中，我们可以看到，在 CPU 访问缓冲区之前，调用了 `dma_sync_sg_for_cpu()` 来使相应的硬件缓存行无效。然后，执行一些环形缓冲区和
    TTY 相关的操作（分别是读取接收到的数据并将其转发到 TTY 层）。最后，在调用 `dma_sync_sg_for_device()` 后，缓冲区被归还给设备。
- en: To summarize, the preceding example did not only show how cyclic DMA works but
    also showed how to address coherency issues when the buffer is used and reused
    between transfers, either by the CPU or the device.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，前面的示例不仅展示了循环 DMA 的工作原理，还展示了如何在传输之间（无论是 CPU 还是设备使用和重用缓冲区时）解决一致性问题。
- en: Now that we are familiar with the cyclic DMA, we have concluded our series on
    DMA transfer and DMA engine APIs. We have learned how to set up transfers, initiate
    them, and await their completion.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了循环 DMA，我们已完成关于 DMA 传输和 DMA 引擎 API 的系列内容。我们学会了如何设置传输、启动它们，并等待它们完成。
- en: In the next section, we will learn how to specify and grab DMA channels from
    the device tree and the code.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何从设备树和代码中指定和获取 DMA 通道。
- en: Understanding DMA and DT bindings
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DMA 和 DT 绑定
- en: DT binding for the DMA channel depends on the DMA controller node, which is
    SoC-dependent, and some parameters (such as DMA cells) may vary from one SoC to
    another. This example only focuses on the i.MX SDMA controller, which can be found
    in the kernel source, at `Documentation/devicetree/bindings/dma/fsl-imx-sdma.txt`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 通道的 DT 绑定依赖于 DMA 控制器节点，这与 SoC 相关，并且某些参数（如 DMA 单元）可能因 SoC 的不同而有所变化。本示例仅关注
    i.MX SDMA 控制器，可以在内核源代码中找到，路径为 `Documentation/devicetree/bindings/dma/fsl-imx-sdma.txt`。
- en: Consumer binding
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者绑定
- en: 'According to the SDMA event-mapping table, the following code shows the DMA
    request signals for peripherals in i.MX 6Dual/6Quad:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 SDMA 事件映射表，以下代码展示了 i.MX 6Dual/6Quad 中外设的 DMA 请求信号：
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The second cells (25 and 26) in the `dma` property correspond to the DMA request/event
    ID. Those values come from the SoC manuals (i.MX53 in our case). You can have
    a look at [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf)
    and the Linux reference manual at [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma` 属性中的第二个单元（25 和 26）对应于 DMA 请求/事件 ID。这些值来自 SoC 手册（在我们的例子中是 i.MX53）。你可以查看
    [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf)
    和 Linux 参考手册 [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf)。'
- en: 'The third cell indicates the priority of use. The driver code to request a
    specified parameter is defined next. You can find the complete code in `drivers/tty/serial/imx.c`
    in the kernel source tree. The following is the excerpt of the code grabbing elements
    from the device tree:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个单元表示使用优先级。请求指定参数的驱动代码在接下来的部分中定义。你可以在内核源代码树中的 `drivers/tty/serial/imx.c` 文件中找到完整的代码。以下是从设备树中抓取元素的代码摘录：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The magic call here is `dma_request_slave_channel()`, which will parse the device
    node (in the DT) using `of_dma_request_slave_channel()` to gather channel settings,
    according to the DMA channel name (refer to the named resource in [*Chapter 6*](B17934_06_Epub.xhtml#_idTextAnchor095),
    *Understanding and Leveraging the Device Tree*).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键调用是 `dma_request_slave_channel()`，它将使用 `of_dma_request_slave_channel()`
    解析设备节点（在 DT 中），根据 DMA 通道名称收集通道设置（参考 [*第六章*](B17934_06_Epub.xhtml#_idTextAnchor095)，*理解和利用设备树*）。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: DMA is a feature that is found in many modern CPUs. This chapter gives you the
    necessary steps to get the most out of this device, using the kernel DMA mapping
    and DMA engine APIs. After this chapter, I have no doubt you will be able to set
    up at least a memory-to-memory DMA transfer. Further information can be found
    at `Documentation/dmaengine/`, in the kernel source tree.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 是许多现代 CPU 中都具备的特性。本章将为你提供必要的步骤，帮助你充分利用该设备，使用内核 DMA 映射和 DMA 引擎 API。在本章结束后，我确信你将能够设置至少一个内存到内存的
    DMA 传输。更多信息可以在 `Documentation/dmaengine/` 中找到，位于内核源代码树中。
- en: However, the next chapter deals with the regmap, which introduces memory-oriented
    abstractions, and which unify access to memory-oriented devices (I2C, SPI, or
    memory-mapped).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下一章将讨论 regmap，它引入了面向内存的抽象，并统一了对面向内存设备（如 I2C、SPI 或内存映射设备）的访问。
