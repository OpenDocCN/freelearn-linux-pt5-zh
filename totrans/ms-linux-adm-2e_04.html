<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-75"><a id="_idTextAnchor090"/>4</h1>
<h1 id="_idParaDest-76"><a id="_idTextAnchor091"/>Managing Users and Groups</h1>
<p>Linux is a multiuser, multitasking operating system, which means multiple users can access the operating system at the same time while sharing platform resources, with the kernel performing tasks for each user concurrently and independently. Linux provides the required isolation and security mechanisms to avoid multiple users accessing or deleting each other’s files.</p>
<p>When multiple users are accessing the system, permissions come into play. We’ll learn how <code>root</code>) account, with complete access to the operating system resources.</p>
<p>Along the way, we’ll take a hands-on approach to the topics learned, further deepening the assimilation of key concepts through practical examples. This chapter covers the following topics:</p>
<ul>
<li>Managing users</li>
<li>Managing groups</li>
<li>Managing permissions</li>
</ul>
<p>We hope that by the end of the chapter, you will be comfortable with the command-line utilities for creating, modifying, and deleting users and groups, while proficiently handling file and directory permissions.</p>
<p>Let’s take a quick look at the technical requirements for this chapter.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor092"/>Technical requirements</h1>
<p>You need a working Linux distribution installed on either a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) or a desktop platform. In case you don’t have one already, <a href="B19682_01.xhtml#_idTextAnchor030"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing Linux</em>, will drive you through the related process. In this chapter, we’ll be using Ubuntu or Fedora, but most of the commands and examples used would pertain to any other Linux platform.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor093"/>Managing users</h1>
<p>In this context, a <strong class="bold">user</strong> is anyone<a id="_idIndexMarker452"/> using a computer or a system resource. In its simplest form, a Linux <em class="italic">user</em> or <em class="italic">user account</em> is identified by a name and a <strong class="bold">unique identifier</strong>, known<a id="_idIndexMarker453"/> as a <strong class="bold">UID</strong>.</p>
<p>From a purely technical point of view, in Linux, we have the following types of users:</p>
<ul>
<li><strong class="bold">Normal (or regular) users</strong>: General-purpose, everyday user accounts, mostly suited for personal use<a id="_idIndexMarker454"/> and for common application and file management tasks, with limited access<a id="_idIndexMarker455"/> to system-wide resources. A regular user account usually has a <em class="italic">login</em> shell and a <em class="italic">home</em> directory.</li>
<li><code>root</code> privileges. Consequently, possible vulnerabilities exposed through the web server would remain strictly isolated to the limited action realm of the associated system account.</li>
<li><code>root</code> user is an example of a superuser.</li>
</ul>
<p>In Linux, only the <code>root</code> user or<a id="_idIndexMarker460"/> users with <code>sudo</code> privileges (<strong class="bold">sudoers</strong>) can create, modify, or delete user accounts.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor094"/>Understanding sudo</h2>
<p>The <code>root</code> user is the default <a id="_idIndexMarker461"/>superuser account in Linux, and it has the ability to do anything on a system. Ideally, acting<a id="_idIndexMarker462"/> as <code>root</code> on a system should generally be avoided due to safety and security reasons. With <code>sudo</code>, Linux provides a mechanism for <em class="italic">promoting</em> a regular user account to superuser privileges, using an additional layer of security. This way, a <code>sudo</code> user is generally used instead of <code>root</code>.</p>
<p><code>sudo</code> is a command-line utility that <a id="_idIndexMarker463"/>allows a permitted user to execute commands with the security privileges of a superuser or another user (depending on the local system’s security policy). <code>sudo</code> originall<a id="_idTextAnchor095"/>y stood for <em class="italic">superuser do</em> due to its initial implementation of acting exclusively as the superuser, but has since been expanded to support not only the superuser but also other (restricted) user impersonations. Thus, it is also referred to as <em class="italic">substitute user do</em>. Yet, more <a id="_idIndexMarker464"/>often than not, it is perceived as <em class="italic">superuser do</em> due to its frequent <a id="_idIndexMarker465"/>use in Linux administrative tasks.</p>
<p>Most of the <a id="_idIndexMarker466"/>command-line tools for<a id="_idIndexMarker467"/> managing users in Linux require <code>sudo</code> privileges unless the related tasks are carried out by the <code>root</code> user. If we want to avoid using the root context, we can’t genuinely proceed with the rest of this chapter—and create a user in particular—before we have a user account with superuser privileges. So, let’s take this chicken-and-egg scenario out of the way first.</p>
<p>Most Linux distributions create an additional user account with superuser privileges, besides <code>root</code>, during installation. The reason, as noted before, is to provide an extra layer of security and safety for elevated operations. The simplest way to check whether a user account has <code>sudo</code> privileges is to run the following command in a terminal, while logged in with the related user account:</p>
<pre class="source-code">
sudo -v</pre> <p>According to the <code>sudo</code> manual (<code>man sudo</code>), the <code>-v</code> option causes <code>sudo</code> to update the user’s cached credentials and authenticate the user if the cached credentials expired.</p>
<p>If the user (for example, <code>julian</code>) doesn’t have superuser privileges on the local machine (for example, <code>neptune</code>), the preceding command yields the following (or a similar) error:</p>
<pre class="source-code">
Sorry, user <code>sudo</code> command usually grants elevated permissions for a limited time. Ubuntu, for example, has a 15-minute <code>sudo</code> elevation span, after which time a <code>sudo</code> user would need to authenticate again. Subsequent invocations of <code>sudo</code> may not prompt for a password if done within the <code>sudo</code> cache credential timeout.</p>
<p>If we don’t have a default superuser account, we can always use the root context to create new users (see the<a id="_idIndexMarker468"/> next chapter) and elevate them to <strong class="bold">sudoer</strong> privileges. We’ll learn <a id="_idIndexMarker469"/>more about this in the <em class="italic">Creating a superuser</em> section, later in this chapter.</p>
<p>Now, let’s have a look at how to create, modify, and delete users.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor096"/>Creating, modifying, and deleting users</h2>
<p>In this section, we explore a few <a id="_idIndexMarker470"/>command-line tools and some common tasks for managing users. The<a id="_idIndexMarker471"/> example commands and procedures are shown for Ubuntu and Fedora, but the same principles apply to any other Linux distribution. Some user <a id="_idIndexMarker472"/>management <code>useradd</code> is not available on Alpine Linux, and <code>adduser</code> should be used instead). Please<a id="_idIndexMarker473"/> check the documentation of the Linux distribution of your choice for the equivalent commands.</p>
<h3>Creating users</h3>
<p>To create users, we can use<a id="_idIndexMarker474"/> either the <code>useradd</code> or the <code>adduser</code> command, although on some Linux distributions (for example, Debian or Ubuntu), the recommended way is to use the <code>adduser</code> command in favor of the low-level <code>useradd</code> utility. We’ll cover both in this section.</p>
<p><code>adduser</code> is a Perl script using <code>useradd</code>—basically, a shim of the <code>useradd</code> command—with a user-friendly guided configuration. Both command-line tools are installed by default in Ubuntu and Fedora. Let’s take a brief look at each of these commands.</p>
<h4>Creating users with useradd</h4>
<p>The syntax for the <code>useradd</code> command is <a id="_idIndexMarker475"/>shown here:</p>
<pre class="source-code">
useradd [OPTIONS] USER</pre> <p>In its simplest<a id="_idIndexMarker476"/> invocation, the following command creates a user account (<code>julian</code>):</p>
<pre class="source-code">
sudo useradd julian</pre> <p>The user information is stored in a <code>/etc/passwd</code> file. Here’s the related user data for <code>julian</code>:</p>
<pre class="source-code">
sudo cat /etc/passwd | grep julian</pre> <p>In our case, this is the output:</p>
<div><div><img alt="Figure 4.1 – The user record created with useradd" src="img/Figure_04_01_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The user record created with useradd</p>
<p>Let’s analyze the related<a id="_idIndexMarker477"/> user record. Each entry is delimited by<a id="_idIndexMarker478"/> a colon (<code>:</code>) and is listed here:</p>
<ul>
<li><code>julian</code>: Username</li>
<li><code>x</code>: Encrypted password (password hash is stored in <code>/etc/shadow</code>)</li>
<li><code>1001</code>: The UID</li>
<li><code>1001</code>: The user <strong class="bold">group </strong><strong class="bold">ID</strong> (<strong class="bold">GID</strong>)</li>
<li><code>::</code> The <strong class="bold">General Electric Comprehensive Operating Supervisor</strong> (<strong class="bold">GECOS</strong>) field—for example, display<a id="_idIndexMarker479"/> name (in our case, empty), explained later in this section</li>
<li><code>/home/julian</code>: User home folder</li>
<li><code>/bin/sh</code>: Default login shell for the user</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">The GECOS field is a string of comma-delimited attributes, reflecting general information about the user account (for example, real name, company, and phone number). In Linux, the GECOS <a id="_idIndexMarker480"/>field is the fifth field in a user record. See more information at <a href="https://en.wikipedia.org/wiki/Gecos_field">https://en.wikipedia.org/wiki/Gecos_field</a>.</p>
<p>We can also use the <code>getent</code> command to retrieve the preceding user information, as follows:</p>
<pre class="source-code">
getent passwd julian</pre> <p>To view the UID (<code>uid</code>), GID (<code>gid</code>), and group membership associated with a user, we can use the <code>id</code> command, as follows:</p>
<pre class="source-code">
id julian</pre> <p>This command gives us the following output:</p>
<div><div><img alt="Figure 4.2 – The UID information" src="img/Figure_04_02_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The UID information</p>
<p>With the simple invocation of <code>useradd</code>, the command creates the user (<code>julian</code>) with some immediate default values (as enumerated), while other user-related data is empty—for example, we have no full name or password specified for the user yet. Also, while the home directory<a id="_idIndexMarker481"/> has a default value (for example, <code>/home/julian</code>), the actual filesystem folder will not be created unless the <code>useradd</code> command is invoked with the <code>-m</code> or the <code>--create-home</code> option, as follows:</p>
<pre class="source-code">
sudo useradd -m julian</pre> <p>Without a home directory, regular <a id="_idIndexMarker482"/>users would not have the ability to save their files in a private location on the system. On the other hand, some system accounts may not need a home directory since they don’t have a login shell. For example, a database server (for example, PostgreSQL) may run with a non-root system account (for example, <code>postgres</code>) that only needs access to database resources in specific locations (for example, <code>/var/lib/pgsql</code>), controlled via other permission<a id="_idIndexMarker483"/> mechanisms (for example, <strong class="bold">Security-Enhanced </strong><strong class="bold">Linux</strong> (<strong class="bold">SELinux</strong>)).</p>
<p>For our regular user, if we also wanted to specify a full name (display name), the command would change to this:</p>
<pre class="source-code">
sudo useradd -m -c "Julian" julian</pre> <p>The <code>-c, --comment</code> option parameter of <code>useradd</code> expects a <em class="italic">comment</em>, also known as the GECOS field (the fifth field in<a id="_idIndexMarker484"/> our user record), with multiple comma-separated values. In our case, we specify the full name (for example, <code>Julian</code>). For more information, check out the <code>useradd</code> manual (<code>man useradd</code>) or <code>useradd --help</code>.</p>
<p>The user still won’t have a <a id="_idIndexMarker485"/>password yet, and consequently, there would be no way for them to log in (for example, via a <code>julian</code>, we invoke<a id="_idIndexMarker487"/> the <code>passwd</code> command, like this:</p>
<pre class="source-code">
sudo passwd julian</pre> <p>You can see the following output:</p>
<div><div><img alt="Figure 4.3 – Creating or changing the user password" src="img/Figure_04_03_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Creating or changing the user password</p>
<p>The <code>passwd</code> command will <a id="_idIndexMarker488"/>prompt for the new user’s password. With the password set, there will be a new entry added to the <code>/etc/shadow</code> file. This file stores the secure password hashes (not the passwords!) for each user. Only superusers can access the content of this file. Here’s the command to retrieve the related information for the user <code>julian</code>:</p>
<pre class="source-code">
sudo getent shadow julian</pre> <p>You can also use the following command:</p>
<pre class="source-code">
sudo cat /etc/shadow | grep julian</pre> <p>The output of both commands is shown in the following screenshot:</p>
<div><div><img alt="Figure 4.4 – Information about the user from the shadow file" src="img/Figure_04_04_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Information about the user from the shadow file</p>
<p>Once the password has been set, in normal circumstances, the user can log in to the system (via SSH or GUI). If the<a id="_idIndexMarker489"/> Linux distribution has a GUI, the new user will show up on the login screen.</p>
<p>As noted, with the <code>useradd</code> command, <a id="_idIndexMarker490"/>we have low-level granular control over how we create user accounts, but sometimes we may prefer a more user-friendly approach. Enter the <code>adduser</code> command.</p>
<h4>Creating users with adduser</h4>
<p>The <code>adduser</code> command is a<a id="_idIndexMarker491"/> Perl wrapper for <code>useradd</code>. The syntax<a id="_idIndexMarker492"/> for this command is shown here:</p>
<pre class="source-code">
adduser [OPTIONS] USER</pre> <p><code>sudo</code> may prompt for the superuser password. <code>adduser</code> will prompt for the new user’s password and other user-related information (as shown in <em class="italic">Figure 4</em><em class="italic">.5</em>).</p>
<p>Let’s create a new user account (<code>alex</code>) with <code>adduser</code>, as follows:</p>
<pre class="source-code">
sudo adduser alex</pre> <p>The preceding command yields the following output:</p>
<div><div><img alt="Figure 4.5 – The adduser command" src="img/Figure_04_05_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – The adduser command</p>
<p>In Fedora, the preceding invocation of the <code>adduser</code> command will simply run without prompting the <a id="_idIndexMarker493"/>user for a password or any other<a id="_idIndexMarker494"/> information.</p>
<p>We can see the related user entry in <code>/etc/passwd</code> with <code>getent</code>, as follows:</p>
<pre class="source-code">
getent passwd alex</pre> <p>The following is the output:</p>
<div><div><img alt="Figure 4.6 – Viewing user information with getent" src="img/Figure_04_06_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Viewing user information with getent</p>
<p>In the preceding examples, we created a regular user account. Administrators or superusers can also elevate the privileges of a regular user to a superuser. Let’s see how in the following section.</p>
<h3>Creating a superuser</h3>
<p>When a regular user is given the <a id="_idIndexMarker495"/>power to run <code>sudo</code>, they become a superuser. Let’s assume we have a regular user created via any of the examples shown in the <em class="italic">Creating </em><em class="italic">users</em> section.</p>
<p>Promoting the user to a <a id="_idIndexMarker496"/>superuser (or <em class="italic">sudoer</em>) requires a <code>sudo</code> group membership. In Linux, the <code>sudo</code> group is a reserved system group for users with elevated or <code>root</code> privileges. To make the user <code>julian</code> a sudoer, we simply need to add the user to the <code>sudo</code> group, like this (in Ubuntu):</p>
<pre class="source-code">
sudo usermod -aG sudo julian</pre> <p>The <code>-aG</code> options of <code>usermod</code> instruct the command to append (<code>-a, --append</code>) the user to the specified group (<code>-G, --group</code>)—in our case, <code>sudo</code>.</p>
<p>To verify our user is now a sudoer, first make sure the related user information reflects the <code>sudo</code> membership by running the following command:</p>
<pre class="source-code">
id julian</pre> <p>This gives us the following output:</p>
<div><div><img alt="Figure 4.7 – Looking for the sudo membership of a user" src="img/Figure_04_07_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Looking for the sudo membership of a user</p>
<p>The output shows that the <code>sudo</code> group membership (GID) in the <code>groups</code> tag is <code>27(sudo)</code>.</p>
<p>To verify the <code>sudo</code> access for the user <code>julian</code>, run the following command:</p>
<pre class="source-code">
su - julian</pre> <p>The preceding command prompts for the password of the user <code>julian</code>. A successful login would usually validate the superuser context. Alternatively, the user (<code>julian</code>) can run the <code>sudo -v</code> command in their terminal session to validate the <code>sudo</code> privileges. For more information on superuser privileges, see the <em class="italic">Understanding sudo</em> section earlier in the chapter.</p>
<p>With multiple users created, a system administrator may want to view or list all the users in the system. In the next section, we provide a few ways to accomplish this task.</p>
<h4>Viewing users</h4>
<p>There are a few ways for a <a id="_idIndexMarker497"/>superuser to view all users configured in the system. As previously noted, the user information is stored in the <code>/etc/passwd</code> and <code>/etc/shadow</code> files. Besides simply viewing these files, we can parse them and extract only the usernames with the following command:</p>
<pre class="source-code">
cat /etc/passwd | cut -d: -f1 | less</pre> <p>Alternatively, we can parse the <code>/etc/shadow</code> file, like this:</p>
<pre class="source-code">
sudo cat /etc/shadow | cut -d: -f1 | less</pre> <p>In the preceding commands, we read the content from the related files (with <code>cat</code>). Next, we piped the result to a delimiter-based parsing (with <code>cut</code>, on the <code>:</code> delimiter) and picked the first field <code>(-f1</code>). Finally, we chose a paginated display of the results, using the <code>less</code> command (to exit the command’s output, press <em class="italic">Q</em>).</p>
<p>Note the use of <code>sudo</code> for the <code>shadow</code> file since access is limited to superusers only, due to the sensitive nature <a id="_idIndexMarker498"/>of the password hash data. Alternatively, we can use the <code>getent</code> command to retrieve the user information.</p>
<p>The following command lists all the users configured in the system:</p>
<pre class="source-code">
getent passwd</pre> <p>The preceding command reads the <code>/etc/passwd</code> file. Alternatively, we can retrieve the same information from <code>/etc/shadow</code>, as follows:</p>
<pre class="source-code">
sudo getent shadow</pre> <p>For both commands, we can further pipe the <code>getent</code> output to <code>| cut -d: -f1</code> to list only the usernames, like this:</p>
<pre class="source-code">
sudo getent shadow | cut -d: -f1 | less | column</pre> <p>The output will be similar to this:</p>
<div><div><img alt="Figure 4.8 – Viewing usernames" src="img/Figure_04_08_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Viewing usernames</p>
<p>With new users created, administrators <a id="_idIndexMarker499"/>or superusers may want to change certain user-related information, such as password, password expiration, full name, or login shell. Next, we take a look at some of the most common ways to accomplish this task.</p>
<h3>Modifying users</h3>
<p>A superuser can run the <code>usermod</code> command to<a id="_idIndexMarker500"/> modify user settings, with the following syntax:</p>
<pre class="source-code">
usermod [OPTIONS] USER</pre> <p>The examples in this section apply to a user we previously created (<code>julian</code>) with the simplest invocation of the <code>useradd</code> command. As noted in the previous section, the related user record in <code>/etc/passwd</code> has no full name for the user, and the user has no password either.</p>
<p>Let’s change the following settings for our user (<code>julian</code>):</p>
<ul>
<li><code>Julian</code> (initially empty)</li>
<li><code>/local/julian</code> (from default <code>/home/julian</code>)</li>
<li><code>/bin/bash</code> (from default <code>/bin/sh</code>)</li>
</ul>
<p>The command-line utility for changing all the preceding information is shown here:</p>
<pre class="source-code">
sudo usermod -c "Julian" -d /local/julian -m -s /bin/bash julian</pre> <p>Here are the command options, briefly explained:</p>
<ul>
<li><code>-c, --comment "Julian"</code>: The full username</li>
<li><code>-d, --home local/julian</code>: The user’s new home directory</li>
<li><code>-m, --move</code>: Move the content of the current home directory to the new location</li>
<li><code>-s, --shell /bin/sh</code>: The user login shell</li>
</ul>
<p>The related change, retrieved<a id="_idIndexMarker501"/> with the <code>getent</code> command, is shown here:</p>
<pre class="source-code">
getent passwd julian</pre> <p>We get the following output:</p>
<div><div><img alt="Figure 4.9 – The user changes reflected with getent" src="img/Figure_04_09_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The user changes reflected with getent</p>
<p>Here are a few more examples of changing user settings with the <code>usermod</code> command-line utility.</p>
<h4>Changing the username</h4>
<p>The <code>-l, --login</code> option<a id="_idIndexMarker502"/> parameter of <code>usermod</code> specifies a new login username. The following command changes the username from <code>julian</code> to <code>balog</code> (that is, first name to last name), as illustrated here:</p>
<pre class="source-code">
sudo usermod -l "balog" julian</pre> <p>In a production environment, we may have to add to the preceding command, as we may also want to change the display name and the home directory of the user (for consistency reasons). In a previous example in the <em class="italic">Creating users with useradd</em> section, we showcased the <code>-d, --home</code> and <code>-m, --move</code> option parameters, which would accommodate such changes.</p>
<h4>Locking or unlocking a user</h4>
<p>A superuser or administrator may choose to<a id="_idIndexMarker503"/> temporarily or permanently lock a specific user with the <code>-L, --lock</code> option parameter of <code>usermod</code>, as follows:</p>
<pre class="source-code">
sudo usermod -L julian</pre> <p>As a result of the preceding command, the<a id="_idIndexMarker504"/> login attempt for the user <code>julian</code> would be denied. Should the user try to SSH into the Linux machine, they would get a <strong class="bold">Permission denied, please try again</strong> error message. Also, the related username will be removed from the login screen if the Linux platform has a GUI.</p>
<p>To unlock the user, we invoke the <code>-U, --unlock</code> option parameter, as follows:</p>
<pre class="source-code">
sudo usermod -U julian</pre> <p>The preceding command restores system access for the user.</p>
<p>For more information on the <code>usermod</code> utility, please check out the related documentation (<code>man usermod</code>) or the command-line help (<code>usermod --help</code>).</p>
<p>Although the recommended way of modifying user settings is via the <code>usermod</code> command-line utility, some users may find it easier to manually edit the <code>/etc/passwd</code> file. The following section shows you how.</p>
<h4>Modifying users via /etc/passwd</h4>
<p>A superuser can also<a id="_idIndexMarker505"/> manually edit the <code>/etc/passwd</code> file to modify user data by updating the relevant line. Although the editing can be done with a text editor of your choice (for example, <code>nano</code>), we recommend the use of the <code>vipw</code> command-line utility for a safer approach. <code>vipw</code> enables the required locks to prevent possible data corruption—for example, in case a superuser performs a change at the same time regular users change their password.</p>
<p>The following command initiates the editing of the <code>/etc/passwd</code> file by also prompting for the preferred text editor (for example, <code>nano</code> or <code>vim</code>):</p>
<pre class="source-code">
sudo vipw</pre> <p>For example, we can change the settings for user <code>julian</code> by editing the following line:</p>
<pre class="source-code">
julian:x:1001:1001:Julian,,,:/home/julian:/bin/bash</pre> <p>The meaning of the colon (<code>:</code>)-separated fields was previously described in the <em class="italic">Creating users with useradd</em> section. Each of these fields can be manually altered in the <code>/etc/passwd</code> file, resulting in changes equivalent to the corresponding <code>usermod</code> invocation.</p>
<p>For more information on the <code>vipw</code> command-line utility, you can refer to the related system manual (<code>man vipw</code>).</p>
<p>Another relatively common<a id="_idIndexMarker506"/> administrative task for a user account is to change a password or set up a password expiration. Although <code>usermod</code> can change a user password via the <code>-p</code> or <code>--password</code> option, it requires an encrypted hash string (and not a cleartext password). Generating an encrypted password hash would be an extra step. An easier way is to use the <code>passwd</code> utility to change the password.</p>
<p>A superuser (administrator) can change the password of a user (for example, the user <code>julian</code>) with the following command:</p>
<pre class="source-code">
sudo passwd julian</pre> <p>The output will ask for the new password for the respective user. To change the expiration time of a password (the password age), the <code>chage</code> command is used. For example, to set a 30-day password age for the user <code>julian</code>, we will use the following command:</p>
<pre class="source-code">
sudo chage -M 30 julian</pre> <p>This will force the user <code>julian</code> to change their password every month. The password time availability is defined system-wide by the password policy. It is found inside the <code>/etc/login.defs</code> file, inside the <code>julian</code> as our example again):</p>
<pre class="source-code">
sudo chage -d 0 julian</pre> <p>This command will force the user <code>julian</code> to enter their own password the first time they log in to the system.</p>
<p>Sometimes, administrators are required to remove specific users from the system. The next section shows a couple of ways of accomplishing this task.</p>
<h3>Deleting users</h3>
<p>The most common way to<a id="_idIndexMarker507"/> remove users from the system is to use the <code>userdel</code> command-line tool. The general syntax of the <code>userdel</code> command is shown here:</p>
<pre class="source-code">
userdel [OPTIONS] USER</pre> <p>For example, to remove the user <code>julian</code>, a superuser would run the following command:</p>
<pre class="source-code">
sudo userdel -f -r julian</pre> <p>Here are the command options used:</p>
<ul>
<li><code>-f, --force</code>: Removes all files in the user’s home directory, even if not owned by the user</li>
<li><code>-r, --remove</code>: Removes the user’s home directory and mail spool</li>
</ul>
<p>The <code>userdel</code> command removes the related user data from the system, including the user’s home directory (when invoked with the <code>-f</code> or <code>--force</code> option) and the related entries in the <code>/etc/passwd</code> and <code>/</code><code>etc/shadow</code> files.</p>
<p>There is also an alternative way, which could be handy in some odd cleanup scenarios. The next section shows how.</p>
<h4>Deleting users via /etc/passwd and /etc/shadow</h4>
<p>A superuser can edit the <code>/etc/passwd</code> and <code>/etc/shadow</code> files and manually remove the corresponding<a id="_idIndexMarker508"/> lines for the user (for example, <code>julian</code>). Please note that both files have to be edited for consistency and complete removal of the related user account.</p>
<p>Edit the <code>/etc/passwd</code> file using the <code>vipw</code> command-line utility, as follows:</p>
<pre class="source-code">
sudo vipw</pre> <p>Remove the following line (for the user <code>julian</code>):</p>
<pre class="source-code">
julian:x:1001:1001:Julian,,,:/home/julian:/bin/bash</pre> <p>Next, edit the <code>/etc/shadow</code> file using the <code>-s</code> or <code>--shadow</code> option with <code>vipw</code>, as follows:</p>
<pre class="source-code">
sudo vipw -s</pre> <p>Remove the following line (for the user <code>julian</code>):</p>
<pre class="source-code">
julian:$6$xDdd7Eay/RKYjeTm$Sf.../:18519:0:99999:7:::</pre> <p>After editing the preceding files, a superuser may also need to remove the deleted user’s home directory, as follows:</p>
<pre class="source-code">
sudo rm -rf /home/julian</pre> <p>For more information on the <code>userdel</code> utility, please check out the related documentation (<code>man userdel</code>) or the command-line help (<code>userdel --help</code>).</p>
<p>The user management concepts and commands learned so far apply exclusively to individual users in the system. When multiple users in the system have a common access level or permission attribute, they<a id="_idIndexMarker509"/> are collectively referred to as a group. Groups can be regarded as standalone organizational units we can create, modify, or delete. We can also define and alter user memberships associated with groups. The next section focuses on group management internals.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor097"/>Managing groups</h1>
<p>Linux uses groups to <a id="_idIndexMarker510"/>organize users. Simply put, a group is a collection of users sharing a common attribute. Examples of such groups could be <em class="italic">employees</em>, <em class="italic">developers</em>, <em class="italic">managers</em>, and so on. In Linux, a group is uniquely identified by a GID. Users within the same group share the same GID.</p>
<p>From a user’s perspective, there are two types of groups, outlined here:</p>
<ul>
<li><strong class="bold">Primary group</strong>: The user’s<a id="_idIndexMarker511"/> initial (default) login group</li>
<li><strong class="bold">Supplementary groups</strong>: A list of groups the <a id="_idIndexMarker512"/>user is also a <a id="_idIndexMarker513"/>member of; also known as <strong class="bold">secondary groups</strong></li>
</ul>
<p>Every Linux user is a member of a primary group. A user can belong to multiple supplementary groups or no supplementary groups at all. In other words, there is one mandatory primary group associated with each Linux user, and a user can have multiple or no supplementary group memberships.</p>
<p>From a practical point of view, we can look at groups as a permissive context of collaboration for a select number of users. Imagine a <em class="italic">developers</em> group having access to developer-specific resources. Each<a id="_idIndexMarker514"/> user in this group has access to these resources. Users outside the <em class="italic">developers</em> group may not have access unless they authenticate with a group password if the group has one.</p>
<p>In the following section, we provide detailed examples of how to manage groups and set up group memberships for users. Most related commands require <em class="italic">superuser</em> or <code>sudo</code> privileges.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor098"/>Creating, modifying, and deleting groups</h2>
<p>While our primary focus remains on<a id="_idIndexMarker515"/> group administrative tasks, some related operations <a id="_idIndexMarker516"/>still involve user-related commands. Command-line utilities such as <code>groupadd</code>, <code>groupmod</code>, and <code>groupdel</code> are targeted strictly at creating, modifying, and <a id="_idIndexMarker517"/>deleting groups, respectively. On the other hand, the <code>useradd</code> and <code>usermod</code> commands carry group-specific options when associating users with groups. We’ll also introduce you to <code>gpasswd</code>, a command-line tool specializing in group administration, combining user- and group-related operations.</p>
<p>With this aspect in mind, let’s take a look at how to create, modify, and delete groups and how to manipulate group memberships for users.</p>
<h3>Creating groups</h3>
<p>To create a new group, a<a id="_idIndexMarker518"/> superuser invokes the <code>groupadd</code> command-line utility. Here’s the basic syntax of the related command:</p>
<pre class="source-code">
groupadd [OPTIONS] GROUP</pre> <p>Let’s create a new group (<code>developers</code>), with default settings, as follows:</p>
<pre class="source-code">
sudo groupadd developers</pre> <p>The group information is stored in the <code>/etc/group</code> file. Here’s the related data for the <code>developers</code> group:</p>
<pre class="source-code">
cat /etc/group | grep developers</pre> <p>The command yields the following output:</p>
<div><div><img alt="Figure 4.10 – The group with default attributes" src="img/Figure_04_10_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The group with default attributes</p>
<p>Let’s analyze the related group record. Each entry is delimited by a colon (<code>:</code>) and is listed here:</p>
<ul>
<li><code>developers</code>: Group name</li>
<li><code>x</code>: Encrypted password (password hash is stored in <code>/etc/gshadow</code>)</li>
<li><code>1003</code>: GID</li>
</ul>
<p>We can also use the <code>getent</code> command to retrieve the preceding group information, as follows:</p>
<pre class="source-code">
getent group developers</pre> <p>A superuser may choose to create a group with a specific GID, using the <code>-g, --gid</code> option parameter with <code>groupadd</code>. For example, the following command creates the <code>developers</code> group (if it doesn’t exist) with a GID of <code>1200</code>:</p>
<pre class="source-code">
sudo groupadd -g 1200 developers</pre> <p>For more information on the <code>groupadd</code> command-line utility, please refer to the related documentation (<code>man groupadd</code>).</p>
<p>Group-related data is stored in the <code>/etc/group</code> and <code>/etc/gshadow</code> files. The <code>/etc/group</code> file contains<a id="_idIndexMarker519"/> generic group membership information, while the <code>/etc/gshadow</code> file stores the encrypted password hashes for each group. Let’s take a brief look at group passwords.</p>
<h4>Understanding group passwords</h4>
<p>By default, a group doesn’t have a password when created with the simplest invocation<a id="_idIndexMarker520"/> of the <code>groupadd</code> command (for example, <code>groupadd developers</code>). Although <code>groupadd</code> supports an encrypted password (via the <code>-p, --password</code> option parameter), this would require an extra step to generate a secure password hash. There’s a better and simpler way to create a group password: by using the <code>gpasswd</code> command-line utility.</p>
<p class="callout-heading">Important note</p>
<p class="callout"><code>gpasswd</code> is a command-line tool that helps with everyday group administration tasks.</p>
<p>The following command creates a password for the <code>developers</code> group:</p>
<pre class="source-code">
sudo gpasswd developers</pre> <p>We get prompted to enter and re-enter a password, as illustrated here:</p>
<div><div><img alt="Figure 4.11 – Creating a password for the developers group" src="img/Figure_04_11_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Creating a password for the developers group</p>
<p>The purpose of a group password is to protect access to group resources. A group password is inherently insecure when shared among group members, yet a Linux administrator may choose to keep the group password private while group members collaborate unhindered within the group’s security context.</p>
<p>Here’s a quick explanation of how it works. When a member of a specific group (for example, <code>developers</code>) logs in to that group (using the <code>newgrp</code> command), the user is not prompted for the group password. When users who don’t belong to the group attempt to log in, they will be prompted for the group password.</p>
<p>In general, a group can have <a id="_idIndexMarker521"/>administrators, members, and a password. Members of a group who are the group’s administrators may use <code>gpasswd</code> without being prompted for a password, as long as they’re logged in to the group. Also, group administrators don’t need superuser privileges to perform group administrative tasks for a group they are the administrator of.</p>
<p>We’ll take a closer look at <code>gpasswd</code> in the next sections, where we further focus on group management tasks, as well as adding users to<a id="_idIndexMarker522"/> a group and removing users from a group. But for now, let’s keep our attention strictly at the group level and see how we can modify a user group.</p>
<h3>Modifying groups</h3>
<p>The most common way to modify the<a id="_idIndexMarker523"/> definition of a group is via the <code>groupmod</code> command-line utility. Here’s the basic syntax for the command:</p>
<pre class="source-code">
groupmod [OPTIONS] GROUP</pre> <p>The most common operations when changing a group’s definition are related to the GID, group name, and group password. Let’s take a look at each of these changes. We assume our previously created group is named <code>developers</code>, with a GID of <code>1003</code>.</p>
<p>To change the GID to <code>1200</code>, a superuser invokes the <code>groupmod</code> command with the <code>-g, --gid</code> option parameter, as follows:</p>
<pre class="source-code">
sudo groupmod -g <code>developers</code> to <code>devops</code>, we invoke the <code>-n, --new-name</code> option, like this:</p>
<pre class="source-code">
sudo groupmod -n <code>devops</code> group with the following command:</p>
<pre class="source-code">
getent group <strong class="bold">devops</strong></pre> <p>The command yields the following output:</p>
<div><div><img alt="Figure 4.12 – Verifying the group changes" src="img/Figure_04_12_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Verifying the group changes</p>
<p>To change the group password for <code>devops</code>, the simplest way is to use <code>gpasswd</code>, as follows:</p>
<pre class="source-code">
sudo gpasswd devops</pre> <p>We are prompted to enter and<a id="_idIndexMarker524"/> re-enter a password.</p>
<p>To remove the group password for <code>devops</code>, we invoke the <code>gpasswd</code> command with the <code>-r, --remove-password</code> option, as follows:</p>
<pre class="source-code">
sudo gpasswd -r devops</pre> <p>As the command has no visible outcome or message, we will be prompted back to the shell:</p>
<div><div><img alt="Figure 4.13 – Setting a new group password and removing a group password" src="img/Figure_04_13_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Setting a new group password and removing a group password</p>
<p>For more information on <code>groupmod</code> and <code>gpasswd</code>, refer to the system manuals of these utilities (<code>man groupmod</code> and <code>man gpasswd</code>), or simply invoke the <code>-h, --help</code> option for each.</p>
<p>Next, we look at how to delete groups.</p>
<h3>Deleting groups</h3>
<p>To delete <a id="_idIndexMarker525"/>groups, we use the <code>groupdel</code> command-line utility. The related syntax is shown here:</p>
<pre class="source-code">
groupdel [OPTIONS] GROUP</pre> <p>By default, Linux enforces referential integrity between a primary group and the users associated with that primary group. We cannot delete a group that has been assigned as a primary group for some users before deleting the users of that primary group. In other words, by default, Linux doesn’t want to leave the users with dangling primary GIDs.</p>
<p>For example, when we first added the user <code>julian</code>, they were assigned automatically to the <code>julian</code> primary group. We then added the user to the <code>sudoers</code> group.</p>
<p>Let’s attempt to add the user <code>julian</code> to the <code>devops</code> group. A superuser may run the <code>usermod</code> command with the <code>-g, --gid</code> option parameter to <em class="italic">change</em> the primary group of a user. The command should be invoked for each user. Here’s an example of removing the user <code>julian</code> from the <code>julian</code> primary group. First, let’s get the current data for the user, as follows:</p>
<pre class="source-code">
id julian</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.14 – Retrieving the current primary group for the user" src="img/Figure_04_14_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Retrieving the current primary group for the user</p>
<p>Now, let us add the user <code>julian</code> to the <code>devops</code> group. The <code>-g, --gid</code> option parameter of the <code>usermod</code> command accepts both a <em class="italic">GID</em> and a group <em class="italic">name</em>. The specified group name must already be present <a id="_idIndexMarker526"/>in the system; otherwise, the command will fail. If we want to change the primary group (for example, to <code>devops</code>), we simply specify the group name in the <code>-g, --gid</code> option parameter, as follows:</p>
<pre class="source-code">
sudo usermod -g devops julian</pre> <p>The output is shown in the following screenshot:</p>
<div><div><img alt="Figure 4.15 – Changing the primary group of the user" src="img/Figure_04_15_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Changing the primary group of the user</p>
<p>The result is that the user <code>julian</code> is now part of the <code>devops</code> group.</p>
<p>Now, let us attempt to delete the <code>devops</code> group, which is the primary group for the user <code>julian</code>. Attempting to delete the <code>devops</code> group results in an error, as can be seen in <em class="italic">Figure 4</em><em class="italic">.16</em> (the first command used). Therefore, we cannot delete a group that is not empty.</p>
<p>A superuser may choose to <em class="italic">force</em> the deletion of a primary group, invoking <code>groupdel</code> with the <code>-f, --force</code> option, but this would be ill advised. This is because the command would result in users with orphaned primary GIDs and a possible security hole in the system. The maintenance and<a id="_idIndexMarker527"/> removal of such users would also become problematic.</p>
<p>In order to be able to delete the <code>devops</code> group, we need to assign another group to the user <code>julian</code>. What we can do is assign it to the initial primary group called <code>julian</code>, and then attempt to delete the <code>devops</code> group, now that it is empty. First, let us assign the user <code>julian</code> to the <code>julian</code> group with the following command:</p>
<pre class="source-code">
sudo usermod -g julian julian</pre> <p>At this point, it’s safe to delete the group (<code>devops</code>), as follows:</p>
<pre class="source-code">
sudo groupdel devops</pre> <p>The outcome from the preceding commands is this:</p>
<div><div><img alt="Figure 4.16 – Successful attempt to delete the group" src="img/Figure_04_16_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Successful attempt to delete the group</p>
<p>For more information on the <code>groupdel</code> command-line utility, check out the related system manual (<code>man groupdel</code>), or simply invoke <code>groupdel --help</code>.</p>
<h4>Modifying groups via /etc/group</h4>
<p>An administrator can also<a id="_idIndexMarker528"/> manually edit the <code>/etc/group</code> file to modify group data by updating the related line. Although the editing can be done with a text editor of your choice (for example, <code>nano</code>), we recommend the use of the <code>vigr</code> command-line utility for a safer approach. <code>vigr</code> is similar to <code>vipr</code> (for modifying <code>/etc/passwd</code>) and sets safety locks to prevent possible data corruption during concurrent changes of group data.</p>
<p>The following command opens the <code>/etc/group</code> file for editing by also prompting for the preferred text editor (for example, <code>nano</code> or <code>vim</code>):</p>
<pre class="source-code">
sudo vigr</pre> <p>For example, we can change the settings for the <code>developers</code> group by editing the following line:</p>
<pre class="source-code">
developers:x:1200:julian,alex</pre> <p>When deleting groups<a id="_idIndexMarker529"/> using the <code>vigr</code> command, we’re also prompted to remove the corresponding entry in the group shadow file <code>(/etc/gshadow</code>). The related command invokes the <code>-s</code> or <code>--shadow</code> option, as illustrated here:</p>
<pre class="source-code">
sudo vigr -s</pre> <p>For more information on the <code>vigr</code> utility, please refer to the related system manual (<code>man vigr</code>).</p>
<p>As with most Linux tasks, all the preceding tasks could have been accomplished in different ways. The commands chosen are the most common ones, but there might be cases when a different approach may prove more appropriate.</p>
<p>In the next section, we’ll take a glance at how to add users to primary and secondary groups and how to remove users from these groups.</p>
<h3>Managing users in groups</h3>
<p>So far, we’ve only created<a id="_idIndexMarker530"/> groups that have no users associated. There is not much use for empty user groups, so let’s add some users to them.</p>
<h4>Adding users to a group</h4>
<p>Before we start adding<a id="_idIndexMarker531"/> users to a group, let’s create a few groups. In the following example, we <a id="_idIndexMarker532"/>create the groups by also specifying their GID (via the <code>-g, --gid</code> option parameter of the <code>groupadd</code> command):</p>
<pre class="source-code">
sudo groupadd -g 1100 admin
sudo groupadd -g 1200 developers
sudo groupadd -g 1300 devops</pre> <p>We can check the last groups created by using the following command:</p>
<pre class="source-code">
cat /etc/group | tail -n 5</pre> <p>It will show us the last five lines of the <code>/etc/group</code> file. We can see the last five groups created.</p>
<p>Next, we create a couple of new users (<code>alex2</code> and <code>julian2</code> as we already have users <code>alex</code> and <code>julian</code>) and add them to some of the groups we just created. We’ll have the <code>admin</code> group set as the <em class="italic">primary group</em> for both users, while the <code>developers</code> and <code>devops</code> groups are defined as <em class="italic">secondary</em> (or <em class="italic">supplementary</em>) <em class="italic">groups</em>. The code can be seen here:</p>
<pre class="source-code">
sudo useradd -g admin -G developers,devops alex2
sudo useradd -g admin -G developers,devops julian2</pre> <p>The <code>-g, --gid</code> option parameter of the <code>useradd</code> command specifies the (unique) primary group (<code>admin</code>). The <code>-G, --groups</code> option parameter provides a comma-separated list (without intervening spaces) of the secondary group names (<code>developers</code><code>,</code><code>devops</code>).</p>
<p>We can verify the group<a id="_idIndexMarker533"/> memberships for both users with the following <a id="_idIndexMarker534"/>commands:</p>
<pre class="source-code">
id alex2
id julian2</pre> <p>The output is shown in the following screenshot:</p>
<div><div><img alt="Figure 4.17 – Assigning groups to new users" src="img/Figure_04_17_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Assigning groups to new users</p>
<p>As we can see, the <code>gid</code> attribute shows the primary group membership: <code>gid=1100(admin)</code>. The <code>groups</code> attribute shows the supplementary (secondary) groups: <code>groups=1100(admin),1200(developers),1300(devops)</code>.</p>
<p>With users scattered<a id="_idIndexMarker535"/> across multiple groups, an administrator is sometimes confronted with the task of moving users between groups. The following section shows how to do this.</p>
<h4>Moving and removing users across groups</h4>
<p>Building<a id="_idIndexMarker536"/> upon the previous <a id="_idIndexMarker537"/>example, let’s <a id="_idIndexMarker538"/>assume the administrator wants to <a id="_idIndexMarker539"/>move (or add) the user <code>alex2</code> to a new secondary group called <code>managers</code>. Please note that, according to our previous examples, the user <code>alex2</code> has <code>admin</code> as the primary group and <code>developers</code>/<code>devops</code> as secondary groups (see the output of the <code>id alex2</code> command in <em class="italic">Figure 4</em><em class="italic">.18</em>).</p>
<p>Let’s create a <code>managers</code> group first, with GID <code>1400</code>. The code can be seen here:</p>
<pre class="source-code">
sudo groupadd -g 1400 managers</pre> <p>Next, add our existing user, <code>alex2</code>, to the <code>managers</code> group. We use the <code>usermod</code> command with the <code>-G, --groups</code> option parameter to specify the secondary groups the user is associated<a id="_idIndexMarker540"/> with.</p>
<p>The simplest way to <em class="italic">append</em> a secondary <a id="_idIndexMarker541"/>group to a user is by invocation of the <code>-a, --append</code> option of the <code>usermod</code> command, as illustrated here:</p>
<pre class="source-code">
sudo usermod -a -G managers alex2</pre> <p>The preceding <a id="_idIndexMarker542"/>command would preserve the existing secondary <a id="_idIndexMarker543"/>groups for the user <code>alex2</code> while adding the new <code>managers</code> group. Alternatively, we could run the following command:</p>
<pre class="source-code">
sudo usermod -G developers,devops,managers alex2</pre> <p>In the preceding command, we specified multiple groups (with no intervening whitespace!).</p>
<p class="callout-heading">Important note</p>
<p class="callout">We preserved the existing secondary groups (<code>developers</code>/<code>devops</code>) and <em class="italic">appended</em> to the comma-separated list the <code>managers</code> additional secondary group. If we only had the <code>managers</code> group specified, the user <code>alex2</code> would have been <em class="italic">removed</em> from the <code>developers</code> and <code>devops</code> secondary groups.</p>
<p>To verify whether the user <code>alex2</code> is now part of the <code>managers</code> group, run the following command:</p>
<pre class="source-code">
id alex2</pre> <p>This is the output of the command:</p>
<pre class="source-code">
uid=1004(alex2) gid=1100(admin) <code>groups</code> attribute (highlighted) includes the related entry for the <code>managers</code> group: <code>1400(managers)</code>.</p>
<p>Similarly, if we wanted to <em class="italic">remove</em> the user <code>alex2</code> from the <code>developers</code> and <code>devops</code> secondary groups, to only<a id="_idIndexMarker544"/> be associated with the <code>managers</code> secondary group, we would run<a id="_idIndexMarker545"/> the following command:</p>
<pre class="source-code">
sudo usermod -G managers alex2</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.18 – Verifying the secondary groups for the user" src="img/Figure_04_18_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Verifying the secondary groups for the user</p>
<p>The <code>groups</code> tag now shows the primary group <code>admin</code> (by default) and the <code>managers</code> secondary group.</p>
<p>The command to <a id="_idIndexMarker546"/>remove the user <code>alex2</code> from all secondary groups<a id="_idIndexMarker547"/> is shown here:</p>
<pre class="source-code">
sudo usermod -G '' alex2</pre> <p>The <code>usermod</code> command has an empty string (<code>''</code>) as the <code>-G, --groups</code> option parameter, to ensure no secondary groups are associated with the user. We can verify that the user <code>alex2</code> has no more secondary group memberships with the following command:</p>
<pre class="source-code">
id alex</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.19 – Verifying the user has no secondary groups" src="img/Figure_04_19_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Verifying the user has no secondary groups</p>
<p>As we can see, the <code>groups</code> tag only contains the <code>1100(admin)</code> primary GID, which by default is always shown for a user.</p>
<p>If an administrator chooses to remove the user <code>alex2</code> from a primary group or assign them to a different primary group, they must run the <code>usermod</code> command with the <code>-g, --gid</code> option parameter and specify the primary group name. A primary group is always mandatory for a user, and it must exist.</p>
<p>For example, to move the user <code>alex2</code> to the <code>managers</code> primary group, the <a id="_idIndexMarker548"/>administrator would run the following <a id="_idIndexMarker549"/>command:</p>
<pre class="source-code">
sudo usermod -g managers alex2</pre> <p>The related user data can be obtained using the following command:</p>
<pre class="source-code">
id alex2</pre> <p>The command yields the following output:</p>
<div><div><img alt="Figure 4.20 – Verifying the user has been assigned to the new primary group" src="img/Figure_04_20_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – Verifying the user has been assigned to the new primary group</p>
<p>The <code>gid</code> attribute of the user record in <em class="italic">Figure 4</em><em class="italic">.21</em> reflects the new primary group: <code>gid=1400(managers)</code>.</p>
<p>If the administrator <a id="_idIndexMarker550"/>chooses to configure the user <code>alex2</code> without a specific primary <a id="_idIndexMarker551"/>group, they must first create an exclusive <em class="italic">group</em> (named <code>alex2</code>, for convenience), and have the GID matching the UID of the user <code>alex2</code> (<code>1004</code>), as follows:</p>
<pre class="source-code">
sudo groupadd -g 1004 alex2</pre> <p>And now, we can remove the user <code>alex2</code> from the current primary group (<code>managers</code>) by specifying the exclusive primary group we just created (<code>alex2</code>), like this:</p>
<pre class="source-code">
sudo usermod -g alex2 alex2</pre> <p>The related user record becomes this:</p>
<pre class="source-code">
id alex2</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.21 – Verifying the user has been removed from primary groups" src="img/Figure_04_21_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – Verifying the user has been removed from primary groups</p>
<p>The <code>gid</code> attribute of the user record reflects the exclusive primary group (matching the user): <code>gid=1004(alex2)</code>. Our user doesn’t belong to any other primary groups anymore.</p>
<p>Adding, moving, and<a id="_idIndexMarker552"/> removing users across groups may become<a id="_idIndexMarker553"/> increasingly daunting tasks for a Linux<a id="_idIndexMarker554"/> administrator. Knowing at any time which users belong to which groups is valuable<a id="_idIndexMarker555"/> information, both for reporting purposes and user automation workflows. The following section provides a few commands for viewing user and group data.</p>
<h4>Viewing users and groups</h4>
<p>In this section, we <a id="_idIndexMarker556"/>will provide some potentially useful commands for retrieving group and group<a id="_idIndexMarker557"/> membership information. Before we<a id="_idIndexMarker558"/> get into any commands, we should keep in mind that group<a id="_idIndexMarker559"/> information is stored in the <code>/etc/group</code> and <code>/etc/gshadow</code> files. Among the two, the former has the information we’re most interested in.</p>
<p>We can parse the <code>/etc/group</code> file to retrieve all groups, as follows:</p>
<pre class="source-code">
cat /etc/group | cut -d: -f1 | column | less</pre> <p>The command yields the following output:</p>
<div><div><img alt="Figure 4.22 – Retrieving all group names" src="img/Figure_04_22_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Retrieving all group names</p>
<p>A similar command would use <code>getent</code>, which we can use like this:</p>
<pre class="source-code">
getent group | cut -d: -f1 | column | less</pre> <p>The output of the preceding command is identical to the output shown in <em class="italic">Figure 4</em><em class="italic">.22</em>. We <a id="_idIndexMarker560"/>can retrieve<a id="_idIndexMarker561"/> the information of an individual <a id="_idIndexMarker562"/>group (for example, <code>developers</code>) with the <a id="_idIndexMarker563"/>following command:</p>
<pre class="source-code">
getent group developers</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.23 – Retrieving information for a single group" src="img/Figure_04_23_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Retrieving information for a single group</p>
<p>The output of the preceding command also reveals the members of the <code>developers</code> group (<code>julian2</code>).</p>
<p>To list all groups a specific user is a member of, we can use the <code>groups</code> command. For example, the following command lists all groups the user <code>alex</code> is a member of:</p>
<pre class="source-code">
groups alex</pre> <p>This is the command output:</p>
<div><div><img alt="Figure 4.24 – Retrieving group membership information of a user" src="img/Figure_04_24_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Retrieving group membership information of a user</p>
<p>The output of the previous command shows the groups for the user <code>alex</code>, starting with the primary group (<code>alex</code>).</p>
<p>A user can<a id="_idIndexMarker564"/> retrieve their own group membership using the <code>groups</code> command-line<a id="_idIndexMarker565"/> utility without specifying a group name. The following command is executed in a terminal session of the user <code>packt</code>, who is also an administrator (superuser):</p>
<pre class="source-code">
groups</pre> <p>The command yields this output:</p>
<div><div><img alt="Figure 4.25 – The current user’s groups" src="img/Figure_04_25_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – The current user’s groups</p>
<p>There are many other ways and commands to retrieve user- and group-related information. We hope that the preceding examples provide a basic idea about where and how to look for some of this information.</p>
<p>Next, let’s look at how a user can switch or log in to specific groups.</p>
<h4>Group login sessions</h4>
<p>When a user logs in to the system, the <a id="_idIndexMarker566"/>group membership context is automatically set to the user’s primary group. Once the user is logged in, any user-initiated task (such as creating a file or running a program) is associated with the user’s primary group membership permissions. A user may also choose to access resources in other groups where they are also a member (that is, supplementary or secondary groups). To switch the group context or log in with a new group membership, a user invokes the <code>newgrp</code> command-line utility.</p>
<p>The basic syntax for the <code>newgrp</code> command is this:</p>
<pre class="source-code">
newgrp GROUP</pre> <p>In the following example, we assume a user (<code>julian</code>) is a member of multiple groups—<code>admin</code> as the primary group, and <code>developers</code>/<code>devops</code> as secondary groups:</p>
<pre class="source-code">
id julian</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.26 – A user with multiple group memberships" src="img/Figure_04_26_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26 – A user with multiple group memberships</p>
<p>Let’s impersonate the user <code>julian</code> for a while. We are currently logged in as the user <code>packt</code>. To change to the user <code>julian</code>, we will use the following command:</p>
<pre class="source-code">
su julian</pre> <p>Remember that the user <code>julian</code> needs to have their password set in order to authenticate.</p>
<p>When logged in as <code>julian</code>, the default login session has the<a id="_idIndexMarker567"/> following user and group context:</p>
<pre class="source-code">
whoami</pre> <p>In our case, this is the output:</p>
<div><div><img alt="Figure 4.27 – Getting the current user" src="img/Figure_04_27_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.27 – Getting the current user</p>
<p>The <code>whoami</code> command provides the current UID (see more details on the command with <code>man whoami</code> or <code>whoami --help</code>), as follows:</p>
<pre class="source-code">
groups</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.28 – Getting the current user’s groups" src="img/Figure_04_28_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.28 – Getting the current user’s groups</p>
<p>The <code>groups</code> command displays all groups that the current user is a member of (see more details on the command with <code>man groups</code> or <code>groups --help</code>).</p>
<p>The user can also view their IDs (user and GIDs) by invoking the <code>id</code> command, as follows:</p>
<pre class="source-code">
id</pre> <p>This is the output:</p>
<div><div><img alt="Figure 4.29 – Viewing the current user and GID information" src="img/Figure_04_29_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.29 – Viewing the current user and GID information</p>
<p>There are various invocations of the <code>id</code> command that provide information on the current user and group<a id="_idIndexMarker568"/> session. The following command (with the <code>-g, --group</code> option) retrieves the ID of the current group session for the user:</p>
<pre class="source-code">
id -g
1100</pre> <p>In our case, the preceding command shows <code>1100</code>—the GID corresponding to the user’s primary group, which is <code>admin</code> (see the <code>gid</code> attribute in <em class="italic">Figure 4</em><em class="italic">.30</em>). Upon login, the default group session is always the primary group corresponding to the user. If the user were to create a file, for example, the file permission attributes would reflect the primary group’s ID. We’ll look at the file permissions in more detail in the <em class="italic">Managing </em><em class="italic">permissions</em> section.</p>
<p>Now, let’s switch the group session for the current user to <code>developers</code>, as follows:</p>
<pre class="source-code">
newgrp developers</pre> <p>The current group session yields this:</p>
<pre class="source-code">
id -g
1200</pre> <p>The GID corresponds to the <code>developers</code> secondary GID, as displayed by the <code>groups</code> attribute in <em class="italic">Figure 4</em><em class="italic">.30</em>: <code>1200(developers)</code>. If the user created any files now, the related file permission attributes would have the <code>developers</code> GID:</p>
<div><div><img alt="Figure 4.30 – Switching the group session" src="img/Figure_04_30_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.30 – Switching the group session</p>
<p>If the user attempts to log in to a group they are not a member of (for example, <code>managers</code>), the <code>newgrp</code> command prompts for the <code>managers</code> group’s password:</p>
<pre class="source-code">
newgrp managers</pre> <p>If our user had the <code>managers</code> group password, or if they were a superuser, the group login attempt would succeed. Otherwise, the user would be denied access to the <code>managers</code> group’s resources.</p>
<p>We conclude here <a id="_idIndexMarker569"/>our topic of managing users and groups. The examples of the related administrative tasks used throughout this section are certainly all-encompassing. In many of these cases, there are multiple ways to achieve the same result, using different commands or approaches.</p>
<p>By now, you should be relatively proficient in managing users and groups, and comfortable using the various command-line utilities for operating the related changes. Users and groups are managed in a relational fashion, where users belong to a group or groups are associated with users. We also learned that creating and managing users and groups requires superuser privileges. In Linux, user data is stored in the <code>/etc/passwd</code> and <code>/etc/shadow</code> files, while group information is found in <code>/etc/group</code> and <code>/etc/gshadow</code>. Besides using the dedicated command-line utilities, users and groups can also be altered by manually editing these files.</p>
<p>Next, we’ll turn to the security and isolation context of the multiuser group environment. In Linux, the related functionality is accomplished by a system-level access layer that controls the read, write, and execute permissions of files and directories, by specific users and groups.</p>
<p>The following section explores the management and administrative tasks related to these permissions.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor099"/>Managing permissions</h1>
<p>A key tenet of Linux is the ability to allow multiple users to access the system while performing independent tasks simultaneously. The<a id="_idIndexMarker570"/> smooth operation of this multiuser, multitasking environment is controlled via <strong class="bold">permissions</strong>. The Linux kernel provides a robust framework for the underlying security and isolation model. At the user level, dedicated tools and command-line utilities help Linux users and system administrators with related permission management tasks.</p>
<p>For some Linux users, especially beginners, Linux permissions may appear confusing at times. This section attempts to demystify some of the key concepts about file and directory permissions in Linux. You will learn about the basic permission <em class="italic">rights</em> of accessing files and directories—the <em class="italic">read</em>, <em class="italic">write</em>, and <em class="italic">execution</em> permissions. We explore some of the essential administrative tasks for viewing and changing permissions, using system-level command-line utilities.</p>
<p>Most of the topics discussed in this <a id="_idIndexMarker571"/>section should be regarded closely with users and groups. The related idioms can be as simple as <em class="italic">a user can read or update a file</em>, <em class="italic">a group has access to these files and directories</em>, or <em class="italic">a user can execute </em><em class="italic">this program</em>.</p>
<p>Let’s start with the basics, introducing file and directory permissions.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor100"/>File and directory permissions</h2>
<p>In Linux, permissions can be <a id="_idIndexMarker572"/>regarded as the <em class="italic">rights</em> or <em class="italic">privileges</em> to act upon a file or a directory. The basic rights, or <em class="italic">permission attributes</em>, are outlined here:</p>
<ul>
<li><strong class="bold">Read</strong>: A <em class="italic">read</em> permission <a id="_idIndexMarker573"/>of a file allows users to view the content of the file. On a directory, the read <a id="_idIndexMarker574"/>permission allows users to list the content of the directory.</li>
<li><strong class="bold">Write</strong>: A <em class="italic">write</em> permission<a id="_idIndexMarker575"/> of a file <a id="_idIndexMarker576"/>allows users to modify the content of the file. For a directory, the write permission allows users to modify the content of the directory by adding, deleting, or renaming files.</li>
<li><code>cd</code> command).</li>
</ul>
<p>First, let’s take a look at how to reveal the permissions for files and directories.</p>
<h3>Viewing permissions</h3>
<p>The most common<a id="_idIndexMarker579"/> way to view the permissions of a file or directory is by using the <code>ls</code> command-line utility. The basic syntax of this command is this:</p>
<pre class="source-code">
ls [OPTIONS] FILE|DIRECTORY</pre> <p>Here is an example use of the <code>ls</code> command to view the permissions of the <code>/</code><code>etc/passwd</code> file:</p>
<pre class="source-code">
ls -l /etc/passwd</pre> <p>The command yields the following output:</p>
<pre class="source-code">
-rw-r--r-- 1 root root 2010 Mar  9 08:57 /etc/passwd</pre> <p>The <code>-l</code> option of the <code>ls</code> command provides a detailed output by using the <em class="italic">long listing format</em>, according to the <code>ls</code> documentation (<code>man ls</code>).</p>
<p>Let’s analyze the output, as follows:</p>
<pre class="source-code">
-rw-r--r-- 1 root root 2010 Mar  9 08:57 /etc/passwd</pre> <p>We have nine segments, separated<a id="_idIndexMarker580"/> by single whitespace characters (delimiters). These are outlined here:</p>
<ul>
<li><code>-rw-r--r--</code>: The file access permissions</li>
<li><code>1</code>: The number of hard links</li>
<li><code>root</code>: The <em class="italic">user</em> who is the owner of the file</li>
<li><code>root</code>: The <em class="italic">group</em> that is the owner of the file</li>
<li><code>2010</code>: The size of the file</li>
<li><code>Mar</code>: The month the file was created</li>
<li><code>9</code>: The day of the month the file was created</li>
<li><code>08:57</code>: The time of day the file was created</li>
<li><code>/etc/passwd</code>: The filename</li>
</ul>
<p>Let’s examine the file<a id="_idIndexMarker581"/> access permissions field (<code>-rw-r--r--</code>). File access permissions are defined as a 10-character field, grouped as follows:</p>
<ul>
<li>The first character (attribute) is reserved for the file type (see the <em class="italic">File </em><em class="italic">types</em> section).</li>
<li>The next 9 characters represent a 9-bit field, defining the effective permissions as 3 sequences of 3 attributes (bits) each: <em class="italic">user owner</em> permissions, <em class="italic">group owner</em> permissions, and <em class="italic">all other users’</em> permissions (see the <em class="italic">Permission </em><em class="italic">attributes</em> section).</li>
</ul>
<p>Let’s take a look at the file type attributes.</p>
<h4>File type attributes</h4>
<p>The file type attributes<a id="_idIndexMarker582"/> are listed here:</p>
<ul>
<li><code>d</code>: Directory</li>
<li><code>-</code>: Regular file</li>
<li><code>l</code>: Symbolic link</li>
<li><code>p</code>: Named pipe—a special file that facilitates communication between programs</li>
<li><code>s</code>: Socket—similar to a pipe but with bidirectional network communications</li>
<li><code>b</code>: Block device—a file that corresponds to a hardware device</li>
<li><code>c</code>: Character device—similar to a block device</li>
</ul>
<p>Let’s have a closer look at the permission attributes.</p>
<h4>Permission attributes</h4>
<p>As previously noted, the access <a id="_idIndexMarker583"/>permissions are represented by a 9-bit field, a group of 3 sequences, each with 3 bits, defined as follows:</p>
<ul>
<li><strong class="bold">Bits 1-3</strong>: <em class="italic">User</em> owner permissions</li>
<li><strong class="bold">Bits 4-6</strong>: <em class="italic">Group</em> owner permissions</li>
<li><strong class="bold">Bits 7-9</strong>: <em class="italic">All</em> other users’ (or <em class="italic">world</em>) permissions</li>
</ul>
<p>Each permission attribute is a bit flag in the binary representation of the related 3-bit sequence. They can be represented either as a character or as an equivalent numerical value, also known as the <em class="italic">octal</em> value, depending on the<a id="_idIndexMarker584"/> range of the bit they represent.</p>
<p>Here are the permission attributes with their respective octal values:</p>
<ul>
<li><code>r</code>: <em class="italic">Read</em> permission; 2 ^ 2 = <code>4</code> (bit 2 set)</li>
<li><code>w</code>: <em class="italic">Write</em> permission: 2 ^ 1 = <code>2</code> (bit 1 set)</li>
<li><code>x</code>: <em class="italic">Execute</em> permission: 2 ^ 0 = <code>1</code> (bit 0 set)</li>
<li><code>-</code>: <em class="italic">No</em> permission: <code>0</code> (no bits set)</li>
</ul>
<p>The resulting corroborated number is <a id="_idIndexMarker585"/>also known as the <em class="italic">octal value</em> of the file permissions (see the <em class="italic">File permission examples</em> section). Here’s an illustration of the file permission attributes:</p>
<div><div><img alt="Figure 4.31 – The file permission attributes" src="img/Figure_04_31_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.31 – The file permission attributes</p>
<p>Next, let’s consider<a id="_idIndexMarker586"/> some examples.</p>
<h4>File permission examples</h4>
<p>Now, let’s go back and evaluate the file <a id="_idIndexMarker587"/>access permissions for <code>/etc/passwd</code>: <code>-rw-r--r--</code>, as follows:</p>
<ul>
<li><code>-</code>: The first character (byte) denotes the file type (a regular file, in our case)</li>
<li><code>rw-</code>: The next three-character sequence indicates the user owner permissions; (in our case, read (<code>r</code>); write (<code>w</code>); octal value = <code>4</code> (<code>r</code>) + <code>2</code> (<code>w</code>) = <code>6</code> (<code>rw</code>))</li>
<li><code>r--</code>: The next 3-byte sequence defines the group owner permissions (in our case, read (<code>r</code>); octal value = <code>4</code> (<code>r</code>))</li>
<li><code>r--</code>: The last three characters denote the permissions for all other users in the system (in our case, read (<code>r</code>); octal value = <code>4</code> (<code>r</code>))</li>
</ul>
<p>According to the preceding information, the resulting octal value of the <code>/etc/passwd</code> file access permissions is <code>644</code>. Alternatively, we can query the octal value with the <code>stat</code> command, as follows:</p>
<pre class="source-code">
stat --format '%a' /etc/passwd</pre> <p>The command yields the following output:</p>
<pre class="source-code">
644</pre> <p>The <code>stat</code> command displays the file or filesystem status. The <code>--format</code> option parameter specifies the access rights in octal format (<code>'%a'</code>) for the output.</p>
<p>Here are a few examples of <a id="_idIndexMarker588"/>access permissions, with their corresponding octal values and descriptions. The three-character sequences are intentionally delimited with whitespace for clarity. The leading file type has been omitted:</p>
<ul>
<li><code>rwx</code> (<code>777</code>): Read, write, and execute for all users including owner, group, and world</li>
<li><code>rwx r-x</code> (<code>755</code>): Read and execute for all users; the file owner has write permissions</li>
<li><code>rwx r-x ---</code> (<code>750</code>): Read and execute for owner and group; the owner has write permissions while others have no access</li>
<li><code>rwx --- ---</code> (<code>700</code>): Read, write, and execute for owner; everyone else has no permissions</li>
<li><code>rw- rw- rw-</code> (<code>666</code>): Read and write for all users; there are no execute permissions</li>
<li><code>rw- rw- r--</code> (<code>664</code>): Read and write for owner and group; read for others</li>
<li><code>rw- rw- ---</code> (<code>660</code>): Read and write for owner and group; others have no permissions</li>
<li><code>rw- r-- r--</code> (<code>644</code>): Read and write for owner; read for group and others</li>
<li><code>rw- r-- ---</code> (<code>640</code>): Read and write for owner; read for group; no permissions for others</li>
<li><code>rw- --- ---</code> (<code>600</code>): Read and write for owner; no permissions for group and others</li>
<li><code>r-- --- ---</code> (<code>400</code>): Read for owner; no permissions for others</li>
</ul>
<p>Read, write, and execute are the most common types of file access permissions. So far, we have mostly focused on permission types and their representation. In the next section, we will explore a<a id="_idIndexMarker589"/> few command-line tools used for altering permissions.</p>
<h3>Changing permissions</h3>
<p>Modifying file and <a id="_idIndexMarker590"/>directory access permissions is a common Linux administrative task. In this section, we will learn about a few command-line utilities that are handy when it comes to changing permissions and ownership of files and directories. These tools are installed with any modern-day Linux distribution, and their use is similar across most Linux platforms.</p>
<h4>Using chmod</h4>
<p>The <code>chmod</code> command is<a id="_idIndexMarker591"/> short for <em class="italic">change mode</em>, and it’s used to set access permissions on files and directories. The <code>chmod</code> command can <a id="_idIndexMarker592"/>be used by both the current user (owner) and a superuser.</p>
<p>Changing permissions can be done in two different modes: <strong class="bold">relative</strong> and <strong class="bold">absolute</strong>. Let’s take a look at each of them.</p>
<h4>Using chmod in relative mode</h4>
<p>Changing permissions in <strong class="bold">relative</strong><strong class="bold"><a id="_idIndexMarker593"/></strong> mode is <a id="_idIndexMarker594"/>probably the easiest of the two. It is important to remember the following:</p>
<ul>
<li><em class="italic">To whom</em> we change permissions: <code>u</code> = user (owner), <code>g</code> = group, <code>o</code> = others</li>
<li><em class="italic">How</em> we change permissions: <code>+</code> = add, <code>-</code> = remove, <code>=</code> = exactly as is</li>
<li><em class="italic">Which</em> permission we change: <code>r</code> = read, <code>w</code> = write, <code>x</code> = execute</li>
</ul>
<p>Let’s explore a few examples of using <code>chmod</code> in relative mode.</p>
<p>In our first example, we want to add write (<code>w</code>) permissions for all <em class="italic">other</em> (<code>o</code>) users (<em class="italic">world</em>), to <code>myfile</code>, as follows:</p>
<pre class="source-code">
chmod o+w myfile</pre> <p>The related command-line output is shown here:</p>
<div><div><img alt="Figure 4.32 – Setting write permissions to all other users" src="img/Figure_04_32_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.32 – Setting write permissions to all other users</p>
<p>In the <a id="_idIndexMarker595"/>next example, we<a id="_idIndexMarker596"/> remove the read (<code>r</code>) and write (<code>w</code>) permissions for the current user owner (<code>u</code>) of <code>myfile</code>, as follows:</p>
<pre class="source-code">
chmod u-rw myfile</pre> <p>The command-line output is shown here:</p>
<p class="IMG---Figure"/>
<div><div><img alt="Figure 4.33 – Removing read-write permissions for owner" src="img/Figure_04_33_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.33 – Removing read-write permissions for owner</p>
<p>We did not use <code>sudo</code> in either of the preceding examples since we carried out the operations as the current owner of the file (<code>packt</code>).</p>
<p>In the following example, we assume that <code>myfile</code> has read, write, and execute permissions for everyone. Then, we carry out the following changes:</p>
<ul>
<li>Remove the read (<code>r</code>) permission for the owner (<code>u</code>)</li>
<li>Remove the write (<code>w</code>) permission for the owner (<code>u</code>) and group (<code>g</code>)</li>
<li>Remove the read (<code>r</code>), write (<code>w</code>), and execute (<code>x</code>) permissions for everyone else (<code>o</code>)</li>
</ul>
<p>This is illustrated in the following code snippet:</p>
<pre class="source-code">
chmod u-r,ug-w,o-rwx myfile</pre> <p>The command-line<a id="_idIndexMarker597"/> output is shown here:</p>
<div><div><img alt="Figure 4.34 – A relatively complex invocation of chmod in relative mode" src="img/Figure_04_34_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.34 – A relatively complex invocation of chmod in relative mode</p>
<p>Next, let’s look<a id="_idIndexMarker598"/> at a second way of changing permissions: using the <code>chmod</code> command-line utility in absolute mode, by specifying the octal number corresponding to the access permissions.</p>
<h4>Using chmod in absolute mode</h4>
<p>The <code>chmod</code> changes all <a id="_idIndexMarker599"/>permission attributes at once, using an <em class="italic">octal</em> number. The <em class="italic">absolute</em> designation of this method is due to changing permissions without any <a id="_idIndexMarker600"/>reference to existing ones, by simply assigning the octal value corresponding to the access permissions.</p>
<p>Here’s a quick list of the octal values corresponding to effective permissions:</p>
<ul>
<li><code>7</code> <code>rwx</code>: Read, write, and execute</li>
<li><code>6</code> <code>rw-</code>: Read and write</li>
<li><code>5</code> <code>r-w</code>: Read and execute</li>
<li><code>4</code> <code>r--</code>: Read</li>
<li><code>3</code> <code>-wx</code>: Write and execute</li>
<li><code>2</code> <code>-</code><code>w-</code>: Write</li>
<li><code>1</code> <code>--</code><code>x</code>: Execute</li>
<li><code>0</code> <code>---</code>: No permissions</li>
</ul>
<p>In the following example, we change the permissions of <code>myfile</code> to read (<code>r</code>), write (<code>w</code>), and execute (<code>x</code>) for<a id="_idIndexMarker601"/> everybody:</p>
<pre class="source-code">
chmod 777 myfile</pre> <p>The related change is illustrated by the following command-line output:</p>
<div><div><img alt="Figure 4.35 – The chmod invocation in absolute mode" src="img/Figure_04_35_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.35 – The chmod invocation in absolute mode</p>
<p>For more information <a id="_idIndexMarker602"/>about the <code>chmod</code> command, please refer to the related documentation (<code>man chmod</code>).</p>
<p>Let’s now look at our next command-line utility, specializing in file and directory ownership changes.</p>
<h4>Using chown</h4>
<p>The <code>chown</code> command (short for <em class="italic">change owner</em>) is<a id="_idIndexMarker603"/> used to set<a id="_idIndexMarker604"/> the ownership of files and directories. Typically, the <code>chmod</code> command can only be run with <em class="italic">superuser</em> privileges (that is, by a <em class="italic">sudoer</em>). Regular users can only change the <em class="italic">group</em> ownership of their files, and only when they are a member of the target group.</p>
<p>The syntax of the <code>chown</code> command is shown here:</p>
<pre class="source-code">
chown [OPTIONS] [OWNER][:[GROUP]] FILE</pre> <p>Usually, we invoke the <code>chown</code> command with both user <em class="italic">and</em> group ownerships—for example, like this:</p>
<pre class="source-code">
sudo chown julian:developers myfile</pre> <p>The related command-line output is shown here:</p>
<div><div><img alt="Figure 4.36 – A simple invocation of the chown command" src="img/Figure_04_36_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.36 – A simple invocation of the chown command</p>
<p>One of the most common uses of <code>chown</code> is for <em class="italic">recursive mode</em> invocation, with the <code>-R, --recursive</code> option. The<a id="_idIndexMarker605"/> following<a id="_idIndexMarker606"/> example changes the ownership permissions of all files in <code>mydir</code> (directory), initially owned by <code>root</code>, to <code>julian</code>:</p>
<pre class="source-code">
sudo chown -R julian:julian mydir/</pre> <p>The related changes are shown in the following command-line output:</p>
<div><div><img alt="Figure 4.37 – Invoking ls and chown in recursive mode" src="img/Figure_04_37_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.37 – Invoking ls and chown in recursive mode</p>
<p>For more information<a id="_idIndexMarker607"/> about the <code>chown</code> command, please refer to the related documentation (<code>man chown</code>).</p>
<p>Next, let’s briefly look at a<a id="_idIndexMarker608"/> similar command-line utility that specializes exclusively in group ownership changes.</p>
<h4>Using chgrp</h4>
<p>The <code>chgrp</code> command (short for <em class="italic">change group</em>) <a id="_idIndexMarker609"/>is used to<a id="_idIndexMarker610"/> change the <em class="italic">group</em> ownership for files and directories. In Linux, files and directories typically belong to a user (owner) or a group. We can set user ownership by using the <code>chown</code> command-line utility, while group ownership can be set with <code>chgrp</code>.</p>
<p>The syntax for <code>chgrp</code> is shown here:</p>
<pre class="source-code">
chgrp [OPTIONS] GROUP FILE</pre> <p>The following example changes the group ownership of <code>myfile</code> to the <code>developers</code> group:</p>
<pre class="source-code">
sudo chgrp developers myfile</pre> <p>The changes are shown in the following output:</p>
<div><div><img alt="Figure 4.38 - Using chgrp to change group ownership" src="img/Figure_04_38_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.38 - Using chgrp to change group ownership</p>
<p>The preceding command has <a id="_idIndexMarker611"/>been invoked with superuser privileges (<code>sudo</code>) since the current user (<code>packt</code>) is not <a id="_idIndexMarker612"/>an admin for the <code>developers</code> group.</p>
<p>For more information about the <code>chgrp</code> utility, please refer to the tool’s command-line help (<code>chgrp --help</code>).</p>
<h4>Using umask</h4>
<p>The <code>umask</code> command is <a id="_idIndexMarker613"/>used to view<a id="_idIndexMarker614"/> or set the default <em class="italic">file mode mask</em> in the system. The file mode represents the default permissions for any new files and directories created by a user. For example, the default file mode masks in Ubuntu are given here:</p>
<ul>
<li><code>0002</code> for a regular user</li>
<li><code>0022</code> for the <code>root</code> user</li>
</ul>
<p>As a general rule in Linux, the <em class="italic">default permissions</em> for new files and directories are calculated with the following formulas:</p>
<ul>
<li><code>0666 – umask</code>: For a new file created by a regular user</li>
<li><code>0777 – umask</code>: For a new directory created by a regular user</li>
</ul>
<p>According to the preceding formula, on Ubuntu, we have the following default permissions:</p>
<ul>
<li>File (regular user): <code>0666 – 0002 = </code><code>0664</code></li>
<li>File (<code>root</code>): <code>0666 – 0022 = </code><code>0644</code></li>
<li>Directory (regular user): <code>0777 – 0002 = </code><code>0775</code></li>
<li>Directory (<code>root</code>): <code>0777 – 0022 = </code><code>0755</code></li>
</ul>
<p>In the following <a id="_idIndexMarker615"/>examples, run on Ubuntu, we create a file (<code>myfile</code>) and a directory (<code>mydir</code>), using the terminal session of a regular user (<code>packt</code>). Then, we query the <code>stat</code> command for each and <a id="_idIndexMarker616"/>verify that the default permissions match the values enumerated previously for regular users (file: <code>664</code>, directory: <code>775</code>).</p>
<p>Let’s start with the default file permissions first, as follows:</p>
<pre class="source-code">
touch myfile2
stat --format '%a' myfile2</pre> <p>The related output is shown here:</p>
<pre class="source-code">
664</pre> <p>Next, let’s verify the default directory permissions, as follows:</p>
<pre class="source-code">
mkdir mydir2
stat --format '%a' mydir2</pre> <p>The related output is shown here:</p>
<pre class="source-code">
775</pre> <p>Here’s a list with the typical <code>umask</code> values for files and directories on Linux systems:</p>
<div><div><img alt="Figure 4.39 – Typical umask values on Linux" src="img/Figure_04_39_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.39 – Typical umask values on Linux</p>
<p>For more information about the <code>umask</code> utility, please refer to the tool’s command-line help (<code>umask --help</code>).</p>
<p>File and directory <a id="_idIndexMarker617"/>permissions are critical for a secure environment. Users and processes should operate exclusively within the isolation and security constraints controlled by permissions, to avoid inadvertent or deliberate interference with the use and ownership of system resources. There are cases, particularly in user impersonation situations, when<a id="_idIndexMarker618"/> the access rights may involve some special permission attributes. Let’s have a look at them.</p>
<h3>Special permissions</h3>
<p>In Linux, the ownership of <a id="_idIndexMarker619"/>files and directories is usually determined by the UID and GID of the user—or group—who created them. The same principle applies to applications and processes—they are owned by the users who launch them. The special permissions are meant to change this default behavior when needed.</p>
<p>Here are the special permission flags, with their respective octal values:</p>
<ul>
<li><code>setuid</code>: 2 ^ 2 = <code>4</code> (bit 2 set)</li>
<li><code>setgid</code>: 2 ^ 1 = <code>2</code> (bit 1 set)</li>
<li><code>sticky</code>: 2 ^ 0 = <code>1</code> (bit 0 set)</li>
</ul>
<p>When any of these special bits are set, the overall octal number of the access permissions will have an extra digit, with the leading (high-order) digit corresponding to the special permission’s octal value.</p>
<p>Let’s look at these special permission flags, with examples for each.</p>
<h4>The setuid permission</h4>
<p>With the <code>setuid</code> bit set, when an<a id="_idIndexMarker620"/> executable file is launched, it will run with the privileges of the file owner instead of the user who launched it. For example, if the executable is owned by <code>root</code> and launched by a <em class="italic">regular</em> user, it will run with <code>root</code> privileges. The <code>setuid</code> permission could pose a potential security risk when used inadequately, or when vulnerabilities of the underlying process could be exploited.</p>
<p>In the file access permission field, the <code>setuid</code> bit could have either of the following representations:</p>
<ul>
<li><code>s</code> <em class="italic">replacing</em> the corresponding executable bit (<code>x</code>) (when the executable bit is present)</li>
<li><code>S</code> (the capital letter) for a non-executable file</li>
</ul>
<p>The <code>setuid</code> permission can be set via the following <code>chmod</code> command (for example, for the <code>myscript.sh</code> executable file):</p>
<pre class="source-code">
chmod u+s myscript.sh</pre> <p>The resulting file permissions are shown here (including the octal value): <code>-</code><code>rwsrwxr-x</code> (<code>4775</code>).</p>
<p>Here is the related command-line output:</p>
<div><div><img alt="Figure 4.40 – The setuid permission" src="img/Figure_04_40_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.40 – The setuid permission</p>
<p>In the preceding screenshot, you can see the difference in permissions. Before applying the <code>chmod</code> command, the permissions are <code>-rwxrwxr-x</code>, and after applying the <code>setuid</code> permission with the <code>chmod</code> command, an <code>s</code> (referring to <code>setuid</code>) is included in the user’s permission, <code>-rwsrwxr-x</code>. For more information on <code>setuid</code>, please visit <a href="https://docs.oracle.com/cd/E19683-01/816-4883/secfile-69/index.html">https://docs.oracle.com/cd/E19683-01/816-4883/secfile-69/index.html</a> or refer to the <code>chmod</code> command-line<a id="_idIndexMarker621"/> utility documentation (<code>man chmod</code>).</p>
<h4>The setgid permission</h4>
<p>While <code>setuid</code> controls user<a id="_idIndexMarker622"/> impersonation privileges, <code>setgid</code> has a similar effect on group impersonation permissions.</p>
<p>When an executable file has the <code>setgid</code> bit set, it runs using the permissions of the group that owns the file, rather than the group of the user who initiated it. In other words, the GID of the process is the same as the GID of the file.</p>
<p>When used on a directory, the <code>setgid</code> bit changes the default ownership behavior so that files created within the directory will have group ownership of the parent directory instead of the group associated with the user who created them. This behavior could be adequate in file-sharing situations when files can be changed by all users associated with the parent directory’s owner group.</p>
<p>The <code>setgid</code> permission can be set via the following <code>chmod</code> command (for example, for the <code>myscript.sh</code> executable file, the original file, before applying <code>setuid</code> to it):</p>
<pre class="source-code">
chmod g+s myscript.shw</pre> <p>The resulting file permissions are shown here (including the octal value): <code>-</code><code>rwxrwsr-x</code> (<code>2775</code>).</p>
<p>The command-line output is shown here:</p>
<div><div><img alt="Figure 4.41 – The setgid permission" src="img/Figure_04_41_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.41 – The setgid permission</p>
<p>For more information on <code>setgid</code>, please visit <a href="https://en.wikipedia.org/wiki/Setuid">https://en.wikipedia.org/wiki/Setuid</a> or refer to the <code>chmod</code> command-line utility<a id="_idIndexMarker623"/> documentation (<code>man chmod</code>).</p>
<h4>The sticky permission</h4>
<p>The <code>sticky</code> bit has no effect <a id="_idIndexMarker624"/>on files. For a directory with the <code>sticky</code> permission, only the user owner or group owner of the directory can delete or rename files within the directory. Users or groups with write access to the directory, by way of user or group ownership, cannot delete or modify files in the directory. The <code>sticky</code> permission is useful when a directory is owned by a privileged group whose members share write access to files in that directory.</p>
<p>The <code>sticky</code> permission can be set via the following <code>chmod</code> command (for example, for the <code>mydir</code> directory):</p>
<pre class="source-code">
chmod +t mydir</pre> <p>The resulting directory permissions are shown here (including the octal value): <code>drwxrwxr-t</code> (<code>1775</code>).</p>
<p>The command-line output is shown here:</p>
<div><div><img alt="Figure 4.42 – The sticky permission" src="img/Figure_04_42_B19682.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.42 – The sticky permission</p>
<p>For more information on <code>sticky</code>, please visit <a href="https://en.wikipedia.org/wiki/Setuid">https://en.wikipedia.org/wiki/Setuid</a> or refer to the <code>chmod</code> command-line utility documentation (<code>man chmod</code>).</p>
<p>Interpreting permissions <a id="_idIndexMarker625"/>can be a daunting task. This section aimed to demystify some of the related intricacies, and we hope that you will feel more comfortable handling file and directory permissions in everyday Linux administration tasks.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor101"/>Summary</h1>
<p>In this chapter, we explored some of the essential concepts related to managing users and groups in Linux. We learned about file and directory permissions and the different access levels of a multiuser environment. For each main topic, we focused on basic administrative tasks, providing various practical examples and using typical command-line tools for everyday user access and permission management operations.</p>
<p>Managing users and groups, and the related filesystem permissions that come into play, is an indispensable skill of a Linux administrator. The knowledge gained in this chapter will, we hope, put you on track to becoming a proficient superuser.</p>
<p>In the following chapter, we continue our journey of mastering Linux internals by exploring processes, daemons, and <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) mechanisms. An important aspect to keep in mind is that processes and daemons are also <em class="italic">owned</em> by users or groups. The skills learned in this chapter will help us navigate the related territory when we look at <em class="italic">who runs what</em> at any given time in the system.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor102"/>Questions</h1>
<p>Here are a few thoughts and questions that sum up the main ideas covered in this chapter:</p>
<ol>
<li>What is a superuser?</li>
</ol>
<p><code>sudo</code></p>
<ol>
<li value="2">Think of a command-line utility for creating users. Can you think of another one?</li>
</ol>
<p><code>adduser</code> and <code>useradd</code></p>
<ol>
<li value="3">What is the octal value of the <code>-rw-rw-r—</code> access permission?</li>
</ol>
<p><code>r</code>, <code>w</code>, and <code>x</code> are: <code>4</code>, <code>2</code>, and <code>1</code></p>
<ol>
<li value="4">What is the difference between a primary group and a secondary (supplementary) group?</li>
<li>How do you change the ownership of a user’s home directory?</li>
<li>Can you remove a user from the system without deleting their home directory? How?</li>
</ol>
<h1 id="_idParaDest-87"><a id="_idTextAnchor103"/>Further reading</h1>
<p>Here are a few Packt titles that can help you with the task of user management:</p>
<ul>
<li><em class="italic">Mastering Ubuntu Server – Fourth Edition</em>, <em class="italic">Jay LaCroix</em></li>
<li><em class="italic">Red Hat Enterprise Linux 9 Administration – Second Edition</em>, <em class="italic">Pablo Iranzo Gómez</em>, <em class="italic">Pedro Ibáñez Requena</em>, <em class="italic">Miguel Pérez Colino</em>, and <em class="italic">Scott McCarty</em></li>
</ul>
</div>
</body></html>