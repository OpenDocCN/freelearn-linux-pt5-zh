<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Working with Checks and States"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Checks and States</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Specifying how frequently to check a host or service</li><li class="listitem" style="list-style-type: disc">Changing thresholds for PING RTT and packet loss</li><li class="listitem" style="list-style-type: disc">Changing thresholds for disk usage</li><li class="listitem" style="list-style-type: disc">Scheduling downtime for a host or service</li><li class="listitem" style="list-style-type: disc">Managing brief outages with flapping</li><li class="listitem" style="list-style-type: disc">Adjusting flapping percentage thresholds for a service</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Introduction</h1></div></div></div><p>Once hosts and services are configured in Nagios Core, its behavior is primarily dictated by the checks it makes to ensure that hosts and services are operating as expected, and the state it concludes these hosts and services must be in as a result of those checks.</p><p>How often it's appropriate to check hosts and services,<a id="id123" class="indexterm"/>
<a id="id124" class="indexterm"/> and on what basis it's appropriate to flag a host or service as having problems, depends very much on the nature of the service and the importance of it running all the time. If a host on the other side of the world is being checked with PING, and during busy periods its round trip time is over 100ms, then this may not actually be a cause for concern at all, and perhaps not something to even flag a <code class="literal">WARNING</code> state over, let alone a <code class="literal">CRITICAL</code> one.</p><p>However, if the same host were on the local network where it would be appropriate to expect round trip times of less than 10ms, then a round trip time of more than 100ms could well be considered a grave cause for concern, signaling a packet storm or other problem with the local network, and we would want to notify the appropriate administrators immediately. Similarly, for hosts such as web servers, we may not be concerned by a response time of more than a second for a page on a busy budget shared web host for customers. But if the response time for the corporate website or a dedicated colocation customer was getting that bad, it might well be something to notify the web server administrator about.</p><p>Hosts and services are therefore not all created equal. Nagios Core provides several ways to define behaviors with more precision, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How often a host or service should be checked with its appropriate <code class="literal">check_command</code> plugin<a id="id125" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">How bad a check's results have to be before a <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> problem is flagged, if at all</li><li class="listitem" style="list-style-type: disc">Defining a downtime period for a host or service, so that Nagios Core knows not to expect it to operate during a specified period of time, often for upgrades or other maintenance</li><li class="listitem" style="list-style-type: disc">Whether to automatically tolerate flapping, or hosts and services seeming to go up and down a lot</li></ul></div><p>This chapter will use some common instances of problems with the preceding behaviors to give examples showing how to configure them.</p></div></div>
<div class="section" title="Specifying how frequently to check a host or service"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Specifying how frequently to check a host or service</h1></div></div></div><p>In this recipe, we'll configure a very important host to be checked every three minutes, and if Nagios Core finds it is <code class="literal">DOWN</code> as a result of the check failing, it will check again after a minute before it sends a notification about the state to its defined contact. We'll do this by customizing the definition of an existing host.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec87"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already. We'll use the example of <code class="literal">sparta.naginet</code>, a host defined in its own file.</p><p>You should also understand the basics of commands and plugins, in particular the meaning of the <code class="literal">check_command</code> directive<a id="id126" class="indexterm"/>. These are covered in the recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How to do it...</h2></div></div></div><p>We can customize the check frequency <a id="id127" class="indexterm"/>for a host as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition of your host in a different file, then move to its directory instead:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing your host definition, <a id="id128" class="indexterm"/>and find the definition within the file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi sparta.naginet.cfg</strong></span>
</pre></div><p>The host definition may look similar to the following:</p><div class="informalexample"><pre class="programlisting">define host {
    use                 linux-server
    host_name           sparta.naginet
    alias               sparta
    address             10.128.0.21
}</pre></div></li><li class="listitem">Add or edit the value of the <code class="literal">check_interval</code> directive to <code class="literal">3</code>:<div class="informalexample"><pre class="programlisting">define host {
    use                 linux-server
    host_name           sparta.naginet
    alias               sparta
    address             10.128.0.21
<span class="strong"><strong>    check_interval      3</strong></span>
}</pre></div></li><li class="listitem">Add or edit the value of the <code class="literal">retry_interval</code> directive<a id="id129" class="indexterm"/> to <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting">define host {
    use                 linux-server
    host_name           sparta.naginet
    alias               sparta
    address             10.128.0.21
    check_interval      3
<span class="strong"><strong>    retry_interval      1</strong></span>
}</pre></div></li><li class="listitem">Add or edit the value of <code class="literal">max_check_attempts</code> to <code class="literal">2</code>:<div class="informalexample"><pre class="programlisting">define host {
    use                 linux-server
    host_name           sparta.naginet
    alias               sparta
    address             10.128.0.21
    check_interval      3
    retry_interval      1
<span class="strong"><strong>    max_check_attempts  2</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, Nagios Core will run the relevant <code class="literal">check_command</code> plugin<a id="id130" class="indexterm"/> (probably something like <code class="literal">check-host-alive</code>) against this host every three minutes; if it fails, it will flag the host as down, check again one minute later, and only then send a notification to its defined contact if the second check fails too.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec89"/>How it works...</h2></div></div></div><p>The preceding configuration changed three properties of the <a id="id131" class="indexterm"/>host object type to effect the changes we needed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">check_interval</code><a id="id132" class="indexterm"/>: This defines how long to wait between successive checks of the host under normal conditions. We set this to <code class="literal">3</code>, or three minutes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">retry_interval</code><a id="id133" class="indexterm"/>: This defines how long to wait between follow-up checks of the host after first finding problems with it. We set this to <code class="literal">1</code>, or one minute.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max_check_attempts</code><a id="id134" class="indexterm"/>: This defines how many checks in total should be run before a notification is sent. We set this to <code class="literal">2</code> for two checks. This means that after the first failed check is run, Nagios Core will run another check a minute later, and will only send a notification if this check fails as well. If two checks have been run and the host is still in a problem state, it will go from a <code class="literal">SOFT</code> state to a <code class="literal">HARD</code> state.</li></ul></div><p>Note that setting these directives in a host that derives from a template, as is the case with our example, will override any of the same directives in the template.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec90"/>There's more...</h2></div></div></div><p>It's important to note that we can also define the units used by the <code class="literal">check_interval</code> and <code class="literal">retry_interval</code> command<a id="id135" class="indexterm"/>s. They only use minutes by default, checking the <code class="literal">interval_length</code> setting that's normally defined in the root configuration file for Nagios Core, by default <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>:</p><div class="informalexample"><pre class="programlisting">interval_length=60</pre></div><p>If we wanted to specify these periods in seconds instead, we could set this value to <code class="literal">1</code> instead of <code class="literal">60</code>:</p><div class="informalexample"><pre class="programlisting">interval_length=1</pre></div><p>This would allow us, for example, to set <code class="literal">check_interval</code> to <code class="literal">15</code>, to check a host every 15 seconds. Note that if we have a lot of hosts with such a tight checking schedule, it might overburden the Nagios Core process, particularly if the checks take a long time to complete.</p><p>Don't forget that changing these properties for a large number of hosts can be tedious, so if it's necessary to set these directives to some common value for more than a few hosts, then it may be appropriate to set the values in a host template and then have these hosts inherit from it. See the <span class="emphasis"><em>Using inheritance to simplify configuration</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <span class="emphasis"><em>Configuration Management</em></span> for details on this. Note that the same three directives also <a id="id136" class="indexterm"/>work for service declarations, and have the same meaning. We could define the same notification behavior for a service on <code class="literal">sparta.naginet</code> with a declaration similar to the following:</p><div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  HTTP
    check_command        check_http
    address              10.128.0.21
<span class="strong"><strong>    check_interval       3</strong></span>
<span class="strong"><strong>    retry_interval       1</strong></span>
<span class="strong"><strong>    max_check_attempts   2</strong></span>
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec91"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Scheduling downtime for a host </em></span>recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Using inheritance to simplify configuration</em></span> recipe in <a class="link" href="ch09.html" title="Chapter 9. Managing Configuration">Chapter 9</a>, <span class="emphasis"><em>Configuration Management</em></span></li></ul></div></div></div>
<div class="section" title="Changing thresholds for PING RTT and packet loss"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Changing thresholds for PING RTT and packet loss</h1></div></div></div><p>In this recipe, we'll set up a service for a host that monitors PING, and take a look at how to adjust the thresholds for the <code class="literal">WARNING</code> and <code class="literal">CRITICAL</code> states, <a id="id137" class="indexterm"/>
<a id="id138" class="indexterm"/>done using command arguments. We'll accomplish this by setting up a service for an existing host that's already being checked with a <code class="literal">check_command</code> plugin<a id="id139" class="indexterm"/>, such as <code class="literal">check-host-alive</code>. Our service will be used to monitor<a id="id140" class="indexterm"/> <a id="id141" class="indexterm"/>not whether the host is completely <code class="literal">DOWN</code>, but whether it's responding to PING requests within a reasonable period of time.</p><p>This could be useful to notify and assist in diagnosing problems with the actual connectivity of a service or host.</p><p>This recipe will therefore serve as a good demonstration of the concepts of supplying arguments to a command, and adjusting the <code class="literal">WARNING</code> and <code class="literal">CRITICAL</code> thresholds for a particular service.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec92"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host configured already, and using a <code class="literal">check_command</code> plugin<a id="id142" class="indexterm"/> of <code class="literal">check-host-alive</code>. We'll use the example of <code class="literal">sparta.naginet</code>, a host defined in its own file.</p><p>You should also understand the basics of how hosts and services fit together in a Nagios Core configuration, and be familiar with the use of commands and plugins via the <code class="literal">check_command</code> directive.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How to do it...</h2></div></div></div><p>We can add our PING service to the existing host with custom round trip time and packet loss thresholds as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the objects configuration <a id="id143" class="indexterm"/>directory for Nagios Core. The default is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition of your host in a different file, then move to its directory instead:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing your host definition:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi sparta.naginet.cfg</strong></span>
</pre></div></li><li class="listitem">Add the following definition to the end of the file. Of most interest here is the value for the <code class="literal">check_command</code> directive:<div class="informalexample"><pre class="programlisting">define service {
    use                  generic-service
    host_name            sparta.naginet
    service_description  PING
<span class="strong"><strong>    check_command        check_ping!100,20%!200,40%</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, Nagios Core will not only run a host check of <code class="literal">check-host-alive</code> against your original host to ensure that it's up, but it will also run a more stringent check of the PING responses from the machine as a service to check that it's adequately responsive:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the <span class="strong"><strong>Round Trip Time</strong></span> (<span class="strong"><strong>RTT</strong></span>) <a id="id144" class="indexterm"/>of the PING response is greater than 100ms (but less than 200ms), Nagios Core will flag a <code class="literal">WARNING</code> state.</li><li class="listitem" style="list-style-type: disc">If the RTT of the PING response is greater than 200ms, Nagios Core will flag a <code class="literal">CRITICAL</code> state.</li><li class="listitem" style="list-style-type: disc">If more than 20 percent (but less than 40 percent) of the PING requests receive no response, Nagios Core will flag a <code class="literal">WARNING</code> state.</li><li class="listitem" style="list-style-type: disc">If more than 40 percent of the PING requests receive no response, Nagios Core will flag a <code class="literal">CRITICAL</code> state.</li></ul></div><p>In both cases, a notification will be sent to the service's defined contacts if configured to do so.</p><p>Otherwise, this service works the same way as any other service, and appears in the web interface.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec94"/>How it works...</h2></div></div></div><p>The configuration we added for our existing host creates a new service with a <code class="literal">service_description</code> of <a id="id145" class="indexterm"/>PING. For <code class="literal">check_command</code>, we use the <code class="literal">check_ping</code> command, which uses the plugin of the same name. The interesting part here is what follows the <code class="literal">check_command</code> definition: the string <code class="literal">!100,20%!200,40%</code>.</p><p>In Nagios Core, a <code class="literal">!</code> character is used as a separator for arguments that should be passed to the command. In the case of <code class="literal">check_ping</code>, the first argument defines thresholds, or conditions that, if met, should make Nagios Core flag a <code class="literal">WARNING</code> state for the service. Similarly, the second argument defines the thresholds for a <code class="literal">CRITICAL</code> state<a id="id146" class="indexterm"/>.</p><p>Each of the two arguments are comprised of two comma-separated terms: the first number is the threshold for the RTT of the PING request and its response that should trigger a state, and the second number is the percentage of packet loss that should be tolerated before raising the same state.</p><p>This pattern of arguments is specific to <code class="literal">check_ping</code>; they would not work for other commands such as <code class="literal">check_http</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec95"/>There's more...</h2></div></div></div><p>If we want to look in a bit more detail at how these arguments are applied, we can inspect the command definition for <code class="literal">check_ping</code>. By default, this is in the <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code> file, and looks similar to the following:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_ping
    command_line  $USER1$/check_ping -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$ -p 5
}</pre></div><p>In the value for <code class="literal">command_line</code>, four macros are used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$USER1$</code><a id="id147" class="indexterm"/>: This expands to <code class="literal">/usr/local/nagios/libexec</code>, or the directory in which the Nagios Core plugins are normally kept, including <code class="literal">check_ping</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$HOSTADDRESS$</code><a id="id148" class="indexterm"/>: This expands to the hostname for the host or service definition in which the command is used. In this case, it expands to <code class="literal">10.128.0.21</code>, the value of the <code class="literal">address</code> directive for the <code class="literal">sparta.naginet</code> host.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG1$</code>:<a id="id149" class="indexterm"/> This expands to the value given for the first argument of the command, in our recipe's case, the string <code class="literal">100,20%</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG2$</code>:<a id="id150" class="indexterm"/> This expands to the value given for the second argument of the command; in our recipe's case, the string <code class="literal">200,40%</code>.</li></ul></div><p>The complete command-line call for our specific check with all these substitutions made would therefore look similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/usr/local/nagios/libexec/check_ping -H 10.128.0.21 -w 100,20% -c 200,40% -p 5</strong></span>
</pre></div><p>This command line makes use of four parameters of the <code class="literal">check_ping</code> program<a id="id151" class="indexterm"/>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-H</code>: This specifies the address of the <a id="id152" class="indexterm"/>host to check</li><li class="listitem" style="list-style-type: disc"><code class="literal">-w</code>: This specifies the <a id="id153" class="indexterm"/>thresholds for raising a <code class="literal">WARNING</code> state</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code>: This specifies the thresholds for <a id="id154" class="indexterm"/>raising a <code class="literal">CRITICAL</code> state</li><li class="listitem" style="list-style-type: disc"><code class="literal">-p</code>: This specifies the number of <a id="id155" class="indexterm"/>PING requests to send</li></ul></div><p>We can run this directly from the command line on the Nagios Core server to see what the results of the check might be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/libexec/check_ping -H 10.128.0.21 -w 100,20% -c 200,40% -p 5</strong></span>
</pre></div><p>The preceding command yields an output including the <code class="literal">OK</code> result of the check, and also some performance data, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>PING OK - Packet loss = 0%, RTA = 0.17 ms|rta=0.174000ms;100.000000;200.000000;0.000000 pl=0%;5;10;0</strong></span>
</pre></div><p>The arguments specified in the command are therefore used to customize the behavior of <code class="literal">check_command</code> for the particular host or service being edited.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec96"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Changing thresholds for disk usage</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new service</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Customizing an existing command</em></span> and <span class="emphasis"><em>Creating a new command</em></span> recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring PING for any host</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <span class="emphasis"><em>Monitoring Methods</em></span></li></ul></div></div></div>
<div class="section" title="Changing thresholds for disk usage"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Changing thresholds for disk usage</h1></div></div></div><p>In this recipe, we'll configure the Nagios Core server to check its own disk usage, and to flag a <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> state depending on how little free space is left on the disk. We'll accomplish this by adding a new service to the already defined <code class="literal">localhost</code> called <code class="literal">DISK</code>, which will run the <code class="literal">check_local_disk</code> command to examine the state of mounted volumes on the server.</p><p>Because burgeoning disk usage can creep up on any system administrator, and because of the dire effect it can have when a disk suddenly fills completely without any warning, this is amongst the more important things to monitor in any given network.</p><p>For simplicity, we'll demonstrate this only for the monitoring server itself, as a host called <code class="literal">localhost</code> on <code class="literal">127.0.0.1</code>. This is because the <code class="literal">check_disk</code> plugin can't directly check the disk usage of a remote server over a network. However, the principles discussed here could be adapted to running the check on a remote server using <code class="literal">check_nrpe</code>. The use of NRPE is discussed in all the recipes in <a class="link" href="ch06.html" title="Chapter 6. Enabling Remote Execution">Chapter 6</a>, <span class="emphasis"><em>Enabling Remote Execution</em></span>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec97"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with a definition for <code class="literal">localhost</code>, so that the monitoring host is able to check itself. A host definition for <code class="literal">localhost</code> is included in the sample configuration in <code class="literal">/usr/local/nagios/etc/objects/localhost.cfg</code>. You should also understand the basics of how hosts and services fit together in a Nagios Core configuration, and be familiar with the use of commands and plugins via the <code class="literal">check_command</code> directive.</p><p>We'll use the example of <code class="literal">olympus.naginet</code> as our Nagios Core server checking itself, with one block device on one disk, with its device file at <code class="literal">/dev/sda1</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec98"/>How to do it...</h2></div></div></div><p>We can add our <code class="literal">DISK</code> service to the existing host with custom usage thresholds as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the objects configuration directory for Nagios Core. The default is <code class="literal">/usr/local/nagios/etc/objects</code>. If you've put the definition for your host in a different file, move to its directory instead:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing your host definition:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi localhost.cfg</strong></span>
</pre></div></li><li class="listitem">Add the following definition to the end of the file. Of most interest here is the value for the <code class="literal">check_command</code> directive:<div class="informalexample"><pre class="programlisting">define service {
    use                  local-service
    host_name            localhost
    service_description  DISK
<span class="strong"><strong>    check_command        check_local_disk!10%!5%!/dev/sda1</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, a new service is created for <code class="literal">localhost</code> that checks the disk usage on <code class="literal">/dev/sda1</code>, and flags a <code class="literal">WARNING</code> state for the service if the free space is below 10 percent, and a <code class="literal">CRITICAL</code> state if it is below 5 percent.</p><p>In both cases, a notification will be sent to the service's defined contacts, if configured to do so.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec99"/>How it works</h2></div></div></div><p>The configuration we added for our existing host creates a new service with a <code class="literal">service_description</code> of <code class="literal">DISK</code>. For <code class="literal">check_command</code>, we use the <code class="literal">check_local_disk</code> command, which in turn uses the <code class="literal">check_disk</code> plugin to check the local machine's disks. The interesting part here is what follows the <code class="literal">check_local_disk</code> definition: the string <code class="literal">!10%!5%!/dev/sda1</code>.</p><p>In Nagios Core, a <code class="literal">!</code> character is used as a separator for arguments that should be passed to the command. In the case of <code class="literal">check_local_disk</code>, the first two arguments define thresholds, or conditions that, if met, should make Nagios Core flag a <code class="literal">WARNING</code> state (first argument, 10 percent) or a <code class="literal">CRITICAL</code> state (second argument, 5 percent) for the service. The third argument defines the device name of the disk to check, <code class="literal">/dev/sda1</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec100"/>There's more...</h2></div></div></div><p>If we want to look in a bit more detail at how these arguments are applied, we can inspect the command definition for <code class="literal">check_local_disk</code>. By default, this is in the file <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code>, and looks similar to the following:</p><div class="informalexample"><pre class="programlisting">define command {
    command_name  check_local_disk
    command_line  $USER1$/check_disk -w $ARG1$ -c $ARG2$ -p $ARG3$
}</pre></div><p>In this case, <code class="literal">command_name</code> and the name of the plugin used in the <code class="literal">command_line</code> are not the same.</p><p>In the value for <code class="literal">command_line</code>, four macros are used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$USER1$</code>: This expands to<code class="literal"> /usr/local/nagios/libexec</code>, or the directory in which the Nagios Core plugins are normally kept, including <code class="literal">check_disk</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG1$</code>: This expands to the value given for the first argument of the command; in this case, the string <code class="literal">10%</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG2$</code>: This expands to the value given for the second argument of the command; in this case, the string <code class="literal">5%</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$ARG3$</code>: This expands to the value given for the third argument of the command; in this case, the string <code class="literal">/dev/sda1</code>.</li></ul></div><p>The complete command-line call for our specific check with all these substitutions made would therefore be as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/usr/local/nagios/libexec/check_disk -w 10% -c 5% -p /dev/sda1</strong></span>
</pre></div><p>This command line makes use of three parameters of the <code class="literal">check_disk</code> program:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-w</code><a id="id156" class="indexterm"/>: This specifies the thresholds for raising a <code class="literal">WARNING</code> state</li><li class="listitem" style="list-style-type: disc"><code class="literal">-c</code>: This specifies the thresholds for <a id="id157" class="indexterm"/>raising a <code class="literal">CRITICAL</code> state</li><li class="listitem" style="list-style-type: disc"><code class="literal">-p</code>: This specifies the device file <a id="id158" class="indexterm"/>for the disk to check</li></ul></div><p>We can run this directly from the command line on the Nagios Core server to see what the results of the check might be:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/libexec/check_disk -w 10% -c 5% -p /dev/sda1</strong></span>
</pre></div><p>The output includes both the <code class="literal">OK</code> result of the check, and also some performance data:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>DISK OK - free space: / 2575 MB (71% inode=78%);| /=1044MB;3432;3051;0;3814</strong></span>
</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec101"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Changing thresholds for disk usage</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a new service</em></span> recipe in <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, <span class="emphasis"><em>Understanding Hosts, Services, and Contacts</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Customizing an existing command</em></span> and <span class="emphasis"><em>Creating a new command</em></span> recipes in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>, <span class="emphasis"><em>Working with Commands and Plugins</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Monitoring PING for any host</em></span> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <span class="emphasis"><em>Monitoring Methods</em></span></li></ul></div></div></div>
<div class="section" title="Scheduling downtime for a host or service"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Scheduling downtime for a host or service</h1></div></div></div><p>In this recipe, we'll learn how to schedule downtime for a host or service in Nagios Core. This is useful for elegantly suppressing notifications for some predictable period of time; a very good example is when servers require downtime to be upgraded, or to have their hardware checked.</p><p>In this example, we'll demonstrate scheduling <a id="id159" class="indexterm"/>downtime for a host named <code class="literal">sparta.naginet</code>, and we'll examine the changes it makes in the web interface.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec102"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with a definition for at least one host and at least one service, and some idea of when you would like your downtime to be scheduled. You should also have a working web interface, per the QuickStart installation of Nagios Core 3.0.</p><p>You should also have Nagios Core configured to process external commands, and have given your web interface user the permissions to apply them. If you are logging in as the <code class="literal">nagiosadmin</code> user per the recommended quick start guide, then you can check this is the case with the following directive in <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>:</p><div class="informalexample"><pre class="programlisting">check_external_commands=1</pre></div><p>Permissions to submit external commands from the web interface are defined in <code class="literal">/usr/local/nagios/etc/cgi.cfg</code>; check that your username is included in these directives:</p><div class="informalexample"><pre class="programlisting">authorized_for_all_service_commands=nagiosadmin
authorized_for_all_host_commands=nagiosadmin</pre></div><p>If you have followed the Nagios Core QuickStart guides, then you will probably find this is already working: <a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/quickstart.html">http://nagios.sourceforge.net/docs/3_0/quickstart.html</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec103"/>How to do it...</h2></div></div></div><p>We can set up a fixed period of scheduled downtime for our <a id="id160" class="indexterm"/>
<a id="id161" class="indexterm"/>host and service as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log into the web interface for Nagios Core.</li><li class="listitem">Click <span class="strong"><strong>Hosts</strong></span> in the left menu:<div class="mediaobject"><img src="graphics/5566_03_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Click on the host's name in the table that comes up, to view the details for that host:<div class="mediaobject"><img src="graphics/5566_03_02.jpg" alt="How to do it..."/></div></li><li class="listitem">Click on <span class="strong"><strong>Schedule downtime for this host</strong></span> in the <span class="strong"><strong>Host Commands</strong></span> menu:<div class="mediaobject"><img src="graphics/5566_03_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Fill out the fields in the resulting form, including the following details:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Host Name</strong></span>: The name of the host for which you're scheduling downtime. This should have been filled out for you.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Author</strong></span>: Your name, for records of <a id="id162" class="indexterm"/><a id="id163" class="indexterm"/>who scheduled the downtime. This may be greyed out and just say <span class="strong"><strong>Nagios Admin</strong></span>; that's fine.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Comment</strong></span>: Some comment explaining the reason for the downtime.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Start Time</strong></span>: The time at which the scheduled downtime should begin, and when the state notifications end.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>End Time</strong></span>: The time at which the scheduled downtime should end, and when the state notifications resume.</li></ul></div><div class="mediaobject"><img src="graphics/5566_03_04.jpg" alt="How to do it..."/></div><p>In this case, our downtime will be from 8:00 PM to 9:00 PM on the 15th of June, 2012. </p></li><li class="listitem">Click on <span class="strong"><strong>Commit</strong></span> to submit the downtime definition, and then <span class="strong"><strong>Done</strong></span> in the screen that follows.</li></ol></div><p>With this done, we can safely bring the <code class="literal">sparta.naginet</code> host down between the nominated times, and any notifications for the host and any of its services will be suppressed until the downtime is over.</p><p>Note that restarting Nagios Core is not required for <a id="id164" class="indexterm"/>
<a id="id165" class="indexterm"/>
<a id="id166" class="indexterm"/>this step, as it usually would be for changes made to Nagios Core's configuration files. The change is done "on the fly".</p><p>Note also that comments now appear in the detailed information for both the host and service, defining the downtime and including the reason specified for it.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec104"/>How it works...</h2></div></div></div><p>The preceding steps nominate a period of downtime for both the <code class="literal">sparta.naginet</code> server and all of its services. This accomplishes two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It suppresses all notifications (whether e-mails or anything else) for the host or service for the appropriate time period, including <code class="literal">RECOVERY</code> notifications. The only exceptions are the <code class="literal">DOWNTIMESTART</code> and <code class="literal">DOWNTIMEEND</code> notifications.</li><li class="listitem" style="list-style-type: disc">It adds a comment to the host or service showing the scheduled downtime, for the benefit of anyone else who might be using the web interface.</li></ul></div><p>Nagios Core keeps track of any downtime defined for all the hosts and services, and prevents the notifications it would normally <a id="id167" class="indexterm"/>
<a id="id168" class="indexterm"/>send out during that time. Note that it will still run its checks and record the state of both the hosts and services even during downtime. All that is suppressed are the notifications, and not the actual checks.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec105"/>There's more...</h2></div></div></div><p>Note that the downtime for individual services can be applied in much the same way, by clicking on <span class="strong"><strong>Schedule downtime for this service</strong></span> in the web interface, under <span class="strong"><strong>Service Commands</strong></span>.</p><p>What was defined in this recipe was a method for defining fixed downtime, where we know ahead of time when the host or its services are likely to be unavailable. If we don't actually know what time the unavailability will start, but we do know how long it's likely to last, then we can define a period of flexible downtime. This means that the downtime can start any time within the nominated period, and will last for the length of time we specify from that point.</p><p>A notification event is also fired when the host or service begins the downtime, called <code class="literal">DOWNTIMESTART</code>, and another when the downtime ends, called <code class="literal">DOWNTIMEEND</code>. This may be a useful notification to send to the relevant contact or contact group if they'd like to be notified when this happens. This can be arranged by ensuring that the host or service is configured to send these messages, by including the <code class="literal">s</code> flag in the <code class="literal">notification_options</code> directive for both hosts and services, and correspondingly in the contact definition:</p><div class="informalexample"><pre class="programlisting">notification_options  d,u,r,f,s</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec106"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Managing brief outages with flapping</em></span> and <span class="emphasis"><em>Adjusting flapping percentage thresholds for a service</em></span> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Specifying which states to be notified about</em></span> and <span class="emphasis"><em>Tolerating a certain number of failed checks</em></span> recipes in <a class="link" href="ch04.html" title="Chapter 4. Configuring Notifications">Chapter 4</a>, <span class="emphasis"><em>Configuring Notifications</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding comments on hosts or services in web interface</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>, <span class="emphasis"><em>Working with the Web Interface</em></span></li></ul></div></div></div>
<div class="section" title="Managing brief outages with flapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Managing brief outages with flapping</h1></div></div></div><p>In this recipe, we'll learn how to use Nagios Core's state flapping detection and handling to avoid sending excessive notifications when a host or service changes its state too frequently. This is useful in circumstances where a host or service is changing between <code class="literal">OK</code> to <code class="literal">WARNING</code> to <code class="literal">CRITICAL</code> states too frequently within the last 21 checks. If the percentage of state changes is too high, Nagios Core will suppress further notifications and add an icon and comment to the host or service showing that it is flapping.</p><p>Flap detection is normally enabled in the QuickStart configuration for Nagios Core, and is part of the sample  <code class="literal">generic-host</code> host template and the <code class="literal">generic-service</code> service template. It's therefore likely that it's already enabled on most servers, and we only need to check that it's still working.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec107"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host and one service configured already. You should also have access to a working web interface for the Nagios Core server. It would be helpful if you are monitoring a test service that you can bring up and down to trigger the flap detection to test it; an unused webserver might be good for this.</p><p>You should be familiar with the way hosts and services change state as a result of their checks and the different states corresponding to hosts and services in order to understand the basics of how flap detection works.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec108"/>How to do it...</h2></div></div></div><p>We can check whether or not flap detection is enabled for our Nagios Core server, our hosts, and our services as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the configuration directory for Nagios Core. The default is <code class="literal">/usr/local/nagios/etc</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc</strong></span>
</pre></div></li><li class="listitem">Edit the <code class="literal">nagios.cfg</code> file. <div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi nagios.cfg</strong></span>
</pre></div></li><li class="listitem">Look for an existing definition for the <code class="literal">enable_flap_detection</code> directive, and check that it is set to <code class="literal">1</code>:<div class="informalexample"><pre class="programlisting">enable_flap_detection=1</pre></div></li><li class="listitem">If this was not set to <code class="literal">1</code>, then after we've changed it, we will probably also need to at least temporarily disable the <code class="literal">use_retained_program_state</code> directive in the same file:<div class="informalexample"><pre class="programlisting">use_retained_program_state=0</pre></div></li><li class="listitem">Edit the file for our particular hosts and or services. We should check that at least one of the following is the case:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The host or service inherits from a template that has the <code class="literal">enable_flap_detection</code> directive set to <code class="literal">1</code>. For example, both the <code class="literal">generic-host</code> and <code class="literal">generic-service</code> templates defined by default in <code class="literal">/usr/local/nagios/etc/objects/templates.cfg</code> do this.</li><li class="listitem" style="list-style-type: disc">The host or service itself has the <code class="literal">enable_flap_detection</code> directive set to <code class="literal">1</code> in its own definition.<p>In the latter case, the configuration for the host or service might look similar to the following code snippet:</p><div class="informalexample"><pre class="programlisting">define host {
    ...
<span class="strong"><strong>    flap_detection_enabled 1</strong></span>
}
define service {
    ...
<span class="strong"><strong>    flap_detection_enabled 1</strong></span>
}</pre></div></li></ul></div></li><li class="listitem">If any of the preceding configuration was changed, validate the new configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li><li class="listitem">Check that for the hosts or services for which flap detection is wanted, the word <span class="strong"><strong>ENABLED</strong></span> appears in the details for that host or service:<div class="mediaobject"><img src="graphics/5566_03_09.jpg" alt="How to do it..."/></div></li></ol></div><p>With this done, if a host or service changes its state too frequently within 21 checks, then it will be flagged as flapping, and will appear with a custom icon in views of that host or service:</p><div class="mediaobject"><img src="graphics/5566_03_10.jpg" alt="How to do it..."/></div><p>A comment is also placed on the host or service explaining what has happened for the benefit of anyone viewing the host or service in the web interface, who might perhaps be wondering why notifications have stopped:</p><div class="mediaobject"><img src="graphics/5566_03_11.jpg" alt="How to do it..."/></div><p>There will also be an indicator on the details for the host or service defining whether the host or service is flapping:</p><div class="mediaobject"><img src="graphics/5566_03_12.jpg" alt="How to do it..."/></div><p>For hosts or services that don't have flap detection enabled, this particular field simply reads <span class="strong"><strong>N/A</strong></span>, and the <span class="strong"><strong>Flap Detection</strong></span> field below it will show as <span class="strong"><strong>DISABLED</strong></span>.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec109"/>How it works...</h2></div></div></div><p>The logic behind determining flap detection is actually quite complex. For our purposes, it suffices to explain flap detection as being based on whether a host or service has changed state within its last 21 checks too often—with the thresholds usually expressed as a percentage.</p><p>This is discussed in great detail including the formulae that are used to determine flapping state in the Nagios Core 3.0 documentation, available online at the following URL:</p><p>
<a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/flapping.html">http://nagios.sourceforge.net/docs/3_0/flapping.html</a>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec110"/>There's more...</h2></div></div></div><p>A common cause of flapping is that checks are too stringent. As an example, if you are checking a shared web server's response time is less than 50ms while the server is busy, checks might pass and fail without actually giving an accurate reflection of whether the service is doing its job. In this case, it would be appropriate to loosen the thresholds of the service by increasing its percentage thresholds, so that it isn't quite so ready to flag a <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> state over things that aren't actually very worrisome. Flap detection can help diagnose these sorts of cases.</p><p>We can also enable or disable flap detection for a host via the web interface; in the details screen for both hosts and services, a menu item is available under <span class="strong"><strong>Host Commands</strong></span> labeled <span class="strong"><strong>Enable/Disable flap detection for this host</strong></span>, and under <span class="strong"><strong>Service Commands</strong></span> there's another labeled <span class="strong"><strong>Enable/Disable flap detection for this service</strong></span>.</p><p>These may be useful when we want to turn flap detection on or off for a particular host or service temporarily, perhaps because under certain circumstances it is or is not appropriate to use the feature. For permanent setup and for clarity, it would be best to include it explicitly in the configuration as shown in the recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec111"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adjusting flapping percentage thresholds for a service</em></span> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Tolerating a certain number of failed checks</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Configuring Notifications">Chapter 4</a>, <span class="emphasis"><em>Configuring </em></span><span class="emphasis"><em>Notifications</em></span></li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Adding comments on hosts or services in web interface</em></span> recipe in <a class="link" href="ch07.html" title="Chapter 7. Using the Web Interface">Chapter 7</a>, <span class="emphasis"><em>Working with the Web Interface</em></span></li></ul></div></div></div>
<div class="section" title="Adjusting flapping percentage thresholds for a service"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Adjusting flapping percentage thresholds for a service</h1></div></div></div><p>In this recipe, we'll learn how to adjust the percentage thresholds for host or service flap detection. This means that we can adjust how frequently a host or service has to change state within its last 21 checks, before Nagios Core will <a id="id169" class="indexterm"/>
<a id="id170" class="indexterm"/>conclude that it is flapping, and suppress notifications until its state becomes stable again.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec112"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server with at least one host and one service configured already. You should also have access to a working web interface for the Nagios Core server.</p><p>You should be familiar with the way hosts and services change state as a result of their checks and the different states corresponding to hosts and services, to understand the basics of how flap detection works. Flap detection should also already be enabled and working for the appropriate hosts and services.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec113"/>How to do it...</h2></div></div></div><p>We can adjust the thresholds for flap detection for a specific host or service as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Change to the <code class="literal">objects</code> configuration directory for Nagios Core. The default is <code class="literal">/usr/local/nagios/etc/objects</code>.<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /usr/local/nagios/etc/objects</strong></span>
</pre></div></li><li class="listitem">Edit the file containing the definition for the host or service for which we want to set the thresholds:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi sparta.naginet.cfg</strong></span>
</pre></div></li><li class="listitem">Within the host or service definition, set the <code class="literal">low_flap_threshold</code> and/or <code class="literal">high_flap_threshold</code> values to appropriate percentages:<div class="informalexample"><pre class="programlisting">define host {
    ...
<span class="strong"><strong>    high_flap_threshold 50.0</strong></span>
<span class="strong"><strong>    low_flap_threshold 25.0</strong></span>
}
define service {
    ...
<span class="strong"><strong>    high_flap_threshold 45.0</strong></span>
<span class="strong"><strong>    low_flap_threshold 20.0</strong></span>
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong></span>
<span class="strong"><strong># /etc/init.d/nagios restart</strong></span>
</pre></div></li></ol></div><p>With this done, the flapping thresholds for the host or service should be changed appropriately for future checks.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec114"/>How it works...</h2></div></div></div><p>The preceding configuration changes include the following directives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">high_flap_threshold</code><a id="id171" class="indexterm"/>: A host or service that is changing state by a certain percentage of the time must exceed this percentage threshold, before it is determined to be flapping.</li><li class="listitem" style="list-style-type: disc"><code class="literal">low_flap_threshold</code><a id="id172" class="indexterm"/>: If a host or service is already in the flapping state, then its state change percentage must fall below this threshold before the flapping state will end.</li></ul></div><p>For a detailed breakdown of how the state change <a id="id173" class="indexterm"/>
<a id="id174" class="indexterm"/>percentage is calculated, see the Nagios Core 3.0 documentation online at the following URL:</p><p>
<a class="ulink" href="http://nagios.sourceforge.net/docs/3_0/flapping.html">http://nagios.sourceforge.net/docs/3_0/flapping.html</a>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec115"/>There's more...</h2></div></div></div><p>If appropriate, we can also set a global default for hosts and services' flap thresholds with the following directives in <code class="literal">/usr/local/nagios/etc/nagios.cfg</code>. The following values are examples:</p><div class="informalexample"><pre class="programlisting">high_host_flap_threshold=50.0
low_host_flap_threshold=25.0
high_service_flap_threshold=45.0
low_service_flap_threshold=20.0</pre></div><p>These values correspond to the percentages of <a id="id175" class="indexterm"/>state change, in just the same way that the per-host and per-service configurations do.</p><p>Note that there are separate directives for hosts and services in this case. These values are also overridden if you specify thresholds for a particular service or host, as we did in the recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec116"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Managing brief outages with flapping</em></span> recipe in this chapter</li></ul></div></div></div></body></html>