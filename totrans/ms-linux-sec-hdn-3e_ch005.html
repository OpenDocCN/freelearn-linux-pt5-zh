<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="packt"/>
<title>4 Securing Your Server with a Firewall - Part 1</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>

</head>
<body>
<section id="securing-your-server-with-a-firewall---part-1" class="level1 pkt" data-number="5">
<h1 data-number="5">4 Securing Your Server with a Firewall - Part 1</h1>
<section id="join-our-book-community-on-discord-3" class="level2" data-number="5.1">
<h2 data-number="5.1">Join our book community on Discord</h2>
<p><a href="https://packt.link/SecNet">https://packt.link/SecNet</a></p>
<figure>
<img src="../media/file33.png" style="width:10em" />
</figure>
<p>Security is one of those things that's best done in layers. Security-in-depth, we call it. So, on any given corporate network, you will find a firewall appliance separating the Internet from the <strong>demilitarized zone</strong> (<strong>DMZ</strong>), where your Internet-facing servers are kept. You will also find a firewall appliance between the DMZ and the internal LAN, and firewall software installed on each individual server and client. We want to make it as tough as possible for intruders to reach their final destinations within our networks.</p>
<p>Interestingly, though, of all the major Linux distros, only the SUSE distros and the Red Hat type distros come with a firewall already set up and enabled. Newer versions of Ubuntu come with a pre-configured firewall, but you need to activate it by running a couple of simple commands.</p>
<p>Since the focus of this book is on hardening our Linux servers, we'll focus this chapter on that last level of defense: the firewalls on our servers and clients. We'll cover both of the command-line netfilter interfaces, which are <strong>iptables</strong> and <strong>nftables</strong>.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>An overview of the Linux firewall</li>
<li>An overview of iptables</li>
<li>An overview of nftables</li>
</ul>
<p>In the next chapter, we'll cover <strong>ufw</strong> and <strong>firewalld</strong>, which are handy front-ends for iptables and nftables.</p>
</section>
<section id="technical-requirements" class="level2" data-number="5.2">
<h2 data-number="5.2">Technical requirements</h2>
<p>The code files for this chapter are available here: <a href="https://github.com/PacktPublishing/Mastering-Linux-Security-and-Hardening-Second-Edition">https://github.com/PacktPublishing/Mastering-Linux-Security-and-Hardening-Second-Edition</a>.</p>
</section>
<section id="an-overview-of-the-linux-firewall" class="level2" data-number="5.3">
<h2 data-number="5.3">An overview of the Linux firewall</h2>
<p>In a typical business setting, especially in larger enterprises, you may encounter various types of firewalls in various places that can provide various types of functionality. Here are some examples:</p>
<ul>
<li>Edge devices that separate the Internet from an internal network translate routable public IP addresses to non-routable private IP addresses. They can also provide various types of access control to keep out unauthorized people. By also providing various types of packet inspection services, they can help prevent attacks on the internal network, keep out malware, and prevent leakage of sensitive information from the internal network to the Internet.</li>
<li>Large enterprise networks are normally divided into subnetworks, or <em>subnets</em>, with each corporate department having a subnet to call its own. Best practice dictates separating the subnets with firewalls. This helps ensure that only authorized personnel can access any given subnet.</li>
<li>And, of course, you also have firewalls running on the individual servers and workstations. By providing a form of access control, they can help prevent an intruder who has compromised one machine from performing a lateral movement to another machine on the network. They can be also configured to prevent certain types of port scanning and <strong>denial-of-service</strong> (<strong>DoS</strong>) attacks.</li>
</ul>
<p>For the first two items in the preceding list, you would likely see dedicated firewall appliances and teams of firewall administrators taking care of them. The third item in the list is where you, the Linux professional, come into the picture. In this chapter and the next, we'll look at the firewall technologies that come packaged with your Linux server and Linux workstation distros.</p>
<p>The name of the Linux firewall is <strong>netfilter</strong>. This netfilter code is compiled into the Linux kernel, and is what performs the actual packet filtering. There’s no way for human users to directly interface with netfilter, which means that we need some sort of helper program to interface with netfilter for us. There have been three helper programs, which are:</p>
<ul>
<li><strong>ipchains</strong>: This was the first one, and was part of the Linux kernel up through kernel version 2.4. It’s now ancient history, so we won’t say any more about it.</li>
<li><strong>iptables</strong>: This replaced ipchains in Linux kernel version 2.6. It’s still used in a lot of Linux distros, but is rapidly disappearing.</li>
<li><strong>nftables</strong>: This is the new kid on the block, and is rapidly replacing iptables. As we’ll see later, it has a lot of advantages over the older iptables.</li>
<li>All three of these helper programs do two things for us:</li>
<li>They provide a command-line interface for human users.</li>
<li>They take the commands that human users input and inject them into netfilter.</li>
<li>Making things even more interesting is that we also have helper programs for our helper programs. The <strong>Uncomplicated Firewall</strong> (<strong>ufw</strong>) was created by Ubuntu developers, and is a front-end for either iptables or nftables. Ubuntu comes with ufw already installed, and you can install ufw yourself on Debian and other Debian-type distros. On the Red Hat side, we have firewalld, which is also a front-end for either iptables or nftables. Note that firewalld is installed and active by default on all Red Hat-type distros, as well as the SUSE distros. It’s available as an option for Ubuntu and Debian. Both ufw and firewalld can vastly simplify the process of setting up a proper firewall. Still though, it’s sometimes helpful to know how to work with either bare iptables or bare nftables. So, let’s begin by looking at iptables.</li>
</ul>
</section>
<section id="an-overview-of-iptables" class="level2" data-number="5.4">
<h2 data-number="5.4">An overview of iptables</h2>
<p>As I’ve mentioned, iptables is one of two command-line utilities that we can currently use to directly manage netfilter. It was originally introduced as a feature of Linux kernel version 2.6, so it's been around for a long time. With iptables, you do have a few advantages:</p>
<ul>
<li>It's been around long enough that most Linux admins already know how to use it.</li>
<li>It's easy to use iptables commands in shell scripts to create your own custom firewall configuration.</li>
<li>It has great flexibility in that you can use it to set up a simple port filter, a router, or a virtual private network.</li>
<li>It still comes pre-installed on some Linux distros, although it’s rapidly getting replaced by nftables.</li>
<li>It's very well documented and has free of charge, book-length tutorials available on the Internet.</li>
</ul>
<p>However, as you might know, there are also a few disadvantages:</p>
<ul>
<li>IPv4 and IPv6 each require their own special implementation of iptables. So, if your organization still needs to run IPv4 while in the process of migrating to IPv6, you'll have to configure two firewalls on each server and run a separate daemon for each. (One for IPv4, the other for IPv6.)</li>
<li>If you need to do MAC bridging, that requires <strong>ebtables</strong>, which is the third component of iptables, with its own unique syntax.</li>
<li><strong>arptables</strong>, the fourth component of iptables, also requires its own daemon and syntax.</li>
<li>Whenever you add a rule to a running iptables firewall, the entire iptables ruleset has to be reloaded, which can have an impact on performance.</li>
</ul>
<p>Until recently, just plain iptables was the default firewall manager on every Linux distro. It still is on some distros, but Red Hat Enterprise Linux 7 and all of its offspring now use the new firewalld as an easier-to-use frontend for configuring iptables rules. Ubuntu comes with <strong>Uncomplicated Firewall</strong> (<strong>ufw</strong>), which is also an easy to use frontend for iptables on all Ubuntu versions up through 20.04.</p>
<p>In this chapter, we'll discuss setting up iptables firewall rules for both IPv4 and IPv6.</p>
<section id="mastering-the-basics-of-iptables" class="level3" data-number="5.4.1">
<h3 data-number="5.4.1">Mastering the basics of iptables</h3>
<p>iptables consists of five tables of rules, each with its own distinct purpose:</p>
<ul>
<li><strong>Filter table</strong>: For basic protection of our servers and clients, this might be the only table that we use.</li>
<li><strong>Network Address Translation (NAT) table</strong>: NAT is used to connect the public Internet to private networks.</li>
<li><strong>Mangle table</strong>: This is used to alter network packets as they go through the firewall.</li>
<li><strong>Raw table</strong>: This is for packets that don't require connection tracking.</li>
<li><strong>Security table</strong>: The security table is only used for systems that have SELinux installed.</li>
</ul>
<p>Since we're currently only interested in basic host protection, we will only look at the filter table for the time being. (In a few moments, I'll show you a couple of fancy tricks that we can do with the mangle table.) Each table consists of chains of rules, and the filter table consists of the <code>INPUT</code>, <code>FORWARD</code>, and <code>OUTPUT</code> chains. Let’s look at this on an Ubuntu 20.04 virtual machine.</p>
<blockquote>
<p>Ubuntu 20.04 LTS comes with iptables, and Ubuntu 22.04 comes with nftables. However, even if you’re running Ubuntu 22.04 or newer, you’ll still want to learn how to work with iptables commands. The first reason is that Ubuntu 22.04 includes a cool feature that automatically translates iptables commands to nftables commands. This allows you to use any iptables scripts that you might already have without worrying about converting them to nftables format. The second reason is that once we start talking about Ubuntu’s <strong>Uncomplicated Firewall</strong> (<strong>ufw</strong>), you’ll see that you’ll still need to know iptables commands in order to configure it, regardless of which Ubuntu version that you’re using.</p>
</blockquote>
<p>First, we'll look at our current configuration by using the <code>sudo iptables -L</code> command:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -L
 [sudo] password for donnie:
 Chain INPUT (policy ACCEPT)
 target prot opt source destination
 Chain FORWARD (policy ACCEPT)
 target prot opt source destination
 Chain OUTPUT (policy ACCEPT)
 target prot opt source destination
 donnie@ubuntu:~$</code></pre>
</div>
<p>Remember that we said that you need a separate component of iptables to deal with IPv6. Here, we'll use the <code>sudo ip6tables -L</code> command:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo ip6tables -L
 Chain INPUT (policy ACCEPT)
 target prot opt source destination
 Chain FORWARD (policy ACCEPT)
 target prot opt source destination
 Chain OUTPUT (policy ACCEPT)
 target prot opt source destination
 donnie@ubuntu:~$</code></pre>
</div>
<p>In both cases, you can see that there are no rules and that the machine is wide open. (Understand that Ubuntu actually does come with a pre-configured Uncomplicated Firewall and you’ll also see some output that is specific to it, but we’ll ignore that for the time-being so that we can work directly with iptables.) We'll start by creating a rule that will allow us to pass incoming packets from servers that our host has requested a connection to:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</code></pre>
</div>
<p>Here's the breakdown of this command:</p>
<ul>
<li><strong>-A INPUT</strong>: <code>-A</code> places a rule at the end of the specified chain, which in this case is the <code>INPUT</code> chain. We would have used <code>-I</code> had we wanted to place the rule at the beginning of the chain.</li>
<li><strong>-m</strong>: This calls in an iptables module. In this case, we're calling in the <code>conntrack</code> module to track connection states. This module allows <code>iptables</code> to determine whether our client has made a connection to another machine, for example.</li>
<li><strong>--ctstate</strong>: The <code>ctstate</code>, or connection state, portion of our rule is looking for two things. First, it's looking for a connection that the client established with a server. Then, it looks for the related connection that's coming back from the server in order to allow it to connect to the client. So, if a user were to use a web browser to connect to a website, this rule would allow packets from the web server to pass through the firewall to get to the user's browser.</li>
<li><strong>-j</strong>: This stands for jump. Rules jump to a specific target, which in this case is <code>ACCEPT</code>. (Please don't ask me who came up with this terminology.) So, this rule will accept packets that have been returned from the server to which the client has requested a connection.</li>
</ul>
<p>Our new ruleset looks like this:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -L
 Chain INPUT (policy ACCEPT)
 target prot opt source destination
 ACCEPT all -- anywhere anywhere ctstate RELATED,ESTABLISHED
 Chain FORWARD (policy ACCEPT)
 target prot opt source destination
 Chain OUTPUT (policy ACCEPT)
 target prot opt source destination
 donnie@ubuntu:~$</code></pre>
</div>
<p>Next, we'll open up port <code>22</code> so that we can connect through Secure Shell:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT</code></pre>
</div>
<p>Here's the breakdown:</p>
<ul>
<li><strong>-A INPUT</strong>: As before, we want to place this rule at the end of the <code>INPUT</code> chain with <code>-A</code>.</li>
<li><strong>-p tcp</strong>: <code>-p</code> indicates the protocol that this rule affects. This rule affects the TCP protocol, of which Secure Shell is a part.</li>
<li><strong>--dport ssh</strong>: When an option name consists of more than one letter, we need to precede it with two dashes, instead of just one. The <code>--dport</code> option specifies the destination port on which we want this rule to operate. (Note that we could have also listed this portion of the rule as <code>--dport 22</code> since <code>22</code> is the number of the SSH port.)</li>
<li><strong>-j ACCEPT</strong>: If we put this all together with <code>-j ACCEPT</code>, then we have a rule that allows other machines to connect to this one through Secure Shell.</li>
</ul>
<p>Now, let's say that we want this machine to be a DNS server. For that, we need to open port <code>53</code> for both the TCP and the UDP protocols:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo iptables -A INPUT -p tcp --dport 53 -j ACCEPT
sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT</code></pre>
</div>
<p>Finally, we have an almost complete, usable ruleset for our <code>INPUT</code> chain:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -L
 Chain INPUT (policy ACCEPT)
 target prot opt source destination
 ACCEPT all -- anywhere anywhere ctstate
 RELATED,ESTABLISHED
 ACCEPT tcp -- anywhere anywhere tcp dpt:ssh
 DROP all -- anywhere anywhere
 Chain FORWARD (policy ACCEPT)
 target prot opt source destination
 Chain OUTPUT (policy ACCEPT)
 target prot opt source destination
 donnie@ubuntu:~$</code></pre>
</div>
<p>However, this is only <em>almost</em> complete, because there's still one little thing that we forgot. That is, we need to allow traffic for the loopback interface. This is okay because it gives us a good chance to see how to insert a rule where we want it if we don't want it at the end. In this case, we'll insert the rule at <code>INPUT 1</code>, which is the first position of the <code>INPUT </code>chain:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo iptables -I INPUT 1 -i lo -j ACCEPT</code></pre>
</div>
<p>Before you inserted the <code>ACCEPT</code> rule for the <code>lo</code> interface, you may have noticed that <code>sudo</code> commands were taking a long time to complete and that you were getting sudo: unable to resolve host. . .Resource temporarily unavailable messages. That's because <code>sudo</code> needs to know the machine's hostname so that it can know which rules are allowed to run on a particular machine. It uses the loopback interface to help resolve the hostname. If the <code>lo</code> interface is blocked, it takes longer for <code>sudo </code>to resolve the hostname.</p>
<p>Our ruleset now looks like this:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             anywhere            
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
donnie@ubuntu:~$</code></pre>
</div>
<p>Note how port <code>53</code> is listed as the domain port. To see port numbers instead of port names, we can use the <code>-n</code> switch:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo iptables -L -n
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:53
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            udp dpt:53
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
donnie@ubuntu3:~$</code></pre>
</div>
<p>Now, as things currently stand, we're still allowing <em>everything</em> to get through, because we still haven't created a rule that blocks what we haven't specifically allowed. Before we do that, though, let's look at a few more things that we might want to allow.</p>
</section>
<section id="blocking-icmp-with-iptables" class="level3" data-number="5.4.2">
<h3 data-number="5.4.2">Blocking ICMP with iptables</h3>
<p>The conventional wisdom that you may have heard for most of your career is that we need to block all the packets from the <strong>Internet Control Message Protocol</strong> (<strong>ICMP</strong>). The idea you may have been told is to make your server invisible to hackers by blocking ping packets. Of course, there are some vulnerabilities that are associated with ICMP, such as the following:</p>
<p>By using a botnet, a hacker could inundate your server with ping packets from multiple sources at once, exhausting your server's ability to cope.</p>
<p>Certain vulnerabilities that are associated with the ICMP protocol can allow a hacker to either gain administrative privileges on your system, redirect your traffic to a malicious server, or crash your operating system.</p>
<p>By using some simple hacking tools, someone could embed sensitive data in the data field of an ICMP packet in order to secretly exfiltrate it from your organization.</p>
<p>However, while blocking certain types of ICMP packets is good, blocking all ICMP packets is bad. The harsh reality is that certain types of ICMP messages are necessary for the proper functionality of the network. Since the <em>drop all that's not allowed</em> rule that we'll eventually create also blocks ICMP packets, we'll need to create some rules that allow the types of ICMP messages that we have to have. So, here goes:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 3 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 11 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 12 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT</code></pre>
</div>
<p>Here's the breakdown:</p>
<ul>
<li><strong>-m conntrack</strong>: As before, we're using the <code>conntrack</code> module to allow packets that are in a certain state. This time, though, instead of just allowing packets from a host to which our server has connected (<code>ESTABLISHED,RELATED</code>), we're also allowing <code>NEW</code> packets that other hosts are sending to our server.</li>
<li><strong>-p icmp</strong>: This refers to the ICMP protocol.</li>
<li><strong>--icmp-type</strong>: There are quite a few types of ICMP messages, which we'll outline next.</li>
</ul>
<p>Here are the three types of ICMP messages that we want to allow:</p>
<ul>
<li><strong>type 3</strong>: These are the destination unreachable messages. Not only can they tell your server that it can't reach a certain host, but they can also tell it why. For example, if the server has sent out a packet that's too large for a network switch to handle, the switch will send back an ICMP message that tells the server to fragment that large packet. Without ICMP, the server would have connectivity problems every time it tries to send out a large packet that needs to be broken up into fragments.</li>
<li><strong>type 11</strong>: Time exceeded messages let your server know that a packet that it has sent out has either exceeded its <strong>Time-to-Live</strong> (<strong>TTL</strong>) value before it could reach its destination, or that a fragmented packet couldn't be reassembled before the TTL expiration date.</li>
<li><strong>type 12</strong>: Parameter problem messages indicate that the server had sent a packet with a bad IP header. In other words, the IP header is either missing an option flag, or it's of an invalid length.</li>
</ul>
<p>Three common message types are conspicuously absent from our list:</p>
<ul>
<li><strong>type 0</strong> and <strong>type 8</strong>: These are the infamous ping packets. Actually, <code>type 8</code> is the echo request packet that you would send out to ping a host, while <code>type 0</code> is the echo reply that the host would return to let you know that it's alive. Of course, allowing ping packets to get through could be a big help with troubleshooting network problems. If that scenario ever comes up, you could just add a couple of <code>iptables</code> rules to temporarily allow pings.</li>
<li><strong>type 5</strong>: Now, we have the infamous redirect messages. Allowing these could be handy if you have a router that can suggest more efficient paths for the server to use, but hackers can also use them to redirect you to someplace that you don't want to go. So, just block them.</li>
</ul>
<p>There are lots more ICMP message types than I've shown here, but these are the only ones that we need to worry about for now.</p>
<p>When we use <code>sudo iptables -L</code>, we'll see our new ruleset, as things currently stand:</p>
<div class="C0-SHConPACKT">
<pre><code>Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             anywhere            
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:domain
ACCEPT     udp  --  anywhere             anywhere             udp dpt:domain
ACCEPT     icmp --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED icmp destination-unreachable
ACCEPT     icmp --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED icmp source-quench
ACCEPT     icmp --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED icmp time-exceeded
ACCEPT     icmp --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED icmp parameter-problem
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         </code></pre>
</div>
<p>Looks good, eh? Well, not really. We haven't blocked anything with this ruleset yet. So, let's take care of that.</p>
</section>
<section id="blocking-everything-that-isnt-allowed-with-iptables" class="level3" data-number="5.4.3">
<h3 data-number="5.4.3">Blocking everything that isn't allowed with iptables</h3>
<p>To start blocking stuff that we don't want, we have to do one of two things. We can set a default <code>DROP</code> or <code>REJECT</code> policy for the <code>INPUT</code> chain, or we can leave the policy set to <code>ACCEPT</code> and create a <code>DROP</code> or <code>REJECT</code> rule at the end of the <code>INPUT</code> chain. Which one you choose is really a matter of preference. (Of course, before you choose one over the other, you might want to check your organization's policy manual to see if your employer has a preference.)</p>
<p>The difference between <code>DROP</code> and <code>REJECT</code> is that <code>DROP</code> blocks packets without sending any message back to the sender. <code>REJECT</code> blocks packets, and then sends a message back to the sender about why the packets were blocked. For our present purposes, let's say that we just want to <code>DROP</code> packets that we don't want to get through.</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>There are times when <code>DROP</code> is better, and times when <code>REJECT</code> is better. Use <code>DROP</code> if it's important to make your host invisible. (Although, even that isn't that effective, because there are other ways to discover hosts.) If you need your hosts to inform other hosts about why they can't make a connection, then use <code>REJECT</code>. The big advantage of <code>REJECT</code> is that it will let connecting hosts know that their packets are being blocked so that they will know to immediately quit trying to make a connection. With <code>DROP</code>, the host that's trying to make the connection will just keep trying to make the connection until it times out.</p>
</blockquote>
</blockquote>
<p>To create a <code>DROP</code> rule at the end of the <code>INPUT</code> chain, use this command:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -A INPUT -j DROP
donnie@ubuntu:~$</code></pre>
</div>
<p>To set a default <code>DROP </code>policy instead, we can use the this command:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -P INPUT DROP
donnie@ubuntu:~$</code></pre>
</div>
<p>The big advantage of setting up a default <code>DROP</code> or <code>REJECT</code> policy is that it makes it easier to add new <code>ACCEPT</code> rules if need be. This is because if we decide to keep the default <code>ACCEPT</code> policy and create a <code>DROP</code> or <code>REJECT</code> rule instead, that rule has to be at the bottom of the list.</p>
<p>Since <code>iptables</code> rules are processed in order, from top to bottom, any <code>ACCEPT</code> rules that come after that <code>DROP</code> or <code>REJECT</code> rule would have no effect. You would need to insert any new <code>ACCEPT</code> rules above that final <code>DROP</code> or <code>REJECT</code> rule, which is just a tiny bit less convenient than just being able to append them to the end of the list. For now, in order to illustrate my next point, I've just left the default <code>ACCEPT</code> policy and added the <code>DROP</code> rule.</p>
<p>When we look at our new ruleset, we'll see something that's rather strange:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -L
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  anywhere             anywhere            
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
. . .
. . .
ACCEPT     icmp --  anywhere             anywhere             ctstate NEW,RELATED,ESTABLISHED icmp parameter-problem
DROP       all  --  anywhere             anywhere            
Chain FORWARD (policy ACCEPT)
target     prot opt source               destination         
. . .
. . .</code></pre>
</div>
<p>The first rule and the last rule of the <code>INPUT</code> chain look the same, except that one is a <code>DROP</code> and the other is an <code>ACCEPT</code>. Let's look at it again with the <code>-v</code> (verbose) option:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -L -v
Chain INPUT (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target prot opt in out source destination 
   67 4828 ACCEPT all -- lo any anywhere anywhere 
  828 52354 ACCEPT all -- any any anywhere anywhere ctstate RELATED,ESTABLISHED
. . .
. . .
    0 0 ACCEPT icmp -- any any anywhere anywhere ctstate NEW,RELATED,ESTABLISHED icmp parameter-problem
  251 40768 DROP all -- any any anywhere anywhere 
Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target prot opt in out source destination 
. . .
. . .</code></pre>
</div>
<p>Now, we can see that <code>lo</code>, for loopback, shows up under the <code>in</code> column of the first rule, and that <code>any</code> shows up under the <code>in</code> column of the last rule. We can also see that the <code>-v</code> switch shows the number of packets and bytes that have been counted by each rule. So, in the preceding example, we can see that the <code>ctstate RELATED,ESTABLISHED</code> rule has accepted 828 packets and 52,354 bytes. The <code>DROP all</code> rule has blocked 251 packets and 40,763 bytes.</p>
<p>This all looks great, except that if we were to reboot the machine right now, the rules would disappear. The final thing that we need to do is make them permanent. There are several ways to do this, but the simplest way to do this on an Ubuntu machine is to install the <code>iptables-persistent</code> package:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo apt install iptables-persistent</code></pre>
</div>
<p>During the installation process, you'll be presented with two screens that ask you whether you want to save the current set of <code>iptables rules</code>. The first screen will be for IPv4 rules, while the second will be for IPv6 rules:</p>
<figure>
<img src="../media/file34.png" alt="19501_04_01.png" /><figcaption aria-hidden="true">19501_04_01.png</figcaption>
</figure>
<p>You'll now see two new rules files in the <code>/etc/iptables/</code> directory:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ ls -l /etc/iptables*
 total 8
 -rw-r--r-- 1 root root 336 Oct 10 10:29 rules.v4
 -rw-r--r-- 1 root root 183 Oct 10 10:29 rules.v6
 donnie@ubuntu:~$</code></pre>
</div>
<p>If you were to reboot the machine now, you'd see that your iptables rules are still there and in effect. The only slight problem with <code>iptables-persistent</code> is that it won't save any subsequent changes that you make to the rules. That's okay, though. I'll show you how to deal with that in just a bit.</p>
<section id="hands-on-lab-for-basic-iptables-usage" class="level4" data-number="5.4.3.1">
<h4 data-number="5.4.3.1">Hands-on lab for basic iptables usage</h4>
<p>You'll complete this lab on your Ubuntu 20.04 virtual machine. Follow these steps to get started:</p>
<ol>
<li>Shut down your Ubuntu virtual machine and create a snapshot. After you boot it back up, look at your iptables rules, or lack thereof, by using this command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L</code></pre>
</div>
<ol>
<li>With a default Ubuntu setup, the Uncomplicated Firewall (ufw) service is already running, albeit with an unactivated firewall configuration. We want to disable it to work directly with iptables. Do that now with this command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo systemctl disable --now ufw</code></pre>
</div>
<ol>
<li>Create the rules that you need for a basic firewall, allowing for Secure Shell access, DNS queries and zone transfers, and the proper types of ICMP. Deny everything else:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -A INPUT -m conntrack  --ctstate ESTABLISHED,RELATED  -j ACCEPT
sudo iptables -A INPUT -p tcp --dport ssh -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 53 -j ACCEPT
sudo iptables -A INPUT -p udp --dport 53 -j ACCEPT
sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 3 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 11 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -m conntrack -p icmp --icmp-type 12 --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT
sudo iptables -A INPUT -j DROP</code></pre>
</div>
<ol>
<li>Use this command to view the results:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L</code></pre>
</div>
<ol>
<li>Oops – it looks like you forgot about that loopback interface. Add a rule for it at the top of the list:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -I INPUT 1 -i lo -j ACCEPT</code></pre>
</div>
<ol>
<li>View the results by using the following two commands. Note the difference between the output of each:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code> sudo iptables -L
 sudo iptables -L -v</code></pre>
</div>
<ol>
<li>Install the <code>iptables-persistent</code> package and choose to save the IPv4 and IPv6 rules when prompted:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo apt install iptables-persistent</code></pre>
</div>
<ol>
<li>Reboot the virtual machine and verify that your rules are still active.</li>
<li>Keep this virtual machine; you'll be adding more to it in the next hands-on lab.</li>
</ol>
<p>That's the end of this lab—congratulations!</p>
</section>
</section>
<section id="blocking-invalid-packets-with-iptables" class="level3" data-number="5.4.4">
<h3 data-number="5.4.4">Blocking invalid packets with iptables</h3>
<p>If you've been in the IT business for any length of time, you're most likely familiar with the good old TCP three-way handshake. If you're not, no worries. Here's the simplified explanation.</p>
<p>Let's say that you're sitting at your workstation, and you pull up Firefox to visit a website. To access that website, your workstation and the web server have to set up the connection. Here's what happens:</p>
<p>Your workstation sends a packet with only the <code>SYN</code> flag set to the web server. This is your workstation's way of saying, "Hello, Mr. Server. I'd like to make a connection with you."</p>
<p>After receiving your workstation's <code>SYN</code> packet, the web server sends back a packet with the <code>SYN</code> and <code>ACK</code> flags set. With this, the server is saying, "Yeah, bro. I'm here, and I'm willing to connect with you."</p>
<p>Upon receipt of the <code>SYN-ACK</code> packet, the workstation sends back a packet with only the <code>ACK</code> flag set. With this, the workstation is saying, "Cool deal, dude. I'm glad to connect with you."</p>
<p>Upon receipt of the <code>ACK</code> packet, the server sets up the connection with the workstation so that they can exchange information.</p>
<p>This sequence works the same way for setting up any kind of TCP connection. This includes connections that involve Secure Shell, telnet, and the various mail server protocols, among other things.</p>
<p>However, clever people can use a variety of tools to craft TCP packets with some very weird combinations of flags. With these so-called <em>invalid</em> packets, a few things could happen:</p>
<p>The invalid packets could be used to elicit responses from the target machine in order to find out what operating system it's running, what services are running on it, and which versions of the services are running.</p>
<p>The invalid packets could be used to trigger certain sorts of security vulnerabilities on the target machine.</p>
<p>Some of these invalid packets require more processing power than what normal packets require, which could make them useful for performing Denial-of-Service (DoS) attacks.</p>
<p>Now, in truth, the <code>DROP all</code> rule at the end of the filter table's <code>INPUT</code> chain will block some of these invalid packets. However, there are some things that this rule might miss. And even if we could count on it to block all the invalid stuff, this still isn't the most efficient way of doing things. By depending on this <code>DROP all</code> rule, we're allowing these invalid packets to travel through the entire <code>INPUT</code> chain, looking for a rule that will let them through. When no <code>ALLOW</code> rule is found for them, they'll finally get blocked by the <code>DROP all</code> rule, which is the last rule in the chain. So, what if we could find a more efficient solution?</p>
<p>Ideally, we'd like to block these invalid packets before they travel through the entire <code>INPUT </code>chain. We could do that with a <code>PREROUTING</code> chain, but the filter table doesn't have a <code>PREROUTING</code> chain. Therefore, we need to use the <code>PREROUTING</code> chain of the mangle table instead. Let's start by adding these two rules:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
 
 donnie@ubuntu:~$ sudo iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP
 donnie@ubuntu:~$</code></pre>
</div>
<p>The first of these rules will block most of what we would consider <em>invalid</em>. However, there are still some things that it misses. Due to this, we added the second rule, which blocks all <code>NEW</code> packets that are not <code>SYN</code> packets. Now, let's see what we have:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -L
 Chain INPUT (policy ACCEPT)
 target     prot opt source               destination         
 ACCEPT     all  --  anywhere             anywhere            
 ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
 ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
 DROP       all  --  anywhere             anywhere            
 
 Chain FORWARD (policy ACCEPT)
 target     prot opt source               destination         
 
 Chain OUTPUT (policy ACCEPT)
 target     prot opt source               destination         
 donnie@ubuntu:~$</code></pre>
</div>
<p>Hmm...</p>
<p>We can't see our new rules, can we? That's because, by default, <code>iptables -L</code> only shows rules for the filter table. We need to see what we've just placed into the mangle table, so let's do this, instead:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -L
 Chain PREROUTING (policy ACCEPT)
 target     prot opt source               destination         
 DROP       all  --  anywhere             anywhere             ctstate INVALID
 DROP       tcp  --  anywhere             anywhere             tcp flags:!FIN,SYN,RST,ACK/SYN ctstate NEW
 
 Chain INPUT (policy ACCEPT)
 target     prot opt source               destination         
 Chain FORWARD (policy ACCEPT)
 target     prot opt source               destination         
 Chain OUTPUT (policy ACCEPT)
 target     prot opt source               destination         
 Chain POSTROUTING (policy ACCEPT)
 target     prot opt source               destination         
 donnie@ubuntu:~$</code></pre>
</div>
<p>Here, we used the <code>-t mangle</code> option to indicate that we want to see the configuration for the mangle table. Something rather curious that you may have noticed is how iptables renders the rule that was created by the <code>sudo iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP</code> command. For some reason, it renders like this:</p>
<div class="C0-SHConPACKT">
<pre><code>DROP     tcp  --  anywhere   anywhere    tcp flags:!FIN,SYN,RST,ACK/SYN ctstate NEW</code></pre>
</div>
<p>It looks strange, but don't let that throw you. It still means that it's blocking <code>NEW</code> packets that aren't <code>SYN</code> packets.</p>
<p>Previously, I mentioned that the <code>iptables-persistent</code> package won't save subsequent changes to your <code>iptables</code> rules. So, as things stand now, the mangle table rules that we just added will disappear once I reboot this virtual machine. To make these changes permanent, I'll use the <code>iptables-save</code> command to save a new file in my own home directory. Then, I'll copy the file over to the <code>/etc/iptables</code> directory, replacing the original one:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables-save &gt; rules.v4
 [sudo] password for donnie:
 donnie@ubuntu:~$ sudo cp rules.v4 /etc/iptables/
 donnie@ubuntu:~$</code></pre>
</div>
<p>To test this, we'll use a handy utility called Nmap. It's a free utility that you can install on your Windows, Mac, or Linux workstation. Or, if you don't want to install it on your host machine, you can install it on one of your Linux virtual machines. It's in the normal repositories of Debian/Ubuntu, RHEL/CentOS 7, and RHEL/AlmaLinux 8. So, just install the Nmap package with the appropriate install command for your distro. If you want to install Nmap on your Windows or Mac host machine, you'll need to download it from the Nmap website.</p>
<blockquote>
<p>You can download Nmap from the official website, which can be found here: <a href="https://nmap.org/download.html">https://nmap.org/download.html</a>.</p>
</blockquote>
<p>With our new mangle table rules in place, let's perform an XMAS scan of our Ubuntu machine. I have Nmap installed here on the Fedora workstation that I'm currently using, so I'll just use this for now. I can do this like so:</p>
<div class="C0-SHConPACKT">
<pre><code>[donnie@fedora-teaching ~]$ sudo nmap -sX 192.168.0.15
 [sudo] password for donnie:
 Starting Nmap 7.70 ( https://nmap.org ) at 2019-07-26 21:20 EDT
 Nmap scan report for 192.168.0.15
 Host is up (0.00052s latency).
 All 1000 scanned ports on 192.168.0.15 are open|filtered
 MAC Address: 08:00:27:A4:95:1A (Oracle VirtualBox virtual NIC)
 
 Nmap done: 1 IP address (1 host up) scanned in 21.41 seconds
 [donnie@fedora-teaching ~]$</code></pre>
</div>
<p>By default, Nmap only scans the most commonly used 1,000 ports. The XMAS scan sends invalid packets that consist of the FIN, PSH, and URG flags. The fact that all 1,000 scanned ports show as <code>open|filtered</code> means that the scan was blocked, and that Nmap can't determine the true state of the ports. (In reality, port <code>22</code> is open.) We can view the result to see which rule did the blocking. (To simplify things a bit, I'll only show the output for the <code>PREROUTING</code> chain since it's the only mangle table chain that's doing anything):</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -t mangle -L -v
 Chain PREROUTING (policy ACCEPT 2898 packets, 434K bytes)
  pkts bytes target     prot opt in     out     source               destination    
     
  2000 80000 DROP  all  --  any    any     anywhere             anywhere             ctstate INVALID
     
  0     0 DROP       tcp  --  any    any     anywhere             anywhere             tcp flags:!FIN,SYN,RST,ACK/SYN ctstate NEW
 
 . . .
 . . .
 donnie@ubuntu:~$</code></pre>
</div>
<p>Here, you can see that the first rule – the <code>INVALID</code> rule – blocked 2,000 packets and 80,000 bytes. Now, let's zero out the counter so that we can do another scan:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -Z
 donnie@ubuntu:~$ sudo iptables -t mangle -L -v
 Chain PREROUTING (policy ACCEPT 22 packets, 2296 bytes)
 pkts bytes target prot opt in out source destination
 0 0 DROP all -- any any anywhere anywhere ctstate INVALID
 0 0 DROP tcp -- any any anywhere anywhere tcp flags:!FIN,SYN,RST,ACK/SYN ctstate NEW
 
 . . .
 . . .
 donnie@ubuntu:~$</code></pre>
</div>
<p>This time, let's do a Window scan, which bombards the target machine with <code>ACK</code> packets:</p>
<div class="C0-SHConPACKT">
<pre><code>[donnie@fedora-teaching ~]$ sudo nmap -sW 192.168.0.15
 Starting Nmap 7.70 ( https://nmap.org ) at 2019-07-26 21:39 EDT
 Nmap scan report for 192.168.0.15
 Host is up (0.00049s latency).
 All 1000 scanned ports on 192.168.0.15 are filtered
 MAC Address: 08:00:27:A4:95:1A (Oracle VirtualBox virtual NIC)
 
 Nmap done: 1 IP address (1 host up) scanned in 21.44 seconds
 [donnie@fedora-teaching ~]$</code></pre>
</div>
<p>As before, the scan was blocked, as indicated by the message that all 1,000 scanned ports have been filtered. Now, let's view what we have on the target Ubuntu machine:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -L -v
 Chain PREROUTING (policy ACCEPT 45 packets, 6398 bytes)
  pkts bytes target     prot opt in     out     source               destination         
     
  0     0 DROP       all  --  any    any     anywhere             anywhere             ctstate INVALID
 
  2000 80000 DROP       tcp  --  any    any     anywhere             anywhere             tcp flags:!FIN,SYN,RST,ACK/SYN ctstate NEW
 
 . . .
 . . .      
 donnie@ubuntu:~$</code></pre>
</div>
<p>This time, we can see that our invalid packets got past the first rule, but were blocked by the second rule.</p>
<p>Now, just for fun, let's clear out the mangle table rules and do our scans again. We'll use the <code>-D</code> option to delete the two rules from the mangle table:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -D PREROUTING 1
 donnie@ubuntu:~$ sudo iptables -t mangle -D PREROUTING 1
 donnie@ubuntu:~$</code></pre>
</div>
<p>When you delete a rule, you have to specify the rule number, just like you do when you insert a rule. Here, I specified rule 1 twice, because deleting the first rule moved the second rule up to first place. Now, let's verify that the rules are gone:</p>
<div class="C0-SHConPACKT">
<pre><code> donnie@ubuntu:~$ sudo iptables -t mangle -L
 Chain PREROUTING (policy ACCEPT)
 target prot opt source destination
 
 . . .
 . . .
 donnie@ubuntu:~$</code></pre>
</div>
<p>Yes, they are. Cool. Now, let's see what we get when we perform another XMAS scan:</p>
<div class="C0-SHConPACKT">
<pre><code> [donnie@fedora-teaching ~]$ sudo nmap -sX 192.168.0.15
 [sudo] password for donnie:
 Starting Nmap 7.70 ( https://nmap.org ) at 2019-07-26 21:48 EDT
 Nmap scan report for 192.168.0.15
 Host is up (0.00043s latency).
 All 1000 scanned ports on 192.168.0.15 are open|filtered
 MAC Address: 08:00:27:A4:95:1A (Oracle VirtualBox virtual NIC)
 
 Nmap done: 1 IP address (1 host up) scanned in 21.41 seconds
 [donnie@fedora-teaching ~]$</code></pre>
</div>
<p>Even without the mangle table rules, it shows that my scan is still blocked. What's up with that? This is happening because I still have the <code>DROP all</code> rule at the end of the <code>INPUT</code> table. Let's disable that and see what we get with another scan.</p>
<p>First, I need to see what the rule number is:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -L
 Chain INPUT (policy ACCEPT)
 target     prot opt source               destination         
 ACCEPT     all  --  anywhere             anywhere            
 ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
 ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
 DROP       all  --  anywhere             anywhere            
 
 Chain FORWARD (policy ACCEPT)
 target     prot opt source               destination         
 
 Chain OUTPUT (policy ACCEPT)
 target     prot opt source               destination         
 donnie@ubuntu:~$</code></pre>
</div>
<p>Counting down, I can see that it's rule number 4, so I'll delete it:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo iptables -D INPUT 4
donnie@ubuntu:~$donnie@ubuntu:~$ sudo iptables -L
 Chain INPUT (policy ACCEPT)
 target     prot opt source               destination         
 ACCEPT     all  --  anywhere             anywhere            
 ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
 ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh
 
 Chain FORWARD (policy ACCEPT)
 target     prot opt source               destination         
 
 Chain OUTPUT (policy ACCEPT)
 target     prot opt source               destination         
 donnie@ubuntu:~$</code></pre>
</div>
<p>Now, for the XMAS scan:</p>
<div class="C0-SHConPACKT">
<pre><code>[donnie@fedora-teaching ~]$ sudo nmap -sX 192.168.0.15
 Starting Nmap 7.70 ( https://nmap.org ) at 2019-07-26 21:49 EDT
 Nmap scan report for 192.168.0.15
 Host is up (0.00047s latency).
 Not shown: 999 closed ports
 PORT STATE SERVICE
 22/tcp open|filtered ssh
 MAC Address: 08:00:27:A4:95:1A (Oracle VirtualBox virtual NIC)
 
 Nmap done: 1 IP address (1 host up) scanned in 98.76 seconds
 [donnie@fedora-teaching ~]$</code></pre>
</div>
<p>This time, the scan shows that 999 ports are closed and that port <code>22</code>, the SSH port, is either open or filtered. This shows that the scan is no longer being blocked by anything.</p>
</section>
<section id="restoring-the-deleted-rules" class="level3" data-number="5.4.5">
<h3 data-number="5.4.5">Restoring the deleted rules</h3>
<p>When I used the <code>iptables -D</code> commands, I only deleted the rules from the runtime configuration, and not from the <code>rules.v4</code> configuration file. To restore the rules that I deleted, I can either reboot the machine or restart the <code>netfilter-persistent</code> service. The latter choice is quicker, so I'll activate it like this:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu:~$ sudo systemctl restart netfilter-persistent
[sudo] password for donnie:
donnie@ubuntu:~$</code></pre>
</div>
<p>The <code>iptables -L</code> and <code>iptables -t mangle -L</code> commands will show that all the rules are now back in effect.</p>
<section id="hands-on-lab-for-blocking-invalid-ipv4-packets" class="level4" data-number="5.4.5.1">
<h4 data-number="5.4.5.1">Hands-on lab for blocking invalid IPv4 packets</h4>
<p>For this lab, you'll use the same virtual machine that you used for the previous lab. You won't replace any of the rules that you already have. Rather, you'll just add a couple. Let's get started:</p>
<ol>
<li>Look at the rules for the filter and the mangle tables. (Note that the <code>-v</code> option shows you statistics about packets that were blocked by <code>DROP</code> and <code>REJECT</code> rules.) Then, zero out the blocked packets counter:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L -v
sudo iptables -t mangle -L -v
sudo iptables -Z
sudo iptables -t mangle -Z</code></pre>
</div>
<ol>
<li>From either your host machine or another virtual machine, perform the NULL and Windows Nmap scans against the virtual machine:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo nmap -sN ip_address_of_your_VM
sudo nmap -sW ip_address_of_your_VM</code></pre>
</div>
<ol>
<li>Repeat <em>Step 1</em>. You should see a large jump in the number of packets that were blocked by the final <code>DROP</code> rule in the <code>INPUT</code> chain of the filter table:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L -v
sudo iptables -t mangle -L -v</code></pre>
</div>
<ol>
<li>Make the firewall work more efficiently by using the <code>PREROUTING</code> chain of the mangle table to drop invalid packets, such as those that are produced by the two Nmap scans that we just performed. Add the two required rules with the following two commands:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
sudo iptables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP</code></pre>
</div>
<ol>
<li>Save the new configuration to your own home directory. Then, copy the file to its proper location and zero out the blocked packet counters:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables-save &gt; rules.v4
sudo cp rules.v4 /etc/iptables
sudo iptables -Z
sudo iptables -t mangle -Z</code></pre>
</div>
<ol>
<li>Perform only the NULL scan against the virtual machine:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo nmap -sN ip_address_of_your_VM</code></pre>
</div>
<ol>
<li>Look at the <code>iptables</code> ruleset and observe which rule was triggered by the Nmap scan:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L -v
sudo iptables -t mangle -L -v</code></pre>
</div>
<ol>
<li>This time, perform just the Windows scan against the virtual machine:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo nmap -sW ip_address_of_your_VM</code></pre>
</div>
<ol>
<li>Observe which rule was triggered by this scan:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo iptables -L -v
sudo iptables -t mangle -L -v</code></pre>
</div>
<p>That's the end of this lab—congratulations!</p>
</section>
</section>
<section id="protecting-ipv6" class="level3" data-number="5.4.6">
<h3 data-number="5.4.6">Protecting IPv6</h3>
<p>I know, you're used to having all networking based on IPv4, with its nice, short, easy to use IP addresses. However, that can't last forever, considering that the world is now out of new IPv4 addresses. IPv6 offers a much larger address space that will last for a long time to come. Some organizations, especially wireless carriers, are either in the process of switching over to IPv6 or have already switched to it.</p>
<p>So far, all we've covered is how to set up an IPv4 firewall with iptables. But remember what we said before. With iptables, you need one daemon and one set of rules for the IPv4 network, and another daemon and set of rules for IPv6. This means that when using iptables to set up a firewall, protecting IPv6 means doing everything twice. Most Linux distros come with IPv6 networking enabled by default, so you either need to protect it with a firewall or disable it. Otherwise, your IPv6 address will still be open for attack since the IPv4 firewall that you've just configured won't protect it. This is true even if your server or device is facing the IPv4 Internet because there are ways to tunnel IPv6 packets through an IPv4 network. Fortunately, the commands for setting up an IPv6 firewall are mostly the same as what we've just covered. The biggest difference is that instead of using the <code>iptables</code> command, you'll use the <code>ip6tables</code> command. Let's start with our basic setup, just like what we did for IPv4:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -i lo -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p tcp --dport ssh -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p tcp --dport 53 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p udp --dport 53 -j ACCEPT</code></pre>
</div>
<p>The other big difference between IPv4 and IPv6 is that with IPv6, you must allow more types of ICMP messages than you need to for IPv4. This is due to the following reasons:</p>
<ul>
<li>With IPv6, new types of ICMP messages have replaced the <strong>Address Resolution Protocol</strong> (<strong>ARP</strong>).</li>
<li>With IPv6, dynamic IP address assignments are normally done by exchanging ICMP discovery messages with other hosts, rather than by DHCP.</li>
<li>With IPv6, echo requests and echo replies, the infamous ping packets, are required when you need to tunnel IPv6 packets through an IPv4 network.</li>
</ul>
<p>And of course, we still need the same types of ICMP messages that we need for IPv4. So, let's start with them:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 1 -j ACCEPT
[sudo] password for donnie: 
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 2 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 3 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 4 -j ACCEPT
donnie@ubuntu3:~$</code></pre>
</div>
<p>These message types are as follows, in order of appearance:</p>
<ul>
<li>Destination unreachable</li>
<li>Packet too big</li>
<li>Time exceeded</li>
<li>Parameter problem with the packet header</li>
</ul>
<p>Next, we'll enable echo requests (type 128) and echo responses (type 129) so that IPv6 over IPv4 tunneling will work:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 128 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 129 -j ACCEPT
donnie@ubuntu3:~$</code></pre>
</div>
<blockquote>
<p>The Teredo protocol is one of a few different ways to tunnel IPv6 packets across an IPv4 network. This protocol is what requires echo requests and echo replies, the infamous ping packets, to be allowed through a firewall. However, if you search through your distro repositories for a Teredo package, you won't find it. That's because the Linux implementation of the Teredo protocol is called miredo. So, when installing the Teredo protocol on a Linux machine, you'll need to install the <code>miredo</code> and <code>miredo-server</code> packages.</p>
</blockquote>
<p>The next four ICMP message types that we need are for the Link-local Multicast Receiver Notification messages:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 130
donnie@ubuntu3:~$ sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 131
donnie@ubuntu3:~$ sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 132
donnie@ubuntu3:~$ sudo ip6tables -A INPUT --protocol icmpv6 --icmpv6-type 143
donnie@ubuntu3:~$</code></pre>
</div>
<p>These are as follows, in order of appearance:</p>
<ul>
<li>Listener query</li>
<li>Listener report</li>
<li>Listener done</li>
<li>Listener report v2</li>
</ul>
<p>Next up is our neighbor and router discovery message types:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 134 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 135 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 136 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 141 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 142 -j ACCEPT
donnie@ubuntu3:~$</code></pre>
</div>
<p>These are as follows, in order of appearance:</p>
<ul>
<li>Router solicitation</li>
<li>Router advertisement</li>
<li>Neighbor solicitation</li>
<li>Neighbor advertisement</li>
<li>Inverse neighbor discovery solicitation</li>
<li>Inverse neighbor discovery advertisement</li>
</ul>
<p>Space doesn't permit me to go into the details of these message types. So, for now, let's just say that they're required in order for IPv6 hosts to dynamically assign themselves an IPv6 address.</p>
<p>For times when you're using security certificates to authenticate the routers that are attached to your network, you'll also need to allow <strong>Secure Neighbor Discovery</strong> (<strong>SEND</strong>) messages:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 148 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 149 -j ACCEPT
donnie@ubuntu3:~$</code></pre>
</div>
<p>Are your fingers tired yet? If so, have no fear. This next group of ICMP rules is the last one. This time, we need to allow Multicast Router Discovery messages:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 151 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 152 -j ACCEPT
donnie@ubuntu3:~$ sudo ip6tables -A INPUT -p icmpv6 --icmpv6-type 153 -j ACCEPT
donnie@ubuntu3:~$</code></pre>
</div>
<p>Finally, we'll add our <code>DROP</code> rule to block everything else:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu3:~$ sudo ip6tables -A INPUT -j DROP
donnie@ubuntu3:~$</code></pre>
</div>
<p>I know you're thinking, “Wow, that's a lot of hoops to jump through just to set up a basic firewall”. <em></em> And yeah, you're right, especially when you also need to configure rules for IPv6. Soon, I'll show you what the Ubuntu folk came up with to make things simpler.</p>
<blockquote>
<p>You can get the whole scoop on how to use iptables on Ubuntu here: <a href="https://help.ubuntu.com/community/IptablesHowTo">https://help.ubuntu.com/community/IptablesHowTo</a>.</p>
</blockquote>
<section id="hands-on-lab-for-ip6tables" class="level4" data-number="5.4.6.1">
<h4 data-number="5.4.6.1">Hands-on lab for ip6tables</h4>
<p>For this lab, you'll use the same Ubuntu virtual machine that you used in the previous iptables labs. You'll leave the IPv4 firewall setup that's already there as-is and create a new firewall for IPv6. Let's get started:</p>
<ol>
<li>View your IPv6 rules, or lack thereof, with this command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables -L</code></pre>
</div>
<ol>
<li>Create the IPv6 firewall. Due to formatting constraints, I can't list the entire code block of commands here. You can find the respective commands in this chapter's directory, in the code file that you can download from the Packt Publishing website.</li>
<li>View the new ruleset by using the following command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables -L</code></pre>
</div>
<ol>
<li>Next, set up the mangle table rules for blocking invalid packets:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables -t mangle -A PREROUTING -m conntrack --ctstate INVALID -j DROP
sudo ip6tables -t mangle -A PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -j DROP</code></pre>
</div>
<ol>
<li>Save the new ruleset to a file in your own home directory, and then transfer the rules file to the proper location:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables-save &gt; rules.v6
sudo cp rules.v6 /etc/iptables/</code></pre>
</div>
<ol>
<li>Obtain the IPv6 address of the virtual machine with this command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>ip a</code></pre>
</div>
<ol>
<li>On the machine on which you installed Nmap, perform a Windows scan of the virtual machine's IPv6 address. The command will look like this, except with your own IP address:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo nmap -6 -sW fe80::a00:27ff:fe9f:d923</code></pre>
</div>
<ol>
<li>On the virtual machine, observe which rule was triggered with this command:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables -t mangle -L -v</code></pre>
</div>
<p>You should see non-zero numbers for the packet counters for one of the rules.</p>
<ol>
<li>On the machine on which you installed Nmap, perform an XMAS scan of the virtual machine's IPv6 address. The command will look like this, except with your own IP address:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo nmap -6 -sX fe80::a00:27ff:fe9f:d923</code></pre>
</div>
<ol>
<li>As before, on the virtual machine, observe which rule was triggered by this scan:</li>
</ol>
<div class="C1-SHConPACKT">
<pre><code>sudo ip6tables -t mangle -L -v</code></pre>
</div>
<ol>
<li>Shut down the virtual machine, and restore it from the snapshot that you created at the beginning of the <em>Hands-on lab for basic iptables usage</em>.</li>
</ol>
<p>That's the end of this lab – congratulations!</p>
<p>So far, you've seen the good, the bad, and the ugly of <code>iptables</code>. It's very flexible, and there's a lot of power in the <code>iptables</code> commands. If you're clever at shell scripting, you can create some rather complex shell scripts that you can use to deploy firewalls on the machines all across your network.</p>
<p>On the other hand, getting everything right can be quite complex, especially if you need to consider that your machines have to run both IPv4 and IPv6, and that everything you do for IPv4 has to be done again for IPv6. (If you're a masochist, you might actually enjoy it.)</p>
</section>
</section>
</section>
<section id="nftables-a-more-universal-type-of-firewall-system" class="level2" data-number="5.5">
<h2 data-number="5.5">nftables – a more universal type of firewall system</h2>
<p>Now, let's turn our attention to nftables, the new kid on the block. So, what does nftables bring to the table? (Yes, the pun was intended.):</p>
<ul>
<li>You can forget about needing separate daemons and utilities for all of the different networking components. The functionality of iptables, ip6tables, ebtables, and arptables is now all combined in one neat package. The nft utility is now the only firewall utility that you'll need.</li>
<li>With nftables, you can create multi-dimensional trees to display your rulesets. This makes troubleshooting vastly easier because it's now easier to trace a packet all the way through all of the rules.</li>
<li>With iptables, you have the filter, NAT, mangle, and security tables installed by default, whether or not you use each one.</li>
<li>With nftables, you only create the tables that you intend to use, resulting in enhanced performance.</li>
<li>Unlike iptables, you can specify multiple actions in one rule, instead of having to create multiple rules for each action.</li>
<li>Unlike iptables, new rules get added atomically. (That's a fancy way of saying that there's no longer a need to reload the entire ruleset in order to just add one rule.)</li>
<li>nftables has its own built-in scripting engine, allowing you to write scripts that are more efficient and more human-readable.</li>
<li>If you already have lots of iptables scripts that you still need to use, you can install a set of utilities that will help you convert them into nftables format. (That is, unless you’re running Ubuntu 22.04, which can automatically translate iptables commands for you.)</li>
</ul>
<p>Although nftables was created by Red Hat, Ubuntu was the first enterprise-grade Linux distro to offer it as an option, beginning with Ubuntu 16.04. It’s now the default option for Ubuntu 22.04, SUSE, OpenSUSE, and the RHEL 8/9-type distros. Let’s begin by looking at some basic nftables concepts.</p>
<section id="learning-about-nftables-tables-and-chains" class="level3" data-number="5.5.1">
<h3 data-number="5.5.1">Learning about nftables tables and chains</h3>
<p>If you're used to iptables, you might recognize some of the nftables terminology. The only problem is that some of the terms are used in different ways, with different meanings. Let's go over some examples so that you’ll know what I'm talking about:</p>
<ul>
<li><strong>Tables</strong>: Tables in nftables refer to a particular protocol family. The table types are ip, ip6, inet, arp, bridge, and netdev.</li>
<li><strong>Chains</strong>: Chains in nftables roughly equate to tables in iptables. For example, in nftables, you could have filter, route, or NAT chains.</li>
</ul>
<section id="getting-started-with-nftables" class="level4" data-number="5.5.1.1">
<h4 data-number="5.5.1.1">Getting started with nftables</h4>
<p>Let's start with a clean snapshot of our Ubuntu 22.04 virtual machine, since it comes with nftables already installed.</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>You can use Ubuntu 20.04 if you really want to, but you’ll first have to install nftables by doing:</p>
</blockquote>
</blockquote>
<div class="C0-SHConPACKT">
<pre><code>sudo apt install nftables</code></pre>
</div>
<p>Now, let's take a look at the list of installed tables:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft list tables</code></pre>
</div>
<p>You didn't see any tables, did you? So, let's load some up.</p>
</section>
</section>
<section id="configuring-nftables-on-ubuntu" class="level3" data-number="5.5.2">
<h3 data-number="5.5.2">Configuring nftables on Ubuntu</h3>
<p>On the Ubuntu virtual machine that we'll be using, the default <code>nftables.conf</code> file is nothing more than a meaningless placeholder. The file you need, which you'll copy over to replace the default <code>nftables.conf</code> file, is elsewhere. Let's check it out.</p>
<p>First, we'll go into the directory where the sample configurations are stored and list the sample configuration files:</p>
<div class="C0-SHConPACKT">
<pre><code>cd /usr/share/doc/nftables/examples/
ls -l</code></pre>
</div>
<p>You should see something similar to this:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu2204-packt:/usr/share/doc/nftables/examples$ ls -l
total 124
-rw-r--r-- 1 root root  1016 Mar 23  2022 all-in-one.nft
-rw-r--r-- 1 root root   129 Mar 23  2022 arp-filter.nft
. . .
. . .
-rwxr-xr-x 1 root root   817 Mar 23  2022 workstation.nft
donnie@ubuntu2204-packt:/usr/share/doc/nftables/examples$</code></pre>
</div>
<p>If you view the contents of the <code>workstation.nft</code> file, you'll see that it's the one we need.</p>
<p>Next, we'll copy the workstation file over to the <code>/etc</code> directory, changing its name to <code>nftables.conf</code>. (Note that this will overwrite the old <code>nftables.conf</code> file, which is what we want.):</p>
<div class="C0-SHConPACKT">
<pre><code>sudo cp workstation.nft /etc/nftables.conf</code></pre>
</div>
<p>Here's the breakdown of what you'll see in the <code>/etc/nftables.conf</code> file that you'll be using:</p>
<ul>
<li><strong>#!/usr/sbin/nft -f</strong>: Although you can create normal Bash shell scripts with nftables commands, it's better to use the built-in scripting engine that's included with nftables. That way, we can make our scripts more human-readable, and we don't have to type <code>nft</code> in front of everything we want to execute.</li>
<li><strong>flush ruleset</strong>: We want to start with a clean slate, so we'll flush out any rules that may have already been loaded.</li>
<li><strong>table inet filter</strong>: This creates an inet family filter, which works for both IPv4 and IPv6. The name of this table is <code>filter</code>, but it could just as well have been something a bit more descriptive.</li>
<li><strong>chain input</strong>: Within the first pair of curly brackets, we have a chain called <code>input</code>. (Again, the name could have been something more descriptive.)</li>
<li><strong>type filter hook input priority 0;</strong>: Within the next pair of curly brackets, we define our chain and list the rules. This chain is defined as a <code>filter</code> type. <code>hook input</code> indicates that this chain is meant to process incoming packets. Because this chain has both a <code>hook</code> and a <code>priority</code>, it will accept packets directly from the network stack.</li>
</ul>
<p>Finally, we have the standard rules for a very basic host firewall, starting with the <strong>Input Interface</strong> (<strong>iif</strong>) rule, which allows the loopback interface to accept packets.</p>
<p>Next is the standard connection tracking (<code>ct</code>) rule, which accepts traffic that's in response to a connection request from this host.</p>
<p>Then, there's a commented-out rule to accept Secure Shell and both secure and nonsecure web traffic. <code>ct state</code> new indicates that the firewall will allow other hosts to initiate connections to our server on these ports.</p>
<p>The <code>meta nfproto ipv6</code> rule accepts neighbor discovery packets, allowing IPv6 functionality.</p>
<p>The <code>counter drop</code> rule at the end silently blocks all other traffic and counts both the number of packets and the number of bytes that it blocks. (This is an example of how you can have one nftables rule perform multiple different actions.)</p>
<p>If all you need on your Ubuntu server is a basic, no-frills firewall, your best bet is to just edit this <code>/etc/nftables.conf</code> file so that it suits your own needs. For starters, let's set this up to match the setup that we created for the iptables section. In other words, let's say that this is a DNS server, and we need to allow connections to port <code>22</code> and port <code>53</code>. Remove the comment symbol from in front of the <code>tcp dport</code> line, get rid of ports <code>80</code> and <code>443</code>, and add port <code>53</code>. The line should now look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>tcp dport { 22, 53 } ct state new accept</code></pre>
</div>
<p>Note how you can use one nftables rule to open multiple ports.</p>
<p>DNS also uses port <code>53/udp</code>, so let's add a line for it:</p>
<div class="C0-SHConPACKT">
<pre><code>udp dport 53 ct state new accept</code></pre>
</div>
<p>When you're only opening one port, you don't need to enclose that port number within curly brackets. When opening multiple ports, just include the comma-separated list within curly brackets, with a blank space after each comma, before the first element, and after the last element.</p>
<p>Load the configuration file and view the results:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu2204-packt:/etc$ sudo systemctl reload nftables
donnie@ubuntu2204-packt:/etc$ sudo nft list ruleset
table inet filter {
    chain input {
        type filter hook input priority 0; policy accept;
        iif &quot;lo&quot; accept
        ct state established,related accept
        tcp dport { ssh, domain } ct state new accept
        udp dport domain ct state new accept
        icmpv6 type { nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert } accept
        counter packets 1 bytes 32 drop
    }
}
donnie@ubuntu2204-packt:/etc$</code></pre>
</div>
<p>The <code>counter drop</code> rule is another example of how an nftables rule can do multiple things. In this case, the rule drops and counts unwanted packets. So far, the rule has blocked one packet and 32 bytes. To demonstrate how this works, let's say that we want to make a log entry when packets are dropped. Just add the <code>log</code> keyword to the <code>drop</code> rule, like so:</p>
<div class="C0-SHConPACKT">
<pre><code>counter log drop</code></pre>
</div>
<p>To make these messages easier to find, add a tag to each log message, like this:</p>
<div class="C0-SHConPACKT">
<pre><code>counter log prefix &quot;Dropped packet: &quot; drop</code></pre>
</div>
<p>Now, when you need to peruse the <code>/var/log/kern.log</code> file to see how many dropped packets you've had, just search for the <code>Dropped packet</code> text string.</p>
<p>Now, let's say that we want to block certain IP addresses from reaching the Secure Shell port of this machine. To do this, we can edit the file, placing a <code>drop</code> rule above the rule that opens port <code>22</code>. The relevant section of the file would look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>tcp dport 22 ip saddr { 192.168.0.7, 192.168.0.10 } log prefix &quot;Blocked SSH packets: &quot; drop
tcp dport { 22, 53 } ct state new accept</code></pre>
</div>
<p>After we reload the file, we'll be blocking SSH access from two different IPv4 addresses. Any attempts to log in from either of those two addresses will create a <code>/var/log/kern.log</code> message with the <code>Blocked SSH packets</code> tag. Note that we've placed the <code>drop</code> rule ahead of the <code>accept</code> rule because if the <code>accept</code> rule gets read first, the <code>drop</code> rule won't have an effect.</p>
<p>Next, we need to allow the desired types of ICMP packets, like so:</p>
<div class="C0-SHConPACKT">
<pre><code>ct state new,related,established icmp type { destination-unreachable, time-exceeded, parameter-problem } accept
ct state established,related,new icmpv6 type { destination-unreachable, time-exceeded, parameter-problem } accept</code></pre>
</div>
<p>In this case, you need separate rules for ICMPv4 and ICMPv6.</p>
<p>Finally, we'll block invalid packets by adding a new prerouting chain to the filter table, like so:</p>
<div class="C0-SHConPACKT">
<pre><code>chain prerouting {
                type filter hook prerouting priority 0;
                ct state invalid counter log prefix &quot;Invalid Packets:  &quot; drop
                tcp flags &amp; (fin|syn|rst|ack) != syn ct state new counter log drop
        }</code></pre>
</div>
<p>Now, we can save the file and close the text editor.</p>
<blockquote>
<p>Due to formatting constraints, I can't show the entire completed file here. To see the whole file, download the code file from the Packt website, and look in the <code>Chapter 4</code> directory. The example file you seek is the <code>nftables_example_1.conf</code> file.</p>
</blockquote>
<p>Now, let's load up the new rules:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo systemctl reload nftables</code></pre>
</div>
<p>Another really cool thing to note is how we've mixed IPv4 (ip) rules with IPv6 (ip6) rules in the same configuration file. Also, unless we specify otherwise, all the rules that we create will apply to both IPv4 and IPv6. That's the beauty of using an inet-type table. For simplicity and flexibility, you'll want to use inet tables as much as possible, rather than separate tables for IPv4 and IPv6.</p>
<p>Most of the time, when all you need is just a simple host firewall, your best bet would be to just use this <code>nftables.conf</code> file as your starting point, and edit the file to suit your own needs. However, there's also a command-line component that you may find useful.</p>
</section>
<section id="using-nft-commands" class="level3" data-number="5.5.3">
<h3 data-number="5.5.3">Using nft commands</h3>
<p>My preferred method of working with nftables is to just start with a template and hand-edit it to my liking, as we did in the previous section. But for those who'd rather do everything from the command line, there's the nft utility.</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>Even if you know that you'll always create firewalls by hand-editing <code>nftables.conf</code>, there are still a couple of practical reasons to know about the nft utility.</p>
</blockquote>
<blockquote>
<p>Let's say that you've observed an attack in progress, and you need to stop it quickly without bringing down the system. With an <code>nft</code> command, you can create a custom rule on the fly that will block the attack. Creating nftables rules on the fly also allows you to test the firewall as you configure it, before making any permanent changes.</p>
</blockquote>
<blockquote>
<p>And, if you decide to take a Linux security certification exam, you might see questions about <code>nft</code> commands. (I happen to know.)</p>
</blockquote>
</blockquote>
<p>There are two ways to use the <code>nft</code> utility. For one, you could just do everything directly from the Bash shell, prefacing every action you want to perform with <code>nft</code>, followed by the <code>nft</code> subcommands. The other way is to use <code>nft</code> in interactive mode. For our present purposes, we'll just go with the Bash shell.</p>
<p>First, let's delete our previous configuration and create an <code>inet</code> table since we want something that works for both IPv4 and IPv6. We'll want to give it a somewhat descriptive name, so let's call it <code>ubuntu_filter</code>:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft delete table inet filter
sudo nft list tables
sudo nft add table inet ubuntu_filter
sudo nft list tables</code></pre>
</div>
<p>Next, we'll add an input filter chain to the table that we just created (note that since we're doing this from the Bash shell, we need to escape the semicolon with a backslash):</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft add chain inet ubuntu_filter input { type filter hook input priority 0\; policy drop\; }</code></pre>
</div>
<p>We could have given it a more descriptive name, but for now, <code>input</code> works. Within the pair of curly brackets, we're setting the parameters for this chain.</p>
<p>Each nftables protocol family has its own set of hooks, which define how packets will be processed. For now, we're only concerned with the ip/ip6/inet families, which have the following hooks:</p>
<ul>
<li>Prerouting</li>
<li>Input</li>
<li>Forward</li>
<li>Output</li>
<li>Postrouting</li>
</ul>
<p>Of these, we're only concerned with the input and output hooks, which apply to filter-type chains. By specifying a hook and a priority for our input chain, we're saying that we want this chain to be a base chain that will accept packets directly from the network stack. You will also see that certain parameters must be terminated by a semicolon, which in turn would need to be escaped with a backslash if you're running the commands from the Bash shell. Finally, we're specifying a default policy of <code>drop</code>. If we had not specified <code>drop</code> as the default policy, then the policy would have been <code>accept</code> by default.</p>
<blockquote>
<p>Tip:</p>
<blockquote>
<p>Every <code>nft</code> command that you enter takes effect immediately. So, if you're doing this remotely, you'll drop your Secure Shell connection as soon as you create a filter chain with a default <code>drop</code> policy.</p>
</blockquote>
<blockquote>
<p>Some people like to create chains with a default <code>accept</code> policy, and then add a <code>drop</code> rule as the final rule. Other people like to create chains with a default <code>drop</code> policy, and then leave off the <code>drop</code> rule at the end. Be sure to check your local procedures to see what your organization prefers.</p>
</blockquote>
</blockquote>
<p>Verify that the chain has been added. You should see something like this:</p>
<div class="C0-SHConPACKT">
<pre><code>donnie@ubuntu2004-packt:~$ sudo nft list table inet ubuntu_filter
 [sudo] password for donnie:
 table inet filter {
       chain input {
             type filter hook input priority 0; policy drop;
       }
 }
 donnie@ubuntu2004-packt:~$</code></pre>
</div>
<p>That's great, but we still need some rules. Let's start with a connection tracking rule and a rule to open the Secure Shell port. Then, we'll verify that they were added:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft add rule inet ubuntu_filter input ct state established accept
sudo nft add rule inet ubuntu_filter input tcp dport 22 ct state new accept
sudo nft list table inet ubuntu_filter
 table inet ubuntu_filter {
     chain input {
         type filter hook input priority 0; policy drop;
         ct state established accept
         tcp dport ssh ct state new accept
     }
 }</code></pre>
</div>
<p>Okay, that looks good. You now have a basic, working firewall that allows Secure Shell connections. Well, except that just as we did in the in the iptables section of this chapter, we forgot to create a rule to allow the loopback adapter to accept packets. Since we want this rule to be at the top of the rules list, we'll use <code>insert </code>instead of <code>add</code>:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft insert rule inet ubuntu_filter input iif lo accept
sudo nft list table inet ubuntu_filter
 table inet ubuntu_filter {
       chain input {
              type filter hook input priority 0; policy drop;
              iif lo accept
              ct state established accept
              tcp dport ssh ct state new accept
      }
 }</code></pre>
</div>
<p>Now, we're all set. But what if we want to insert a rule at a specific location? For that, you'll need to use list with the <code>-a</code> option to see the rule handles:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft list table inet ubuntu_filter -a
 table inet ubuntu_filter {
        chain input {
                 type filter hook input priority 0; policy drop;
                 iif lo accept # handle 4
                 ct state established accept # handle 2
                 tcp dport ssh ct state new accept # handle 3
       }
 }</code></pre>
</div>
<p>As you can see, there's no real rhyme or reason to the way the handles are numbered. Let's say that we want to insert the rule about blocking certain IP addresses from accessing the Secure Shell port. We can see that the SSH <code>accept</code> rule is <code>handle 3</code>, so we'll need to insert our <code>drop</code> rule before it. This command will look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft insert rule inet ubuntu_filter input position 3 tcp dport 22 ip saddr { 192.168.0.7, 192.168.0.10 } drop
sudo nft list table inet ubuntu_filter -a
 table inet ubuntu_filter {
         chain input {
                  type filter hook input priority 0; policy drop;
                  iif lo accept # handle 4
                  ct state established accept # handle 2
                  tcp dport ssh ip saddr { 192.168.0.10, 192.168.0.7} drop # handle 6
                  tcp dport ssh ct state new accept # handle 3
         }
 }</code></pre>
</div>
<p>So, to place the rule before the rule with the <code>handle 3</code> label, we have to insert it at position <code>3</code>. The new rule that we just inserted has the label <code>handle 6.</code> To delete a rule, we have to specify the rule's handle number:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft delete rule inet ubuntu_filter input handle 6
sudo nft list table inet ubuntu_filter -a
 table inet ubuntu_filter {
       chain input {
              type filter hook input priority 0; policy drop;
              iif lo accept # handle 4
              ct state established accept # handle 2
              tcp dport ssh ct state new accept # handle 3
      }
 }</code></pre>
</div>
<p>As is the case with iptables, everything you do from the command line will disappear once you reboot the machine. To make it permanent, let's redirect the output of the <code>list</code> subcommand to the <code>nftables.conf</code> configuration file (of course, we'll want to have made a backup copy of the already-existing file, in case we want to revert back to it):</p>
<div class="C0-SHConPACKT">
<pre><code>sudo sh -c &quot;nft list table inet ubuntu_filter &gt; /etc/nftables.conf&quot;</code></pre>
</div>
<p>Due to a quirk in the Bash shell, we can't just redirect output to a file in the <code>/etc/</code> directory in the normal manner, even when we use <code>sudo</code>. That's why I had to add the <code>sh -c</code> command, with the <code>nft list</code> command surrounded by double quotes. Also, note that the file has to be named <code>nftables.conf</code> because that's what the nftables systemd service looks for. Now, when we look at the file, we'll see that there are a couple of things that are missing:</p>
<div class="C0-SHConPACKT">
<pre><code>table inet ubuntu_filter { 
    chain input { 
        type filter hook input priority 0; policy drop; 
        iif lo accept 
        ct state established accept 
        tcp dport ssh ct state new accept 
    } 
}</code></pre>
</div>
<p>Those of you who are sharp-eyed will see that we're missing the <code>flush</code> rule and the shebang line to specify the shell that we want to interpret this script. Let's add them:</p>
<div class="C0-SHConPACKT">
<pre><code>#!/usr/sbin/nft -f 
flush ruleset 
table inet ubuntu_filter { 
    chain input { 
         type filter hook input priority 0; policy drop; 
         iif lo accept 
         ct state established accept 
         tcp dport ssh ct state new accept 
   } 
} </code></pre>
</div>
<p>Much better. Let's test this by loading the new configuration and observing the <code>list</code> output:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo systemctl reload nftables
sudo nft list table inet ubuntu_filter
 table inet ubuntu_filter {
        chain input {
                 type filter hook input priority 0; policy drop;
                 iif lo accept
                 ct state established accept
                 tcp dport ssh ct state new accept
       }
 }</code></pre>
</div>
<p>That's all there is to creating your own simple host firewall. Of course, running commands from the command line, rather than just creating a script file in your text editor, does make for a lot more typing. However, it does allow you to test your rules on the fly, as you create them. And creating your configuration in this manner and then redirecting the <code>list</code> output to your new configuration file relieves you of the burden of having to keep track of all of those curly brackets as you try to hand-edit the file.</p>
<p>It's also possible to take all of the <code>nft</code> commands that we just created and place them into a regular, old-fashioned Bash shell script. Trust me, though, you really don't want to do that. Just use the nft-native scripting format, as we've done here, and you'll have a script that performs better and is much more human-readable.</p>
<section id="hands-on-lab-for-nftables-on-ubuntu" class="level4" data-number="5.5.3.1">
<h4 data-number="5.5.3.1">Hands-on lab for nftables on Ubuntu</h4>
<p>For this lab, you'll need a clean snapshot of your Ubuntu 22.04 virtual machine. Let’s get started.</p>
<p>Restore your Ubuntu virtual machine to a clean snapshot to clear out any firewall configurations that you created previously. (Or, if you refer, start with a new virtual machine.) Disable ufw and verify that no firewall rules are present:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo systemctl disable --now ufw
sudo iptables -L</code></pre>
</div>
<p>You should see no rules listed for nftables.</p>
<p>Copy the <code>workstation.nft</code> template over to the <code>/etc/</code> directory and rename it <code>nftables.conf</code>:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo cp /usr/share/doc/nftables/examples/syntax/workstation /etc/nftables.conf</code></pre>
</div>
<p>Edit the <code>/etc/nftables.conf</code> file to create your new configuration. (Note that due to formatting constraints, I have to break this into three different code blocks.) Make the top portion of the file look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>#!/usr/sbin/nft -f flush ruleset
table inet filter {
    chain prerouting {
        type filter hook prerouting priority 0;
        ct state invalid counter log prefix &quot;Invalid Packets:  &quot; drop
        tcp flags &amp; (fin|syn|rst|ack) != syn ct state new counter log prefix &quot;Invalid Packets 2: &quot; drop
}</code></pre>
</div>
<p>Make the second portion of the file look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>chain input {
    type filter hook input priority 0;
    # accept any localhost traffic
    iif lo accept
    # accept traffic originated from us
    ct state established,related accept
        # activate the following line to accept common local services
        tcp dport 22 ip saddr { 192.168.0.7, 192.168.0.10 } log prefix &quot;Blocked SSH packets: &quot; drop
        
        tcp dport { 22, 53 } ct state new accept
        udp dport 53 ct state new accept
        ct state new,related,established icmp type { destination-unreachable, time-exceeded, parameter-problem } accept</code></pre>
</div>
<p>Make the final portion of the file look like this:</p>
<div class="C0-SHConPACKT">
<pre><code>       ct state new,related,established icmpv6 type { destination-unreachable, time-exceeded, parameter-problem } accept
        # accept neighbour discovery otherwise IPv6 connectivity breaks.
        ip6 nexthdr icmpv6 icmpv6 type { nd-neighbor-solicit,  nd-router-advert, nd-neighbor-advert } accept
# count and drop any other traffic
    counter log prefix &quot;Dropped packet: &quot; drop
     }
}</code></pre>
</div>
<p>Save the file and reload nftables:</p>
<div class="C0-SHConPACKT">
<pre><code>     sudo systemctl reload nftables</code></pre>
</div>
<p>View the results:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft list tables
sudo nft list tables
sudo nft list table inet filter
sudo nft list ruleset</code></pre>
</div>
<p>From either your host computer or from another virtual machine, do a Windows scan against the Ubuntu virtual machine:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nmap -sW ip_address_of_UbuntuVM</code></pre>
</div>
<p>Look at the packet counters to see which blocking rule was triggered. (Hint: It's in the prerouting chain.):</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft list ruleset</code></pre>
</div>
<p>This time, do a null scan of the virtual machine:</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nmap -sN ip_address_of_UbuntuVM</code></pre>
</div>
<p>Finally, look at which rule was triggered this time. (Hint: It's the other one in the prerouting chain.):</p>
<div class="C0-SHConPACKT">
<pre><code>sudo nft list ruleset</code></pre>
</div>
<p>In the <code>/var/log/kern.log</code> file, search for the <code>Invalid Packets</code> text string to view the messages about the dropped invalid packets.</p>
<p>That's the end of this lab – congratulations!</p>
<p>In this section, we looked at the ins and outs of nftables, and looked at ways to configure it to help prevent certain types of attacks. In the next chapter, we’ll look at the helper programs for our helper programs.</p>
</section>
</section>
</section>
<section id="summary-3" class="level2" data-number="5.6">
<h2 data-number="5.6">Summary</h2>
<p>In this chapter, we looked at both of the helper programs that directly interface with the netfilter firewall. First, we looked at our trusty old friend, iptables. We saw that even though it's been around forever and still works, it does have some shortcomings. Then, we worked with nftables, and saw that it has certain advantages over the old iptables.</p>
<p>In the space that's been allotted for this chapter, I've only been able to present the essentials that you need in order to set up basic host protection. However, this should be enough to get you started.</p>
<p>In the next chapter, we'll look at ufw and firewalld, which are helper programs for the two helper programs that we discussed in this chapter. I’ll see you there.</p>
</section>
<section id="questions-3" class="level2" data-number="5.7">
<h2 data-number="5.7">Questions</h2>
<ol>
<li>Which of the following statements is true?
<ol type="A">
<li>iptables is the easiest firewall system to work with.</li>
<li>With iptables, any rule that you create applies to both IPv4 and IPv6.</li>
<li>With iptables, you have to create IPv6 rules separately from IPv4 rules.</li>
<li>With nftables, you have to create IPv6 rules separately from IPv4 rules.</li>
</ol></li>
<li>What is the official name of the Linux firewall?
<ol type="A">
<li>iptables</li>
<li>ufw</li>
<li>nftables</li>
<li>netfilter</li>
</ol></li>
<li>Which of the following statements about nftables is false?
<ol type="A">
<li>With nftables, rules are added atomically.</li>
<li>With nftables, a table refers to a particular protocol family.</li>
<li>With nftables, ports and their associated rules are bundled into zones.</li>
<li>With nftables, you can write scripts in either normal bash shell scripting, or with the scripting engine that's built into nftables.</li>
</ol></li>
<li>Which iptables command would show you how many packets have been dropped by a particular rule?</li>
<li>Which nftables command would you use to see how many packets have been dropped by a particular rule?</li>
<li>In iptables, which of the following targets would cause packets to be blocked without sending a notification back to the source?
<ol type="A">
<li><code>STOP</code></li>
<li><code>DROP</code></li>
<li><code>REJECT</code></li>
<li><code>BLOCK</code></li>
</ol></li>
<li>Which of the following six choices are tables in iptables?
<ol type="A">
<li>netfilter</li>
<li>filter</li>
<li>mangle</li>
<li>security</li>
<li>ip6table</li>
<li>NAT</li>
</ol></li>
<li>Which firewall system loads its rules atomically?</li>
</ol>
</section>
<section id="further-reading-3" class="level2" data-number="5.8">
<h2 data-number="5.8">Further reading</h2>
<ul>
<li>25 iptables netfilter firewall examples: <a href="https://www.cyberciti.biz/tips/linux-iptables-examples.html">https://www.cyberciti.biz/tips/linux-iptables-examples.html</a></li>
<li>Linux IPv6 how-to: <a href="http://tldp.org/HOWTO/html_single/Linux+IPv6-HOWTO/">http://tldp.org/HOWTO/html_single/Linux+IPv6-HOWTO/</a></li>
<li>Recommendations for Filtering ICMPv6 Messages in Firewalls: <a href="https://www.ietf.org/rfc/rfc4890.txt">https://www.ietf.org/rfc/rfc4890.txt</a></li>
<li>nftables wiki: <a href="https://wiki.nftables.org/wiki-nftables/index.php/Main_Page">https://wiki.nftables.org/wiki-nftables/index.php/Main_Page</a></li>
<li>nftables examples: <a href="https://wiki.gentoo.org/wiki/Nftables/Examples">https://wiki.gentoo.org/wiki/Nftables/Examples</a></li>
</ul>
</section>
<section id="answers-1" class="level2" data-number="5.9">
<h2 data-number="5.9">Answers</h2>
<ol>
<li>C</li>
<li>D</li>
<li>C</li>
<li>sudo iptables -L -v</li>
<li>sudo nft list ruleset</li>
<li>B</li>
<li>B, C, D, F</li>
<li>nftables</li>
</ol>
</section>
</section>
</body>
</html>
