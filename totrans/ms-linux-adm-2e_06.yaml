- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Working with Disks and Filesystems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用磁盘和文件系统
- en: 'In this chapter, you will learn how to manage disks and filesystems, how to
    use the **Logical Volume Management** (**LVM**) system, and how to mount and partition
    the hard drive, as well as gain an understanding of storage in Linux. You will
    also learn how to partition and format a disk, as well as how to create logical
    volumes, and you will gain a deeper understanding of filesystem types. In this
    chapter, we’re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何管理磁盘和文件系统，如何使用**逻辑卷管理**（**LVM**）系统，以及如何挂载和分区硬盘，并且深入了解Linux中的存储。你还将学习如何对磁盘进行分区和格式化，如何创建逻辑卷，并对文件系统类型有更深刻的理解。在本章中，我们将涵盖以下主要内容：
- en: Understanding devices in Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Linux中的设备
- en: Understanding filesystem types in Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Linux中的文件系统类型
- en: Understanding disks and partitions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解磁盘和分区
- en: Introducing LVM in Linux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux中介绍LVM
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A basic knowledge of disks, partitions, and filesystems is preferred. No other
    special technical requirements are needed, just a working installation of Linux
    on your system. We will mainly use Ubuntu or Debian for this chapter’s exercises.
    All the commands used in this chapter can be replicated on any Linux distribution,
    even if you don’t use Debian or Ubuntu.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 了解磁盘、分区和文件系统的基础知识是推荐的。没有其他特殊的技术要求，只需要你的系统上有一个正常运行的Linux安装。我们将在本章练习中主要使用Ubuntu或Debian。即使你不使用Debian或Ubuntu，本章中使用的所有命令都可以在任何Linux发行版上复制。
- en: Understanding devices in Linux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Linux中的设备
- en: As already stated on several occasions in this book, everything in Linux is
    a file. This also includes devices. **Device files** are special files in Unix
    and Linux operating systems. Those special files are interfaces to device drivers,
    and they are present in the filesystem as a regular file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中多次提到的，Linux中的一切都是文件。设备也不例外。**设备文件**是Unix和Linux操作系统中的特殊文件。这些特殊文件是设备驱动程序的接口，并且作为常规文件出现在文件系统中。
- en: With no further ado, let’s see how Linux abstraction layers work. This will
    give you an overview of how hardware and software are related and interconnected.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不再多说，我们来看看Linux的抽象层如何工作。这将为你提供硬件与软件如何相互关联和交织的概览。
- en: Linux abstraction layers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux抽象层
- en: 'Now is as good a time as any to discuss Linux system abstraction layers and
    how devices fit into the overall picture. Any computer is generally organized
    into two layers (or levels) – the hardware and the software levels:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论Linux系统抽象层以及设备如何融入整体架构的最佳时机。任何计算机通常都被组织为两个层级（或级别）——硬件层和软件层：
- en: '**Hardware level**: This level contains the hardware components of your machine,
    such as the memory (RAM), **central processing unit** (**CPU**), and devices,
    including disks, network interfaces, ports, and controllers.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬件层级**：此层包含你计算机的硬件组件，如内存（RAM）、**中央处理单元**（**CPU**）和设备，包括磁盘、网络接口、端口和控制器。'
- en: '**Software level**: For all these hardware components to work, the operating
    system (Linux, in our case) uses **abstraction layers**. Those layers exist in
    the **kernel**, which is the main software component of Linux. Without diving
    into more information, it is sufficient for you to know that Linux has these layers
    that are responsible for accessing low-level resources and providing the specific
    drivers for different hardware components. When the computer is booted up, the
    Linux kernel is loaded from the disk into the system’s memory (RAM). Thus, inside
    the memory, there will be two separate regions, called **kernel space** and **user
    space**, and this would be the **software level**:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件层级**：为了让这些硬件组件正常工作，操作系统（在本书中为Linux）使用**抽象层**。这些层存在于**内核**中，内核是Linux的主要软件组件。在不深入更多信息的前提下，你只需知道，Linux有这些层，负责访问低级资源，并为不同硬件组件提供特定的驱动程序。当计算机启动时，Linux内核会从磁盘加载到系统内存（RAM）中。因此，在内存中将有两个独立的区域，称为**内核空间**和**用户空间**，这将构成**软件层级**：'
- en: The kernel is the beating heart of the Linux operating system. The kernel resides
    inside the memory (RAM) and manages all the hardware components. It is the *interface*
    between the software and hardware on your Linux system.
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核是Linux操作系统的核心。内核驻留在内存（RAM）中，管理所有硬件组件。它是你Linux系统中软件与硬件之间的*接口*。
- en: The user space level is the level where user processes are executed. As presented
    in [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104), *Working with Processes, Daemons,
    and Signals*, a process is a running instance of a program.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间级别是执行用户进程的层次。正如在 [*第5章*](B19682_05.xhtml#_idTextAnchor104) 《处理进程、守护进程和信号》
    中所展示的，进程是程序的运行实例。
- en: Where are devices in this grand scheme of things? Devices are managed by the
    *kernel*. To sum up, the kernel is in charge of managing processes, system calls,
    memory, and devices. When dealing with devices, the kernel manages **device drivers**,
    which are the interface between hardware components and software. All devices
    are accessible only in kernel mode, for a more secure and streamlined operation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个宏大的体系结构中，设备在哪里呢？设备由 *内核* 来管理。总的来说，内核负责管理进程、系统调用、内存和设备。在处理设备时，内核管理 **设备驱动程序**，它们是硬件组件与软件之间的接口。所有设备只能在内核模式下访问，以确保更加安全和高效的操作。
- en: How does all this work? Well, the memory, known as RAM, consists of cells that
    are used to store information temporarily. Those cells are accessed by different
    programs that are executed and function as an intermediary between the CPU and
    the storage. The speeds of accessing memory are very high to secure a seamless
    process of execution. The management of user processes inside the user space is
    the kernel’s job. The kernel makes sure that none of the processes will interfere
    with each other. The kernel space is usually accessed only by the kernel, but
    there are times when user processes need to access this space. This is done through
    **system calls**. A system call is the way a user process requests a kernel service
    through an active process inside the kernel space, for anything such as **input/output**
    (**I/O**) requests to internal or external devices. All those requests transfer
    data to and from the CPU, through RAM, to get the job done.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切是如何运作的呢？实际上，内存（也就是 RAM）由用于临时存储信息的单元组成。这些单元被不同的程序访问，这些程序作为 CPU 和存储之间的中介。访问内存的速度非常高，以确保执行过程的流畅性。用户空间内的用户进程管理是内核的工作。内核确保没有任何进程会相互干扰。内核空间通常只由内核访问，但有时用户进程也需要访问这个空间。这是通过
    **系统调用** 来实现的。系统调用是用户进程通过内核空间内的活动进程请求内核服务的一种方式，涉及的内容包括 **输入/输出**（**I/O**）请求，来与内部或外部设备进行交互。所有这些请求都将数据从
    CPU 通过 RAM 传输，以完成任务。
- en: In the following section, we will introduce you to the naming convention in
    Linux and how device files are managed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍 Linux 中的命名规则以及设备文件的管理方式。
- en: Device files and naming conventions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备文件和命名规则
- en: After seeing how the abstraction layers work, you may be wondering how Linux
    manages devices. Well, it does that with the help of **userspace /dev** (**udev**),
    which is a device manager for the kernel. It works with **device nodes**, which
    are special files (also called **device files**) that are used as an interface
    to the driver.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了抽象层的工作原理后，你可能会想知道 Linux 如何管理设备。其实，Linux 是通过 **用户空间 /dev**（**udev**）来管理设备的，它是一个为内核提供服务的设备管理器。它通过
    **设备节点** 来工作，设备节点是特殊的文件（也叫 **设备文件**），用于作为驱动程序的接口。
- en: Device files in Linux
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux 中的设备文件
- en: '`udev` runs as a daemon that listens to the user space calls that the kernel
    is sending, so it is aware of what kinds of devices are used and how they are
    used. The daemon is called `udevd` and its configurations are currently available
    under `/etc/udev/udev.conf`. You can concatenate the `/etc/udev/udev.conf` file
    to see its contents by running the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`udev` 作为一个守护进程运行，监听内核发送的用户空间调用，因此它能够知道使用了哪些设备，以及如何使用这些设备。这个守护进程叫做 `udevd`，其配置文件目前存储在
    `/etc/udev/udev.conf` 下。你可以通过运行以下命令来查看 `/etc/udev/udev.conf` 文件的内容：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each Linux distribution has a default set of rules that governs `udevd`. Those
    rules are normally stored under the `/etc/udev/rules.d/` directory, as shown in
    the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Linux 发行版都有一套默认的规则来管理 `udevd`。这些规则通常存储在 `/etc/udev/rules.d/` 目录下，正如下面的截图所示：
- en: '![Figure 6.1 – udevd rules location](img/B19682_06_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – udevd 规则位置](img/B19682_06_01.jpg)'
- en: Figure 6.1 – udevd rules location
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – udevd 规则位置
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The kernel sends calls for events using the **Netlink** socket. The netlink
    socket is an interface for inter-process communication that’s used for both userspace
    and kernel space processes alike.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过 **Netlink** 套接字发送事件调用。Netlink 套接字是一种用于进程间通信的接口，适用于用户空间和内核空间的进程。
- en: 'The `/dev` directory is the interface between user processes and devices managed
    by the kernel. If you were to use the `ls -la /dev` command, you would see a lot
    of files inside, each with different names. If you were to do a long listing,
    you would see different file types. Some of the files will start with the letters
    *b* and *c*, but the letters *p* and *s* may also be present, depending on your
    system. Files starting with those letters are device files. The ones starting
    with *b* are **block devices**, and those starting with the letter *c* are **character
    devices**, as shown in the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev` 目录是用户进程与内核管理的设备之间的接口。如果你使用 `ls -la /dev` 命令，你会看到很多文件，每个文件都有不同的名称。如果你使用长格式列出文件，你会看到不同的文件类型。某些文件名以
    *b* 和 *c* 开头，但根据你的系统，也可能会看到 *p* 和 *s* 开头的文件。以这些字母开头的文件是设备文件。以 *b* 开头的是**块设备**，而以
    *c* 开头的是**字符设备**，如下所示的屏幕截图所示：'
- en: '![Figure 6.2 – Device files inside the /dev directory](img/B19682_06_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – /dev 目录中的设备文件](img/B19682_06_02.jpg)'
- en: Figure 6.2 – Device files inside the /dev directory
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – /dev 目录中的设备文件
- en: Let’s see how disk devices are presented inside the `/dev` directory. But first,
    we’ve provided a few words about our working setup in the following note.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看磁盘设备如何在 `/dev` 目录中呈现。但首先，我们在以下提示中提供了有关工作环境的几句话。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For most of the exercises in this book, we will be using virtual machines with
    planet names as hostnames, running different Linux-based operating systems. For
    example, `neptune` is running on Ubuntu 22.04.2 LTS Server, so when you see the
    `neptune` hostname on the shell’s prompt, you will know we are on an Ubuntu-based
    system. We also have `jupiter`, running on the openSUSE 15.4 Leap server, `saturn`
    running on Fedora 37 Workstation, `venus` running on AlmaLinux, and `mars` running
    on a Debian 11.6 server. Inside a virtual machine, device drivers are presented
    with different names than on bare-metal systems. We will provide details when
    we discuss device naming conventions in the following section. For some examples,
    though, which are marked accordingly, we will also use our primary workstation,
    which is running on Debian 12 GNU/Linux.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大部分练习将使用以行星名称为主机名的虚拟机，运行不同的基于 Linux 的操作系统。例如，`neptune` 运行的是 Ubuntu 22.04.2
    LTS Server，因此当你在终端提示符中看到 `neptune` 主机名时，你就知道我们正在使用基于 Ubuntu 的系统。我们还使用了 `jupiter`，运行在
    openSUSE 15.4 Leap 服务器上，`saturn` 运行在 Fedora 37 Workstation 上，`venus` 运行在 AlmaLinux
    上，`mars` 运行在 Debian 11.6 服务器上。在虚拟机中，设备驱动程序的命名与裸机系统有所不同。我们将在接下来的部分讨论设备命名约定时提供详细信息。不过，对于一些示例（已做标记），我们也会使用我们的主工作站，运行的是
    Debian 12 GNU/Linux。
- en: 'As shown in *Figure 6**.3*, the disk device, `sda`, is represented as a block
    device. Block devices have a fixed size that can easily be indexed. Character
    devices, on the other hand, can be accessed using data streams, as they don’t
    have a size like block devices. For example, printers are represented as character
    devices. In the following screenshot, `sg0` is an SCSI generic device, and not
    assigned to any disks in our case. We used our primary workstation running on
    Debian GNU/Linux and the device presented as `sda` is an external USB device:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 6.3* 所示，磁盘设备 `sda` 作为块设备表示。块设备具有固定大小，可以方便地进行索引。另一方面，字符设备可以通过数据流进行访问，因为它们不像块设备那样有固定的大小。例如，打印机作为字符设备表示。在下面的屏幕截图中，`sg0`
    是一个 SCSI 通用设备，在我们的例子中没有分配给任何磁盘。我们使用了运行在 Debian GNU/Linux 上的主工作站，作为 `sda` 展示的设备是一个外部
    USB 设备：
- en: '![Figure 6.3 – Disk drives inside the /dev directory](img/B19682_06_03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – /dev 目录中的磁盘驱动器](img/B19682_06_03.jpg)'
- en: Figure 6.3 – Disk drives inside the /dev directory
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – /dev 目录中的磁盘驱动器
- en: 'In comparison, when listing devices from our `neptune` virtual machine, we
    will have the output presented in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，当列出 `neptune` 虚拟机中的设备时，我们将看到如下所示的输出：
- en: '![Figure 6.4 – Virtual devices inside a virtual machine](img/B19682_06_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 虚拟机中的虚拟设备](img/B19682_06_04.jpg)'
- en: Figure 6.4 – Virtual devices inside a virtual machine
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 虚拟机中的虚拟设备
- en: Device blocks presented with `vdaX` are virtual devices inside the virtual machine.
    You will learn more about virtual machines in [*Chapter 11*](B19682_11.xhtml#_idTextAnchor231),
    *Working with* *Virtual Machines*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `vdaX` 表示的设备块是虚拟机中的虚拟设备。你将在[*第 11 章*](B19682_11.xhtml#_idTextAnchor231)中了解到更多关于虚拟机的内容，*与虚拟机的工作*。
- en: But for now, let’s find out more about device naming conventions in Linux.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，让我们先了解一下 Linux 中的设备命名约定。
- en: Understanding device naming conventions
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解设备命名规范
- en: 'Linux uses a device naming convention that makes device management easier and
    more consistent throughout the Linux ecosystem. `udev` uses several specific naming
    schemes that, by default, assign fixed names to devices. Those names are standardized
    for device categories. For example, when naming network devices, the kernel uses
    information compiled from sources such as firmware, topology, and location. On
    a Red Hat-based system, five schemes are used for naming a network interface,
    and we encourage you to look at these on the Red Hat customer portal official
    documentation website: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 使用一种设备命名规范，使得设备管理在整个 Linux 生态系统中变得更加容易和一致。`udev` 使用几种特定的命名方案，默认情况下将固定的名称分配给设备。这些名称是根据设备类别标准化的。例如，在命名网络设备时，内核使用来自固件、拓扑和位置等来源的信息。在基于
    Red Hat 的系统中，有五种方案用于命名网络接口，我们鼓励你查看 Red Hat 客户门户官网文档：[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9)。
- en: On a Debian-based system, the naming convention is similar in that it’s based
    on hardware buses’ names for predictability. This is similar to all modern Linux-based
    operating systems.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 Debian 的系统中，命名规范也类似，它是基于硬件总线名称来实现可预测性。这与所有现代 Linux 操作系统类似。
- en: You could also check what `udev` rules are active on your system. On Debian
    and Red Hat-based distributions, they are stored in the `/``lib/udev/rules.d/`
    directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看系统上哪些`udev`规则是活跃的。在基于 Debian 和 Red Hat 的发行版中，它们存储在 `/lib/udev/rules.d/`
    目录下。
- en: 'When it comes to hard drives or external drives, the conventions are more streamlined.
    Here are some examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬盘或外部硬盘方面，命名规范更加简化。以下是一些示例：
- en: '`hda` (the master device), `hdb` (the slave device on the first channel), `hdc`
    (the master device on the second channel), and `hdd` (the slave device on the
    second channel)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hda`（主设备）、`hdb`（第一个通道上的从设备）、`hdc`（第二个通道上的主设备）、`hdd`（第二个通道上的从设备）'
- en: '`nvme0` (the first device controller – character device), `nvme0n1` (first
    namespace – block device), and `nvme0n1p1` (first namespace, first partition –
    block device)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nvme0`（第一个设备控制器 – 字符设备）、`nvme0n1`（第一个命名空间 – 块设备），以及`nvme0n1p1`（第一个命名空间，第一个分区
    – 块设备）'
- en: '`mmcblk` (for SD cards using eMMC chips), `mmcblk0` (first device), and `mmcblk0p1`
    (first device, first partition)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmcblk`（用于使用 eMMC 芯片的 SD 卡）、`mmcblk0`（第一个设备），以及`mmcblk0p1`（第一个设备，第一个分区）'
- en: '`sd` (for mass storage devices), `sda` (for the first registered device), `sdb`
    (for the second registered device), `sdc` (for the third registered device), and
    so on, and `sg` (for generic SCSI layers – character device)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sd`（用于大容量存储设备）、`sda`（第一个注册设备）、`sdb`（第二个注册设备）、`sdc`（第三个注册设备），依此类推，以及`sg`（用于通用
    SCSI 层 – 字符设备）'
- en: The devices that we are most interested in regarding this chapter are the mass
    storage devices. Those devices are usually **hard disk drives** (**HDDs**) or
    **solid-state drives** (**SSDs**), which are used inside your computer to store
    data. These drives are most likely divided into partitions with a specific structure
    provided by the filesystem. We talked a little bit about filesystems earlier in
    this book in [*Chapter 2*](B19682_02.xhtml#_idTextAnchor053), *The* *Linux Shell
    and* *Filesystem*, when we referred to the Linux directory structure, but now,
    it is time to get into more details about filesystem types in Linux.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们最关注的设备是大容量存储设备。这些设备通常是**硬盘驱动器**（**HDDs**）或**固态硬盘**（**SSDs**），用于计算机内部存储数据。这些驱动器很可能会根据文件系统提供的特定结构被划分为多个分区。我们之前在本书的[*第二章*](B19682_02.xhtml#_idTextAnchor053)《Linux
    Shell 和 文件系统》中简单讨论了文件系统，当时我们提到过 Linux 目录结构，但现在，是时候深入了解 Linux 中的文件系统类型了。
- en: Understanding filesystem types in Linux
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Linux 中的文件系统类型
- en: When talking about physical media, such as hard drives or external drives, we
    are *not* referring to the directory structure. Here, we are talking about the
    structures that are created on the physical drive when formatting and/or partitioning
    it. These structures, depending on their type, are known as filesystems, and they
    determine how the files are managed when stored on the drive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论物理介质时，比如硬盘或外部硬盘时，我们*并不是*在讨论目录结构。这里我们讨论的是在格式化和/或分区时，在物理硬盘上创建的结构。这些结构根据其类型被称为文件系统，它们决定了文件在存储到硬盘时如何被管理。
- en: There are several types of filesystems, some being native to the Linux ecosystem,
    while others are not, such as specific Windows or macOS filesystems. In this section,
    we will describe only the Linux-native filesystems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的文件系统，其中一些是 Linux 生态系统的原生文件系统，而其他则不是，例如特定的 Windows 或 macOS 文件系统。在本节中，我们将仅描述
    Linux 原生的文件系统。
- en: The most widely used filesystems in Linux are the `Ext`, `Ext2`, `Ext3`, and
    `Ext4`, the `XFS` filesystem, `ZFS`, and `btrfs` (short for `Ext4`, the latest
    iteration, is similar to `Ext3`, but better, with improved support for larger
    files, fragmentation, and performance. The `Ext3` filesystem uses 32-bit addressing,
    while `Ext4` uses 48-bit addressing, thus supporting files up to 16 TB in size.
    It also offers support for unlimited subdirectories as `Ext3` only supports 32k
    subdirectories. Also, support for extended timestamps was added in `Ext4`, offering
    two more bits for up to the year 2446 AD, and online defragmentation at the kernel
    level.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中最常用的文件系统包括 `Ext`、`Ext2`、`Ext3` 和 `Ext4`，`XFS` 文件系统，`ZFS` 和 `btrfs`（简而言之，`Ext4`
    是 `Ext3` 的最新版本，它在支持更大文件、碎片管理和性能方面进行了改进，比 `Ext3` 更好。`Ext3` 文件系统使用 32 位寻址，而 `Ext4`
    使用 48 位寻址，因此支持最大 16 TB 的文件大小。它还支持无限子目录，因为 `Ext3` 仅支持 32k 个子目录。此外，`Ext4` 中还新增了对扩展时间戳的支持，提供额外的两位，以支持到公元
    2446 年，并且支持在内核层面进行在线碎片整理。
- en: Nonetheless, `Ext4` is not a truly next-gen filesystem; rather, it is an improved,
    trustworthy, robust, and stable *workhorse* that failed the data protection and
    integrity test. Its journaling system is not suitable for detecting and repairing
    data corruption and degradation. That is why other filesystems, such as `XFS`
    and `ZFS`, started to resurface by being used in Red Hat Enterprise Linux, starting
    from version 7 (`XFS`) and in Ubuntu since version 16.04 (`ZFS`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`Ext4` 仍然不是一个真正的下一代文件系统；它更像是一个经过改进、值得信赖、稳健且稳定的 *工作马*，但在数据保护和完整性方面并未通过测试。它的日志系统不适合检测和修复数据损坏或降级问题。这就是为什么其他文件系统，如
    `XFS` 和 `ZFS`，开始重新出现并被应用于 Red Hat Enterprise Linux 7 版本开始使用 `XFS`，以及从 Ubuntu 16.04
    版本起使用 `ZFS` 的原因。
- en: The case of `btrfs` is somewhat controversial. It is considered a modern filesystem,
    but it is still used as a single-disk filesystem and not used in multiple disk
    volume managers due to several performance issues compared to other filesystems.
    It is used in SUSE Linux Enterprise and openSUSE, is no longer supported by Red
    Hat, and has been voted as the future default filesystem in Fedora, starting with
    version 33.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`btrfs` 的情况有些争议。它被认为是一个现代文件系统，但由于与其他文件系统相比存在多个性能问题，它仍然只作为单盘文件系统使用，并未在多盘卷管理器中得到广泛应用。它被用于
    SUSE Linux Enterprise 和 openSUSE，但不再被 Red Hat 支持，并已被投票选为 Fedora 从版本 33 开始的未来默认文件系统。'
- en: 'Here are some more details on the major filesystem features:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些主要文件系统特性的详细信息：
- en: '`Ext4` filesystem was designed for Linux right from the outset. Even though
    it is slowly being replaced with other filesystems, this one still has powerful
    features. It offers block size selection, with values between 512 and 4,096 bytes.
    There is also a feature called inode reservation, which saves a couple of inodes
    when you create a directory, for improved performance when creating new files.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext4` 文件系统从一开始就为 Linux 设计。尽管它正在被其他文件系统逐渐替代，但它仍然具有强大的功能。它提供了块大小选择，大小范围在 512
    到 4,096 字节之间。它还具有 inode 保留功能，在创建目录时保留一些 inode，从而在创建新文件时提高性能。'
- en: 'The layout is simple, written in `Ext4` takes advantage of. Among them, we
    will bring the following into the discussion: a maximum filesystem size of 1 `fsck`
    command for speedy filesystem checks, the use of checksums for journaling and
    better reliability, and the use of improved timestamps.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 布局简单，`Ext4` 文件系统在此方面有所利用。在讨论中，我们将涉及以下几点：最大文件系统大小、使用 `fsck` 命令进行快速文件系统检查、为日志系统使用校验和提高可靠性，以及改进的时间戳使用。
- en: '**ZFS**: This filesystem was created at Sun Microsystems and combines a file
    system and a logical volume manager into one solution. It was announced in 2004,
    with development starting in 2001, and was first integrated into the Solaris operating
    system, then used (not the default though) by Debian, FreeBSD, and others. ZFS
    is a highly scalable 128-bit system that offers simple administration, data integrity,
    scalability, and performance. Development of this filesystem is done through the
    **OpenZFS** open source project. ZFS offers a complex structure by using a copy-on-write
    mechanism, different from traditional filesystems. For more detailed information
    about ZFS, we recommend the following link: [https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html](https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ZFS**：这个文件系统是在 Sun Microsystems 创建的，它将文件系统和逻辑卷管理器结合为一个解决方案。它于 2004 年发布，开发始于
    2001 年，最初集成到 Solaris 操作系统中，后来被 Debian、FreeBSD 等使用（虽然不是默认的）。ZFS 是一个高度可扩展的 128 位系统，提供简单的管理、数据完整性、可扩展性和性能。该文件系统的开发通过
    **OpenZFS** 开源项目进行。ZFS 采用了一种写时复制机制，与传统文件系统不同，从而提供了一种复杂的结构。有关 ZFS 的更多详细信息，我们推荐以下链接：[https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html](https://openzfs.github.io/openzfs-docs/Getting%20Started/index.html)。'
- en: '`Ext4` to other competent filesystem types. Among those is `XFS`. This filesystem
    was first created by Silicon Graphics, Inc and used in the IRIX operating system.
    Its most important key design element is performance as it is capable of dealing
    with large datasets. Furthermore, it is designed to handle parallel I/O tasks
    with a guaranteed high I/O rate. The filesystem supports up to 16 EB with support
    for individual files up to 8 EB. `XFS` has a feature to journal quota information,
    together with online maintenance tasks such as defragmenting, enlarging, and restoring.
    There are also specific tools for backup and restore, including `xfsdump` and
    `xfsrestore`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext4` 以及其他有竞争力的文件系统类型。其中之一是 `XFS`。这个文件系统最初由 Silicon Graphics, Inc 创建，并在 IRIX
    操作系统中使用。它最重要的设计元素是性能，因为它能够处理大型数据集。此外，它被设计为能够处理并行 I/O 任务，保证高 I/O 速率。该文件系统支持最大 16
    EB，单个文件最大支持 8 EB。`XFS` 有一个日志记录配额信息的功能，并支持在线维护任务，如碎片整理、扩展和恢复。还提供了备份和恢复的专用工具，包括
    `xfsdump` 和 `xfsrestore`。'
- en: '`btrfs`) is still under development, but it addresses issues associated with
    existing filesystems, including the lack of snapshots, pooling, checksums, and
    multi-device spanning. These are features that are required in an enterprise Linux
    environment. The ability to take snapshots of the filesystem and maintain its
    internal framework for managing new partitions makes `btrfs` a viable newcomer
    in terms of the critical enterprise ecosystem.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btrfs` 仍在开发中，但它解决了现有文件系统的一些问题，包括缺少快照、池化、校验和和多设备跨越等功能。这些都是企业 Linux 环境中所需的功能。能够对文件系统进行快照并维护其内部框架以管理新的分区，使得
    `btrfs` 在企业关键生态系统中成为一个可行的新兴选项。'
- en: There are other filesystems that we did not discuss here, including `cat /``proc/filesystems`
    command.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些我们没有在此讨论的文件系统，包括使用 `cat /``proc/filesystems` 命令查看的文件系统。
- en: 'Linux implements a special software system that is designed to run specific
    functions of the filesystems. It is known as the **virtual file system** and acts
    as a bridge between the kernel and the filesystem types and hardware. Therefore,
    when an application wants to open a file, the action is delivered through the
    Virtual File System as an abstraction layer:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 实现了一个特殊的软件系统，旨在运行文件系统的特定功能。它被称为**虚拟文件系统**，充当内核与文件系统类型和硬件之间的桥梁。因此，当应用程序想要打开文件时，操作通过虚拟文件系统作为抽象层传递：
- en: '![Figure 6.5 – The Linux Virtual File System abstraction layer](img/B19682_06_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – Linux 虚拟文件系统抽象层](img/B19682_06_05.jpg)'
- en: Figure 6.5 – The Linux Virtual File System abstraction layer
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – Linux 虚拟文件系统抽象层
- en: Basic filesystem functions include provisioning namespaces, metadata structures
    as a logical foundation for hierarchical directory structures, disk block usage,
    file size and access information, and high-level data for logical volumes and
    partitions. There is also an **application programming interface** (**API**) available
    for every filesystem. Thus, developers can access system function calls for filesystem
    object manipulation with specific algorithms for creating, moving, and deleting
    files, or for indexing, searching, and finding files. Furthermore, every modern
    filesystem provides a special access rights scheme that’s used to determine the
    rules governing a user’s access to files.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的文件系统功能包括为分层目录结构提供命名空间、元数据结构作为逻辑基础、磁盘块使用情况、文件大小和访问信息，以及逻辑卷和分区的高级数据。每个文件系统还有一个**应用程序编程接口**（**API**）。因此，开发人员可以访问系统功能调用，利用特定的算法进行文件的创建、移动、删除，或进行索引、搜索和查找文件。此外，每个现代文件系统都提供了一个特殊的访问权限方案，用于确定用户访问文件的规则。
- en: At this point, we have already covered the principal Linux filesystems, including
    `EXT4`, `btrfs`, and `XFS`. In the next section, we will teach you the basics
    of disks and partition management in Linux.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了主要的Linux文件系统，包括`EXT4`、`btrfs`和`XFS`。在下一节中，我们将教授你Linux中磁盘和分区管理的基础知识。
- en: Understanding disks and partitions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解磁盘和分区
- en: Understanding disks and partitions is a key asset for any system administrator.
    Formatting and partitioning disks is critical, starting with system installation.
    Knowing the type of hardware available on your system is important, and it is
    therefore imperative to know how to work with it. One of these is the disk; let’s
    look at this in further detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 理解磁盘和分区是任何系统管理员的关键技能。格式化和分区磁盘至关重要，从系统安装开始。了解系统上可用的硬件类型非常重要，因此必须掌握如何使用这些硬件。其中之一就是磁盘；我们来进一步了解一下。
- en: Common disk types
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的磁盘类型
- en: 'A **disk** is a hardware component that stores your data. It comes in various
    types and uses different interfaces. The main disk types are the well-known **spinning
    HDD**, the SSD, and the **non-volatile memory express** (**NVMe**). SSDs and NVMes
    use RAM-like technologies, with better energy consumption and higher transfer
    rates than original spinning hard drives. The following interfaces are used:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁盘**是存储数据的硬件组件。它有多种类型，并使用不同的接口。主要的磁盘类型包括广为人知的**旋转硬盘HDD**、SSD和**非易失性存储器Express**（**NVMe**）。SSD和NVMe使用类似RAM的技术，具有比传统旋转硬盘更低的能耗和更高的传输速率。以下是使用的接口：'
- en: '**Integrated Drive Electronics** (**IDE**): This is an old standard that’s
    used on consumer hardware with small transfer rates. It’s now deprecated.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成驱动电子**（**IDE**）：这是一种旧标准，广泛应用于具有较小传输速率的消费类硬件，现已被弃用。'
- en: '**Serial Advanced Technology Attachment** (**SATA**): This replaced IDEs and
    has transfer rates of up to 16 GB/s.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行先进技术附件**（**SATA**）：这取代了IDE，具有最高16 GB/s的传输速率。'
- en: '**Small Computer Systems Interface** (**SCSI**): This is used mostly in enterprise
    servers with RAID configurations with sophisticated hardware components.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型计算机系统接口**（**SCSI**）：这主要用于具有RAID配置的企业服务器，配备了复杂的硬件组件。'
- en: '**Serial Attached SCSI** (**SAS**): This is a point-to-point serial protocol
    interface with transfer rates similar to SATA. It is mostly used in enterprise
    environments for their reliability.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行附加SCSI**（**SAS**）：这是一种点对点串行协议接口，传输速率类似于SATA。它主要用于企业环境，因为其可靠性。'
- en: '**Universal Serial Bus** (**USB**): This is used for external hard drives and
    memory drives.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用串行总线**（**USB**）：这用于外部硬盘和存储设备。'
- en: Each disk has a specific geometry that consists of heads, cylinders, tracks,
    and sectors. On a Linux system, to see the information regarding a disk’s geometry,
    you can use the `fdisk -``l` command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个磁盘都有特定的几何结构，包括磁头、磁道、柱面和扇区。在Linux系统中，要查看磁盘几何结构的信息，可以使用`fdisk -l`命令。
- en: 'On our primary workstation, we have a single SSD running Debian 12 GNU/Linux
    and a USB device inserted in one of the ports. We will run the following command
    to obtain information about the drives on our machine:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主要工作站上，我们有一个单独的SSD运行Debian 12 GNU/Linux，并且一个USB设备插入其中一个端口。我们将运行以下命令以获取有关机器上驱动器的信息：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows excerpts of the `fdisk` command’s output for
    both drives:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了`fdisk`命令输出的摘录，涉及两块驱动器：
- en: '![Figure 6.6 – The output of the fdisk -l command showing disk information](img/B19682_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – fdisk -l 命令输出显示磁盘信息](img/B19682_06_06.jpg)'
- en: Figure 6.6 – The output of the fdisk -l command showing disk information
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – fdisk -l 命令输出显示磁盘信息
- en: 'The output of the `fdisk` utility may look intimidating at first, but rest
    assured that we will explain it to you so that it will look friendlier from now
    on. By using the `fdisk` utility without a specific partition as an argument,
    all the partition information available inside `/proc/partitions` will be shown.
    In the example shown in the preceding screenshot, you have details on two disks
    that are available on our system: a 1 TB Lexar NM620 SSD and an 8 GB USB flash
    drive attached. Let’s explain how the 1 TB drive is shown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdisk` 工具的输出初看起来可能让人感到有些复杂，但请放心，我们会为你解释，使其从现在开始变得更容易理解。通过不指定特定分区作为参数来使用 `fdisk`
    工具，所有 `/proc/partitions` 中可用的分区信息都会显示出来。在前面的截图中，你可以看到系统中有两个磁盘的详细信息：一块 1 TB 的 Lexar
    NM620 SSD 和一块 8 GB 的 USB 闪存驱动器。我们来解释一下如何显示 1 TB 硬盘的信息：'
- en: First, you have `Disk model` with the name of the drive, `Units` as sectors,
    each of which has a size of 512 bytes, `Disklabel type` as GPT, and `Disk identifier`,
    which is unique for each drive.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你会看到 `Disk model` 显示的是驱动器的名称，`Units` 为扇区，每个扇区大小为 512 字节，`Disklabel type`
    为 GPT，`Disk identifier` 是每个驱动器唯一的标识符。
- en: Next is a table of the partitions available on the disk. This table has six
    columns (sometimes seven columns, as in the case of the USB flash drive, shown
    on the lower side of the screenshot). The first column has the `Device` header
    and shows the partition naming scheme. The second and third columns (in our example)
    show the starting and ending sectors. The fourth column shows the total number
    of sectors on the partition. The fifth column shows the size of the partition
    in human-readable format and the last column shows the type of the filesystem.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是磁盘上可用分区的表格。这个表有六列（有时是七列，比如在截图底部显示的 USB 闪存驱动器）。第一列有 `Device` 标头，显示分区命名方案。第二列和第三列（在我们的例子中）显示分区的起始和结束扇区。第四列显示分区的总扇区数。第五列显示分区的大小（以人类可读的格式），最后一列显示文件系统的类型。
- en: Knowing basic information about disk devices on your system is merely the starting
    point for working with disks and partitions on Linux. Disks are just a big chunk
    of metal if we don’t format and partition them so that the system can use them.
    This is why, in the next section, we will teach you what partitions are.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 了解系统上磁盘设备的基本信息仅仅是操作 Linux 系统中磁盘和分区的起点。如果我们不对磁盘进行格式化和分区，它们只是大块的金属。因此，在下一节中，我们将教你什么是分区。
- en: Partitioning disks
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘分区
- en: 'Commonly, disks use **partitions**. To understand partitions, knowing a disk’s
    geometry is essential. This legacy knowledge base is useful even when dealing
    with SSDs. Partitions are contiguous sets of sectors and/or cylinders, and they
    can be of several types: **primary**, **extended**, and **logical** partitions.
    A maximum number of 15 partitions can exist on a disk. The first four will be
    either primary or extended, and the remaining are logical partitions. Furthermore,
    there can only be a single extended partition, but they can be divided into several
    logical partitions until the maximum number is reached.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，磁盘使用**分区**。要理解分区，了解磁盘的几何结构是至关重要的。这些传统的知识即使在处理 SSD 时仍然有用。分区是连续的扇区和/或磁道集合，它们可以有几种类型：**主分区**、**扩展分区**和**逻辑分区**。每个磁盘最多可以有
    15 个分区。前四个分区将是主分区或扩展分区，其余的则是逻辑分区。此外，磁盘上只能有一个扩展分区，但它可以被划分为多个逻辑分区，直到达到最大数量为止。
- en: Partition types
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区类型
- en: There are two major partition types – the `0x0c` for FAT, `0x07` for NTFS, `0x83`
    for a Linux filesystem type, and `0x82` for swap. GPT became a part of the **Unified
    Extensible Firmware Interface** (**UEFI**) standard as a solution to some issues
    with MBR, including partition limitations, addressing methods, using only one
    copy of the partition table, and so on. It supports up to 128 partitions and disk
    sizes of up to 75.6 **Zettabytes** (**ZB**).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的分区类型 – `0x0c` 代表 FAT，`0x07` 代表 NTFS，`0x83` 代表 Linux 文件系统类型，`0x82` 代表交换分区（swap）。GPT
    成为**统一扩展固件接口**（**UEFI**）标准的一部分，解决了 MBR 的一些问题，包括分区限制、寻址方式、只使用一个分区表副本等等。它支持最多 128
    个分区，磁盘大小可以达到 75.6 **泽字节**（**ZB**）。
- en: The partition table
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区表
- en: The **partition table** of a disk is stored inside the disk’s MBR. MBR is the
    first 512 bytes of a drive. Out of these, the partition table is 64 bytes and
    is stored after the first 446 bytes of records. At the end of MBR, there are 2
    bytes known as the end of sector marker. The first 446 bytes are reserved for
    code that usually belongs to a bootloader program. In the case of Linux, the bootloader
    is called **GRand Unified** **Bootloader** (**GRUB**).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘的 **分区表** 存储在磁盘的 MBR 中。MBR 是磁盘的前 512 字节。其中，分区表占 64 字节，存储在前 446 字节的记录之后。在 MBR
    的末尾，有 2 字节称为扇区结束标记。前 446 字节保留给通常属于引导加载程序的代码。在 Linux 中，引导加载程序称为 **GRand Unified**
    **Bootloader** (**GRUB**)。
- en: When you boot up a Linux system, the bootloader looks for the active partition.
    There can only be one active partition on a single disk. When the active partition
    is located, the bootloader loads items. The partition table has 4 entries, each
    of which is 16 bytes in size, with each belonging to a possible primary partition
    on the system. Furthermore, each entry contains information regarding the beginning
    address of `cylinder/head/sectors`, the partition type code, the end address of
    `cylinder/head/sectors`, the starting sector, and the number of sectors inside
    one partition.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动 Linux 系统时，引导加载程序会查找活动分区。单个磁盘上只能有一个活动分区。找到活动分区后，引导加载程序会加载相关项目。分区表有 4 个条目，每个条目的大小为
    16 字节，每个条目属于系统中的某个可能的主分区。此外，每个条目包含有关 `柱面/磁头/扇区` 的起始地址、分区类型代码、`柱面/磁头/扇区` 的结束地址、起始扇区和分区内扇区的数量等信息。
- en: Naming partitions
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区命名
- en: 'The kernel interacts with the disk at a low level. This is done through device
    nodes that are stored inside the `/dev` directory. Device nodes use a simple naming
    convention that tells you which disk is the one that requires your attention.
    Looking at the contents of the `/dev` directory, you can see all the available
    disk nodes, also referred to as disk drives, in *Figure 6**.2* and *Figure 6**.3*
    earlier in this section. A short explanation is always useful, so disks and partitions
    are recognized as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过低级方式与磁盘交互。这是通过存储在 `/dev` 目录中的设备节点来完成的。设备节点使用简单的命名约定，告诉您哪个磁盘需要关注。查看 `/dev`
    目录的内容，您可以看到所有可用的磁盘节点，也称为磁盘驱动器，参见本节前面的 *图 6.2* 和 *图 6.3*。简短的说明总是很有用，因此磁盘和分区的识别如下：
- en: The first hard drive is always `/dev/sda` (for an SCSI or SATA device)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一块硬盘始终是 `/dev/sda`（对于 SCSI 或 SATA 设备）
- en: The second hard drive is `/dev/sdb`, the third is `/dev/sdc`, and so on
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二块硬盘是 `/dev/sdb`，第三块是 `/dev/sdc`，以此类推
- en: The first partition of the first disk is `/dev/sda1`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个磁盘的第一个分区是 `/dev/sda1`
- en: The first partition of the second disk is `/dev/sdb1`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个磁盘的第一个分区是 `/dev/sdb1`
- en: The second partition of the second disk is `/dev/sdb2`, and so on
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个磁盘的第二个分区是 `/dev/sdb2`，以此类推
- en: We specified that this is true in the case of an SCSI and SATA, and we need
    to explain this in a little more detail. The kernel gives the letter designation,
    such as *a*, *b*, and *c*, based on the ID number of the SCSI device, and not
    based on the position of the hardware bus.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定在 SCSI 和 SATA 的情况下是这样的，接下来我们需要稍微详细地解释一下。内核会根据 SCSI 设备的 ID 号给出字母标识，例如 *a*、*b*
    和 *c*，而不是根据硬件总线的位置来决定。
- en: Partition attributes
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区属性
- en: 'To learn about your partition’s attributes, you can use the `lsblk` command.
    We will run it on our Debian system, as shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解分区的属性，您可以使用 `lsblk` 命令。我们将在我们的 Debian 系统上运行它，如下图所示：
- en: '![Figure 6.7 – The output of lsblk](img/B19682_06_07.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – lsblk 输出](img/B19682_06_07.jpg)'
- en: Figure 6.7 – The output of lsblk
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – lsblk 输出
- en: The `lsblk` command shows the device’s name (the node’s name from `sysfs` and
    the `udev` database), the major and minor device number, the removable state of
    the device (`0` for a non-removable device and `1` for a removable device), the
    size in human-readable format, the read-only state (again, using `0` for the ones
    that are not read-only and `1` for the read-only ones), the type of device, and
    the device’s mount point (where available).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsblk` 命令显示设备的名称（来自 `sysfs` 和 `udev` 数据库的节点名称）、主设备号和次设备号、设备的可拆卸状态（`0` 表示非可拆卸设备，`1`
    表示可拆卸设备）、以人类可读格式显示的大小、只读状态（使用 `0` 表示非只读，`1` 表示只读）、设备类型以及设备的挂载点（如果有的话）。'
- en: Now that we know more about the drive, let’s learn how to alter a disk’s partition
    table.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对驱动器有了更多了解，接下来我们来学习如何修改磁盘的分区表。
- en: Partition table editors
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分区表编辑器
- en: 'In Linux, there are several tools we can use when managing partition tables.
    Among the most commonly used ones are the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，管理分区表时有几种工具可以使用。最常用的工具包括以下几种：
- en: '`fdisk`: A command-line partition editor, perhaps the most widely used one'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fdisk`：一个命令行分区编辑器，可能是最广泛使用的一个'
- en: '`Sfdisk`: A non-interactive partition editor, used mostly in scripting'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sfdisk`：一个非交互式的分区编辑器，主要用于脚本编写'
- en: '`parted`: The GNU (the recursive acronym for GNU is *GNU''s Not Unix*) partition
    manipulation software'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parted`：GNU（GNU是*GNU''s Not Unix*的递归首字母缩写）分区操作软件'
- en: '`gparted`: The graphical interface for `parted`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gparted`：`parted`的图形界面'
- en: Of these, we will only detail how to use `fdisk` as this is the most widely
    used command-line partition editor in Linux. It is found in both Ubuntu/Debian
    and RHEL/Fedora or openSUSE and many other distributions too.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些工具中，我们只详细介绍如何使用`fdisk`，因为它是Linux中最广泛使用的命令行分区编辑器。它在Ubuntu/Debian、RHEL/Fedora、openSUSE以及许多其他发行版中都能找到。
- en: 'But before we use `fdisk`, we would like to see the partitions that the operating
    system knows about. If you are not sure about the operations you just completed,
    you can always visualize the contents of the `/proc/partitions` file with the
    `cat` command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`fdisk`之前，我们希望查看操作系统已知的分区。如果你不确定刚刚完成的操作，可以使用`cat`命令查看`/proc/partitions`文件的内容：
- en: '![Figure 6.8 – Listing the /proc/partitions file](img/B19682_06_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 列出/proc/partitions文件](img/B19682_06_08.jpg)'
- en: Figure 6.8 – Listing the /proc/partitions file
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 列出/proc/partitions文件
- en: 'To use `fdisk`, you must be the root user. We advise you to use caution when
    using `fdisk` as it can damage your existing partitions and disks. `fdisk` can
    be used on a particular disk as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`fdisk`，你必须是root用户。我们建议你在使用`fdisk`时要小心，因为它可能会损坏你现有的分区和磁盘。你可以在特定磁盘上使用`fdisk`，方法如下：
- en: '![Figure 6.9 – Using fdisk for the first time](img/B19682_06_09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 第一次使用fdisk](img/B19682_06_09.jpg)'
- en: Figure 6.9 – Using fdisk for the first time
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 第一次使用fdisk
- en: You will notice that when using `fdisk` for the first time, you are warned that
    changes will be done to the disk only when you decide to write them to it. You
    will also be prompted to introduce a command, and you will be shown the `m` option
    for help. We advise you to always use the help menu, even if you already know
    the most used commands.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在第一次使用`fdisk`时，会有警告提示，表示只有在你决定将更改写入磁盘时，才会对磁盘进行更改。系统还会提示你输入命令，并会显示`m`选项以供帮助。我们建议你始终使用帮助菜单，即使你已经知道最常用的命令。
- en: When you type `m`, you will be shown the entire list of commands available for
    `fdisk`. You will see options to manage partitions, create new boot records, save
    changes, and others. Partition table editors are important tools for managing
    disks in Linux. Their use is incomplete if you do not know how to format a partition.
    In the next section, we will show you how to partition a disk drive.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入`m`时，将显示`fdisk`的完整命令列表。你将看到用于管理分区、创建新引导记录、保存更改等选项。分区表编辑器是管理Linux磁盘的重要工具。如果你不知道如何格式化分区，使用它们是不完整的。在接下来的部分，我们将向你展示如何对磁盘进行分区。
- en: Creating and formatting partitions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和格式化分区
- en: 'We will use the `fdisk` utility to create a new partition table on a USB memory
    stick plugged into our primary workstation running Debian GNU/Linux. We will create
    an MBR partition table using the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fdisk`工具在插入主工作站上的USB闪存驱动器（运行Debian GNU/Linux）上创建一个新的分区表。我们将使用以下命令创建MBR分区表：
- en: '[PRE2]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use the `o` option to create an empty MBR partition table and then
    the `w` option to save the changes to disk. The output of the command is shown
    in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`o`选项创建一个空的MBR分区表，然后使用`w`选项将更改保存到磁盘。命令的输出如下所示：
- en: '![Figure 6.10 – Creating a new MBR partition table with fdisk](img/B19682_06_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 使用fdisk创建新的MBR分区表](img/B19682_06_10.jpg)'
- en: Figure 6.10 – Creating a new MBR partition table with fdisk
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 使用fdisk创建新的MBR分区表
- en: With that, the partition table has been created, but there is no partition defined
    on the disk. While still inside the `fdisk` command-line interface, you can use
    the `v` option to verify the newly created partition table and the `I` option
    to see information about existing partitions. You will see some output saying
    that no partitions have been defined yet. So, it is time to set up a new partition.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，分区表已创建，但磁盘上尚未定义任何分区。仍然处于 `fdisk` 命令行界面时，您可以使用 `v` 选项验证新创建的分区表，使用 `I` 选项查看现有分区的信息。您将看到一些输出，表明尚未定义任何分区。因此，现在是时候设置一个新分区了。
- en: 'To create a new partition, we will use the following series of options:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新分区，我们将使用以下系列选项：
- en: The `n` option to start the creation processes
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `n` 选项启动创建过程
- en: The `p` option when asked to create either a primary (`p`) or extended (`e`)
    partition type
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当提示创建主分区（`p`）或扩展分区（`e`）类型时，使用 `p` 选项
- en: Enter the partition number (use the default of `1`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入分区号（使用默认值 `1`）
- en: Enter the first sector (use the default of `2048`)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入第一个扇区（使用默认值 `2048`）
- en: Enter the last sector – if you want a specific size for the partition, you can
    use size values in KB, MB, GB, and so on, or sector values (the default is the
    maximum size of the disk)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入最后一个扇区 – 如果您希望分区具有特定大小，可以使用 KB、MB、GB 等单位的大小值，或使用扇区值（默认是磁盘的最大大小）
- en: If asked to remove any signatures, type `Y` to remove them
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提示删除任何签名，输入 `Y` 以删除它们
- en: '`w` to write changes to disk'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` 用于将更改写入磁盘'
- en: 'The output of the previous series of actions is shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一系列操作的输出显示在以下屏幕截图中：
- en: '![Figure 6.11 – Creating a new partition with fdisk](img/B19682_06_11.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 使用 fdisk 创建新分区](img/B19682_06_11.jpg)'
- en: Figure 6.11 – Creating a new partition with fdisk
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 使用 fdisk 创建新分区
- en: With that, the partition has been created, but it hasn’t been formatted. Before
    we learn how to format partitions, let’s learn how to back up a partition table.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，分区已创建，但尚未格式化。在学习如何格式化分区之前，我们先来学习如何备份分区表。
- en: 'There are situations when you will need to back up and restore your `dd` utility.
    The command to use is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要备份并恢复您的 `dd` 工具。使用的命令如下：
- en: '[PRE3]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This program is very useful and powerful as it can clone disks or wipe data.
    Here is an example showing the output of the command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序非常有用且强大，因为它可以克隆磁盘或擦除数据。以下是一个展示命令输出的例子：
- en: '![Figure 6.12 – Backing up MBR with the dd command](img/B19682_06_12.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 使用 dd 命令备份 MBR](img/B19682_06_12.jpg)'
- en: Figure 6.12 – Backing up MBR with the dd command
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 使用 dd 命令备份 MBR
- en: The `dd` command has a clear syntax. By default, it uses the standard input
    and standard output, but you can change those by specifying new input files with
    the `if` option, and output files with the `of` option. We specified the input
    file as the device file for the disk we wanted to back up and gave a name for
    the backup output file. We also specified the block size using the `bs` option,
    and the `count` option to specify the number of blocks to read.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd` 命令有一个清晰的语法。默认情况下，它使用标准输入和标准输出，但您可以通过指定新输入文件（使用 `if` 选项）和输出文件（使用 `of` 选项）来更改这些。我们将输入文件指定为要备份的磁盘的设备文件，并为备份输出文件指定了名称。我们还使用
    `bs` 选项指定了块大小，并使用 `count` 选项指定了要读取的块数。'
- en: 'To restore the bootloader, we can use the `dd` command, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复引导加载程序，我们可以使用 `dd` 命令，如下所示：
- en: '[PRE4]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that you have learned how to use `dd` to back up a partition table, let’s
    format the partition we created earlier. The most commonly used program for formatting
    a filesystem on a partition is `mkfs`. Formatting a partition is also known as
    *making* a filesystem, hence the name of the utility. It has specific tools for
    different filesystems, all using the same frontend utility. The following is a
    list of all filesystems supported by `mkfs`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了如何使用 `dd` 备份分区表，我们来格式化之前创建的分区。格式化分区的最常用程序是 `mkfs`。格式化分区也称为*创建*文件系统，因此该工具的名称就是这么来的。它有针对不同文件系统的特定工具，但都使用相同的前端工具。以下是
    `mkfs` 支持的所有文件系统列表：
- en: '![Figure 6.13 – Details regarding the mkfs utility](img/B19682_06_13.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 关于 mkfs 工具的详细信息](img/B19682_06_13.jpg)'
- en: Figure 6.13 – Details regarding the mkfs utility
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 关于 mkfs 工具的详细信息
- en: 'To format the target disk as having the `Ext4` filesystem, we will use the
    `mkfs` utility. The commands to execute are shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将目标磁盘格式化为 `Ext4` 文件系统，我们将使用 `mkfs` 工具。执行的命令如下：
- en: 'First, we will run the `fdisk` utility to make sure that we select the largest
    disk correctly. Run the following command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将运行`fdisk`工具，以确保正确选择最大磁盘。运行以下命令：
- en: '[PRE5]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, check the output with extreme caution and select the correct disk name.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，极其小心地检查输出并选择正确的磁盘名称。
- en: 'Now that we know which disk to work with, we will use `mkfs` to format it as
    an `Ext4` filesystem. The output is shown here:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经知道要操作的磁盘，接下来我们将使用`mkfs`将其格式化为`Ext4`文件系统。输出如下所示：
- en: '![Figure 6.14 – Formatting an Ext4 partition using mkfs](img/B19682_06_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 使用mkfs格式化Ext4分区](img/B19682_06_14.jpg)'
- en: Figure 6.14 – Formatting an Ext4 partition using mkfs
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 使用mkfs格式化Ext4分区
- en: 'When using `mkfs`, there are several options available. To create an `Ext4`
    type partition, you can either use the command shown in *Figure 6**.14* or you
    can use the `-t` option followed by the filesystem type. You can also use the
    `-v` option for a more verbose output, and the `-c` option for bad sector scanning
    while creating the filesystem. You can also use the `-L` option if you want to
    add a label for the partition right from the command. The following is an example
    of creating an `Ext4` filesystem partition with the name `newpartition`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mkfs`时，有多个选项可供选择。要创建一个`Ext4`类型的分区，你可以使用*图6.14*中显示的命令，也可以使用`-t`选项后跟文件系统类型。你还可以使用`-v`选项以获取更详细的输出，使用`-c`选项扫描坏道并创建文件系统。如果你想在命令中直接添加分区标签，还可以使用`-L`选项。以下是创建一个名为`newpartition`的`Ext4`文件系统分区的示例：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once a partition is formatted, it’s advised that you check it for errors. Similar
    to `mkfs`, there is a tool called `fsck`. This is a utility that sometimes runs
    automatically following an abnormal shutdown or on set intervals. It has specific
    programs for the most commonly used filesystems, just like `mkfs`. The following
    is the output of running `fsck` on one of our partitions. After running, it will
    show whether there are any problems. In the following screenshot, the output shows
    that checking the partition resulted in no errors:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分区格式化完成，建议检查其是否存在错误。类似于`mkfs`，有一个名为`fsck`的工具。这是一个有时会在异常关机后或按设定间隔自动运行的工具。它针对最常用的文件系统有特定的程序，就像`mkfs`一样。以下是运行`fsck`时显示的输出。运行后，它会显示是否有任何问题。在以下截图中，输出显示检查分区时没有发现错误：
- en: '![Figure 6.15 – Using fsck to check a partition](img/B19682_06_15.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 使用fsck检查分区](img/B19682_06_15.jpg)'
- en: Figure 6.15 – Using fsck to check a partition
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 使用fsck检查分区
- en: After partitions are created, they need to be mounted; otherwise, they cannot
    be used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分区后，需要将其挂载；否则，无法使用。
- en: Important note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**Mounting** is an important action in Linux, and any other operating system
    for that matter. By mounting, you give the operating system access to the disk
    resource in such a way that it looks like it is using a local disk. On Linux,
    the external disk that is mounted is linked to a mount point, which is a directory
    on the local filesystem. Mount points are essential to POSIX-compatible operating
    systems, such as Linux. Mounting a disk makes it accessible to the entire operating
    system through mount points. For more information on mounting, visit [https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html](https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载**是Linux以及任何其他操作系统中的一项重要操作。通过挂载，你为操作系统提供了访问磁盘资源的方式，使其看起来就像使用本地磁盘一样。在Linux中，挂载的外部磁盘会链接到挂载点，即本地文件系统上的一个目录。挂载点对于POSIX兼容的操作系统（如Linux）至关重要。挂载磁盘后，操作系统可以通过挂载点访问整个磁盘。有关挂载的更多信息，请访问[https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html](https://docs.oracle.com/cd/E19455-01/805-7228/6j6q7ueup/index.html)。'
- en: Each partition will be mounted inside the existing filesystem structure. Mounting
    is allowed at any point in the tree structure. Each filesystem is mounted under
    certain directories, created inside the directory structure. We will explore mounting
    and unmounting partitions in the next section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区将在现有的文件系统结构中挂载。挂载可以在树结构的任何位置进行。每个文件系统都会挂载在某些目录下，这些目录是在目录结构内部创建的。我们将在下一节中探讨挂载和卸载分区的过程。
- en: Mounting and unmounting partitions
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载和卸载分区
- en: 'The `mount`, and the `umount`. To see whether a certain partition is mounted,
    you can simply type `mount` and see the output, which will be of a significant
    size. You can use `grep` to filter it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`和`umount`。要查看某个分区是否已挂载，你可以简单地输入`mount`并查看输出，该输出可能会非常庞大。你可以使用`grep`来筛选它：'
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are looking for `/dev/sda` in the output, but it is not shown. This means
    that the drive is not mounted.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中查找 `/dev/sda`，但未显示出来。这意味着该驱动器未挂载。
- en: 'To mount it, we need to make a new directory. For simplicity, we will show
    all the steps required until you mount and use the partition:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了挂载它，我们需要创建一个新的目录。为了简便起见，我们将展示从创建目录到挂载并使用分区所需的所有步骤：
- en: 'Create a new directory to mount the partition. In our case, we created a new
    directory called `USB` inside the `/``home/alexandru` directory:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录来挂载分区。在我们的例子中，我们在`/home/alexandru`目录下创建了一个名为 `USB` 的新目录：
- en: '[PRE8]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Mount the partition using the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令挂载分区：
- en: '[PRE9]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: sudo cp mbr-backup USB/
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo cp mbr-backup USB/
- en: '[PRE10]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output for all the commands from the preceding list:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面列表中所有命令的输出：
- en: '![Figure 6.16 – Mounting an external memory stick](img/B19682_06_16.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 挂载外部存储设备](img/B19682_06_16.jpg)'
- en: Figure 6.16 – Mounting an external memory stick
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 挂载外部存储设备
- en: 'The `mount` command needs to be used with superuser permission. If you try
    to mount an external USB device without `sudo`, you will get the following message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 命令需要超级用户权限。如果你尝试在没有 `sudo` 的情况下挂载外部 USB 设备，你将看到以下消息：'
- en: '![Figure 6.17 – Error for not using sudo with mount](img/B19682_06_17.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 未使用 sudo 执行 mount 命令时的错误](img/B19682_06_17.jpg)'
- en: Figure 6.17 – Error for not using sudo with mount
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 未使用 sudo 执行 mount 命令时的错误
- en: 'The `mount` utility has many options available. Use the help menu to see everything
    that it has under the hood. Now that the partition has been mounted, you can start
    using it. If you want to unmount it, you can use the `umount` utility. You can
    use it as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount` 工具有许多可用选项。使用帮助菜单可以查看它的所有功能。现在分区已经挂载，你可以开始使用它。如果你想卸载它，可以使用 `umount`
    工具。你可以按照以下方式使用它：'
- en: '[PRE11]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When unmounting a filesystem, you may receive errors if that partition is still
    in use. Being in use means that certain programs from that filesystem are still
    running in memory, using files from that partition. Therefore, you first have
    to close all running applications, and if other processes are using that filesystem,
    you will have to kill them, too. Sometimes, the reason a filesystem is busy is
    not clear at first, and to know which files are open and running, you can use
    the `lsof` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载文件系统时，如果该分区仍在使用中，你可能会收到错误信息。被使用意味着该文件系统中的某些程序仍在内存中运行，并正在使用该分区中的文件。因此，你必须首先关闭所有正在运行的应用程序，如果其他进程正在使用该文件系统，你也需要终止它们。有时，文件系统忙碌的原因起初并不明显，你可以使用
    `lsof` 命令来查看哪些文件正在被打开和使用：
- en: '[PRE12]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Mounting a filesystem only makes it available until the system is shut down
    or rebooted. If you want the changes to be persistent, you will have to edit the
    `/etc/fstab` file accordingly. First, open the file with your favorite text editor:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载文件系统只会使其在系统关闭或重启之前可用。如果你希望更改具有持久性，你需要相应地编辑 `/etc/fstab` 文件。首先，用你喜欢的文本编辑器打开该文件：
- en: '[PRE13]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a new line similar to the one that follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一行与以下内容类似的新行：
- en: '[PRE14]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `/etc/fstab` file is a configuration file for the filesystem table. It
    consists of a set of rules needed to control how the filesystems are used. This
    simplifies the need to manually mount and unmount each disk when used, by drastically
    reducing possible errors. The table has a six-column structure, with each column
    designated with a specific parameter. There is only one correct order for the
    parameters to work:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/fstab` 文件是文件系统表的配置文件。它包含了一组用于控制文件系统使用方式的规则。通过大大减少可能的错误，它简化了每次使用时手动挂载和卸载每个磁盘的需求。该表有六列结构，每列对应特定的参数。参数的顺序是固定的，必须按正确顺序排列才能正常工作：'
- en: '**Device name**: Either by using UUID or the mounted device name'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备名称**：可以使用 UUID 或已挂载设备名称'
- en: '**Mount point**: The directory where the device is, or will be, mounted'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载点**：设备所在的目录，或者设备将被挂载的目录'
- en: '**Filesystem type**: The filesystem type used'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统类型**：所使用的文件系统类型'
- en: '**Options**: The options shown, with multiple ones separated by commas'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：显示的选项，如果有多个选项，则用逗号分隔'
- en: '`0` = no backup, `1` = dump utility backup'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` = 不进行备份，`1` = 执行 dump 工具备份'
- en: '`0` = no `fsck` filesystem check, with `1` for the root filesystem, and `2`
    for other partitions'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` = 不进行 `fsck` 文件系统检查，`1` 代表根文件系统，`2` 代表其他分区'
- en: By updating the `/etc/fstab` file, the mounting is permanent and is not affected
    by any shutdown or system reboot. Usually, the `/etc/fstab` file only stores information
    about the internal hard drive partitions and filesystems. The external hard drives
    or USB drives are automatically mounted under `/media` by the kernel’s **hardware
    abstraction** **layer** (**HAL**).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should be comfortable with managing partitions in Linux, but there
    is still one type of partition we have not discussed: the **swap partition**.
    In the next section, we will introduce you to how swap works on Linux.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Swap partition
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Linux uses a robust swap implementation. The virtual memory uses hard drive
    space when physical memory is full through swap. This additional space is made
    available either for the programs that do not use all the memory they are given,
    or when memory pressure is high. Swapping is usually done using one or more dedicated
    partitions as Linux permits multiple swap areas. The recommended swap size is
    at least the total RAM on the system. To check the actual swap used on the system,
    you can concatenate the `/proc/swaps` file or use the `free` command to see swap
    utilization, as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Checking the currently used swap](img/B19682_06_18.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Checking the currently used swap
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'If swap is not set up on your system, you can format a partition as swap and
    activate it. The commands to do that are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The operating system is caching file contents inside the memory to prevent the
    use of swap as much as possible. This happens because memory is working at much
    higher speeds compared to hard drives or hard disk drives. Only when available
    memory is limited will swap be used. However, the memory that the kernel uses
    is never swapped; only the memory that the user space is using gets to be swapped.
    This assures data integrity for the kernel. Refer to the utilities we applied
    in [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104) to show memory usage in Linux.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems and partitions are the bare bones of any disk management task, but
    there are still several hiccups that an administrator needs to overcome, and this
    can be solved by using logical volumes. This is why, in the next section, we will
    introduce you to LVM.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LVM in Linux
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you may have already heard of **LVM**. For those who do not know what
    it is, we will explain it briefly in this section. Imagine a situation where your
    disks run out of space. You can always move it to a larger disk and then replace
    the smaller one, but this implies system restarts and unwanted downtimes. As a
    solution, you can consider LVM, which offers more flexibility and efficiency.
    By using LVM, you can add more physical disks to your existing volume groups while
    they’re still in use. This still offers the possibility to move data to a new
    hard drive but with no downtime – everything is done while filesystems are online.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The utilities used in Linux for LVM management are called `pvcreate`, `vgcreate`,
    `vgdisplay`, `lvcreate`, `lvextend`, and `lvdisplay`. Let’s learn how to use them.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'As we don’t have a system with LVM set up just yet, we will show you the steps
    that are necessary to create new LVM volumes by using another system with two
    internal drives: one with the operating system installed on it, and a second,
    internal one that’s available. We’ll be using Debian GNU/Linux, but the commands
    are the same for any other Linux-based operating system.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create an LVM volume:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `fdisk` command to verify the names of the available disks (you can
    also use `lsblk` for this step):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the LVM physical volume with the `pvcreate` command:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Figure 6.19 – Using pvcreate to create an LVM physical volume](img/B19682_06_19.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Using pvcreate to create an LVM physical volume
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new volume group to add the new physical volume to using the `vgcreate`
    command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![Figure 6.20 – Creating and viewing details of the new volume](img/B19682_06_20.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Creating and viewing details of the new volume
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a logical volume using some of the space available from the
    volume group, using `lvcreate`. Use the `-n` option to add a name for the logical
    volume and `-L` to set the size in a human-readable manner (we created a 5 GB
    logical volume named `projects`):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Creating a logical volume using lvcreate](img/B19682_06_21.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Creating a logical volume using lvcreate
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the logical volume exists:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The newly created device can only be used if it’s formatted using a known filesystem
    and mounted afterward, in the same way as a regular partition. First, let’s format
    the new volume:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem](img/B19682_06_22.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Formatting the new logical volume as an Ext4 filesystem
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to mount the logical volume. First, create a new directory and
    mount the logical volume there. Then, check its size using the `df` command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Mounting the logical volume](img/B19682_06_23.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Mounting the logical volume
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'All changes implemented hitherto are not permanent. To make them permanent,
    you will have to edit the `/etc/fstab` file by adding the following within the
    file:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'lvextend command. We will extend the initial size by 5 GB, for a total of 10
    GB. The following is an example:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Figure 6.24 – Extending the logical volume using lvextend](img/B19682_06_24.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Extending the logical volume using lvextend
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, resize the filesystem so that it fits the new size of the logical volume
    using `resize2fs` and check for the size with `df`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Resizing the logical volume with resize2fs and checking for
    the size with df](img/B19682_06_25.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 6.25 – Resizing the logical volume with resize2fs and checking for the
    size with df
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: LVM is an advanced topic that will prove essential for any Linux system administrator
    to have. The brief hands-on examples we provided in this section only show the
    basic operations that you need to work with LVM. Feel free to dig deeper into
    this topic if you need to.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will discuss several more advanced LVM topics,
    including how to take full filesystem snapshots.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: LVM snapshots
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is an LVM snapshot? It is a frozen instance of an LVM logical volume. More
    specifically, it uses a **copy-on-write** technology. This technology monitors
    each block of the existing volume, and when blocks change, due to new writings,
    that block’s value is copied to the snapshot volume.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The snapshots are created constantly and instantly and persist until they are
    deleted. This way, you can create backups from any snapshot. As snapshots are
    constantly changing due to the copy-on-write technology, initial thoughts on the
    size of the snapshot should be given when creating one. Take into consideration,
    if possible, how much data is going to change during the existence of the snapshot.
    Once the snapshot is full, it will be automatically disabled.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new snapshot
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a new snapshot, you can use the `lvcreate` command, with the `-s`
    option. You can also specify the size with the `-L` option and add a name for
    the snapshot with the `-n` option, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – Creating an LVM snapshot with the lvcreate command](img/B19682_06_26.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – Creating an LVM snapshot with the lvcreate command
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding command, we set a size of 5 GB and used the name `linux-snapshot-01`.
    The last part of the command contains the destination of the volume for which
    we created the snapshot. To list the new snapshot, use the `lvs` command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – Listing the available volume and the newly created snapshot](img/B19682_06_27.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – Listing the available volume and the newly created snapshot
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the logical volumes, run the `lvdisplay` command. The
    output will show information about all the volumes, and among them, you will see
    the snapshot we just created.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created the snapshot, we gave it a size of 5 GB. Now, we would like
    to extend it to the size of the source, which was 10 GB. We will do this with
    the `lvextend` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Extending the snapshot from 5 to 10 GB](img/B19682_06_28.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – Extending the snapshot from 5 to 10 GB
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, the name that the snapshot volume is using
    is different from the one we used. Even though we used the name `linux-snapshot-01`
    for the snapshot volume, if we do a listing of the `/dev/mapper/` directory, we
    will see that the name uses two more dashes instead. This is a convention that’s
    used to represent logical volume files.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create snapshots, let’s learn how to restore a snapshot.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Restoring a snapshot
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To restore a snapshot, first, you would need to unmount the filesystem. To
    unmount, we will use the `umount` command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we can proceed to restore the snapshot with the `lvconvert` command.
    After the snapshot is merged into the source, we can check this by using the `lvs`
    command. The output of the two commands is shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – Restoring and checking the snapshot](img/B19682_06_29.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – Restoring and checking the snapshot
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Following the merge, the snapshot is automatically removed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered all the basics of LVM in Linux. LVM is more complicated
    than normal disk partitioning. It might be intimidating to many, but it can show
    its strengths when needed. Nevertheless, it also comes with several drawbacks
    – for example, it can add unwanted complexity in a disaster recovery scenario
    or when a hardware failure occurs. But all this aside, it is still worth learning
    about.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing filesystems and disks is an important task for any Linux system administrator.
    Understanding how devices are managed in Linux, and how to format and partition
    disks, is essential. Furthermore, it is important to learn about LVM as it offers
    a flexible way to manage partitions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Mastering those skills will give you a strong foundation for any basic administration
    task. In the following chapter, we will introduce you to the vast domain of **networking**
    in Linux.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you managed to skim through some parts of this chapter, you might want to
    recap a few essential details about Linux filesystem and disk management:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Think of another tool to use for working with disks and install it.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`parted` and use it from the command line. You can also use GParted from the
    GUI.'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Experiment with using Disks (in GNOME) and KDE Partition Manager (in KDE) and
    use the command-line interface side by side.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Keep both applications open and use the command-line utilities side
    by side. Try to format and mount a disk from the command line while keeping the
    GUI apps open.'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Format new partitions using different filesystems.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`btrfs` instead of `ext4`.'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explore your filesystem and disks.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`lsblk`, `df`, and `fdisk`.'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, please refer to
    the following Packt titles:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Administration Best Practices*, by Scott Alan Miller'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mastering Ubuntu Server – Fourth Edition*, by Jay LaCroix'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
