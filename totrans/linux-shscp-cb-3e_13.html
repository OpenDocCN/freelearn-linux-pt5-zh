<html><head></head><body>
        

            
                <h1 class="header-title">Containers, Virtual Machines, and the Cloud</h1>
            

            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using Linux Containers</li>
<li>Using Docker</li>
<li>Using Virtual Machines in Linux</li>
<li>Linux in the cloud</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Introduction</h1>
            

            
                
<p>Modern Linux applications can be deployed on dedicated hardware, containers, Virtual Machines (VMs), or the cloud. Each solution has strengths and weaknesses, and each of them can be configured and maintained with scripts as well as GUIs.</p>
<p>A container is ideal if you want to deploy many copies of a single application where each instance needs its own copy of data. For example, containers work well with database-driven web servers where each server needs the same web infrastructure but has private data.</p>
<p>However, the downside of a container is that it relies on the host system's kernel. You can run multiple Linux distributions on a Linux host, but you can't run Windows in a container.</p>
<p>Using a VM is your best bet if you need a complete environment that is not the same for all instances. With VMs, you can run Windows and Linux on a single host. This is ideal for validation testing when you don't want a dozen boxes in your office but need to test against different distributions and operating systems.</p>
<p>The downside of VMs is that they are huge. Each VM implements an entire computer-operating system, device drivers, all the applications and utilities, and so on. Each Linux VM needs at least one core and 1 GB RAM. A Windows VM may need two cores and 4 GB RAM. If you wish to run multiple VMs simultaneously, you need enough RAM to support each one of the VMs; otherwise, the host will start swapping and performance will suffer.</p>
<p>The cloud is like having many computers and lots of bandwidth at your fingertips. You may actually be running on a VM or container in the cloud, or you might have your own dedicated system.</p>
<p>The biggest advantage of the cloud is that it can scale. If you think your application might go viral or your usage is cyclic, the ability to scale up and down quickly without needing to buy or lease new hardware new connectivity is necessary. For example, if your system processes college registrations, it will be overworked for about two weeks, twice a year, and almost dormant for the rest of the time. You may need a dozen sets of hardware for those two weeks, but you don't want to have them sitting idle for the rest of the year.</p>
<p>The downside of the cloud is that it's not something you can see. All of the maintenance and configuration has to be done remotely.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Using Linux containers</h1>
            

            
                
<p><strong>Linux Container</strong> (<strong>lxc</strong>) packages provide the basic container functionality used by Docker and LXD container deployment systems.</p>
<p>A Linux container uses kernel level support for <strong>Control Groups</strong> (<strong>cgroups</strong>) and the <kbd>systemd</kbd> tools described in <a href="5c74c943-1155-4720-a3cb-f4740f691f8c.xhtml" target="_blank">Chapter 12</a>, <em>Tuning a Linux System</em>. The cgroups support provides tools to control the resources available to a group of programs. This informs kernel control about the resources that are available to the processes running in a container. A container may have limited access to devices, network connectivity, memory, and so on. This control keeps the containers from interfering with each other or potentially damaging the host system.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>Container support is not provided in stock distributions. You'll need to install it separately. The level of support across distributions is inconsistent. The <strong>lxc</strong> container system was developed by Canonical, so Ubuntu distributions have complete container support. Debian 9 (Stretch) is better than Debian 8 (Jessie) in this regard.</p>
<p>Fedora has limited support for lxc containers. It is easy to create privileged containers and a bridged Ethernet connection, but as of Fedora 25, the <kbd>cgmanager</kbd> service required for unprivileged containers is unavailable.</p>
<p>SuSE supports limited use of lxc. SuSE's <kbd>libvirt-lxc</kbd> package is similar but not identical to lxc. SuSE's <kbd>libvirt-lxc</kbd> package is not covered in this chapter. A privileged container with no Ethernet is easy to create under SuSE, but it does not support unprivileged containers and bridged Ethernet.</p>
<p>Here's how to install <kbd>lxc</kbd> support on major distributions.</p>
<p>For Ubuntu, use the following code:</p>
<pre>
    <strong># apt-get install lxc1</strong>
</pre>
<p>Next we have Debian. Debian distributions may only include the security repositories in <kbd>/etc/apt/sources.list</kbd>. If so, you'll need to add <kbd>deb http://ftp.us.debian.org/debian stretch main contrib</kbd> to <kbd>/etc/apt/sources.list</kbd> and then perform <kbd>apt-get update before</kbd>, loading the <kbd>lxc</kbd> package:</p>
<pre>
    <strong># apt-get install lxc</strong>
</pre>
<p>For OpenSuSE, use the following code:</p>
<pre>
    <strong># zypper install lxc</strong>
<strong>    RedHat, Fedora:</strong>
</pre>
<p>For Red Hat/Fedora-based systems, add the following <kbd>Epel</kbd> repository:</p>
<pre>
    <strong># yum install epel-release</strong>
</pre>
<p>Once you've done this, install the following packages before you install lxc support:</p>
<pre>
    <strong># yum install perl libvirt debootstrap</strong>
</pre>
<p>The <kbd>libvirt</kbd> package provides networking support, and <kbd>debootstrap</kbd> is required to run Debian-based containers:</p>
<pre>
    <strong># yum install lxc lxc-templates tunctl bridge-utils</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The <kbd>lxc</kbd> package adds several commands to your system. These include:</p>
<ul>
<li><kbd>lxc-create</kbd>: This is to create an lxc container</li>
<li><kbd>lxc-ls</kbd>: This is a list of the available containers</li>
<li><kbd>lxc-start</kbd>: This is to start a container</li>
<li><kbd>lxc-stop</kbd>: This is to stop a container</li>
<li><kbd>lxc-attach</kbd>: This is to connect to the root shell of a container</li>
<li><kbd>lxc-console</kbd>: This is to connect to a login session in a container</li>
</ul>
<p>On Red Hat-based systems, you may need to disable SELinux while testing. On OpenSuSE systems, you may need to disable <strong>AppArmor</strong>. You'll need to reboot after disabling AppArmor via <kbd>yast2</kbd>.</p>
<p>Linux containers come in two basic flavors: privileged and unprivileged. Privileged containers are created by the root and the underlying system has root privileges. An unprivileged container is created by a user and only has user privileges.</p>
<p>Privileged containers are easier to create and more widely supported since they don't require <kbd>uid</kbd> and <kbd>gid</kbd> mapping, device permissions, and so on. However, if a user or application manages to escape from the container, they'll have full privileges on the host.</p>
<p>Creating a privileged container is a good way to confirm that all the required packages are installed on your system. After you create a privileged container, use unprivileged containers for your applications.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a privileged container</h1>
            

            
                
<p>The easiest way to get started with Linux containers is to download a prebuilt distribution in a privileged container. The <kbd>lxc-create</kbd> command creates a base container structure and can populate it with a predefined Linux distribution. The syntax of the <kbd>lxc-create</kbd> command is as follows:</p>
<pre>
    <strong>lxc-create -n NAME -t TYPE</strong>
</pre>
<p>The <kbd>-n</kbd> option defines a name for this container. This name will be used to identify this container when it is started, stopped, or reconfigured.</p>
<p>The <kbd>-t</kbd> option defines the template to be used to create this container. The type <kbd>download</kbd> connects your system to a repository of prebuilt containers and prompts you for the container to download.</p>
<p>This is an easy way to experiment with other distributions or create an application that needs a distribution other than the host's Linux distribution:</p>
<pre>
    <strong>$ sudo lxc-create -t download -n ContainerName</strong>
</pre>
<p>The download template retrieves a list of the available predefined containers from the Internet and populates the container from the network archive. The create command provides a list of the available containers and then prompts for the <strong>Distribution</strong>, <strong>Release</strong>, and Architecture. You can only run a container if your hardware supports this Architecture. You cannot run an Arm container if your system has an Intel CPU, but you can run a 32-bit i386 container on a system with a 64-bit Intel CPU:</p>
<pre>
<strong>$ sudo lxc-create -t download -n ubuntuContainer</strong>
<strong>...</strong>
<strong>ubuntu  zesty   armhf   default 20170225_03:49</strong>
<strong>ubuntu  zesty   i386    default 20170225_03:49</strong>
<strong>ubuntu  zesty   powerpc default 20170225_03:49</strong>
<strong>ubuntu  zesty   ppc64el default 20170225_03:49</strong>
<strong>ubuntu  zesty   s390x   default 20170225_03:49</strong>
<strong>---</strong>

<strong>Distribution: ubuntu</strong>
<strong>Release: trusty</strong>
<strong>Architecture: i386 </strong>

<strong>Downloading the image index</strong>
<strong>Downloading the rootfs</strong>
<strong>Downloading the metadata</strong>
<strong>The image cache is now ready</strong>
<strong>Unpacking the rootfs</strong>

<strong>---</strong>
<strong>You just created an Ubuntu container (release=trusty, arch=i386, variant=default)</strong>
<strong>To enable sshd, run: apt-get install openssh-server</strong>
<strong>For security reason, container images ship without user accounts and without a root password.</strong>
<strong>Use lxc-attach or chroot directly into the rootfs to set a root password or create user accounts.</strong>
</pre>
<p>You can create a container based on your current distribution by selecting a template that matches the current installation. The templates are defined in <kbd>/usr/share/lxc/templates</kbd>:</p>
<pre>
    <strong># ls /usr/share/lxc/templates</strong>
<strong>    lxc-busybox   lxc-debian   lxc-download ...</strong>
</pre>
<p>To create a container for your current distribution, select the appropriate template and run the <kbd>lxc-create</kbd> command. The download process and installation takes several minutes. The following example skips most of the installation and configuration messages:</p>
<pre>
<strong>$ cat /etc/issue</strong>
<strong>Debian GNU/Linux 8</strong>
<strong>$ sudo lxc-create -t debian -n debianContainer</strong>
<strong>debootstrap is /usr/sbin/debootstrap</strong>
<strong>Checking cache download in /var/cache/lxc/debian/rootfs-jessie-i386 ... </strong>
<strong>Downloading debian minimal ...</strong>
<strong>I: Retrieving Release </strong>
<strong>I: Retrieving Release.gpg </strong>
<strong>I: Checking Release signature</strong>
<strong>I: Valid Release signature (key id 75DDC3C4A499F1A18CB5F3C8CBF8D6FD518E17E1)</strong>
<strong>...</strong>
<strong>I: Retrieving Packages </strong>
<strong>I: Validating Packages </strong>
<strong>I: Checking component main on http://http.debian.net/debian...</strong>
<strong>I: Retrieving acl 2.2.52-2</strong>
<strong>I: Validating acl 2.2.52-2</strong>
<strong>I: Retrieving libacl1 2.2.52-2</strong>
<strong>I: Validating libacl1 2.2.52-2</strong>

<strong>I: Configuring libc-bin...</strong>
<strong>I: Configuring systemd...</strong>
<strong>I: Base system installed successfully.</strong>
<strong>Current default time zone: 'America/New_York'</strong>
<strong>Local time is now:      Sun Feb 26 11:38:38 EST 2017.</strong>
<strong>Universal Time is now:  Sun Feb 26 16:38:38 UTC 2017.</strong>

<strong>Root password is 'W+IkcKkk', please change !</strong>
</pre>
<p>The preceding command populates the new container from the repositories defined in your package manager. Before you can use a container, you must start it.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Starting a container</h1>
            

            
                
<p>The <kbd>lxc-start</kbd> command starts a container. As with other lxc commands, you must provide the name of the container to start:</p>
<pre>
    <strong># lxc-start -n ubuntuContainer</strong>
</pre>
<p>The boot sequence may hang and you may see errors similar to the following one. These are caused by the container's boot sequence trying to perform graphics operations, such as displaying a splash screen without graphics support in the client:</p>
<pre>
    <strong>&lt;4&gt;init: plymouth-upstart-bridge main process (5) terminated with   
    status 1</strong>
<strong>    ...</strong>
</pre>
<p>You can wait for these errors to time out and ignore them, or you can disable the splash screen. Disabling the splash screen varies between distributions and releases. The files may be in <kbd>/etc/init</kbd>, but that's not guaranteed. </p>
<p>There are two ways to work within a container:</p>
<ul>
<li><kbd>lxc-attach</kbd>: This attaches directly to a root account on a running container</li>
<li><kbd>lxc-console</kbd>: This opens a console for a login session on a running container</li>
</ul>
<p>The first use of a container is to attach directly to create user accounts:</p>
<pre>
<strong># lxc-attach -n containerName</strong>
<strong>root@containerName:/#</strong>
<strong>root@containerName:/# useradd -d /home/USERNAME -m  USERNAME</strong>
<strong>root@containerName:/# passwd USERNAME</strong>
<strong>Enter new UNIX password:</strong>
<strong>Retype new UNIX password:</strong>
</pre>
<p>After you've created a user account, log in as an unprivileged user or root with the <kbd>lxc-console</kbd> application:</p>
<pre>
<strong>$ lxc-console -n containerName</strong>
<strong>Connected to tty 1</strong>
<strong>Type &lt;Ctrl+a q&gt; to exit the console, </strong>
<strong>&lt;Ctrl+a Ctrl+a&gt; to enter Ctrl+a itself</strong>
<strong>Login:</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Stopping a container</h1>
            

            
                
<p>The <kbd>lxc-stop</kbd> command stops a container:</p>
<pre>
    <strong># lxc-stop -n containerName</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Listing known containers</h1>
            

            
                
<p>The <kbd>lxc-ls</kbd> command lists the container names that are available for the current user. This does not list all the containers in a system, only those that the current user owns:</p>
<pre>
    <strong>$ lxc-ls</strong>
<strong>   container1Name container2Name...</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Displaying container information</h1>
            

            
                
<p>The <kbd>lxc-info</kbd> command displays information about a container:</p>
<pre>
<strong>$ lxc-info -n containerName</strong>
<strong>Name:   testContainer</strong>
<strong>State:   STOPPED</strong>
</pre>
<p>This command will only display information about a single container, though. Using a shell loop, as described in <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml" target="_blank">Chapter 1</a>, <em>Shell Something Out</em>, we can display information about all the containers:</p>
<pre>
<strong>$ for c in `lxc-ls` </strong>
<strong>do</strong>
<strong>lxc-info -n $c</strong>
<strong>echo</strong>
<strong>done</strong>
<strong>Name:  name1</strong>
<strong>State:  STOPPED</strong>

<strong>Name:  name2</strong>
<strong>State:  RUNNING</strong>
<strong>PID:  1234</strong>
<strong>IP  10.0.3.225</strong>
<strong>CPU use:  4.48 seconds</strong>
<strong>BlkIO use:  728.00 KiB</strong>
<strong>Memory use:  15.07 MiB</strong>
<strong>KMem use:  2.40 MiB</strong>
<strong>Link:  vethMU5I00</strong>
<strong> TX bytes:  20.48 KiB</strong>
<strong> RX bytes:  30.01 KiB</strong>
<strong> Total bytes:  50.49 KiB</strong>
</pre>
<p>If the container is stopped, there is no status information available. Running containers record their CPU, memory, disk (block), I/O, and network usage. This tool lets you monitor your containers to see which ones are most active.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating an unprivileged container</h1>
            

            
                
<p>Unprivileged containers are recommended for normal use. There is potential for a badly configured container or badly configured application to allow control to escape from the container. Since containers invoke system calls in the host kernel, if the container is running as the root, the system calls will also run as the root. However, unprivileged containers run with normal user privileges and are thus safer.</p>
<p>To create unprivileged containers, the host must support Linux Control Groups and uid mapping. This support is included in basic Ubuntu distributions, but it needs to be added to other distributions. The <kbd>cgmanager</kbd> package is not available in all distributions. You cannot start an unprivileged container without this package:</p>
<pre>
    <strong># apt-get install cgmanager uidmap systemd-services</strong>
</pre>
<p>Start <kbd>cgmanager</kbd>:</p>
<pre>
    <strong>$ sudo service cgmanager start</strong>
</pre>
<p>Debian systems may require that clone support be enabled. If you receive a <kbd>chown</kbd> error when creating a container, these lines will fix it:</p>
<pre>
    <strong># echo 1 &gt; /sys/fs/cgroup/cpuset/cgroup.clone_children</strong>
<strong>    # echo 1 &gt; /proc/sys/kernel/unprivileged_userns_clone </strong>
</pre>
<p>The username of an account that's allowed to create containers must be included in the <kbd>etc</kbd> mapping tables:</p>
<pre>
    <strong>$ sudo usermod --add-subuids 100000-165536 $USER</strong>
<strong>    $ sudo usermod --add-subgids 100000-165536 $USER</strong>
<strong>    $ sudo chmod +x $HOME</strong>
</pre>
<p>These commands add the user to the User ID and Group ID mapping tables <kbd>(/etc/subuid</kbd> and <kbd>/etc/subgid</kbd>) and assign UIDs from <kbd>100000 -&gt; 165536</kbd> to the user.</p>
<p>Next, set up the configuration file for your containers:</p>
<pre>
    <strong>$ mkdir ~/.config/lxc</strong>
<strong>    $ cp /etc/lxc/default.conf ~/.config/lxc</strong>
</pre>
<p>Add the following lines to <kbd>~/.config/lxc/default.conf</kbd>:</p>
<pre>
    <strong>lxc.id_map = u 0 100000 65536</strong>
<strong>    lxc.id_map = g 0 100000 65536</strong>
</pre>
<p>If the containers support network access, add a line to <kbd>/etc/lxc/lxc-usernet</kbd> to define the users who will have access to the network bridge:</p>
<pre>
    <strong>USERNAME veth BRIDGENAME COUNT</strong>
</pre>
<p>Here, <kbd>USERNAME</kbd> is the name of the user who owns the container. <kbd>veth</kbd> is the usual name for the virtual Ethernet device. <kbd>BRIDGENAME</kbd> is the name that's displayed by <kbd>ifconfig</kbd>. It is usually either <kbd>br0</kbd> or <kbd>lxcbro</kbd>. <kbd>COUNT</kbd> is the number of simultaneous connections that will be allowed:</p>
<pre>
    <strong>$ cat /etc/lxc/lxc-usernet</strong>
<strong>    clif veth lxcbr0 10</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating an Ethernet bridge</h1>
            

            
                
<p>A container cannot access your Ethernet adapter directly. It requires a bridge between the Virtual Ethernet and the actual Ethernet. Recent Ubuntu distributions create an Ethernet bridge automatically when you install the lxc package. Debian and Fedora may require that you manually create the bridge. To create a bridge on Fedora, use the <kbd>libvirt</kbd> package to create a virtual bridge first:</p>
<pre>
    <strong># systemctl start libvirtd</strong>
</pre>
<p>Then, edit <kbd>/etc/lxc/default.conf</kbd> to reference <kbd>virbr0</kbd> instead of <kbd>lxcbr0</kbd>:</p>
<pre>
    <strong>lxc.network_link = virbr0</strong>
</pre>
<p>If you've already created a container, edit the config file for that container as well.</p>
<p>To create a bridge on Debian systems, you must edit the network configuration and the container configuration files.</p>
<p>Edit <kbd>/etc/lxc/default.conf</kbd>. Comment out the default empty network and add a definition for the lxc bridge:</p>
<pre>
    <strong># lxc.network.type = empty</strong>
<strong>    lxc.network.type = veth</strong>
<strong>    lxc.network.link = lxcbr0</strong>
<strong>    lxc.network.flage = up`</strong>
</pre>
<p>Next, create the networking bridge:</p>
<pre>
    <strong># systemctl enable lxc-net</strong>
<strong>    # systemctl start lxc-net</strong>
</pre>
<p>Containers created after these steps are performed will have networking enabled. Network support can be added to the existing containers by adding the <kbd>lxc.network</kbd> lines to the container's config file.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The container created by the <kbd>lxc-create</kbd> command is a directory tree that includes the configuration options and root filesystem for the container. Privileged containers are constructed under <kbd>/var/lib/lxc</kbd>. Nonprivileged containers are stored under <kbd>$HOME/.local/lxc</kbd>:</p>
<pre>
    <strong>$ ls /var/lib/lxc/CONTAINERNAME</strong>
<strong>    config rootfs</strong>
</pre>
<p>You can examine or modify a container's configuration by editing the config file in the container's top directory:</p>
<pre>
    <strong># vim /var/lib/lxc/CONTAINERNAME/config</strong>
</pre>
<p>The <kbd>rootfs</kbd> folder contains a root filesystem for the container. This is the root (<kbd>/</kbd>) folder of a running container:</p>
<pre>
    <strong># ls /var/lib/lxc/CONTAINERNAME/rootfs</strong>
<strong>    bin   boot cdrom dev  etc   home  lib   media mnt   proc</strong>
<strong>    root  run  sbin  sys  tmp   usr   var</strong>
</pre>
<p>You can populate a container by adding, deleting, or modifying files in the <kbd>rootfs</kbd> folder. For instance, to run web services, a container might have basic web services installed via the package manager and the actual data of each service installed by copying files to the <kbd>rootfs</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Using Docker</h1>
            

            
                
<p>The <kbd>lxc</kbd> containers are complex and can be difficult to work with. These issues led to the Docker package. Docker uses the same underlying Linux functionalities of <kbd>namespaces</kbd> and <kbd>cgroups</kbd> to create lightweight containers.</p>
<p>Docker is only officially supported on 64-bit systems, making <kbd>lxc</kbd> the better choice for legacy systems.</p>
<p>The major difference between a Docker container and an lxc container is that a Docker container commonly runs one process, while an lxc container runs many. To deploy a database-backed web server, you need at least two Docker containers–one for the web server and one for the database server–but only one lxc container.</p>
<p>The Docker philosophy makes it easy to construct systems from smaller building blocks, but it can make it harder to develop blocks since so many Linux utilities are expected to run inside a full Linux system with <kbd>crontab</kbd> entries to carry out operations such as cleanup, log rotation, and so on.</p>
<p>Once a Docker container is created, it will run exactly as expected on other Docker servers. This makes it very easy to deploy Docker containers on cloud clusters or remote sites.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>Docker is not installed with most distributions. It is distributed via Docker's repositories. Using these requires adding new repositories to your package manager with new checksums.</p>
<p>Docker has instructions for each distribution and different releases on their main page, which is available at <a href="http://docs.docker.com" target="_blank">http://docs.docker.com</a>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>When Docker is first installed, it is not running. You must start the server with a command such as the following:</p>
<pre>
    <strong># service docker start</strong>
</pre>
<p>The Docker command has many subcommands that provide functionality. These commands will find a Docker container and download and run it. Here's a bit about the subcommands:</p>
<ul>
<li><kbd># docker search</kbd>: This searches Docker archives for containers with names that match a key</li>
<li><kbd># docker pull</kbd>: This pulls the named container to your system</li>
<li><kbd># docker run</kbd>: This runs an application in a container</li>
<li><kbd># docker ps</kbd>: This lists the running Docker containers</li>
<li><kbd># docker attach</kbd>: This attaches to a running container</li>
<li><kbd># docker stop</kbd>: This stops a container</li>
<li><kbd># docker rm</kbd>: This removes a container</li>
</ul>
<p>The default Docker installation requires that the <kbd>docker</kbd> command be run either as a <kbd>root</kbd> or using <kbd>sudo</kbd>.</p>
<p>Each of these commands have a <kbd>man</kbd> page. This page is named by combining the command and subcommand with a dash. To view the <kbd>docker search</kbd> man page, use <kbd>man docker-search</kbd>.</p>
<p>The next recipe demonstrates how to download a Docker container and run it.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Finding a container</h1>
            

            
                
<p>The <kbd>docker search</kbd> command returns a list of Docker containers that match a search term:</p>
<pre>
    <strong>docker search TERM</strong>
</pre>
<p>Here TERM is an alphanumeric string (no wild cards). The search command will return up to 25 containers that include the string in their name:</p>
<pre>
<strong># docker search apache</strong>
<strong>NAME            DESCRIPTION                STARS OFFICIAL   AUTOMATED</strong>
<strong>eboraas/apache  Apache (with SSL support)  70                   [OK]</strong>
<strong>bitnami/apache  Bitnami Apache Docker      25                   [OK]</strong>
<strong>apache/nutch    Apache Nutch               12                   [OK]</strong>
<strong>apache/marmotta Apache Marmotta             4                   [OK]</strong>
<strong>lephare/apache  Apache container            3                   [OK]</strong>
</pre>
<p>Here STARS represent a rating for the container. The containers are ordered with the highest rating first.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Downloading a container</h1>
            

            
                
<p>The <kbd>docker pull</kbd> command downloads a container from the Docker registry. By default, it pulls data from Docker's public registry at <kbd>registry-1.docker.io</kbd>. The downloaded container is added to your system. The containers are commonly stored under /<kbd>var/lib/docker</kbd>:</p>
<pre>
<strong># docker pull lephare/apache</strong>
<strong>latest: Pulling from lephare/apache</strong>
<strong>425e28bb756f: Pull complete </strong>
<strong>ce4a2c3907b1: Extracting [======================&gt; ] 2.522 MB/2.522 MB</strong>
<strong>40e152766c6c: Downloading [==================&gt;    ] 2.333 MB/5.416 MB</strong>
<strong>db2f8d577dce: Download complete </strong>
<strong>Digest: sha256:e11a0f7e53b34584f6a714cc4dfa383cbd6aef1f542bacf69f5fccefa0108ff8</strong>
<strong>Status: Image is up to date for lephare/apache:latest</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Starting a Docker container</h1>
            

            
                
<p>The <kbd>docker run</kbd> command starts a process in a container. Commonly, the process is a <kbd>bash</kbd> shell that allows you to attach to the container and start other processes. This command returns a hash value that defines this session.</p>
<p>When a Docker container starts, a network connection is created for it automatically.</p>
<p>The syntax for the run command is as follows:</p>
<pre>
    <strong>docker run [OPTIONS] CONTAINER COMMAND</strong>
</pre>
<p>The <kbd>docker run</kbd> command supports many options, including:</p>
<ul>
<li><kbd>-t</kbd>: Allocate a pseudo tty (by default, false)</li>
<li><kbd>-i</kbd>: Keep an interactive session open while unattached</li>
<li><kbd>-d</kbd>: Start the container detached (running in the background)</li>
<li><kbd>--name</kbd>: The name to assign to this instance</li>
</ul>
<p>This example starts the bash shell in the container that was previously pulled:</p>
<pre>
<strong>    # docker run -t -i -d --name leph1 lephare/apache  /bin/bash</strong>
<strong>    1d862d7552bcaadf5311c96d439378617d85593843131ad499...</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Listing the Docker sessions</h1>
            

            
                
<p>The <kbd>docker p</kbd>s command lists the currently running Docker sessions:</p>
<pre>
<strong># docker ps</strong>
<strong>CONTAINER ID  IMAGE           COMMAND   CREATED  STATUS  PORTS  NAMES</strong>
<strong>123456abc     lephare/apache  /bin/bash 10:05    up      80/tcp leph1</strong>
</pre>
<p>The <kbd>-a</kbd> option will list all the Docker containers on your system, whether they are running or not.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Attaching your display to a running Docker container</h1>
            

            
                
<p>The <kbd>docker attach</kbd> command attaches your display to the <kbd>tty</kbd> session in a running container. You need to run as the root within this container.</p>
<p>To exit an attached session, type <kbd>^P^Q</kbd>.</p>
<p>This example creates an HTML page and starts the Apache web server in the container:</p>
<pre>
<strong>$ docker attach leph1</strong>
<strong>root@131aaaeeac79:/# cd /var/www</strong>
<strong>root@131aaaeeac79:/var/www# mkdir symfony</strong>
<strong>root@131aaaeeac79:/var/www# mkdir symfony/web</strong>
<strong>root@131aaaeeac79:/var/www# cd  symfony/web</strong>
<strong>root@131aaaeeac79:/var/www/symfony/web# echo "&lt;html&gt;&lt;body&gt;&lt;h1&gt;It's Alive&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"   
    &gt;index.html</strong>
<strong>root@131aaaeeac79:/# cd /etc/init.d</strong>
<strong>root@131aaaeeac79:/etc/init.d# ./apache2 start</strong>
<strong>[....] Starting web server: apache2/usr/sbin/apache2ctl: 87: ulimit: error setting limit (Operation 
    not permitted)</strong>
<strong>Setting ulimit failed. See README.Debian for more information.</strong>
<strong>AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 
    172.17.0.5. Set the 'ServerName' directive globally to suppress this message</strong>
<strong>. ok </strong>
</pre>
<p>Browsing to <kbd>172.17.0.5</kbd> will show the <kbd>It's Alive</kbd> page.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Stopping a Docker session</h1>
            

            
                
<p>The <kbd>docker stop</kbd> command terminates a running Docker session:</p>
<pre>
    <strong># docker stop leph1</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Removing a Docker instance</h1>
            

            
                
<p>The <kbd>docker rm</kbd> command removes a container. The container must be stopped before removing it. A container can be removed either by name or identifier:</p>
<pre>
    <strong># docker rm leph1</strong>
</pre>
<p>Alternatively, you can use this:</p>
<pre>
    <strong># docker rm 131aaaeeac79</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works</h1>
            

            
                
<p>The Docker containers use the same <kbd>namespace</kbd> and <kbd>cgroup</kbd> kernel support as that of the <kbd>lxc</kbd> containers. Initially, Docker was a layer over <kbd>lxc</kbd>, but it has since evolved into a unique system.</p>
<p>The main configuration files for the server are stored at /<kbd>var/lib/docker</kbd> and <kbd>/etc/docker</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Using Virtual Machines in Linux</h1>
            

            
                
<p>There are four options for using VMs in Linux. The three open source options are KVM, XEN, and VirtualBox. Commercially, VMware supplies a virtual engine that can be hosted in Linux and an executive that can run VMs.</p>
<p>VMware has been supporting VMs longer than anyone else. They support Unix, Linux, Mac OS X, and Windows as hosts and Unix, Linux, and Windows as guest systems. For commercial use, VMware Player or VMWare Workstation are the two best choices you have.</p>
<p>KVM and VirtualBox are the two most popular VM engines for Linux. KVM delivers better performance, but it requires a CPU that supports virtualization (Intel VT-x). Most modern Intel and AMD CPUs support these features. VirtualBox has the advantage of being ported to Windows and Mac OS X, allowing you to move a virtual machine to another platform easily. VirtualBox does not require VT-x support, making it suitable for legacy systems as well as modern systems.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>VirtualBox is supported by most distributions, but it may not be part of these distributions' default package repositories.</p>
<p>To install VirtualBox on Debian 9, you need to add the virtualbox.org repository to the sites that apt-get will accept packages from:</p>
<pre>
<strong># vi /etc/apt/sources.list</strong>
<strong>## ADD:</strong>
<strong>deb http://download.virtualbox.org/virtualbox/debian stretch contrib</strong>
</pre>
<p>The <kbd>curl</kbd> package is required to install the proper keys. If this is not already present, install it before adding the key and updating the repository information:</p>
<pre>
<strong># apt-get install curl</strong>
<strong># curl -O https://www.virtualbox.org/download/oracle_vbox_2016.asc</strong>
<strong># apt-key add oracle_vbox_2016.asc</strong>
<strong># apt-get update</strong>
</pre>
<p>Once the repository is updated, you can install VirtualBox with <kbd>apt-get</kbd>:</p>
<pre>
<strong># apt-get install virtualbox-5.1</strong>

<strong>OpenSuSE </strong>
<strong># zypper install gcc make kernel-devel</strong>
<strong>Open yast2, select Software Management, search for virtualbox.</strong>
<strong>Select virtualbox, virtualbox-host-kmp-default, and virtualbox-qt.</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>When VirtualBox is installed, it creates an item in the start menu. It may be under System or Applications/System Tools. The GUI can be started from a terminal session as <kbd>virtualbox</kbd> or as <kbd>VirtualBox</kbd>.</p>
<p>The VirtualBox GUI makes it easy to create and run VMs. The GUI has a button named New in the upper-left corner; this is used to create a new, empty VM. The wizard prompts you for information such as memory and disk limits for the new VM.</p>
<p>Once the VM is created, the Start button is activated. The default settings connect the virtual machine's CD-ROM to the host's CD-ROM. You can put an installation disk in the CD-ROM and click on Start to install the operating system on a new VM.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Linux in the cloud</h1>
            

            
                
<p>There are two primary reasons to use a cloud server. Service providers use a commercial cloud service, such as Amazon's AWS, because it lets them easily ramp up their resources when demand is higher and ramp down their costs when demand is lower. Cloud storage providers, such as Google Docs, allow users to access their data from any device and share data with others.</p>
<p>The OwnCloud package transforms your Linux server into a private cloud storage system. You can use an OwnCloud server as a private corporate file sharing system to share files with friends or as a remote backup for your phone or tablet.</p>
<p>The OwnCloud project forked in 2016. The NextCloud server and applications are expected to use the same protocol as that of OwnCloud and to be interchangeable.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>Running the OwnCloud package requires a <strong>LAMP</strong> (<strong>Linux, Apache, MySQL, PHP</strong>) installation. These packages are supported by all Linux distributions, though they may not be installed by default. Administering and installing MySQL is discussed in <a href="20129291-0a5b-43a8-ad0c-54c74992d0e3.xhtml" target="_blank">Chapter 10</a>, <em>Administration Calls</em>.</p>
<p>Most distributions do not include the OwnCloud server in their repositories. Instead, the OwnCloud project maintains repositories to support the distributions. You'll need to attach OwnCloud to your RPM or apt repository before you download.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Ubuntu 16.10</h1>
            

            
                
<p>The following steps will install the LAMP stack on a Ubuntu 16.10 system. Similar commands will work for any Debian-based system. Unfortunately, package names sometimes vary between releases:</p>
<pre>
<strong>    apt-get install apache2</strong>
<strong>    apt-get install mysql-server php-mysql</strong>
</pre>
<p>OwnCloud requires security beyond default settings. The <kbd>mysql_secure_installation</kbd> script will configure MySQL properly:</p>
<pre>
    <strong>/usr/bin/mysql_secure_installation</strong>
</pre>
<p>Configure the <kbd>OwnCloud</kbd> repository:</p>
<pre>
<strong>curl \ https://download.owncloud.org/download/repositories/stable/ \ Ubuntu_16.10/Release.key/'</strong><strong>| sudo tee \ /etc/apt/sources.list.d/owncloud.list</strong>

<strong>apt-get update</strong>
</pre>
<p>Once the repository is in place, apt will install and start the server:</p>
<pre>
    <strong>apt-get install owncloud</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">OpenSuSE Tumbleweed</h1>
            

            
                
<p>Install the <strong>LAMP</strong> stack with <strong>Yast2</strong>. Open <kbd>yast2</kbd>, select Software Management, and install <kbd>apache2</kbd>, <kbd>mysql</kbd>, and <kbd>owncloud-client</kbd>.</p>
<p>Next, select the <kbd>System</kbd> tab, and from this tab, select the <kbd>Services Manager</kbd> tab. Confirm that the <kbd>mysql</kbd> and <kbd>apache2</kbd> services are enabled and active.</p>
<p>These steps install the OwnCloud client that will let you synchronize your workspace to an OwnCloud server and the system requirements for a server.</p>
<p>OwnCloud requires security beyond default settings. The <kbd>mysql_secure_installation</kbd> script will configure MySQL properly:</p>
<pre>
    <strong>/usr/bin/mysql_secure_installation</strong>
</pre>
<p>The following commands will install and start the OwnCloud server. The first three commands configure <kbd>zypper</kbd> to include the OwnCloud repository. Once these repositories are added, the Owncloud package is installed like any other package:</p>
<pre>
<strong>rpm --import https://download.owncloud.org/download/repositories/stable/openSUSE_Leap_42.2/repodata/repomd.xml.key</strong>

<strong>zypper addrepo http://download.owncloud.org/download/repositories/stable/openSUSE_Leap_42.2/ce:stable.repo</strong>

<strong>zypper refresh</strong>

<strong>zypper install owncloud </strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>Once OwnCloud is installed, you can configure an admin account, and from there, add user accounts. The NextCloud Android app will communicate with the OwnCloud server as well as the NextCloud server.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring OwnCloud</h1>
            

            
                
<p>Once <kbd>owncloud</kbd> is installed, you can configure it by browsing to your local address:</p>
<pre>
    <strong>$ konqueror http://127.0.0.1/owncloud</strong>
</pre>
<p>The initial screen will prompt you for an admin username and password. You can log in as the user to create backups and copy files between phones, tablets, and computers.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>The bare installation process we just discussed is suitable for testing. OwnCloud and NextCloud will use HTTPS sessions if HTTPS support is available. Enabling HTTPS support requires an X.509 security certificate.</p>
<p>You can purchase a security certificate from one of the dozens of commercial providers, self-sign a certificate for your own use, or create a free certificate with <strong>Let's Encrypt</strong> (http://letsencrypt.org).</p>
<p>A self-signed certificate is adequate for testing, but most browsers and phone apps will flag this as an untrusted site. Let's Encrypt is a service of the Internet Security Research Group (ISRG). The certificates they generate are fully registered and all applications can accept them.</p>
<p>The first step in acquiring a certificate is verifying that your site is what you claim it is. Let's Encrypt certificates are validated using a system called Automated Certificate Management Environment (ACME). The ACME system creates a hidden file on your web server, tells the <strong>Certificate Authority</strong> (<strong>CA</strong>) where that file is, and the CA confirms that the expected file is there. This proves that you have access to the web server and that DNS records point to the proper hardware.</p>
<p>If you are using a common web server, such as Nginx or Apache, the simplest way to set up your certificates is with the <kbd>certbot</kbd> created by EFF:</p>
<pre>
    <strong># wget https://dl.eff.org/certbot-auto</strong>
<strong>    # chmod a+x certbot-auto</strong>
<strong>    # ./certbot-auto</strong>
</pre>
<p>This robot will add new packages and install your new certificate in the proper place.</p>
<p>If you are using a less common server or have a non-standard installation, the <kbd>getssl</kbd> package is more configurable. The <kbd>getssl</kbd> package is a bash script that reads two configuration files to automate the creation of the certificate. Download the package from here and unzip from <kbd>https://github.com/srvrco/getssl</kbd>.</p>
<p>Unzipping <kbd>getssl.zip</kbd> creates a folder named <kbd>getssl_master</kbd>.</p>
<p>Generating and installing the certificates requires three steps:</p>
<ol>
<li>Create the default configuration files with <kbd>getssl -c DOMAIN.com</kbd>.</li>
<li>Edit the configuration files.</li>
<li>Create the certificates.</li>
</ol>
<p>Start by <kbd>cd-ing</kbd> to the <kbd>getssl_master</kbd> folder and creating the configuration files:</p>
<pre>
    <strong># cd getssl_master</strong>
<strong>    # getssl -c DOMAIN.com</strong>
</pre>
<p>Replace <kbd>DOMAIN</kbd> with the name of your domain.</p>
<p>This step creates the <kbd>$HOME/.getssl</kbd> and <kbd>$HOME/.getssl/DOMAIN.com</kbd> folders and creates a file named <kbd>getssl.cfg</kbd> in both of these. Each of these files must be edited.</p>
<p>Edit <kbd>~/.getssl/getssl.cfg</kbd> and add your email address:</p>
<pre>
    <strong>ACCOUNT_EMAIL='myName@mySite.com'</strong>
</pre>
<p>The default values in the rest of the fields are suitable for most sites.</p>
<p>Next, edit <kbd>~/.getssl/DOMAIN.com/getssl.cfg</kbd>. There are several fields to modify in this file.</p>
<p>The main change is to set the Acme Challenge Location (ACL) field. The ACME protocol will try to find a file in <a href="http://www.DOMAIN.com/.well-known/acme-challenge">http://www.DOMAIN.com/.well-known/acme-challenge</a>. The ACL value is the physical location of that folder on your system. You must create the <kbd>.well-known</kbd> and .<kbd>well-known/acme-challenge</kbd> folders and set ownership if they don't exist.</p>
<p>If your web pages are kept in <kbd>/var/web/DOMAIN</kbd>, you could create new folders as follows:</p>
<pre>
<strong># mkdir /var/web/DOMAIN/.well-known</strong>
<strong># mkdir /var/web/DOMAIN/.well-known/acme-challenge</strong>
<strong># chown webUser.webGroup /var/web/DOMAIN/.well-known</strong>
<strong># chown webUser.webGroup /var/web/DOMAIN/.well-known/acme-challenge</strong>
</pre>
<p>The ACL lines would resemble the following:</p>
<pre>
<strong>ACL="/var/web/DOMAIN/.well-known/acme-challenge"</strong>
<strong>USE_SINGLE_ACL="true"</strong>
</pre>
<p>You must also define where the certificates are to be placed. This location must match the configuration option in your web server. For instance, if certificates are kept in <kbd>/var/web/certs</kbd>, the definitions will resemble this:</p>
<pre>
<strong>DOMAIN_CERT_LOCATION="/var/web/certs/DOMAIN.crt"</strong>
<strong>DOMAIN_KEY_LOCATION="/var/web/certs/DOMAIN.key"</strong>
<strong>CA_CERT_LOCATION="/var/web/certs/DOMAIN.com.bundle"</strong>
</pre>
<p>You must set the type of test that the ACME protocol will use. These are commented out at the bottom of the configuration file. Using the default values are usually best:</p>
<pre>
<strong>SERVER_TYPE="https"</strong>
<strong>CHECK_REMOTE="true"</strong>
</pre>
<p>After these edits are complete, test them by running this:</p>
<pre>
<strong>./getssl DOMAIN.com</strong>
</pre>
<p>This command resembles the first one, but it does not include the <kbd>-c</kbd> (create) option. You can repeat this command until you've corrected any errors and are happy with the results.</p>
<p>The default behavior of the <kbd>getssl</kbd> script is to generate a test certificate that's not really valid. This is done because Let's Encrypt limits the number of actual certificates it will generate for a site to avoid abuse.</p>
<p>Once the configuration files are correct, edit them again and change the server–from the Staging server to the actual Let's Encrypt server:</p>
<pre>
<strong>CA="https://acme-v01.api.letsencrypt.org"</strong>
</pre>
<p>Then, rerun the <kbd>getssl</kbd> script one last time with the <kbd>-f</kbd> option to force it to rebuild and replace the previous files:</p>
<pre>
<strong>./getssl -f DOMAIN.com</strong>
</pre>
<p>You may need to restart your web server or reboot your system before the new files are recognized.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>