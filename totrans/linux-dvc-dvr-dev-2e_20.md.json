["```\nstruct pinctrl_desc {\n     const char *name;\n     const struct pinctrl_pin_desc *pins;\n     unsigned int npins;\n     const struct pinctrl_ops *pctlops;\n     const struct pinmux_ops *pmxops;\n     const struct pinconf_ops *confops;\n     struct module *owner;\n[...]\n};\n```", "```\n    struct pinctrl_pin_desc {\n         unsigned number;\n         const char *name;\n    [...]\n    };\n    ```", "```\nstruct pinctrl_dev *devm_pinctrl_register(\n                      struct device *dev,\n                      struct pinctrl_desc *pctldesc,\n                      void *driver_data);\n```", "```\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n#include <linux/pinctrl/pinctrl.h>\n#include <linux/pinctrl/pinmux.h>\n```", "```\n#include <linux/pinctrl/consumer.h>\n```", "```\n&usdhc4 {\n[...]\n     pinctrl-0 = <&pinctrl_usdhc4_1>;\n     pinctrl-names = \"default\";\n};\ngpio-keys {\n    compatible = \"gpio-keys\";\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&pinctrl_io_foo &pinctrl_io_bar>;\n};\niomuxc@020e0000 { /* Pin controller node */\n    compatible = \"fsl,imx6q-iomuxc\";\n    reg = <0x020e0000 0x4000>;\n    /* shared pinctrl settings */\n    usdhc4 { /* first node describing the function */\n        pinctrl_usdhc4_1: usdhc4grp-1 { /* second node */\n            fsl,pins = <\n                MX6QDL_PAD_SD4_CMD__SD4_CMD    0x17059\n                MX6QDL_PAD_SD4_CLK__SD4_CLK    0x10059\n                MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059\n                MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059\n                MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059\n                MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059\n                [...]\n            >;\n        };\n    };\n    [...]\n    uart3 {\n        pinctrl_uart3_1: uart3grp-1 {\n            fsl,pins = <\n                MX6QDL_PAD_EIM_D24__UART3_TX_DATA 0x1b0b1\n                MX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1\n            >;\n        };\n    };\n    // GPIOs (Inputs)\n   gpios {\n        pinctrl_io_foo: pinctrl_io_foo {\n           fsl,pins = <\n              MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09  0x1f059\n              MX6QDL_PAD_DISP0_DAT13__GPIO5_IO07  0x1f059\n           >;\n        };\n        pinctrl_io_bar: pinctrl_io_bar {\n           fsl,pins = <\n              MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05  0x1f059\n              MX6QDL_PAD_DISP0_DAT9__GPIO4_IO30   0x1f059\n              MX6QDL_PAD_DISP0_DAT7__GPIO4_IO28   0x1f059\n           >;\n        };\n    };\n};\n```", "```\nMX6QDL_PAD_DISP0_DAT15__GPIO5_IO09 0x80000000\n```", "```\nMX6QDL_PAD_EIM_D25__UART3_RX_DATA 0x1b0b1\n```", "```\n#define MX6QDL_PAD_DISP0_DAT11__GPIO5_IO05 0x19c 0x4b0 0x000 0x5 0x0\n```", "```\n#include <linux/pinctrl/consumer.h>\nint ret;\nstruct pinctrl_state *s;\nstruct pinctrl *p;\nfoo_probe()\n{\n    p = devm_pinctrl_get(dev);\n    if (IS_ERR(p))\n        return PTR_ERR(p);\n    s = pinctrl_lookup_state(p, name);\n    if (IS_ERR(s))\n        return PTR_ERR(s);\n    ret = pinctrl_select_state(p, s);\n    if (ret < 0) // on error\n        return ret;\n[...]\n}\n```", "```\nstatic struct pinctrl *devm_pinctrl_get_select(\n                  struct device *dev, const char *name)\n```", "```\nstatic struct pinctrl * pinctrl_get_select_default(\n                                      struct device *dev)\n{\n   return pinctrl_get_select(dev, PINCTRL_STATE_DEFAULT);\n}\n```", "```\nstruct gpio_chip {\n     const char       *label;\n     struct gpio_device    *gpiodev;\n     struct device         *parent;\n     struct module         *owner;\n     int        (*request)(struct gpio_chip *gc,\n                           unsigned int offset);\n     void       (*free)(struct gpio_chip *gc,\n                           unsigned int offset);\n     int       (*get_direction)(struct gpio_chip *gc,\n                           unsigned int offset);\n     int       (*direction_input)(struct gpio_chip *gc,\n                           unsigned int offset);\n     int       (*direction_output)(struct gpio_chip *gc,\n                      unsigned int offset, int value);\n     int       (*get)(struct gpio_chip *gc,\n                           unsigned int offset);\n     int       (*get_multiple)(struct gpio_chip *gc,\n                           unsigned long *mask,\n                           unsigned long *bits);\n     void       (*set)(struct gpio_chip *gc,\n                      unsigned int offset, int value);\n     void       (*set_multiple)(struct gpio_chip *gc,\n                           unsigned long *mask,\n                           unsigned long *bits);\n     int        (*set_config)(struct gpio_chip *gc,\n                            unsigned int offset,\n                            unsigned long config);\n     int        (*to_irq)(struct gpio_chip *gc,\n                           unsigned int offset);\n     int       (*init_valid_mask)(struct gpio_chip *gc,\n                              unsigned long *valid_mask,\n                              unsigned int ngpios);\n     int       (*add_pin_ranges)(struct gpio_chip *gc);\n     int        base;\n     u16        ngpio;\n     const char *const *names;\n     bool       can_sleep;\n#if IS_ENABLED(CONFIG_GPIO_GENERIC)\n     unsigned long (*read_reg)(void __iomem *reg);\n     void (*write_reg)(void __iomem *reg, unsigned long data);\n     bool be_bits;\n     void __iomem *reg_dat;\n     void __iomem *reg_set;\n     void __iomem *reg_clr;\n     void __iomem *reg_dir_out;\n     void __iomem *reg_dir_in;\n     bool bgpio_dir_unreadable;\n     int bgpio_bits;\n     spinlock_t bgpio_lock;\n     unsigned long bgpio_data;\n     unsigned long bgpio_dir;\n#endif /* CONFIG_GPIO_GENERIC */\n#ifdef CONFIG_GPIOLIB_IRQCHIP\n     struct gpio_irq_chip irq;\n#endif /* CONFIG_GPIOLIB_IRQCHIP */\n     unsigned long *valid_mask;\n#if defined(CONFIG_OF_GPIO)\n     struct device_node *of_node;\n     unsigned int of_gpio_n_cells;\n     int (*of_xlate)(struct gpio_chip *gc,\n                const struct of_phandle_args *gpiospec,\n                u32 *flags);\n#endif /* CONFIG_OF_GPIO */\n};\n```", "```\n     static void gpio_chip_set_multiple(\n                        struct gpio_chip *chip,\n                        unsigned long *mask,\n                        unsigned long *bits)\n    {\n        if (chip->set_multiple) {\n            chip->set_multiple(chip, mask, bits);\n        } else {\n            unsigned int i;\n            /*\n             * set outputs if the corresponding\n             * mask bit is set\n             */\n            for_each_set_bit(i, mask, chip->ngpio)\n                chip->set(chip, i, test_bit(i, bits));\n            }\n    }\n    ```", "```\nint gpiochip_add_data(struct gpio_chip *gc, void *data)\nint devm_gpiochip_add_data(struct device *dev,\n                        struct gpio_chip *gc, void *data)\n```", "```\nif (!of_find_property(np, \"gpio-ranges\", NULL)) {\n     ret = gpiochip_add_pin_range(chip,\n                   dev_name(hw->dev), 0, 0, chip->ngpio);\n     if (ret < 0) {\n           gpiochip_remove(chip);\n           return ret;\n     }\n}\n```", "```\n#include <linux/gpio.h> \n```", "```\n#define GPIO_NUM 16\nstruct mcp23016 {\n    struct i2c_client *client;\n    struct gpio_chip gpiochip;\n    struct mutex lock;\n};\nstatic int mcp23016_probe(struct i2c_client *client)\n{\n  struct mcp23016 *mcp;\n\n  if (!i2c_check_functionality(client->adapter,\n      I2C_FUNC_SMBUS_BYTE_DATA))\n    return -EIO;\n  mcp = devm_kzalloc(&client->dev, sizeof(*mcp),\n                      GFP_KERNEL);\n  if (!mcp)\n    return -ENOMEM;\n  mcp->gpiochip.label = client->name;\n  mcp->gpiochip.base = -1;\n  mcp->gpiochip.dev = &client->dev;\n  mcp->gpiochip.owner = THIS_MODULE;\n  mcp->gpiochip.ngpio = GPIO_NUM; /* 16 */\n  /* may not be accessed from atomic context */\n  mcp->gpiochip.can_sleep = 1; \n  mcp->gpiochip.get = mcp23016_get_value;\n  mcp->gpiochip.set = mcp23016_set_value;\n  mcp->gpiochip.direction_output =\n                          mcp23016_direction_output;\n  mcp->gpiochip.direction_input =\n                          mcp23016_direction_input;\n  mcp->client = client;\n  i2c_set_clientdata(client, mcp);\n  return devm_gpiochip_add_data(&client->dev,\n                                &mcp->gpiochip, mcp);\n}\n```", "```\nstruct gpio_irq_chip {\n     struct irq_chip *chip;\n     struct irq_domain *domain;\n     const struct irq_domain_ops *domain_ops;\n     irq_flow_handler_t handler;\n     unsigned int default_type;\n     irq_flow_handler_t parent_handler;\n     union {\n          void *parent_handler_data;\n          void **parent_handler_data_array;\n     };\n     unsigned int num_parents;\n     unsigned int *parents;\n     unsigned int *map;\n     bool threaded;\n     bool per_parent_data;\n     int (*init_hw)(struct gpio_chip *gc);\n     void (*init_valid_mask)(struct gpio_chip *gc,\n                      unsigned long *valid_mask,\n                      unsigned int ngpios);\n     unsigned long *valid_mask;\n     unsigned int first;\n     void       (*irq_enable)(struct irq_data *data);\n     void       (*irq_disable)(struct irq_data *data);\n     void       (*irq_unmask)(struct irq_data *data);\n     void       (*irq_mask)(struct irq_data *data);\n};\n```", "```\n      static irqreturn_t foo_gpio_irq(int irq, void *data)\n          chained_irq_enter(...);\n          generic_handle_irq(...);\n          chained_irq_exit(...);\n    ```", "```\n    static irqreturn_t gpio_rcar_irq_handler(int irq,\n                                        void *dev_id)\n        /* go through the entire GPIOs and handle\n         * all interrupts\n         */\n        for each detected GPIO IRQ\n            generic_handle_irq(...);\n    ```", "```\nstatic irqreturn_t pcf857x_irq(int irq,\n                               void *data)\n{\n     struct pcf857x *gpio = data;\n     unsigned long change, i, status;\n     status = gpio->read(gpio->client);\n     mutex_lock(&gpio->lock);\n     change = (gpio->status ^ status) &\n              gpio->irq_enabled;\n     gpio->status = status;\n     mutex_unlock(&gpio->lock);\n     for_each_set_bit(i, &change, gpio->chip.ngpio)\n      child_irq = irq_find_mapping(\n                     gpio->chip.irq.domain, i);\n        handle_nested_irq(child_irq);\n     return IRQ_HANDLED;\n}\n```", "```\nstatic struct irq_chip mcp23016_irq_chip = {\n     .name = \"gpio-mcp23016\",\n     .irq_mask = mcp23016_irq_mask,\n     .irq_unmask = mcp23016_irq_unmask,\n     .irq_set_type = mcp23016_irq_set_type,\n};\n```", "```\nstatic int mcp23016_probe(struct i2c_client *client)\n{\n    struct gpio_irq_chip *girq;\n    struct irq_chip *irqc;\n[...]\n    girq = &mcp->gpiochip.irq;\n    girq->chip = &mcp23016_irq_chip;\n    /* This will let us handling the parent IRQ in the driver */\n    girq->parent_handler = NULL;\n    girq->num_parents = 0;\n    girq->parents = NULL;\n    girq->default_type = IRQ_TYPE_NONE;\n    girq->handler = handle_level_irq;\n    girq->threaded = true;\n[...]\n    /*\n     * Directly request the irq here instead of passing\n     * a flow-handler.\n     */\n    err = devm_request_threaded_irq(\n                      &client->dev,\n                      client->irq,\n                      NULL, mcp23016_irq,\n                      IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n                      dev_name(&i2c->dev), mcp);\n[...]\n\n    return devm_gpiochip_add_data(&client->dev,\n                                &mcp->gpiochip, mcp);\n}\n```", "```\nstatic irqreturn_t mcp23016_irq(int irq, void *data)\n{\n    struct mcp23016 *mcp = data;\n    unsigned long status, changes, child_irq, i;\n    status = read_gpio_status(mcp);\n    mutex_lock(&mcp->lock);\n    change = mcp->status ^ status;\n    mcp->status = status;\n    mutex_unlock(&mcp->lock);\n    /* Do some stuff, may be adapting \"change\" according to level */\n    [...]\n    for_each_set_bit(i, &change, mcp->gpiochip.ngpio) {\n        child_irq =\n           irq_find_mapping(mcp->gpiochip.irq.domain, i);\n        handle_nested_irq(child_irq);\n    }\n    return IRQ_HANDLED;\n}\n```", "```\n&i2c1\n    expander: mcp23016@20 {\n        compatible = \"microchip,mcp23016\";\n        reg = <0x20>;\n        gpio-controller;\n        #gpio-cells = <2>;\n        interrupt-controller;\n        #interrupt-cells = <2>;\n        interrupt-parent = <&gpio4>;\n        interrupts = <29 IRQ_TYPE_EDGE_FALLING>;\n    };\n};\n```", "```\nparent_node {\n    compatible = \"simple-bus\";\n    foo_device: foo_device@1c {\n        [...]\n        reg = <0x1c>;\n        interrupt-parent = <&expander>;\n        interrupts = <2 IRQ_TYPE_EDGE_RISING>;\n    };\n    bar_device {\n        [...]\n        reset-gpios = <&expander 8 GPIO_ACTIVE_HIGH>;\n        power-gpios = <&expander 12 GPIO_ACTIVE_HIGH>;\n        [...]\n    };\n};\n```", "```\n<[pin controller phandle], [GPIO controller offset], [pin controller offset], [number of pins]>;\n```", "```\ngpio-ranges = <&foo 0 20 10>, <&bar 10 50 20>;\n```", "```\n&gpio5 {\n    gpio-ranges = <&pinctrl 29 89 1> ;\n}\n```", "```\niomuxc: pinctrl@20e0000 {\n    compatible = \"fsl,imx6dl-iomuxc\", \"fsl,imx6q-iomuxc\";\n    reg = <0x20e0000 0x4000>;\n};\n```", "```\ngpio3: gpio@20a4000 {\n    compatible = \"fsl,imx6q-gpio\", \"fsl,imx35-gpio\";\n    reg = <0x020a4000 0x4000>;\n    interrupts = <0 70 IRQ_TYPE_LEVEL_HIGH>,\n                 <0 71 IRQ_TYPE_LEVEL_HIGH>;\n    gpio-controller;\n    #gpio-cells = <2>;\n    interrupt-controller;\n    #interrupt-cells = <2>;\n};\n```", "```\n&gpio3 {\n     gpio-ranges = <&iomuxc 0 69 16>, <&iomuxc 16 36 8>,\n                  <&iomuxc 24 45 8>;\n};\n```", "```\n&iomuxc {\n[...]\n    pinctrl_gpio3_hog: gpio3hoggrp {\n        fsl,pins = <\n            MX6QDL_PAD_EIM_D19__GPIO3_IO19      0x1b0b0\n            MX6QDL_PAD_EIM_D20__GPIO3_IO20      0x1b0b0\n            MX6QDL_PAD_EIM_D22__GPIO3_IO22      0x1b0b0\n            MX6QDL_PAD_EIM_D23__GPIO3_IO23      0x1b0b0\n        >;\n    };\n[...]\n}\n```", "```\n&gpio3 {\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&pinctrl_gpio3_hog>;\n    usb-emulation-hog {\n        gpio-hog;\n        gpios = <19 GPIO_ACTIVE_HIGH>;\n        output-low;\n        line-name = \"usb-emulation\";\n    };\n    usb-mode1-hog {\n        gpio-hog;\n        gpios = <20 GPIO_ACTIVE_HIGH>;\n        output-high;\n        line-name = \"usb-mode1\";\n    };\n    usb-pwr-hog {\n        gpio-hog;\n        gpios = <22 GPIO_ACTIVE_LOW>;\n        output-high;\n       line-name = \"usb-pwr-ctrl-en-n\";\n    };\n    usb-mode2-hog {\n        gpio-hog;\n        gpios = <23 GPIO_ACTIVE_HIGH>;\n        output-high;\n        line-name = \"usb-mode2\";\n    };\n};\n```", "```\n#include <linux/gpio.h>\n```", "```\nbool gpio_is_valid(int number);\nint  gpio_request(unsigned gpio, const char *label);\nint  gpio_get_value_cansleep(unsigned gpio);\nint  gpio_direction_input(unsigned gpio);\nint  gpio_direction_output(unsigned gpio, int value);\nvoid gpio_set_value(unsigned int gpio, int value);\nint  gpio_get_value(unsigned gpio);\nvoid gpio_set_value_cansleep(unsigned gpio, int value);\nint gpio_get_value_cansleep(unsigned gpio);\nvoid gpio_free(unsigned int gpio);\n```", "```\nint gpio_to_irq(unsigned gpio)\n```", "```\nint request_threaded_irq (unsigned int irq,\n                   irq_handler_t handler,\n                   irq_handler_t thread_fn,\n                   unsigned long irqflags,\n                   const char *devname,\n                   void *dev_id); \nint request_any_context_irq (unsigned int irq,\n                       irq_handler_t handler,\n                       unsigned long flags,\n                       const char * name,\n                       void * dev_id);\n```", "```\nstatic irqreturn_t my_interrupt_handler(int irq,\n                                        void *dev_id)\n{\n    [...]\n    return IRQ_HANDLED;\n}\nstatic int foo_probe(struct i2c_client *client)\n{\n    [...]\n    struct device_node *np = client->dev.of_node;\n    int gpio_int = of_get_gpio(np, 0);\n    int irq_num = gpio_to_irq(gpio_int);\n    int error =\n        devm_request_threaded_irq(&client->dev, irq_num,\n               NULL, my_interrupt_handler,\n               IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n               input_dev->name, my_data_struct);\n    if (error) {\n        dev_err(&client->dev, \"irq %d requested failed,\n                 %d\\n\", client->irq, error);\n        return error;\n    }\n    [...]\n    return 0;\n}\n```", "```\n#include <linux/gpio/consumer.h>\n```", "```\nstruct gpio_desc {\n     struct gpio_chip *chip;\n     unsigned long    flags;\n     const char       *label;\n};\n```", "```\nstatic const char * const gpio_suffixes[] =\n                          { \"gpios\", \"gpio\" };\n```", "```\nstatic struct gpio_desc *of_find_gpio(\n                           struct device *dev,\n                           const char *con_id,\n                           unsigned int idx,\n                           enum gpio_lookup_flags *flags)\n{\n    /* 32 is max size of property name */\n    char prop_name[32];\n    enum of_gpio_flags of_flags;\n    struct gpio_desc *desc;\n    unsigned int i;\n    /* Try GPIO property \"foo-gpios\" and \"foo-gpio\" */\n    for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {\n        if (con_id)\n            snprintf(prop_name, sizeof(prop_name),\n                      \"%s-%s\", con_id,\n                      gpio_suffixes[i]);\n        else\n            snprintf(prop_name, sizeof(prop_name), \"%s\",\n                       gpio_suffixes[i]);\n        desc = of_get_named_gpiod_flags(dev->of_node,\n                                      prop_name, idx,\n                                      &of_flags);\n        if (!IS_ERR(desc) || PTR_ERR(desc) != -ENOENT)\n            break;\n[...]\n}\n```", "```\nfoo_device {\n    compatible = \"acme,foo\";\n    [...]\n    led-gpios = <&gpio 15 GPIO_ACTIVE_HIGH>, /* red */\n                <&gpio 16 GPIO_ACTIVE_HIGH>, /* green */\n                <&gpio 17 GPIO_ACTIVE_HIGH>; /* blue */\n    power-gpio = <&gpio 1 GPIO_ACTIVE_LOW>;\n    reset-gpio = <&gpio 1 GPIO_ACTIVE_LOW>;\n};\n```", "```\nstruct gpio_desc *gpiod_get_index(struct device *dev,\n                                 const char *con_id,\n                                 unsigned int idx,\n                                 enum gpiod_flags flags)\nstruct gpio_desc *gpiod_get(struct device *dev,\n                            const char *con_id,\n                            enum gpiod_flags flags)\nstruct gpio_desc *gpiod_get_optional(struct device *dev,\n                                     const char *con_id,\n                                     enum gpiod_flags flags);\n```", "```\nstruct gpio_desc *devm_gpiod_get_index(\n                                struct device *dev,\n                                const char *con_id,\n                                unsigned int idx,\n                                enum gpiod_flags flags);\nstruct gpio_desc *devm_gpiod_get(struct device *dev,\n                               const char *con_id,\n                               enum gpiod_flags flags);\nstruct gpio_desc *devm_gpiod_get_optional(\n                                struct device *dev,\n                                const char *con_id,\n                                enum gpiod_flags flags);\n```", "```\nenum gpiod_flags {\n    GPIOD_ASIS  = 0,\n    GPIOD_IN = GPIOD_FLAGS_BIT_DIR_SET,\n    GPIOD_OUT_LOW = GPIOD_FLAGS_BIT_DIR_SET |\n                    GPIOD_FLAGS_BIT_DIR_OUT,\n    GPIOD_OUT_HIGH = GPIOD_FLAGS_BIT_DIR_SET |\n                     GPIOD_FLAGS_BIT_DIR_OUT |\n                     GPIOD_FLAGS_BIT_DIR_VAL,\n};\n```", "```\nstruct gpio_desc *red, *green, *blue, *power;\nred = gpiod_get_index(dev, \"led\", 0, GPIOD_OUT_HIGH);\ngreen = gpiod_get_index(dev, \"led\", 1, GPIOD_OUT_HIGH);\nblue = gpiod_get_index(dev, \"led\", 2, GPIOD_OUT_HIGH);\npower = gpiod_get(dev, \"power\", GPIOD_OUT_HIGH);\n```", "```\nint gpiod_direction_input(struct gpio_desc *desc);\nint gpiod_direction_output(struct gpio_desc *desc,\n                           int value);\n```", "```\nint gpiod_cansleep(const struct gpio_desc *desc);\n```", "```\nint gpiod_get_value_cansleep(const struct gpio_desc *desc);\nvoid gpiod_set_value_cansleep(struct gpio_desc *desc,\n                              int value);\n```", "```\nint gpiod_get_value(const struct gpio_desc *desc);\nvoid gpiod_set_value(struct gpio_desc *desc, int value);\n```", "```\nint gpiod_to_irq(const struct gpio_desc *desc);\n```", "```\n/* Convert between the old gpio_ and new gpiod_ interfaces */\nstruct gpio_desc *gpio_to_desc(unsigned gpio);\nint desc_to_gpio(const struct gpio_desc *desc);\n```", "```\nvoid gpiod_put(struct gpio_desc *desc);\n```", "```\nfoo_device {\n    compatible = \"packt,gpio-descriptor-sample\";\n    led-gpios = <&gpio2 15 GPIO_ACTIVE_HIGH>, // red \n                <&gpio2 16 GPIO_ACTIVE_HIGH>, // green \n    btn1-gpios = <&gpio2 1 GPIO_ACTIVE_LOW>;\n    btn2-gpios = <&gpio2 31 GPIO_ACTIVE_LOW>;\n};\n```", "```\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h> /* platform devices */\n#include <linux/gpio/consumer.h>   /* GPIO Descriptor */\n#include <linux/interrupt.h>       /* IRQ */\n#include <linux/of.h>              /* Device Tree */\nstatic struct gpio_desc *red, *green, *btn1, *btn2;\nstatic unsigned int irq, led_state = 0;\nstatic irq_handler_t btn1_irq_handler(unsigned int irq,\n                                      void *dev_id)\n{\n    unsigned int btn2_state;\n    btn2_state = gpiod_get_value(btn2);\n    if (btn2_state) {\n        led_state = 1 – led_state;\n        gpiod_set_value(red, led_state);\n        gpiod_set_value(green, led_state);\n    }\n    pr_info(\"btn1 interrupt: Interrupt! btn2 state is %d)\\n\",\n            led_state);\n    return IRQ_HANDLED;\n}\n```", "```\nstatic int my_pdrv_probe (struct platform_device *pdev)\n{\n    int retval;\n    struct device *dev = &pdev->dev;\n    red = devm_gpiod_get_index(dev, \"led\", 0,\n                               GPIOD_OUT_LOW);\n    green = devm_gpiod_get_index(dev, \"led\", 1,\n                                 GPIOD_OUT_LOW);\n    /* Configure GPIO Buttons as input */\n    btn1 = devm_gpiod_get(dev, \"led\", 0, GPIOD_IN);\n    btn2 = devm_gpiod_get(dev, \"led\", 1, GPIOD_IN);\n    irq = gpiod_to_irq(btn1);\n    retval = devm_request_threaded_irq(dev, irq, NULL,\n                         btn1_pushed_irq_handler,\n                         IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n                         \"gpio-descriptor-sample\", NULL);\n    pr_info(\"Hello! device probed!\\n\");\n    return 0;\n}\n```", "```\nstatic const struct of_device_id gpiod_dt_ids[] = {\n    { .compatible = \"packt,gpio-descriptor-sample\", },\n    { /* sentinel */ }\n};\nstatic struct platform_driver mypdrv = {\n    .probe      = my_pdrv_probe,\n    .driver     = {\n        .name     = \"gpio_descriptor_sample\",\n        .of_match_table = of_match_ptr(gpiod_dt_ids),  \n        .owner    = THIS_MODULE,\n    },\n};\nmodule_platform_driver(mypdrv);\nMODULE_AUTHOR(\"John Madieu <john.madieu@labcsmart.com>\");\nMODULE_LICENSE(\"GPL\");\n```", "```\nstatic void my_pdrv_remove(struct platform_device *pdev)\n{\n    free_irq(irq, NULL);\n    gpiod_put(red);\n    gpiod_put(green);\n    gpiod_put(btn1);\n    gpiod_put(btn2);\n    pr_info(\"good bye reader!\\n\");\n}\nstatic struct platform_driver mypdrv = {\n    [...]\n    .remove     = my_pdrv_remove,\n    [...]\n};\n```", "```\n# echo 24 > /sys/class/gpio/export\n# echo out > /sys/class/gpio/gpio24/direction\n# echo 1 > /sys/class/gpio/gpio24/value\n# echo 0 > /sys/class/gpio/gpio24/value\n# echo high > /sys/class/gpio/gpio24/direction # shorthand for out/1\n# echo low > /sys/class/gpio/gpio24/direction # shorthand for out/0\n```", "```\nbool gpiod_line_is_free(struct gpiod_line *line);\nbool gpiod_line_is_requested(struct gpiod_line *line);\n```", "```\nstruct gpiod_line_event {\n    struct timespec ts;\n    int event_type;\n};\n```", "```\nint gpiod_line_request_rising_edge_events(\n                          struct gpiod_line *line,\n                          const char *consumer);\nint gpiod_line_request_bulk_rising_edge_events(\n                          struct gpiod_line_bulk *bulk,\n                          const char *consumer);\nint gpiod_line_request_falling_edge_events(\n                          struct gpiod_line *line,\n                          const char *consumer);\nint gpiod_line_request_bulk_falling_edge_events(\n                          struct gpiod_line_bulk *bulk,\n                          const char *consumer);\nint gpiod_line_request_both_edges_events(\n                          struct gpiod_line *line,\n                          const char *consumer);\nint gpiod_line_request_bulk_both_edges_events(\n                          struct gpiod_line_bulk *bulk,\n                          const char *consumer);\n```", "```\nint gpiod_line_event_wait(struct gpiod_line *line,\n                  const struct timespec *timeout);\nint gpiod_line_event_wait_bulk(\n                  struct gpiod_line_bulk *bulk,\n                  const struct timespec *timeout,\n                  struct gpiod_line_bulk *event_bulk);\n```", "```\nint gpiod_line_event_read(struct gpiod_line *line,\n                         struct gpiod_line_event *event);\n```", "```\nchar *chipname = \"gpiochip0\";\nint ret;\nstruct gpiod_chip *chip;\nstruct gpiod_line *input_line;\nstruct gpiod_line_event event;\nunsigned int line_num = 25;  /* GPIO Pin #25 */\nchip = gpiod_chip_open_by_name(chipname);\nif (!chip) {\n     perror(\"Open chip failed\\n\");\n     return -1;\n}\ninput_line = gpiod_chip_get_line(chip, line_num);\nif (!input_line) {\n     perror(\"Get line failed\\n\");\n     ret = -1;\n     goto close_chip;\n}\nret = gpiod_line_request_rising_edge_events(input_line,\n                                            \"gpio-test\");\nif (ret < 0) {\n     perror(\"Request event notification failed\\n\");\n     ret = -1;\n     goto release_line;\n}\nwhile (1) {\n  gpiod_line_event_wait(input_line, NULL); /* blocking */\n  if (gpiod_line_event_read(input_line, &event) != 0)\n        continue;\n\n    /* should always be a rising event in our example */\n    if (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)\n        continue;\n    [...]\n}\nrelease_line:\n     gpiod_line_release(input_line);\nclose_chip:\n     gpiod_chip_close(chip);\n     return ret;\n```", "```\n// file event-bulk.c\n#include <gpiod.h>\n#include <error.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/time.h>\n```", "```\nstatic struct gpiod_chip *chip;\nstatic struct gpiod_line_bulk gpio_lines;\nstatic struct gpiod_line_bulk gpio_events;\n/* use GPIOs #4, #7, #9, #15, and #31 as input */\nstatic unsigned int gpio_offsets[] = {4, 7, 9, 15, 31};\n```", "```\nint main(int argc, char *argv[])\n{\n    int err;\n    int values[5] = {-1};\n    struct timespec timeout;\n    chip = gpiod_chip_open(\"/dev/gpiochip0\");\n    if (!chip) {\n        perror(\"gpiod_chip_open\");\n        goto cleanup;\n    }\n```", "```\n    err = gpiod_chip_get_lines(chip, gpio_offsets, 5,\n                               &gpio_lines);\n    if (err) {\n        perror(\"gpiod_chip_get_lines\");\n        goto cleanup;\n    }\n```", "```\n    err = gpiod_line_request_bulk_rising_edge_events(\n                    &gpio_lines, \"rising edge example\");\n    if(err) {\n        perror(\n           \"gpiod_line_request_bulk_rising_edge_events\");\n        goto cleanup;\n    }\n```", "```\n    /* Timeout of 60 seconds, pass in NULL to wait forever */\n    timeout.tv_sec = 60;\n    timeout.tv_nsec = 0;\n    printf(\"waiting for rising edge event \\n\");\nmarker1:\n    err = gpiod_line_event_wait_bulk(&gpio_lines,\n                                     &timeout, &gpio_events);\n    if (err == -1) {\n        perror(\"gpiod_line_event_wait_bulk\");\n        goto cleanup;\n    } else if (err == 0) {\n        fprintf(stderr, \"wait timed out\\n\");\n        goto cleanup;\n    }\n```", "```\n    err = gpiod_line_get_value_bulk(&gpio_events, values);\n    if(err) {\n        perror(\"gpiod_line_get_value_bulk\");\n        goto cleanup;\n    }\n```", "```\n    for (int i = 0;\n         i < gpiod_line_bulk_num_lines(&gpio_events);\n         i++) {\n        struct gpiod_line* line;\n        struct gpiod_line_event event;\n        line = gpiod_line_bulk_get_line(&gpio_events, i);\n        if(!line) {\n           fprintf(stderr, \"unable to get line %d\\n\", i);\n           continue;\n        }\n        if (gpiod_line_event_read(line, &event) != 0)\n            continue;\n        printf(\"line %s, %d\\n\", gpiod_line_name(line),\n           gpiod_line_offset(line));\n    }\nmarker2:\n```", "```\ncleanup:\n    gpiod_line_release_bulk(&gpio_lines);\n    gpiod_chip_close(chip);\n    return EXIT_SUCCESS;\n}\n```", "```\n# echo 'e6052000.gpio 19 e6050000.gpio 20-21' > /sys/bus/platform/drivers/gpio-aggregator/new_device\n# gpioinfo gpio-aggregator.0\n     gpiochip12 - 3 lines:\n     line 0: unnamed unused input active-high\n     line 1: unnamed unused input active-high\n     line 2: unnamed unused input active-high\n# chown geert /dev/gpiochip12\n```", "```\n$ echo gpio-aggregator.0 > delete_device\n```", "```\n&iomuxc {\n[...]\n   aggregator {\n      pinctrl_aggregator_pins: aggretatorgrp {\n         fsl,pins = <\n           MX6QDL_PAD_EIM_D30__GPIO3_IO30      0x80000000  \n           MX6QDL_PAD_EIM_D23__GPIO3_IO23      0x80000000 \n           MX6QDL_PAD_ENET_TXD1__GPIO1_IO29    0x80000000\n           MX6QDL_PAD_ENET_RX_ER__GPIO1_IO24   0x80000000\n           MX6QDL_PAD_EIM_D25__GPIO3_IO25      0x80000000\n           MX6QDL_PAD_EIM_LBA__GPIO2_IO27      0x80000000\n           MX6QDL_PAD_EIM_EB2__GPIO2_IO30      0x80000000\n           MX6QDL_PAD_SD3_DAT4__GPIO7_IO01     0x80000000\n         >;\n      };\n   };\n}\n```", "```\ngpio-aggregator {\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&pinctrl_aggregator_pins>;\n    compatible = \"gpio-aggregator\";\n    gpios = <&gpio3 30 GPIO_ACTIVE_HIGH>,\n            <&gpio3 23 GPIO_ACTIVE_HIGH>,\n            <&gpio1 29 GPIO_ACTIVE_HIGH>,\n            <&gpio1 25 GPIO_ACTIVE_HIGH>,\n            <&gpio3 25 GPIO_ACTIVE_HIGH>,\n            <&gpio2 27 GPIO_ACTIVE_HIGH>,\n            <&gpio2 30 GPIO_ACTIVE_HIGH>,\n            <&gpio7 1 GPIO_ACTIVE_HIGH>;\n    gpio-line-names = \"line_a\", \"line_b\", \"line_c\",\n            \"line_d\", \"line_e\", \"line_f\", \"line_g\",\n            \"line_h\";\n};\n```", "```\n# gpioinfo\n[...]\ngpiochip9 - 8 lines:\n    line 0: \"line_a\" unused input active-high\n    line 1: \"line_b\" unused input active-high\n[...]\n    line 7: \"line_g\" unused input active-high\n[...]\n```", "```\n# gpiofind 'line_b'\ngpiochip9 1\n```", "```\n# gpioget $(gpiofind 'line_b')\n1\n#\n# gpioset $(gpiofind 'line_h')=1\n# gpioset $(gpiofind 'line_h')=0\n```", "```\n# chown $user:$group /dev/gpiochip9\n# chmod 660 /dev/gpiochip9\n```", "```\ndoor {\n     compatible = \"myvendor,mydoor\";\n     gpios = <&gpio2 19 GPIO_ACTIVE_HIGH>,\n           <&gpio2 20 GPIO_ACTIVE_LOW>;\n     gpio-line-names = \"open\", \"lock\";\n};\n```", "```\n$ echo gpio-aggregator > /sys/bus/platform/devices/door/driver_override\n$ echo door > /sys/bus/platform/drivers/gpio-aggregator/bind\n```", "```\n$ gpioinfo door\ngpiochip12 - 2 lines:\n     line   0:       \"open\"       unused   input  active-high\n     line   1:       \"lock\"       unused   input  active-high\n```"]