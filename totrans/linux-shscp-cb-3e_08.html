<html><head></head><body>
        

            
                <h1 class="header-title">The Old-Boy Network</h1>
            

            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li> Setting up the network</li>
<li> Let us ping!</li>
<li> Tracing IP routes</li>
<li> Listing all available machines on a network</li>
<li> Running commands on a remote host with SSH</li>
<li> Running graphical commands on a remote machine</li>
<li> Transferring files through the network</li>
<li> Connecting to a wireless network</li>
<li> Password-less auto-login with SSH</li>
<li> Port forwarding using SSH</li>
<li> Mounting a remote drive at a local mount point</li>
<li> Network traffic and port analysis</li>
<li> Measuring network bandwidth</li>
<li> Creating arbitrary sockets</li>
<li> Building a bridge</li>
<li> Sharing an Internet connection</li>
<li> Basic firewall using <kbd>iptables</kbd></li>
<li> Creating a Virtual Private Network</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Introduction</h1>
            

            
                
<p>Networking is the act of connecting computers to allow them to exchange information. The most widely used networking stack is TCP/IP, where each node is assigned a unique IP address for identification. If you are already familiar with networking, you can skip this introduction.</p>
<p>TCP/IP networks work by passing data packets from node to node. Each data packet contains the IP address of its destination and the port number of the application that can process this data.</p>
<p>When a node receives a packet, it checks to see if it is this packet's destination. If so, the node checks the port number and invokes the appropriate application to process the data. If this node is not the destination, it evaluates what it knows about the network and passes the packet to a node that is closer to the final destination.</p>
<p>Shell scripts can be used to configure the nodes in a network, test the availability of machines, automate execution of commands at remote hosts, and more. This chapter provides recipes that introduce tools and commands related to networking, and shows how to use them effectively.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Setting up the network</h1>
            

            
                
<p>Before digging through recipes based on networking, it is essential to have a basic understanding of setting up a network, terminologies, and commands for assigning IP address, adding routes, and so on. This recipe provides an overview of commands used in GNU/Linux networks.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>A network interface physically connects a machine to a network, either with a wire or a Wi-Fi link. Linux denotes network interfaces using names such as <kbd>eth0</kbd>, <kbd>eth1</kbd>, or <kbd>enp0s25</kbd> (referring to Ethernet interfaces). Other interfaces, namely <kbd>usb0</kbd>, <kbd>wlan0</kbd>, and <kbd>tun0</kbd>, are available for USB network interfaces, wireless LAN, and tunnels, respectively.</p>
<p>In this recipe, we will use these commands: <kbd>ifconfig</kbd>, <kbd>route</kbd>, <kbd>nslookup</kbd>, and <kbd>host</kbd>.</p>
<p>The <kbd>ifconfig</kbd> command is used to configure and display details about network interfaces, subnet mask, and so on. It should be available at <kbd>/sbin/ifconfig</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>List the current network interface configuration:</li>
</ol>
<pre>
<strong>        $ ifconfig</strong> 
<strong>        lo        Link encap:Local Loopback</strong> 
<strong>        inet addr:127.0.0.1  Mask:255.0.0.0</strong> 
<strong>        inet6addr: ::1/128 Scope:Host</strong> 
<strong>           UP LOOPBACK RUNNING  MTU:16436  Metric:1</strong> 
<strong>           RX packets:6078 errors:0 dropped:0 overruns:0 frame:0</strong> 
<strong>           TX packets:6078 errors:0 dropped:0 overruns:0 carrier:0</strong> 
<strong>        collisions:0 txqueuelen:0</strong> 
<strong>           RX bytes:634520 (634.5 KB)  TX bytes:634520 (634.5 KB)</strong> 
<strong>        wlan0     Link encap:EthernetHWaddr 00:1c:bf:87:25:d2</strong> 
<strong>        inet addr:192.168.0.82  Bcast:192.168.3.255  Mask:255.255.252.0</strong> 
<strong>        inet6addr: fe80::21c:bfff:fe87:25d2/64 Scope:Link</strong> 
<strong>           UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</strong> 
<strong>           RX packets:420917 errors:0 dropped:0 overruns:0 frame:0</strong> 
<strong>           TX packets:86820 errors:0 dropped:0 overruns:0 carrier:0</strong> 
<strong>        collisions:0 txqueuelen:1000</strong> 
<strong>           RX bytes:98027420 (98.0 MB)  TX bytes:22602672 (22.6 MB)</strong> 
</pre>
<p style="padding-left: 60px">The leftmost column in the ifconfig output lists the names of network interfaces, and the right-hand columns show the details related to the corresponding network interface.</p>
<ol start="2">
<li>To set the IP address for a network interface, use the following command:</li>
</ol>
<pre>
<strong>        # ifconfig wlan0 192.168.0.80</strong> 
</pre>
<p style="padding-left: 60px">You will need to run the preceding command as root</p>
<p style="padding-left: 60px"><kbd>192.168.0.80</kbd> is defined as the address for the wireless device, wlan0</p>
<p style="padding-left: 60px">To set the subnet mask along with the IP address, use the following command:</p>
<pre>
<strong>        # ifconfig wlan0 192.168.0.80  netmask 255.255.252.0</strong> 
</pre>
<ol start="3">
<li>Many networks use <strong>Dynamic Host Configuration Protocol</strong> (<strong>DHCP</strong>) to assign IP addresses automatically when a computer connects to the network. The <kbd>dhclient</kbd> command assigns the IP address when your machine is connected to a network that assigns IP addresses automatically. If addresses are assigned via DHCP, use <kbd>dhclient</kbd> instead of manually choosing an address that might conflict with another machine on the network. Many Linux distributions invoke <kbd>dhclient</kbd> automatically when they sense a network cable connection</li>
</ol>
<pre>
<strong>        # dhclient eth0</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>The <kbd>ifconfig</kbd> command can be combined with other shell tools to produce specific reports.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Printing the list of network interfaces</h1>
            

            
                
<p>This one-line command sequence displays network interfaces available on a system:</p>
<pre>
<strong>$ ifconfig | cut -c-10 | tr -d ' ' | tr -s 'n'</strong> 
<strong>lo</strong> 
<strong>wlan0</strong> 
</pre>
<p>The first ten characters of each line in <kbd>ifconfig</kbd> output is reserved for writing names of network interfaces. Hence, we use <kbd>cut</kbd> to extract the first ten characters of each line. <kbd>tr -d ' '</kbd> deletes every space character in each line. Now, the <kbd>n</kbd> newline character is squeezed using <kbd>tr -s 'n'</kbd> to produce a list of interface names.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Displaying IP addresses</h1>
            

            
                
<p>The <kbd>ifconfig</kbd> command displays details of every active network interface available on the system. However, we can restrict it to a specific interface using the following command:</p>
<pre>
<strong>$ ifconfig iface_name</strong> 
</pre>
<p>Consider this example:</p>
<pre>
<strong>$ ifconfig wlan0</strong> 
<strong>wlan0     Link encap:EthernetHWaddr 00:1c:bf:87:25:d2</strong> 
<strong>inet addr:192.168.0.82 Bcast:192.168.3.255 Mask:255.255.252.0</strong> 
<strong>inet6 addr: fe80::3a2c:4aff:6e6e:17a9/64 Scope:Link</strong> 
<strong>UP BROADCAST RUNNINT MULTICAST  MTU:1500 Metric:1</strong> 
<strong>RX Packets...</strong> 
</pre>
<p>To control a device, we need the IP address, broadcast address, hardware address, and subnet mask:</p>
<ul>
<li> <kbd>HWaddr 00:1c:bf:87:25:d2</kbd>: This is the hardware address (MAC address)</li>
<li> <kbd>inet addr:192.168.0.82</kbd>: This is the IP address</li>
<li> <kbd>Bcast:192.168.3.255</kbd>: This is the broadcast address</li>
<li> <kbd>Mask:255.255.252.0</kbd>: This is the subnet mask</li>
</ul>
<p>To extract the IP address from the <kbd>ifconfig</kbd> output, use this command:</p>
<pre>
<strong>$ ifconfig wlan0 | egrep -o "inetaddr:[^ ]*" | grep -o "[0-9.]*"</strong> 
<strong>192.168.0.82</strong> 
</pre>
<p>The <kbd>egrep -o "inetaddr:[^ ]*"</kbd> command returns <kbd>inet addr:192.168.0.82</kbd>. The pattern starts with <kbd>inetaddr:</kbd> and ends with any non-space character sequence (specified by <kbd>[^ ]*</kbd>). The next command, <kbd>grep -o "[0-9.]*"</kbd> reduces its input to only numbers and periods, and prints out an IP4 address.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Spoofing the hardware address (MAC address)</h1>
            

            
                
<p>When authentication or filtering is based on the hardware address, we can use hardware address spoofing. The hardware address appears in the <kbd>ifconfig</kbd> output as <kbd>HWaddr 00:1c:bf:87:25:d2</kbd>.</p>
<p>The <kbd>hw</kbd> subcommand of <kbd>ifconfig</kbd> will define a devices class and the MAC address:</p>
<pre>
<strong># ifconfig eth0 hw ether 00:1c:bf:87:25:d5</strong> 
</pre>
<p>In the preceding command, <kbd>00:1c:bf:87:25:d5</kbd> is the new MAC address to be assigned. This is useful when we need to access the Internet through MAC-authenticated service providers that provide access to the Internet for a single machine.</p>
<p>Note: this definition only lasts until a machine restarts.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Name server and DNS (Domain Name Service)</h1>
            

            
                
<p>The underlying addressing scheme for the Internet is the dotted decimal form (like <kbd>83.166.169.231</kbd>). Humans prefer to use words instead of numbers, so resources on the Internet are identified with strings of words called <strong>URLs</strong> or <strong>domain names</strong>. For example, <a href="http://www.packtpub.com">www.packtpub.com</a> is a domain name and it corresponds to an IP address. The site can be identified by the numeric or the string name.</p>
<p>This technique of mapping IP addresses to symbolic names is called <strong>Domain Name Service</strong> (<strong>DNS</strong>). When we enter <a href="http://www.google.com">www.google.com</a>, our computer uses the DNS servers to resolve the domain name into the corresponding IP address. While on a local network, we set up the local DNS to name local machines with symbolic names.</p>
<p>Name servers are defined in <kbd>/etc/resolv.conf</kbd>:</p>
<pre>
<strong>$ cat /etc/resolv.conf</strong> 
<strong># Local nameserver</strong> 
<strong>nameserver 192.168.1.1</strong> 
<strong># External nameserver</strong> 
<strong>nameserver 8.8.8.8</strong> 
</pre>
<p>We can add name servers manually by editing that file or with a one-liner:</p>
<pre>
<strong># sudo echo nameserver IP_ADDRESS &gt;&gt; /etc/resolv.conf</strong> 
</pre>
<p>The easiest method to obtain an IP address is to use the <kbd>ping</kbd> command to access the domain name. The reply includes the IP address:</p>
<pre>
<strong>$ ping google.com</strong> 
<strong>PING google.com (64.233.181.106) 56(84) bytes of data.</strong> 
</pre>
<p>The number <kbd>64.233.181.106</kbd> is the IP address of a google.com server.</p>
<p>A domain name may map to multiple IP addresses. In that case, <kbd>ping</kbd> shows one address from the list of IP addresses. To obtain all the addresses assigned to the domain name, we should use a DNS lookup utility.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">DNS lookup</h1>
            

            
                
<p>Several DNS lookup utilities provide name and IP address resolution from the command line. The <kbd>host</kbd> and <kbd>nslookup</kbd> commands are two commonly installed utilities.</p>
<p>The <kbd>host</kbd> command lists all of the IP addresses attached to a domain name:</p>
<pre>
<strong>$ host google.com</strong> 
<strong>google.com has address 64.233.181.105</strong> 
<strong>google.com has address 64.233.181.99</strong> 
<strong>google.com has address 64.233.181.147</strong> 
<strong>google.com has address 64.233.181.106</strong> 
<strong>google.com has address 64.233.181.103</strong> 
<strong>google.com has address 64.233.181.104</strong> 
</pre>
<p>The <kbd>nslookup</kbd> command maps names to IP addresses and will also map IP addresses to names:</p>
<pre>
<strong>$ nslookup google.com</strong> 
<strong>Server:    8.8.8.8</strong> 
<strong>Address:  8.8.8.8#53</strong> 
 
<strong>Non-authoritative answer:</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.105</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.99</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.147</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.106</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.103</strong> 
<strong>Name:  google.com</strong> 
<strong>Address: 64.233.181.104</strong> 
 
<strong>Server:    8.8.8.8</strong> 
</pre>
<p>The last line in the preceding command-line snippet corresponds to the default name server used for resolution.</p>
<p>It is possible to add a symbolic name to the IP address resolution by adding entries into the <kbd>/etc/hosts</kbd> file.</p>
<p>Entries in <kbd>/etc/hosts follow this format</kbd>:</p>
<pre>
<strong>IP_ADDRESS name1 name2 ...</strong> 
</pre>
<p>You can update <kbd>/etc/hosts</kbd> like this:</p>
<pre>
<strong># echo IP_ADDRESS symbolic_name&gt;&gt; /etc/hosts</strong> 
</pre>
<p>Consider this example:</p>
<pre>
<strong># echo 192.168.0.9 backupserver&gt;&gt; /etc/hosts</strong> 
</pre>
<p>After adding this entry, whenever resolution to <kbd>backupserver</kbd> occurs, it will resolve to <kbd>192.168.0.9</kbd>.</p>
<p>If <kbd>backupserver</kbd> has multiple names, you can include them on the same line:</p>
<pre>
<strong># echo 192.168.0.9 backupserver backupserver.example.com &gt;&gt; /etc/hosts</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Showing routing table information</h1>
            

            
                
<p>It is common to have interconnected networks. For example, different departments at work or school may be on separate networks. When a device on one network wants to communicate with a device on the other network, it needs to send packets through a device which is common to both networks. This device is called a <kbd>gateway</kbd> and its function is to route packets to and from different networks.</p>
<p>The operating system maintains a table called the <kbd>routing table</kbd>, which contains the information on how packets are to be forwarded through machines on the network. The <kbd>route</kbd> command displays the routing table:</p>
<pre>
<strong>$ route</strong> 
<strong>Kernel IP routing table</strong> 
<strong>Destination      Gateway   GenmaskFlags  Metric  Ref  UseIface</strong> 
<strong>192.168.0.0         *      255.255.252.0  U     2      0     0wlan0</strong> 
<strong>link-local          *      255.255.0.0    U     1000   0     0wlan0</strong> 
<strong>default          p4.local  0.0.0.0        UG    0      0     0wlan0</strong> 
</pre>
<p>Alternatively, you can also use this:</p>
<pre>
<strong>$ route -n</strong> 
<strong>Kernel IP routing table</strong> 
<strong>Destination   Gateway      Genmask       Flags Metric Ref  UseIface</strong> 
<strong>192.168.0.0   0.0.0.0      255.255.252.0   U     2     0     0   wlan0</strong> 
<strong>169.254.0.0   0.0.0.0      255.255.0.0     U     1000  0     0   wlan0</strong> 
<strong>0.0.0.0       192.168.0.4  0.0.0.0         UG    0     0     0   wlan0</strong> 
</pre>
<p>Using <kbd>-n</kbd> specifies to display the numeric addresses. By default, route will map the numeric address to a name.</p>
<p>When your system does not know the route to a destination, it sends the packet to a default gateway. The default gateway may be the link to the Internet or an inter-departmental router.</p>
<p>The <kbd>route add</kbd> command can add a default gateway:</p>
<pre>
<strong># route add default gw IP_ADDRESS INTERFACE_NAME</strong> 
</pre>
<p>Consider this example:</p>
<pre>
<strong># route add default gw 192.168.0.1 wlan0</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Using variables and environment variables </em>recipe of <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml" target="_blank">Chapter 1</a>, <em>Shell Something Out</em>, explains the <kbd>PATH</kbd> variable</li>
<li>The <em>Searching and mining text inside a file with grep</em> recipe of <a href="22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml" target="_blank">Chapter 4</a>, <em>Texting and Driving</em>, explains the <kbd>grep</kbd> command</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Let us ping!</h1>
            

            
                
<p>The <kbd>ping</kbd> command is a basic network command, supported on all major operating systems. Ping is used to verify connectivity between hosts on a network and identify accessible machines.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The ping command uses <strong>Internet Control Message Protocol</strong> (<strong>ICMP</strong>) packets to check the connectivity of two hosts on a network. When these echo packets are sent to a target, the target responds with a reply if the connection is complete. A ping request can fail if there is no route to the target or if there is no known route from the target back to the requester.</p>
<p>Pinging an address will check whether a host is reachable:</p>
<pre>
<strong>$ ping ADDRESS</strong> 
</pre>
<p>The <kbd>ADDRESS</kbd> can be a hostname, domain name, or an IP address itself.</p>
<p>By default, <kbd>ping</kbd> will continuously send packets and the reply information is printed on the terminal. Stop the pinging process by pressing <em>Ctrl</em> + <em>C</em>.</p>
<p>Consider the following example:</p>
<ul>
<li>When a host is reachable, the output will be similar to the following:</li>
</ul>
<pre>
<strong>        $ ping 192.168.0.1 </strong> 
<strong>        PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.</strong> 
<strong>        64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=1.44 ms</strong> 
<strong>        ^C </strong> 
<strong>        --- 192.168.0.1 ping statistics ---</strong> 
<strong>        1 packets transmitted, 1 received, 0% packet loss, time 0ms</strong> 
<strong>        rtt min/avg/max/mdev = 1.440/1.440/1.440/0.000 ms</strong> 
 
<strong>        $ ping google.com</strong> 
<strong>        PING google.com (209.85.153.104) 56(84) bytes of data.</strong> 
<strong>        64 bytes from bom01s01-in-f104.1e100.net (209.85.153.104):    
        icmp_seq=1 ttl=53 time=123 ms</strong> 
<strong>        ^C </strong> 
<strong>        --- google.com ping statistics ---</strong> 
<strong>        1 packets transmitted, 1 received, 0% packet loss, time 0ms</strong> 
<strong>        rtt min/avg/max/mdev = 123.388/123.388/123.388/0.000 ms</strong> 
</pre>
<ul>
<li>When a host is unreachable, the output will resemble this:</li>
</ul>
<pre>
<strong>        $ ping 192.168.0.99</strong> 
<strong>        PING 192.168.0.99 (192.168.0.99) 56(84) bytes of data.</strong> 
<strong>        From 192.168.0.82 icmp_seq=1 Destination Host Unreachable</strong> 
<strong>        From 192.168.0.82 icmp_seq=2 Destination Host Unreachable</strong> 
</pre>
<p>If the target is not reachable, the ping returns with the <kbd>Destination Host Unreachable</kbd> error message.</p>
<p>Network administrators generally configure devices such as routers not to respond to <kbd>ping</kbd>. This is done to lower security risks, as <kbd>ping</kbd> can be used by attackers (using brute-force) to find out IP addresses of machines.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>In addition to checking the connectivity between two points in a network, the <kbd>ping</kbd> command returns other information. The round trip time and lost packet reports can be used to determine whether a network is working properly.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Round Trip Time</h1>
            

            
                
<p>The <kbd>ping</kbd> command displays <strong>Round Trip Time</strong> (<strong>RTT</strong>) for each packet sent and returned. RTT is reported in milliseconds. On an internal network, a RTT of under 1ms is common. When pinging a site on the Internet, RTT are commonly 10-400 ms, and may exceed 1000 ms:</p>
<pre>
<strong>--- google.com ping statistics ---</strong> 
<strong>5 packets transmitted, 5 received, 0% packet loss, time 4000ms</strong> 
<strong>rtt min/avg/max/mdev = 118.012/206.630/347.186/77.713 ms</strong> 
</pre>
<p>Here, the minimum RTT is <kbd>118.012 ms</kbd>, the average RTT is <kbd>206.630</kbd> ms, and the maximum RTT is <kbd>347.186ms</kbd>. The <kbd>mdev</kbd> (<kbd>77.713ms</kbd>) parameter in the ping output stands for mean deviation.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Sequence number</h1>
            

            
                
<p>Each packet that ping sends is assigned a number, sequentially from 1 until ping stops. If a network is near saturation, packets may be returned out of order because of collisions and retries, or may be completely dropped:</p>
<pre>
<strong>$&gt; ping example.com</strong> 
<strong>64 bytes from example.com (1.2.3.4): icmp_seq=1 ttl=37 time=127.2 ms</strong> 
<strong>64 bytes from example.com (1.2.3.4): icmp_seq=3 ttl=37 time=150.2 ms</strong> 
<strong>64 bytes from example.com (1.2.3.4): icmp_seq=2 ttl=30 time=1500.3 ms</strong> 
</pre>
<p>In this example, the second packet was dropped and then retried after a timeout, causing it to be returned out of order and with a longer Round Trip Time.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Time to live</h1>
            

            
                
<p>Each ping packet has a predefined number of hops it can take before it is dropped. Each router decrements that value by one. This value shows how many routers are between your system and the site you are pinging. The initial <strong>Time To Live</strong> (<strong>TTL</strong>) value can vary depending on your platform or ping revision. You can determine the initial value by pinging the loopback connection:</p>
<pre>
<strong>$&gt; ping 127.0.0.1</strong> 
<strong>64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.049 ms</strong> 
<strong>$&gt; ping www.google.com</strong> 
<strong>64 bytes from 173.194.68.99: icmp_seq=1 ttl=45 time=49.4 ms</strong> 
</pre>
<p>In this example, we ping the loopback address to determine what the TTL is with no hops (in this case, 64). Then we ping a remote site and subtract that TTL value from our No-Hop value to determine how many hops are between the two sites. In this case, 64-45 is 19 hops.</p>
<p>The TTL value is usually constant between two sites, but can change when conditions require alternative paths.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Limiting the number of packets to be sent</h1>
            

            
                
<p>The <kbd>ping</kbd> command sends echo packets and waits for the reply of echo indefinitely until it is stopped by pressing <em>Ctrl</em> + <em>C</em>. The <kbd>-c</kbd> flag will limit the count of echo packets to be sent:</p>
<pre>
<strong>-c COUNT</strong> 
</pre>
<p>Consider this example:</p>
<pre>
<strong>$ ping 192.168.0.1 -c 2 </strong> 
<strong>PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data. </strong> 
<strong>64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=4.02 ms</strong> 
<strong>64 bytes from 192.168.0.1: icmp_seq=2 ttl=64 time=1.03 ms</strong> 
 
<strong>--- 192.168.0.1 ping statistics --- </strong> 
<strong>2 packets transmitted, 2 received, 0% packet loss, time 1001ms </strong> 
<strong>rtt min/avg/max/mdev = 1.039/2.533/4.028/1.495 ms</strong> 
</pre>
<p>In the previous example, the <kbd>ping</kbd> command sends two echo packets and stops. This is useful when we need to ping multiple machines from a list of IP addresses through a script and check their statuses.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Return status of the ping command</h1>
            

            
                
<p>The <kbd>ping</kbd> command returns the exit status <kbd>0</kbd> when it succeeds and returns non-zero when it fails. <kbd>Successful</kbd> means the destination host is reachable, whereas <kbd>Failure</kbd> is when the destination host is unreachable.</p>
<p>The return status can be obtained as follows:</p>
<pre>
<strong>$ ping domain -c2</strong> 
<strong>if [ $? -eq0 ];</strong> 
<strong>then</strong> 
<strong>  echo Successful ;</strong> 
<strong>else</strong> 
<strong>  echo Failure</strong> 
<strong>fi</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Tracing IP routes</h1>
            

            
                
<p>When an application requests a service through the Internet, the server may be at a distant location and connected via many of gateways or routers. The <kbd>traceroute</kbd> command displays the address of all intermediate gateways a packet visits before reaching its destination. <kbd>traceroute</kbd> information helps us to understand how many hops each packet takes to reach a destination. The number of intermediate gateways represents the effective distance between two nodes in a network, which may not be related to the physical distance. Travel time increases with each hop. It takes time for a router to receive, decipher, and transmit a packet.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The format for the <kbd>traceroute</kbd> command is as follows:</p>
<pre>
<strong>traceroute destinationIP</strong> 
</pre>
<p><kbd>destinationIP</kbd> may be numeric or a string:</p>
<pre>
<strong>$ traceroute google.com</strong> 
<strong>traceroute to google.com (74.125.77.104), 30 hops max, 60 byte packets</strong> 
<strong>1  gw-c6509.lxb.as5577.net (195.26.4.1)  0.313 ms  0.371 ms  0.457 ms</strong> 
<strong>2  40g.lxb-fra.as5577.net (83.243.12.2)  4.684 ms  4.754 ms  4.823 ms</strong> 
<strong>3  de-cix10.net.google.com (80.81.192.108)  5.312 ms  5.348 ms  5.327 ms</strong> 
<strong>4  209.85.255.170 (209.85.255.170)  5.816 ms  5.791 ms 209.85.255.172 (209.85.255.172)  5.678 ms</strong> 
<strong>5  209.85.250.140 (209.85.250.140)  10.126 ms  9.867 ms  10.754 ms</strong> 
<strong>6  64.233.175.246 (64.233.175.246)  12.940 ms 72.14.233.114 (72.14.233.114)  13.736 ms  13.803 ms</strong> 
<strong>7  72.14.239.199 (72.14.239.199)  14.618 ms 209.85.255.166 (209.85.255.166)  12.755 ms 209.85.255.143 (209.85.255.143)  13.803 ms</strong> 
<strong>8  209.85.255.98 (209.85.255.98)  22.625 ms 209.85.255.110 (209.85.255.110)  14.122 ms</strong> 
<strong>* </strong> 
<strong>9  ew-in-f104.1e100.net (74.125.77.104)  13.061 ms  13.256 ms  13.484 ms</strong> 
</pre>
<p>Modern Linux distributions also ship with an <kbd>mtr</kbd> command, which is similar to traceroute but shows real-time data that keeps refreshing. It is useful for checking your network carrier quality.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Listing all available machines on a network</h1>
            

            
                
<p>When we monitor a large network, we need to check the availability of all machines. A machine may not be available for two reasons: it is not powered on, or because of a problem in the network. We can write a shell script to determine and report which machines are available on the network.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>In this recipe, we demonstrate two methods. The first method uses ping and the second method uses <kbd>fping</kbd>. The <kbd>fping</kbd> command is easier for scripts and has more features than the ping command. It may not be part of your Linux distribution, but can be installed with your package manager.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The next example script will find the visible machines on the network using the ping command:</p>
<pre>
<strong>#!/bin/bash</strong> 
<strong>#Filename: ping.sh</strong> 
<strong># Change base address 192.168.0 according to your network.</strong> 
 
<strong>for ip in 192.168.0.{1..255} ;</strong> 
<strong>do</strong> 
<strong>  ping $ip -c 2 &amp;&gt; /dev/null ;</strong> 
 
<strong>  if [ $? -eq 0 ];</strong> 
<strong>  then</strong> 
<strong>    echo $ip is alive</strong> 
<strong>  fi</strong> 
<strong>done</strong> 
</pre>
<p>The output resembles this:</p>
<pre>
<strong>$ ./ping.sh</strong> 
<strong>192.168.0.1 is alive</strong> 
<strong>192.168.0.90 is alive</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>This script uses the <kbd>ping</kbd> command to find out the available machines on the network. It uses a <kbd>for</kbd> loop to iterate through a list of IP addresses generated by the expression <kbd>192.168.0.{1..255}</kbd>. The <kbd>{start..end}</kbd> notation generates values between start and end. In this case, it creates IP addresses from <kbd>192.168.0.1</kbd> to <kbd>192.168.0.255</kbd>.</p>
<p><kbd>ping $ip -c 2 &amp;&gt; /dev/null</kbd> runs a <kbd>ping</kbd> command to the corresponding IP address. The <kbd>-c</kbd> option causes ping to send only two packets. The <kbd>&amp;&gt; /dev/null</kbd> redirects both <kbd>stderr</kbd> and <kbd>stdout to /dev/null</kbd>, so nothing is printed on the terminal. The script uses <kbd>$?</kbd> to evaluate the exit status. If it is successful, the exit status is <kbd>0</kbd>, and the IP address which replied to our ping is printed.</p>
<p>In this script, a separate <kbd>ping</kbd> command is executed for each address, one after the other. This causes the script to run slowly when an IP address does not reply, since each ping must wait to time out before the next ping begins.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>The next recipes show enhancements to the ping script and how to use <kbd>fping</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Parallel pings</h1>
            

            
                
<p>The previous script tests each address sequentially. The delay for each test is accumulated and becomes large. Running the ping commands in parallel will make this faster. Enclosing the body of the loop in <kbd>{}&amp;</kbd> will make the <kbd>ping</kbd> commands run in parallel. <kbd>( )</kbd> encloses a block of commands to run as a subshell, and <kbd>&amp;</kbd> sends it to the background:</p>
<pre>
#!/bin/bash 
#Filename: fast_ping.sh 
# Change base address 192.168.0 according to your network. 

for ip in 192.168.0.{1..255} ; 
do 
   ( 
      ping $ip -c2 &amp;&gt; /dev/null ; 

      if [ $? -eq0 ]; 
      then 
       echo $ip is alive 
      fi 
   )&amp; 
  done 
wait 
</pre>
<p>In the <kbd>for</kbd> loop, we execute many background processes and come out of the loop, terminating the script. The <kbd>wait</kbd> command prevents the script from terminating until all its child processes have exited.</p>
<p>The output will be in the order that pings reply. This will not be the numeric order in which they were sent if some machines or network segments are slower than others.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Using fping</h1>
            

            
                
<p>The second method uses a different command called <kbd>fping</kbd>. The <kbd>fping</kbd> command generates ICMP messages to multiple IP addresses and then waits to see which reply. It runs much faster than the first script.</p>
<p>The options available with <kbd>fping</kbd> include the following:</p>
<ul>
<li>The <kbd>-a</kbd> option with <kbd>fping</kbd> specifies to display the IP addresses for available machines</li>
<li>The <kbd>-u</kbd> option with <kbd>fping</kbd> specifies to display unreachable machines</li>
<li>The <kbd>-g</kbd> option specifies generating a range of IP addresses from the slash-subnet mask notation specified as IP/mask or start and end IP addresses:</li>
</ul>
<pre>
<strong>        $ fping -a 192.160.1/24 -g</strong> 
</pre>
<p style="padding-left: 60px">Alternatively, this can be used:</p>
<pre>
<strong>        $ fping -a 192.160.1 192.168.0.255 -g</strong> 
</pre>
<ul>
<li><kbd>2&gt;/dev/null</kbd> is used to dump error messages printed due to an unreachable host to a null device</li>
</ul>
<p>It is also possible to manually specify a list of IP addresses as command-line arguments or as a list through <kbd>stdin</kbd>. Consider the following example:</p>
<pre>
<strong>$ fping -a 192.168.0.1 192.168.0.5 192.168.0.6</strong> 
<strong># Passes IP address as arguments</strong> 
<strong>$ fping -a &lt;ip.list</strong> 
<strong># Passes a list of IP addresses from a file</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Playing with file descriptors and redirection</em> recipe in <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml">Chapter 1</a>, <em>Shell Something Out</em>, explains the data redirection</li>
<li>The <em>Comparisons and tests</em> recipe in <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml">Chapter 1</a>, <em>Shell Something Out</em>, explains numeric comparisons</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Running commands on a remote host with SSH</h1>
            

            
                
<p><strong>SSH</strong> stands for <strong>Secure Shell</strong>. It connects two computers across an encrypted tunnel. SSH gives you access to a shell on a remote computer where you can interactively run a single command and receive the results or start an interactive session.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>SSH doesn't come preinstalled with all GNU/Linux distributions. You may have to install the <kbd>openssh-server</kbd> and <kbd>openssh-client</kbd> packages using a package manager. By default, SSH runs on port number <kbd>22</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>To connect to a remote host with the SSH server running, use the following command:</li>
</ol>
<pre>
<strong>        $ ssh username@remote_host</strong> 
</pre>
<p style="padding-left: 60px">The options in this command are as follows:</p>
<div><ul>
<li> <kbd>username</kbd> is the user that exists at the remote host</li>
</ul>
<ul>
<li><kbd>remote_host</kbd> can be the domain name or IP address</li>
</ul>
</div>
<p style="padding-left: 60px">Consider this example:</p>
<pre>
<strong>        $ ssh mec@192.168.0.1</strong> 
<strong>        The authenticity of host '192.168.0.1 (192.168.0.1)' can't be   
        established.</strong> 
<strong>        RSA key fingerprint is   
        2b:b4:90:79:49:0a:f1:b3:8a:db:9f:73:2d:75:d6:f9.</strong> 
<strong>        Are you sure you want to continue connecting (yes/no)? yes</strong> 
<strong>        Warning: Permanently added '192.168.0.1' (RSA) to the list of   
        known hosts.</strong> 
<strong>        Password:</strong> 
 
<strong>        Last login: Fri Sep  3 05:15:21 2010 from 192.168.0.82</strong> 
<strong>        mec@proxy-1:~$</strong> 
</pre>
<p style="padding-left: 90px">SSH will ask for a password, and upon successful authentication it will connect to the login shell on the remote machine.</p>
<p>SSH performs a fingerprint verification to make sure we are actually connecting to the remote computer we want. This is to avoid what is called a <strong>man-in-the-middle attack</strong>, where an attacker tries to impersonate another computer. SSH will, by default, store the fingerprint the first time we connect to a server and verify that it does not change for future connections.</p>
<p style="padding-left: 90px">By default, the SSH server runs at port <kbd>22</kbd>. However, certain servers run SSH service at different ports. In that case, use <kbd>-p port_num</kbd> with the <kbd>ssh</kbd> command to specify the port.</p>
<ol start="2">
<li>Connect to an SSH server running at port <kbd>422</kbd>:</li>
</ol>
<pre>
<strong>        $ ssh user@locahost -p 422</strong> 
</pre>
<p style="padding-left: 60px">When using <kbd>ssh</kbd> in shell scripts, we do not want an interactive shell, we simply want to execute commands on the remote system and process the command's output.</p>
<p>Issuing a password every time is not practical for an automated script, so password-less login using SSH keys should be configured. The <em>P<em>a</em>ssword-less auto-login with SSH</em> recipe in this chapter explains the SSH commands to set this up.</p>
<ol start="3">
<li>To run a command at the remote host and display its output on the local shell, use the following syntax:</li>
</ol>
<pre>
<strong>        $ sshuser@host 'COMMANDS'</strong> 
</pre>
<p style="padding-left: 60px">Consider this example:</p>
<pre>
<strong>        $ ssh mec@192.168.0.1 'whoami'</strong> 
<strong>        mec</strong>
</pre>
<p style="padding-left: 60px">You can submit multiple commands by separating the commands with a semicolon:</p>
<pre>
<strong>        $ ssh user@host "command1 ; command2 ; command3"</strong> 
</pre>
<p style="padding-left: 60px">Consider the following example:</p>
<pre>
<strong>        $ ssh mec@192.168.0.1  "echo user: $(whoami);echo OS: $(uname)"</strong> 
<strong>        Password:
</strong><strong>        user: mec
</strong><strong>        OS: Linux </strong>
</pre>
<p style="padding-left: 60px">In this example, the commands executed at the remote host are as follows:</p>
<pre>
<strong>        echo user: $(whoami);</strong> 
<strong>        echo OS: $(uname)</strong> 
</pre>
<p style="padding-left: 60px">We can pass a more complex subshell in the command sequence using the <kbd>( )</kbd> subshell operator.</p>
<ol start="3">
<li>The next example is an SSH-based shell script to collect the uptime of a list of remote hosts. Uptime is the length of time since the last power-on. It's returned by the <kbd>uptime</kbd> command.</li>
</ol>
<p style="padding-left: 60px">It is assumed that all systems in <kbd>IP_LIST</kbd> have a common user <kbd>test</kbd>.</p>
<pre>
<strong>        #!/bin/bash</strong> 
<strong>        #Filename: uptime.sh</strong> 
<strong>        #Description: Uptime monitor</strong> 
 
<strong>        IP_LIST="192.168.0.1 192.168.0.5 192.168.0.9"</strong> 
<strong>        USER="test"</strong> 
 
<strong>        for IP in $IP_LIST;</strong> 
<strong>        do</strong> 
<strong>        utime=$(ssh ${USER}@${IP} uptime  |awk '{ print $3 }' )</strong> 
<strong>          echo $IP uptime:  $utime</strong> 
<strong>        done</strong> 
</pre>
<p style="padding-left: 60px">Expected output:</p>
<pre>
<strong>        $ ./uptime.sh</strong> 
<strong>        192.168.0.1 uptime: 1:50,</strong> 
<strong>        192.168.0.5 uptime: 2:15,</strong> 
<strong>        192.168.0.9 uptime: 10:15,</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>The <kbd>ssh</kbd> command can be executed with several additional options.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">SSH with compression</h1>
            

            
                
<p>The SSH protocol supports compressing the data transfer. This feature comes in handy when bandwidth is an issue. Use the <kbd>-C</kbd> option with the <kbd>ssh</kbd> command to enable compression:</p>
<pre>
<strong>$ ssh -C user@hostname COMMANDS</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Redirecting data into stdin of remote host shell commands</h1>
            

            
                
<p>SSH allows you to use output from a task on your local system as input on the remote system:</p>
<pre>
<strong>$ echo 'text' | ssh user@remote_host 'echo'</strong> 
<strong>text</strong> 
</pre>
<p>Alternatively, this can be used:</p>
<pre>
<strong># Redirect data from file as:</strong> 
<strong>$ ssh user@remote_host 'echo'  &lt; file</strong> 
</pre>
<p><kbd>echo</kbd> on the remote host prints the data received through <kbd>stdin</kbd>, which in turn is passed to <kbd>stdin</kbd> from localhost.</p>
<p>This facility can be used to transfer tar archives from a local host to the remote host. This is described in detail in <a href="3fc45121-c541-4c47-90ec-4db14dc7a60e.xhtml" target="_blank">Chapter 7</a>, <em>The Backup plan</em>:</p>
<pre>
<strong>$&gt; tar -czf - LOCALFOLDER | ssh 'tar -xzvf-'</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Running graphical commands on a remote machine</h1>
            

            
                
<p>If you attempt to run a command on a remote machine that uses a graphical window, you will see an error similar to <kbd>cannot open display</kbd>. This is because the <kbd>ssh</kbd> shell is attempting (and failing) to connect to the X server on the remote machine.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>To run an graphical application on a remote server, you need to set the <kbd>$DISPLAY</kbd> variable to force the application to connect to the X server on your local machine:</p>
<pre>
<strong>ssh user@host "export DISPLAY=:0 ; command1; command2"""</strong> 
</pre>
<p>This will launch the graphical output on the remote machine.</p>
<p>If you want to show the graphical output on your local machine, use SSH's X11 forwarding option:</p>
<pre>
<strong>ssh -X user@host "command1; command2"</strong> 
</pre>
<p>This will run the commands on the remote machine, but it will display graphics on your machine.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Password-less auto-login with SSH</em> recipe in this chapter explains how to configure auto-login to execute commands without prompting for a password<br/></li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Transferring files through the network</h1>
            

            
                
<p>A major use for networking computers is resource sharing. Files are a common shared resource. There are different methods for transferring files between systems, ranging from a USB stick and <kbd>sneakernet</kbd> to network links such as NFS and Samba. These recipes describe how to transfer files using the common protocols FTP, SFTP, RSYNC, and SCP.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>The commands for performing file transfer over the network are mostly available by default with Linux installation. Files can be transferred via FTP using the traditional <kbd>ftp</kbd> command or the newer <kbd>lftp</kbd>, or via an SSH connection using <kbd>scp</kbd> or <kbd>sftp</kbd>. Files can be synchronized across systems with the <kbd>rsync</kbd> command.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p><strong>File Transfer Protocol</strong> (<strong>FTP</strong>) is old and is used in many public websites to share files. The service usually runs on port <kbd>21</kbd>. FTP requires that an FTP server be installed and running on the remote machine. We can use the traditional <kbd>ftp</kbd> command or the newer <kbd>lftp</kbd> command to access an FTP-enabled server. The following commands are supported by both <kbd>ftp</kbd> and <kbd>lftp</kbd>. FTP is used in many public websites to share files.</p>
<p>To connect to an FTP server and transfer files to and from it, use the following command:</p>
<pre>
<strong>$ lftpusername@ftphost</strong> 
</pre>
<p>It will prompt for a password and then display a logged in prompt:</p>
<pre>
<strong>lftp username@ftphost:~&gt;</strong> 
</pre>
<p>You can type commands in this prompt, as shown here:</p>
<ul>
<li><kbd>cd directory</kbd>: This will change directory on the remote system</li>
<li><kbd>lcd:</kbd> This will change the directory on the local machine</li>
<li><kbd>mkdir</kbd>: This will create a directory on the remote machine</li>
<li><kbd>ls</kbd>: This will list files in the current directory on the remote machine</li>
<li><kbd>get FILENAME</kbd>: This will download a file to the current directory on the local machine:</li>
</ul>
<pre>
<strong>        lftp username@ftphost:~&gt; get filename</strong> 
</pre>
<ul>
<li><kbd>put filename</kbd>: This will upload a file from the current directory on the remote machine:</li>
</ul>
<pre>
<strong>        lftp username@ftphost:~&gt; put filename</strong> 
</pre>
<ul>
<li>The <kbd>quit</kbd> command will terminate an <kbd>lftp</kbd> session</li>
</ul>
<p>Autocompletion is supported in the <kbd>lftp</kbd> prompt</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>Let's go through additional techniques and commands used for file transfer through a network.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Automated FTP transfer</h1>
            

            
                
<p>The <kbd>lftp</kbd> and the <kbd>ftp</kbd> commands open an interactive session with the user. We can automate FTP file transfers with a shell script:</p>
<pre>
#!/bin/bash 

#Automated FTP transfer 
HOST=example.com' 
USER='foo' 
PASSWD='password' 
lftp  -u ${USER}:${PASSWD} $HOST &lt;&lt;EOF 

binary 
cd /home/foo 
put testfile.jpg 

quit 
EOF 
</pre>
<p>The preceding script has the following structure:</p>
<pre>
&lt;&lt;EOF 
DATA 
EOF 
</pre>
<p>This is used to send data through <kbd>stdin</kbd> to the <kbd>lftp</kbd> command. The <em>Playing with file descriptors and redirection</em> recipe of <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml">Chapter 1</a>, <em>Shell Something Out</em>, explains various methods for redirection to <em>stdin</em>.</p>
<p>The <kbd>-u</kbd> option logs in to the remote site with our defined <kbd>USER</kbd> and <kbd>PASSWD</kbd>. The <kbd>binary</kbd> command sets the file mode to binary.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">SFTP (Secure FTP)</h1>
            

            
                
<p>SFTP is a file transfer system that runs on the top of an SSH connection and emulates an FTP interface. It requires an SSH server on the remote system instead of an FTP server. It provides an interactive session with an <kbd>sftp</kbd> prompt.</p>
<p>Sftp supports the same commands as <kbd>ftp</kbd> and <kbd>lftp</kbd>.</p>
<p>To start an <kbd>sftp</kbd> session, use the following command:</p>
<pre>
<strong>$ sftp user@domainname</strong> 
</pre>
<p>Similar to <kbd>lftp</kbd>, an <kbd>sftp</kbd> session can be terminated by typing the <kbd>quit</kbd> command.</p>
<p>Sometimes, the SSH server will not be running at the default port <kbd>22</kbd>. If it is running at a different port, we can specify the port along with <kbd>sftp</kbd> as <kbd>-oPort=PORTNO</kbd>. Consider this example:</p>
<pre>
<strong>$ sftp -oPort=422 user@slynux.org</strong> 
</pre>
<p><kbd>-oPort</kbd> should be the first argument of the <kbd>sftp</kbd> command.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">The rsync command</h1>
            

            
                
<p>The <kbd>rsync</kbd> command is widely used for copying files over networks and for taking backup snapshots. This is described in detail in the <em>Backing up snapshots with rsync</em></p>
<p> recipe of <a href="3fc45121-c541-4c47-90ec-4db14dc7a60e.xhtml" target="_blank">Chapter 7</a>, <em>The Backup Plan</em>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">SCP (secure copy program)</h1>
            

            
                
<p>SCP is a secure file copy command similar to the older, insecure remote copy tool called <kbd>rcp</kbd>. The files are transferred through an encrypted channel using SSH:</p>
<pre>
<strong>$ scp filename user@remotehost:/home/path</strong> 
</pre>
<p>This will prompt for a password. Like <kbd>ssh</kbd>, the transfer can be made password-less with the auto-login SSH technique. The <em>Password-less auto-login with SSH</em> recipe in this chapter explains SSH auto-login. Once SSH login is automated, the scp command can be executed without an interactive password prompt.</p>
<p>The <kbd>remotehost</kbd> can be an IP address or domain name. The format of the <kbd>scp</kbd> command is as follows:</p>
<pre>
<strong>$ scp SOURCE DESTINATION</strong> 
</pre>
<p><kbd>SOURCE</kbd> or <kbd>DESTINATION</kbd> can be in the format <kbd>username@host:/path</kbd>:</p>
<pre>
<strong>$ scp user@remotehost:/home/path/filename filename</strong> 
</pre>
<p>The preceding command copies a file from the remote host to the current directory with the given filename.</p>
<p>If SSH is running at a different port than <kbd>22</kbd>, use <kbd>-oPort</kbd> with the same syntax, <kbd>sftp</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Recursive copying with scp</h1>
            

            
                
<p>The <kbd>-r</kbd> parameter tells <kbd>scp</kbd> to recursively copy a directory between two machines:</p>
<pre>
<strong>$ scp -r /home/usernameuser@remotehost:/home/backups</strong> 
<strong># Copies the directory /home/usernameto the remote backup</strong> 
</pre>
<p>The <kbd>-p</kbd> parameter will cause <kbd>scp</kbd> to retain permissions and modes when copying files.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Playing with file descriptors and redirection</em> recipe in <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml" target="_blank">Chapter 1</a>, <em>Shell Something Out</em>, explains the standard input using EOF</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Connecting to a wireless network</h1>
            

            
                
<p>An Ethernet connection is simple to configure, since it is connected through wired cables with no special requirements like authentication. However, wireless LAN requires an <strong>Extended Service Set IDentification</strong> network identifier (<strong>ESSID</strong>) and may also require a pass-phrase.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>To connect to a wired network, we simply assign an IP address and subnet mask with the <kbd>ifconfig</kbd> utility. A wireless network connection requires the <kbd>iwconfig</kbd> and <kbd>iwlist</kbd> utilities.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>This script will connect to a wireless LAN with <strong>WEP</strong> (<strong>Wired Equivalent Privacy</strong>):</p>
<pre>
<strong>#!/bin/bash </strong>
<strong>#Filename: wlan_connect.sh </strong>
<strong>#Description: Connect to Wireless LAN </strong>

<strong>#Modify the parameters below according to your settings </strong>
<strong>######### PARAMETERS ########### </strong>
<strong>IFACE=wlan0 </strong>
<strong>IP_ADDR=192.168.1.5 </strong>
<strong>SUBNET_MASK=255.255.255.0 </strong>
<strong>GW=192.168.1.1 </strong>
<strong>HW_ADDR='00:1c:bf:87:25:d2'  </strong>
<strong>#Comment above line if you don't want to spoof mac address </strong>

<strong>ESSID="homenet" </strong>
<strong>WEP_KEY=8b140b20e7  </strong>
<strong>FREQ=2.462G </strong>
<strong>################################# </strong>

<strong>KEY_PART="" </strong>

<strong>if [[ -n $WEP_KEY ]]; </strong>
<strong>then </strong>
<strong>  KEY_PART="key $WEP_KEY" </strong>
<strong>fi </strong>

<strong>if [ $UID -ne 0 ]; </strong>
<strong>then </strong>
<strong>  echo "Run as root" </strong>
<strong>  exit 1; </strong>
<strong>fi </strong>

<strong># Shut down the interface before setting new config </strong>
<strong>/sbin/ifconfig $IFACE down </strong>


<strong>if [[ -n $HW_ADDR  ]]; </strong>
<strong>then </strong>
<strong>  /sbin/ifconfig $IFACE hw ether $HW_ADDR </strong>
<strong>  echo Spoofed MAC ADDRESS to $HW_ADDR </strong>
<strong>fi </strong>

<strong>/sbin/iwconfig $IFACE essid $ESSID $KEY_PART freq $FREQ </strong>

<strong>/sbin/ifconfig $IFACE $IP_ADDR netmask $SUBNET_MASK </strong>

<strong>route add default gw $GW $IFACE </strong>

<strong>echo Successfully configured $IFACE</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The <kbd>ifconfig</kbd>, <kbd>iwconfig</kbd>, and <kbd>route</kbd> commands must be run as root. Hence, a check for the root user is performed before performing any actions in the scripts.</p>
<p>Wireless LAN requires parameters such as <kbd>essid</kbd>, <kbd>key</kbd>, and <kbd>frequency</kbd> to connect to the network. <kbd>essid</kbd> is the name of the wireless network to connect to. Some networks use a WEP key for authentication, which is usually a five- or ten-letter hex passphrase. The frequency assigned to the network is required by the <kbd>iwconfig</kbd> command to attach the wireless card with the proper wireless network.</p>
<p>The <kbd>iwlist</kbd> utility will scan and list the available wireless networks:</p>
<pre>
<strong># iwlist scan</strong> 
<strong>wlan0     Scan completed :</strong> 
<strong>          Cell 01 - Address: 00:12:17:7B:1C:65</strong> 
<strong>                    Channel:11</strong> 
<strong>                    Frequency:2.462 GHz (Channel 11) </strong> 
<strong>                    Quality=33/70  Signal level=-77 dBm</strong> 
<strong>                    Encryption key:on</strong> 
<strong>                    ESSID:"model-2" </strong> 
</pre>
<p>The <kbd>Frequency</kbd> parameter can be extracted from the scan result, from the <kbd>Frequency:2.462 GHz (Channel 11)</kbd> line.</p>
<p>WEP is used in this example for simplicity. Note that WEP is insecure. If you are administering the wireless network, use a variant of <strong>Wi-Fi Protected Access2</strong> (<strong>WPA2</strong>).</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Comparisons and tests</em> recipe of <a href="195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml" target="_blank">Chapter 1</a>, <em>Shell Something Out</em>, explains string comparisons</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Password-less auto-login with SSH</h1>
            

            
                
<p>SSH is widely used with automation scripting, as it makes it possible to remotely execute commands at remote hosts and read their outputs. Usually, SSH is authenticated with username and password, which are prompted during the execution of SSH commands. Providing passwords in automated scripts is impractical, so we need to automate logins. SSH has a feature which SSH allows a session to auto-login. This recipe describes how to create SSH keys for auto-login.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>SSH uses an encryption technique called asymmetric keys consisting of two keys–a public key and a private key for automatic authentication. The <kbd>ssh-keygen</kbd> application creates an authentication key pair. To automate the authentication, the public key must be placed on the server (by appending the public key to the <kbd>~/.ssh/authorized_keys</kbd> file) and the private key file of the pair should be present at the <kbd>~/.ssh</kbd> directory of the user at the client machine. SSH configuration options (for example, path and name of the <kbd>authorized_keys</kbd> file) can be modified by altering the <kbd>/etc/ssh/sshd_config</kbd> configuration file.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>There are two steps to implement automatic authentication with SSH. They are as follows:</p>
<ul>
<li>Creating the SSH key on the local machine</li>
<li>Transferring the public key to the remote host and appending it to <kbd>~/.ssh/authorized_keys</kbd> (which requires access to the remote machine)</li>
</ul>
<p>To create an SSH key, run the <kbd>ssh-keygen</kbd> command with the encryption algorithm type specified as RSA:</p>
<pre>
<strong>$ ssh-keygen -t rsa</strong> 
<strong>Generating public/private rsa key pair. </strong> 
<strong>Enter file in which to save the key (/home/username/.ssh/id_rsa): </strong> 
<strong>Created directory '/home/username/.ssh'. </strong> 
<strong>Enter passphrase (empty for no passphrase): </strong> 
<strong>Enter same passphrase again: </strong> 
<strong>Your identification has been saved in /home/username/.ssh/id_rsa. </strong> 
<strong>Your public key has been saved in /home/username/.ssh/id_rsa.pub. </strong> 
<strong>The key fingerprint is: </strong> 
<strong>f7:17:c6:4d:c9:ee:17:00:af:0f:b3:27:a6:9c:0a:05 username@slynux-laptop</strong> 
<strong>The key'srandomart image is: </strong> 
<strong>+--[ RSA 2048]----+ </strong> 
<strong>|           .     | </strong> 
<strong>|            o . .|</strong> 
<strong>|     E       o o.|</strong> 
<strong>|      ...oo | </strong> 
<strong>|       .S .+  +o.| </strong> 
<strong>|      .  . .=....| </strong> 
<strong>|     .+.o...| </strong> 
<strong>|      . . + o.  .|</strong> 
<strong>|       ..+       | </strong> 
<strong>+-----------------+ </strong> 
</pre>
<p>You need to enter a passphrase to generate the public-private key pair. It is possible to generate the key pair without entering a passphrase, but it is insecure.</p>
<p>If you intend to write scripts that use automated login to several machines, you should leave the passphrase empty to prevent the script from asking for a passphrase while running.</p>
<p>The <kbd>ssh-keygen</kbd> program creates two files. <kbd>~/.ssh/id_rsa.pub</kbd> and <kbd>~/.ssh/id_rsa:id_rsa.pub</kbd> is the generated public key and <kbd>id_rsa</kbd> is the private key. The public key has to be appended to the <kbd>~/.ssh/authorized_keys</kbd> file on remote servers where we need to auto-login from the current host.</p>
<p>This command will append a key file:</p>
<pre>
<strong>$ ssh USER@REMOTE_HOST \
    "cat &gt;&gt; ~/.ssh/authorized_keys" &lt; ~/.ssh/id_rsa.pub
Password:</strong>
</pre>
<p>Provide the login password in the previous command.</p>
<p>The auto-login has been set up from now onwards, so SSH will not prompt for passwords during execution. Test this with the following command:</p>
<pre>
<strong>$ ssh USER@REMOTE_HOST uname</strong> 
<strong>Linux</strong> 
</pre>
<p>You will not be prompted for a password. Most Linux distros include <kbd>ssh-copy-id</kbd>, which will append your private key to the appropriate <kbd>authorized_keys</kbd> file on the remote server. This is shorter than the <kbd>ssh</kbd> technique described earlier:</p>
<pre>
<strong>ssh-copy-id USER@REMOTE_HOST</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Port forwarding using SSH</h1>
            

            
                
<p>Port forwarding is a technique which redirects an IP connection from one host to another. For example, if you are using a Linux/Unix system as a firewall you can redirect connections to port <kbd>1234</kbd> to an internal address such as <kbd>192.168.1.10:22</kbd> to provide an <kbd>ssh</kbd> tunnel from the outside world to an internal machine.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>You can forward a port on your local machine to another machine and it's also possible to forward a port on a remote machine to another machine. In the following examples, you will get a shell prompt once the forwarding is complete. Keep this shell open to use the port forward and exit it whenever you want to stop the port forward.</p>
<ol>
<li>This command will forward port <kbd>8000</kbd> on your local machine to port <kbd>80</kbd> on <a href="http://www.kernel.org">www.kernel.org</a>:</li>
</ol>
<pre>
<strong>        ssh -L 8000:www.kernel.org:80user@localhost</strong> 
</pre>
<p style="padding-left: 60px">Replace user with the username on your local machine.</p>
<ol start="2">
<li>This command will forward port 8000 on a remote machine to port <kbd>80</kbd> of <a href="http://www.kernel.org">www.kernel.org</a>:</li>
</ol>
<pre>
<strong>        ssh -L 8000:www.kernel.org:80user@REMOTE_MACHINE</strong> 
</pre>
<p style="padding-left: 60px">Here, replace <kbd>REMOTE_MACHINE</kbd> with the hostname or IP address of the remote machine and <kbd>user</kbd> with the username you have SSH access to.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>Port forwarding is more useful when using non-interactive mode or reverse port forwarding.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Non-interactive port forward</h1>
            

            
                
<p>If you want to just set port forwarding instead of having a shell kept open while port forwarding is effective, use the following form of <kbd>ssh</kbd>:</p>
<pre>
<strong>ssh -fL8000:www.kernel.org:80user@localhost -N</strong> 
</pre>
<p>The <kbd>-f</kbd> option instructs <kbd>ssh</kbd> to fork to background before executing the command. <kbd>-N</kbd> tells <kbd>ssh</kbd> that there is no command to run; we only want to forward ports.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Reverse port forwarding</h1>
            

            
                
<p>Reverse port forwarding is one of the most powerful features of SSH. This is most useful in situations where you have a machine which isn't publicly accessible from the Internet, but you want others to be able to access a service on this machine. In this case, if you have SSH access to a remote machine which is publicly accessible on the Internet, you can set up a reverse port forward on that remote machine to the local machine which is running the service.</p>
<pre>
<strong>ssh -R 8000:localhost:80 user@REMOTE_MACHINE</strong> 
</pre>
<p>This command will forward port <kbd>8000</kbd> on the remote machine to port <kbd>80</kbd> on the local machine. Don't forget to replace <kbd>REMOTE_MACHINE</kbd> with the hostname of the IP address of the remote machine.</p>
<p>Using this method, if you browse to <kbd>http://localhost:8000</kbd> on the remote machine, you will connect to a web server running on port <kbd>80</kbd> of the local machine.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Mounting a remote drive at a local mount point</h1>
            

            
                
<p>Having a local mount point to access the remote host filesystem facilitates read and write data transfer operations. SSH is the common transfer protocol. The <kbd>sshfs</kbd> application uses SSH to enable you to mount a remote filesystem on a local mount point.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p><kbd>sshfs</kbd> doesn't come by default with GNU/Linux distributions. Install <kbd>sshfs</kbd> with a package manager. <kbd>sshfs</kbd> is an extension to the FUSE filesystem package that allows users to mount a wide variety of data as if it were a local filesystem. Variants of FUSE are supported on Linux, Unix, Mac OS/X, Windows, and more.</p>
<p>For more information on FUSE, visit its website at <a href="http://fuse.sourceforge.net/" target="_blank">http://fuse.sourceforge.net/</a>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>To mount a filesystem location at a remote host to a local mount point:</p>
<pre>
<strong># sshfs -o allow_otheruser@remotehost:/home/path /mnt/mountpoint</strong> 
<strong>Password:</strong> 
</pre>
<p>Issue the password when prompted. After the password is accepted, the data at <kbd>/home/path</kbd> on the remote host can be accessed via a local mount point, <kbd>/mnt/mountpoint</kbd>.</p>
<p>To unmount, use the following command:</p>
<pre>
<strong># umount /mnt/mountpoint</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">See also</h1>
            

            
                
<ul>
<li>The <em>Running commands on a remote host with SSH</em> recipe in this chapter explains the <kbd>ssh</kbd> command</li>
</ul>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Network traffic and port analysis</h1>
            

            
                
<p>Every application that accesses the network does it via a port. Listing the open ports, the application using a port and the user running the application is a way to track the expected and unexpected uses of your system. This information can be used to allocate resources as well as checking for rootkits or other malware.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>Various commands are available for listing ports and services running on a network node. The <kbd>lsof</kbd> and <kbd>netstat</kbd> commands are available on most GNU/Linux distributions.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The <kbd>lsof</kbd> (list open files) command will list open files. The <kbd>-i</kbd> option limits it to open network connections:</p>
<pre>
<strong>$ lsof -i 
COMMAND    PID   USER   FD   TYPE DEVICE SIZE/OFF NODE 
    NAME

firefox-b 2261 slynux   78u  IPv4  63729      0t0  TCP 
    localhost:47797-&gt;localhost:42486 (ESTABLISHED)

firefox-b 2261 slynux   80u  IPv4  68270      0t0  TCP 
    slynux-laptop.local:41204-&gt;192.168.0.2:3128 (CLOSE_WAIT)

firefox-b 2261 slynux   82u  IPv4  68195      0t0  TCP 
    slynux-laptop.local:41197-&gt;192.168.0.2:3128 (ESTABLISHED)

ssh       3570 slynux    3u  IPv6  30025      0t0  TCP 
    localhost:39263-&gt;localhost:ssh (ESTABLISHED)

ssh       3836 slynux    3u  IPv4  43431      0t0  TCP 
    slynux-laptop.local:40414-&gt;boney.mt.org:422 (ESTABLISHED)

GoogleTal 4022 slynux   12u  IPv4  55370      0t0  TCP 
    localhost:42486 (LISTEN)

GoogleTal 4022 slynux   13u  IPv4  55379      0t0  TCP 
    localhost:42486-&gt;localhost:32955 (ESTABLISHED)</strong>
</pre>
<p>Each entry in the output of <kbd>lsof</kbd> corresponds to a service with an active network port. The last column of output consists of lines similar to this:</p>
<pre>
<strong>laptop.local:41197-&gt;192.168.0.2:3128</strong> 
</pre>
<p>In this output, <kbd>laptop.local:41197</kbd> corresponds to the <kbd>localhost</kbd> and <kbd>192.168.0.2:3128</kbd> corresponds to the remote host. <kbd>41197</kbd> is the port used on the current machine, and <kbd>3128</kbd> is the port to which the service connects at the remote host.</p>
<p>To list the opened ports from the current machine, use the following command:</p>
<pre>
<strong>$ lsof -i | grep ":[0-9a-z]+-&gt;" -o | grep "[0-9a-z]+" -o  | sort | uniq</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>The <kbd>:[0-9a-z]+-&gt;</kbd> regex for grep extracts the host port portion <kbd>(:34395-&gt; or :ssh-&gt;)</kbd> from the <kbd>lsof</kbd> output. The next <kbd>grep</kbd> removes the leading colon and trailing arrow leaving the port number (which is alphanumeric). Multiple connections may occur through the same port and hence, multiple entries of the same port may occur. The output is sorted and passed through <kbd>uniq</kbd> to display each port only once.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>There are more utilities that report open port and network traffic related information.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Opened port and services using netstat</h1>
            

            
                
<p><kbd>netstat</kbd> also returns network service statistics. It has many features beyond what is covered in this recipe.</p>
<p>Use <kbd>netstat -tnp</kbd> to list opened port and services:</p>
<pre>
<strong>$ netstat -tnp</strong> 
<strong>Proto Recv-Q Send-Q Local Address           Foreign Address         
    State       PID/Program name 

tcp        0      0 192.168.0.82:38163      192.168.0.2:3128        
    ESTABLISHED 2261/firefox-bin 

tcp        0      0 192.168.0.82:38164      192.168.0.2:3128        
    TIME_WAIT   -               

tcp        0      0 192.168.0.82:40414      193.107.206.24:422      
    ESTABLISHED 3836/ssh

tcp        0      0 127.0.0.1:42486         127.0.0.1:32955         
    ESTABLISHED 4022/GoogleTalkPlug

tcp        0      0 192.168.0.82:38152      192.168.0.2:3128        
    ESTABLISHED 2261/firefox-bin 

tcp6       0      0 ::1:22                  ::1:39263               
    ESTABLISHED -               

tcp6       0      0 ::1:39263               ::1:22                  
    ESTABLISHED 3570/ssh</strong>
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Measuring network bandwidth</h1>
            

            
                
<p>The previous discussion of <kbd>ping</kbd> and <kbd>traceroute</kbd> was on measuring the latency of a network and the number of hops between nodes.</p>
<p>The <kbd>iperf</kbd> application provides more metrics for a networks' performance. The <kbd>iperf</kbd> application is not installed by default, but it is provided by most distributions' package manager.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The <kbd>iperf</kbd> application must be installed on both ends of a link (a host and a client). Once <kbd>iperf</kbd> is installed, start the server end:</p>
<pre>
<strong>$ iperf -s</strong> 
</pre>
<p>Then run the client side to generate throughput statistics:</p>
<pre>
<strong>$ iperf -c 192.168.1.36</strong> 
<strong>------------------------------------------------------------</strong> 
<strong>Client connecting to 192.168.1.36, TCP port 5001</strong> 
<strong>TCP window size: 19.3 KByte (default)</strong> 
<strong>------------------------------------------------------------</strong> 
<strong>[  3] local 192.168.1.44 port 46526 connected with 192.168.1.36 port 5001</strong> 
<strong>[ ID] Interval       Transfer     Bandwidth</strong> 
<strong>[  3]  0.0-10.0 sec   113 MBytes  94.7 Mbits/sec</strong> 
</pre>
<p>The <kbd>-m</kbd> option instructs <kbd>iperf</kbd> to also find the <strong>Maximum Transfer Size</strong> (<strong>MTU</strong>):</p>
<pre>
<strong>$ iperf -mc 192.168.1.36</strong> 
<strong>------------------------------------------------------------</strong> 
<strong>Client connecting to 192.168.1.36, TCP port 5001</strong> 
<strong>TCP window size: 19.3 KByte (default)</strong> 
<strong>------------------------------------------------------------</strong> 
<strong>[  3] local 192.168.1.44 port 46558 connected with 192.168.1.36 port 5001</strong> 
<strong>[ ID] Interval       Transfer     Bandwidth</strong> 
<strong>[  3]  0.0-10.0 sec   113 MBytes  94.7 Mbits/sec</strong> 
<strong>[  3] MSS size 1448 bytes (MTU 1500 bytes, ethernet)</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating arbitrary sockets</h1>
            

            
                
<p>For operations such as file transfer and secure shell, there are prebuilt tools such as ftp and <kbd>ssh</kbd>. We can also write custom scripts as network services. The next recipe demonstrates how to create simple network sockets and use them for communication.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>The <kbd>netcat</kbd> or <kbd>nc</kbd> command will create network sockets to transfer data over a TCP/IP network. We need two sockets: one listens for connections and the other connects to the listener.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Set up the listening socket using the following command:</li>
</ol>
<pre>
<strong>        nc -l 1234</strong> 
</pre>
<p style="padding-left: 60px">This will create a listening socket on port <kbd>1234</kbd> on the local machine.</p>
<ol start="2">
<li>Connect to the socket using the following command:</li>
</ol>
<pre>
<strong>        nc HOST 1234</strong> 
</pre>
<p style="padding-left: 60px">If you are running this on the same machine as the listening socket, replace <kbd>HOST</kbd> with localhost, otherwise replace it with the IP address or hostname of the machine.</p>
<ol start="3">
<li>Type something and press <em>Enter</em> on the terminal where you performed step 2. The message will appear on the terminal where you performed step 1.</li>
</ol>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>Network sockets can be used for more than just text communication, as shown in the following sections.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Quickly copying files over the network</h1>
            

            
                
<p>We can exploit <kbd>netcat</kbd> and shell redirection to copy files over the network. This command will send a file to the listening machine:</p>
<ol>
<li> On the listening machine, run the following command:</li>
</ol>
<pre>
<strong>        nc -l 1234 &gt;destination_filename</strong> 
</pre>
<ol start="2">
<li>On the sender machine, run the following command:</li>
</ol>
<pre>
<strong>        nc HOST 1234 &lt;source_filename</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a broadcasting server</h1>
            

            
                
<p>You can use <kbd>netcan</kbd> to create a custom server. The next recipe demonstrates a server that will send the time every 10 seconds. The time can be received by connecting to the port with a client <kbd>nc</kbd> session of telnet:</p>
<pre>
<strong># A script to echo the date out a port</strong> 
<strong>while [ 1 ]</strong> 
<strong>do</strong> 
<strong>  sleep 10</strong> 
<strong>  date</strong> 
<strong>done | nc -l 12345 </strong> 
<strong>echo exited</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p>Copying files with <kbd>nc</kbd> works because ns echoes the input from the input of one socket to the output at the other.</p>
<p>The broadcasting server is a bit more complicated. The <kbd>while [ 1 ]</kbd> loop will run forever. Within the loop, the script sleeps for 10 seconds, then invokes the date command and pipes the output to the <kbd>nc</kbd> command.</p>
<p>You can use <kbd>nc</kbd> to create a client, as follows:</p>
<pre>
<strong>$ nc 127.0.0.1 12345</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Building a bridge</h1>
            

            
                
<p>If you have two separate networks, you may need a way to pass data from one network to the other. This is commonly done by connecting the two subnets with a router, hub, or switch.</p>
<p>A Linux system can be used for a network bridge.</p>
<p>A bridge is a low-level connection that passes packets based on their MAC address instead of being identified by the IP address. As such it requires fewer machine resources and is more efficient.</p>
<p>You can use a bridge to link virtual machines on private, non-routed networks, or to link separate subnets in a company, for instance, to link a manufacturing subnet to the shipping sub-net so production information can be shared.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>The Linux kernel has supported network bridges since the 2.2 kernel. The current tool to define a bridge, is the iproute2 (<kbd>ip</kbd>) command. This is standard in most distributions.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The ip command performs several actions using the command/subcommand model. To create a bridge, we use the <kbd>ip link</kbd> commands.</p>
<p>The Ethernet adapter being attached to the bridge should not be configured with an IP address when it is added to the bridge. The bridge is configured with an address, not the NIC.</p>
<p>In this example, there are two NIC cards: <kbd>eth0</kbd> is configured and connected to the <kbd>192.168.1.0</kbd> subnet, while eth1 is not configured but will be connected to the <kbd>10.0.0.0</kbd> subnet via the bridge:</p>
<pre>
<strong>    # Create a new bridge named br0</strong> 
<strong>    ip link add br0 type bridge</strong> 
 
<strong>    # Add an Ethernet adapter to the bridge</strong> 
<strong>    ip link set dev eth1 master br0</strong> 
 
<strong>    # Configure the bridge's IP address</strong> 
<strong>    ifconfig br0 10.0.0.2</strong> 
 
<strong>    # Enable packet forwarding </strong> 
<strong>    echo 1 &gt;/proc/sys/net/ipv4/ip_forward</strong> 
</pre>
<p>This creates the bridge allowing packets to be sent from <kbd>eth0</kbd> to <kbd>eth1</kbd> and back. Before the bridge can be useful, we need to add this bridge to the routing tables.</p>
<p>On machines in the <kbd>10.0.0.0/24</kbd> network, we add a route to the <kbd>192.168.1.0/16</kbd> network:</p>
<pre>
<strong>route add -net 192.168.1.0/16 gw 10.0.0.2</strong> 
</pre>
<p>Machines on the <kbd>192.168.1.0/16</kbd> subnet need to know how to find the <kbd>10.0.0.0/24</kbd> subnet. If the <kbd>eth0</kbd> card is configured for IP address <kbd>192.168.1.2</kbd>, the route command is as follows:</p>
<pre>
<strong>route add -net 10.0.0.0/24 gw 192.168.1.2</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Sharing an Internet connection</h1>
            

            
                
<p>Most firewall/routers have the ability to share an Internet connection with the devices in your home or office. This is called <strong>Network Address Translation</strong> (<strong>NAT</strong>). A Linux computer with two <strong>Network Interface Cards</strong> (<strong>NIC</strong>) can act as a router, providing firewall protection and connection sharing.</p>
<p>Firewalling and NAT support are provided by the support for iptables built into the kernel. This recipe introduces <kbd>iptables</kbd> with a recipe that shares a computer's Ethernet link to the Internet through the wireless interface to give other wireless devices access to the Internet via the host's Ethernet NIC.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>This recipe uses <kbd>iptables</kbd> to define a <strong>Network Address Translation</strong> (<strong>NAT</strong>), which lets a networking device share a connection with other devices. You will need the name of your wireless interface, which is reported by the <kbd>iwconfig</kbd> command.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<ol>
<li>Connect to the Internet. In this recipe, we are assuming that the primary wired network connection, <kbd>eth0</kbd>, is connected to the Internet. Change it according to your setup.</li>
<li>Using your distro's network management tool, create a new ad hoc wireless connection with the following settings:<br/>
<ul>
<li>IP address: 10.99.66.55</li>
</ul>
</li>
</ol>
<div><ul>
<li>Subnet mask: 255.255.0.0 (16)</li>
</ul>
</div>
<ol start="3">
<li>Use the following shell script to share the Internet connection:</li>
</ol>
<pre>
<strong>        #!/bin/bash 
        #filename: netsharing.sh

        echo 1 &gt; /proc/sys/net/ipv4/ip_forward 

        iptables -A FORWARD -i $1 -o $2 \
            -s 10.99.0.0/16 -m conntrack --ctstate NEW -j ACCEPT 

        iptables -A FORWARD -m conntrack --ctstate \
            ESTABLISHED,RELATED -j ACCEPT

        iptables -A POSTROUTING -t nat -j MASQUERADE
</strong>
</pre>
<ol start="4">
<li> Run the script:</li>
</ol>
<pre>
<strong>        ./netsharing.sh eth0 wlan0</strong> 
</pre>
<p style="padding-left: 60px">Here <kbd>eth0</kbd> is the interface that is connected to the Internet and <kbd>wlan0</kbd> is the wireless interface that is supposed to share the Internet with other devices.</p>
<ol start="5">
<li>Connect your devices to the wireless network you just created with the following settings:
<ul>
<li>IP address: 10.99.66.56 (and so on)</li>
<li>Subnet mask: 255.255.0.0</li>
</ul>
</li>
</ol>
<p>To make this more convenient, you might want to install a DHCP and DNS server on your machine, so it's not necessary to configure IPs on devices manually. A handy tool for this is <kbd>dnsmasq</kbd>, which performs both DHCP and DNS operations.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works</h1>
            

            
                
<p>There are three sets of IP addresses set aside for non-routing use. That means that no network interface visible to the Internet can use them. They are only used by machines on a local, internal network. The addresses are <kbd>10.x.x.x</kbd>, <kbd>192.168.x.x</kbd>, and <kbd>172.16.x.x-&gt; 172.32.x.x</kbd>. In this recipe, we use a portion of the <kbd>10.x.x.x</kbd> address space for our internal network.</p>
<p>By default, Linux systems will accept or generate packets, but will not echo them. This is controlled by the value <kbd>in/proc/sys/net/ipv4/ip_forward</kbd>.</p>
<p>Echoing a <kbd>1</kbd> to that location tells the Linux kernel to forward any packet it doesn't recognize. This allows the wireless devices on the <kbd>10.99.66.x</kbd> subnet to use <kbd>10.99.66.55</kbd> as their gateway. They will send a packet destined for an Internet site to <kbd>10.99.66.55</kbd>, which will then forward it out its gateway on <kbd>eth0</kbd> to the Internet to be routed to the destination.</p>
<p>The <kbd>iptables</kbd> command is how we interact with the Linux kernel's iptables subsystem. These commands add rules to forward all packets from the internal network to the outside world and to forward expected packets from the outside world to our internal network.</p>
<p>The next recipe will discuss more ways to use iptables.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Basic firewall using iptables</h1>
            

            
                
<p>A firewall is a network service that is used to filter network traffic for unwanted traffic, block it, and allow the desired traffic to pass. The standard firewall tool for Linux is <kbd>iptables</kbd>, which is integrated into the kernel in recent versions.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p><kbd>iptables</kbd> is present by default on all modern Linux distributions. It's easy to configure for common scenarios:</p>
<ol>
<li> If don't want to contact a given site (for example, a known malware site), you can block traffic to that IP address:</li>
</ol>
<pre>
<strong>        #iptables -A OUTPUT -d 8.8.8.8 -j DROP</strong> 
</pre>
<p style="padding-left: 60px">If you use <kbd>PING 8.8.8.8</kbd> in another terminal, then by running the <kbd>iptables</kbd> command, you will see this:</p>
<pre>
<strong>        PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.</strong> 
<strong>        64 bytes from 8.8.8.8: icmp_req=1 ttl=56 time=221 ms</strong> 
<strong>        64 bytes from 8.8.8.8: icmp_req=2 ttl=56 time=221 ms</strong> 
<strong>        ping: sendmsg: Operation not permitted</strong> 
<strong>        ping: sendmsg: Operation not permitted</strong> 
</pre>
<p style="padding-left: 60px">Here, the ping fails the third time because we used the <kbd>iptables</kbd> command to drop all traffic to <kbd>8.8.8.8</kbd>.</p>
<ol start="2">
<li>You can also block traffic to a specific port:</li>
</ol>
<pre>
<strong>        #iptables -A OUTPUT -p tcp -dport 21 -j DROP</strong> 
<strong>        $ ftp ftp.kde.org</strong> 
<strong>        ftp: connect: Connection timed out</strong> 
</pre>
<p style="padding-left: 60px">If you find messages like this in your <kbd>/var/log/secure</kbd> or <kbd>var/log/messages</kbd> file, you have a small problem:</p>
<pre>
<strong>        Failed password for abel from 1.2.3.4 port 12345 ssh2</strong> 
<strong>        Failed password for baker from 1.2.3.4 port 12345 ssh2</strong> 
</pre>
<p>These messages mean a robot is probing your system for weak passwords. You can prevent the robot from accessing your site with an INPUT rule that will drop all traffic from that site.</p>
<pre>
<strong>        #iptables -I INPUT -s 1.2.3.4 -j DROP</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How it works...</h1>
            

            
                
<p><kbd>iptables</kbd> is the command used to configure the firewall on Linux. The first argument in <kbd>iptables</kbd> is -A, which instructs <kbd>iptables</kbd> to append a new rule to the chain, or -I, which places the new rule at the start of the ruleset. The next parameter defines the chain. A chain is a collection of rules, and in earlier recipes we used the <kbd>OUTPUT</kbd> chain, which is evaluated for outgoing traffic, whereas the last recipes used the <kbd>INPUT</kbd> chain, which is evaluated for incoming traffic.</p>
<p>The <kbd>-d</kbd> parameter specifies the destination to match with the packet being sent, and  <kbd>-s</kbd> specifies the source of a packet. Finally, the <kbd>-j</kbd> parameter instructs <kbd>iptables</kbd> to jump to a particular action. In these examples, we used the DROP action to drop the packet. Other actions include <kbd>ACCEPT</kbd> and <kbd>REJECT</kbd>.</p>
<p>In the second example, we use the <kbd>-p</kbd> parameter to specify that this rule matches only TCP on the port specified with <kbd>-dport</kbd>. This blocks only the outbound <kbd>FTP</kbd> traffic.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">There's more...</h1>
            

            
                
<p>You can clear the changes made to the <kbd>iptables</kbd> chains with the <kbd>-flush</kbd> parameter:</p>
<pre>
<strong>#iptables -flush</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating a Virtual Private Network</h1>
            

            
                
<p>A <strong>Virtual Private Network</strong> (<strong>VPN</strong>) is an encrypted channel that operates across public networks. The encryption keeps your information private. VPNs are used to connect remote offices, distributed manufacturing sites, and remote workers.</p>
<p>We've discussed copying files with <kbd>nc</kbd>, or <kbd>scp</kbd>, or <kbd>ssh</kbd>. With a VPN network, you can mount remote drives via NFS and access resources on the remote network as if they were local.</p>
<p>Linux has clients for several VPN systems, as well as client and server support for OpenVPN.</p>
<p>This section's recipes will describe setting up an OpenVPN server and client. This recipe is to configure a single server to service multiple clients in a hub and spoke model. OpenVPN supports more topologies that are beyond the scope of this chapter.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Getting ready</h1>
            

            
                
<p>OpenVPN is not part of most Linux distributions. You can install it using your package manager:</p>
<pre>
<strong>apt-get install openvpn</strong> 
</pre>
<p>Alternatively, this command can also be used:</p>
<pre>
<strong>yum install openvpn</strong> 
</pre>
<p>Note that you'll need to do this on the server and each client.</p>
<p>Confirm that the tunnel device (<kbd>/dev/net/tun</kbd>) exists. Test this on server and client systems. On modern Linux systems, the tunnel should already exist:</p>
<pre>
<strong>ls /dev/net/tun</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">How to do it...</h1>
            

            
                
<p>The first step in setting up an OpenVPN network is to create the certificates for the server and at least one client. The simplest way to handle this is to make self-signed certificates with the <kbd>easy-rsa</kbd> package included with pre-version 2.3 releases of OpenVPN. If you have a later version of OpenVPN, <kbd>easy-rsa</kbd> should be available via the package manager.</p>
<p>This package is probably installed in <kbd>/usr/share/easy-rsa</kbd>.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating certificates</h1>
            

            
                
<p>First, make sure you've got a clean slate with nothing left over from previous installations:</p>
<pre>
<strong># cd /usr/share/easy-rsa</strong> 
<strong># . ./vars</strong> 
<strong># ./clean-all</strong> 
</pre>
<p>NOTE: If you run <kbd>./clean-all</kbd>, I will be doing a <kbd>rm -rf</kbd> on <kbd>/usr/share/easy-rsa/keys</kbd>.</p>
<p>Next, create the <strong>Certificate Authority</strong> key with the <kbd>build-ca</kbd> command. This command will prompt you for information about your site. You'll have to enter this information several times. Substitute your name, e-mail, site name, and so on for the values in this recipe. The required information varies slightly between commands. Only the unique sections will be repeated in these recipes:</p>
<pre>
<strong># ./build-ca</strong> 
<strong>Generating a 2048 bit RSA private key</strong> 
<strong>......+++</strong> 
<strong>.....................................................+++</strong> 
<strong>writing new private key to 'ca.key'</strong> 
<strong>-----</strong> 
<strong>You are about to be asked to enter information that will be incorporated</strong> 
<strong>into your certificate request.</strong> 
<strong>What you are about to enter is what is called a Distinguished Name or a DN.</strong> 
<strong>There are quite a few fields but you can leave some blank</strong> 
<strong>For somefieldsthere will be a default value,</strong> 
<strong>If you enter '.', the field will be left blank.</strong> 
<strong>-----</strong> 
<strong>Country Name (2 letter code) [US]:</strong> 
<strong>State or Province Name (full name) [CA]:MI</strong> 
<strong>Locality Name (eg, city) [SanFrancisco]:WhitmoreLake</strong> 
<strong>Organization Name (eg, company) [Fort-Funston]:Example</strong> 
<strong>Organizational Unit Name (eg, section) [MyOrganizationalUnit]:Packt</strong> 
<strong>Common Name (eg, your name or your server's hostname) [Fort-Funston CA]:vpnserver</strong> 
<strong>Name [EasyRSA]:</strong> 
<strong>Email Address [me@myhost.mydomain]:admin@example.com</strong> 
 
<strong>Next, build the server certificate with the build-key command:</strong> 
<strong># ./build-key server</strong> 
<strong>Generating a 2048 bit RSA private key</strong> 
<strong>..................................+++</strong> 
<strong>.....................+++</strong> 
<strong>writing new private key to 'server.key'</strong> 
<strong>-----</strong> 
<strong>You are about to be asked to enter information that will be incorporated</strong> 
<strong>into your certificate request....</strong> 
 
 
 
 
 
<strong>Please enter the following 'extra' attributes</strong> 
<strong>to be sent with your certificate request</strong> 
<strong>A challenge password []:</strong> 
</pre>
<p>Create a certificate for at least one client. You'll need a separate client certificate for each machine that you wish to connect to this OpenVPN server:</p>
<pre>
<strong># ./build-key client1</strong> 
<strong>Generating a 2048 bit RSA private key</strong> 
<strong>.......................+++</strong> 
<strong>.................................................+++</strong> 
<strong>writing new private key to 'client1.key'</strong> 
<strong>-----</strong> 
<strong>You are about to be asked to enter information that will be incorporated</strong> 
<strong>into your certificate request.</strong> 
<strong>... </strong> 
 
 
 
 
<strong>Please enter the following 'extra' attributes</strong> 
<strong>to be sent with your certificate request</strong> 
<strong>A challenge password []:</strong> 
<strong>An optional company name []:</strong> 
<strong>Using configuration from /usr/share/easy-rsa/openssl-1.0.0.cnf</strong> 
<strong>Check that the request matches the signature</strong> 
<strong>Signature ok</strong> 
<strong>The Subject's Distinguished Name is as follows</strong> 
<strong>countryName  :PRINTABLE:'US'</strong> 
<strong>stateOrProvinceName  :PRINTABLE:'MI'</strong> 
<strong>localityName  :PRINTABLE:'WhitmoreLake'</strong> 
<strong>organizationName  :PRINTABLE:'Example'</strong> 
<strong>organizationalUnitName:PRINTABLE:'Packt'</strong> 
<strong>commonName  :PRINTABLE:'client1'</strong> 
<strong>name                  :PRINTABLE:'EasyRSA'</strong> 
<strong>emailAddress:IA5STRING:'admin@example.com'</strong> 
<strong>Certificate is to be certified until Jan  8 15:24:13 2027 GMT (3650 days)</strong> 
<strong>Sign the certificate? [y/n]:y</strong> 
 
 
<strong>1 out of 1 certificate requests certified, commit? [y/n]y</strong> 
<strong>Write out database with 1 new entries</strong> 
<strong>Data Base Updated</strong> 
</pre>
<p>Finally, generate the <strong>Diffie-Hellman</strong> with the <kbd>build-dh</kbd> command. This will take several seconds and will generate a few screens filled with dots and plusses:</p>
<pre>
<strong># ./build-dh</strong> 
<strong>Generating DH parameters, 2048 bit long safe prime, generator 2</strong> 
<strong>This is going to take a long time</strong> 
<strong>......................+............+........</strong> 
</pre>
<p>These steps will create several files in the keys folder. The next step is to copy them to the folders where they'll be used.</p>
<p>Copy server keys to <kbd>/etc/openvpn</kbd>:</p>
<pre>
<strong># cp keys/server* /etc/openvpn</strong> 
<strong># cp keys/ca.crt /etc/openvpn</strong> 
<strong># cp keys/dh2048.pem /etc/openvpn</strong> 
</pre>
<p>Copy the client keys to the client system:</p>
<pre>
<strong># scp keys/client1* client.example.com:/etc/openvpn</strong> 
<strong># scp keys/ca.crt client.example.com:/etc/openvpn</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring OpenVPN on the server</h1>
            

            
                
<p>OpenVPN includes sample configuration files that are almost ready to use. You only need to customize a few lines for your environment. The files are commonly found in <kbd>/usr/share/doc/openvpn/examples/sample-config-files</kbd>:</p>
<pre>
<strong># cd /usr/share/doc/openvpn/examples/sample-config-files</strong> 
<strong># cp server.conf.gz /etc/openvpn</strong> 
<strong># cd /etc/openvpn</strong> 
<strong># gunzip server.conf.gz</strong> 
<strong># vim server.conf</strong> 
</pre>
<p>Set the local IP address to listen on. This is the IP address of the NIC attached to the network you intend to allow VPN connections through:</p>
<pre>
<strong>local 192.168.1.125</strong> 
<strong>Modify the paths to the certificates:</strong> 
 
<strong>ca /etc/openvpn/ca.crt</strong> 
<strong>cert /etc/openvpn/server.crt</strong> 
<strong>key /etc/openvpn/server.key  # This file should be kept secret</strong> 
</pre>
<p>Finally, check that the <kbd>diffie-hellman</kbd> parameter file is correct. The OpenVPN sample <kbd>config</kbd> file may specify a 1024-bit length key, while the <kbd>easy-rsa</kbd> creates a 2048-bit (more secure) key.</p>
<pre>
<strong>#dh dh1024.pem</strong> 
<strong>dh dh2048.pem</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Configuring OpenVPN on the client</h1>
            

            
                
<p>There is a similar set of configurations to do on each client.</p>
<p>Copy the client configuration file to <kbd>/etc/openvpn</kbd>:</p>
<pre>
<strong># cd /usr/share/doc/openvpn/examples/sample-config-files</strong> 
<strong># cpclient.conf /etc/openvpn</strong> 
</pre>
<p>Edit the <kbd>client.conf</kbd> file:</p>
<pre>
<strong># cd /etc/openvpn</strong> 
<strong># vim client.conf</strong> 
</pre>
<p>Change the paths for the certificates to the point to correct folders:</p>
<pre>
<strong>ca /etc/openvpn/ca.crt</strong> 
<strong>cert /etc/openvpn/server.crt</strong> 
<strong>key /etc/openvpn/server.key  # This file should be kept secret</strong> 
</pre>
<p>Set the remote site for your server:</p>
<pre>
<strong>#remote my-server-1 1194</strong> 
<strong>remote server.example.com 1194</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Starting the server</h1>
            

            
                
<p>The server can be started now. If everything is configured correctly, you'll see it output several lines of output. The important line to look for is the <kbd>Initialization Sequence Completed</kbd> line. If that is missing, look for an error message earlier in the output:</p>
<pre>
<strong># openvpnserver.conf</strong> 
<strong>Wed Jan 11 12:31:08 2017 OpenVPN 2.3.4 x86_64-pc-linux-gnu [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6] built on Nov 12 2015</strong> 
<strong>Wed Jan 11 12:31:08 2017 library versions: OpenSSL 1.0.1t  3 May 2016, LZO 2.08...</strong> 
 
 
<strong>Wed Jan 11 12:31:08 2017 client1,10.8.0.4</strong> 
<strong>Wed Jan 11 12:31:08 2017 Initialization Sequence Completed</strong> 
</pre>
<p>Using <kbd>ifconfig</kbd>, you can confirm that the server is running. You should see the tunnel device (tun) listed:</p>
<pre>
<strong>$ ifconfig</strong> 
<strong>tun0      Link encap:UNSPECHWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  </strong> 
<strong>inet addr:10.8.0.1  P-t-P:10.8.0.2  Mask:255.255.255.255</strong> 
<strong>          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1</strong> 
<strong>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</strong> 
<strong>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</strong> 
<strong>          collisions:0 txqueuelen:100 </strong> 
<strong>          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Starting and testing a client</h1>
            

            
                
<p>Once the server is running, you can start a client. Like the server, the client side of OpenVPN is created with the <kbd>openvpn</kbd> command. Again, the important part of this output is the <kbd>Initialization Sequence Completed</kbd> line:</p>
<pre>
<strong># openvpn client.conf</strong> 
<strong>Wed Jan 11 12:34:14 2017 OpenVPN 2.3.4 i586-pc-linux-gnu [SSL (OpenSSL)] [LZO] [EPOLL] [PKCS11] [MH] [IPv6] built on Nov 19 2015</strong> 
<strong>Wed Jan 11 12:34:14 2017 library versions: OpenSSL 1.0.1t  3 May 2016, LZO 2.08...</strong> 
 
 
 
 
<strong>Wed Jan 11 12:34:17 2017 /sbin/ipaddr add dev tun0 local 10.8.0.6 peer 10.8.0.5</strong> 
<strong>Wed Jan 11 12:34:17 2017 /sbin/ip route add 10.8.0.1/32 via 10.8.0.5</strong> 
<strong>Wed Jan 11 12:34:17 2017 Initialization Sequence Completed</strong> 
</pre>
<p>Using the <kbd>ifconfig</kbd> command, you can confirm that the tunnel has been initialized:</p>
<pre>
<strong>$ /sbin/ifconfig</strong> 
 
<strong>tun0      Link encap:UNSPECHWaddr 00-00-00-00-00-00-00-00...00-00-00-00  </strong> 
<strong>inet addr:10.8.0.6  P-t-P:10.8.0.5  Mask:255.255.255.255</strong> 
<strong>          UP POINTOPOINT RUNNING NOARP MULTICAST  MTU:1500  Metric:1</strong> 
<strong>          RX packets:2 errors:0 dropped:0 overruns:0 frame:0</strong> 
<strong>          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</strong> 
<strong>          collisions:0 txqueuelen:100 </strong> 
<strong>          RX bytes:168 (168.0 B)  TX bytes:336 (336.0 B)</strong> 
</pre>
<p>Use the <kbd>netstat</kbd> command to confirm that the new network is routed correctly:</p>
<pre>
<strong>$ netstat -rn</strong> 
<strong>Kernel IP routing table</strong> 
<strong>Destination   Gateway       Genmask         Flags   MSS Window  irttIface</strong> 
<strong>0.0.0.0       192.168.1.7   0.0.0.0         UG        0 0          0 eth0</strong> 
<strong>10.8.0.1      10.8.0.5      255.255.255.255 UGH       0 0          0 tun0</strong> 
<strong>10.8.0.5      0.0.0.0       255.255.255.255 UH        0 0          0 tun0</strong> 
<strong>192.168.1.0   0.0.0.0       255.255.255.0   U         0 0          0 eth0</strong> 
</pre>
<p>This output shows the tunnel device connected to the <kbd>10.8.0.x</kbd> network, and the gateway is <kbd>10.8.0.1</kbd>.</p>
<p>Finally, you can test connectivity with the <kbd>ping</kbd> command:</p>
<pre>
<strong>$ ping 10.8.0.1</strong> 
<strong>PING 10.8.0.1 (10.8.0.1) 56(84) bytes of data.</strong> 
<strong>64 bytes from 10.8.0.1: icmp_seq=1 ttl=64 time=1.44 ms</strong> 
</pre>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>