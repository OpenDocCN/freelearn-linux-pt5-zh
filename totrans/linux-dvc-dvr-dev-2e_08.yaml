- en: '*Chapter 6*: Introduction to Devices, Drivers, and Platform Abstraction'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Linux Device Model** (**LDM**) is a concept that was introduced in the
    Linux kernel to describe and manage kernel objects (those requiring reference
    counting, for example, such as files, devices, buses, and even drivers), as well
    as their hierarchies and how they are bound to others. LDM introduced object life
    cycle management, reference counting, an **object-oriented** (**OO**) programming
    style in the kernel, and other advantages (such as code reusability and refactoring,
    automatic resource releasing, and more), which will not be discussed here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Since reference counting and life cycle management are at the lowest level of
    LDM, we will discuss higher representations, such as dealing with common kernel
    data objects and structures, including **devices**, **drivers**, and **buses**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Linux kernel platform abstraction and data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device and driver matching mechanism explained
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel platform abstraction and data structures
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux device model is built on top of some fundamental data structures,
    including `struct device`, `struct device_driver`, and `struct bus_type`. The
    first data structure represents the device to be driven, the second is the data
    structure of each software entity intended to drive the device, and the latter
    represents the channel between the device and the CPU.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Device base structure
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Devices help extract either physical or virtual devices. They are built on
    top of the `struct device` structure, which is worth introducing first, as described
    in `include/linux/device.h`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at each element in this structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '`parent`: This is the device''s "parent" device, the device that this device
    is attached to. In most cases, a parent device is some sort of bus or host controller.
    If `parent` is `NULL`, then the device is a top-level device. This is the case
    for bus controller devices for example.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kobj`: This is the lowest-level data structure and is used to track a kernel
    object (bus, driver, device, and so on). This is the centerpiece of LDM. We will
    discuss this in [*Chapter 14*](B17934_14_Epub.xhtml#_idTextAnchor203), *Introduction
    to the Linux Device Model*.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bus`: This specifies the type of bus the device is on. It is the channel between
    the device and the CPU.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver`: This specifies which driver has allocated this device.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`platform_data`: This provides platform data that''s specific to the device.
    This field is automatically set when the device is declared from within the board
    file. In other words, it points to board-specific structures from within the board
    setup file that describe the device and how it is wired. It helps minimize the
    use of `#ifdefs` inside the device driver code. It contains resources such as
    chip variants, GPIO pin roles, and interrupt lines.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`driver_data`: This is a private pointer for driver-specific information. The
    bus controller driver is responsible for providing helper functions, which are
    accessors that are used to get/set this field.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_data`：这是一个私有指针，用于存储与驱动程序相关的信息。总线控制器驱动程序负责提供辅助函数，这些访问器用于获取/设置此字段。'
- en: '`pm_domain`: This specifies power management-specific callbacks that are executed
    during system power state changes: suspend, hibernation, system resume, and during
    runtime PM transitions, along with subsystem-level and driver-level callbacks.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm_domain`：此字段指定在系统电源状态变化时执行的电源管理特定回调：挂起、休眠、系统恢复以及在运行时PM过渡期间，包含子系统级和驱动程序级的回调。'
- en: '`of_node`: This is the device tree node that''s associated with this device.
    This field is automatically filled by the `platform_data` or `of_node` is set
    to determine where exactly the device has been declared.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_node`：这是与该设备关联的设备树节点。此字段由`platform_data`自动填充，或者`of_node`设置为确定设备声明的位置。'
- en: '`id`: This is the device instance.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是设备实例。'
- en: Devices are rarely represented by bare device structures since most subsystems
    track extra information about the devices they host; instead, the structure is
    frequently embedded within a higher-level representation of the device. This is
    the case for the `struct i2c_client`, `struct spi_device`, `struct usb_device`,
    and `struct platform_device` structures, which all embed a `struct device` element
    in their members (`spi_device->dev`, `i2c_client->dev`, `usb_device->dev`, and
    `platform_device->dev`).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 设备通常不是通过裸设备结构表示的，因为大多数子系统会追踪它们所托管的设备的额外信息；相反，该结构通常嵌入在设备的更高级表示中。`struct i2c_client`、`struct
    spi_device`、`struct usb_device`和`struct platform_device`结构都嵌入了一个`struct device`元素（`spi_device->dev`、`i2c_client->dev`、`usb_device->dev`和`platform_device->dev`）。
- en: Device driver base structure
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备驱动程序基础结构
- en: The next structure we need to introduce is the `struct device_driver` structure.
    This structure is the base element of any device driver. In object-oriented languages,
    this structure would be the base class, which would be inherited by each device
    driver.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要介绍的是`struct device_driver`结构。此结构是任何设备驱动程序的基本元素。在面向对象的编程语言中，这个结构就像基类，每个设备驱动程序都将继承它。
- en: 'This data structure is defined in `include/linux/device/driver.h` like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据结构在`include/linux/device/driver.h`中定义，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s look at each element in this structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个结构中的每个元素：
- en: '`name`: This is the name of the device driver. It''s used as a fallback (that
    is, it matches this name with the device name) when no matching method succeeds.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是设备驱动程序的名称。当没有匹配方法成功时，它会作为回退（即，它会将此名称与设备名称匹配）。'
- en: '`bus`: This field is mandatory. It represents the bus that the devices of this
    driver belong to. Driver registration will fail if this field is not set because
    it is its probe method that is responsible for matching the driver with devices.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus`：此字段是必填项。它表示此驱动程序所属设备的总线。如果此字段未设置，驱动程序注册将失败，因为正是其`probe`方法负责将驱动程序与设备匹配。'
- en: '`owner`: This field specifies the module owner.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`：此字段指定模块所有者。'
- en: '`of_match_table`: This is the open firmware table. It represents the array
    of `struct of_device_id` elements that are used for device tree matching.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_match_table`：这是开放固件表。它表示用于设备树匹配的`struct of_device_id`元素数组。'
- en: '`acpi_match_table`: This is the ACPI match table. This is the same as `of_match_table`
    but for ACPI matching, which will not be discussed in this tutorial.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acpi_match_table`：这是ACPI匹配表。它与`of_match_table`相同，但用于ACPI匹配，在本教程中不会讨论该内容。'
- en: '`probe`: This function is called to query the existence of a specific device,
    whether this driver can work with it, and then bind the driver to a specific device.
    The bus driver is responsible for calling this function at given moments. We will
    discuss this shortly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe`：此函数用于查询特定设备是否存在，驱动程序是否可以与其配合工作，然后将驱动程序绑定到特定设备上。总线驱动程序负责在特定时刻调用此函数，我们稍后将讨论此内容。'
- en: '`remove`: When a device is removed from the system, this method is called to
    unbind it from this driver.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：当设备从系统中移除时，会调用此方法将其与驱动程序解绑。'
- en: '`shutdown`: This command is issued when the device is about to be turned off.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：当设备即将关闭时，会发出此命令。'
- en: '`suspend`: This is a callback that allows you to put the device into sleep
    mode, mostly in a low-power state.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`：这是一个回调函数，允许将设备置于睡眠模式，通常是低功耗状态。'
- en: '`resume`: This is invoked by the driver core to wake up a device that has been
    in sleep mode.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume`：这是由驱动程序核心调用，用于唤醒处于睡眠模式的设备。'
- en: '`pm`: This represents a set of power management callbacks for devices that
    matched this driver.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm`：这表示一组与该驱动程序匹配的设备相关的电源管理回调函数。'
- en: In the preceding data structure, the `shutdown`, `suspend`, `resume`, and `pm`
    elements are optional as they are used for power management purposes. Providing
    these elements depends on the capability of the underlying device (whether it
    can be shut down, suspended, or perform other power management-related capabilities).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述数据结构中，`shutdown`、`suspend`、`resume` 和 `pm` 元素是可选的，因为它们用于电源管理目的。是否提供这些元素取决于底层设备的能力（例如，设备是否可以关闭、挂起或执行其他与电源管理相关的功能）。
- en: Driver registration
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序注册
- en: First, you should keep in mind that registering a device consists of inserting
    that device into the list of devices that are maintained by its bus driver. In
    the same way, registering a device driver consists of pushing this driver into
    the list of drivers that's maintained by the driver of the bus that it sits on
    top of. For example, registering a USB device driver will result in inserting
    that driver into the list of drivers that are maintained by the USB controller
    driver. The same goes for registering an SPI device driver, which will queue the
    driver into the list of drivers that are maintained by the SPI controller driver.
    `driver_register()` is a low-level function that's used to register a device driver
    with the bus. It adds the driver to the bus's list of drivers. When a device driver
    is registered with the bus, the core walks through the bus's list of devices and
    calls the bus's `match()` callback for each device that does not have a driver
    associated with it to find out whether there are any devices that the driver can
    handle. When a match occurs, the device and the device driver are bound together.
    The process of associating a device with a device driver is called binding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你应该记住，注册设备包括将设备插入到由其总线驱动程序维护的设备列表中。同样，注册设备驱动程序是将该驱动程序推入由其所在总线驱动程序维护的驱动程序列表中。例如，注册
    USB 设备驱动程序会将该驱动程序插入到由 USB 控制器驱动程序维护的驱动程序列表中。注册 SPI 设备驱动程序的过程也是一样，它会将该驱动程序排入由 SPI
    控制器驱动程序维护的驱动程序列表中。`driver_register()` 是一个低级函数，用于将设备驱动程序注册到总线中。它会将驱动程序添加到总线的驱动程序列表中。当设备驱动程序与总线注册后，内核会遍历总线的设备列表，对于每个没有关联驱动程序的设备，调用总线的
    `match()` 回调函数，以查看该驱动程序是否可以处理这些设备。当匹配成功时，设备与设备驱动程序将被绑定在一起。将设备与设备驱动程序关联的过程称为绑定。
- en: You probably never want to use `driver_register()` as-is; it is up to the bus
    driver to provide a bus-specific registration function, which will be a wrapper
    based on `driver_register()`. So far, bus-specific registration functions have
    always matched the `{bus_name}_register_driver()` pattern. For example, the registration
    functions for the USB, SPI, I2C, and PCI drivers would be `usb_register_driver()`,
    `spi_register_driver()`, `i2c_register_driver()`, and `pci_register_driver()`,
    respectively.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能永远不想直接使用 `driver_register()`；由总线驱动程序提供特定总线的注册函数，通常是基于 `driver_register()`
    的包装函数。到目前为止，特定总线的注册函数一直遵循 `{bus_name}_register_driver()` 模式。例如，USB、SPI、I2C 和 PCI
    驱动程序的注册函数分别为 `usb_register_driver()`、`spi_register_driver()`、`i2c_register_driver()`
    和 `pci_register_driver()`。
- en: 'The recommended place to register/unregister the driver is within the `init`/`exit`
    functions of the module, which are executed at the module loading/unloading stages,
    respectively. In lots of cases, registering/unregistering the driver is the only
    action you will want to execute within those `init`/`exit` functions. In such
    cases, each bus core provides a specific helper macro, which will be expanded
    as the `init`/`exit` functions of the module and internally call the bus-specific
    registering/unregistering function. Those bus macros follow the `module_{bus_name}_driver(__{bus_name}_driver);`
    pattern, where `__{bus_name}_driver` is the driver structure of the corresponding
    bus. The following table shows a non-exhaustive list of buses that are supported
    in Linux, along with their macros:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐在模块的`init`/`exit`函数中注册/反注册驱动程序，这些函数分别在模块加载/卸载阶段执行。在许多情况下，注册/反注册驱动程序是你在这些`init`/`exit`函数中唯一需要执行的操作。在这种情况下，每个总线核心提供一个特定的辅助宏，它将被扩展为模块的`init`/`exit`函数，并内部调用总线特定的注册/反注册函数。这些总线宏遵循`module_{bus_name}_driver(__{bus_name}_driver);`模式，其中`__{bus_name}_driver`是相应总线的驱动程序结构。下表展示了
    Linux 支持的一些总线及其宏（此表并不详尽）：
- en: '![Table 6.1 – Some buses, along with their (un)registration macros'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.1 – 一些总线及其（反）注册宏'
- en: '](img/B17934_06_Table_1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_06_Table_1.jpg)'
- en: Table 6.1 – Some buses, along with their (un)registration macros
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1 – 一些总线及其（反）注册宏
- en: 'The bus controller code is responsible for providing such macros, but this
    is not always the case. For example, the MDIO bus driver (a 2-wire serial bus
    that''s used to control network devices) does not provide a `module_mdio_driver()`
    macro. You should check whether this macro exists for the bus that the device
    sits on top of to write the driver before using it. The following code blocks
    show two examples of different buses – one using the bus-provided registering/unregistering
    macro, and another not using it. Let''s see what the code looks like when we don''t
    use the macro:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总线控制器代码负责提供这些宏，但并非总是如此。例如，MDIO 总线驱动程序（用于控制网络设备的 2 线串行总线）并未提供`module_mdio_driver()`宏。在编写驱动程序之前，你应该检查该宏是否存在于设备所在的总线上。以下代码块展示了两个不同总线的示例——一个使用总线提供的注册/反注册宏，另一个则没有使用。我们来看一下不使用宏时的代码：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example does not use the macro at all. Now, let''s look at an
    example that uses the macro:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例完全没有使用宏。现在，让我们来看一个使用宏的示例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, you can see how the code is factorized, which is a serious plus when you're
    writing a driver.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到代码是如何进行因式分解的，这在编写驱动程序时是一个很大的优势。
- en: Exposing the supported devices in the driver
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在驱动程序中暴露支持的设备
- en: The kernel must be aware of the devices that are supported by a given driver
    and whether they are present on the system so that whenever one of them appears
    on the system (the bus), the kernel knows which driver is in charge of it and
    runs its probe function. That said, the `probe()` function of the driver will
    only be run if this driver is loaded (which is a userspace operation); otherwise,
    nothing will happen. The next section will explain how to manage driver auto-loading
    so that when the device appears, its driver is automatically loaded, and its probe
    function is called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 内核必须了解由给定驱动程序支持的设备及其是否存在于系统中，以便当它们出现在系统（总线）上时，内核知道哪个驱动程序负责它，并运行其探测函数。也就是说，驱动程序的`probe()`函数只有在该驱动程序已加载时才会运行（这是用户空间操作）；否则，什么也不会发生。下一节将解释如何管理驱动程序的自动加载，以便当设备出现时，驱动程序会自动加载，并调用其探测函数。
- en: 'If we have a look at each bus-specific device driver structure (`struct platform_driver`,
    `struct i2c_driver`, `struct spi_driver`, `struct pci_driver`, and `struct usb_driver`),
    we will see that there is an `id_table` field whose type depends on the bus type.
    This field should be given an array of device IDs that correspond to those supported
    by the driver. The following table shows the common buses, along with their device
    ID structures:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看每个总线特定的设备驱动程序结构（`struct platform_driver`、`struct i2c_driver`、`struct spi_driver`、`struct
    pci_driver` 和 `struct usb_driver`），我们会看到有一个`id_table`字段，其类型取决于总线类型。该字段应包含与驱动程序支持的设备
    ID 对应的数组。下表展示了常见总线及其设备 ID 结构：
- en: '![Table 6.2 – Some buses, along with their device identification data structures'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 6.2 – 一些总线及其设备识别数据结构'
- en: '](img/B17934_06_Table_2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_06_Table_2.jpg)'
- en: Table 6.2 – Some buses, along with their device identification data structures
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2 – 一些总线及其设备识别数据结构
- en: 'I intentionally omitted two special cases: the device tree and ACPI. They can
    expose devices so that they can be declared either from within the device tree
    or ACPI using the `driver.of_match_table` or `driver.acpi_match_table` fields,
    which are not direct elements of the bus-specific driver structure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意省略了两个特殊情况：设备树和ACPI。它们可以暴露设备，以便可以通过`driver.of_match_table`或`driver.acpi_match_table`字段在设备树或ACPI中声明设备，这些字段并不是总线特定驱动结构的直接元素：
- en: '![Table 6.3 – Pseudo buses, along with their device identification data structures'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![表6.3 – 仿真总线及其设备识别数据结构'
- en: '](img/B17934_06_Table_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_06_Table_3.jpg)'
- en: Table 6.3 – Pseudo buses, along with their device identification data structures
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3 – 仿真总线及其设备识别数据结构
- en: 'These structures are all defined in `include/linux/mod_devicetable.h` in the
    kernel sources, and their names match the `{bus_name}_device_id` pattern. We have
    already discussed each structure in the appropriate chapters. So, let''s look
    at an example that exposes SPI devices using both `struct spi_device_id` and `struct
    of_device_id` for declaring the device tree (new and recommended) of this driver
    ([http://elixir.free-electrons.com/linux/v4.10/source/drivers/gpio/gpio-mcp23s08.c](http://elixir.free-electrons.com/linux/v4.10/source/drivers/gpio/gpio-mcp23s08.c)):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构体都定义在内核源码中的`include/linux/mod_devicetable.h`文件中，它们的名称遵循`{bus_name}_device_id`的模式。我们已经在相应的章节中讨论了每个结构体。因此，让我们来看一个示例，它使用`struct
    spi_device_id`和`struct of_device_id`来声明该驱动的设备树（新的并且推荐的），并暴露SPI设备（[http://elixir.free-electrons.com/linux/v4.10/source/drivers/gpio/gpio-mcp23s08.c](http://elixir.free-electrons.com/linux/v4.10/source/drivers/gpio/gpio-mcp23s08.c)）：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding excerpt shows how a driver can declare the devices it supports.
    Since our example is an SPI driver, the data structure that is involved is `struct
    spi_device_id`, in addition to `struct of_device_id,` which is used in any driver
    that needs to match a device according to their `compatible` string in the driver.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的摘录展示了驱动如何声明它支持的设备。由于我们的示例是SPI驱动，涉及的结构体是`struct spi_device_id`，此外还有`struct
    of_device_id`，它用于任何需要根据驱动中的`compatible`字符串来匹配设备的驱动。
- en: Now that we are done learning the way a driver can expose the device it supports,
    let's get deeper in the device and driver binding mechanism to understand what
    happens under the hood when there is a match between a device and a driver.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了驱动如何暴露它支持的设备，接下来让我们深入了解设备与驱动绑定的机制，理解当设备与驱动匹配时，底层发生了什么。
- en: Device/driver matching and module (auto) loading
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备/驱动匹配和模块（自动）加载
- en: Please pay attention to this section, even though we will partially repeat what
    we discussed previously. The **bus** is the fundamental element that device drivers
    and devices rely on. From a hardware point of view, the bus is the link between
    devices and the CPU, while from a software point of view, the bus driver is the
    link between devices and their drivers. Whenever a device or driver is added/registered
    with the system, it is automatically added to a list that's maintained by the
    driver of the bus that it sits on top of. For example, registering a list of I2C
    devices that can be managed by a given driver (i2c, of course) will result in
    queueing those devices into a global list that maintains the I2C adapter driver,
    as well as providing a USB device table that will insert those devices into the
    list of devices that's maintained by the USB controller driver. Another example
    involves registering a new SPI driver, which will insert this driver into the
    list of drivers that's maintained by the SPI controller driver. Without this,
    there would be no way for the kernel to know which driver should handle which
    device.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这一部分，尽管我们将部分重复之前讨论的内容。**总线**是设备驱动和设备依赖的基本元素。从硬件的角度来看，总线是设备与CPU之间的连接，而从软件的角度来看，总线驱动是设备与其驱动之间的连接。每当设备或驱动被添加/注册到系统时，它会自动被添加到一个由总线驱动维护的列表中。例如，注册一个可以由给定驱动（i2c，当然是）管理的I2C设备列表时，会将这些设备排入一个全局列表，这个列表由I2C适配器驱动维护，并提供一个USB设备表，该表会将这些设备插入到USB控制器驱动维护的设备列表中。另一个例子是注册一个新的SPI驱动，它会将该驱动插入到由SPI控制器驱动维护的驱动列表中。没有这些，内核将无法知道哪个驱动应该处理哪个设备。
- en: Every device driver should expose the list of devices it supports and should
    make that list accessible to the driver core (especially to the bus driver). This
    list of devices is called `id_table` and is declared and filled from within the
    driver code. This table is an array of device IDs, where each ID's type depends
    on the device's type (I2C, SPI, USB, and so on). In this manner, whenever a device
    appears on the bus, the bus driver will walk through its device driver's list
    and look into each ID table for the entry that corresponds to this new device.
    Every driver that contains the device ID in their table will have their `probe()`
    function run, with the new device given as a parameter. This process is called
    the matching loop. It works similarly for drivers. Whenever a new driver is registered
    with the bus, the bus driver will walk through the list of its devices and look
    for the device IDs that appear in the registered driver's `id_table`. For each
    hit, the corresponding device will be given as a parameter to the `probe()` function
    of the driver, which will be run as many times as there are hits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备驱动程序应该暴露它支持的设备列表，并且应该让驱动核心（特别是总线驱动程序）能够访问该列表。这个设备列表叫做`id_table`，它在驱动程序代码中声明并填充。这个表格是一个设备ID的数组，其中每个ID的类型取决于设备的类型（如I2C、SPI、USB等）。通过这种方式，每当设备出现在总线上时，总线驱动程序会遍历其设备驱动程序的列表，并查看每个ID表中的条目，以寻找与新设备对应的条目。所有包含该设备ID的驱动程序的`probe()`函数都会运行，并将新设备作为参数传递。这个过程被称为匹配循环。对于驱动程序，它的工作方式类似。每当一个新的驱动程序被注册到总线时，总线驱动程序会遍历其设备列表，并查找已注册驱动程序的`id_table`中出现的设备ID。对于每次匹配，总线驱动程序都会将相应的设备作为参数传递给驱动程序的`probe()`函数，并根据匹配的次数运行该函数。
- en: 'The problem with the matching loop is that only loaded modules will have their
    probe functions invoked. In other words, the matching loop will be useless if
    the corresponding module is not loaded (`insmod`, `modprobe`) or built-in. You''ll
    have to manually load the module before the device appears on the bus. The solution
    to this issue is module auto-loading. Since, most of the time, module loading
    is a userspace action (when the kernel does not request the module itself using
    the `request_module()` function), the kernel must find a way to expose drivers,
    along with their device tables, to the userspace. Thus came a macro called `MODULE_DEVICE_TABLE()`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配循环的问题在于只有已加载的模块才会调用它们的探测函数。换句话说，如果相应的模块未加载（通过`insmod`、`modprobe`）或是内置的，匹配循环将变得无用。在设备出现在总线之前，您必须手动加载该模块。解决这个问题的方法是模块自动加载。由于大多数情况下，模块加载是用户空间的操作（当内核没有通过`request_module()`函数请求该模块时），因此内核必须找到一种方法，将驱动程序及其设备表暴露给用户空间。因此，出现了一个名为`MODULE_DEVICE_TABLE()`的宏：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This macro is used to support hot-plugging, which describes which devices each
    specific driver can support. At compilation time, the build process extracts this
    information out of the driver and builds a human-readable table called `modules.alias`,
    which is located in the `/lib/modules/kernel_version/` directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏用于支持热插拔，描述了每个特定驱动程序可以支持哪些设备。在编译时，构建过程从驱动程序中提取这些信息，并生成一个可读的表格，名为`modules.alias`，该表格位于`/lib/modules/kernel_version/`目录下。
- en: 'The `<bus_type_name>` parameter should be the generic name of the bus that
    you need to add module auto-loading support to. It should be `spi` for an SPI
    bus, `of` for a device tree, `i2c` for I2C, and so on. In other words, it should
    be one of the elements of the first column (of the **bus type**) of the previous
    table (knowing that not all the buses are listed). Let''s add module auto-loading
    support to the same driver we used previously (gpio-mcp23s08):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`<bus_type_name>`参数应该是需要添加模块自动加载支持的总线的通用名称。对于SPI总线，应该是`spi`；对于设备树，应该是`of`；对于I2C，应该是`i2c`，以此类推。换句话说，它应该是前一个表格中**总线类型**第一列的元素之一（注意，并非所有总线都列出）。让我们为之前使用的相同驱动程序（gpio-mcp23s08）添加模块自动加载支持：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s see what these two lines do when they''re added to the `modules.alias`
    file on an i.MX6-based board running a Yocto-based image:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看将这两行添加到运行基于Yocto的镜像的i.MX6板上的`modules.alias`文件时会发生什么：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second part of the solution is the kernel informing the userspace about
    some events (called `pci:v00008086d000015B8sv*sd*bc*sc*i*`). This event will be
    caught by your system hotplug manager (`module.alias` file while looking for an
    entry with the same alias and load the corresponding module (for example, e1000).
    As soon as the module is loaded, the device will be probed. This is how the simple
    `MODULE_DEVICE_TABLE()` macro can change your life.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Device declaration – populating devices
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Device declaration is not part of the LDM. It consists of declaring devices
    that are present (or not) on the system, while the module device table involves
    feeding the drivers with devices they support. There are three places you can
    declare/populate devices:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: From the board file or in a separate module (older and now deprecated)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **device tree** (the new and recommended method)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the **Advanced Configuration and Power Interface** (**ACPI**), which will
    not be discussed here
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be handled by a driver, any declared device should exist at least in one
    module device table; otherwise, the device will simply be ignored, unless a driver
    with this device ID in its module device table gets loaded or has already been
    loaded.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Bus structure
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, there''s the `struct bus_type` structure, which is the structure that
    the kernel internally represents a bus with (whether it is physical or virtual).
    The `struct bus_type`) is the link between devices (`struct device`) and drivers
    (`struct device_driver`). Without this, nothing would be appended to the system,
    since the bus (`bus_type`) is responsible for matching the devices and drivers:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s look at the elements in this structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the bus''s name as it will appear in `/sys/bus/`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match`: This is a callback that''s called whenever a new device or driver
    is added to the bus. The callback must be smart enough and should return a nonzero
    value when there is a match between a device and a driver. Both are given as parameters.
    The main purpose of a match callback is to allow a bus to determine whether a
    particular device can be handled by a given driver or the other logic if the given
    driver supports a given device. Most of the time, the verification process is
    done with a simple string comparison (the device and driver name, or a table and
    **device tree** (**DT**)-compatible property). For enumerated devices (such as
    PCI and USB), the verification process is done by comparing the device IDs that
    are supported by the driver with the device ID of the given device, without sacrificing
    bus-specific functionality.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`probe`: This is a callback that''s called when a new device or driver is added
    to the bus *and* once a match has occurred. This function is responsible for allocating
    the specific bus device structure and calling the given driver''s probe function,
    which is supposed to manage the device (we allocated this earlier).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This is called when a device is removed from the bus.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the device that you wrote the driver for sits on a physical bus called
    the **bus controller**, it must rely on the driver of that bus, called the **controller
    driver**, which is responsible for sharing bus access between devices. The controller
    driver offers an abstraction layer between your device and the bus. Whenever you
    perform a transaction (read or write) on an I2C or USB bus, for example, the I2C/USB
    bus controller transparently takes care of that in the background (managing the
    clock, shifting data, and so on). Every bus controller driver exports a set of
    functions to ease the development of drivers for the devices sitting on that bus.
    This works for every bus (I2C, SPI, USB, PCI, SDIO, and so on).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个设备编写驱动程序时，如果该设备位于一个名为**总线控制器**的物理总线上，它必须依赖该总线的驱动程序，该驱动程序被称为**控制器驱动程序**，它负责在设备之间共享总线访问权限。控制器驱动程序提供了一个抽象层，位于你的设备和总线之间。每当你在I2C或USB总线上执行事务（读取或写入）时，I2C/USB总线控制器将在后台透明地处理这些事务（管理时钟、数据移位等）。每个总线控制器驱动都会导出一组函数，以简化为位于该总线上的设备编写驱动程序的工作。这适用于每种总线（I2C、SPI、USB、PCI、SDIO等）。
- en: Now that we have looked at the bus driver and how modules are loaded, we will
    discuss the matching mechanism, which tries to bind a particular device to its
    drivers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了总线驱动程序以及模块如何加载，我们将讨论匹配机制，它尝试将特定设备绑定到其驱动程序。
- en: Device and driver matching mechanism explained
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备与驱动匹配机制说明
- en: Device drivers and devices are always registered with the bus. When it comes
    to exporting the devices that are supported by the driver, you can use `driver.of_match_table`,
    `driver.of_match_table`, or `<bus>_driver.id_table` (which is specific to the
    device type; for example, `i2c_device.id_table` or `platform_device.id_table`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动和设备总是与总线一起注册。对于导出由驱动程序支持的设备，您可以使用`driver.of_match_table`、`driver.of_match_table`或`<bus>_driver.id_table`（该表特定于设备类型；例如，`i2c_device.id_table`或`platform_device.id_table`）。
- en: 'Each bus driver has the responsibility of providing its match function, which
    is run by the kernel whenever a new device or device driver is registered with
    this bus. That said, there are three matching mechanisms for platform devices,
    all of which consist of string comparison. Those matching mechanisms are based
    on the DT table, ACPI table, device, and driver name. Let''s see how the pseudo-platform
    and i2c buses implement their matching functions using those mechanisms:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个总线驱动都负责提供其匹配函数，每当有新的设备或设备驱动程序注册到该总线时，内核会运行该函数。也就是说，平台设备有三种匹配机制，所有这些机制都基于字符串比较。这些匹配机制分别基于DT表、ACPI表、设备和驱动程序名称。让我们看看伪平台和i2c总线是如何使用这些机制实现匹配函数的：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code shows the `drivers/base/platform.c`. The following code
    shows the I2C bus matching function, which is defined in `drivers/i2c/i2c-core.c`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了`drivers/base/platform.c`。下面的代码展示了I2C总线匹配函数，该函数在`drivers/i2c/i2c-core.c`中定义：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Case study – the OF matching mechanism
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究 – OF匹配机制
- en: 'In the device tree, each device is represented by a node and declared as a
    child of its bus node. At boot time, the kernel (the **OF** core) parses every
    bus node (as well as their sub-nodes, which are the devices that are sitting on
    it) in the device tree. For each device node, the kernel will do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备树中，每个设备都由一个节点表示，并声明为其总线节点的子节点。在启动时，内核（**OF**核心）解析设备树中的每个总线节点（以及它们的子节点，即坐落在其上的设备）。对于每个设备节点，内核将执行以下操作：
- en: Identify the bus that this node belongs to.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定该节点所属的总线。
- en: Allocate a platform device and initialize it according to the properties contained
    in the node using the `of_device_alloc()` function. `built_pdev->dev.of_node`
    will be set with the current device tree node.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配一个平台设备，并使用`of_device_alloc()`函数根据节点中包含的属性进行初始化。`built_pdev->dev.of_node`将设置为当前设备树节点。
- en: Walk through the list of device drivers associated with (maintained by) the
    previously identified bus using the `bus_for_each_drv()` function.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bus_for_each_drv()`函数遍历与之前识别的总线相关的（由其维护的）设备驱动列表。
- en: 'For each driver in the list, the core will do the following:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表中的每个驱动，核心将执行以下操作：
- en: Call the bus match function, given as the parameter that the driver found and
    the previously built device structure; that is, `bus_found->match(cur_drv, cur_dev);`.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用总线匹配函数，传入作为参数的已找到的驱动程序和先前构建的设备结构；即`bus_found->match(cur_drv, cur_dev);`。
- en: If the DT matching mechanism is supported by this bus driver, the bus match
    function will then call `of_driver_match_device()`, given the same parameters
    that were mentioned previously; that is, `of_driver_match_device(ur_drv, cur_dev)`.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`of_driver_match_device` will walk through the `of_match_table` table (which
    is an array of struct `of_device_id` elements) that''s associated with the current
    driver. For each `of_device_id` in the array, the kernel will compare the compatible
    property of both the current `of_device_id` element and `built_pdev->dev.of_node`.
    If they are the same (let''s say that there''s a match), the probe function of
    the current driver will be run.'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If no driver that supports this device is found, this device will be registered
    with the bus anyway. Then, the probing mechanism will be deferred to a later date
    so that whenever a new driver is registered with this bus, the core will walk
    through the list of devices that are maintained by the bus; any devices without
    any drivers associated with them will be probed again. For each, the compatible
    property of associated `of_node` will be compared to the compatible property of
    each `of_device_id` in the `of_match_table` array that's associated with the freshly
    registered driver.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how drivers are matched with devices that are declared from within the
    device tree. This works in the same manner for each type of device declaration
    (board file, ACPI, and so on).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deal with devices and drivers, as well as
    how they are tied to each other. We have also demystified the matching mechanism.
    Make sure you understand this before moving on to [*Chapter 7*](B17934_07_Epub.xhtml#_idTextAnchor105),
    *Understanding the Concept of Platform Devices and Drivers*, [*Chapter 8*](B17934_08_Epub.xhtml#_idTextAnchor117),
    *Writing I2C Device Drivers*, and [*Chapter 9*](B17934_09_Epub.xhtml#_idTextAnchor130),
    *Writing SPI Device Drivers* , which will deal with device driver development.
    This will involve working with devices, drivers, and bus structures.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into *platform driver development* in detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
