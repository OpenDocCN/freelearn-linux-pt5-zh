- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Networking with Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 Linux 的网络连接
- en: '**Linux networking** is a vast domain. The last few decades have seen countless
    volumes and references written about Linux network administration internals. Sometimes,
    the mere assimilation of essential concepts can be overwhelming for both novice
    and advanced users. This chapter provides a relatively concise overview of Linux
    networking, focusing on network communication layers, sockets and ports, network
    services and protocols, and network security.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux 网络**是一个广阔的领域。在过去几十年里，关于 Linux 网络管理内部机制的书籍和参考资料数不胜数。有时，仅仅是理解基本概念，对初学者和高级用户来说都会感到不小的压力。本章提供了一个相对简洁的
    Linux 网络概述，重点介绍网络通信层、套接字和端口、网络服务和协议以及网络安全。'
- en: We hope that the content presented in this chapter is both a comfortable introduction
    to basic Linux networking principles for a novice user and a good refresher for
    an advanced Linux administrator.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望本章内容既能为初学者提供一个舒适的 Linux 网络基本概念入门，也能为高级 Linux 管理员提供一个很好的复习资料。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring basic networking – focusing on computer networks, networking models,
    protocols, network addresses, and ports. We’ll also cover some practical aspects
    of configuring Linux network settings using the command-line Terminal.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索基础网络——重点介绍计算机网络、网络模型、协议、网络地址和端口。我们还将介绍一些使用命令行终端配置 Linux 网络设置的实际操作。
- en: Working with network services – introducing common networking servers that run
    on Linux.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络服务——介绍在 Linux 上运行的常见网络服务器。
- en: Understanding network security.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络安全。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we’ll be using the Linux command line to some extent.
    A working Linux distribution, installed on either a **virtual machine** (**VM**)
    or a desktop platform, is highly recommended. If you don’t have one already, go
    back to [*Chapter 1*](B19682_01.xhtml#_idTextAnchor030), *Installing Linux*, which
    will guide you through the installation process. Most of the commands and examples
    illustrated in this chapter use Ubuntu and Fedora, but the same would apply to
    any other Linux platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将一定程度上使用 Linux 命令行。建议安装一个工作中的 Linux 发行版，可以是在 **虚拟机**（**VM**）或桌面平台上。如果你还没有安装，请返回到[*第
    1 章*](B19682_01.xhtml#_idTextAnchor030)，*安装 Linux*，它将引导你完成安装过程。本章中大多数命令和示例使用的是
    Ubuntu 和 Fedora，但同样适用于其他任何 Linux 平台。
- en: Exploring basic networking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索基础网络
- en: Today, it’s almost inconceivable to imagine a computer not connected to some
    sort of network or the internet. Our ever-increasing online presence, cloud computing,
    mobile communications, and **Internet of Things** (**IoT**) would not be possible
    without the highly distributed, high-speed, and scalable networks serving the
    underlying data traffic; yet the basic networking principles behind the driving
    force of the modern-day internet are decades old. Networking and communication
    paradigms will continue to evolve, but some of the original primitives and concepts
    will still have a long-lasting effect in shaping the building blocks of future
    communications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，几乎无法想象一台没有连接到某种网络或互联网的计算机。我们的日益增长的在线存在、云计算、移动通信和 **物联网**（**IoT**）都离不开为底层数据流量提供服务的高度分布式、高速、可扩展的网络；然而，现代互联网背后的基本网络原理已有几十年历史。网络和通信范式将继续发展，但一些原始的基础元素和概念仍将对塑造未来通信的基石产生持久影响。
- en: This section will introduce you to a few of these networking essentials and,
    hopefully, spark your curiosity for further exploration. Let’s start with computer
    networks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍其中的一些网络基础知识，并希望能激发你进一步探索的兴趣。让我们从计算机网络开始。
- en: Computer networks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算机网络
- en: A **computer network** is a group of two or more computers (or nodes) connected
    via a physical medium (cable, wireless, optical) and communicating with each other
    using a standard set of agreed-upon communication protocols. At a very high level,
    a **network communication infrastructure** includes computers, devices, switches,
    routers, Ethernet or optical cables, wireless environments, and all sorts of network
    equipment.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算机网络**是指通过物理介质（电缆、无线、光纤）连接的两台或更多计算机（或节点），并通过标准的协议集进行相互通信。从宏观角度看，**网络通信基础设施**包括计算机、设备、交换机、路由器、以太网或光纤电缆、无线环境以及各种网络设备。'
- en: Beyond the *physical* connectivity and arrangement, networks are also defined
    by a *logical* layout via network topologies, tiers, and the related data flow.
    An example of a logical networking hierarchy is the three-tiered layering of the
    **demilitarized zone** (**DMZ**), *firewall*, and *internal* networks. The DMZ
    is an organization’s outward-facing network, with an extra security layer against
    the public internet. A firewall controls the network traffic between the DMZ and
    the internal network.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*物理*连接和布置外，网络还通过网络拓扑、层级和相关的数据流定义了*逻辑*布局。一个逻辑网络层次结构的例子是**非军事区**（**DMZ**）、*防火墙*和*内部*网络的三层结构。DMZ是组织面向外部的网络，具有额外的安全层来防御公共互联网。防火墙控制着DMZ与内部网络之间的网络流量。
- en: 'Network devices are identified by the following aspects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备的标识由以下几个方面决定：
- en: '**Network addresses**: These assist with locating nodes on the network using
    **communication protocols**, such as the **Internet Protocol** (**IP**) (see more
    on IP in the *TCP/IP protocols* section, later in this chapter)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络地址**：这些有助于通过**通信协议**定位网络上的节点，例如**互联网协议**（**IP**）（有关IP的更多内容，请参见本章后面的*TCP/IP协议*部分）'
- en: '**Hostnames**: These are user-friendly labels associated with devices that
    are easier to remember than network addresses'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机名**：这些是与设备相关的用户友好的标签，比网络地址更容易记住'
- en: 'A common classification criterion looks at the *scale* and *expansion* of computer
    networks. Let’s introduce you to **local area networks** (**LANs**) and **wide
    area** **networks** (**WANs**):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的分类标准是考虑计算机网络的*规模*和*扩展*。让我们来介绍一下**局域网**（**LANs**）和**广域网**（**WANs**）：
- en: '**LANs**: A LAN represents a group of devices connected and located in a single
    physical location, such as a private residence, school, or office. A LAN can be
    of any size, ranging from a home network with only a few devices to large-scale
    enterprise networks with thousands of users and computers.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局域网**（**LANs**）：LAN表示一组连接并位于单一物理位置的设备，例如私人住宅、学校或办公室。LAN可以是任何规模，从只有少数设备的家庭网络，到拥有成千上万用户和计算机的大型企业网络。'
- en: Regardless of the network’s size, a LAN’s essential characteristic is that it
    connects devices in a single, limited area. Examples of LANs include the home
    network of a single-family residence or your local coffee shop’s free wireless
    service.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论网络的规模如何，LAN的基本特征是它将设备连接在一个有限的区域内。LAN的例子包括单户住宅的家庭网络或你所在的咖啡店的免费无线服务。
- en: For more information about LANs, you can refer to [https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html](https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html).
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于LAN的更多信息，请参见[https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html](https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html)。
- en: When a computer network spans multiple regions or multiple interconnected LANs,
    WANs come into play.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当计算机网络跨越多个区域或多个互联的LAN时，WAN开始发挥作用。
- en: '**WANs**: A WAN is usually a network of networks, with multiple or distributed
    LANs communicating with each other. In this sense, we regard the internet as the
    world’s largest WAN. An example of a WAN is the computer network of a multinational
    company’s geographically distributed offices worldwide. Some WANs are built by
    service providers, to be leased to various businesses and institutions around
    the world.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广域网**（**WANs**）：WAN通常是一个由多个或分布式的局域网（LAN）相互通信的网络。从这个角度看，我们可以将互联网视为全球最大的WAN。WAN的一个例子是跨国公司在全球各地地理分布的办公地点的计算机网络。有些WAN是由服务提供商构建的，供全球各地的企业和机构租用。'
- en: WANs have several variations, depending on their type, range, and use. Typical
    examples of WANs include **personal area networks** (**PANs**), **metropolitan
    area networks** (**MANs**), and **cloud** or **internet area** **networks** (**IANs**).
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: WAN有几种变体，具体取决于它们的类型、范围和用途。WAN的典型例子包括**个人区域网络**（**PANs**）、**城市区域网络**（**MANs**）和**云**或**互联网区域****网络**（**IANs**）。
- en: For more information about WANs, you can refer to [https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html](https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html).
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于WAN的更多信息，请参见[https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html](https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html)。
- en: We think that an adequate introduction to basic networking principles should
    always include a brief presentation of the theoretical model governing network
    communications in general. We’ll look at this next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为，对于基础网络原理的适当介绍应当包括简要介绍支配网络通信的理论模型。接下来，我们将讨论这一点。
- en: The OSI model
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSI模型
- en: The **Open Systems Interconnection** (**OSI**) model is a theoretical representation
    of a multilayer communication mechanism between computer systems interacting over
    a network. The OSI model was introduced in 1983 by the **International Organization
    for Standardization** (**ISO**) to provide a standard for different computer systems
    to communicate with each other.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**开放系统互联**（**OSI**）模型是一个理论性的表示，描述了计算机系统之间通过网络进行多层次通信的机制。OSI模型于1983年由**国际标准化组织**（**ISO**）提出，旨在为不同计算机系统之间的通信提供标准。'
- en: 'We can regard the OSI model as a universal framework for network communications.
    As the following figure shows, the OSI model defines a stack of seven layers,
    directing the communication flow:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将OSI模型视为网络通信的通用框架。如以下图所示，OSI模型定义了七层协议栈，指引着通信流的方向：
- en: '![Figure 7.1 – The OSI model](img/B19682_07_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – OSI模型](img/B19682_07_01.jpg)'
- en: Figure 7.1 – The OSI model
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – OSI模型
- en: In the layered view shown in the preceding figure, the communication flow moves
    from top to bottom (on the transmitting end) or bottom to top (on the receiving
    end). Before we look at each layer in more detail, let’s briefly explain how the
    OSI model and data encapsulation and decapsulation work.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图所示的分层视图中，通信流从上至下（在发送端）或从下至上（在接收端）移动。在详细查看每一层之前，我们先简要解释一下OSI模型以及数据封装和解封装的工作原理。
- en: Data encapsulation and decapsulation in the OSI model
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OSI模型中的数据封装和解封装
- en: 'When using the network to transfer data from one computer to another, some
    specific rules are followed. Inside the OSI model, the network data flows in two
    different ways. One way is down, from Layer 7 to Layer 1, and this is known as
    **data encapsulation**. The other way, up from Layer 1 to Layer 7, is known as
    **data decapsulation**. Data encapsulation represents the process of sending data
    from one computer to another, while data decapsulation represents the process
    of receiving data. Let’s look at these in greater detail:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用网络将数据从一台计算机传输到另一台计算机时，需要遵循一些特定的规则。在OSI模型中，网络数据流有两种不同的传输方式。一种是从第7层到第1层的下行传输，这被称为**数据封装**。另一种是从第1层到第7层的上行传输，这被称为**数据解封装**。数据封装表示从一台计算机向另一台计算机发送数据的过程，而数据解封装表示接收数据的过程。让我们更详细地了解这些过程：
- en: '**Encapsulation**: When sending data, data from one computer is converted to
    be sent through the network, and it receives extra information as it is being
    sent though all the layers of the stack. The application layer (Layer 7) is the
    place where the user directly interacts with the application. Then, data is sent
    through the presentation (Layer 6) and session (Layer 5) layers, where data is
    transformed into a usable format. In the transport layer (Layer 4), data is broken
    into smaller chunks (segments) and receives a new TCP header. Inside the network
    layer (Layer 3), the data is called a packet, receives an IP header, and is sent
    to the data link layer (Layer 2), where it is called a frame and contains both
    TCP and IP headers. At Layer 2, each frame receives information about the hardware
    addresses of the source and destination (**media access control** (**MAC**) addresses)
    and information about the protocols to be used in the network layer (created by
    the **logical link control** (**LLC**) data communication protocol). At this point,
    a new field is added, called **Frame Check Sequence** (**FCS**), which is used
    for checking errors. Then, the frames are passed through the physical layer (Layer
    1).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：在发送数据时，来自一台计算机的数据会被转换为可以通过网络发送的格式，并且在经过协议栈的每一层时，数据会附加额外的信息。应用层（第7层）是用户直接与应用程序交互的地方。接着，数据会通过表示层（第6层）和会话层（第5层），在这些层中，数据被转化为可用的格式。在传输层（第4层），数据被分割成较小的块（段），并获得一个新的TCP头部。在网络层（第3层），数据被称为数据包，获得一个IP头部，并被发送到数据链路层（第2层），在此它被称为帧，并包含TCP和IP头部。在第2层，每个帧都会接收到源地址和目的地址的硬件信息（**媒体访问控制**（**MAC**）地址），以及网络层中将要使用的协议的信息（由**逻辑链路控制**（**LLC**）数据通信协议创建）。此时，添加了一个新的字段，称为**帧校验序列**（**FCS**），用于检查错误。接着，帧会被传递到物理层（第1层）。'
- en: '**Decapsulation**: When data is received, the process is identical, but in
    reverse order. This starts from the physical layer (Layer 1), where the first
    synchronization happens, after which the frame is sent through the data link layer
    (Layer 2), where an error check is done, by verifying the FCS field. This process
    is called a **Cyclic Redundancy Check** (**CRC**). The data, which is now a packet,
    is sent through all the other layers. Here, the headers that were added during
    the encapsulation process are stripped off until they reach the upper layers and
    become ready to be used on the target computer. A graphic explanation is provided
    in the following figure:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**去封装**：当数据接收时，过程是相同的，但顺序是相反的。从物理层（第一层）开始，首先发生同步，然后帧通过数据链路层（第二层），在那里进行错误检查，通过验证FCS字段。这一过程称为**循环冗余检查**（**CRC**）。现在是数据包的数据，经过所有其他层。此时，在封装过程中添加的头信息被去除，直到它们到达上层并准备在目标计算机上使用。以下图形提供了详细的解释：'
- en: '![Figure 7.2 – Encapsulation and decapsulation in the OSI model](img/B19682_07_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – OSI 模型中的封装与去封装](img/B19682_07_02.jpg)'
- en: Figure 7.2 – Encapsulation and decapsulation in the OSI model
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – OSI 模型中的封装与去封装
- en: Let’s look at each of these layers in detail and describe their functionality
    in shaping network communication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下这些层，并描述它们在塑造网络通信中的功能。
- en: The physical layer
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理层
- en: The **physical layer** (or *Layer 1*) consists of the networking equipment or
    infrastructure connecting the devices and serving the communication, such as cables,
    wireless or optical environments, connectors, and switches. This layer handles
    the conversion between raw bit streams and the communication medium (which includes
    electrical, radio, or optical signals) while regulating the corresponding bit-rate
    control.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理层**（或*第一层*）由连接设备并提供通信服务的网络设备或基础设施组成，例如电缆、无线或光学环境、连接器和交换机。该层处理原始比特流与通信媒介（包括电信号、无线电信号或光学信号）之间的转换，同时调节相应的比特率控制。'
- en: Examples of protocols operating at the physical layer include Ethernet, **Universal
    Serial Bus** (**USB**), and **Digital Subscriber** **Line** (**DSL**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理层上运行的协议示例包括以太网、**Universal Serial Bus**（**USB**）和**数字用户线**（**DSL**）。
- en: The data link layer
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据链路层
- en: 'The **data link layer** (or *Layer 2*) establishes a reliable data flow between
    two directly connected devices on a network, either as adjacent nodes in a WAN
    or as devices within a LAN. One of the data link layer’s responsibilities is flow
    control, adapting to the physical layer’s communication speed. On the receiving
    device, the data link layer corrects communication errors that originated in the
    physical layer. The data link layer consists of the following subsystems:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据链路层**（或*第二层*）在网络中建立两个直接连接设备之间可靠的数据流，无论是作为广域网中的相邻节点，还是局域网中的设备。数据链路层的责任之一是流量控制，适应物理层的通信速度。在接收设备上，数据链路层修正源自物理层的通信错误。数据链路层由以下子系统组成：'
- en: '**Media access control** (**MAC**): This subsystem uses MAC addresses to identify
    and connect devices on the network. It also controls the device access permissions
    to transmit and receive data on the network.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体访问控制**（**MAC**）：此子系统使用MAC地址来标识和连接网络中的设备。它还控制设备访问权限，以在网络上传输和接收数据。'
- en: '**Logical link control** (**LLC**): This subsystem identifies and encapsulates
    network layer protocols and performs error checking and frame synchronization
    while transmitting or receiving data.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑链路控制**（**LLC**）：该子系统识别并封装网络层协议，并在传输或接收数据时执行错误检查和帧同步。'
- en: The protocol data units controlled by the data link layer are also known as
    **frames**. A frame is a data transmission unit that acts as a container for a
    single network packet. Network packets are processed at the next OSI level (*network
    layer*). When multiple devices access the same physical layer simultaneously,
    frame collisions may occur. Data link layer protocols can detect and recover from
    such collisions and further reduce or prevent their occurrence.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层控制的协议数据单元也被称为**帧**。帧是数据传输单元，充当单个网络数据包的容器。网络数据包在下一个OSI层（*网络层*）中被处理。当多个设备同时访问同一物理层时，可能会发生帧碰撞。数据链路层协议可以检测并恢复此类碰撞，并进一步减少或防止它们的发生。
- en: There are also Ethernet frames, for example, which are encapsulated data that
    is defined for MAC implementations. The original IEEE 802.3 Ethernet format, the
    802.3 **SubNetwork Access Protocol** (**SNAP**), and the Ethernet II (extended)
    frame formats are also available.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，还有以太网帧，这些是为 MAC 实现定义的封装数据。原始的 IEEE 802.3 以太网格式、802.3 **子网络访问协议** (**SNAP**)
    和以太网 II（扩展）帧格式也可用。
- en: One more example of the data link protocol is the **Point-to-Point Protocol**
    (**PPP**), a binary networking protocol that’s used in high-speed broadband communication
    networks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个数据链路协议的例子是 **点对点协议** (**PPP**)，这是一种用于高速宽带通信网络的二进制网络协议。
- en: The network layer
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: The **network layer** (or *Layer 3*) discovers the optimal communication path
    (or route) between devices on a network. This layer uses a routing mechanism based
    on the IPaddresses of the devices involved in the data exchange to move data packets
    from source to destination.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络层**（或 *第3层*）发现网络上设备之间的最佳通信路径（或路由）。该层使用基于参与数据交换设备 IP 地址的路由机制，将数据包从源端传送到目标端。'
- en: On the transmitting end, the network layer disassembles the data segments that
    originated in the *transport layer* into network packets. On the receiving end,
    the data frames are reassembled from the layer below (*data link layer*) into
    packets.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送端，网络层将源自 *传输层* 的数据段拆分成网络包。在接收端，数据帧从下层（*数据链路层*）重新组装成数据包。
- en: A protocol that operates at the network layer is the **Internet Control Message
    Protocol** (**ICMP**). ICMP is used by network devices to diagnose network communication
    issues. ICMP reports an error when a requested endpoint is not available by sending
    messages such as *destination network unreachable*, *timer expired*, *source route
    failed*, and others.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在网络层运行的协议是 **互联网控制消息协议** (**ICMP**)。ICMP 被网络设备用于诊断网络通信问题。当请求的端点不可用时，ICMP 会通过发送诸如
    *目标网络不可达*、*定时器过期*、*源路由失败* 等消息来报告错误。
- en: The transport layer
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: The **transport layer** (or *Layer 4*) operates with **data segments** or **datagrams**.
    This layer is mainly responsible for transferring data from a source to a destination
    and guaranteeing a specific **quality of service** (**QoS**). On the transmitting
    end, data that originated from the layer above (*session layer*) is disassembled
    into segments. On the receiving end, the transport layer reassembles the data
    packets received from the layer below (*network layer*) into segments.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层**（或 *第4层*）处理 **数据段** 或 **数据报**。该层主要负责将数据从源传输到目标，并保证特定的 **服务质量** (**QoS**)。在发送端，来自上层（*会话层*）的数据被拆分成数据段；在接收端，传输层将从下层（*网络层*）接收到的数据包重新组装成数据段。'
- en: The transport layer maintains the reliability of the data transfer through flow-control
    and error-control functions. The flow-control function adjusts the data transfer
    rate between endpoints with different connection speeds, to avoid a sender overwhelming
    the receiver. When the data received is incorrect, the error-control function
    may request the retransmission of data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层通过流量控制和错误控制功能保持数据传输的可靠性。流量控制功能调整具有不同连接速度的端点之间的数据传输速率，以避免发送方压倒接收方。当接收到的数据不正确时，错误控制功能可能会请求数据重传。
- en: Examples of transport layer protocols include the **Transmission Control Protocol**
    (**TCP**) and the **User Datagram** **Protocol** (**UDP**).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层协议的例子包括 **传输控制协议** (**TCP**) 和 **用户数据报协议** (**UDP**).
- en: The session layer
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话层
- en: The **session layer** (or *Layer 5*) controls the lifetime of the connection
    channels (or sessions) between devices communicating on a network. At this layer,
    sessions or network connections are usually defined by network addresses, sockets,
    and ports. We’ll explain each of these concepts in the *Sockets and ports* and
    *IP addresses* sections. The session layer is responsible for the integrity of
    the data transfer within a communication channel or session. For example, if a
    session is interrupted, the data transfer resumes from a previous checkpoint.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话层**（或 *第5层*）控制设备间通信连接通道（或会话）的生命周期。在这一层，会话或网络连接通常由网络地址、套接字和端口定义。我们将在 *套接字和端口*
    以及 *IP地址* 部分解释这些概念。会话层负责通信通道或会话内数据传输的完整性。例如，如果会话被中断，数据传输会从先前的检查点恢复。'
- en: Some typical session layer protocols are the **Remote Procedure Call** (**RPC**)
    protocol, which is used by interprocess communications, and **Network Basic Input/Output
    System** (**NetBIOS**), which is a file-sharing and name-resolution protocol.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些典型的会话层协议包括**远程过程调用**（**RPC**）协议，通常用于进程间通信，以及**网络基础输入输出系统**（**NetBIOS**），这是一个文件共享和名称解析协议。
- en: The presentation layer
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表示层
- en: The **presentation layer** (or *Layer 6*) acts as a data translation tier between
    the *application layer* above and the *session layer* below. On the transmitting
    end, this layer formats the data into a system-independent representation before
    sending it across the network. On the receiving end, the presentation layer transforms
    the data into an application-friendly format. Examples of such transformations
    are encryption and decryption, compression and decompression, encoding and decoding,
    and serialization and deserialization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示层**（或*第六层*）充当*应用层*和*会话层*之间的数据转换层。在发送端，这一层会将数据格式化为独立于系统的表示形式，然后发送到网络上。在接收端，表示层将数据转化为适合应用的格式。此类转换的例子包括加密与解密、压缩与解压缩、编码与解码，以及序列化与反序列化。'
- en: Usually, there is no substantial distinction between the presentation and application
    layers, mainly due to the relatively tight coupling of the various data formats
    with the applications consuming them. Standard data representation formats include
    the **American Standard Code for Information Interchange** (**ASCII**), **Extensible
    Markup Language** (**XML**), **JavaScript Object Notation** (**JSON**), **Joint
    Photographic Experts Group** (**JPEG**), ZIP, and others.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，表示层和应用层之间没有实质性的区别，主要是由于各种数据格式与其使用应用之间的相对紧密耦合。标准数据表示格式包括**美国信息交换标准代码**（**ASCII**）、**可扩展标记语言**（**XML**）、**JavaScript
    对象表示法**（**JSON**）、**联合图像专家组**（**JPEG**）、ZIP等。
- en: The application layer
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: The **application layer** (or *Layer 7*) is the closest to the end user in the
    OSI model. This layer collects or provides the input or output of application
    data in some meaningful way. This layer does not contain or run the applications
    themselves. Instead, it acts as an abstraction between applications, implementing
    a communication component and the underlying network. Typical examples of applications
    that interact with the application layer are web browsers and email clients.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用层**（或*第七层*）是离 OSI 模型中最终用户最近的一层。该层以某种有意义的方式收集或提供应用数据的输入或输出。该层并不包含或运行应用程序本身。相反，它充当应用程序、实现通信组件与底层网络之间的抽象。与应用层交互的典型应用程序包括网页浏览器和电子邮件客户端。'
- en: A few examples of Layer 7 protocols are the DNS protocol, the **HyperText Transfer
    Protocol** (**HTTP**), the **File Transfer Protocol** (**FTP**), and email messaging
    protocols, such as the **Post Office Protocol** (**POP**), **Internet Message
    Access Protocol** (**IMAP**), and **Simple Mail Transfer** **Protocol** (**SMTP**).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第七层协议的几个例子包括 DNS 协议、**超文本传输协议**（**HTTP**）、**文件传输协议**（**FTP**）以及电子邮件消息协议，如**邮局协议**（**POP**）、**互联网消息访问协议**（**IMAP**）和**简单邮件传输协议**（**SMTP**）。
- en: Before wrapping up, we should note that the OSI model is a generic representation
    of networking communication layers and provides the theoretical guidelines for
    how network communication works. A similar – but more practical – illustration
    of the networking stack is the TCP/IP model. Both these models are useful when
    it comes to network design, implementation, troubleshooting, and diagnostics.
    The OSI model gives network operators a good understanding of the full networking
    stack, from the physical medium to the application layer, and each level has **Protocol
    Data Units** (**PDUs**) and communication internals. However, the TCP/IP model
    is somewhat simplified, with a few of the OSI model layers collapsed into one,
    and it takes a rather protocol-centric approach to network communications. We’ll
    explore this in more detail in the next section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，我们需要注意，OSI 模型是一个通用的网络通信层次模型，并为网络通信的工作原理提供了理论指导。类似的，但更具实际应用的网络协议栈模型是 TCP/IP
    模型。这两种模型在网络设计、实现、故障排除和诊断方面都非常有用。OSI 模型使网络操作员能够很好地理解完整的网络协议栈，从物理媒介到应用层，每一层都有**协议数据单元**（**PDU**）和通信内部结构。然而，TCP/IP
    模型相对简化，将一些 OSI 模型的层次合并为一层，并且采用了一种更为以协议为中心的网络通信方式。我们将在下一节中详细探讨这一点。
- en: The TCP/IP network stack model
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP 网络协议栈模型
- en: 'The **TCP/IP model** is a four-layer interpretation of the OSI networking stack,
    where some of the equivalent OSI layers appear consolidated, as shown in the following
    figure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP/IP 模型**是对 OSI 网络堆栈的四层解释，其中一些等效的 OSI 层被合并，如下图所示：'
- en: '![Figure 7.3 – The OSI and TCP/IP models](img/B19682_07_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – OSI 和 TCP/IP 模型](img/B19682_07_03.jpg)'
- en: Figure 7.3 – The OSI and TCP/IP models
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – OSI 和 TCP/IP 模型
- en: Chronologically, the TCP/IP model is older than the OSI model. It was first
    suggested by the US **Department of Defense** (**DoD**) as part of an internetwork
    project developed by the **Defense Advanced Research Projects Agency** (**DARPA**).
    This project eventually became the modern-day internet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按时间顺序，TCP/IP 模型比 OSI 模型更早。它最初由美国 **国防部**（**DoD**）提出，作为由 **国防高级研究计划局**（**DARPA**）开发的一个互联网络项目的一部分。这个项目最终成为了现代互联网的雏形。
- en: The TCP/IP model layers encapsulate similar functions to their counterpart OSI
    layers. Here’s a summary of each layer in the TCP/IP model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP 模型的各个层次封装了与其对应的 OSI 层相似的功能。以下是 TCP/IP 模型中各层的总结。
- en: The network interface layer
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络接口层
- en: The **network interface layer** is responsible for data delivery over a physical
    medium (such as wire, wireless, or optical). Networking protocols operating at
    this layer include Ethernet, Token Ring, and Frame Relay. This layer maps to the
    composition of the *physical and data link layers* in the OSI model.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络接口层**负责通过物理介质（如电缆、无线或光纤）传输数据。该层操作的网络协议包括以太网、令牌环和帧中继。该层对应于 OSI 模型中的 *物理层和数据链路层*
    的组合。'
- en: The internet layer
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络层
- en: The **internet layer** provides *connectionless* data delivery between nodes
    on a network. Connectionless protocols describe a network communication pattern
    where a sender transmits data to a receiver without a prior arrangement between
    the two. This layer is responsible for disassembling data into network packets
    at the transmitting end and reassembling them on the receiving end. The internet
    layer uses routing functions to identify the optimal path between the network
    nodes. This layer maps to the *network layer* in the OSI model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络层**提供 *无连接* 的数据传输服务，允许网络节点之间进行数据交换。无连接协议描述了一种网络通信模式，其中发送方将数据传输给接收方，而无需双方事先建立连接。该层负责在发送端将数据拆解为网络数据包，并在接收端将其重新组装。网络层通过路由功能来识别网络节点之间的最佳路径。该层与
    OSI 模型中的 *网络层* 对应。'
- en: The transport layer
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传输层
- en: The **transport layer** (also known as the **transmission layer** or the **host-to-host
    layer**) is responsible for maintaining the communication sessions between connected
    network nodes. The transport layer implements error-detection and correction mechanisms
    for reliable data delivery between endpoints. This layer maps to the *transport
    layer* in the OSI model.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层**（也称为 **传输层** 或 **主机到主机层**）负责保持连接网络节点之间的通信会话。传输层实现了错误检测和修正机制，以确保端点之间可靠的数据传输。该层与
    OSI 模型中的 *传输层* 相对应。'
- en: The application layer
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用层
- en: The **application layer** provides the data communication abstraction between
    software applications and the underlying network. This layer maps to the composition
    of the *session, presentation, and application layers* in the OSI model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用层**提供了软件应用程序与底层网络之间的数据通信抽象。该层对应于 OSI 模型中的 *会话层、表示层和应用层* 的组合。'
- en: As discussed earlier in this chapter, the TCP/IP model is a protocol-centric
    representation of the networking stack. This model served as the foundation of
    the internet by gradually defining and developing networking protocols required
    for internet communications. These protocols are collectively referred to as the
    *IP suite*. The following section describes some of the most common networking
    protocols.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，TCP/IP 模型是一个以协议为中心的网络堆栈表示模型。该模型通过逐步定义和开发用于互联网通信的网络协议，为互联网奠定了基础。这些协议统称为
    *IP 套件*。以下部分描述了一些最常见的网络协议。
- en: TCP/IP protocols
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP/IP 协议
- en: In this section, we’ll describe some widely used networking protocols. The reference
    provided here should not be regarded as an all-encompassing guide. There are a
    vast number of TCP/IP protocols, and a comprehensive study is beyond the scope
    of this chapter. Nevertheless, there are a handful of protocols worth exploring,
    frequently at work in everyday network communication and administration workflows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述一些广泛使用的网络协议。这里提供的参考内容不应被视为全面的指南。TCP/IP协议数量庞大，全面研究超出了本章的范围。然而，有一些值得探索的协议，它们在日常网络通信和管理工作流中经常被使用。
- en: 'The following list briefly describes each TCP/IP protocol and its related **Request
    for Comments** (**RFC**) identifier. The RFC represents the detailed technical
    documentation – of a protocol, in our case – that’s usually authored by the **Internet
    Engineering Task Force** (**IETF**). For more information about RFC, please refer
    to [https://www.ietf.org/standards/rfcs/](https://www.ietf.org/standards/rfcs/).
    Here are the most widely used protocols:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表简要描述了每个TCP/IP协议及其相关的**请求评论**（**RFC**）标识符。RFC代表详细的技术文档——在我们这种情况下是协议的文档——通常由**互联网工程任务组**（**IETF**）编写。欲了解更多有关RFC的信息，请访问[https://www.ietf.org/standards/rfcs/](https://www.ietf.org/standards/rfcs/)。以下是最常用的协议：
- en: '**IP**: IP (*RFC 791*) identifies network nodes based on fixed-length addresses,
    also known as IP addresses. IP addresses will be described in more detail in the
    next section. The IP protocol uses datagrams as the data transmission unit and
    provides fragmentation and reassembly capabilities of large datagrams to accommodate
    small-packet networks (and avoid transmission delays). The IP protocol also provides
    routing functions to find the optimal data path between network nodes. IP operates
    at the network layer (*Layer 3*) in the OSI model.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP**：IP（*RFC 791*）通过固定长度的地址（也称为IP地址）标识网络节点。IP地址将在下一节中更详细地描述。IP协议使用数据报作为数据传输单元，并提供大数据报的分片和重组功能，以适应小数据包网络（并避免传输延迟）。IP协议还提供路由功能，用于查找网络节点之间的最佳数据传输路径。IP在OSI模型的网络层（*Layer
    3*）中运行。'
- en: '**ARP**: The **Address Resolution Protocol** (**ARP**) (*RFC 826*) is used
    by the IP protocol to map IP network addresses (specifically, **IP version 4**
    or **IPv4**) to device MAC addresses used by a data link protocol. ARP operates
    at the data link layer (*Layer 2*) in the OSI model.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ARP**：**地址解析协议**（**ARP**）（*RFC 826*）由IP协议用于将IP网络地址（具体来说是**IP版本4**或**IPv4**）映射到数据链路协议使用的设备MAC地址。ARP在OSI模型的数据链路层（*Layer
    2*）中运行。'
- en: '**NDP**: The **Neighbor Discovery Protocol** (**NDP**) (*RFC 4861*) is like
    the ARP protocol, and it also controls **IP version 6** (**IPv6**) address mapping.
    NDP operates within the data link layer (*Layer 2*) in the OSI model.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NDP**：**邻居发现协议**（**NDP**）（*RFC 4861*）类似于ARP协议，也控制**IP版本6**（**IPv6**）地址映射。NDP在OSI模型的数据链路层（*Layer
    2*）中运行。'
- en: '**ICMP**: ICMP (*RFC 792*) is a supporting protocol for checking transmission
    issues. When a device or node is not reachable within a given timeout, ICMP reports
    an error. ICMP operates at the network layer (*Layer 3*) in the OSI model.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ICMP**：ICMP（*RFC 792*）是一个用于检查传输问题的支持协议。当设备或节点在给定超时时间内不可达时，ICMP会报告错误。ICMP在OSI模型的网络层（*Layer
    3*）中运行。'
- en: '**TCP**: TCP (*RFC 793*) is a connection-oriented, highly reliable communication
    protocol. TCP requires a logical connection (such as a *handshake*) between the
    nodes before initiating the data exchange. TCP operates at the transport layer
    (*Layer 4*) in the OSI model.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TCP**：TCP（*RFC 793*）是一种面向连接的、高度可靠的通信协议。TCP要求节点之间建立逻辑连接（如*握手*）后，才能启动数据交换。TCP在OSI模型的传输层（*Layer
    4*）中运行。'
- en: '**UDP**: UDP (*RFC 768*) is a connectionless communication protocol. UDP has
    no handshake mechanism (compared to TCP). Consequently, with UDP, there’s no guarantee
    of data delivery. It is also known as a *best-effort protocol*. UDP uses datagrams
    as the data transmission unit, and it’s suitable for network communications where
    error checking is not critical. UDP operates at the transport layer (*Layer 4*)
    in the OSI model.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UDP**：UDP（*RFC 768*）是一种无连接的通信协议。与TCP相比，UDP没有握手机制。因此，使用UDP时无法保证数据传输的可靠性。它也被称为*尽力而为协议*。UDP使用数据报作为数据传输单元，适用于对错误检查不严格要求的网络通信。UDP在OSI模型的传输层（*Layer
    4*）中运行。'
- en: '**Dynamic Host Configuration Protocol** (**DHCP**): The DHCP (*RFC 2131*) provides
    a framework for requesting and passing host configuration information required
    by devices on a TCP/IP network. DHCP enables the automatic (dynamic) allocation
    of reusable IP addresses and other configuration options. DHCP is considered an
    application layer (*Layer 7*) protocol in the OSI model, but the initial DHCP
    discovery mechanism operates at the data link layer (*Layer 2*).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态主机配置协议**（**DHCP**）：DHCP（*RFC 2131*）提供了一个框架，用于请求和传递 TCP/IP 网络上设备所需的主机配置信息。DHCP
    实现了可重用 IP 地址的自动（动态）分配和其他配置选项。DHCP 被视为 OSI 模型中的应用层协议（*第 7 层*），但初始的 DHCP 发现机制在数据链路层（*第
    2 层*）操作。'
- en: '`dns.google.com`) into an IP address (such as `8.8.8.8`). The DNS protocol
    operates at the application layer (*Layer 7*) in the OSI model.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns.google.com`）转换为 IP 地址（例如 `8.8.8.8`）。DNS 协议在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**HTTP**: HTTP (*RFC 2616*) is the vehicular language of the internet. HTTP
    is a stateless application-level protocol based on the request and response between
    a client application (for example, a browser) and a server endpoint (for example,
    a web server). HTTP supports a wide variety of data formats, ranging from text
    to images and video streams. HTTP operates at the application layer (*Layer 7*)
    in the OSI model.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP**：HTTP（*RFC 2616*）是互联网的车辆语言。HTTP 是一种基于请求和响应的无状态应用级协议，用于客户端应用程序（例如浏览器）和服务器端点（例如
    Web 服务器）之间的通信。HTTP 支持从文本到图像和视频流等多种数据格式。HTTP 在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**FTP**: FTP (*RFC 959*) is a standard protocol for transferring files requested
    by an FTP client from an FTP server. FTP operates at the application layer (*Layer
    7*) in the OSI model.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FTP**：FTP（*RFC 959*）是一个用于从 FTP 服务器请求文件传输的标准协议。FTP 在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**TELNET**: The **Terminal Network protocol** (**TELNET**) (*RFC 854*) is an
    application-layer protocol that provides a bidirectional text-oriented network
    communication between a client and a server machine, using a virtual terminal
    connection. TELNET operates at the application layer (*Layer 7*) in the OSI model.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TELNET**：**终端网络协议**（**TELNET**）（*RFC 854*）是一种应用层协议，提供客户端和服务器机器之间的双向文本导向网络通信，使用虚拟终端连接。TELNET
    在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**SSH**: **Secure Shell** (**SSH**) (*RFC 4253*) is a secure application-layer
    protocol that encapsulates strong encryption and cryptographic host authentication.
    SSH uses a virtual terminal connection between a client and a server machine.
    SSH operates at the application layer (*Layer 7*) in the OSI model.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSH**：**安全外壳协议**（**SSH**）（*RFC 4253*）是一种安全的应用层协议，封装强加密和加密主机认证。SSH 使用客户端和服务器机器之间的虚拟终端连接。SSH
    在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**SMTP**: SMTP (*RFC 5321*) is an application-layer protocol for sending and
    receiving emails between an email client (for example, Outlook) and an email server
    (such as Exchange Server). SMTP supports strong encryption and host authentication.
    SMTP acts at the application layer (*Layer 7*) in the OSI model.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SMTP**：SMTP（*RFC 5321*）是用于在电子邮件客户端（例如 Outlook）和电子邮件服务器（例如 Exchange Server）之间发送和接收电子邮件的应用层协议。SMTP
    支持强加密和主机认证。SMTP 在 OSI 模型中操作于应用层（*第 7 层*）。'
- en: '**SNMP**: The **Simple Network Management Protocol** (**SNMP**) (*RFC 1157*)
    is used for remote device management and monitoring. SNMP operates at the application
    layer (*Layer 7*) in the OSI model.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SNMP**：**简单网络管理协议**（**SNMP**）（*RFC 1157*）用于远程设备管理和监控。SNMP 在 OSI 模型中操作于应用层（*第
    7 层*）。'
- en: '**NTP**: The **Network Time Protocol** (**NTP**) (*RFC 5905)* is an internet
    protocol that’s used for synchronizing the system clock of multiple machines across
    a network. NTP operates at the application layer (*Layer 7*) in the OSI model.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NTP**：**网络时间协议**（**NTP**）（*RFC 5905*）是用于在网络中多台机器之间同步系统时钟的互联网协议。NTP 在 OSI
    模型中操作于应用层（*第 7 层*）。'
- en: Most of the internet protocols enumerated previously use the IP protocol to
    identify devices participating in the communication. Devices on a network are
    uniquely identified by an IP address. Let’s examine these network addresses more
    closely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数之前列举的互联网协议使用 IP 协议来识别参与通信的设备。网络上的设备通过 IP 地址唯一标识。让我们更仔细地检查这些网络地址。
- en: IP addresses
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP 地址
- en: An **IP address** is a fixed-length **unique identifier** (**UID**) of a device
    in a network. Devices locate and communicate with each other based on IP addresses.
    The concept of an IP address is very similar to a postal address of a residence,
    whereby mail or a package would be sent to that destination based on its address.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP 地址**是网络中设备的固定长度**唯一标识符**（**UID**）。设备基于 IP 地址来定位并与彼此通信。IP 地址的概念非常类似于住宅的邮政地址，通过地址来发送邮件或包裹到目的地。'
- en: Initially, IP defined the IP address as a 32-bit number known as an **IPv4 address**.
    With the growth of the internet, the total number of IP addresses in a network
    has been exhausted. To address this issue, a new version of the IP protocol devised
    a 128-bit numbering scheme for IP addresses. A 128-bit IP address is also known
    as an **IPv6 address**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，IP 将 IP 地址定义为一个 32 位数字，称为**IPv4 地址**。随着互联网的发展，网络中的 IP 地址总数已被耗尽。为了解决这个问题，IP
    协议的一个新版本设计了一个 128 位的 IP 地址编号方案。一个 128 位的 IP 地址也被称为**IPv6 地址**。
- en: In the next few sections, we’ll take a closer look at the networking constructs
    that play an important role in IP addresses, such as IPv4 and IPv6 address formats,
    network classes, subnetworks, and broadcast addresses.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更深入地了解在 IP 地址中起重要作用的网络构造，例如 IPv4 和 IPv6 地址格式、网络类别、子网和广播地址。
- en: IPv4 addresses
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4 地址
- en: An `.`). Each number in these four groups is an integer between `0` and `255`.
    An example of an IPv4 address is `192.168.1.53`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个` . `）。这四组数字中的每个数字是一个介于`0`和`255`之间的整数。一个 IPv4 地址的例子是`192.168.1.53`。
- en: 'The following figure shows a binary representation of an IPv4 address:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了 IPv4 地址的二进制表示：
- en: '![Figure 7.4 – Network classes](img/B19682_07_04.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 网络类别](img/B19682_07_04.jpg)'
- en: Figure 7.4 – Network classes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 网络类别
- en: The IPv4 address space is limited to 4,294,967,296 (2^32) addresses (roughly
    4 billion). Of these, approximately 18 million are reserved for special purposes
    (for example, private networks), and about 270 million are multicast addresses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址空间的总数限制为 4,294,967,296（2^32）个地址（大约 40 亿）。其中，大约 1800 万个地址保留用于特殊目的（例如，私有网络），约有
    2.7 亿个是组播地址。
- en: A **multicast address** is a logical identifier of a group of IP addresses.
    For more information on multicast addresses, please refer to *RFC* *6308* ([https://tools.ietf.org/html/rfc6308](https://tools.ietf.org/html/rfc6308)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**组播地址**是一组 IP 地址的逻辑标识符。如需了解更多关于组播地址的信息，请参考 *RFC* *6308*（[https://tools.ietf.org/html/rfc6308](https://tools.ietf.org/html/rfc6308)）。'
- en: Network classes
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络类别
- en: 'In the early stages of the internet, the highest-order byte (first group) in
    the IPv4 address indicated the **network number**. The subsequent bytes further
    express the network hierarchy and subnetworks, with the lowest-order byte identifying
    the device itself. This scheme soon proved insufficient for network hierarchies
    and segregations as it only allowed for 256 (2^8) networks, denoted by the leading
    byte of the IPv4 address. As additional networks were added, each with its own
    identity, the IP address specification needed a special revision to accommodate
    a standard model. The *Classful Network* specification, which was introduced in
    1981, addressed this problem by dividing the IPv4 address space into five classes
    based on the leading 4 bits of the address, as illustrated in the following figure:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网早期，IPv4 地址中的最高位字节（第一组）表示**网络号**。随后的字节进一步表示网络层次结构和子网，最低位字节标识设备本身。这个方案很快证明不足以满足网络层次结构和分隔的需求，因为它仅允许
    256（2^8）个网络，由 IPv4 地址的首字节表示。随着额外网络的加入，每个网络都有自己的身份，IP 地址规范需要进行特别修订，以适应标准模型。1981
    年推出的 *Classful Network* 规范通过根据地址的前 4 位将 IPv4 地址空间划分为五个类别，解决了这个问题，具体如下面的图所示：
- en: '![Figure 7.5 – Network classes](img/B19682_07_05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 网络类别](img/B19682_07_05.jpg)'
- en: Figure 7.5 – Network classes
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 网络类别
- en: For more information on network classes, please refer to *RFC 870* ([https://tools.ietf.org/html/rfc870](https://tools.ietf.org/html/rfc870)).
    In the preceding figure, the last column specifies the default subnet mask for
    each of these network classes. We’ll look at subnets (or subnetworks) next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于网络类别的信息，请参考 *RFC 870*（[https://tools.ietf.org/html/rfc870](https://tools.ietf.org/html/rfc870)）。在上图中，最后一列指定了每个网络类别的默认子网掩码。接下来我们将查看子网（或子网络）。
- en: Subnetworks
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子网
- en: '**Subnetworks** (or **subnets**) are logical subdivisions of an IP network.
    Subnets were introduced to identify devices that belong to the same network. The
    IP addresses of devices in the same network have an identical most-significant
    group. The subnet definition yields a logical division of an IP address into two
    fields: the **network identifier** and the **host identifier**. The numerical
    representation of the subnet is called a **subnet mask** or **netmask**. The following
    figure provides an example of a network identifier and a host identifier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网络**（或**子网**）是IP网络的逻辑子划分。子网的引入是为了识别属于同一网络的设备。处于同一网络的设备的IP地址具有相同的最高有效位组。子网定义将IP地址逻辑上划分为两个字段：**网络标识符**和**主机标识符**。子网的数字表示称为**子网掩码**或**网掩码**。下图提供了网络标识符和主机标识符的示例：'
- en: '![Figure 7.6 – Subnet with network and host identifiers](img/B19682_07_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 带有网络和主机标识符的子网](img/B19682_07_06.jpg)'
- en: Figure 7.6 – Subnet with network and host identifiers
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 带有网络和主机标识符的子网
- en: 'With our IPv4 address (`192.168.1.53`), we could devise a network identifier
    of `192.168.1`, where the host identifier is `53`. The resulting subnet mask would
    be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的IPv4地址（`192.168.1.53`），我们可以设计出一个网络标识符`192.168.1`，其中主机标识符是`53`。生成的子网掩码如下所示：
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We dropped the least significant group in the subnet mask, representing the
    host identifier (`53`), and replaced it with `0`. Here, `0` indicates the starting
    address in the subnet. In other words, any host identifier value in the range
    of `0` to `255` is allowed in the subnetwork. For example, `192.168.1.92` is a
    valid (and accepted) IP address in the `192.168.1.0` network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢弃了子网掩码中的最低有效组，代表主机标识符（`53`），并将其替换为`0`。这里的`0`表示子网中的起始地址。换句话说，子网中允许任何主机标识符值在`0`到`255`的范围内。例如，`192.168.1.92`是`192.168.1.0`网络中的一个有效（并被接受的）IP地址。
- en: 'An alternative representation of subnets uses so-called `/`) and the *bit-length*
    of the prefix. In our case, the CIDR notation of the `192.168.1.0` subnet is this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 子网的另一种表示方法使用所谓的`/`和*前缀的位长度*。在我们的例子中，`192.168.1.0`子网的CIDR表示法如下：
- en: '[PRE1]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three groups in the network address make up *3 x 8 = 24* bits, hence
    the `/``24` notation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地址中的前三组构成*3 x 8 = 24*位，因此采用`/24`表示法。
- en: Usually, `100` and end with `125`. Let’s look at how we can achieve this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它以`100`开始，以`125`结束。让我们看看如何实现这一点。
- en: 'First, let’s see the binary representation of `192.168.1.100`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`192.168.1.100`的二进制表示：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '1. These bits would be added to the 24 already reserved bits of the network
    address (192.168.1), accounting in total for *27 = 24 + 3* bits. Here’s the equivalent
    representation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 这些位将被添加到网络地址（192.168.1）中已经保留的24位中，总共占用*27 = 24 + 3*位。以下是等效的表示：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consequently, the resulting netmask is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，生成的子网掩码如下所示：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The CIDR notation of the corresponding subnet is shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对应子网的CIDR表示法如下所示：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The remaining five bits in the host identifier’s group account for *2^5 = 32*
    possible addresses in the subnet, starting with `97`. This would limit the maximum
    host identifier value to *127 = 96 + 32 – 1* (we subtract 1 to account for the
    starting number of 97 included in the total of 32). In this range of 32 addresses,
    the last IP address is reserved as a **broadcast address**, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 主机标识符组中的剩余五个位表示子网中可能的*2^5 = 32*个地址，从`97`开始。这将限制最大主机标识符值为*127 = 96 + 32 – 1*（我们减去1是为了排除包含在32个地址总数中的起始数字97）。在这32个地址的范围内，最后一个IP地址保留作为**广播地址**，如图所示：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A broadcast address is reserved as the highest number in a network or subnet,
    when applicable. Back to our example, excluding the broadcast address, the maximum
    host IP address in the subnet is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 广播地址是保留为网络或子网中的最大数字，在适用时。回到我们的例子，除去广播地址后，子网中最大主机IP地址如下所示：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can learn more about subnets in *RFC 1918* ([https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918)).
    Since we mentioned the broadcast address, let’s have a quick look at it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*RFC 1918*中了解更多关于子网的内容 ([https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918))。由于我们提到了广播地址，接下来我们快速了解一下它。
- en: Broadcast addresses
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 广播地址
- en: A **broadcast address** is a reserved IP address in a network or subnetwork
    that’s used to transmit a collective message (data) to all devices belonging to
    the network. The broadcast address is the last IP address in the network or subnet,
    when applicable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播地址**是在网络或子网中预留的 IP 地址，用于向属于该网络的所有设备传送集体消息（数据）。广播地址是网络或子网中的最后一个 IP 地址（如果适用）。'
- en: For example, the broadcast address of the `192.168.1.0/24` network is `192.168.1.255`.
    In our example in the previous section, the broadcast address of the `192.168.1.96/27`
    subnet is `192.168.1.127` (*127 = 96 + 32 –* *1*).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`192.168.1.0/24` 网络的广播地址是 `192.168.1.255`。在上一节中的示例中，`192.168.1.96/27` 子网的广播地址是
    `192.168.1.127`（*127 = 96 + 32 –* *1*）。
- en: For more information on broadcast addresses, you can refer to [https://www.sciencedirect.com/topics/computer-science/broadcast-address](https://www.sciencedirect.com/topics/computer-science/broadcast-address).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多有关广播地址的信息，请参阅 [https://www.sciencedirect.com/topics/computer-science/broadcast-address](https://www.sciencedirect.com/topics/computer-science/broadcast-address)。
- en: IPv6 addresses
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址
- en: 'An IPv6 address is a 128-bit number (16 bytes) that’s usually expressed as
    up to eight groups of 2-byte (16 bits) numbers, separated by a column (`:`). Each
    number in these eight groups is a hexadecimal number, with values between `0000`
    and `FFFF`. Here’s an example of an IPv6 address:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址是一个 128 位（16 字节）的数字，通常表示为最多八组 2 字节（16 位）的数字，每组数字之间用冒号（`:`）分隔。每组数字是一个十六进制数字，值在
    `0000` 和 `FFFF` 之间。下面是一个 IPv6 地址的示例：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An equivalent representation of the preceding IPv6 address is shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 IPv6 地址的等效表示如下：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the second representation, the leading zeros are omitted, and the all-zero
    groups (`0000:0000`) are collapsed into an empty group (`::`). The `/64` notation
    at the end represents the `1` and `128`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种表示法中，前导零被省略，所有零组（`0000:0000`）被压缩成一个空组（`::`）。末尾的`/64`符号表示的是`1`和`128`。
- en: 'In our case, with a prefix length of 64 (*4 x 16*) bits, the subnet looks like
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，前缀长度为 64（*4 x 16*）位，子网看起来是这样的：
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The subnet represents the leading four groups (`2001`, `0b8d`, `8a52`, and `0000`),
    which results in a total of *4 x 16 = 64* bits. In the shortened representation
    of the IPv6 subnet, the leading zeros are omitted and the all-zero group is collapsed
    to `::`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 子网表示的是前四个组（`2001`、`0b8d`、`8a52` 和 `0000`），这将总共产生*4 x 16 = 64*位。在简化表示的 IPv6 子网中，前导零被省略，所有零组被压缩成
    `::`。
- en: Subnetting with IPv6 is very similar to IPv4\. We won’t go into the details
    here since the related concepts were presented in the *IPv4 addresses* section.
    For more information about IPv6, please refer to *RFC* *2460* ([https://tools.ietf.org/html/rfc2460](https://tools.ietf.org/html/rfc2460)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 的子网划分与 IPv4 非常相似。我们在这里不会详细讨论，因为相关概念已在*IPv4 地址*部分介绍。有关 IPv6 的更多信息，请参阅*RFC*
    *2460*（[https://tools.ietf.org/html/rfc2460](https://tools.ietf.org/html/rfc2460)）。
- en: Now that you’ve become familiar with IP addresses, it is fitting to introduce
    some of the related network constructs that serve the software implementation
    of IP addresses – that is, sockets and ports.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你已经熟悉了 IP 地址，接下来介绍一些与 IP 地址的软件实现相关的网络构造——即套接字和端口。
- en: Sockets and ports
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字和端口
- en: A **socket** is a software data structure representing a network node for communication
    purposes. Although a programming concept, in Linux, a **network socket** is ultimately
    a file descriptor that’s controlled via a network **application programming interface**
    (**API**). A socket is used by an application process for transmitting and receiving
    data. An application can create and delete sockets. A socket cannot be active
    (send or receive data) beyond the lifetime of the process that created the socket.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字**是一个用于表示网络节点的软件数据结构，供通信使用。虽然它是一个编程概念，但在 Linux 中，**网络套接字**最终是一个文件描述符，通过网络**应用程序编程接口**（**API**）进行控制。套接字被应用程序进程用于数据的发送和接收。应用程序可以创建和删除套接字。套接字不能在创建它的进程生命周期之外处于活动状态（发送或接收数据）。'
- en: Network sockets operate at the *transport-layer* level in the OSI model. There
    are two endpoints to a socket connection – a sender and a receiver. Both the sender
    and receiver have an IP address. Consequently, a critical piece of information
    in the socket data structure is the *IP address* of the endpoint that owns the
    socket.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字在 OSI 模型的*传输层*操作。套接字连接有两个端点——发送方和接收方。发送方和接收方都有一个 IP 地址。因此，套接字数据结构中的一个关键部分是拥有该套接字的端点的*IP
    地址*。
- en: Both endpoints create and manage their sockets via the network processes using
    these sockets. The sender and receiver may agree upon using multiple connections
    to exchange data. Some of these connections may even run in parallel. How do we
    differentiate between these socket connections? The IP address by itself is not
    sufficient, and this is where **ports** come into play.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个端点通过网络进程使用这些套接字来创建和管理它们的套接字。发送方和接收方可以达成共识，使用多个连接来交换数据。有些连接甚至可能并行运行。我们如何区分这些套接字连接？单独的
    IP 地址是不够的，这时 **端口** 就发挥了作用。
- en: 'A `0` and `65535`. Usually, ports in the range of `0` and `1024` are assigned
    to the most used services on a system. These ports are also called **well-known
    ports**. Here are a few examples of well-known ports and the related network service
    for each:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 和 `65535`。通常，`0` 和 `1024` 之间的端口分配给系统上使用最频繁的服务。这些端口也被称为 **知名端口**。以下是一些知名端口及其相关网络服务的示例：'
- en: '`25`: SMTP'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`: SMTP'
- en: '`21`: FTP'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`21`: FTP'
- en: '`22`: SSH'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`22`: SSH'
- en: '`53`: DNS'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`53`: DNS'
- en: '`67`, `68`: DHCP (client = `68`, server = `67`)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`67`，`68`: DHCP（客户端 = `68`，服务器 = `67`）'
- en: '`80`: HTTP'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`80`: HTTP'
- en: '`443`: **HTTP** **Secure** (**HTTPS**)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`443`: **HTTP** **Secure**（**HTTPS**）'
- en: Port numbers beyond `1024` are for general use and are also known as **ephemeral
    ports**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`1024` 以上的端口号供一般使用，也称为 **临时端口**。'
- en: A port is always associated with an IP address. Ultimately, a socket is a combination
    of an IP address and a port. For more information on network sockets, you can
    refer to *RFC 147* ([https://tools.ietf.org/html/rfc147](https://tools.ietf.org/html/rfc147)).
    For well-known ports, see *RFC* *1340* ([https://tools.ietf.org/html/rfc1340](https://tools.ietf.org/html/rfc1340)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 端口总是与 IP 地址关联。最终，套接字是 IP 地址和端口的组合。有关网络套接字的更多信息，请参阅 *RFC 147*（[https://tools.ietf.org/html/rfc147](https://tools.ietf.org/html/rfc147)）。有关常见端口的信息，请参阅
    *RFC* *1340*（[https://tools.ietf.org/html/rfc1340](https://tools.ietf.org/html/rfc1340)）。
- en: Now, let’s put the knowledge we’ve gained so far to work by looking at how to
    configure the local networking stack in Linux.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运用迄今为止所学的知识，看看如何配置 Linux 中的本地网络栈。
- en: Linux network configuration
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 网络配置
- en: This section describes the TCP/IP **network configuration** for Ubuntu and Fedora
    platforms, using their latest released versions to date. The same concepts would
    apply to most Linux distributions, albeit some of the network configuration utilities
    and files involved could be different.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了适用于 Ubuntu 和 Fedora 平台的 TCP/IP **网络配置**，使用的是它们目前发布的最新版本。相同的概念适用于大多数 Linux
    发行版，尽管其中一些网络配置工具和文件可能有所不同。
- en: 'We can use the `ip` command-line utility to retrieve the system’s current IP
    addresses, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ip` 命令行工具来检索系统当前的 IP 地址，方法如下：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An example of the output is shown here:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出的一个示例：
- en: '![Figure 7.7 – Retrieving the current IP addresses with the ip command](img/B19682_07_07.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 使用 ip 命令检索当前的 IP 地址](img/B19682_07_07.jpg)'
- en: Figure 7.7 – Retrieving the current IP addresses with the ip command
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 使用 ip 命令检索当前的 IP 地址
- en: 'We’ve highlighted some relevant information here, such as the network interface
    ID (`2: enp1s0`) and the IP address with the subnet prefix (`192.168.122.117/24`).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在这里突出显示了一些相关信息，例如网络接口 ID（`2: enp1s0`）和带有子网前缀的 IP 地址（`192.168.122.117/24`）。'
- en: We’ll look at Ubuntu’s network configuration next. At the time of writing this
    book, the released version of Ubuntu is 22.04.2 LTS.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来看 Ubuntu 的网络配置。在编写本书时，Ubuntu 的发布版本是 22.04.2 LTS。
- en: Ubuntu network configuration
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 网络配置
- en: 'Ubuntu 22.04 provides the `netplan` command-line utility for easy network configuration.
    `netplan` uses a `netplan` configuration file(s) is in the `/etc/netplan/` directory,
    and we can access it by using the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 22.04 提供了 `netplan` 命令行工具，以便轻松进行网络配置。`netplan` 使用一个配置文件，该文件位于 `/etc/netplan/`
    目录中，我们可以使用以下命令访问它：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our case, the configuration file is `00-installer-config.yaml`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，配置文件是 `00-installer-config.yaml`。
- en: Changing the network configuration involves editing the `netplan` YAML configuration
    file. As good practice, we should always make a backup of the current configuration
    file before making changes. Changing a network configuration would most commonly
    involve setting up either a dynamic or a static IP address. We will show you how
    to configure both types in the next few sections. We’ll look at dynamic IP addressing
    first.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 更改网络配置涉及编辑 `netplan` YAML 配置文件。作为良好的实践，我们应始终在更改之前备份当前的配置文件。更改网络配置通常包括设置动态或静态
    IP 地址。我们将在接下来的几个部分中展示如何配置这两种类型的 IP 地址。我们将首先介绍动态 IP 地址配置。
- en: Dynamic IP configuration
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 IP 配置
- en: 'To enable a dynamic (DHCP) IP address, we must edit the `netplan` configuration
    file and set the `dhcp4` attribute to `true` (as shown in *Figure 7**.8*) for
    the network interface of our choice (`ens33`, in our case). Open the `00-installer-config.yaml`
    file with your text editor of choice (nano, in our case):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用动态（DHCP）IP 地址，我们必须编辑 `netplan` 配置文件，并将所选网络接口（我们选择的是 `ens33`）的 `dhcp4` 属性设置为
    `true`（如 *图 7.8* 所示）。使用你喜欢的文本编辑器（在我们这里是 nano）打开 `00-installer-config.yaml` 文件：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s the related configuration excerpt, with the relevant points highlighted:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关的配置摘录，并标出了关键点：
- en: '![Figure 7.8 – Enabling DHCP in the netplan configuration](img/B19682_07_08.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 在 netplan 配置中启用 DHCP](img/B19682_07_08.jpg)'
- en: Figure 7.8 – Enabling DHCP in the netplan configuration
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 在 netplan 配置中启用 DHCP
- en: 'After saving the configuration file, we can test the related changes with the
    following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 保存配置文件后，我们可以使用以下命令测试相关更改：
- en: '[PRE14]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We’ll get the following response:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下响应：
- en: '![Figure 7.9 – Testing and accepting the netplan configuration changes](img/B19682_07_09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 测试并接受 netplan 配置更改](img/B19682_07_09.jpg)'
- en: Figure 7.9 – Testing and accepting the netplan configuration changes
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 测试并接受 netplan 配置更改
- en: 'The `netplan` keyword validates the new configuration and prompts the user
    to accept the changes. The following command applies the current changes to the
    system:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`netplan` 关键字验证新的配置并提示用户接受更改。以下命令将当前更改应用到系统中：'
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we will configure a static IP address using `netplan`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `netplan` 配置静态 IP 地址。
- en: Static IP configuration
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 IP 配置
- en: 'To set the static IP address of a network interface, we start by editing the
    `netplan` configuration YAML file, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置网络接口的静态 IP 地址，我们首先编辑 `netplan` 配置 YAML 文件，内容如下：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s a configuration example with a static IP address of `192.168.122.22/24`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个静态 IP 地址 `192.168.122.22/24` 的配置示例：
- en: '![Figure 7.10 – Static IP configuration example with netplan](img/B19682_07_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 使用 netplan 配置静态 IP 示例](img/B19682_07_10.jpg)'
- en: Figure 7.10 – Static IP configuration example with netplan
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 使用 netplan 配置静态 IP 示例
- en: 'After saving the configuration, we can test and accept it, and then apply changes,
    as we did in the *Dynamic IP* section, with the following commands:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 保存配置后，我们可以像在 *动态 IP* 部分中那样，使用以下命令测试并接受配置，更改并应用：
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For more information on the `netplan` command-line utility, see `netplan --help`
    or the related system manual (`man netplan`).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 `netplan` 命令行工具的更多信息，请参见 `netplan --help` 或相关系统手册（`man netplan`）。
- en: We’ll look at the Fedora network configuration next. At the time of writing,
    the current released version of Fedora is 37.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看看 Fedora 的网络配置。本文写作时，当前发布的 Fedora 版本为 37。
- en: Fedora/RHEL network configuration
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Fedora/RHEL 网络配置
- en: 'Starting with Fedora 33 and RHEL 9, network configuration files are *no longer*
    kept in the `/etc/sysconfig/network-scripts/` directory. To learn more about the
    new configuration options, read the following file:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Fedora 33 和 RHEL 9 开始，网络配置文件 *不再* 存放在 `/etc/sysconfig/network-scripts/` 目录下。要了解有关新配置选项的更多信息，请阅读以下文件：
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preferred method to configure the network in Fedora/RHEL is to use the `nmcli`
    utility. This location is deprecated and no longer used by NetworkManager in Fedora;
    it can still be used, but we do not recommend it. The new NetworkManager keyfiles
    are stored inside the `/``etc/NetworkManager/system-connections/` directory.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Fedora/RHEL 中，配置网络的首选方法是使用 `nmcli` 工具。此位置已经被弃用，并且在 Fedora 中不再被 NetworkManager
    使用；它仍然可以使用，但我们不推荐使用它。新的 NetworkManager 密钥文件存储在 `/etc/NetworkManager/system-connections/`
    目录中。
- en: 'Let’s use some basic `nmcli` commands to view information about our connections.
    To learn about `nmcli`, read the related manual pages. First, let’s find information
    about our active connection using the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一些基本的 `nmcli` 命令查看有关连接的信息。要了解 `nmcli`，请阅读相关的手册页。首先，让我们使用以下命令查找有关我们活动连接的信息：
- en: '[PRE19]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output will show basic information about the name of the connection, UUID,
    type, and the device used. The following screenshot shows the relevant information
    on our Fedora 37 VM:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示有关连接名称、UUID、类型和使用的设备的基本信息。以下截图显示了我们在 Fedora 37 虚拟机上的相关信息：
- en: '![Figure 7.11 – Using nmcli to view connection information](img/B19682_07_11.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 使用 nmcli 查看连接信息](img/B19682_07_11.jpg)'
- en: Figure 7.11 – Using nmcli to view connection information
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 使用 nmcli 查看连接信息
- en: Similar to Ubuntu, when using Fedora/RHEL, changing a network configuration
    would most commonly involve setting up either a dynamic or a static IP address.
    We will show you how to configure both types in the following sections. Let’s
    look at dynamic IP addressing first.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ubuntu 类似，在使用 Fedora/RHEL 时，更改网络配置通常涉及设置动态或静态IP地址。我们将在接下来的章节中展示如何配置这两种类型的IP地址。让我们先看看动态IP地址配置。
- en: Dynamic IP configuration
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 动态IP配置
- en: 'To configure a dynamic IP address using `ncmli`, we can run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ncmli` 配置动态IP地址，我们可以运行以下命令：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ipv4.method auto` directive enables DHCP. There is no output from the
    command; after execution, you will be returned to the prompt again. You can check
    if the command worked by viewing the `/etc/NetworkManager/system-connections/`
    directory. In our case, there is a new keyfile inside. It has the same name as
    our connection. The following is an excerpt:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipv4.method auto` 指令启用 DHCP。该命令没有输出；执行后，您将返回到提示符。您可以通过查看 `/etc/NetworkManager/system-connections/`
    目录来检查命令是否生效。在我们的案例中，目录内会有一个新的密钥文件。它与我们的连接名称相同。以下是一个摘录：'
- en: '![Figure 7.12 – New configuration keyfile](img/B19682_07_12.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 新的配置密钥文件](img/B19682_07_12.jpg)'
- en: Figure 7.12 – New configuration keyfile
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 新的配置密钥文件
- en: Next, we’ll configure a static IP address.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置静态IP地址。
- en: Static IP configuration
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 静态IP配置
- en: 'To perform the equivalent static IP address changes using `ncmli`, we need
    to run multiple commands. First, we must set the static IP address, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ncmli` 执行等效的静态IP地址更改，我们需要运行多个命令。首先，我们必须设置静态IP地址，如下所示：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If no previous static IP address has been configured, we recommend saving the
    preceding change before proceeding with the next steps. The changes can be saved
    with the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前没有配置静态IP地址，我们建议在继续下一步之前保存前面的更改。可以使用以下代码保存这些更改：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we must set the gateway and DNS IP addresses, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须设置网关和DNS IP地址，如下所示：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we must disable DHCP with the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用以下代码禁用 DHCP：
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After making these changes, we need to restart the `''Wired connection 1''`
    network interface with the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些更改后，我们需要使用以下代码重新启动 `'Wired connection 1'` 网络接口：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s see the results of all the commands we’ve performed. After bringing
    the connection up again, let’s check the new IP address and the contents of the
    network keyfile. The following figure shows the new IP we assigned to the system
    (`192.168.122.3`) by using the `ip addr` `show` command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看我们执行的所有命令的结果。重新启动连接后，我们来检查新的IP地址和网络密钥文件的内容。下图显示了我们通过使用 `ip addr` `show`
    命令分配给系统的新的IP（`192.168.122.3`）：
- en: '![Figure 7.13 – Checking the new IP address](img/B19682_07_13.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 检查新的IP地址](img/B19682_07_13.jpg)'
- en: Figure 7.13 – Checking the new IP address
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 检查新的IP地址
- en: 'Now, let’s view the contents of the network keyfile to see the changes that
    were made for static IP configuration. Remember that the location of the file
    is `/etc/NetworkManager/system-connections/`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看网络密钥文件的内容，看看为静态IP配置所做的更改。请记住，文件的位置是`/etc/NetworkManager/system-connections/`：
- en: '![Figure 7.14 – New keyfile configuration for the static IP address](img/B19682_07_14.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 静态IP地址的新密钥文件配置](img/B19682_07_14.jpg)'
- en: Figure 7.14 – New keyfile configuration for the static IP address
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 静态IP地址的新密钥文件配置
- en: The `nmcli` utility is a powerful and useful one. At the end of this chapter,
    we will provide you with some useful links for learning more about it. Next, we’ll
    take a look at how to configure network services on openSUSE.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmcli` 工具是一个功能强大且有用的工具。在本章末尾，我们将为你提供一些有用的链接，帮助你进一步了解它。接下来，我们将看看如何在 openSUSE
    上配置网络服务。'
- en: openSUSE network configuration
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: openSUSE 网络配置
- en: 'openSUSE provides several tools for network configuration: **Wicked** and NetworkManager.
    According to the official SUSE documentation, Wicked is used for all types of
    machines, from servers to laptops and workstations, whereas NetworkManager is
    used only for laptop and workstation setup and is not used for server setup. However,
    in openSUSE Leap, Wicked is set up by default on both desktop or server configurations,
    and NetworkManager is set up by default on laptop configurations.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: openSUSE 提供了几种网络配置工具：**Wicked** 和 NetworkManager。根据官方的 SUSE 文档，Wicked 适用于各种类型的机器，从服务器到笔记本电脑和工作站，而
    NetworkManager 仅用于笔记本电脑和工作站的配置，不适用于服务器配置。然而，在 openSUSE Leap 中，默认情况下，无论是桌面配置还是服务器配置，都会使用
    Wicked，而笔记本电脑配置则默认使用 NetworkManager。
- en: 'For example, on our main workstation (which is a laptop), if we want to see
    which service is running by default on openSUSE Leap, we can use the following
    command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的主工作站（笔记本电脑）上，如果我们想查看 openSUSE Leap 默认运行的是哪个服务，可以使用以下命令：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output will show us which service is running, and in our case, it is NetworkManager:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 输出会显示正在运行的服务，在我们的情况下，它是 NetworkManager：
- en: '![Figure 7.15 – Checking which network service is running in openSUSE](img/B19682_07_15.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 检查哪个网络服务在 openSUSE 中运行](img/B19682_07_15.jpg)'
- en: Figure 7.15 – Checking which network service is running in openSUSE
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 检查哪个网络服务在 openSUSE 中运行
- en: 'When running the same command inside an openSUSE Leap server VM, the result
    is different. The output shows that Wicked is running by default. The following
    screenshot shows an example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 openSUSE Leap 服务器虚拟机中运行相同命令时，结果会有所不同。输出显示 Wicked 默认运行。以下截图展示了一个示例：
- en: '![Figure 7.16 – Wicked is running inside the openSUSE server](img/B19682_07_16.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – Wicked 在 openSUSE 服务器中运行](img/B19682_07_16.jpg)'
- en: Figure 7.16 – Wicked is running inside the openSUSE server
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – Wicked 在 openSUSE 服务器中运行
- en: As a result, we will perform all the examples in this section on an openSUSE
    Leap server VM, thus using Wicked as the default network configuration tool. In
    the next section, we will configure dynamic IP on an openSUSE machine.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在本节中所有的示例都在 openSUSE Leap 服务器虚拟机上进行，从而使用 Wicked 作为默认的网络配置工具。在下一节中，我们将配置
    openSUSE 机器上的动态 IP。
- en: Dynamic IP configuration
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 IP 配置
- en: 'Before setting anything up, let’s check for active connections and devices.
    We can do this by using the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何配置之前，让我们检查一下活动连接和设备。我们可以通过使用以下命令来完成此操作：
- en: '[PRE27]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output will show all the active devices. The following screenshot shows
    an excerpt from the output on our machine:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示所有活动设备。以下截图展示了我们机器上输出的摘录：
- en: '![Figure 7.17 – Information about active devices](img/B19682_07_17.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 有关活动设备的信息](img/B19682_07_17.jpg)'
- en: Figure 7.17 – Information about active devices
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 有关活动设备的信息
- en: 'There are two active connections, one is loopback (`lo`) and the other is on
    the ethernet port (`eth0`). We will only show information related to `eth0`. The
    location where Wicked stores configuration files in openSUSE is `/etc/sysconfig/network`.
    If we do a listing of that directory, we will see that it is already populated
    with configuration files for existing connections:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个活动连接，一个是回环（`lo`），另一个是以太网端口（`eth0`）。我们将仅显示与 `eth0` 相关的信息。Wicked 在 openSUSE
    中存储配置文件的位置是 `/etc/sysconfig/network`。如果我们列出该目录内容，我们会看到其中已经有现有连接的配置文件：
- en: '![Figure 7.18 – Location of the Wicked configuration files](img/B19682_07_18.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – Wicked 配置文件的位置](img/B19682_07_18.jpg)'
- en: Figure 7.18 – Location of the Wicked configuration files
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – Wicked 配置文件的位置
- en: 'In our case, and maybe it will be the same for you, the file we are interested
    in is called `ifcfg-eth0`; we can open it with a text editor or concatenate it.
    Let’s take a look at the contents of the file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，可能你也会遇到相同的情况，感兴趣的文件叫做 `ifcfg-eth0`；我们可以用文本编辑器打开它，或者将其连接输出。让我们来看看文件的内容：
- en: '![Figure 7.19 – Information provided by the configuration file](img/B19682_07_19.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 配置文件提供的信息](img/B19682_07_19.jpg)'
- en: Figure 7.19 – Information provided by the configuration file
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 配置文件提供的信息
- en: 'As shown in the preceding screenshot, the information provided is rather scarce
    but relevant. For a more detailed output, we can use the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，提供的信息相对较少，但仍然相关。为了获得更详细的输出，我们可以使用以下命令：
- en: '[PRE28]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will provide much more relevant information directly to the monitor. The
    following screenshot provides an excerpt from our output, with detailed IPv4 DHCP
    information:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接向显示器提供更多相关信息。以下截图展示了我们输出的摘录，包含详细的IPv4 DHCP信息：
- en: '![Figure 7.20 – Detailed information provided by Wicked](img/B19682_07_20.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – Wicked提供的详细信息](img/B19682_07_20.jpg)'
- en: Figure 7.20 – Detailed information provided by Wicked
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – Wicked提供的详细信息
- en: To better understand this output, we recommend reading the `config` file and,
    if available, the `dhcp` files inside the `/etc/sysconfig/network` directory.
    These files provide information about specific variables and default parameters
    needed for configuring the network devices.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解该输出，我们建议您阅读`config`文件，并且如果有的话，查看`dhcp`文件，这些文件位于`/etc/sysconfig/network`目录中。它们提供了有关配置网络设备所需的特定变量和默认参数的信息。
- en: 'Dynamic IP addresses are usually set up by default when installing the operating
    system. If yours is not configured, all you need to do is create a configuration
    file inside `/etc/sysconfig/network` and give it a relevant name based on the
    device you are using to connect to the network, such as `ifcfg-eth0`. Inside that
    file, you will have to provide just three lines, as seen in *Figure 7**.19*. The
    following commands are needed for the actions described in this paragraph:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 安装操作系统时，通常默认设置动态IP地址。如果您的系统未配置动态IP地址，您只需要在`/etc/sysconfig/network`目录中创建一个配置文件，并根据您用来连接网络的设备为其命名，例如`ifcfg-eth0`。在该文件中，您只需提供三行内容，如*图
    7.19*所示。以下命令是执行本段操作所需的：
- en: 'Check your device name using the `ip` `addr` command:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ip` `addr`命令检查您的设备名称：
- en: '[PRE29]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: sudo nano /etc/sysconfig/network/ifcfg-eth0
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo nano /etc/sysconfig/network/ifcfg-eth0
- en: '[PRE30]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*   Provide relevant information for the DHCP configuration:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*   提供DHCP配置的相关信息：'
- en: '[PRE31]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*   Restart the Wicked service:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*   重启Wicked服务：'
- en: '[PRE32]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ping google.com
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ping google.com
- en: '[PRE33]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the following section, we will show you how to set up a static IP configuration.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将展示如何设置静态IP配置。
- en: Static IP configuration
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 静态IP配置
- en: To set up a static IP configuration, you would need to manually provide variables
    for the configuration files. These files are the same ones that were presented
    in the previous section. The location of the files is `/etc/sysconfig/network`.
    For example, you can create a new file for the `eth0` device connection and provide
    the information you want. Let’s look at an example of using our openSUSE Leap
    server VM. However, before doing this, we advise you to open the manual pages
    for the `ifcfg` utility as they provide valuable information on the variables
    used for this exercise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置静态IP配置，您需要手动为配置文件提供变量。这些文件与上一部分中介绍的文件相同。文件的路径是`/etc/sysconfig/network`。例如，您可以为`eth0`设备连接创建一个新文件，并提供所需的信息。让我们看一下使用我们openSUSE
    Leap服务器虚拟机的示例。但在此之前，我们建议您打开`ifcfg`工具的手册页，因为它们提供了有关本次操作所需变量的有价值信息。
- en: 'Therefore, we will set the `ifcfg` configuration file as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将按如下方式设置`ifcfg`配置文件：
- en: 'First, we will check for the IP address and the network device name; in our
    case, the dynamically allocated IP is `192.168.122.146` and the device’s name
    is `eth0`:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将检查IP地址和网络设备名称；在我们的案例中，动态分配的IP为`192.168.122.146`，设备名称为`eth0`：
- en: '![Figure 7.21 – IP and device information](img/B19682_07_21.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – IP和设备信息](img/B19682_07_21.jpg)'
- en: Figure 7.21 – IP and device information
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – IP和设备信息
- en: 'Go to the `/etc/sysconfig/network` directory and edit the `ifcfg-eth0` file;
    we will use the following variables for static IP configuration:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入`/etc/sysconfig/network`目录并编辑`ifcfg-eth0`文件；我们将使用以下变量进行静态IP配置：
- en: '`BOOTPROTO=''static''`: This allows us to use a fixed IP address that will
    be provided by using the IPADDR variable'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOTPROTO=''static''`：这允许我们使用由`IPADDR`变量提供的固定IP地址'
- en: '`STARTMODE=''auto''`: The interface will be automatically enabled on boot'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STARTMODE=''auto''`：该接口将在启动时自动启用'
- en: '`IPADDR=''192.168.122.144''`: The IP address we choose for the machine'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPADDR=''192.168.122.144''`：我们为机器选择的IP地址'
- en: '`ZONE=''public''`: The zone used by the `firewalld` utility'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZONE=''public''`：`firewalld`工具使用的区域'
- en: '`PREFIXLEN=''24''`: The number of bits in the `IPADDR` variable'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREFIXLEN=''24''`：`IPADDR`变量中的位数'
- en: 'This will look as follows:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将如下所示：
- en: '![Figure 7.22 – New variables for static IP configuration](img/B19682_07_22.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – 静态 IP 配置的新变量](img/B19682_07_22.jpg)'
- en: Figure 7.22 – New variables for static IP configuration
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 – 静态 IP 配置的新变量
- en: 'Save the changes to the new file and restart the Wicked daemon:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存更改到新文件，并重启 Wicked 守护进程：
- en: '[PRE34]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*   Enable the interface so that the changes appear:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*   启用接口，以便更改生效：'
- en: '[PRE35]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![Figure 7.23 – New IP address assigned to eth0](img/B19682_07_23.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – 新分配给 eth0 的 IP 地址](img/B19682_07_23.jpg)'
- en: Figure 7.23 – New IP address assigned to eth0
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 – 新分配给 eth0 的 IP 地址
- en: At this point, you know how to configure networking devices in all major Linux
    distributions, using their preferred utilities. We’ve merely scratched the surface
    of this matter, but we’ve provided sufficient information for you to start working
    with network interfaces in Linux. For more information, feel free to read the
    manual pages freely provided with your operating system. In the next section,
    we will approach the matter of hostname configuration.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了如何在所有主要的 Linux 发行版中配置网络设备，并使用它们首选的工具。我们仅仅触及了这个话题的表面，但已经提供了足够的信息，帮助你开始在
    Linux 中操作网络接口。更多信息，请随时阅读操作系统自带的手册页。在下一节中，我们将讨论主机名配置的问题。
- en: Hostname configuration
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 主机名配置
- en: 'To retrieve the current hostname on a Linux machine, we can use either the
    `hostname` or `hostnamectl` command, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux 机器上获取当前主机名，我们可以使用`hostname`或`hostnamectl`命令，如下所示：
- en: '[PRE36]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The most convenient way to change the hostname is with the `hostnamectl` command.
    We can change the hostname to `earth` using the `set-hostname` parameter of the
    command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 更改主机名的最便捷方法是使用`hostnamectl`命令。我们可以使用该命令的`set-hostname`参数将主机名更改为`earth`：
- en: '[PRE37]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s verify the hostname change with the `hostname` command again. You could
    use the `hostnamectl` command to verify the hostname. The output of the `hostnamectl`
    command provides more detailed information compared to the `hostname` command,
    as shown in the following screenshot:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用`hostname`命令来验证主机名的更改。你也可以使用`hostnamectl`命令来验证主机名。与`hostname`命令相比，`hostnamectl`命令的输出提供了更详细的信息，如下图所示：
- en: '![Figure 7.24 – Retrieving the current hostname with the different commands](img/B19682_07_24.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.24 – 使用不同命令获取当前主机名](img/B19682_07_24.jpg)'
- en: Figure 7.24 – Retrieving the current hostname with the different commands
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 – 使用不同命令获取当前主机名
- en: 'Alternatively, we can use the `hostname` command to change the hostname *temporarily*,
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用`hostname`命令来*临时*更改主机名，如下所示：
- en: '[PRE38]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, this change will not survive a reboot unless we also change the hostname
    in the `/etc/hostname` and `/etc/hosts` files. When editing these two files, change
    your hostname accordingly. The following screenshot shows the succession of commands:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个更改在重启后不会生效，除非我们还在`/etc/hostname`和`/etc/hosts`文件中更改主机名。在编辑这两个文件时，按照需要更改主机名。以下截图显示了命令的顺序：
- en: '![Figure 7.25 – The /etc/hostname and /etc/hosts files](img/B19682_07_25.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.25 – /etc/hostname 和 /etc/hosts 文件](img/B19682_07_25.jpg)'
- en: Figure 7.25 – The /etc/hostname and /etc/hosts files
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 – /etc/hostname 和 /etc/hosts 文件
- en: After the hostname reconfiguration, a logout followed by a login would usually
    reflect the changes. Hostnames are important for coherent network management,
    where each system on the network should have relevant hostnames set up. In the
    following section, you’ll learn about network services in Linux.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新配置主机名后，通常需要注销再登录才能反映更改。主机名在一致的网络管理中非常重要，网络上的每个系统都应该设置相关的主机名。在接下来的章节中，你将了解
    Linux 中的网络服务。
- en: Working with network services
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网络服务
- en: In this section, we’ll enumerate some of the most common network services running
    on Linux. Not all the services mentioned here are installed or enabled by default
    on your Linux platform of choice. [*Chapter 9*](B19682_09.xhtml#_idTextAnchor194),
    *Securing* *Linux*, and [*Chapter 10*](B19682_10.xhtml#_idTextAnchor212), *Disaster
    Recovery, Diagnostics, and Troubleshooting*, will dive deeper into how to install
    and configure some of them. Our focus in this section remains on what these network
    services are, how they work, and the networking protocols they use for communication.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将列出 Linux 上最常见的网络服务。并非所有这里提到的服务都在你选择的 Linux 平台上默认安装或启用。[*第 9 章*](B19682_09.xhtml#_idTextAnchor194)，*保护*
    *Linux*，和 [*第 10 章*](B19682_10.xhtml#_idTextAnchor212)，*灾难恢复、诊断和故障排除*，将深入探讨如何安装和配置其中一些服务。本节的重点仍然是这些网络服务是什么，它们如何工作，以及它们使用哪些网络协议进行通信。
- en: A **network service** is typically a system process that implements application
    layer (OSI *Layer 7*) functionality for data communication purposes. Network services
    are usually designed as peer-to-peer or client-server architectures.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络服务**通常是一个系统进程，实施应用层（OSI *第7层*）功能，用于数据通信目的。网络服务通常设计为对等或客户端-服务器架构。'
- en: In peer-to-peer networking, multiple network nodes each run their own equally
    privileged instance of a network service while sharing and exchanging a common
    set of data. Take, for example, a network of DNS servers, all sharing and updating
    their domain name records.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等网络中，多个网络节点各自运行自己同等特权的网络服务实例，同时共享和交换一组公共数据。例如，一个DNS服务器网络，所有服务器共享并更新它们的域名记录。
- en: Client-server networking usually involves one or more server nodes on a network
    and multiple clients communicating with any of these servers. An example of a
    client-server network service is SSH. An SSH client connects to a remote SSH server
    via a secure Terminal session, perhaps for remote administration purposes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器网络通常涉及一个或多个服务器节点和多个客户端与这些服务器进行通信。SSH就是一个客户端-服务器网络服务的例子。SSH客户端通过安全的终端会话连接到远程SSH服务器，可能是为了远程管理目的。
- en: Each of the following subsections briefly describes a network service, and we
    encourage you to explore topics related to these network services in [*Chapter
    13*](B19682_13.xhtml#_idTextAnchor276) or other relevant titles recommended at
    the end of this chapter. Let’s start with DHCP servers.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节简要描述了网络服务，我们鼓励你在[*第13章*](B19682_13.xhtml#_idTextAnchor276)或本章末推荐的其他相关标题中探索与这些网络服务相关的主题。我们从DHCP服务器开始。
- en: DHCP servers
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP服务器
- en: A **DHCP server** uses the DHCP protocol to enable devices on a network to request
    an IP address that’s been assigned dynamically. The DHCP protocol was briefly
    described in the *TCP/IP protocols* section earlier in this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**DHCP服务器**使用DHCP协议，使网络上的设备能够请求动态分配的IP地址。DHCP协议在本章前面的*TCP/IP协议*部分中有简要描述。'
- en: A computer or device requesting a DHCP service sends out a broadcast message
    (or query) on the network to locate a DHCP server, which, in turn, provides the
    requested IP address and other information. Communication between the DHCP client
    (device) and the server uses the DHCP protocol.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请求DHCP服务的计算机或设备会向网络发送一个广播消息（或查询），以定位DHCP服务器，后者提供所请求的IP地址和其他信息。DHCP客户端（设备）与服务器之间的通信使用DHCP协议。
- en: The DHCP protocol’s initial *discovery* workflow between a client and a server
    operates at the data link layer (*Layer 2*) in the OSI model. Since Layer 2 uses
    network frames as PDUs, the DHCP discovery packets cannot transcend the local
    network boundary. In other words, a DHCP client can only initiate communication
    with a *local* DHCP server.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP协议的初始*发现*工作流在客户端和服务器之间发生在数据链路层（*第2层*）中。由于第2层使用网络帧作为PDU，DHCP发现包无法跨越本地网络边界。换句话说，DHCP客户端只能与*本地*DHCP服务器发起通信。
- en: After the initial *handshake* (on Layer 2), DHCP turns to UDP as its transport
    protocol, using datagram sockets (*Layer 4*). Since UDP is a connectionless protocol,
    a DHCP client and server exchange messages without a prior arrangement. Consequently,
    both endpoints (client and server) require a well-known DHCP communication port
    for the back-and-forth data exchange. These are the well-known ports `68` (for
    a DHCP server) and `67` (for a DHCP client).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始的*握手*（在第2层）之后，DHCP转向UDP作为其传输协议，使用数据报套接字（*第4层*）。由于UDP是无连接协议，DHCP客户端和服务器在没有事先安排的情况下交换消息。因此，客户端和服务器的两个端点都需要一个众所周知的DHCP通信端口用于双向数据交换。这些端口是`68`（用于DHCP服务器）和`67`（用于DHCP客户端）。
- en: A DHCP server maintains a collection of IP addresses and other client configuration
    data (such as MAC addresses and domain server addresses) for each device on the
    network requesting a DHCP service.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP服务器维护一系列IP地址和其他客户端配置信息（如MAC地址和域服务器地址），用于网络上请求DHCP服务的每个设备。
- en: DHCP servers use a **leasing mechanism** to assign IP addresses dynamically.
    Leasing an IP address is subject to a **lease time**, either finite or infinite.
    When the lease of an IP address expires, the DHCP server may reassign it to a
    different client upon request. A device would hold on to its dynamic IP address
    by regularly requesting a **lease renewal** from the DHCP server. Failing to do
    so would result in the potential loss of the device’s dynamic IP address. A late
    (or post-lease) DHCP request would possibly result in a new IP address being acquired
    if the previous address had already been allocated by the DHCP server.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: DHCP 服务器使用 **租赁机制** 来动态分配 IP 地址。租赁一个 IP 地址受 **租期** 的制约，租期可以是有限的或无限的。当 IP 地址的租期到期时，DHCP
    服务器可能会根据请求将其重新分配给其他客户端。设备通过定期向 DHCP 服务器请求 **续租** 来保持其动态 IP 地址。若未及时续租，设备的动态 IP
    地址可能会丧失。延迟（或租期后）发出的 DHCP 请求可能会导致获取一个新的 IP 地址，尤其是在之前的地址已经被 DHCP 服务器分配的情况下。
- en: 'A simple way to query the DHCP server from a Linux machine is by invoking the
    following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Linux 机器查询 DHCP 服务器的一个简单方法是执行以下命令：
- en: '[PRE39]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is the output of the preceding command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面命令的输出：
- en: '![Figure 7.26 – Querying the IP route for DHCP information](img/B19682_07_26.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.26 – 查询 DHCP 信息的 IP 路由](img/B19682_07_26.jpg)'
- en: Figure 7.26 – Querying the IP route for DHCP information
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 – 查询 DHCP 信息的 IP 路由
- en: The first line of the output provides the DHCP server (`192.168.122.1`).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行提供了 DHCP 服务器（`192.168.122.1`）。
- en: '[*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring Linux Servers*,
    will further go into the practical details of installing and configuring a DHCP
    server.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第13章*](B19682_13.xhtml#_idTextAnchor276)，*配置 Linux 服务器*，将进一步介绍安装和配置 DHCP
    服务器的实际细节。'
- en: For more information on DHCP, please refer to *RFC* *2131* ([https://tools.ietf.org/html/rfc2131](https://tools.ietf.org/html/rfc2131)).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解有关 DHCP 的更多信息，请参考 *RFC* *2131*（[https://tools.ietf.org/html/rfc2131](https://tools.ietf.org/html/rfc2131)）。
- en: DNS servers
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器
- en: A `wikipedia.org`) into an IP address (such as `208.80.154.224`). The name-resolution
    protocol is DNS, briefly described in the *TCP/IP protocols* section earlier in
    this chapter. In a DNS-managed TCP/IP network, computers and devices can also
    identify and communicate with each other via hostnames, not just IP addresses.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `wikipedia.org`）将被转换为一个 IP 地址（例如 `208.80.154.224`）。名称解析协议是 DNS，在本章之前的 *TCP/IP
    协议* 部分有简要描述。在一个 DNS 管理的 TCP/IP 网络中，计算机和设备可以通过主机名进行识别和相互通信，而不仅仅是通过 IP 地址。
- en: As a reasonable analogy, DNS very much resembles an address book. Hostnames
    are relatively easier to remember than IP addresses. Even in a local network,
    with only a few computers and devices connected, it would be rather difficult
    to identify (or memorize) any of the hosts by simply using their IP address. The
    internet relies on a globally distributed network of DNS servers.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个合理的类比，DNS 非常像一本地址簿。主机名比 IP 地址更容易记住。即使在一个局部网络中，只有几台计算机和设备连接，单纯使用 IP 地址识别（或记住）任何主机也会相当困难。互联网依赖于一个全球分布的
    DNS 服务器网络。
- en: 'There are four different types of DNS servers: **recursive servers**, **root
    servers**, **top-level domain** (**TLD**) **servers**, and **authoritative servers**.
    All these DNS server types work together to bring you the internet as you experience
    it in your browser.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 服务器有四种不同类型：**递归服务器**、**根服务器**、**顶级域**（**TLD**）**服务器**和**权威服务器**。所有这些 DNS
    服务器类型共同协作，将你带入浏览器中所体验到的互联网。
- en: A **recursive DNS server** is a resolver that helps you find the destination
    (IP) of a website you search for. When you perform a lookup operation, a recursive
    DNS server is connected to different DNS servers to find the IP address that you
    are looking for and return it to you in the form of a website. Recursive DNS lookups
    are faster as they cache every query that they perform. In a recursive type of
    query, the DNS server calls itself and does the recursion while still sending
    the request to another DNS server to find the answer.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归 DNS 服务器**是一个解析器，帮助你查找你搜索的网站的目标（IP）。当你执行查询操作时，递归 DNS 服务器会连接到不同的 DNS 服务器，以找到你正在寻找的
    IP 地址，并以网站的形式将其返回给你。递归 DNS 查询更快速，因为它们缓存了每一个执行过的查询。在递归类型的查询中，DNS 服务器会调用自身并进行递归，同时仍然将请求发送给另一个
    DNS 服务器以找到答案。'
- en: 'In contrast, an **iterative DNS** lookup is done by every DNS server directly,
    without using caching. For example, in an iterative query, each DNS server responds
    with the address of another DNS server, until one of them has the matching IP
    address for the hostname in question and responds to the client. For more details
    on DNS server types, please check out the following Cloudflare learning solution:
    [https://www.cloudflare.com/learning/dns/what-is-dns/](https://www.cloudflare.com/learning/dns/what-is-dns/).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: DNS servers maintain (and possibly share) a collection of `/etc/resolv.conf`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the DNS server managing the local machine, we can query the `/etc/resolv.conf`
    file by running the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code yields the following output:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Querying DNS server using /etc/resolv.conf](img/B19682_07_27.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Querying DNS server using /etc/resolv.conf
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: A simple way to query name-server data for an arbitrary host on a network is
    by using the `nslookup` tool. If you don’t have the `nslookup` utility installed
    on your system, you may do so with the commands outlined here.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian, run the following command:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On Fedora, run this command:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For example, to query the name-server information for a computer named `neptune.local`
    in our local network, we can run the following command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is shown here:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Querying name-server information with nslookup](img/B19682_07_28.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – Querying name-server information with nslookup
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `nslookup` tool interactively. For example, to query the
    name-server information for `wikipedia.org`, we can simply run the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, in the interactive prompt, we must enter `wikipedia.org`, as illustrated
    here:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – Using the nslookup tool interactively](img/B19682_07_29.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – Using the nslookup tool interactively
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'To exit the interactive shell mode, press *Ctrl* + *C*. Here’s a brief explanation
    of the information shown in the preceding output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '`127.0.0.53`) and port (`53`) of the DNS server running locally'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wikipedia.org`)'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`91.198.174.192`) and IPv6 (`2620:0:862:ed1a::1`) addresses that correspond
    to the lookup domain (`wikipedia.org`)'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nslookup` is also capable of reverse DNS search when providing an IP address.
    The following command retrieves the name server (`dns.google`) corresponding to
    the IP address `8.8.8.8`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding command yields the following output:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – Reverse DNS search with nslookup](img/B19682_07_30.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
- en: Figure 7.30 – Reverse DNS search with nslookup
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the `nslookup` tool, you can refer to the `nslookup`
    system reference manual (`man nslookup`).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use the `dig` command-line utility. If you don’t have
    the `dig` utility installed on your system, you can do so by installing the `dnsutils`
    package on Ubuntu/Debian or `bind-utils` on Fedora platforms. The related commands
    for installing the packages were shown previously with `nslookup`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following command retrieves the name-server information for
    the `google.com` domain:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is the result (see the highlighted `ANSWER SECTION`):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – DNS lookup with dig](img/B19682_07_31.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: Figure 7.31 – DNS lookup with dig
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a reverse DNS lookup with `dig`, we must specify the `-x` option,
    followed by an IP address (for example, `8.8.4.4`), as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This command yields the following output (see the highlighted `ANSWER SECTION`):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Reverse DNS lookup with dig](img/B19682_07_32.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: Figure 7.32 – Reverse DNS lookup with dig
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the `dig` command-line utility, please refer to the
    related system manual (`man dig`).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The DNS protocol operates at the application layer (*Layer 7*) in the OSI model.
    The standard DNS service’s well-known port is `53`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19682_08.xhtml#_idTextAnchor164), *Linux* *Shell Scripting*,
    will cover the practical details of installing and configuring a DNS server in
    more detail. For more information on DNS, you can refer to *RFC* *1035* ([https://www.ietf.org/rfc/rfc1035.txt](https://www.ietf.org/rfc/rfc1035.txt)).'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The DHCP and DNS network services are arguably the closest to the TCP/IP networking
    stack while playing a crucial role when computers or devices are attached to a
    network. After all, without proper IP addressing and name resolution, there’s
    no network communication.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to distributed networking and related application servers
    than just strictly the pure network management stack performed by DNS and DHCP
    servers. In the following sections, we’ll take a quick tour of some of the most
    relevant application servers running across distributed Linux systems.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Authentication servers
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Standalone Linux systems typically use the default authentication mechanism,
    where user credentials are stored in the local filesystem (such as `/etc/passwd`
    and `/etc/shadow`). We explored the related user authentication internals in [*Chapter
    4*](B19682_04.xhtml#_idTextAnchor090), *Managing* *Users and Groups*. However,
    as we extend the authentication boundary beyond the local machine – for example,
    accessing a file or email server – having the user credentials shared between
    the remote and localhosts would become a serious security issue.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, we should have a centralized authentication endpoint across the network
    that’s handled by a secure authentication server. User credentials should be validated
    using robust encryption mechanisms before users can access remote system resources.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the secure access to a network share on an arbitrary file server.
    Suppose the access requires **Active Directory** (**AD**) user authentication.
    Creating the related mount (share) locally on a user’s client machine will prompt
    for user credentials. The authentication request is made by the file server (on
    behalf of the client) to an authentication server. If the authentication succeeds,
    the server share becomes available to the client. The following diagram represents
    a simple remote authentication flow between a client and a server, using a **Lightweight
    Directory Access Protocol** (**LDAP**) authentication endpoint:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Authentication workflow with LDAP](img/B19682_07_33.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: Figure 7.33 – Authentication workflow with LDAP
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of standard secure authentication platforms (available
    for Linux):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**Kerberos** ([https://web.mit.edu/kerberos/](https://web.mit.edu/kerberos/))'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LDAP** ([https://www.redhat.com/en/topics/security/what-is-ldap-authentication](https://www.redhat.com/en/topics/security/what-is-ldap-authentication))'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote Authentication Dial-In User Service** (**RADIUS**) ([https://freeradius.org/documentation/](https://freeradius.org/documentation/))'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diameter** ([https://www.f5.com/glossary/diameter-protocol](https://www.f5.com/glossary/diameter-protocol))'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal Access Controller Access-Control System** (**TACACS+**) ([https://datatracker.ietf.org/doc/rfc8907/](https://datatracker.ietf.org/doc/rfc8907/))'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux LDAP authentication server can be configured using OpenLDAP, which was
    covered in the first edition of this book.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we illustrated the authentication workflow with an example
    of using a file server. To remain on topic, we’ll look at network file-sharing
    services next.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: File sharing
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: In common networking terms, **file sharing** represents a client machine’s ability
    to *mount* and access a remote filesystem belonging to a server, as if it were
    local. Applications running on the client machine would access the shared files
    directly on the server. For example, a text editor can load and modify a remote
    file, and then save it back to the same remote location, all in a seamless and
    transparent operation. The underlying remoting process – the appearance of a remote
    filesystem acting as local – is made possible by file-sharing services and protocols.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: For every file-sharing network protocol, there is a corresponding client-server
    file-sharing platform. Although most network file servers (and clients) have cross-platform
    implementations, some operating system platforms are better suited for specific
    file-sharing protocols, as we’ll see in the following subsections. Choosing between
    different file-server implementations and protocols is ultimately a matter of
    compatibility, security, and performance.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the most common file-sharing protocols, with some brief descriptions
    for each:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '**Server Message Block** (**SMB**): The SMB protocol provides network discovery
    and file- and printer-sharing services. SMB also supports interprocess communication
    over a network. SMB is a relatively old protocol, developed by **International
    Business Machines Corporation** (**IBM**) in the 1980s. Eventually, Microsoft
    took over and made some considerable alterations to what became the current version
    through multiple revisions (SMB 1.0, 2.0, 2.1, 3.0, 3.0.2, and 3.1.1).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Internet File System** (**CIFS**): This protocol is a particular implementation
    of the SMB protocol. Due to the underlying protocol similarity, SMB clients can
    communicate with CIFS servers and vice versa. Though SMB and CIFS are idiomatically
    the same, their internal implementation of file locking, batch processing, and
    – ultimately – performance is quite different. Apart from legacy systems, CIFS
    is rarely used these days. SMB should always be preferred over CIFS, especially
    with the more recent revisions of SMB 2 or SMB 3.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Samba**: As with CIFS, Samba is another implementation of the SMB protocol.
    Samba provides file- and print-sharing services for Windows clients on a variety
    of server platforms. In other words, Windows clients can seamlessly access directories,
    files, and printers on a Linux Samba server, just as if they were communicating
    with a Windows server.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of version 4, Samba natively supports Microsoft AD and Windows NT domains.
    Essentially, a Linux Samba server can act as a domain controller on a Windows
    AD network. Consequently, user credentials on the Windows domain can transparently
    be used on the Linux server without being recreated, and then manually kept in
    sync with the AD users.
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Network File System** (**NFS**): This protocol was developed by Sun Microsystems
    and essentially operates on the same premise as SMB – accessing files over a network
    as if they were local. NFS is not compatible with CIFS or SMB, meaning that NFS
    clients cannot communicate directly with SMB servers or vice versa.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apple Filing Protocol** (**AFP**): The AFP is a proprietary file-sharing
    protocol designed by Apple and exclusively operates in macOS network environments.
    We should note that besides AFP, macOS systems also support standard file-sharing
    protocols, such as SMB and NFS.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the time, NFS is the file-sharing protocol of choice within Linux networks.
    For mixed networking environments – such as Windows, Linux, and macOS interoperability
    – Samba and SMB are best suited for file sharing.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Some file-sharing protocols (such as SMB) also support print sharing and are
    used by print servers. We’ll take a closer look at print sharing next.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Printer servers
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'A **printer server** (or **print server**) connects a printer to client machines
    (computers or mobile devices) on a network using a printing protocol. Printing
    protocols are responsible for the following remote printing tasks over a network:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Discovering printers or print servers
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying printer status
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending, receiving, queueing, or canceling print jobs
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying print job status
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common printing protocols include the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '**Line Printer Daemon** (**LPD**) protocol'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generic protocols**, such as SMB and TELNET'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wireless printing**, such as AirPrint by Apple'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet printing protocols**, such as Google Cloud Print'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the generic printing protocols, SMB (also a file-sharing protocol) was
    previously described in the *File sharing* section. The TELNET communication protocol
    was described in the *Remote* *access* section.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: File- and printer-sharing services are mostly about *sharing* documents, digital
    or printed, between computers on a network. When it comes to *exchanging* documents,
    additional network services come into play, such as *file transfer* and *email*
    services. We’ll look at file transfer next.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: File transfer
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: FTP is a standard network protocol for transferring files between computers
    on a network. FTP operates in a client-server environment, where an FTP client
    initiates a remote connection to an FTP server, and files are transferred in either
    direction. FTP maintains a `21`, and it’s used for exchanging commands between
    the client and the server. Data connections are exclusively used for data transfer
    and are negotiated between the client and the server (through the control connection).
    Data connections usually involve ephemeral ports for inbound traffic, and they
    only stay open during the actual data transfer, closing immediately after the
    transfer completes.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP negotiates data connections in one of the following two modes:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '`PORT` command to the FTP server, signaling that the client *actively* provides
    the inbound port number for data connections'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PASV` command to the FTP server, indicating that the client *passively* awaits
    the server to supply the port number for inbound data connections'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP is a relatively *messy* protocol when it comes to firewall configurations
    due to the dynamic nature of the data connections involved. The control connection
    port is usually well known (such as port `21` for insecure FTP) but data connections
    originate on a different port (usually `20`) on either side, while on the receiving
    end, the inbound sockets are opened within a preconfigured ephemeral range (`1024`
    to `65535`).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'FTP is most often implemented securely through either of the following approaches:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '`990`.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`22`. For more information on the SSH protocol and client-server connectivity,
    refer to *SSH* in the *Remote access* section, later in this chapter.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll look at mail servers and the underlying email exchange protocols.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Mail servers
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: A **mail server** (or **email server**) is responsible for email delivery over
    a network. A mail server can either exchange emails between clients (users) on
    the same network (domain) – within a company or organization – or deliver emails
    to other mail servers, possibly beyond the local network, such as the internet.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'An email exchange usually involves the following actors:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: An **email client** application (such as Outlook or Gmail)
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more **mail servers** (Exchange or Gmail server)
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **recipients** involved in the email exchange – a *sender* and one or more
    *receivers*
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **email protocol** that controls the communication between the email client
    and the mail servers
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most used email protocols are **POP3**, **IMAP**, and **SMTP**. Let’s take
    a closer look at each of these protocols.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: POP3
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '**POP version 3** (**POP3**) is a standard email protocol for receiving and
    downloading emails from a remote mail server to a local email client. With POP3,
    emails are available for reading offline. After being downloaded, emails are usually
    removed from the POP3 server, thus saving up space. Modern-day POP3 mail client-server
    implementations (Gmail, Outlook, and others) also have the option of keeping email
    copies on the server. Persisting emails on the POP3 server becomes very important
    when users access emails from multiple locations (client applications).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'The default POP3 ports are outlined here:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '`110`: For insecure (non-encrypted) POP3 connections'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`995`: For secure POP3 using SSL/TLS encryption'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: POP3 is a relatively old email protocol that’s not always suitable for modern-day
    email communications. When users access their emails from multiple devices, IMAP
    is a better choice. We’ll look at the IMAP email protocol next.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: IMAP
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: IMAP is a standard email protocol for accessing emails on a remote IMAP mail
    server. With IMAP, emails are always retained on the mail server, while a copy
    of the emails is available for IMAP clients. A user can access emails on multiple
    devices, each with their IMAP client application.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'The default IMAP ports are outlined here:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '`143`: For insecure (non-encrypted) IMAP connections'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`993`: For secure IMAP using SSL/TLS encryption'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both POP3 and IMAP are standard protocols for receiving emails. To send emails,
    SMTP comes into play. We’ll take a look at the SMTP email protocol next.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: SMTP
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: SMTP is a standard email protocol for sending emails over a network or the internet.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The default SMTP ports are outlined here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '`25`: For insecure (non-encrypted) SMTP connections'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`465` or `587`: For secure SMTP using SSL/TLS encryption'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using or implementing any of the standard email protocols described in
    this section, it is always recommended to use the corresponding secure implementation
    with the most up-to-date TLS encryption, if possible. POP3, IMAP, and SMTP also
    support user authentication, an added layer of security – this is also recommended
    in commercial or enterprise-grade environments.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: To get an idea of how the SMTP protocol operates, let’s go through some of the
    initial steps for initiating an SMTP handshake with Google’s Gmail SMTP server.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by connecting to the Gmail SMTP server, using a secure (TLS)
    connection via the `openssl` command, as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we invoked the `openssl` command, simulated a client (`s_client`), started
    a TLS SMTP connection (`-starttls smtp`), and connected to the remote Gmail SMTP
    server on port `587` `(-``connect smtp.gmail.com:587`).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gmail SMTP server responds with a relatively long TLS handshake block that
    ends with the following code:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – Initial TLS handshake with a Gmail SMTP server](img/B19682_07_34.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: Figure 7.34 – Initial TLS handshake with a Gmail SMTP server
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'While still inside the `openssl` command’s interactive prompt, we initiate
    the SMTP communication with a `HELO` command (spelled precisely as such). The
    `HELO` command *greets* the server. It is a specific SMTP command that starts
    the SMTP connection between a client and a server. There is also an `EHLO` variant,
    which is used for ESMTP service extensions. Google expects the following `HELO`
    greeting:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another handshake follows, ending with `250 smtp.gmail.com at your service`,
    as illustrated here:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35 – The Gmail SMTP server is ready for communication](img/B19682_07_35.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
- en: Figure 7.35 – The Gmail SMTP server is ready for communication
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Next, the Gmail SMTP server requires authentication via the `AUTH LOGIN` SMTP
    command. We won’t go into further details, but the key point to be made here is
    that the SMTP protocol follows a plaintext command sequence between the client
    and the server. It’s very important to adopt a secure (encrypted) SMTP communication
    channel using TLS. The same applies to any of the other email protocols (POP3
    and IMAP).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve covered several network services, some of them spanning multiple
    networks or even the internet. Network packets carry data and destination addresses
    within the payload, but there are also synchronization signals between the communication
    endpoints, mostly to discern between sending and receiving workflows. The synchronization
    of network packets is based on timestamps. Reliable network communications would
    not be possible without a highly accurate time-synchronization between network
    nodes. We’ll look at network timekeepers next.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: NTP servers
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: NTP is a standard networking protocol for clock synchronization between computers
    on a network. NTP attempts to synchronize the system clock on participating computers
    within a few milliseconds of **Coordinated Universal Time** (**UTC**) – the world’s
    time reference.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: The NTP protocol’s implementation usually assumes a client-server model. An
    NTP server acts as a time source on the network by either broadcasting or sending
    updated **timestamp datagrams** to clients. An NTP server continually adjusts
    its system clock according to well-known accurate time servers worldwide, using
    specialized algorithms to mitigate network latency.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'A relatively easy way to check the NTP synchronization status on our Linux
    platform of choice is by using the `ntpstat` utility. `ntpstat` may not be installed
    by default on our system. On Ubuntu, we can install it with the following command:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On Fedora, we can install `ntpstat` with the following command:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`ntpstat` requires an NTP server to be running locally. To set up a local NTP
    server, you will need to do the following (all examples shown here are for Ubuntu
    22.04.2 LTS):'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `ntp` package with the following command:'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'ntp service:'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '*   Modify the firewall settings:'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'ntp service:'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Before installing the `ntp` utility, take into account that Ubuntu is using
    another tool instead of `ntpd` by default, named `timesyncd`. When installing
    `ntpd`, the default utility will be disabled.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the NTP synchronization status, we can run the following command:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is the output:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36 – Querying the NTP synchronization status with ntpstat](img/B19682_07_36.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_IMG
- en: Figure 7.36 – Querying the NTP synchronization status with ntpstat
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: '`ntpstat` provides the IP address of the NTP server the system is synchronized
    with (`31.209.85.242`), the synchronization margin (`29` milliseconds), and the
    time-update polling interval (`64` seconds). To find out more about the NTP server,
    we can `dig` its IP address with the following command:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It looks like it’s one of the `lwlcom` time servers (`ntp1.lwlcom.net`), as
    shown here:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37 – Querying the NTP synchronization status with ntpstat](img/B19682_07_37.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
- en: Figure 7.37 – Querying the NTP synchr[onization status with ntpstat](https://en.wikipedia.org/wiki/Network_Time_Protocol)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[The NTP client-server](https://en.wikipedia.org/wiki/Network_Time_Protocol)
    communication uses UDP as the transport protocol on port `123`. [*Chapter 9*](B19682_09.xhtml#_idTextAnchor194),
    *Securing* *Linux*, has a section dedicated to installing and configuring an NTP
    server. For more information on NTP, you can refer to [https://en.wikipedia.org/wiki/Network_Time_Protocol](https://en.wikipedia.org/wiki/Network_Time_Protocol).'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: With that, our brief journey into networking servers and protocols has come
    to an end. Everyday Linux administration tasks often require some sort of remote
    access to a system. There are many ways to access and manage computers remotely.
    The next section describes some of the most common remote-access facilities and
    related network protocols.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Remote access
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux network services provide a relatively limited **remote management**
    interface, with their management **command-line interface** (**CLI**) utilities
    predominantly operating locally on the same system where the service runs. Consequently,
    the related administrative tasks assume local Terminal access. Direct console
    access to the system is sometimes not possible. This is when remote-access servers
    come into play to enable a virtual Terminal login session with the remote machine.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some of the most common remote-access services and applications.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: SSH
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: SSH is perhaps the most popular secure login protocol for remote access. SSH
    uses strong encryption, combined with user authentication mechanisms, for secure
    communication between a client and a server machine. SSH servers are relatively
    easy to install and configure, and the *Setting up an SSH server* section in [*Chapter
    13*](B19682_13.xhtml#_idTextAnchor276), *Configuring Linux Servers*, is dedicated
    to describing the related steps. The default network port for SSH is `22`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH supports the following authentication types:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Public-key authentication
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password authentication
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard-interactive authentication
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections provide brief descriptions of these forms of SSH authentication.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Public-key authentication
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '**Public-key authentication** (or **SSH-key authentication**) is arguably the
    most common type of SSH authentication.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: This section will use the terms *public-key* and *SSH-key* interchangeably,
    mostly to reflect the related SSH authentication nomenclature in the Linux community.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The SSH-key authentication mechanism uses a *certificate/key* pair – a `ssh-keygen`
    tool, using standard encryption algorithms such as the **Rivest–Shamir–Adleman**
    algorithm (**RSA**) or the **Digital Signature** **Algorithm** (**DSA**).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: The SSH public-key authentication supports either **user-based authentication**
    or **host-based authentication** models. The two models differ in the ownership
    of the certificate/key pairs involved. With client authentication, each user has
    a certificate/key pair for SSH access. On the other hand, host authentication
    involves a single certificate/key pair per system (host).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'Both SSH-key authentication models are illustrated and explained in the following
    sections. The basic SSH handshake and authentication workflows are the same for
    both models:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: First, the SSH client generates a secure certificate/key pair and shares its
    public key with the SSH server. This is a one-time operation for enabling public-key
    authentication.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a client initiates the SSH handshake, the server asks for the client’s
    public key and verifies it against its allowed public keys. If there’s a match,
    the SSH handshake succeeds, the server shares its public key with the client,
    and the SSH session is established.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further client-server communication follows standard encryption/decryption workflows.
    The client encrypts the data with its private key, while the server decrypts the
    data with the client’s public key. When responding to the client, the server encrypts
    the data with its own private key, and the client decrypts the data with the server’s
    public key.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH public-key authentication is also known as **passwordless authentication**,
    and it’s frequently used in automation scripts where commands are executed over
    multiple remote SSH connections without prompting for a password.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the user-based and host-based public-key authentication
    mechanisms:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '**User-based authentication**: This is the most common SSH public-key authentication
    mechanism. According to this model, every user connecting to a remote SSH server
    has its own SSH key. Multiple user accounts on the same host (or domain) would
    have different SSH keys, each with its own access to the remote SSH server, as
    suggested in the following figure:'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.38 – User-based key authentication](img/B19682_07_38.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
- en: Figure 7.38 – User-based key authentication
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '**Host-based authentication**: This is another form of SSH public-key authentication
    and involves a single SSH key per system (host) to connect to a remote SSH server,
    as illustrated in the following figure:'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.39 – Host-based key authentication](img/B19682_07_39.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: Figure 7.39 – Host-based key authentication
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: With host-based authentication, the underlying SSH key can only authenticate
    SSH sessions that originated from a single client host. Host-based authentication
    allows multiple users to connect from the same host to a remote SSH server. If
    a user attempts to use a host-based SSH key from a different machine than the
    one allowed by the SSH server, access will be denied.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a mix of the two public-key authentications is used – user- and host-based
    authentication –an approach that provides an increased level of security to SSH
    access.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: When security is not critical, simpler SSH authentication mechanisms could be
    more suitable. Password authentication is one such mechanism.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Password authentication
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/passwd`) or select user accounts defined in the SSH server configuration
    (`/etc/ssh/sshd_config`). The SSH server configuration described in [*Chapter
    9*](B19682_09.xhtml#_idTextAnchor194), *Securing* *Linux*, further elaborates
    on this subject.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: Besides local authentication, SSH can also leverage remote authentication methods
    such as Kerberos, LDAP, RADIUS, and others. In such cases, the SSH server delegates
    the user authentication to a remote authentication server, as described in the
    *Authentication servers* section earlier in this chapter.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Password authentication requires either user interaction or some automated way
    to provide the required credentials. Another similar authentication mechanism
    is keyboard-interactive authentication, described next.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard-interactive authentication
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '**Keyboard-interactive authentication** is based on a dialogue of multiple
    challenge-response sequences between the SSH client (user) and the SSH server.
    This dialogue is a plaintext exchange of questions and answers, where the server
    may prompt the user for any number of challenges. In some respect, password authentication
    is a **single-challenge interactive** **authentication** mechanism.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The *interactive* connotation of this authentication method could lead us to
    think that user interaction would be mandatory for the related implementation.
    Not really. Keyboard-interactive authentication could also serve implementations
    of authentication mechanisms based on custom protocols, where the underlying message
    exchange would be modeled as an authentication protocol.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to other remote access protocols, we should call out the wide
    use of SSH due to its security, versatility, and performance. However, SSH connectivity
    may not always be possible or adequate in specific scenarios. In such cases, *TELNET*
    may come to the rescue. We’ll take a look at it next.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: TELNET
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '**TELNET** is an application-layer protocol for bidirectional network communication
    that uses a plaintext CLI with a remote host. Historically, TELNET was among the
    first remote-connection protocols, but it always lacked secure implementation.
    SSH eventually became the standard way to log in from one computer to another,
    yet TELNET has its advantages over SSH when it comes to troubleshooting various
    application-layer protocols, such as web- or email-server communication. You will
    learn more about how to use TELNET in [*Chapter 9*](B19682_09.xhtml#_idTextAnchor194),
    *Securing* *Linux*.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: TELNET and SSH are command-line-driven remote-access interfaces. There are cases
    when a direct desktop connection is needed to a remote machine through a **graphical
    user interface** (**GUI**). We’ll look at desktop sharing next.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: VNC
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Network Computing** (**VNC**) is a desktop-sharing platform that
    allows users to access and control a remote computer’s GUI. VNC is a cross-platform
    client-server application. A VNC server running on a Linux machine, for example,
    allows desktop access to multiple VNC clients running on Windows or macOS systems.
    The VNC network communication uses the **Remote Framebuffer** (**RFB**) protocol,
    defined by *RFC 6143*. Setting up a VNC server is relatively simple. VNC assumes
    the presence of a graphical desktop system. More details on this will be provided
    in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring* *Linux Servers*.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our section about network services and protocols. We tried to
    cover the most common concepts about general-purpose network servers and applications,
    mostly operating in a client-server or distributed fashion. With each network
    server, we described the related network protocols and some of the internal aspects
    involved. [*Chapter 9*](B19682_09.xhtml#_idTextAnchor194), *Securing Linux*, and
    [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring Linux Servers*,
    will showcase practical implementations for some of these network servers.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, our focus will turn to network security internals.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Understanding network security
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '**Network security** represents the processes, actions, and policies to prevent,
    monitor, and protect unauthorized access to computer networks. Network security
    paradigms span a vast array of technologies, tools, and practices. Here are a
    few important ones:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '**Access control**: Selectively restricting access based on user authentication
    and authorization mechanisms. Examples of access control include users, groups,
    and permissions. Some of the related concepts were covered in [*Chapter 4*](B19682_04.xhtml#_idTextAnchor090),
    *Managing* *Users* *and Groups*.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application security**: Securing and protecting server and end user applications
    (email, web, and mobile apps). Examples of application security include **Security-Enhanced
    Linux** (**SELinux**), strongly encrypted connections, antivirus, and anti-malware
    programs. We’ll cover **SELinux** in [*Chapter 10*](B19682_10.xhtml#_idTextAnchor212),
    *Disaster Recovery, Diagnostics,* *and Troubleshooting*.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endpoint security**: Securing and protecting servers and end user devices
    (smartphones, laptops, and desktop PCs) on the network. Examples of endpoint security
    include *firewalls* and various intrusion-detection mechanisms. We’ll look at
    firewalls in [*Chapter 10*](B19682_10.xhtml#_idTextAnchor212), *Disaster Recovery,
    Diagnostics,* *and Troubleshooting*.'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network segmentation**: Partitioning computer networks into smaller segments
    or **virtual LANs** (**VLANs**). This is not to be confused with subnetting, which
    is a logical division of networks through addressing.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VPNs**: Accessing corporate networks using a secure encrypted tunnel from
    public networks or the internet. We’ll look at VPNs in more detail in [*Chapter
    9*](B19682_09.xhtml#_idTextAnchor194), *Securing Linux*, and [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276),
    *Configuring* *Linux Servers*.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In everyday Linux administration, setting up a network security perimeter should
    always follow the paradigms enumerated previously, roughly in the order listed.
    Starting with access-control mechanisms and ending with VPNs, securing a network
    takes an *inside-out* approach, from local systems and networks to firewalls,
    VLANs, and VPNs.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provided a relatively condensed view of basic Linux networking
    principles. We learned about network communication layers and protocols, IP addressing
    schemes, TCP/IP configurations, well-known network application servers, and VPN.
    A good grasp of networking paradigms will give Linux administrators a more comprehensive
    view of the distributed systems and underlying communication between the application
    endpoints involved.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Some of the theoretical aspects covered in this chapter will be taken for a
    practical spin in [*Chapter 13*](B19682_13.xhtml#_idTextAnchor276), *Configuring
    Linux Servers*, where we’ll focus on real-world implementations of network servers.
    [*Chapter 10*](B19682_10.xhtml#_idTextAnchor212), *Disaster Recovery, Diagnostics,
    and Troubleshooting*, will further explore network security internals and practical
    Linux firewalls. Everything we have learned so far will serve as a good foundation
    for the assimilation of these upcoming chapters.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: The following chapter will introduce you to Linux shell scripting, where you
    will learn about the most common shell features and how to use decisions, loops,
    variables, arrays, and functions.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick quiz to outline and test some of the essential concepts covered
    in this chapter:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: How does the OSI model compare to the TCP/IP model?
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: *Figure 7**.2* could be of help.'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Think of a couple of TCP/IP protocols and try to see where and how they operate
    in some of the network administration tasks or applications you are familiar with.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At what networking layer does the HTTP protocol operate? How about DNS?
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Both operate on the same layer.'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the network class for IP address `192.168.0.1`?
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Refer to *Figure 7**.5*.'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the network prefix that corresponds to network mask `255.255.0.0`?
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: Check out *Figure* *7**.5* again.'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you configure a static IP address using the `nmcli` utility?
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connection modify`.'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How do you change the hostname of a Linux machine?
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`hostnamectl` utility.'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What is the difference between the POP3 and IMAP email protocols?
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does SSH host-based authentication differ from user-based SSH key authentication?
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between SSH and TELNET?
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about what was covered in this chapter, please refer to
    the following Packt titles:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '*Linux Administration Best Practices*, by Scott Alan Miller'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux for Networking Professionals*, by Rob VandenBrink'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
