<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Users – Do We Really Want Them?</h1></div></div></div><p>The question, I admit, is more than a little rhetorical but there are times when we dream of how great our lives would be without pesky users getting in the way and gumming up the cogs that make our systems run; however, the better we manage the user base on our Linux systems, the better CentOS will be to us. In reality, the more control we have over the users, the more life is better for them as they can continue their work uninterrupted by system downtime.</p><p>In this chapter, we will develop techniques to maintain unobtrusive control of our systems, keeping ourselves sane and the users happy. This will include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Managing public and private groups</strong>: Understanding how we can use public groups and overriding the CentOS default of private groups can give us more scope in assigning permissions to users. We have to be aware of the potential pitfalls to each solution.</li><li class="listitem" style="list-style-type: disc"><strong>Getent</strong>: This <a class="indexterm" id="id248"/>can provide us with a global view of our users and groups and will open up to us in this chapter the understanding of the name services switch file: <code class="literal">nsswitch.conf</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Quotas</strong>: Using <a class="indexterm" id="id249"/>quotas can allow us to both monitor and if required, restrict users' space to a partition, and is truly important where users' home directories are located.</li><li class="listitem" style="list-style-type: disc"><strong>Scripting user creation</strong>: When creating a user, we will need to set the password <a class="indexterm" id="id250"/>and possibly user's disk quota limits; it makes sense then to combine all these activities into a script so that nothing is forgotten.</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Managing public and private groups</h1></div></div></div><p>The Red Hat and, therefore, the CentOS user management systems deploy a private user group system. Each <a class="indexterm" id="id251"/>user created will also belong to an eponymous<a class="indexterm" id="id252"/> primary group; in other words, creating<a class="indexterm" id="id253"/> a user bob will also create a<a class="indexterm" id="id254"/> group<a class="indexterm" id="id255"/> bob, to which the user will be the only member.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec37"/>Linux groups</h2></div></div></div><p>Firstly, we<a class="indexterm" id="id256"/> have to understand a little about Linux <a class="indexterm" id="id257"/>groups. A user has both a primary group and secondary<a class="indexterm" id="id258"/> groups.</p><p>
<strong>User ID and group ID</strong> (<strong>UID/GID</strong>) are used with the permission management structure in Linux. Every<a class="indexterm" id="id259"/> file in any filesystem will be owned by a user and a group by means<a class="indexterm" id="id260"/> of storing the UID and GID in the files metadata. Permissions can be assigned to the user, group, or others.</p><p>Each user has one UID and GID but belongs to just one group, which is a little restrictive, so users additionally have secondary groups. Users can change their current GID to one from their secondary groups using the <code class="literal">/usr/bin/newgrp</code> command, effectively switching their GID. In practice, this is not required <a class="indexterm" id="id261"/>and leads us to describing the differences between the users' primary group and secondary groups.</p><p>When creating a new file, the users UID and their current GID are used to create the ownership of the new file. If a user creates a new file, he/she will be the owner of that file and the file will be group owned by his/her own private group, creating an inherently secure system without the need of user intervention. Secondary groups are used in all other situations when accessing resources that <em>currently</em> exist. Users present all of their secondary groups when accessing a resource. In this way, a file that is readable by the <code class="literal">users</code> group but not to <code class="literal">others</code> will be accessible to a user whose GID is set to his/her own private group, but the list of secondary groups to which they belong includes the <code class="literal">users</code> group.</p><p>When assessing a user's ID, setting the <code class="literal">/usr/bin/id</code> command can be very useful. Run without any options or arguments and the output will display your own associated IDs. In the following screenshot, we can see that the user <code class="literal">andrew</code> belongs to only the private user group and has no additional secondary group memberships:</p><div><pre class="programlisting">
<strong>$ id</strong>
</pre></div><div><img alt="Linux groups" src="img/5920OS_06_01.jpg"/></div><p>We will <a class="indexterm" id="id262"/>use the same command but this time we <a class="indexterm" id="id263"/>will use the user, <code class="literal">u1</code>, as an argument. The output will show the associated IDs of that account; this command can be run as a standard user:</p><div><pre class="programlisting">
<strong>$ id u1</strong>
</pre></div><p>From the following screenshot, we can see that the user, <code class="literal">u1</code>, has the primary group or GID assigned to the private group <code class="literal">u1</code>; however, <code class="literal">u1</code> additionally belongs to the <code class="literal">users</code> group.</p><div><img alt="Linux groups" src="img/5920OS_06_02.jpg"/></div><p>With the current IDs in place for the user <code class="literal">u1</code>, any new file created will be group owned by GID 501 (<code class="literal">u1</code>), but <code class="literal">u1</code> can access any resource accessible to the <code class="literal">users</code> and <code class="literal">u1</code> groups without any additional action on <code class="literal">u1</code>'s part. From an administrative perspective, we need to make sure we assign the correct secondary IDs to our users.</p><p>The same cannot be said for the first example that we looked at. The user, <code class="literal">andrew</code>, currently belongs only to <code class="literal">andrew</code>'s private group, so he can only access resources where permissions are set to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Their UID (<code class="literal">andrew</code>)</li><li class="listitem" style="list-style-type: disc">Their private GID (<code class="literal">andrew</code>)</li><li class="listitem" style="list-style-type: disc">Others</li></ul></div><p>The user account <code class="literal">andrew</code> does not have access to permissions assigned to the <code class="literal">users</code> group<a class="indexterm" id="id264"/> in the same way that the user <code class="literal">u1</code> does.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Adding users to groups</h2></div></div></div><p>We can <a class="indexterm" id="id265"/>now see that the user <code class="literal">u1</code> has the desired<a class="indexterm" id="id266"/> access to resources shared with the <code class="literal">users</code> groups, but what about <code class="literal">andrew</code>? How can we help here?</p><p>If the user<a class="indexterm" id="id267"/> already exists and we need to add him/her to a public group, then we can use the <code class="literal">usermod</code> command to add the user to an additional group. When we add <code class="literal">andrew</code> to the <code class="literal">users</code> group, we will also want to maintain any existing secondary groups' memberships.</p><p>Run the following command:</p><div><pre class="programlisting">
<strong># usermod -G users andrew</strong>
</pre></div><p>If we choose to run the preceding command, then <code class="literal">andrew</code> would be added to the <code class="literal">users</code> groups but, along with his primary group, this would be his only secondary group membership. In other words, if <code class="literal">andrew</code> belongs to multiple secondary groups, the <code class="literal">-G</code> option overwrites this group list, which is not a good thing.</p><p>The command ID can display current secondary groups with the <code class="literal">-G</code> option:</p><div><pre class="programlisting">
<strong># id -G andrew</strong>
</pre></div><p>If we combine the two commands together, then we can effectively append the <code class="literal">users</code> groups to the current group list of <code class="literal">andrew</code>. To do this, additionally, we have to translate the spaces in the group list supplied by the command ID into commas:</p><div><pre class="programlisting">
<strong># usermod -G$(id -G andrew | tr ' ' ','),users</strong>
</pre></div><p>The commands in the parenthesis are evaluated first. The <code class="literal">id</code> command creates a space-separated list of secondary groups, and the <code class="literal">tr</code> command will translate the spaces to commas (in this case). The group list we supply to <code class="literal">usermod</code> needs to be comma delimited but can use group names or IDs. More simply though, we can use the append option to usermod as shown in the following code example:</p><div><pre class="programlisting">
<strong># usermod -a -G users andrew</strong>
</pre></div><p>When creating new users, we can simply specify the secondary groups the user should belong to. We don't need to concern ourselves with the existing group membership:</p><div><pre class="programlisting">
<strong># useradd -G users u4</strong>
<strong># id u4</strong>
</pre></div><p>From the<a class="indexterm" id="id268"/> following output, we can see that the new user, <code class="literal">u4</code>, is <a class="indexterm" id="id269"/>created and added to the secondary group users.</p><div><img alt="Adding users to groups" src="img/5920OS_06_03.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>Evaluating private group usage</h2></div></div></div><p>You do <a class="indexterm" id="id270"/>not need to use private <code class="literal">groups</code> schemes. They are the default, but as with all defaults, we can specify options to<a class="indexterm" id="id271"/> modify this. Using the <code class="literal">-N</code> option with <code class="literal">useradd</code> will not create the private groups and, if not specified, the user's primary group or GID will be the <code class="literal">users</code> groups. Let's execute the following commands:</p><div><pre class="programlisting">
<strong># useradd -N u5</strong>
<strong># id u5</strong>
</pre></div><p>The output is shown in the following screenshot, and we see that the users' primary group is the <code class="literal">users</code> group:</p><div><img alt="Evaluating private group usage" src="img/5920OS_06_04.jpg"/></div><p>The only security issue that we may need to contend with is that now, by default, any file created <a class="indexterm" id="id272"/>by the user <code class="literal">u5</code> will be group owned by a shared <a class="indexterm" id="id273"/>group. Depending on the circumstances, this may be not desirable; however, having all files private to the user by default is no more desirable either. This is up to the administration team deciding which model suits the organizational needs best.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Getent</h1></div></div></div><p>The <code class="literal">/usr/bin/getent</code> command will display a list of entries, <em>Get Entries</em>. The entries are resolved<a class="indexterm" id="id274"/> by <em>Name Service Switch Libraries</em>, which are configured in the <code class="literal">/etc/nsswitch.conf</code> file. This file has a list of databases and libraries that <a class="indexterm" id="id275"/>will be used to access those databases.</p><p>For example, we could use the <code class="literal">getent passwd</code> command to display all users, or <code class="literal">getent group</code> to display all groups. We could extend this though to commands such as <code class="literal">getent hosts</code> to display host file entries and <code class="literal">getent aliases</code> to display user aliases on the system.</p><p>The <code class="literal">nsswitch.conf</code> file will define the libraries used to access the <code class="literal">passwd</code> database. On a standard CentOS system, <code class="literal">/etc/passwd</code> is often the only local file, but an enterprise system could include <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>) modules. In the next<a class="indexterm" id="id276"/> chapter, we will learn more using directory services.</p><p>We search the <code class="literal">/etc/nsswitch</code> file for the <code class="literal">passwd</code> database using <code class="literal">grep</code>:</p><div><pre class="programlisting">
<strong># grep passwd /etc/nsswitch.conf</strong>
</pre></div><p>We can see that on my system, we just use the local files to resolve user names:</p><div><img alt="Getent" src="img/5920OS_06_05.jpg"/></div><p>The <code class="literal">getent</code> command is a very useful way to quickly list users or groups on your system, and the output can be filtered or sorted as required with the <code class="literal">grep</code> and <code class="literal">sort</code> commands. For<a class="indexterm" id="id277"/> example, if we want to see all configured groups on our system that<a class="indexterm" id="id278"/> start with the letter <code class="literal">u</code> and have only one additional character in their names, we can use the following command:</p><div><pre class="programlisting">
<strong># getent group | grep 'u.:' | sort</strong>
</pre></div><p>The following screenshot shows this command:</p><div><img alt="Getent" src="img/5920OS_06_06.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Quotas</h1></div></div></div><p>In almost <a class="indexterm" id="id279"/>all areas of user management, we have to assign disk space quotas of some description in order to give the responsibility of disk space management back to the user. If we do not, then the user would never know the struggles that we have to face in providing them with unlimited disk space. Allowing the user to see that their space is filling up then may prompt them to carry out a little housekeeping.</p><p>In Linux, disk quotas are applied to the mount points; if you want to limit a user's space in their home directory, then the <code class="literal">/home</code> directory will need to be in its own partition. If it is part of the root filesystem, then a user's space will be restricted to all directories within that partition.</p><p>Quota restrictions are implemented using tools from the <code class="literal">quota</code> package. You can use the <code class="literal">yum</code> command<a class="indexterm" id="id280"/> to verify that it is installed:</p><div><pre class="programlisting">
<strong>$ yum list quota</strong>
</pre></div><p>If the output of<a class="indexterm" id="id281"/> the command indicates that it is available rather than installed, then install the quota with:</p><div><pre class="programlisting">
<strong># yum install quota</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Setting quotas</h2></div></div></div><p>My system includes a partition for <code class="literal">/home</code> and has the <code class="literal">quota</code> package installed. We now need to <a class="indexterm" id="id282"/>set the correct mount options for the <code class="literal">/home</code> partition. Currently, it does not include quotas.</p><p>To enable this, we will edit the <code class="literal">/etc/fstab</code> file and mount options for the <code class="literal">/home</code> partition. The following two mount options should be added to enable journal quotas for a selected partition:</p><div><pre class="programlisting">
<strong>usrjquota=aquota.user,jqfmt=vfsv0</strong>
</pre></div><p>The <code class="literal">usrjquota=aquota.user</code> part specifies the quota file, and <code class="literal">jqfmt=vfsv0</code> specifies the quota format.</p><p>The line in question is shown in the following screenshot:</p><div><img alt="Setting quotas" src="img/5920OS_06_07.jpg"/></div><p>We have enabled journal-based user quotas as we are using <code class="literal">ext4</code>, a journal-based filesystem. User space restriction is checked when writing the journal rather than waiting until the changes are flushed to disk. We also set the format of the journal quotas.</p><p>To make these settings effective, we can remount the <code class="literal">/home</code> partition using the following command:</p><div><pre class="programlisting">
<strong># mount -o remount /home</strong>
</pre></div><p>We will now need to initialize the quota database; this was referenced in the mount options as <code class="literal">aquota.user</code> and will reside at the root of the partition where quotas are enabled. Enabling quotas on a filesystem may take some time, depending on the amount of data in the filesystem:</p><div><pre class="programlisting">
<strong>#quotacheck -muv /home</strong>
</pre></div><p>Using these options with the <code class="literal">/sbin/quotacheck</code> command, we can set the following options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-m</code>: This<a class="indexterm" id="id283"/> indicates not to remount as read-only during an operation</li><li class="listitem" style="list-style-type: disc"><code class="literal">-u</code>: This<a class="indexterm" id="id284"/> is for user quotas</li><li class="listitem" style="list-style-type: disc"><code class="literal">-v</code>: This<a class="indexterm" id="id285"/> is the verbose output</li><li class="listitem" style="list-style-type: disc"><code class="literal">/home</code>: This is <a class="indexterm" id="id286"/>the partition to work with, or use <code class="literal">-a</code> for all quota-enabled partitions</li></ul></div><p>It may be worth adding the <code class="literal">quotacheck</code> commands and options into your <code class="literal">crontab</code> to ensure that <code class="literal">quotacheck</code> is run perhaps once a day. Even though journal quotas are more reliable<a class="indexterm" id="id287"/> than<a class="indexterm" id="id288"/> traditional quotas, there is no harm in re-evaluating file space used to ensure that the data maintained is accurate.</p><p>Quotas <a class="indexterm" id="id289"/>can be set with the <code class="literal">edquota</code> or <code class="literal">setquota</code> command; I<a class="indexterm" id="id290"/> prefer the <code class="literal">setquota</code> command, but traditionally <code class="literal">edquota</code> is taught to new administrators. The <code class="literal">/usr/sbin/edquota</code> command takes you into your editor to make the changes, whereas <code class="literal">/usr/sbin/setquota</code> sets the quota directly from the command line:</p><div><pre class="programlisting">
<strong># setquota -u u1 20000 25000 0 0 /home</strong>
</pre></div><p>The preceding command will set the quota for the user <code class="literal">u1</code>. Giving the user a soft limit, just a warning when they exceed 20 M (20 x 1k blocks) and implementing a hard limit of 25 M, where the user cannot save any more data in <code class="literal">/home</code>. I have not limited the user <code class="literal">u1</code> with either soft or hard limits to the number of files they may have, just the space they use.</p><p>The <code class="literal">/usr/sbin/repquota</code> command<a class="indexterm" id="id291"/> can be used to display disk usage:</p><div><pre class="programlisting">
<strong># repquota -uv /home</strong>
</pre></div><p>The output from my system is shown in the following screenshot:</p><div><img alt="Setting quotas" src="img/5920OS_06_08.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Scripting user creation</h1></div></div></div><p>User <a class="indexterm" id="id292"/>creation will now consist of three steps:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">useradd</code>: This <a class="indexterm" id="id293"/>creates the user</li><li class="listitem" style="list-style-type: disc"><code class="literal">passwd</code>: This<a class="indexterm" id="id294"/> sets the password</li><li class="listitem" style="list-style-type: disc"><code class="literal">setquota</code>: This<a class="indexterm" id="id295"/> sets the disk limits</li></ul></div><p>We can ensure that all this happens correctly and uniformly using scripts to ensure the procedural integrity of the user creation process. It is also going to save you time. As a very quick solution, the following script provides all that we need:</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>
<strong>useradd -m -G users $1 </strong>
<strong>echo Password123 | passwd --stdin $1</strong>
<strong>passwd -e $1</strong>
<strong>setquota -u $1 20000 25000 0 0 /home</strong>
</pre></div><p>We will need to run the script with the new username as the argument, as shown in the following example:</p><div><pre class="programlisting">
<strong># userscript.sh bob</strong>
</pre></div><p>Reading<a class="indexterm" id="id296"/> the script though line by line can explain the script contents as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">#!/bin/bash</code>: This is the script interpreter to use</li><li class="listitem" style="list-style-type: disc"><code class="literal">useradd -m -G users $1</code>: This creates the user supplied as the first argument to the script, <code class="literal">$1</code>. The user's home directory will be created, and it will be added to the <code class="literal">users</code> group.</li><li class="listitem" style="list-style-type: disc"><code class="literal">echo Password123 | passwd --stdin $1</code>: This sets the user's password to a standard password.</li><li class="listitem" style="list-style-type: disc"><code class="literal">passwd -e $1</code>: The password is expired so the user will need to set their own password when they first login.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setquota -u $1 20000 25000 0 0 /home</code>: Finally, the quotas are implemented for the user.</li></ul></div><p>We can, of course, allow more functionality in the script to set different groups and quotas; however, as an example of procedural integrity and a functional script, this is a great start.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>As we close another chapter, we can take stock of all that we have acquainted ourselves with in the process. The big task for this section was to become more accustomed to the vagaries of CentOS group management and being able to properly differentiate between the primary group and secondary groups of a user. During this process, we took the time to evaluate the use of public and private group schemes and the use of the <code class="literal">-N</code> option to disable the user's private group during user creation.</p><p>It was not long before we found ourselves in the depths of <code class="literal">/etc/nsswitch.conf</code> and the <code class="literal">getent</code> command (get entries). From here, we got down straight to business implementing user disk limits or quotas before seeing how to link all of this together with scripts.</p><p>In the next chapter, we stick to the theme of users, but look at centralizing our accounts in a central LDAP directory, using the open source code from Red Hat's directory server by implementing the 389 Directory Server on CentOS 6.5.</p></div></body></html>