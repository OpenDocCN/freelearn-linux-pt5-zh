["```\n~$  ldd /usr/sbin/crond | grep selinux\n libselinux.so.1 => /lib64/libselinux.so.1 (0x00007fa53299a000)\n\n```", "```\n<!DOCTYPE busconfig PUBLIC \"-//freedesktop//DTD D-BUS Bus Configuration 1.0//EN\" \"http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd\">\n<busconfig>\n  <policy user=\"root\">\n    <allow own=\"uk.org.thekelleys.dnsmasq\"/>\n    <allow send_destination=\"uk.org.thekelleys.dnsmasq\"/>\n  </policy>\n  <policy context=\"default\">\n    <deny own=\"uk.org.thekelleys.dnsmasq\"/>\n    <deny send_destination=\"uk.org.thekelleys.dnsmasq\"/>\n  </policy>\n</busconfig>\n```", "```\n    ~# ps -eZ | grep dnsmasq | awk '{print $1}'\n    system_u:system_r:dnsmasq_t:s0-s0:c0.c1023\n\n    ```", "```\n    gen_require(`\n      class dbus send_msg;\n    ')\n    allow sysadm_t dnsmasq_t:dbus send_msg;\n    allow dnsmasq_t sysadm_t:dbus send_msg;\n    ```", "```\n~# dbus-send --system --dest=uk.org.thekelleys.dnsmasq --print-reply /uk/org/thekelleys/dnsmasq org.freedesktop.DBus.Introspectable.Introspect\n\n```", "```\nError org.freedesktop.DBus.Error.AccessDenied: An SELinux policy prevents this sender from sending this message to this recipient. 0 matched rules; type=\"method_call\", sender=\":1.17\" (uid=0 pid=6738 comm=\"\") interface=\"org.freedesktop.DBus.Introspectable\" member=\"Introspect\" error name=\"(unset)\" requested_reply=\"0\" destination=\"uk.org.thekelleys.dnsmasq\" (uid=0 pid=6635 comm=\"\")\n\n```", "```\n    <policy user=\"root\">\n      <allow own=\"uk.org.thekelleys.dnsmasq\" />\n    </policy>\n    ```", "```\n    <selinux>\n      <associate own=\"uk.org.thekelleys.dnsmasq\" context=\"dnsmasq_t\" />\n    </selinux>\n    ```", "```\n    gen_require(`\n      class dbus acquire_svc;\n    ')\n    allow dnsmasq_t self:dbus acquire_svc;\n    ```", "```\nallow dnsmasq_t dnsmasq_dbus_t:dbus acquire_svc;\n```", "```\nFailed to start message bus: Failed to open \"/etc/selinux/mcs/contexts/dbus_contexts\": No such file or directory\n\n```", "```\n<include if_selinux_enabled=\"yes\" selinux_root_relative=\"yes\">contexts/dbus_contexts</include>\n```", "```\ndev_filetrans(udev_t, mydevice_t, chr_file, \"mydevice\")\n```", "```\n~# semanage fcontext -a -t mydevice_t -f -c /dev/mydevice[0-9]*\n\n```", "```\n~# restorecon -R /dev\n\n```", "```\n~# ps -efZ | grep fcron | awk '{print $1}'\nsystem_u:system_r:crond_t:s0-s0:c0.c1023\n\n```", "```\n~# getseuser hannah system_u:system_r:crond_t:s0\nseuser: user_u\nContext 0    user_u:user_r:cronjob_t:s0\n\n```", "```\n~# grep crond_t /etc/selinux/mcs/contexts/users/user_u\nsystem_r:crond_t  user_r:cronjob_t\n\n```", "```\n~# setsebool cron_userdomain_transition on\n~# grep crond_t /etc/selinux/mcs/contexts/users/user_u\nsystem_r:crond_t  user_r:user_t\n\n```", "```\n~# sesearch -s user_t -t user_cron_spool_t -c file -p entrypoint -A\nFound 1 semantic av rules:\n allow user_t user_cron_spool_t : file entrypoint ;\n\n```", "```\n    #ifdef SELINUX\n    #include <selinux/selinux.h>\n    #include <selinux/av_permissions.h>\n    #include <selinux/get_context_list.h>\n    #endif\n    ```", "```\n    int selinux_prepare_fork(char * name) {\n    #ifndef SELINUX\n      return 0;\n    #else\n      …\n    #endif\n    };\n    ```", "```\n    int rc;\n    rc = is_selinux_enabled();\n    if (rc == 0) {\n      … // SELinux is not enabled\n    } else if (rc == -1) {\n      … // Could not check SELinux state (call failed)\n    } else {\n      … // SELinux is enabled\n    };\n    ```", "```\n    rc = security_getenforce();\n    if (rc == 0) {\n      … // SELinux is in permissive mode\n    } else if (rc == 1) {\n      … // SELinux is in enforcing mode\n    } else {\n      … // Failed to query state\n    };\n    ```", "```\n    ~# gcc -o test -DSELINUX -lselinux test.c\n\n    ```", "```\n    char * curcon = 0;\n    rc = getcon(&curcon);\n    if (rc) {\n      … // Getting context failed\n      if (permissive) {\n        … // Continue with the application logic, ignoring SELinux stuff\n      } else {\n        … // Log failure and stop application logic\n      };\n    };\n    ```", "```\n    char * sename = 0;\n    char * selevel = 0;\n    rc = getseuserbyname(name, &sename, &selevel);\n    if (rc) {\n      … // Call failed. Again check permissive state\n      … // and take appropriate action.\n      freecon(curcon);\n    };\n    ```", "```\n    char * newcon = 0;\n    rc = get_default_context(sename, NULL, &newcon);\n    if (rc) {\n      … // Call failed. Again check permissive state\n      … // and take appropriate action.\n      freecon(curcon);\n    };\n    ```", "```\nrc = get_default_context(sename, curcon, &newcon);\n```", "```\n~$ id -Z\nstaff_u:staff_r:staff_t:s0\n~$ newrole -r sysadm_r\nPassword: \n~$ id -Z\nstaff_u:sysadm_r:sysadm_t:s0\n~$ cat /proc/$$/attr/current\nstaff_u:sysadm_r:sysadm_t:s0\n~$ cat /proc/$$/attr/prev\nstaff_u:staff_r:newrole_t:s0\n\n```", "```\n    struct av_decision avd;\n    rc = security_compute_av_flags(curcon, newcon, SECCLASS_PROCESS, PROCESS__TRANSITION, &avd);\n    if (rc) {\n      … // Method failed.\n      freecon(curcon);\n      freecon(newcon);\n    };\n    ```", "```\n    if (!(avd.allowed & PROCESS__TRANSITION)) {\n      … // Transition is denied\n    };\n    ```", "```\n    if (avd.flags & SELINUX_AVD_FLAGS_PERMISSIVE) {\n      … // Domain is permissive\n    };\n    ```", "```\n    int rc = setexeccon(newcon);\n    if (rc) {\n      … // Call failed\n      freecon(newcon);\n    };\n    ```", "```\n    pid_t child;\n    child = fork();\n    if (child < 0) {\n      … // Fork failed } else if (child == 0) {\n      int pidrc;\n      pidrc = execl(\"/usr/bin/id\", \"id\", \"-Z\", NULL);\n      if (pidrc != 0) {\n        … // Command failed\n      };\n    } else {\n      … // Parent process\n      int status;\n      wait(&status);\n    };\n    ```", "```\nallow crond_t self : process setexec;\nallow crond_t staff_t : process transition;\n```", "```\nchar * fallbackcon = \"system_u:object_r:openscap_helper_script_t:s0\";\nchar * filename = \"/usr/libexec/openscap/probe_process\";\n…rc = setexecfilecon(filename, fallbackcon);\n```", "```\n    security_context_t filecon = 0;\n    char * path = \"/etc/passwd\";\n    rc = getfilecon(path, &filecon);\n    if (rc < 0) {\n      … // Call failed\n    };\n    … // Do stuff with the context\n    freecon(filecon);\n    ```", "```\n    security_context_t pidcon = 0;\n    rc = getpidcon(pid, &pidcon);\n    if (rc < 0) {\n      … // Call failed\n    };\n    … // Do stuff with the context\n    freecon(pidcon);\n    ```"]