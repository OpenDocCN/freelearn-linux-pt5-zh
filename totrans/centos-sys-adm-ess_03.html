<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;CentOS Filesystems &#x2013; A Deeper Look"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. CentOS Filesystems – A Deeper Look</h1></div></div></div><p>So we know that our filesystems are comprised of files and directories; both of which are files, just different types. However, what about links, pipes, and sockets? What are they and how are they used? And why do we talk of links? What is the difference between a hard link and soft link? I think I need to sit down. I can feel one of my turns coming on.</p><p>Let's also<a class="indexterm" id="id86"/> challenge the traditional filesystem design; you may well have worked with a <span class="strong"><strong>logical volume manager</strong></span> (<span class="strong"><strong>LVM</strong></span>) in the past, but let me tell you just how last century that is. You are going to be blown away by the power and ease of your enterprise filesystem management using BTRFS, pronounced Better FS. We will cover the following sections in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A magician's secret</strong></span>: We reveal how to count subdirectories without actually counting<a class="indexterm" id="id87"/> them.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Special permissions</strong></span>: This will cover the tail of the <code class="literal">wall</code> command and how it met the GUID bit.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Naming your pipes</strong></span>: I am sure that you would not care to be unnamed, and your <a class="indexterm" id="id88"/>pipes feel this way too. We investigate how to use named pipes to enable <span class="strong"><strong>inter-process communication</strong></span> (<span class="strong"><strong>IPC</strong></span>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Understanding the command stat</strong></span>: This will cover all you ever needed to know about an inode, the files' metadata.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Enterprise filesystem shootout</strong></span>: In BTRFS versus LVM, BTRFS wins hands down. We look at what is new in the BTRFS and see how we can make use of snapshots and extend volumes.</li></ul></div><div class="section" title="A magician's secret"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>A magician's secret</h1></div></div></div><p>We know that there are many groups of people in this world that can and often do annoy us; magicians perhaps being just one of those groups of people. They annoy us because we do not<a class="indexterm" id="id89"/> know how they do what they do; quite simply we know that we are being tricked, but we don't quite know how. Well let me be the one to break the honor of the magician's circle and disclose a little trick within CentOS Linux that you can use to trick your colleagues; believe me when I say that this is one trick worth knowing.</p><p>Let me show you that if I run the following command on my CentOS 6.5 system, I will be shown a long listing of the specified <code class="literal">doc</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -ld /usr/share/doc</strong></span>
</pre></div><p>The output on my system is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>drwxr-xr-x. 758 root root 36864 May 1 09:09 /usr/share/doc</strong></span>
</pre></div><p>The first number that is displayed, <code class="literal">758</code>, is the <span class="emphasis"><em>link</em></span> count. This shows the number of filenames that are hard linked to the file's metadata; in simple terms, this directory has 758 separate names.</p><p>Immediately from this value, I can categorically state that this directory has 756 subdirectories!</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"It's not rocket science, it is subtracting 2 from a number"</em></span></p></blockquote></div><p>The formula is simple! For a given directory, the number of subdirectories is equal to the hard link count of two.</p><p>I think it is time that we investigate this a little further. When a new directory is created, it is initiated with the link count being equal to two; in other words, each new directory has to have two names that point to it. This will consist of the directory name and the file named <code class="literal">.</code> (just the period by itself).</p><p>In fact, in a new directory, there are always two new files that are created along with the directory: the <code class="literal">.</code> and <code class="literal">..</code> files.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">.</code> file<a class="indexterm" id="id90"/> represents the directory itself</li><li class="listitem" style="list-style-type: disc">The <code class="literal">..</code> file<a class="indexterm" id="id91"/> represents the parent directory</li></ul></div><p>Try this yourself; it is easier to understand and might prevent you from going too dotty over this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd</strong></span>
<span class="strong"><strong>$ mkdir newdir </strong></span>
<span class="strong"><strong>$ ls -a newdir #Note the two files</strong></span>
<span class="strong"><strong>$ ls -ld newdir # Note the hard link count of 2</strong></span>
</pre></div><p>The following screenshot shows the new directory and the listing of the two hidden files therein. The color coding, natural to BASH, highlights both files in blue, which indicate that they represent directories:</p><div class="mediaobject"><img alt="A magician's secret" src="graphics/5902OS_03_01.jpg"/></div><p>I am<a class="indexterm" id="id92"/> sure, when you take time to think, that we use the dot notation as a form of shorthand all the time. Consider the following code using the copy command <code class="literal">cp</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cp /etc/hosts .</strong></span>
</pre></div><p>Here, we copy the <code class="literal">hosts</code> file from the <code class="literal">/etc</code> directory to the current directory using the notation of a single dot. In the following example, we change to the parent directory using the <code class="literal">cd</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd ..</strong></span>
</pre></div><p>We can now begin understanding how a directory's link count relates to the subdirectory count. If the filename consists of two dots representing the parent directory, then for each subdirectory we create in the given directory, we will have a new file pointing to the parent directory. Each of these double-dot files is hard linked to the subdirectory's parent directory.</p><div class="section" title="Hard links"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec12"/>Hard links</h2></div></div></div><p>In Linux filesystems, we have two types of links: hard links and soft or symbolic links. Hard links<a class="indexterm" id="id93"/> are, as we have seen, the name or names of the file. A regular file <a class="indexterm" id="id94"/>will have just a single name when it is first created. We can add additional names to the file using the <code class="literal">ln</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd</strong></span>
<span class="strong"><strong>$ echo "Hello" &gt; my_newfile</strong></span>
<span class="strong"><strong>$ ln my_newfile the_samefile</strong></span>
<span class="strong"><strong>$ ls -li my_newfile the_samefile</strong></span>
</pre></div><p>We will walk through the steps we executed on our system as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We move to our home directory.</li><li class="listitem">Then, we create a new file containing the word <code class="literal">Hello</code>.</li><li class="listitem">The <code class="literal">ln</code> command links the original file to a new name, <code class="literal">the_samefile</code>. We now have two filenames that point to the same metadata. The hard link count of both files will be two; the names point to the same metadata.</li><li class="listitem">Using the <code class="literal">ls</code> command with the option for the long listing, <code class="literal">-l</code>, will display the hard link count. The option, <code class="literal">-i</code>, will display the inode number of the file. The<a class="indexterm" id="id95"/> inode number of both files will be the same. As hard links <a class="indexterm" id="id96"/>share the same inode number, the source and target <a class="indexterm" id="id97"/>file must be on the same filesystem. An<a class="indexterm" id="id98"/> inode is an entry within a single filesystem.</li></ol></div></div><div class="section" title="Symbolic links"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec13"/>Symbolic links</h2></div></div></div><p>Symbolic links, or soft links as they are sometimes referred to, are completely separate files whose<a class="indexterm" id="id99"/> data points to another filename; as such, they can cross the filesystem boundaries and be a little more useful than hard links. Symbolic links have a<a class="indexterm" id="id100"/> file type of <code class="literal">l</code> indicating that they are a special type of file. Hard links are regular files and can only be identified as links via the hard link count. Symbolic links do not affect a file's hard link count; they are completely independent files with their own name, inode, and data. The data of a symbolic link is the pointer to the target files. In the following code segment, we can see the creation and display of a symbolic link:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd</strong></span>
<span class="strong"><strong>$ ln -s my_newfile the_linkedfile</strong></span>
<span class="strong"><strong>$ ls -l the_linkedfile</strong></span>
</pre></div><p>Let's walk through the following steps that create a symbolic link in our home directory:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first<a class="indexterm" id="id101"/> move to our home directory.</li><li class="listitem">The <code class="literal">ln</code> command links the original file to a new name, <code class="literal">the_linkedfile</code>. The option <code class="literal">-s</code> will <a class="indexterm" id="id102"/>create a soft link.</li><li class="listitem">Using the <code class="literal">ls</code> command, which is the option for the long listing, <code class="literal">-l</code>, we can see from the output that the first character, which indicates the file type, shows an <code class="literal">l</code> indicating that this file is a symbolic link. The extended output also shows where the target file is.</li></ol></div></div></div></div>
<div class="section" title="Special permissions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Special permissions</h1></div></div></div><p>The <a class="indexterm" id="id103"/>permissions or <span class="emphasis"><em>mode</em></span> of a file you we will be familiar <a class="indexterm" id="id104"/>with is <span class="strong"><strong>Read, Write, and eXecute</strong></span> (<span class="strong"><strong>RWX</strong></span>). These permissions can be set to the three objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User</li><li class="listitem" style="list-style-type: disc">Group</li><li class="listitem" style="list-style-type: disc">Others</li></ul></div><p>The standard permissions are shown with their octal notation, should you want a quick revision exercise, as follows:</p><div class="mediaobject"><img alt="Special permissions" src="graphics/5902OS_03_02.jpg"/></div><p>There is a <a class="indexterm" id="id105"/>fourth block of permissions that precedes user, group, and others. This block is for the special permissions; however, rather than representing RWX, the permissions comprise of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The set user ID (SUID) bit</li><li class="listitem" style="list-style-type: disc">The set group ID (SGID) bit</li><li class="listitem" style="list-style-type: disc">The sticky bit</li></ul></div><p>Using symbolic notations, these permissions can be added to <code class="literal">file1</code>, which acts as our axiom for the filename during the following demonstration:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chmod u+s file1 #adding the SUID Bit</strong></span>
<span class="strong"><strong>$ chmod g+s file1 #adding the SGID Bit</strong></span>
<span class="strong"><strong>$ chmod o+t file1 #adding the Sticky Bit</strong></span>
</pre></div><div class="section" title="The SUID bit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>The SUID bit</h2></div></div></div><p>The<a class="indexterm" id="id106"/> set user ID bit is used when a program needs to run <a class="indexterm" id="id107"/>using another user ID other than the user running the program. When set, the program runs with the permissions of the file's owner and not the user ID of the current user. This is set on some simple programs; for example, the password program <code class="literal">/usr/bin/passwd</code> has this permission set. This is required as standard users can change their own password program but they do not have the permissions to write to the <code class="literal">/etc/shadow</code> file, where the passwords are stored. The program will always execute as the root user no matter who initiates it.</p><p>If you are <a class="indexterm" id="id108"/>curious and want to see how many files on your system<a class="indexterm" id="id109"/> have this permission included, then the <code class="literal">find</code> command may come to your aid:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find / -perm +4000</strong></span>
</pre></div><p>The command, as typed, will search the OS root directory, <code class="literal">/</code>, down for any file that includes the SUID bit, <code class="literal">-perm +4000</code>.</p></div><div class="section" title="The SGID bit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>The SGID bit</h2></div></div></div><p>Similar to the set UID bit, if the SGID permission is set on an executable, then the program <a class="indexterm" id="id110"/>will run with the group ID of the file's group <a class="indexterm" id="id111"/>rather than the group ID of the current user. This is set by default in the <code class="literal">/usr/bin/wall</code> file, and we will again take a closer look by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -l /usr/bin/wall</strong></span>
</pre></div><p>From the output, we see that the permissions read <code class="literal">r-xr-sr-x</code>. The lowercase <code class="literal">s</code> indicates that the SGID and execute permissions are set. If it were an uppercase <code class="literal">S</code>, then the execute permission would not be set for the group.</p><p>When looking at the <code class="literal">/usr/bin/wall</code> program, we should understand that this program is used to send messages to user consoles; it is a group owned by the <code class="literal">tty</code> group. With the SGID bit set, when any user executes this program, he or she run with the privileges of the <code class="literal">tty</code> group.</p><p>A user logged on to a console has some control over these messages using the <code class="literal">y</code> or <code class="literal">n</code> option with the <code class="literal">mesg</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mesg   #without options displays the current messaging state</strong></span>
<span class="strong"><strong>$ mesg y #enables messages to be received in the console</strong></span>
<span class="strong"><strong>$ mesg n #disables messages from being received in the console</strong></span>
</pre></div><p>We could leave the matter at this, understanding that we are simply enabling and disabling messages to our console. We could, but we would not learn the relationship with the SGID bit on the wall program, and we would not unlock the fountain of knowledge that understanding brings. Remaining within our console, we will determine which console we are currently connected to; the <code class="literal">tty</code> command will help us here. The output on my system shows <code class="literal">/dev/pts/1</code>. Obtaining a long listing of the device file using the following command will show the file type and permissions. The file type is <code class="literal">c</code> indicating a character device:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -l /dev/pts/1</strong></span>
</pre></div><p>From the output, we can see the permissions of the file; the group owner is <code class="literal">tty</code> and, if messaging is enabled, the group will have the write permission. If messaging is disabled, the group will have no permission. We can combine the two commands together using the bracket expansion we first saw in <a class="link" href="ch01.html" title="Chapter 1. Taming vi">Chapter 1</a>, <span class="emphasis"><em>Taming vi</em></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls -l $(tty)</strong></span>
</pre></div><p>The contents of the brackets are evaluated first; the output from which is in turn processed using the <code class="literal">ls -l</code> command.</p><p>In the following screenshot, messaging is disabled as the group does not have the write permission to the console:</p><div class="mediaobject"><img alt="The SGID bit" src="graphics/5902OS_03_03.jpg"/></div><p>When <a class="indexterm" id="id112"/>we enable messaging and review the output in the following <a class="indexterm" id="id113"/>screenshot, we can see that, miraculously, the write permission now shows for the group:</p><div class="mediaobject"><img alt="The SGID bit" src="graphics/5902OS_03_04.jpg"/></div><p>We have now seen a little more of that initial Linux magic in which we indulged in earlier in this chapter. Moreover, we have seen how to apply it to real-world Linux issues by controlling the use of the <code class="literal">/usr/bin/wall</code> command via the <code class="literal">/usr/bin/mesg</code> command.</p><p>However, the giving from the SGID does not stop with executable files. The SGID bit can also be set on directories. When set on a directory, the SGID bit ensures that all new files created within the directory are group owned by the group owner from the directory. To put this in context, let's say that our web server's document root, (where the web pages go), is set to the <code class="literal">/var/www/html/</code> directory. If we set the group ownership of the directory to the <code class="literal">apache</code> group, we can then use the SGID bit to maintain the correct ownership <a class="indexterm" id="id114"/>of all files created. The following commands <a class="indexterm" id="id115"/>demonstrate this intricate procedure:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chgrp apache /var/www/html</strong></span>
<span class="strong"><strong># chmod g+s /var/www/html</strong></span>
<span class="strong"><strong># ls -ld /var/www/html</strong></span>
</pre></div><p>Now, each new web page created <code class="literal">in /var/www/html</code> will automatically be group owned by the <code class="literal">apache</code> group. We have now seen that the SGID bit can be effective on executable files and directories.</p></div><div class="section" title="The sticky bit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>The sticky bit</h2></div></div></div><p>The final <a class="indexterm" id="id116"/>special permission is the sticky bit. This is used on <a class="indexterm" id="id117"/>directories and set on the <code class="literal">/tmp</code> directory during the default installation of CentOS. The ability to delete a file is controlled by directory permissions and not by, as some people think, the file's permissions. When you create or delete a file, you are writing to the directory. This means that within a central shared directory, such as <code class="literal">/tmp</code>, where all users can write to the directory, it would be possible for users to delete any file. To limit the deletions to files owned by the user, the sticky bit is applied to the directory. To add the sticky bit permission to the <code class="literal">/data</code> directory, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># chmod +t /data</strong></span>
</pre></div></div></div>
<div class="section" title="Naming your pipes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Naming your pipes</h1></div></div></div><p>I am sure that we all have come across the vertical bar or pipe character <code class="literal">|</code>; we can use this to <a class="indexterm" id="id118"/>create command pipelines, where the output of one command is piped to the input of another. As a simple demonstration, we can use the following commands as an illustration of how often we may use unnamed pipes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ yum list installed | grep plymouth</strong></span>
</pre></div><p>The first command, <code class="literal">yum list installed</code>, lists all the installed packages which will be a considerable size; in order to reduce the content, we search for the string <code class="literal">plymouth</code> with the second command <code class="literal">grep</code>. The two lines of code are conjoined with an unnamed pipe. It is said to be unnamed as it is transient and only exists for the instance that the two commands run, which, incidentally, is much shorter than the life of a mayfly.</p><p>This transient nature may not be useful to us in every situation, in which case we can create named pipes, which are files with the pipe type. Files can be one of the following types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Regular file</li><li class="listitem" style="list-style-type: disc">Directory</li><li class="listitem" style="list-style-type: disc">Symbolic link</li><li class="listitem" style="list-style-type: disc">Socket</li><li class="listitem" style="list-style-type: disc">Named pipe</li><li class="listitem" style="list-style-type: disc">Character device</li><li class="listitem" style="list-style-type: disc">Block device</li></ul></div><p>You should be quite familiar with the first three types, but we tend to see the others less, although <a class="indexterm" id="id119"/>we saw a character device file <code class="literal">/dev/pts/1</code> in the previous section where we were looking at the SGID bit. Character devices are simply terminals that we can access. Here, we want to keep our focus on the file type of pipe, some of which may exist in your filesystem already. We can hunt them using the <code class="literal">find</code> command, searching for a file type <code class="literal">p</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ find / -type p 2&gt;/dev/null</strong></span>
</pre></div><p>Running this command as a standard user, you can expect errors related to directories to which we do not have rights; in such a case, it is often easier to redirect errors to <code class="literal">/dev/null</code>, as we have done here. Having the <code class="literal">autofs</code> service running on your system will create named pipes: <code class="literal">/var/run/autofs.fifo-misc</code> and <code class="literal">/var/run/autofs.fifo-net</code>.</p><p>Named pipes allow for different processes to talk with each other or interprocess communication. With unnamed pipes, the processes are always running in the same parent hierarchy, the same BASH shell in other words. As such, they are useful but only to us and our own parochial worlds. Named pipes, however, open up the input of one command to any process running on that system irrelevant of the process hierarchy. This is perhaps similar to the realization that you had when you first realized that there were more places in the world to holiday than the Isle of Wight. A service process such as the <code class="literal">autofs</code> service may connect to the output of the named pipe waiting for the input from clients on the system, releasing us from the inward facing coterie, which is the unnamed pipe, into a wider expanse of communication.</p><p>The easiest way to explain how named pipes operate is to demonstrate them. So why don't we open two terminal windows? These can be graphical terminals running on the desktop if this is easier. I will stay logged in through my own standard account into both windows.</p><p>In the first terminal window, we can type the following groups of commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd  #move to your home directory</strong></span>
<span class="strong"><strong>$ mkfifo my-pipe #create a named pipe called "my-pipe"</strong></span>
<span class="strong"><strong>$ ls -l my-pipe #will list the file as type p</strong></span>
<span class="strong"><strong>$ wc -l &lt; my-pipe #We read in from the pipe and count the lines. As nothing is connected to the input we wait for something to process.</strong></span>
</pre></div><p>While the first window waits for input, we can go to the second terminal window and feed data to the input of the pipe:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd #move to your home directory where the pipe is located</strong></span>
<span class="strong"><strong>$ ls &gt; my-pipe #send the output of the ls command to the pipe</strong></span>
</pre></div><p>Immediately, we<a class="indexterm" id="id120"/> will see the result in the first window as we are now able to count the lines of output from the <code class="literal">ls</code> command that we input in the second terminal. By doing this, we have allowed two separate processes to talk with each other.</p></div>
<div class="section" title="Understanding the command stat"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Understanding the command stat</h1></div></div></div><p>The CentOS command line is full of tools, and trying to learn them all is perhaps a lifetime's <a class="indexterm" id="id121"/>work. As with all tasks, reaching the finish line begins with the<a class="indexterm" id="id122"/> first step. Our first step will be to delve into the world of the <code class="literal">/usr/bin/stat</code> command. By using this command, we can query a file's metadata. A file in CentOS consists of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A filename (hard link)</li><li class="listitem" style="list-style-type: disc">File metadata (inode)</li><li class="listitem" style="list-style-type: disc">Data</li></ul></div><p>Using <code class="literal">stat</code> and the filename alone, we can view the complete inode metadata. This is demonstrated with the following group of commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd #move to your home directory</strong></span>
<span class="strong"><strong>$ ls &gt; my_newfile #list the contents and redirect the output to the new file</strong></span>
<span class="strong"><strong>$ stat my_newfile #display the inode metadata</strong></span>
</pre></div><p>The following screenshot displays the output of <code class="literal">stat</code>:</p><div class="mediaobject"><img alt="Understanding the command stat" src="graphics/5902OS_03_05.jpg"/></div><p>We can see that the complete metadata is displayed, but if we choose, we can display just elements of the metadata; for example, to display the file permissions in the octal format, run the<a class="indexterm" id="id123"/> following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ stat -c%a my_newfile</strong></span>
</pre></div><p>To display the permission in human-readable format, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ stat -c%A my_newfile</strong></span>
</pre></div><p>The output will show <code class="literal">664</code> and <code class="literal">-rw-rw-r</code>, respectively. The inode will always store the permissions in the octal format, but many commands, such as <code class="literal">ls</code> and <code class="literal">stat</code> can convert to a friendlier format.</p><p>There are three timestamps that are stored in the inode:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a class="indexterm" id="id124"/>last access time</li><li class="listitem" style="list-style-type: disc">The <a class="indexterm" id="id125"/>last modified time</li><li class="listitem" style="list-style-type: disc">The <a class="indexterm" id="id126"/>last changed time</li></ul></div><div class="section" title="The last access time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>The last access time</h2></div></div></div><p>The<a class="indexterm" id="id127"/> last access time for a file lists the time that the file was last read. This is dependent on the filesystem maintaining the last access time; there is a mount option noatime that prevents the last access time from being updated. To list the last access time for the file, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ stat -c%x my_newfile</strong></span>
</pre></div><p>The time shown for me is 10:12. If I now read the file and run the command again, the time will change:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ less my_newfile</strong></span>
<span class="strong"><strong>$ stat -c%x my_newfile</strong></span>
</pre></div><p>The time now shows as 10:28. This is useful to find out if files are being read on a system. If they are not, it indicates that perhaps they are not needed and can be archived onto another device.</p></div><div class="section" title="The last modified time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>The last modified time</h2></div></div></div><p>The last <a class="indexterm" id="id128"/>modified time for a file indicates when the file itself was changed, that is, the file's data. If we edit the file and then check the last modified time, it will have changed.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ls &gt;&gt; my_newfile #we now append another listing to the file</strong></span>
<span class="strong"><strong>$ stat -c%y my_newfile #displays the last modified time</strong></span>
</pre></div><p>This is now 10:36 as opposed to 10:12 when the original content was created.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>The<a class="indexterm" id="id129"/> output from <code class="literal">ls -l</code> also shows the file's last <a class="indexterm" id="id130"/>modified time.</p></div></div></div><div class="section" title="The last changed time"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>The last changed time</h2></div></div></div><p>The<a class="indexterm" id="id131"/> last changed time of a file relates to when the metadata <a class="indexterm" id="id132"/>was changed, as opposed to the file's data. Changing the file permissions, for example, will alter the last changed time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chmod 640 my_newfile</strong></span>
<span class="strong"><strong>$ stat -c%z my_newfile</strong></span>
</pre></div><p>The time for my system now shows that the file's metadata was changed at 10:41.</p></div></div>
<div class="section" title="Enterprise filesystem shootout"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Enterprise filesystem shootout</h1></div></div></div><p>The LVM has been for many years the way to manage disk growth, and allowing logical volumes to <a class="indexterm" id="id133"/>span over multiple disks and support backing up<a class="indexterm" id="id134"/> through the use of snapshots. LVMs, although very good, still require a filesystem to sit on top of the logical volume and hence, incur an extra level of management; bearing in mind that the LVM system itself has three levels of management:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Physical volumes</strong></span>: These <a class="indexterm" id="id135"/>are the disk space made available to the LVM system</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Volume groups</strong></span>: These organize the physical volumes to be made available to the<a class="indexterm" id="id136"/> consumer</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Logical volumes</strong></span>: These consume the disk space made available via the volume <a class="indexterm" id="id137"/>groups and are presented to the filesystem tools to be formatted</li></ul></div><p>Now just <a class="indexterm" id="id138"/>because we have used such software for the last 10 years or so <a class="indexterm" id="id139"/>does not give it the right to continue unchallenged, even within the enterprise. We now see <span class="strong"><strong>B-tree filesystem</strong></span> (<span class="strong"><strong>BTRFS</strong></span>) pronounced as <span class="strong"><strong>Better FS</strong></span> making inroads in Linux. BTRFS is available on version 0.20 to install and can be used on CentOS 6.5, although caution should be taken, as it is marked as experimental.</p><div class="section" title="What BTRFS has to offer"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>What BTRFS has to offer</h2></div></div></div><p>With over 55 kernel-based filesystems in the Linux kernel tree currently, do we really need <a class="indexterm" id="id140"/>another one? The first issue here is that many filesystems have limited or very specific usage; only the extN systems such as ext2, ext3, and ext4 are truly general purpose but <a class="indexterm" id="id141"/>even with the latest incarnation of these, ext4, the size limit is 16 TB. BTRFS scales to 16 <span class="strong"><strong>exabytes</strong></span> (<span class="strong"><strong>EB</strong></span>) and brings reliability features previously not found, as<a class="indexterm" id="id142"/> follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Very fast filesystem creation</li><li class="listitem" style="list-style-type: disc">Data and metadata checksums</li><li class="listitem" style="list-style-type: disc">Snapshotting</li><li class="listitem" style="list-style-type: disc">Online scrub to fix issues</li></ul></div></div><div class="section" title="Installing BTRFS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Installing BTRFS</h2></div></div></div><p>On the <a class="indexterm" id="id143"/>CentOS 6.5 demonstration system I am using, we will first need<a class="indexterm" id="id144"/> to install BTRFS:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install -y btrfs-progs</strong></span>
</pre></div><p>Now that we have the utilities installed, we can begin to experience the power and simplicity of BTRFS. My lab machine currently has four additional free partitions on the second drive; each one consists of 1 GB to use in the following demonstrations.</p></div><div class="section" title="Creating a BTRFS filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Creating a BTRFS filesystem</h2></div></div></div><p>To kick off the <a class="indexterm" id="id145"/>show today, we will first create a BTRFS filesystem on a single 1 GB partition, mount it to the <code class="literal">/data</code> directory, and copy some data to it as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mkfs.btrfs /dev/sdb5 </strong></span>
<span class="strong"><strong># mount /dev/sdb5 /data </strong></span>
<span class="strong"><strong># find /usr/share/doc -name '*.pdf' -exec cp {} /data \; </strong></span>
<span class="strong"><strong># btrfs filesystem show /dev/sdb5 </strong></span>
</pre></div><p>From these commands, you will see that we copy some of the existing PDF files to give us some real data to use in the demonstration, ensuring that we will see no loss of data during the exercises. The final command line shows the filesystem and confirms it size of 1 GB.</p></div><div class="section" title="Expanding a BTRFS filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Expanding a BTRFS filesystem</h2></div></div></div><p>We may <a class="indexterm" id="id146"/>well be running out of space within the <code class="literal">/data</code> structure; we are not but we can imagine. If we were using an LVM structure, we would have to run several commands to expand the existing filesystem across a new partition or disk. This would be the process in LVMs:</p><p>Volume <a class="indexterm" id="id147"/>management in the old way requires us to execute the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># pvcreate /dev/sdb6</strong></span>
<span class="strong"><strong># vgextend vg1 /dev/sdb6</strong></span>
<span class="strong"><strong># lvextend -L+1000M /dev/vg1/data_lv</strong></span>
<span class="strong"><strong># resize2fs /dev/vg1/data</strong></span>
</pre></div></div><div class="section" title="Volume management with BTRFS"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Volume management with BTRFS</h2></div></div></div><p>As we <a class="indexterm" id="id148"/>can see, there are four commands to be executed, all<a class="indexterm" id="id149"/> with a generous sprinkling of syntax that will try to trip us up. We can now see how to do this using BTRFS:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs add device /dev/sdb6 /data</strong></span>
</pre></div><p>That's it! That is all that we needed to do, and we now have a 2 GB volume. We can confirm this by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># df -h /data</strong></span>
<span class="strong"><strong># btrfs filesystem show /dev/sdb5</strong></span>
</pre></div><p>Both commands will confirm that we now have 2 GB of disk space available in the volume and the data is still there and accessible. The volume metadata is copied to both partitions. In this way, we can view the volume information from either device:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs filesystem show /dev/sdb5</strong></span>
<span class="strong"><strong># btrfs filesystem show /dev/sdb6</strong></span>
</pre></div><p>Both commands will show the same data, as their metadata is stored on both devices.</p></div><div class="section" title="Balancing the filesystem"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Balancing the filesystem</h2></div></div></div><p>If we had genuinely added the extra partition because we were running out of disk space within the <a class="indexterm" id="id150"/>original volume, then we can balance the data across the complete volume now as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs balance start -d -m /data</strong></span>
</pre></div><p>The <code class="literal">-m</code> argument represents the metadata and <code class="literal">-d</code> represents the data. In this way, the disks are equally used.</p></div><div class="section" title="Adding an entry to /etc/fstab"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Adding an entry to /etc/fstab</h2></div></div></div><p>One would assume that we would like the <code class="literal">/data</code> directory mounted at boot time and we will add an <a class="indexterm" id="id151"/>entry to the <code class="literal">/etc/fstab</code> file. When mounting from this file, we must reference all the devices:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/dev/sdb5  /data  btrfs  device=/dev/sdb5,device=/dev/sdb6  0 0</strong></span>
</pre></div><p>In this way, we <a class="indexterm" id="id152"/>instruct the early mount process of the device construction when a BTRFS scan is not available.</p></div><div class="section" title="Creating an RAID1 mirror"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Creating an RAID1 mirror</h2></div></div></div><p>Software <span class="strong"><strong>redundant array of inexpensive disks</strong></span> (<span class="strong"><strong>RAID</strong></span>) is also support by BTRFS. The following<a class="indexterm" id="id153"/> are the currently supported RAID levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RAID 0: Striping<a class="indexterm" id="id154"/> without redundancy</li><li class="listitem" style="list-style-type: disc">RAID 1: Disk<a class="indexterm" id="id155"/> mirroring</li><li class="listitem" style="list-style-type: disc">RAID 10: Striped <a class="indexterm" id="id156"/>mirror</li></ul></div><p>We can create a mirrored device <a class="indexterm" id="id157"/>using BTRFS software mirroring, should we need it. This <a class="indexterm" id="id158"/>does not give us extra disk space, but does provide fault tolerance in the case of a disk failure. We can emulate this in our setup, but as all of our partitions are on one disk, it will not help against disk failure, but the idea holds true.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mkfs.btrfs -m raid1 -d raid1 /dev/sdb7 /dev/sdb8</strong></span>
<span class="strong"><strong># mount /dev/sdb7 /mirror</strong></span>
</pre></div><p>Creating the mirror, we use RAID1 for the metadata and data <code class="literal">-m</code> and <code class="literal">–d</code>, respectively. The disk space available is 1 GB. Whatever we write to <code class="literal">/dev/sdb7</code> is mirrored to <code class="literal">/dev/sdb8</code>; with mirroring, we lose 50 percent of the data storage but have a high level of redundancy.</p><p>We will again need to add an entry to the <code class="literal">/etc/fstab</code> file, as seen earlier to ensure the system mounts correctly during boot time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/dev/sdb7  /mirror  btrfs  device=/dev/sdb7,device=/dev/sdb8  0 0</strong></span>
</pre></div></div></div>
<div class="section" title="Using BTRFS snapshots"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Using BTRFS snapshots</h1></div></div></div><p>Analyzing what you have so far, BTRFS is quite cool, don't you think? However, we have not yet<a class="indexterm" id="id159"/> exhausted the wealth of goodness that it has to offer. Snapshots can be used as read only or read/write copies of data. The reality is that there is no <a class="indexterm" id="id160"/>need to copy data as it is effectively linked until it changes in one of the locations. In this way, a snapshot of a large filesystem can be taken instantly. You can use snapshots in the following ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">As part of a backup solution where you may be concerned with open files affecting the backup, the snapshot will be created as read only and subsequently you will implement a backup of the snapshot. In this way, the backup will be of the host filesystem at the point in time that the snapshot was created.</li><li class="listitem" style="list-style-type: disc">Snapshots can be useful where you know many files will change in a structure and you may want to restore the original files quickly. Perhaps where you are working with scripts to modify many files, you can easily revert to the snapshot copies if the scripts prove not to be as robust as you had imagined, thought, or hoped.</li></ul></div><p>The <a class="indexterm" id="id161"/>snapshot <span class="emphasis"><em>must</em></span> be created in the same filesystem as the target <a class="indexterm" id="id162"/>data; as we mentioned before, the rapid creation of the snapshot is affected by a form of internal linking within the filesystem. Within a BTRFS filesystem, we can create subvolumes. Subvolumes allow discrete management identities within the BTRFS filesystem. We will take a snapshot of a BTRFS subvolume storing it in another subvolume on the same filesystem.</p><p>To achieve this, we shall define two subvolumes within the <code class="literal">/data</code> BTRFS filesystem. Defining the subvolumes will create both the directories in the filesystem as well as the BTRFS subvolume entities. We will create a snapshot of the first subvolume, storing it in the second subvolume on the same <code class="literal">/data</code> filesystem. We cannot create a snapshot of the complete filesystem as changes to the snapshot will need to be written back to itself casing infinite recursion; believe me infinite recursion is not a good thing, not a good thing, not a good thing,…</p><p>Let's begin by creating the two subvolumes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs subvolume create /data/working</strong></span>
<span class="strong"><strong># btrfs subvolume create /data/backup</strong></span>
</pre></div><p>We can list subvolumes easily using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs subvolume list /data</strong></span>
</pre></div><p>With the subvolumes in place, we can now move our existing data to the <code class="literal">/data/working</code> directory, allowing some data to be ready for snapshotting. The working directory, as the name suggests, should be where our real data is stored and the lifeblood of our organization. If this data fails, then so does our organization and we lose our jobs. It makes sense that this data is managed carefully.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># mv /data/*.pdf  /data/working</strong></span>
</pre></div><p>Our scenario is that we test scripts that will delete files based perhaps on the last accessed time; I do realize that we should not be working with live data but living on the edge does liven up our otherwise mundane life. That said, we have not entirely lost all sense of the importance of this data. Before we run the scripts, we create a read-only snapshot of the data.</p><p>To create a read-only snapshot of the working subvolume, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs subvolume snapshot -r /data/working /data/backup/first-run</strong></span>
</pre></div><p>We can list the available subvolumes as shown earlier with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># btrfs subvolume list /data</strong></span>
</pre></div><p>From the <a class="indexterm" id="id163"/>output, we can see that the snapshot appears as a new <a class="indexterm" id="id164"/>subvolume. Listing the contents of both directories should indicate that the contents are the same:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ls /data/working</strong></span>
<span class="strong"><strong># ls /data/backup/first-run</strong></span>
</pre></div><p>The name <code class="literal">first-run</code> is not important, but perhaps we can create multiple snapshots based on the data before the first run of the scripts, before the second run of the scripts, and so on. At this stage, the snapshot really does not take up any space as the data is the same in both the source and destination. Should we delete all the files from <code class="literal">/data/working</code>, the <span class="strong"><strong>copy-on-write</strong></span> (<span class="strong"><strong>COW</strong></span>) technology in BTRFS will then create the files in <code class="literal">/data/backup/first-run</code>. This would also be the case if the files were modified <a class="indexterm" id="id165"/>in any way rather than deleted; the snapshot holds the files as they were at the time the snapshot was created. We can simply copy the files back to the original location in the event of a catastrophe.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Summary</h1></div></div></div><p>This chapter has seen us disseminate the filesystem structure that we find in CentOS Linux and opens our comfort zone to entertain new technologies such as BTRFS. We began with a little trickery or understanding of the hard link count that we can see with the <code class="literal">ls</code> or <code class="literal">stat</code> command. This count shows how many filenames are linked to the one inode or file metadata. Understanding the metadata of the file led us to look more at <code class="literal">/usr/bin/stat</code> and the options that it supplies to us including the three timestamps, not of the apocalypse but of the file itself: last access, last modified, and last changed.</p><p>A little foray into special permissions released the knowledge of how users can enable and disable console messaging, the console files being group owned by the <code class="literal">tty</code> group, and the write permission being added and removed.</p><p>Finally, we basked in the glory that is the BTRFS filesystem. This is truly something to start working with now as this will be the enterprise filesystem of choice for years to come. Providing both filesystem and volume management in a single task is simplified and improved beyond measure.</p><p>You now need to prepare yourself for the banquet that is YUM and of software repository management tool, Yellowdog Update Manager, ensuring that we know a little more than simply <code class="literal">yum install</code>.</p></div></body></html>