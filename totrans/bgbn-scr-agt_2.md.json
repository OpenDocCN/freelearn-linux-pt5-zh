["```\ndeb http://deb.torproject.org/torproject.org wheezy main\ndeb http://deb.torproject.org/torproject.org tor-experimental-0.2.5.x-wheezy main\n\n```", "```\ngpg --keyserver keys.gnupg.net --recv 886DDD89\ngpg --export A3C4F0F979CAA22CDBA8F512EE8CBC9E886DDD89 | sudo apt-key add -\n\n```", "```\nsudo apt-get update\n\n```", "```\nsudo apt-get install deb.torproject.org-keyring\n\n```", "```\nsudo ntpdate -b -u pool.ntp.org\n\n```", "```\nsudo apt-get install tor\n\n```", "```\nsudo apt-get install obfsproxy\n\n```", "```\nsudo pip install stem\n\n```", "```\n# We are running a relay, no need for the SocksPort\nSocksPort 0\n# Extra logging is nice\nLog notice file /var/log/tor/notices.log\n# Run in the background\nRunAsDaemon 1\n# The following two lines are so we can connect with the\n## Tor Stem library over the control port\nControlPort 9051\nCookieAuthentication 1\n# The is the Onion Router (OR) Port for normal relay operation\nORPort 9001\n# Your bridge's nickname, change!\nNickname changeme\n# Bandwidth settings\nRelayBandwidthRate 520 KB # Throttle traffic to 520 KB/s\nRelayBandwidthBurst 640 KB # But allow burts up to 640 KB/s\n# You put a real email here, but consider making a new account\n## or alias address\nContactInfo Random Person <nobody AT example dot com>\n# Do not exit traffic\nExitPolicy reject *:* # no exits allowed\n# Yes, we want to be a bridge\nBridgeRelay 1\n# Use the obfs3 pluggable transport\nServerTransportPlugin obfs3 exec /usr/bin/obfsproxy managed\n# Enable extra bridge statistics collection\nExtORPort auto\n# A nice option for embedded platforms to minimize writes\n# to eMMC or SD card\nAvoidDiskWrites 1\n```", "```\nExitPolicy reject *:*\n\n```", "```\nsudo service tor restart\n\n```", "```\ntail -n 20 /var/log/tor/notices.log\n\n```", "```\nMar 25 21:37:43.000 [notice] Tor has successfully opened a circuit. Looks like client functionality is working.\nMar 25 21:37:43.000 [notice] Bootstrapped 100%: Done.\n\n```", "```\ngrep obfs3 /var/log/tor/notices.log\n\n```", "```\nMar 05 01:56:04.000 [notice] Registered server transport 'obfs3' at '0.0.0.0:59519'\n\n```", "```\nServerTransportListenAddr obfs3 0.0.0.0:xxxx\n```", "```\nMar 25 21:37:43.000 [notice] Now checking whether ORPort xxx.xxx.xxx.xxx:9001 is reachable... (this may take up to 20 minutes -- look for log messages indicating success)\nMar 25 21:37:44.000 [notice] Self-testing indicates your ORPort is reachable from the outside. Excellent. Publishing server descriptor.\n\n```", "```\nsudo apt-get install build-essential python-dev python-setuptools python-pip python-smbus -y\nsudo pip install Adafruit_BBIO\nsudo pip install pyserial\n\n```", "```\nimport Adafruit_BBIO.GPIO as GPIO\nclass TorFreedomLED(object):\n  def __init__(self):\n    self.pin = 'P9_15'\n    GPIO.setup(self.pin, GPIO.OUT)\n\n  def on(self):\n    GPIO.output(self.pin, GPIO.HIGH)\n\n  def off(self):\n    GPIO.output(self.pin, GPIO.LOW)\n\n  def blink(self):\n    self.on()\n    sleep(.5)\n    self.off()\n```", "```\nimport Adafruit_BBIO.UART as UART\nimport serial\nclass FrontPanelDisplay(object):\n\n  def __init__(self):\n    self.uart = 'UART4'\n    UART.setup(self.uart)\n self.port = serial.Serial(port=\"/dev/ttyO4\", baudrate=9600)\n    self.port.open()\n```", "```\nself.clear_screen()\nup_str = '{0:<16}'.format('Up:   ' + self.block_char * up)\ndn_str = '{0:<16}'.format('Down: ' + self.block_char * down)\n\nself.port.write(up_str)\nself.port.write(dn_str)\n```", "```\nimport Adafruit_BBIO.ADC as ADC\nimport threading\nfrom time import sleep\nfrom math import ceil, floor\nimport Queue\nclass BandwidthKnob(threading.Thread):\n\n  def __init__(self, pin, *args, **kwargs):\n\n    threading.Thread.__init__(self, *args, **kwargs)\n    self.pin = pin\n    self.setup_adc()\n    self.kill = False\n    self.prev_value = -1\n    self.q = Queue.Queue()\n\n  def setup_adc(self):\n    'Load the Adafruit device tree fragment for ADC pins'\n ADC.setup()\n\n  def read_value(self):\n    return ceil(10 * ADC.read(self.pin))\n\n  def stop(self):\n    self.kill = True\n\n  def run(self):\n    knob = self.prev_value\n\n    while knob != 0 and not self.kill:\n      sleep(1)\n      knob = self.read_value()\n      if knob != self.prev_value:\n self.q.put(knob)\n        self.prev_value = knob\n```", "```\nsudo pip install git+https://github.com/sivel/speedtest-cli.git\n\n```", "```\nspeedtest-cli --simple > speedtest.txt\n\n```", "```\nPing: 107.686 ms\nDownload: 28.23 Mbit/s\nUpload: 5.37 Mbit/s\n\n```", "```\ndef make_bw_callback(test,lcd):\n  '''Returns a callback function for the bandwidth event'''\n  def print_bw(event):\n    '''Obtains the bandwidth used from the last second from the\n       bridge, normalizes it to the total bandwidth, and draw \n       that information to the display'''\n    up = int(test.get_up_ratio(event.written))\n    down = int(test.get_down_ratio(event.read))\n    lcd.display_graph(up, down)\n\n  return print_bw\n```", "```\ndef make_conf_callback(lcd):\n  '''Returns a callback function for the configuration changed\n     event'''\n  def conf_changed(event):\n    '''Reads the new bandwidth rates from the bridge and draws\n       that information to the display'''\n    rate = str(int(event.config['RelayBandwidthRate']) / 1024)\n    burst = str(int(event.config['RelayBandwidthBurst']) / 1024)\n    lcd.display_rates(rate, burst)\n\n  return conf_changed\n```", "```\nsudo python beaglebridge.py ~/speedtest.txt &\n\n```"]