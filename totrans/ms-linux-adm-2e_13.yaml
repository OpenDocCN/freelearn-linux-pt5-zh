- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring Linux Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to set up different types of Linux servers.
    This will include **Domain Name System** (**DNS**) servers, **Domain Host Configuration
    Protocol** (**DHCP**) servers, **Samba** or **Server Message Block**/**Common
    Internet File System** (**SMB**/**CIFS**) file servers, and **Network File System**
    (**NFS**) servers. All these servers, in one way or another, are powering the
    backbone of the World Wide Web. Even though we will not cover it here, you should
    know that the reason your computer is showing the exact time is because of a well-implemented
    **Network Time Protocol** (**NTP**) server. You can shop online and transfer files
    between your friends and colleagues thanks to effective DHCP, web, and file servers.
    Configuring the different types of Linux services that power all these servers
    represents the knowledge base for any Linux system administrator. In this edition
    of the book, we will only cover a select few of these Linux servers, those we
    consider the most important and major Linux servers currently. For further information,
    please refer to the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Linux services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an SSH server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a DNS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a DHCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up an NFS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Samba file server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of networking and Linux commands is required. You will need
    access to multiple working systems, preferably on premise or in the cloud. If
    this is not possible, you can use local virtual machines on your system. Furthermore,
    it would be useful to have a domain available for you to use too. We will use
    Ubuntu Server 22.04.2 LTS as the distribution of choice for this chapter’s exercises
    and examples. Nevertheless, any other major Linux distribution—such as Fedora,
    RHEL, openSUSE, or Debian—is equally suitable for the tasks detailed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Linux services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything you have learned up until now will easily apply to any workstation
    or desktop/laptop running Linux. We have delved into advanced networking subjects
    that are meant to ease your learning path to becoming a seasoned Linux system
    administrator. Now we will enter the *server* territory as a natural path to the
    *cloud*, which will be discussed in detail in the last four chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: A **Linux server**, compared to a Linux workstation, is a system that serves
    content over a network. While doing so, a server provides its hardware and software
    resources to different clients that are accessing it. For example, every time
    you enter a website address into your browser, a server is accessed. That particular
    type of server is a **web server**. When you print over the network in your workplace,
    you access a **print server**, and when you read your email, you access a **mail
    server**. All these are specialized systems that run a specific piece of software
    (sometimes called a service) that provides you, the client, with the data you
    requested. Usually, servers are very powerful systems that have lots of resources
    available for a client’s use.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, a **workstation** (which is yet another powerful piece of hardware)
    is generally used for personal work, not for client access over a network. A workstation
    is used for intensive work, similar to any regular desktop or laptop system. In
    light of everything we have exposed up to now, the contents of this chapter and
    the following chapters are best suited for server use, but not limited to it.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably already heard about setting up different Linux servers—such
    as a web server, a file server, or an email server—and have probably wondered
    why they are called that. They do not represent the hardware boxes that are the
    actual servers—they are basically services running on top of Linux. So what are
    Linux services? These are programs that run in the background. Inside the Linux
    world, those services are known as `init` process in [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104),
    *Working with Processes, Daemons, and Signals*, when we discussed what processes,
    daemons, and signals are and how to manage them on Linux. The mother of all processes
    is the `init` process, which is among the first processes when Linux boots up.
    Currently, the latest version of Ubuntu (and also CentOS, Fedora, openSUSE, and
    others) uses `systemd` as the default `init` process.
  prefs: []
  type: TYPE_NORMAL
- en: We will refresh your memory by using some basic commands for working with services
    on Linux. If you want more information, please refer to [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104),
    *Working with Processes, Daemons,* *and Signals*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command we will remind you of is the `ps` command. We will use it
    to show the `init` process running, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output on our Ubuntu 22.04.2 system is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Showing the init process by using the ps command](img/B19682_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Showing the init process by using the ps command
  prefs: []
  type: TYPE_NORMAL
- en: By using the `-e` flag, we can generate information about all processes, except
    kernel-related ones, while the `-f` flag is used to generate a full listing.
  prefs: []
  type: TYPE_NORMAL
- en: In the process list shown, the first process is either the `init` process or
    `systemd`. Sometimes, on older operating systems (such as Ubuntu 20.04 or 18.04),
    it uses the `init` name for backward-compatibility issues, but to make sure that
    it really is `systemd`, you can use the manual pages of `init` for more details.
    When you type `man init` in the command line, the manual page shown is for `systemd`.
    As the parent of all services, `systemd` starts all the running processes in parallel
    as a way to make the boot process and service-time response more efficient. To
    see how efficient those processes are, you can run the `systemd-analyze` command.
  prefs: []
  type: TYPE_NORMAL
- en: A command we have frequently used, and one you should already know, is the `systemctl`
    command, which is the main command-line utility for working with `systemd` services
    (or daemons) on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know `systemctl` invokes `systemd`. Those units have several types,
    such as service, mount, socket, and others. To see those units listed by the time
    they take to start up, you can use the `systemd-analyze blame` command, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The systemd-analyze blame command](img/B19682_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The systemd-analyze blame command
  prefs: []
  type: TYPE_NORMAL
- en: The output shows different types of units, such as *service*, *mount*, and *device*.
    The preceding screenshot is only an excerpt of the running units. To learn more
    about the `systemctl` command, feel free to use the manual pages, or go back to
    [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104) to refresh your memory.
  prefs: []
  type: TYPE_NORMAL
- en: This brief introduction to Linux services is only a refresher of the respective
    sections from [*Chapter 5*](B19682_05.xhtml#_idTextAnchor104), enough for you
    to start delving into setting up and configuring specific Linux services. In the
    following sections, we will show you how to manage some of the most important
    services on Linux, such as **SSH**, **DNS**, **DHCP**, **NTP**, **Samba**, **NFS**,
    **web**, **File Transfer Protocol** (**FTP**), and **printing services**. Now,
    it’s time to roll up your sleeves and configure them yourself. First, we will
    show you how to set up an SSH server on Ubuntu Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will configure SSH on a computer running Ubuntu Server 22.04.2 LTS as the
    host operating system. Throughout the entire book, we used SSH connections several
    times, and showed you how to create an SSH key pair in [*Chapter 11*](B19682_11.xhtml#_idTextAnchor231),
    *Working with Virtual Machines*, when we worked with cloud-init. This time, we
    will show you how to install **OpenSSH**, how to enable SSH, and how to modify
    some of its configuration defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring OpenSSH on Ubuntu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use SSH, the first thing we need to do is to install the `openssh`
    package. On Ubuntu, this can be done by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Chances are that it is already installed on your system. If that is the case,
    you can go ahead and skip this step and go to the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, we can start and enable the `openssh` service with the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For openSSH, the configuration file that we can work with is located under
    `/etc/ssh/sshd_config`. By default, this file already contains a lot of information,
    all we need to do is to open it with our text editor and start modifying the available
    options. Depending on what we want to achieve, the bare minimum configuration
    for SSH involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the remote root login options; this can be done by changing the line
    with the following code and setting the option accordingly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our case, we modified the default `prohibit-password` option to `no`, so
    that the root user will not be able to connect through SSH at all.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Disable the SSH password authentication. This can be done by changing the following
    lines to `no`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do this only after you copy your key pair on the remote machine and make sure
    you can use it. Otherwise, you won’t be able to access your server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To allow public key authentication, you will need to uncomment the following
    line:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will quickly show the commands used in [*Chapter 11*](B19682_11.xhtml#_idTextAnchor231)
    to enable public keys authentication, as a reminder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ssh packt@192.168.0.113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The configuration options presented here are the base minimum to start using
    SSH when working with a remote system or a virtual machine. However, OpenSSH is
    a very powerful tool that offers lots of options that you could explore. Here
    are two links that could help you in your endeavors: [https://ubuntu.com/server/docs/service-openssh](https://ubuntu.com/server/docs/service-openssh)
    and [https://www.openssh.com/](https://www.openssh.com/)manual.html. In the following
    section, we will show you how to set up a DNS server.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a DNS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most widely used DNS services is **Berkeley Internet Name Domain
    9** (**BIND 9**). You can visit its official website at the following address:
    [https://www.isc.org/bind/](https://www.isc.org/bind/). Before continuing, let’s
    underline the system configuration and goals. For this section, we will use a
    computer running on Ubuntu Server 22.04.2 LTS. On this system, we will create
    two types of servers, a **caching name server** and a **primary name server**,
    which you can use on your local network to manage hostnames and private IP addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different DNS servers, such as **authoritative**, **caching**, or
    **forwarding** types; those are also called functional types. Among those, a caching
    DNS server is the one that always answers recursive requests from clients. Also,
    there are **relational server types**, such as primary and secondary DNS servers.
    Those are authoritative types, and are almost identical, with the only difference
    between the primary and the secondary being the location from which they get the
    zones’ information. For more information on DNS, you can consult the following
    links: [https://www.digitalocean.com/community/tutorials/a-comparison-of-dns-server-types-how-to-choose-the-right-dns-configuration](https://www.digitalocean.com/community/tutorials/a-comparison-of-dns-server-types-how-to-choose-the-right-dns-configuration)
    and [https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts](https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts).'
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to do this, but for the purpose of showing you the basics
    of DNS setup, this configuration will suffice. If you would like a secondary server,
    you will need to have another spare system, or if you use **virtual private servers**
    (**VPSs**), they would have to be in the same data center and be using the same
    private network. In our case, however, we will use a local system on our small
    private network.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install the `bind9` package in Ubuntu by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install all the packages needed for BIND9 to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the packages are installed, you can test them to see whether BIND works
    as expected. For this, we will use the `nslookup` command, as shown in the following
    screenshot, by using the local address (or *loopback* address):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Checking to see whether BIND is working using nslookup](img/B19682_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Checking to see whether BIND is working using nslookup
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now start setting up the service, as you can see it is working. First,
    we will configure a caching DNS service. But before we start, we advise you to
    back up the following configuration files: `/etc/bind/named.conf`, `/etc/bind/named.conf.options`,
    `/etc/hosts`, and `/etc/resolv.conf`. Let’s see how to create a caching server.'
  prefs: []
  type: TYPE_NORMAL
- en: Caching a DNS service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default behavior of BIND9 is as a caching server. This means that setting
    it up is quite straightforward. We will tweak the configuration file just a little,
    in order to make it work according to our requests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After seeing that the installed packages work as intended, you can also configure
    the firewall to allow BIND9, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: // listen-on-v6 { any; };
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will have to add a list of IP addresses inside the `forwarders` directive.
    This line tells the server where to look in order to find addresses not cached
    locally. For simplicity, we will add the Google public DNS servers, but feel free
    to use your `forwarders` directive to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also add a directive defining the `allow-query` spectrum. This line
    tells the server which networks can be accepted for DNS queries. You can add your
    local network address. In our case, it will be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also a `listen-on` directive, where you can specify the networks the
    DNS server will work for. This applies for IPv4 addresses and is shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the added options, the code you added should appear as in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The final form of /etc/bind/named.conf.options after adding
    new options](img/B19682_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The final form of /etc/bind/named.conf.options after adding new
    options
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and exit the editor. You can check the BIND9 configuration with
    the `named-checkconf` command. If there is no output, it means that the configuration
    of the file is correct. Restart the BIND9 service and optionally check its status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Knowing that the BIND9 service is working fine, you can test the service from
    any other computer on the network with the `nslookup` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Testing the BIND9 implementation](img/B19682_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Testing the BIND9 implementation
  prefs: []
  type: TYPE_NORMAL
- en: We used the command with the host’s IP address, as seen in the previous screenshot.
    The output shows that the DNS service on our test machine is working fine. The
    test was conducted from a local ThinkPad on the same network.
  prefs: []
  type: TYPE_NORMAL
- en: You now have a working caching DNS server on your private network. In the next
    section, we will show you how to create a primary DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a primary DNS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to configure a primary DNS server, we will need a domain name that
    it will serve. For this section’s purpose, we will use the `calcatinge.ro` domain
    name (when you try on your system, please use a domain name you own). We will
    have to create new zones for the BIND9 configuration, and we will add information
    to the `/etc/bind/named.conf.local` file about the ones we create. Right now,
    we will create a new zone for our `calcatinge.ro` domain.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a **DNS zone**? The short answer is that it is a part of a domain namespace
    associated with an entity responsible for maintaining it. Zones also offer a granular
    take on administrating different components. For more information on DNS zones,
    please refer to the following link: [https://ns1.com/resources/dns-zones-explained](https://ns1.com/resources/dns-zones-explained).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the contents of our configuration
    file, followed by details on each of the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – New zone for our domain in /etc/bind/named.conf.local file](img/B19682_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – New zone for our domain in /etc/bind/named.conf.local file
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s explain the contents of a zone directive:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we had to add the name of the domain that the zone will serve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `type` of the zone is set as `master`, but there are other types to use,
    such as `slave`, `forward`, or `hint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `file` represents the path to the actual zone file that will be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `allow-transfer` list, the IPs of DNS servers that handle the zone are
    set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `also-notify` list, the IPs of servers that will be notified about zone
    changes are indicated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a new zone for our chosen domain:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how we copied the `db.local` file under another
    name and used it for a new zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Creating the zone file for our domain](img/B19682_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – Creating the zone file for our domain
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the zone file, as indicated in the zone directive
    about `calcatinge.ro`. The details are shown in the preceding screenshot and as
    you can see, its location is `/etc/bind/`. Once the file is created using `db.local`
    as a template, you can open it with your favorite text editor and add information
    about your server IP and domain name. In the following screenshot, you can see
    the zone file for `calcatinge.ro` created on our machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Zone file information](img/B19682_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Zone file information
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS records are introduced at the end of the file. Here are some details
    about the contents of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The table has a specific format that contains details about hostname (first
    column), class (second column), DNS record type (third column), and value (the
    last column).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the hostname, we entered `@`, which means that the entry of the record refers
    to the zone name from the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The class is `IN`, which indicates that the network is the internet.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS records types are `A`, `NS`, `MX`, `CNAME`, `TXT`, and `SOA`. `A` indicates
    the IP address of the domain name; `NS` indicates the IP address of the DNS server;
    `MX` is the address of the email server; `CNAME` is an alias (canonical name);
    and `TXT` has a custom entry, `SOA`, which indicates the authoritative name server
    for the zone, with details on the administrator, serial number, and refresh rates.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The value in the last column most often comprises of the IP address or the hostname.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to restart the **Remote Name Daemon Control** (**RNDC**),
    which is a control utility inside BIND that controls the name server. The command
    to do that is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can check to see if the primary DNS server works. Try the `nslookup`
    command from another system on the network, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The output of the preceding command will most certainly show that the local
    DNS server on the system with the indicated IP address has a working zone file.
    Your primary DNS server works as expected on your local network. Don’t forget
    to use your IP inside the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is always a good idea to create a secondary DNS server in case the first
    one stops working, which is why we will show you how to set up a second one in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a secondary DNS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It comes as no surprise that the secondary DNS server should be set up on different
    hardware from the primary one, but on the same network. If you do it inside a
    data center, use a VPS in the same network as the first one. If you plan to experiment
    with it on your home private network, make sure you have another system at your
    disposal.
  prefs: []
  type: TYPE_NORMAL
- en: We will start another NUC system available that is also running Ubuntu Server
    22.04.2 LTS. We will need to know its IP address in order to use it in our configuration.
    In our case, the IP of the new system is `192.168.0.140`. This second machine
    needs to have BIND9 installed and configured too. Before setting up the secondary
    server, you will need to modify the configuration of the primary DNS server first.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the primary server configuration files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To modify the configuration of the primary DNS server and allow it to send
    the zone details to the secondary server, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will have to open the `/etc/bind/named.conf.local` configuration file and
    add some new lines to it. We add the second server’s IP address inside the `allow-transfer`
    and `also-notify` directives, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Adding the IP of the secondary DNS server](img/B19682_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Adding the IP of the secondary DNS server
  prefs: []
  type: TYPE_NORMAL
- en: Save the file and restart the BIND9 service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will also need to open the `/etc/bind/named.conf.options` configuration
    file and add an access list parameter (`acl "trusted"`) with all the accepted
    IP addresses on the network. In our case, the primary server has the address `192.168.0.113`,
    and the secondary server has the address `192.168.0.140`. Add this before the
    already existing `options` directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `options` directive block, below the comments, we also add the following
    directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Adding new directive inside /etc/bind/named.conf.options file](img/B19682_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Adding new directive inside /etc/bind/named.conf.options file
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration is finished, and we will restart the BIND9 service using
    the `systemctl` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before proceeding further, let’s understand the directives used. The `recursion`
    directive has a boolean value (`yes` | `no`) and defines whether recursion and
    caching are allowed or not on the server. The default is `yes`, and thus the server
    will require DNS query recursion by solving all the attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Recursion** is also known as **recursive query**, which in the case of DNS
    refers to the way a name resolution is solved. The recursive mode represents the
    way a computer looks for a FQDN by inquiring first at the local cache data and
    the local DNS server. The request is clear and demands a precise answer, and the
    solution for that answer is the responsibility of the DNS server. Thus, the query
    initiated by the computer, which is a DNS client, to the DNS server is a recursive
    query.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `allow-recursion` directive is referenced to a list of matching addresses
    of clients, in our case specified by a `listen-on` directive specifies the IP
    on which the server listens. And we also used the `allow-transfer` directive that
    provides a list of hosts that are allowed to transfer zone information (in our
    case, none). For more information about configuration options, please refer to
    the following link: [https://bind9.readthedocs.io/en/latest/reference.html#](https://bind9.readthedocs.io/en/latest/reference.html#).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to configure the secondary server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the secondary server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the secondary server, as stated earlier, you will need to install BIND9
    too. Once it is installed, you will need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `/etc/bind/named.conf.options` file and add the following lines in
    an `acl` directive, before the already existing `options` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Adding an acl directive on the secondary server](img/B19682_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – Adding an acl directive on the secondary server
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the following lines inside the `options` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Adding new directives inside options](img/B19682_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.12 – Adding new directives inside options
  prefs: []
  type: TYPE_NORMAL
- en: Now edit the `/etc/bind/named.conf.local` file and add the zones you want, but
    this time use the `secondary` type, as opposed to the `master` one used on the
    primary DNS server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a comparison between the two `/etc/bind/named.conf.local`
    files. On the left is the file on the primary DNS server, and on the right is
    the file on the secondary DNS server:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Configuration files from primary (left) and secondary (right)
    servers](img/B19682_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – Configuration files from primary (left) and secondary (right)
    servers
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can restart the BIND9 service and make sure that the firewall is allowing
    DNS connections on the second server with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you have two DNS servers set up and working, one primary and one secondary.
    In the following section, we will show you how to set up a local DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a DHCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DHCP is a network service that is used to assign IP addresses to hosts on a
    network. The settings are enabled by the server, without any control from the
    host. Most commonly, the DHCP server provides the IP addresses and netmasks for
    clients, the default gateway IP, and the DNS server’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the DHCP service on Ubuntu, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a test system, we will use the same system on which we installed the DNS
    services in the previous section. After installation, we will configure two specific
    files. On an Ubuntu system, like ours, the default configuration will be set inside
    the `/etc/dhcp/dhcpd.conf` file, while the interfaces will be configured inside
    the `/``etc/default/isc-dhcp-server` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first show you how to set up a basic local DHCP server. In this respect,
    we will alter the `/etc/dhcp/dhcpd.conf` file by adding the IP address pool. You
    can either uncomment one of the `subnet` directives already available inside the
    file, or you can add a new one, which is what we will do. Our existing subnet
    is `192.168.0.0/24`, and we will add a new one for this new DHCP server, as shown
    in the following screenshot (for a refresher on networking, please refer to [*Chapter
    7*](B19682_07.xhtml#_idTextAnchor139), *Networking* *with Linux*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Defining a new subnet in /etc/dhcp/dhcpd.conf](img/B19682_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.14 – Defining a new subnet in /etc/dhcp/dhcpd.conf
  prefs: []
  type: TYPE_NORMAL
- en: Inside the same `/etc/dhcp/dhcpd.conf` file, you can uncomment the line that
    says `authoritative;`. The `authoritative` DHCP clause ensures that the server
    will automatically resolve any invalid IP numbers on the network and assign a
    new and valid IP to each new device registered without requiring the user’s manual
    interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the options are modified, you must specify the network interface name
    in the `/etc/default/isc-dhcp-server` file. This is needed for the server to know
    which network device to use. To do this, open the file with your preferred editor
    and add the interface’s name. If you don’t remember your interface name, run the
    `ip addr show` command and select the appropriate interface. In our case, the
    system we use has both Ethernet and wireless interfaces, and we will choose the
    Ethernet interface for the DHCP server, which is `enp0s25`. Inside the `/etc/default/isc-dhcp-server`
    file, add the interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, save the changes to the file and restart the DHCP service with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have a working DHCP server on your system of choice. A DHCP server
    gives you some advantages in managing your local network, but there are times
    when you might not need to create a new one, as all the network routers provide
    a fully working DHCP service right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid conflicts, you might want to isolate the new DHCP server from your
    local network router. Your network router already has a fully functional DHCP
    server that will most likely conflict with the new one. In most cases, `isc-dhcp-server.service`
    will give you an error as an indication that it was not able to connect to any
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the preceding note into consideration, when we check to see whether
    the DHCP service is running with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We received an error, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Error running the DHCP service](img/B19682_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.15 – Error running the DHCP service
  prefs: []
  type: TYPE_NORMAL
- en: Once you isolate the machine from your local network and use it as a single
    DHCP server, the service will be running as intended.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show you how to set up an NFS server on your local
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an NFS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NFS is a distributed filesystem used to share files over a network. To show
    you how it works, we will set up the NFS server on one of our machines on the
    network. We will use Ubuntu 22.04.2 LTS as the base for the NFS server. For more
    in-depth theoretical information about NFS, please refer to [*Chapter 7*](B19682_07.xhtml#_idTextAnchor139),
    *Networking* *with Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: The NFS filesystem type is supported by any Linux and/or Unix environment and
    also by Windows, but with some limitations. For mostly-Windows client environments,
    we recommend using the Samba/**Common Internet File System** (**CIFS**) protocol
    instead. Also, for those of you concerned about privacy and security, please keep
    in mind that the NFS protocol is not encrypted, thus any transfer of data is not
    protected by default.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the NFS server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On our network, we will use an Ubuntu machine as a server and we will show
    you how to access the files from another Linux client. First, let’s install and
    configure the server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install the `nfs-kernel-server` package using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo systemctl start nfs-kernel-server.service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sudo systemctl enable nfs-kernel-server.service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '/home directory for all clients on the network, or you could make a dedicated
    shared directory from the start. You could create a new directory starting from
    the root, but you could also create your shared directory inside specific directories
    such as /var, /mnt, or /srv—it’s your choice.We will create a new directory called
    `/home/export/shares` inside our `/home` directory using the following commands
    (make sure that you are already inside your `/home` directory if you want to use
    the command as is):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '/etc/exports file. There are three configuration files for NFS (/etc/default/nfs-kernel-server,
    /etc/default/nfs-common, and /etc/exports) but we will only alter one of them.
    In the following screenshot, you will see the two files inside /etc/default and
    the default contents of the /etc/exports configuration file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.16 – The configuration files inside /etc/default and the contents
    of the /etc/exports configuration file](img/B19682_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.16 – The configuration files inside /etc/default and the contents
    of the /etc/exports configuration file
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `/etc/exports` file with your preferred text editor and edit it according
    to your configuration. Inside the file, we will add lines for each shared directory.
    Before doing that, you might have noticed that inside the file there are two types
    of directives: one for NFS versions 2 and 3, and one for version 4\. For more
    details about the differences between those versions, we encourage you to consult
    the following document: [https://archive.fosdem.org/2018/schedule/event/nfs3_to_nfs4/attachments/slides/2702/export/events/attachments/nfs3_to_nfs4/slides/2702/FOSDEM_Presentation_Final_pdf.pdf](https://archive.fosdem.org/2018/schedule/event/nfs3_to_nfs4/attachments/slides/2702/export/events/attachments/nfs3_to_nfs4/slides/2702/FOSDEM_Presentation_Final_pdf.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s start editing the configuration file. We will add a new line containing
    the directory, the IP address of the client, and configuration options. The general
    syntax is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We share only one directory, hence the single line added. If you want all clients
    on the network to access the shares, you can add the subnet class (for example,
    `192.168.0.0/24`). Or, if you want only specific clients to access the shares,
    you should add their IPs. More clients will be added on the same line, separated
    by spaces. There are many options that you can add, and for a full list, we advise
    that you consult [https://linux.die.net/man/5/exports](https://linux.die.net/man/5/exports)
    or the local manual file with the `man exports` command. In our file, we added
    the following options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`rw` for both read and write access'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync` to force write changes to disk (this reduces the speed, though)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_subtree_check` to prevent subtree checking, which is mainly a check to
    see whether the file is still available before the request'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a nutshell, here is the line we added to the file (please take into consideration
    that this is only a single line, with a space between `/home/export/shares` and
    the IP, and there is no space between the IP and the parentheses):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After saving and closing the file, restart the service with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, apply the configuration with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the service is restarted and running, you can set up a firewall to allow
    NFS access. For this, it is extremely useful to know that the port NFS is using
    port `2049` by default. As we allow all the systems from our network to access
    the shares, we will add the following new rule to the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the new firewall rule has been added, we can run the following command
    to make sure that it is running according to our needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your firewall is not actively running, you can use the following command
    to activate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.17 – Showing the new firewall rule to allow NFS shares](img/B19682_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.17 – Showing the new firewall rule to allow NFS shares
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that after adding the new rule using
    the `sudo ufw allow nfs` command, port `2049` was added to the list of allowed
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The basic configuration of the server is now complete. In order to access the
    files, you will need to configure the clients too. We will show you how to do
    this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the NFS client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a client, we will use another system, a laptop running Debian GNU/Linux
    12 Bookworm. First, we will have to install NFS on the client by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the needed packages are installed on the client too, we can create
    directories on the client to mount the shares to. We will create a new directory
    on the client, where the shares from the server will be mounted. This new directory
    will be `/home/shares`. We create it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the new directory is created, we can mount the location from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding command, we mounted the shares from the server on the client
    using the `mount` command. We gave the location on the server as the first argument,
    followed by the location on the client as the second argument. We can also check
    to see whether everything went well by using the `df -h` command. The new mount
    is shown last in the `df` command’s output. The following is a screenshot showing
    the commands used to create, mount, and check the new shares directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Mounting the new shares directory on the client](img/B19682_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.18 – Mounting the new shares directory on the client
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have finished the setup for the NFS shares. We now need to
    test the configuration to prove that it works.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the NFS setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the setup is finished on both server and client, you can test to see if
    everything works according to your expectations. In our test, we created several
    files named `testing_files` using the `packt` user on the server, and a file called
    `file` using the regular user `alexandru` on the client machine. The following
    is the output showing the contents of the `/home/shares` directory on our Debian
    local system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Testing the NFS on our local client](img/B19682_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.19 – Testing the NFS on our local client
  prefs: []
  type: TYPE_NORMAL
- en: There you have it, the NFS server and client are working just fine. You can
    use the **graphical user interface** (**GUI**) on the client (as shown in the
    previous screenshot), and also the **command-line interface** (**CLI**) to access
    the NFS shares.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show you how to configure a Samba/CIFS share that
    can be accessed by Windows clients on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Samba file server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Samba server allows you to share files over a network where clients use
    different operating systems, such as Windows, macOS, and Linux. In this section,
    we will set up a Samba server on Ubuntu 22.04.2 LTS and access shares from different
    operating systems on the network. The SMB/CIFS protocol is developed by Microsoft;
    for more details, you can visit their developer pages at [https://docs.microsoft.com/en-us/windows/win32/fileio/microsoft-smb-protocol-and-cifs-protocol-overview](https://docs.microsoft.com/en-us/windows/win32/fileio/microsoft-smb-protocol-and-cifs-protocol-overview).
    Some information about the SMB/CIFS protocol can be found in [*Chapter 7*](B19682_07.xhtml#_idTextAnchor139),
    *Networking with Linux*, too. In the following sub-sections we will show you how
    to install and configure it on your local network.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Samba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation procedure has the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will install Samba on the system using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once Samba is installed, we can check whether the service is running as expected.
    We will run the following command for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '/etc/samba/smb.conf. The configuration file has two major sections: a [global]
    section with general configuration settings, and a [shares] section that configures
    the shares’ behavior. A safe practice is to back up the original configuration
    file before starting to modify it. We will do this with the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.20 – The smb.conf global directive](img/B19682_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.20 – The smb.conf global directive
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us briefly explain the content shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line sets a server name, in our case Local Samba File Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line sets the `workgroup` name, in our case the Windows default name,
    `WORKGROUP`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line determines that it will not be necessary to have a Samba user
    account in order to access the shares (mapping the guest to `Bad User`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guest users are allowed on the fourth line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we set the interfaces used by Samba, which in our case will be the Ethernet
    connection (`eno1`) and the loopback (`lo`) interfaces (check your exact interface
    name with the `ip addr show` or `ip` `link` commands)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will set the `server role` and the hosts allowed (from the local pool)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line sets the order the hostnames are checked, using the broadcast
    (`bcast`) method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we will create the `[shares]` directive and add the necessary configuration
    options for the shares. We will add details about the shared directory on our
    server, user details, and permissions. See the following screenshot for details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Adding information inside the shares.conf file](img/B19682_13_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.21 – Adding information inside the shares.conf file
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us briefly explain the contents of this directive:'
  prefs: []
  type: TYPE_NORMAL
- en: We first set a name for the shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we set the path of our local shared directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we set the default permissions for the directory and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also set the default mask values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set the shares as public, guest-user friendly, and writable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the modifications are done, we restart the service with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, we adjust the firewall rules to allow Samba using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 13.22 – Testing the Samba configuration](img/B19682_13_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.22 – Testing the Samba configuration
  prefs: []
  type: TYPE_NORMAL
- en: The output shows `Loaded services file OK`, which means that the configuration
    files have no syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: After the system is restarted and the firewall configured, we can proceed to
    setting up a Samba password for users who can access the shares. In the next section,
    we will create new Samba users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Samba users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each Samba server needs to have specific users that can access the shared directories
    and files. Those users need to be both Samba and system users, as this is necessary
    for users to be able to authenticate and to read and write system files. Let’s
    assume that you need to create a local share for your small business or family
    group.
  prefs: []
  type: TYPE_NORMAL
- en: 'By creating local users specifically for using the Samba shares, you don’t
    need them to act like actual users as they only need to be able to access the
    shares. However, local Samba users need to be local system users. In our case,
    we will use our local `packt` user to create a new user for Samba:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the following command to add the `packt` local user to Samba:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'alex using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we add it to Samba with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: valid users = @packt @alex
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before testing the new user’s access to Samba, we will need to give the user
    `alex` access to the shared directory. To do this, we follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the `acl` package in Ubuntu with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo setfacl -R -m "u:alex:rwx" /home/packt/samba_shares
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next section, we will show you how to access the Samba shares from different
    systems on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Samba shares
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On your network, you can access the shares from Linux, macOS, or Windows. To
    make everything a little bit challenging—worthy of a Linux master!—we will show
    you how to access the Samba shares in Linux using the CLI only. We will let you
    find out for yourselves how to access them from the GUI or from a Windows or macOS
    client. To access the shares from the CLI, use the `smbclient` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Linux system, you need to install the Samba client `smbclient` first.
    We will assume that you will have an Ubuntu or Debian Linux client, but the steps
    are similar for other Linux distributions too. On Ubuntu/Debian, first install
    the Samba client with the following command, but make sure that your repositories
    are updated before you do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running a Fedora/RHEL client, install the Samba client with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let’s access the shares of user `packt` from one of our local
    machines. Remember that the shares are on a local server running Ubuntu. We will
    use our local IP for the server and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Accessing shares from a Linux CLI client](img/B19682_13_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.23 – Accessing shares from a Linux CLI client
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see that the Samba access was successful,
    and the user `packt` managed to access the Samba shares on the server. We used
    the `-U` option followed by the username to specify the name of the user we are
    connecting with. The location was given using the server’s local IP, followed
    by the Samba `samba shares` name. Furthermore, if we would like to see the Samba
    services available on the server, we could use the `-L` option with the `smbclient`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Listing the available services on the Samba server](img/B19682_13_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Listing the available services on the Samba server
  prefs: []
  type: TYPE_NORMAL
- en: Here we are, at the end of this chapter on configuring Linux servers. The servers
    showcased were considered important and relevant for any Linux sysadmin to know.
    However, there are many other types of Linux servers not covered due to page-count
    constraints. Nevertheless, there are plenty of resources you can find online.
    As a base, you can start with the official documentation for RHEL, Ubuntu, or
    Debian, which will cover most of the Linux server types that you should know.
    One server type that will prove useful to know how to configure is the web server.
    Feel free to explore any other resources that you find relevant and might not
    be included in the *Further* *reading* list.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the installation and configuration processes for
    the most well-known services available for Linux. Knowing how to configure all
    the servers described in this chapter—from DNS to DHCP, Apache, and a printing
    server—is a minimum requirement for any Linux administrator.
  prefs: []
  type: TYPE_NORMAL
- en: By going through this chapter, you learned how to provide essential services
    for any Linux server. You learned how to set up and configure a web server using
    the Apache package; how to provide networked printing services to a small office
    or home office; how to run an FTP server and share files over TCP; how to share
    files with Windows clients on your network using the Samba/CIFS protocol; how
    to share files over Unix and Linux systems using the NFS file-sharing protocol;
    how to set up NTP to show an accurate time; and how to configure DNS and local
    DHCP servers. In a nutshell, you learned a lot in this chapter, and yet we have
    barely scratched the surface of Linux server administration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce you to cloud technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a clear view of how to manage some of the most widely used
    services in Linux, here are some exercises that will further contribute to your
    learning:'
  prefs: []
  type: TYPE_NORMAL
- en: Try using a VPS for all the services detailed in this chapter, not on your local
    network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try setting up a LEMP stack on Ubuntu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test all the services described in this chapter using Fedora or RHEL-based distributions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the topics covered in the chapter, you can refer
    to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official Ubuntu documentation: [https://ubuntu.com/server/docs](https://ubuntu.com/server/docs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RHEL official docs: [https://www.redhat.com/sysadmin/install-apache-web-server](https://www.redhat.com/sysadmin/install-apache-web-server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NGINX official docs: [https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/](https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DigitalOcean official docs: [https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-install-the-apache-web-server-on-ubuntu-22-04)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 4:Cloud Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this fourth part, you will learn about advanced concepts related to cloud
    computing. By the end of this part, you will be proficient in using specific tools
    such as Kubernetes and Ansible and deploying Linux to the AWS and Azure clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19682_14.xhtml#_idTextAnchor299), *Short Introduction to* *Computing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19682_15.xhtml#_idTextAnchor326), *Deploying to the Cloud with
    AWS and Azure*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19682_16.xhtml#_idTextAnchor342), *Deploying Applications with
    Kubernetes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19682_17.xhtml#_idTextAnchor359), *Infrastructure and Automation
    with Ansible*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
