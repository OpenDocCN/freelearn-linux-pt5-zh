- en: '*Chapter 4*: Writing Character Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix-based systems expose hardware to user space by means of special files,
    all created in the `/dev` directory upon device registration with the system.
    Programs willing to access a given device must locate its corresponding device
    file in `/dev` and perform the appropriate system call on it, which will be redirected
    to the driver of the underlying device associated with that special file. Though
    system calls redirection is done by an operating system, what system calls are
    supported depends on the type of device and the driver implementation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of types of devices, there are many of them from a hardware point
    of view, which are, however, grouped into two families of special device files
    in `/dev` – these are **block devices** and **character devices**. They are differentiated
    by the way they are accessed, their speed, and the way data is transferred between
    them and the system. Typically, character devices are slow and transfer data to
    or from user applications sequentially byte by byte (one character after another
    – hence their name). Such devices include serial ports and input devices (keyboards,
    mouses, touchpads, video devices, and so on). On the other hand, block devices
    are fast, since they are accessed quite frequently and transfer data in blocks.
    Such devices are essentially storage devices (hard drives, CD-ROMs, solid-state
    drives, and so on).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on character devices and their drivers, their
    APIs, and their common data structures. We will introduce most of their concepts
    and write our first character device driver.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The concept of major and minor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character device data structure introduction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a device node
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing file operations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of major and minor
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has always enforced device file identification by a unique identifier,
    composed of two parts, a `/dev`, character or block device files are recognizable
    by their types, which can be seen using the `ls -l` command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding excerpt, in the first column, `c` identifies character device
    files and `b` identifies block device files. In the fifth and sixth columns, we
    can see, respectively, major and minor numbers. The major number either identifies
    the type of device or can be bound to a driver. The minor number either identifies
    a device locally to the driver or devices of the same type. This explains the
    fact that some device files have the same major number in the preceding output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the basic concepts of character devices in a Linux
    system, we can start exploring the kernel code, starting from introducing the
    main data structures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Character device data structure introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A character device driver represents the most basic device driver in the kernel
    sources. Character devices are represented in the kernel as instances of `struct
    cdev`, declared in `include/linux/cdev.h`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding excerpt has listed elements of our interest only. The following
    shows the meaning of these elements in this data structure:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录仅列出了我们感兴趣的元素。以下显示了这些元素在此数据结构中的含义：
- en: '`kobj`: This is the underlying kernel object for this character device object,
    used to enforce the Linux device model. We will discuss this in [*Chapter 14*](B17934_14_Epub.xhtml#_idTextAnchor203),
    *Introduction to the Linux Device Model*.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kobj`: 这是该字符设备对象的基础内核对象，用于实施 Linux 设备模型。我们将在[*第14章*](B17934_14_Epub.xhtml#_idTextAnchor203)，*Linux
    设备模型介绍*中讨论这一点。'
- en: '`owner`: This should be set with the `THIS_MODULE` macro.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`: 应该使用`THIS_MODULE`宏进行设置。'
- en: '`ops`: This is the set of file operations associated with this character device.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`: 这是与此字符设备关联的文件操作集合。'
- en: '`dev`: This is the character device identifier.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`: 这是字符设备标识符。'
- en: With this data structure introduced, the next logical one for discussion is
    the one exposing file operations that system calls will rely on. Let's then introduce
    the data structure that allows interaction between user space and kernel space
    through the character device.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了这个数据结构后，接下来讨论的逻辑下一个数据结构是暴露给系统调用依赖的文件操作。然后让我们介绍允许用户空间与内核空间通过字符设备进行交互的数据结构。
- en: An introduction to device file operations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备文件操作简介
- en: 'The `cdev->ops` element points to the file operations supported by a given
    device. Each of these operations is the target of a particular system call, in
    a manner that, when the system call is invoked by a program in user space on the
    character device, this system call is redirected in the kernel to its file operation
    counterpart in `cdev->ops`. `struct file_operations` is the data structure that
    holds these operations. It looks like the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdev->ops`元素指向给定设备支持的文件操作。每个这些操作都是特定系统调用的目标，当用户空间程序在字符设备上调用系统调用时，内核将此系统调用重定向到其在`cdev->ops`中的文件操作对应项。`struct
    file_operations`是保存这些操作的数据结构。它看起来像这样：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding excerpt lists only the important methods of the structure, especially
    the ones that are relevant to the needs of this book. The full code is in `include/linux/fs.h`
    in kernel sources. Each of these callbacks is the backend of a system call, and
    none of them are mandatory. The following explains the meanings of elements in
    the structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录仅列出了结构的重要方法，特别是与本书需求相关的方法。完整代码在内核源码的`include/linux/fs.h`中。每个这些回调函数是系统调用的后端，并且它们都不是强制性的。以下解释了结构中元素的含义：
- en: '`struct module *owner`: This is a mandatory field that should point to the
    module owning this structure. It is used for proper reference counting. Most of
    the time, it is set to `THIS_MODULE`, a macro defined in `<linux/module.h>`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct module *owner`: 这是一个必填字段，应指向拥有此结构的模块。它用于正确的引用计数。大多数情况下，它设置为`THIS_MODULE`，这是在`<linux/module.h>`中定义的宏。'
- en: '`loff_t (*llseek) (struct file *, loff_t, int);`: This method is used to move
    the current cursor position in the file given as the first parameter. On a successful
    move, the function must return the new position, or else a negative value must
    be returned. If this method is not implemented, then every seek performed on this
    file will succeed by modifying the position counter in the `file` structure (`file->f_pos`),
    except the seek relative to end-of-file, which will fail.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loff_t (*llseek) (struct file *, loff_t, int);`: 此方法用于移动文件中当前光标位置，第一个参数是文件。成功移动后，函数必须返回新位置，否则必须返回负值。如果未实现此方法，则在该文件上执行的每个查找都将通过修改文件结构（`file->f_pos`）中的位置计数器成功执行，除了相对于文件末尾的查找将失败。'
- en: '`ssize_t (*read) (struct file *, char *, size_t, loff_t *);`: The role of this
    function is to retrieve data from the device. Since the return value is a "signed
    size" type, this function must return either the number (positive) of bytes successfully
    read, or else return an appropriate negative code on error. If this function is
    not implemented, then any `read()` system call on the device file will fail, returning
    with `-EINVAL` (an "invalid argument").'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssize_t (*read) (struct file *, char *, size_t, loff_t *);`: 此函数的作用是从设备中检索数据。由于返回值是"有符号大小"类型，因此此函数必须返回成功读取的字节数（正数），否则在错误时返回适当的负代码。如果未实现此函数，则对设备文件的任何`read()`系统调用都将失败，并返回`-EINVAL`（"无效参数"）。'
- en: '`ssize_t (*write) (struct file *, const char *, size_t, loff_t *);`: The role
    of this function is to send data to the device. Like the `read()` function, it
    must return a positive number, which, in this case, represents the number of bytes
    that have been written successfully, or else return an appropriately negative
    code on error. In the same way, if it is not implemented in the driver, then the
    `write()` system call attempt will fail with `-EINVAL`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssize_t (*write) (struct file *, const char *, size_t, loff_t *);`：此函数的作用是向设备发送数据。像`read()`函数一样，它必须返回一个正数，表示已成功写入的字节数，否则返回适当的负值代码以指示错误。同样，如果驱动程序中未实现此功能，则尝试执行`write()`系统调用时将失败，并返回`-EINVAL`。'
- en: '`int (*flush) (struct file *, fl_owner_t id);`: This operation is invoked when
    the file structure is being released. Like `open`, `release` can be `NULL`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*flush) (struct file *, fl_owner_t id);`：当文件结构被释放时，将调用此操作。与`open`类似，`release`可以是`NULL`。'
- en: '`unsigned int (*poll) (struct file *, struct poll_table_struct *);`: This file
    operation must return a bitmask describing the status of the device. It is the
    kernel backend for both `poll()` and `select()` system calls, both used to query
    whether the device is writable, readable, or in some special state. Any caller
    of this method will block until the device enters the requested state. If this
    file operation is not implemented, then the device is always assumed to be readable,
    writable, and in no special state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int (*poll) (struct file *, struct poll_table_struct *);`：此文件操作必须返回一个位掩码，描述设备的状态。它是`poll()`和`select()`系统调用的内核后端，二者用于查询设备是否可写、可读，或是否处于某些特殊状态。调用此方法的任何程序都会阻塞，直到设备进入请求的状态。如果此文件操作未实现，则设备始终被假定为可读、可写且不处于特殊状态。'
- en: '`int (*mmap) (struct file *, struct vm_area_struct *);`: This is used to request
    part or all of the device memory to be mapped to a process address space. If this
    file operation is not implemented, then any attempt to invoke the `mmap()` system
    call on the device file will fail, returning `-ENODEV`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*mmap) (struct file *, struct vm_area_struct *);`：此操作用于请求将设备内存的部分或全部映射到进程的地址空间。如果此文件操作未实现，则对设备文件调用`mmap()`系统调用时会失败，并返回`-ENODEV`。'
- en: '`int (*open) (struct inode *, struct file *);` This file operation is the backend
    of the `open()` system call, which, if not implemented (if `NULL`), will result
    in the success of any attempt to open the device and the driver won''t be notified
    of the operation.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*open) (struct inode *, struct file *);`：此文件操作是`open()`系统调用的后端。如果未实现（即`NULL`），则任何尝试打开设备的操作都会成功，并且驱动程序不会收到此操作的通知。'
- en: '`int (*release) (struct inode *, struct file *);`: This is invoked when the
    file is being released, in response to the `close()` system call. Like `open`,
    `release` is not mandatory and can be `NULL`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*release) (struct inode *, struct file *);`：当文件被释放时，响应`close()`系统调用时调用此操作。像`open`一样，`release`不是强制性的，可以是`NULL`。'
- en: '`int (*fsync) (struct file *, loff_t, loff_t, int datasync);`: This operation
    is the backend of the `fsync()` system call, whose purpose is to flush any pending
    data. If it is not implemented, any call to `fsync()` on the device file will
    fail, returning `-EINVAL`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*fsync) (struct file *, loff_t, loff_t, int datasync);`：此操作是`fsync()`系统调用的后端，旨在刷新任何待处理的数据。如果未实现，对设备文件的任何`fsync()`调用都会失败，并返回`-EINVAL`。'
- en: '`long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);`: This
    is the backend of the `ioctl` system call, whose purpose is to extend the commands
    that can be sent to the device (such as formatting a track of a floppy disk, which
    is neither reading nor writing). The commands defined by this function will extend
    a set of predefined commands that are already recognized by the kernel without
    referring to this file operation. Thus, for any command that is not defined (either
    because this function is not implemented or because it does not support the specified
    command), the system call will return `-ENOTTY`, to say *"No such ioctl for device"*.
    Any non-negative value returned by this function is passed back to the calling
    program to indicate successful completion.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);`：这是`ioctl`系统调用的后端，其目的是扩展可以发送到设备的命令（例如格式化软盘的某个磁道，这既不是读取也不是写入）。由此函数定义的命令将扩展一组已经被内核识别的预定义命令，而无需参考此文件操作。因此，对于任何未定义的命令（无论是因为此函数未实现，还是因为它不支持指定的命令），系统调用将返回`-ENOTTY`，表示*“设备没有此类ioctl”*。此函数返回的任何非负值都将传回调用程序，以表示成功完成。'
- en: Now that we are familiar with the file operation callbacks, let's delve into
    the kernel insights and learn how files are handled for a better understanding
    of the mechanisms behind character devices.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: File representation in the kernel
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at the file operation table, at least one of the parameters of each
    operation is either the `struct inode` or `struct file` type. `struct inode` refers
    to a file on the disk. However, to refer an open file (associated with a file
    descriptor within a process), the `struct file` structure is used.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the declaration of an `inode` structure:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most important field in the structure is the `union`, especially the `i_cdev`
    element, which is set when the underlying file is a character device. This makes
    it possible to switch back and forth between `struct inode` and `struct cdev`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `struct file` is a filesystem data structure holding information
    about a file (its type, character, block, pipe, and so on), most of which is only
    relevant to the OS. The `struct file` structure (defined in `include/linux/fs.h`)
    has the following definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding data structure, `f_path` represents the actual path of the
    file in the filesystem, and `f_inode` is the underlying `inode` that points to
    this opened file. This makes it possible to switch back and forth between `struct
    file` and the underlying `cdev`, through the `f_inode` element. `f_op` represents
    the file operation table. Because `struct file` represents an open file descriptor,
    it tracks the current read/write position within its opened instance. This is
    done through the `f_pos` element, and `f_pos` is the current read/write position.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating a device node
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creation of a device node makes it visible to users and allows users to
    interact with the underlying device. Linux requires intermediate steps before
    the device node is created and the following section discusses these steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Device identification
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To precisely identify devices, their identifiers must be unique. Although identifiers
    can be dynamically allocated, most drivers still use static identifiers for compatibility
    reasons. Whatever the allocation method, the Linux kernel stores file device numbers
    in elements of `dev_t` type, which is a 32-bit unsigned integer in which the major
    is represented by the first `12` bits, and the minor is coded on the `20` remaining
    bits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is stated in `include/linux/kdev_t.h`, which contains several macros,
    including those that, given a `dev_t` type variable, can return either a minor
    or a major number:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last macro accepts a minor and a major number and returns a `dev_t` type
    identifier, which the kernel uses to keep identifiers. The preceding excerpt also
    describes how the `character device` identifier is built using a bit shift. At
    this point, we can get deep into the code, using the APIs that the kernel provides
    for code allocation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Registration and deregistration of character device numbers
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to deal with device numbers – **registration** (the static
    method) and **allocation** (the dynamic method). Registration, also called **static
    allocation**, is only useful if you know in advance which major number you want
    to start with, after making sure it does not clash with another driver using the
    same major (though this is not always predictable). Registration is a brute-force
    method in which you let the kernel know what device numbers you want by providing
    the starting major/minor pair and the number of minors, and it either grants them
    to you or not (depending on availability). The function to use for device number
    registration is the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 处理设备号的方式有两种——**注册**（静态方法）和**分配**（动态方法）。注册，也叫**静态分配**，只有在你提前知道想要开始使用的主设备号时才有用，前提是确保它不会与另一个驱动程序使用相同的主设备号（虽然这并不总是可预测的）。注册是一种暴力方法，你通过提供起始的主设备号/次设备号对和次设备号的数量，让内核知道你想要哪些设备号，内核会根据可用性来分配它们或不分配。用于设备号注册的函数如下：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method returns `0` on success, or a negative error code when it fails.
    The `first` parameter is the identifier you must have built using the major number
    and the first minor of the desired range. You can use the `MKDEV(maj, min)` macro
    to achieve that. `count` is the number of consecutive device minors required,
    and `name` should be the name of the associated device or driver.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，失败时返回负错误代码。`first`参数是你必须使用主设备号和所需范围的第一个次设备号构建的标识符。你可以使用`MKDEV(maj,
    min)`宏来实现。`count`是所需连续设备次设备号的数量，`name`应该是关联的设备或驱动程序的名称。
- en: 'However, note that `register_chrdev_region()` works well if you know exactly
    which device numbers you want, and of course, those numbers must be available
    on your running system. Because this can be a source of conflict with other device
    drivers, it is considered preferable to use dynamic allocation, with which the
    kernel happily allocates a major number for you on the fly. `alloc_chrdev_region()`
    is the API you must use for dynamic allocation. The following is its prototype:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`register_chrdev_region()`如果你确切知道想要的设备号，它会表现得很好，当然，这些号必须在你运行的系统中可用。由于这可能与其他设备驱动程序发生冲突，因此建议使用动态分配方式，内核可以自动为你分配一个主设备号。你必须使用`alloc_chrdev_region()`来进行动态分配。以下是它的原型：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method returns `0` on success, or a negative error code on failure. `dev`
    is the only output parameter. It represents the first number (built using the
    allocated major and the first minor requested) that the kernel assigned. `firstminor`
    is the first of the requested range of minor numbers, `count` is the number of
    consecutive minors you need, and `name` should be the name of the associated device
    or driver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，失败时返回负错误代码。`dev`是唯一的输出参数。它表示内核分配的第一个号（使用分配的主设备号和请求的第一个次设备号构建）。`firstminor`是请求的次设备号范围中的第一个，`count`是你需要的连续次设备号的数量，`name`应该是关联的设备或驱动程序的名称。
- en: The difference between static allocation and dynamic allocation is that, with
    the former, you should know in advance which device number is needed. When it
    comes to loading the driver on another machine, there is no guarantee that the
    chosen number is free on that machine, and this can lead to conflict and trouble.
    New drivers are encouraged to use dynamic allocation to obtain a major device
    number, rather than choosing a number randomly from the ones that are currently
    free, which will probably lead to a clash. In other words, your drivers are better
    using `alloc_chrdev_region()` rather than `register_chrdev_region()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分配和动态分配的区别在于，前者需要你提前知道所需的设备号。将驱动程序加载到另一台机器上时，无法保证所选设备号在该机器上是空闲的，这可能导致冲突和问题。新驱动程序建议使用动态分配来获取主设备号，而不是从当前空闲的设备号中随机选择，这样可能会导致冲突。换句话说，你的驱动程序最好使用`alloc_chrdev_region()`，而不是`register_chrdev_region()`。
- en: Initializing and registering a character device on the system
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在系统上初始化并注册字符设备
- en: 'The registration of a character device is made by specifying a device identifier
    (of `dev_t` type). In this chapter, we will be using dynamic allocation, using
    `alloc_chrdev_region()`. After the identifier has been allocated, you must initialize
    the character device and add it to the system using `cdev_init()` and `cdev_add(),`
    respectively. The following are their prototypes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In `cdev_init()`, `cdev` is the structure to initialize, and `fops` the `file_operations`
    instance for this device, making it ready to add to the system. In `cdev_add()`,
    `p` is the `cdev` structure for the device, `dev` is the first device number for
    which this device is responsible (obtained dynamically), and `count` is the number
    of consecutive minor numbers corresponding to this device. When it succeeds, `cdev_add()`
    returns `0`, or else it returns a negative error code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The respective reverse operation of `cdev_add()` is `cdev_del()`, which removes
    the character device from the system and has the following prototype:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this step, the device is part of the system but not physically present.
    In other words, it is not visible in `/dev` yet. For the node to be created, you
    must use `device_create()`, which has the following prototype:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method creates a device and registers it with Sysfs. In its argument, `class`
    is a pointer to `struct class` that this device should be registered to, `parent`
    is a pointer to the `struct device` parent of this new device if there is any,
    `devt` is the device number for the char device to be added, and `drvdata` is
    the data to be added to the device for callbacks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of multiple minors, the `device_create()` and `device_destroy()` APIs
    can be put in a `for` loop, and the `<device name format>` string can be appended
    with the loop counter, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`device_create(class, NULL, MKDEV(MAJOR(first_devt), MINOR(first_devt) + i),
    NULL, "mynull%d", i);`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Because a device needs an existing class before being created, you must either
    create a class or use an existing one. For now, we will create a class, and to
    do that, we need to use the `class_create()` function, declared as the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After then, the class will be visible in `/sys/class`, and we can create the
    device using that class. The following is a rough example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, `device_create()` will create a node for each device,
    – `/dev/eep-mem0`, `dev/eep-mem1`, and so on, with our class represented by `eep_class`.
    Additionally, devices can also be viewed under `/sys/class/eep-class`. In the
    meantime, the reverse operation is the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `device_destroy()` will remove a device node from `/dev`,
    `cdev_del()` will make the system forget about this character device, `class_unregister()`
    and `class_destroy()` will deregister and remove the class from the system, and
    finally, `unregister_chrdev_region()` will release our device number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with all the prerequisites about character devices,
    we can start implementing a file operation, which allows users to interact with
    the underlying device.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Implementing file operations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After introducing file operations in the previous section, it is time to implement
    those to enhance the driver capabilities and expose the device's methods to user
    space (by means of system calls, of course). Each of these methods has its particularities,
    which we will highlight in this section.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Exchanging data between the kernel space and user space
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen while introducing the file operation table, the `read` and `write`
    methods are used to exchange data with the underlying device. Both being system
    calls means that data will originate from or be in destination to user space.
    While looking at the `read` and `write` method prototypes, the first point that
    catches our attention is the use of `__user`. This is a cookie used by **Sparse**
    (a semantic checker used by the kernel to find possible coding faults) to let
    the developer know they are about to use an untrusted pointer (or a pointer that
    may be invalid in the current virtual address mapping) improperly, which they
    should not dereference but, instead, use dedicated kernel functions to access
    the memory to which this pointer points.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to two principal functions that allow us to exchange data between
    a kernel and user space, `copy_from_user()` and `copy_to_user()`, which copy a
    buffer from user space to kernel space and vice versa, respectively:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In both cases, pointers prefixed with `__user` point to the user space (untrusted)
    memory. `n` represents the number of bytes to copy, either to or from user space.
    `from` represents the source address, and `to` is the destination address. Each
    of these returns the number of bytes that could not be copied, if any, while they
    return `0` on success. Note that these routines may sleep as they run in a user
    context and do not need to be invoked in an atomic context.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the open file operation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `open` file operation is the backend of the open system call. One usually
    uses this method to perform device and data structure initializations, after which
    it should return `0` on success, or a negative error code if something went wrong.
    The prototype of the `open` file operation is defined as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If it is not implemented, device opening will always succeed, but the driver
    won't be aware, which is not necessarily a problem if the device needs no special
    initialization.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Per-device data
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen in file operation prototypes, there is almost always a `struct
    file` argument. `struct file` has an element free of use, that is `private_data`.
    `file->private_data`, if set, will be available to other system calls invoked
    on the same file descriptor. You can use this field during the lifetime of the
    file descriptor. It is good practice to set this field in the `open` method as
    it is always the first system call on any file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is our data structure:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的数据结构：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Given this data structure, the `open` method would look like the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此数据结构，`open` 方法将如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Most of the time, the `open` operation does some initialization and requests
    resources that will be used while a user keeps an open instance of the device
    node. Everything that has to be done in this operation must be undone and released
    when the device is closed, as we'll see in the next operation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，`open` 操作进行一些初始化并请求在用户保持设备节点的打开实例期间使用的资源。在设备关闭时，必须撤销和释放此操作中所做的所有工作，正如我们将在下一操作中看到的那样。
- en: Implementing the release file operation
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现释放文件操作
- en: The `release` method is called when the device gets closed, the reverse of the
    `open` method. You must then undo everything you have done in the `open` operation.
    It could be literally, freeing any private memory allocated and shutting down
    the device (if supported), and discarding every buffer on the last closing (if
    the device supports multi-opening, or if the driver can handle more than one device
    at a time).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`release` 方法在设备关闭时调用，是 `open` 方法的反向操作。你必须撤销在 `open` 操作中所做的一切。这可能包括释放分配的私有内存、关闭设备（如果支持），并在最后一次关闭时丢弃所有缓冲区（如果设备支持多次打开，或者驱动程序可以处理多个设备）。'
- en: 'The following is an excerpt of a `release` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `release` 函数的摘录：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code releases all the resources acquired when the device node
    has been open. This is literally all that needs to be done in this file operation.
    If the device node is backed by a hardware device, this operation can also put
    this device in the appropriate state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码释放了设备节点打开时获得的所有资源。这实际上是此文件操作中需要做的所有事情。如果设备节点由硬件设备支持，此操作还可以将设备置于适当的状态。
- en: At this point, we are able to implement the entry (`open`) and exit (`release)`
    points for the character device. All that remains now is to implement each possible
    operation that can be done in between.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们能够实现字符设备的入口点（`open`）和出口点（`release`）。现在剩下的就是实现每个可能的操作。
- en: Implementing the write file operation
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现写文件操作
- en: 'The `write` method is used to send data to the device; whenever a user calls
    the `write()` system call on the device''s file, the kernel implementation that
    is called ends up being invoked. Its prototype is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 方法用于向设备发送数据；每当用户在设备的文件上调用 `write()` 系统调用时，内核实现的相应方法会被调用。其原型如下：'
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This file operation must return the number of bytes (size) written, and the
    following are the definitions of its arguments:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件操作必须返回已写入的字节数（大小），以下是其参数的定义：
- en: '`*buf` represents the data buffer coming from the user space.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*buf` 表示来自用户空间的数据缓冲区。'
- en: '`count` is the size of the requested transfer.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 是请求传输的大小。'
- en: '`*pos` indicates the start position from which data should be written in the
    file (or in the corresponding memory region if the character device file is memory-backed).'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*pos` 表示从文件中的哪个位置开始写入数据（如果字符设备文件由内存支持，则表示相应内存区域的位置）。'
- en: 'Generally, in this file operation, the first thing to do is to check for bad
    or invalid requests coming from the user space (for example, check for size limitations
    in case of a memory-backed device and size overflow). The following is an example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在执行此文件操作时，首先需要检查来自用户空间的无效请求或错误请求（例如，检查内存支持设备的大小限制以及大小溢出）。以下是一个示例：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After the checks, it is common to make some adjustments, especially with `count,`
    to not go beyond the file size. This step is not mandatory either:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查完成后，通常需要进行一些调整，尤其是对于 `count`，以确保不超过文件大小。此步骤也不是强制性的：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next step is to find the location from which you will start to write. This
    step is relevant only if the device is backed by physical memory in which the
    `write()` method is supposed to store given data:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是找到开始写入的位置。只有在设备由物理内存支持的情况下，这一步才相关，在这种情况下，`write()` 方法应当存储给定的数据：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, you can copy data from user space into kernel memory, after which
    you can perform the `write` operation on the backing device and adjust `*pos`,
    as in the following excerpt:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以将数据从用户空间复制到内核内存，然后在支持设备上执行 `write` 操作，并调整 `*pos`，如下所示：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following is an example of the `write` method, which summarizes the steps
    described so far:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `write` 方法的示例，概述了目前为止描述的步骤：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After the data has been read and processed, it might be necessary to write the
    processing output back. Since we have started with writing, the next operation
    we may think of is `read`, as we will see in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the read file operation
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `read` method has the following prototype:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This operation is the backend of the `read()` system call. Its arguments are
    described as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`*buf` is the buffer we receive from user space.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count` is the size of the requested transfer (the size of the user buffer).'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*pos` indicates the start position from which data should be read in the file.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must return the size of the data that has been successfully read. This size
    can be less than `count` though (for example, when reaching the end of the file
    before reaching the `count` requested by the user).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the read operation looks like the write one, since some sanity
    checks need to be performed. First, you can prevent reading beyond the file size
    and return an end-of-file response:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, you should make sure the number of bytes read can''t go beyond the file
    size and you can adjust `count` appropriately:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, you can find the location from which you will start the read, after which
    you can copy the data into the user space buffer and return an error on failure,
    and then advance the file''s current position according to the number of bytes
    read and return the number of bytes copied:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is an example of a driver `read()` file operation, intended to
    give an overview of what can be done here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Though reading and writing data moves the cursor position, there is an operation
    whose main purpose is to move the cursor position without touching data at all.
    Such an operation helps to start writing or reading data from anywhere by moving
    the cursor to the desired position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the llseek file operation
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `llseek` file operation is the kernel backend for the `lseek()` system
    call, used to move the cursor position within a file. Its prototype looks as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This callback must return the new position in the file. The following are the
    definitions of its parameters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '`loff_t` is an offset, relative to the current file position, which defines
    how much of it will be changed.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whence` defines where to seek from. The possible values are as follows:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_SET`: To put the cursor to a position relative from the beginning of
    the file'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_CUR`: To put the cursor to a position relative to the current file position'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SEEK_END`: To adjust the cursor to a position relative to the end of the file'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When implementing this operation, it is a good practice to use the `switch`
    statement to check every possible `whence` case, since they are limited, and adjust
    the new position accordingly:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After the preceding kernel backend excerpt, the following is an example of
    a user program that will successively read and seek into a file. The underlying
    driver will then execute the `llseek()` file operation entry:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The code produces the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this section, we have explained the concept of seeking with an example, showing
    how relative and absolute seeking works. Now that we are done with operations
    moving data around, we can switch to the next operation, sensing the readability
    or writability of data in a character device.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The poll method
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `poll` method is the backend of both the `poll()` and `select()` system
    calls. These system calls are used to passively (by sleeping, without wasting
    CPU cycles) sense the readability/writability in a file. To support these system
    calls, the driver must implement `poll`, which has the following prototype:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The kernel function at the heart of this method implementation is `poll_wait()`,
    defined in `<linux/poll.h>`, which is the header you must include in the driver
    code. It has the following declaration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`poll_wait()` adds the device associated with a `struct file` structure (given
    as the first parameter) to a list of those that can wake up processes (put to
    sleep in the `struct wait_queue_head_t` structure given as the second parameter),
    according to events registered in the `struct poll_table` structure given as the
    third parameter. A user process can call the `poll()`, `select()`, or `epoll()`
    system calls to add a set of files to a list on which it needs to wait, in order
    to be aware of the associated (if any) device''s readiness. The kernel will then
    call the `poll` entry of the driver associated with each device file. The `poll`
    method of each driver should then call `poll_wait()` in order to register events
    for which the process needs to be notified with the kernel, put that process to
    sleep until one of these events occurs, and register the driver as one of those
    that can wake the process up. The usual way is to use a wait queue per event type
    (one for readability, another one for writability, and eventually one for an exception
    if needed), according to events supported by the `select()` (or `poll()`) system
    call.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The return value of the (`*poll`) file operation must have `POLLIN | POLLRDNORM`
    set if there is data to read, `POLLOUT | POLLWRNORM` if the device is writable,
    and `0` if there is no new data and the device is not yet writable. In the following
    example, we assume the device supports both blocking read and write. Of course,
    you can implement only one of these. If the driver does not define this method,
    the device will be considered as always readable and writable, and `poll()` or
    `select()` system calls return immediately.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing the poll operation may require adapting the read or write file
    operations in a way that, on write, readers are notified of the readability, and
    on read, writers are notified of the writability:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding snippet, we have implemented the `poll` operation, which can
    put processes to sleep if a device is not writable or readable. However, there
    is no notification mechanism when any of those states change. Therefore, a `write`
    operation (or any operation making data available, such as an IRQ) must notify
    processes sleeping in the readability wait queue; the same applies to the `read`
    operation (or any operation making the device ready to be writable), which must
    notify processes sleeping in the writability wait queue. The following is an example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: More precisely, you can notify a readable event either from within the driver's
    `write()` method, meaning that the written data can be read back, or from within
    an IRQ handler, meaning that an external device sent some data that can be read
    back. On the other hand, you can notify a writable event either from within the
    driver's `read()` method, meaning that the buffer is empty and can be filled again,
    or from within an IRQ handler, meaning that the device has completed a data-send
    operation and is ready to accept data again. Do not forget to set flags back to
    `false` when the state changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of code that uses `select()` on a given character
    device in order to sense data availability:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code sample, we used `select()` without timeout, in a way that
    means we will be notified of "read" events only. From that line, the process is
    put to sleep until it is notified of the event for which it registered itself.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The ioctl method
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical Linux system contains around 350 `-ENOTTY` error to any `ioctl()`
    system call. The following is its prototype:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding prototype, `f` is the pointer to the file descriptor representing
    an opened instance of the device, `cmd` is the ioctl command, and `arg` is a user
    parameter, which can be the address of any user memory on which the driver can
    call `copy_to_user()` or `copy_from_user()`. To be concise, and for obvious reasons,
    an IOCTL command needs to be identified by a number, which should be unique to
    the system. The unicity of IOCTL numbers across the system will prevent us from
    sending the right command to the wrong device, or passing the wrong argument to
    the right command (with a duplicated IOCTL number). Linux provides four helper
    macros to create an IOCTL identifier, depending on whether there is data transfer
    or not and the direction of the transfer. Their respective prototypes are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Their descriptions are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '`_IO`: The IOCTL command does not need data transfer.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOR`: This means that we''re creating an IOCTL command number for passing
    information from the kernel to user space (which is reading data). The driver
    will be allowed to return the `sizeof(TYPE)` bytes to the user without this return
    value being considered as an error.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOW`: This is the same as `_IOR`, but the user sends data to the driver this
    time.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_IOWR`: The IOCTL command needs both write and read parameters.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What their parameters mean (in the order they are passed) is described here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: A number coded on 8 bits (`0` to `255`), called the **magic number**.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence number or command ID, also on 8 bits.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data type, if any, that will inform the kernel about the size to be copied.
    This could be the name of a structure or a data type.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is well documented in `Documentation/ioctl/ioctl-decoding.txt` in the kernel
    sources, and existing IOCTL commands are listed in `Documentation/ioctl/ioctl-number.txt`,
    a good place to start when you need to create your own IOCTL commands.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Generating an IOCTL number (a command)
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is recommended to generate your own IOCTL numbers in a dedicated header
    file, since this header should be available in user space as well. In other words,
    you should handle the duplication (by means of symbolic links, for example) of
    the IOCTL header file so that there is one in the kernel and one in user space,
    which can be included in user apps. Let''s now generate some IOCTL numbers in
    a real example, and let''s call this header `eep_ioctl.h`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After the commands have been defined, the header needs to be included in the
    final code. Moreover, because they are all unique and limited, it is a good practice
    to use a `switch ... case` statement to handle each command and return a `-ENOTTY`
    error code when an undefined `ioctl` command is called. The following is an example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both the kernel and user space must include the header files that contain the
    IOCTL commands. Therefore, in the first line of the preceding excerpt, we have
    included `eep_ioctl.h`, which is the header file where our IOCTL commands are
    defined.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: If you think your IOCTL command will need more than one argument, you should
    gather those arguments in a structure and just pass a pointer to the structure
    to `ioctl`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from the user space, you must use the same `ioctl` header as in the driver''s
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, we have demonstrated the use of kernel IOCTL commands
    from user space. That said, all throughout this section, we have learned how to
    implement the character device's `ioctl` callback and how to exchange data between
    the kernel and user space.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have demystified character devices, and we have seen how
    to let users interact with our driver through device files. We learned how to
    expose file operations to user space and control their behavior from within the
    kernel. We went so far that you are even able to implement multi-device support.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is a bit more hardware-oriented, as it deals with the device
    tree, a mechanism that allows hardware devices present on the system to be declared
    to the kernel. See you in the next chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
