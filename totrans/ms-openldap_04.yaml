- en: Chapter 4. Securing OpenLDAP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。保护 OpenLDAP
- en: 'In Chapter 2 we installed OpenLDAP and created a basic configuration file for
    the SLAPD server. Then, in the last chapter, we turned our attention to LDAP operations
    and LDAP clients. Now we will return to the SLAPD server, but with a specific
    focus: **security**. We will take a look at three major security considerations
    with OpenLDAP: securing connections between the server and client connections,
    authenticating users of the directory, and specifying what data particular users
    can access (and in what capacity they can access it). We will look at these security
    considerations on a practical level and, in doing so, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们安装了 OpenLDAP 并创建了 SLAPD 服务器的基本配置文件。然后，在上一章中，我们将注意力转向了 LDAP 操作和 LDAP
    客户端。现在，我们将返回到 SLAPD 服务器，但重点将有所不同：**安全性**。我们将重点关注 OpenLDAP 的三个主要安全考虑因素：保护服务器和客户端之间的连接、验证目录用户的身份，以及指定特定用户可以访问哪些数据（以及他们可以以何种方式访问）。我们将从实际角度来审视这些安全考虑因素，并在此过程中涵盖以下内容：
- en: Configuring SSL and TLS to protect network data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 SSL 和 TLS 以保护网络数据
- en: Using simple binding to authenticate DNS (Domain Name System) for using the
    directory
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单绑定来验证 DNS（域名系统）以使用目录
- en: Using SASL to provide more robust authentication services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SASL 提供更强大的身份验证服务
- en: Integrating SASL and client SSL/TLS certificates for authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 SASL 和客户端 SSL/TLS 证书进行身份验证
- en: Configuring Access Control Lists (ACLs) to establish rules about what data users
    can access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置访问控制列表（ACL）以建立有关用户可以访问哪些数据的规则
- en: 'LDAP Security: The Three Aspects'
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 安全性：三大方面
- en: As we have seen already, the directory contains sensitive information. One example
    of such sensitive information is the `userPassword` attribute. But other information
    that may be considered sensitive, such as personal information or confidential
    information about the organization, may exist in the directory. Such information
    needs to be protected.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，目录包含敏感信息。一个例子就是 `userPassword` 属性。但目录中也可能包含其他被认为是敏感的信息，如个人信息或关于组织的机密信息。这些信息需要得到保护。
- en: We might ask what is meant by *protection* in this case. For it is certainly
    not the case that we want to prevent *all* clients from seeing *everything*. What
    we want rather, is to allow people to get at specific pieces of the directory
    information. But, on the other hand, there are cases where we want to deny certain
    users the ability to get at certain pieces of directory information. So protecting
    our data becomes a matter of providing information in some cases, while denying
    it in other cases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会问，这里所说的*保护*是什么意思。因为我们显然并不是要阻止*所有*客户端查看*所有*内容。我们真正想要的，是允许人们访问特定的目录信息。然而，另一方面，也有些情况是我们希望拒绝某些用户访问特定的目录信息。所以，保护我们的数据成为在某些情况下提供信息，而在其他情况下拒绝信息的一个问题。
- en: 'While it is possible to draw finer-grained distinctions, here we are going
    to consider three broad aspects of security where we want to make sure that we
    are protecting the directory and its information. These three aspects are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以进行更精细的区分，但在这里我们将考虑保护目录及其信息的三个广泛安全方面。这三个方面如下：
- en: '**Connection Security**: This is the process of protecting directory information
    (and client information) as it is passed between a client and the directory server.
    We will talk about this in the context of network security with SSL and TLS.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接安全性**：这是保护目录信息（以及客户端信息）在客户端和目录服务器之间传递过程的过程。我们将在网络安全的背景下讨论这一点，涉及 SSL 和 TLS。'
- en: '**Authentication**: This is the process of ensuring that the user who tries
    to access the information in the directory is who he/she/it claims to be. In this
    chapter we will look at two types of authentication: simple and SASL Binding.
    SASL stands for **Simple Authentication and Security Layer****.**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：这是确保尝试访问目录信息的用户确实是其声称身份的过程。在本章中，我们将介绍两种身份验证类型：简单绑定和 SASL 绑定。SASL 代表**简单身份验证和安全层**。'
- en: '**Authorization**: This is the process of ensuring that an identified or authenticated
    user is allowed to access pieces of information within the directory. OpenLDAP
    ACLs are used to specify rules for authorization.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是确保已识别或已验证的用户被允许访问目录中某些信息的过程。OpenLDAP 的 ACL 用于指定授权规则。'
- en: In this chapter we will look at each of these three aspects of security. By
    combining all three we will be able to provide suitably fine-grained protection
    for our directory information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这三个安全方面。通过将这三者结合起来，我们可以为我们的目录信息提供适当细粒度的保护。
- en: Securing Network-Based Directory Connections with SSL/TLS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SSL/TLS 保护基于网络的目录连接
- en: The first element of security that we will examine is network security. Most
    clients connect to OpenLDAP over a network interface, and client requests, as
    well as the server's responses, are transferred over a network.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要研究的第一个安全要素是网络安全。大多数客户端通过网络接口连接到 OpenLDAP，客户端请求和服务器响应都通过网络传输。
- en: 'The LDAP protocol, by default, sends and receives messages in clear text. In
    this case no attempt is made to obscure the data as it is being transmitted across
    the network. Sending in clear text has a few advantages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP 协议默认情况下以明文形式发送和接收消息。在这种情况下，数据在通过网络传输时不会进行任何隐藏处理。明文传输有几个优点：
- en: It is easier to configure and maintain.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更容易配置和维护。
- en: LDAP services can function faster. The process of encrypting and decrypting
    messages can be processor-intensive, and eliminating that processing can serve
    to speed things up.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP 服务可以更快速地运行。加密和解密消息的过程可能会占用大量处理器资源，去除这些处理过程可以加速操作。
- en: But these advantages come at the cost of security. Other devices on the network
    may be able to intercept these unencrypted transmissions and read their contents
    and in doing so, they may obtain sensitive information. On a small Local Area
    Network (LAN) the risks may be smaller (though still present). On a large scale
    network, such as the Internet, the dangers are much greater.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些优点是以安全性为代价的。网络上的其他设备可能能够拦截这些未加密的传输并读取其内容，从而可能获取敏感信息。在小型局域网（LAN）中，风险可能较小（尽管依然存在）。而在大规模网络中，例如互联网，风险则要大得多。
- en: In this section we will walk through the process of configuring **Secure Sockets
    Layer** (**SSL**) and **Transport Layer Security (TLS)** encryption to protect
    data as it is transmitted over a network. SSL and TLS are very similar, to the
    point where the terms are often used (acceptably) as synonyms. TLS though, is
    a refinement of SSL, and has been implemented in ways that are more flexible than
    the typical SSL implementation. The StartTLS method of securing a connection is
    an example.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍配置**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）加密的过程，以保护数据在网络上传输时的安全。SSL
    和 TLS 非常相似，以至于这两个术语经常被作为同义词使用（通常是可以接受的）。不过，TLS 是 SSL 的改进版本，实施方式比典型的 SSL 实现更加灵活。StartTLS
    方法就是一种保护连接的例子。
- en: The Basics of SSL and TLS
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSL 和 TLS 的基础
- en: OpenLDAP provides two methods for encrypting network traffic. The first is to
    have OpenLDAP listen on a special port for requests (port 636, the LDAPS port,
    is used by default). Transmissions on this port will automatically be encrypted.
    This method is older, introduced as an addition to LDAP v2, but it is no longer
    the preferred method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 提供了两种加密网络流量的方法。第一种是让 OpenLDAP 在一个特殊端口上监听请求（默认使用端口 636，即 LDAPS 端口）。这个端口上的传输会自动进行加密。这种方法较旧，是作为
    LDAP v2 的一个附加功能引入的，但现在已不再是首选方法。
- en: The second method, which is part of the LDAP v3 standard, is to allow clients
    connecting over the standard port (usually port 389) to request to switch from
    clear text transmissions to encrypted transmissions. I will cover both configurations
    here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是 LDAP v3 标准的一部分，允许客户端在标准端口（通常是端口 389）上连接时，申请从明文传输切换到加密传输。我将在这里介绍这两种配置。
- en: '**Secure Sockets Layer** (**SSL**) is a security process, originally developed
    by Netscape Communications for their web browser, designed to provide a safe way
    of exchanging trusted information between a server and any client on the network.
    There are two major features of the SSL process: establishing authenticity and
    conducting securely encrypted transactions.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全套接字层**（**SSL**）是一种安全过程，最初由 Netscape 通信公司为其网页浏览器开发，旨在提供一种安全的方式，在服务器和任何客户端之间交换可信的信息。SSL
    过程的两个主要特性是：建立身份验证和进行安全加密交易。'
- en: As SSL developed and evolved it was handed over to a standard body, the **Internet
    Engineering Task Force (IETF)**, for standardization and continued development.
    IETF renamed it **Transport Layer Security (TLS)** and released version 1.0 (as
    RFC 2246). SSL 3.0 and TLS 1.0 do not have any notable differences, and most servers
    that support one also support the other. Because of their similarity and shared
    heritage, I refer to them jointly as SSL/TLS.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着SSL的发展和演变，它被移交给了一个标准化组织——**互联网工程任务组（IETF）**，进行标准化和持续开发。IETF将其重新命名为**传输层安全（TLS）**，并发布了1.0版本（作为RFC
    2246）。SSL 3.0和TLS 1.0没有显著差异，大多数支持其中一种的服务器也支持另一种。由于它们的相似性和共同的历史，我通常将它们合并称为SSL/TLS。
- en: Authenticity
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实性
- en: Proving authenticity and providing encryption are the two major features of
    SSL/TLS. In regards to the first, SSL/TLS provides a way to establish the authenticity
    of the server (and, if desired, the client too). What this means is that SSL/TLS
    makes it possible for the client to be reasonably sure that the server belongs
    to whom it claims to belong.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 证明真实性和提供加密是SSL/TLS的两个主要特性。关于第一个，SSL/TLS提供了一种建立服务器真实性的方法（如果需要，也可以验证客户端的真实性）。这意味着SSL/TLS使客户端能够合理地确认服务器确实属于它声称的所有者。
- en: 'Consider the case of online banking. If I use my browser to log on to my bank''s
    website and conduct a few transactions, I want to be sure that the website I am
    connected to really is my bank''s website, and not some other website masquerading
    as my bank. SSL/TLS provides tools to establish the authenticity of the server
    using **X.509 certificates**. An X.509 certificate has three important pieces
    of information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下在线银行的情况。如果我使用浏览器登录到银行的网站并进行一些交易，我希望确保我连接到的网站确实是我的银行网站，而不是一个冒充我银行的网站。SSL/TLS提供了使用**X.509证书**来验证服务器真实性的工具。X.509证书包含三个重要信息：
- en: Information about the individual or organization that owns the certificate
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关证书所有者的个人或组织的信息
- en: A public encryption key (which we will discuss in the next section)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公钥（我们将在下一部分讨论）
- en: The **digital signature** of a certificate authority (CA)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字签名**由证书颁发机构（CA）提供'
- en: A certificate is designed as a sort of assurance that a server is associated
    with a particular individual or organization. When I contact a server that I believe
    to be my bank's, I want some assurance that it is, in fact, my bank's server.
    So one piece of information contained in the certificate is information about
    who owns the certificate. We can inspect this information ourselves, but since
    the certificate has a digital signature, it is also possible for software to computationally
    verify this—in a way much more reliable than reading the certificate and simply
    trusting that the certificate is accurate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 证书被设计为一种保证，确保某个服务器与特定的个人或组织相关联。当我联系我认为是我的银行的服务器时，我希望得到一些保证，确认它确实是我银行的服务器。因此，证书中包含的一项信息是关于谁拥有该证书的信息。我们可以自己检查这些信息，但由于证书包含数字签名，软件也可以以一种比简单读取证书并信任证书更可靠的方式来验证这些信息。
- en: The digital signature is an encrypted bit of information. It is encrypted with
    a special "private" key that is owned by a Certificate Authority. The CA can then
    issue a public key that client software can use to verify that the certificate
    was in fact signed by the CA. The CA then, plays a very important role in establishing
    trust. We will discuss public and private keys in the *Encryption* section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名是加密的信息块。它使用证书颁发机构（CA）拥有的特殊“私钥”进行加密。然后，CA可以发布一个公钥，客户端软件可以使用它来验证证书确实是由CA签署的。CA在建立信任方面起着非常重要的作用。我们将在*加密*部分讨论公钥和私钥。
- en: Certificate Authorities are responsible for issuing certificates. Ideally, a
    CA is a trusted source that can verify the authenticity of the certificate, and
    provide assurance that the certificate is really owned by the organization or
    individual that claims to own it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构（CA）负责颁发证书。理想情况下，CA是一个受信任的来源，可以验证证书的真实性，并提供保证，确保证书确实由声明拥有该证书的组织或个人所有。
- en: There are a number of commercial CAs that provide certificate generation services
    for a price. To obtain a certificate through these services, an organization or
    individual must provide a certain amount of information that can be used to verify
    that the person or organization signing up for the certificate is legitimate.
    Once investigation of this material has been done, and the person or organization
    has paid the requisite fee, the CA issues a digitally-signed certificate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多商业 CA 提供收费的证书生成服务。为了通过这些服务获取证书，组织或个人必须提供一些信息，用以验证申请证书的人或组织是否合法。一旦对这些信息进行了调查，并且申请人或组织支付了相应的费用，CA
    就会签发一个数字签名的证书。
- en: The certificates of large CAs are included by default in most SSL-aware applications,
    such as popular web browsers (like Mozilla Firefox) and SSL libraries (like OpenSSL).
    These certificates include the public keys necessary for verifying digital signatures.
    Thus, when a client gets an X.509 certificate that is signed by one of these CAs,
    it has all of the tools it needs to verify the certificate's authenticity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大型 CA 的证书默认包含在大多数支持 SSL 的应用程序中，如流行的网页浏览器（如 Mozilla Firefox）和 SSL 库（如 OpenSSL）。这些证书包含了验证数字签名所需的公钥。因此，当客户端获取到由这些
    CA 签名的 X.509 证书时，它就具备了验证证书真实性所需的所有工具。
- en: But it is possible, and often useful, for an organization or individual to simply
    create a locally used CA, and then use that CA to generate certificates for in-house
    applications. This is what we will do when we create a certificate for OpenLDAP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于一个组织或个人来说，创建一个本地使用的证书颁发机构（CA）并使用该 CA 为内部应用生成证书是可行的，而且通常是有用的。这就是我们在为 OpenLDAP
    创建证书时所做的事情。
- en: Of course, certificates generated this way may not be considered reliable to
    users outside of your organization, but hosting an individual or organization-wide
    CA can be an effective way to add security to your own network, without having
    to purchase certificates from a commercial vendor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种方式生成的证书可能不会被组织外的用户认为是可靠的，但托管一个个人或组织级别的 CA 可以有效地为自己的网络增加安全性，而无需购买来自商业供应商的证书。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not all CAs use the same form of authoritative signing (and not all CAs charge
    for certificates). Some CAs, such as Cacert.org, use what is called a **web of
    trust** technique for establishing authenticity. In the web of trust the authenticity
    of a certificate is established by peers who can play the role of assuring that
    the certificate is owned by the person or organization that it claims to be owned
    by. For more information visit [http://www.cacert.org/](http://www.cacert.org/).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有 CA 都采用相同形式的权威签名（也并非所有 CA 都收取证书费用）。有些 CA，如 Cacert.org，采用一种称为 **信任网** 的技术来建立身份认证。在信任网中，证书的真实性由同伴验证，他们可以担任确保证书归属所声明的个人或组织的角色。欲了解更多信息，请访问
    [http://www.cacert.org/](http://www.cacert.org/)。
- en: We have discussed the first role of SSL/TLS, establishing authenticity. Next
    we will turn to the second role of SSL/TLS; providing encryption services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 SSL/TLS 的第一个功能：建立身份认证。接下来，我们将讨论 SSL/TLS 的第二个功能：提供加密服务。
- en: Encryption
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: 'SSL/TLS provides the features required for sending encrypted messages back
    and forth between the client and the server. In a nutshell the process goes like
    this: the server sends the client its certificate, and inside the certificate
    (among other things) is the server''s **public key**. The public key is the first
    half of a pair of keys. A public key can be used for encrypting a message, but
    not decrypting it. A second key, the **private key**, is then used for decrypting
    a message. The server keeps its private key to itself, but gives out its public
    key to any client that requests it. Clients can then send messages to the server
    that only the server can decrypt and interpret.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SSL/TLS 提供了客户端和服务器之间发送加密消息所需的功能。简而言之，过程如下：服务器将证书发送给客户端，在证书中（以及其他内容中）包含了服务器的**公钥**。公钥是一对密钥中的第一部分。公钥可用于加密消息，但不能解密消息。第二个密钥，**私钥**，则用于解密消息。服务器将私钥保密，但会将公钥提供给任何请求的客户端。客户端可以将消息发送给服务器，只有服务器可以解密并解读这些消息。
- en: Depending on the configuration the client also sends the server its public key,
    which the server can use to send messages that only the client can decrypt. At
    this point, each can transmit encrypted messages to the other.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据配置，客户端还会向服务器发送其公钥，服务器可以利用这个公钥发送只有客户端能够解密的消息。此时，双方可以互相发送加密消息。
- en: 'But there is a drawback to using public/private keys: they are slow and resource-intensive.
    Rather than trading all information through these public/private key combos, the
    client and server then negotiate a set of temporary symmetric encryption keys
    (which use the same key to encrypt and decrypt messages) that they will both use
    for the duration of the session. All traffic between the two clients is encrypted
    using these keys. Once the session is complete, both the client and server discard
    the temporary keys.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥/私钥的缺点是：它们速度较慢且资源消耗大。与其通过这些公钥/私钥组合交换所有信息，客户端和服务器会协商一组临时对称加密密钥（使用相同的密钥来加密和解密消息），它们将在会话期间共同使用。客户端之间的所有流量都使用这些密钥进行加密。一旦会话完成，客户端和服务器都会丢弃临时密钥。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a more detailed introduction to SSL and TLS, as well as pointers to further
    sources of information, see the Wikipedia entry for Transport Layer Security:
    [http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/     Transport_Layer_Security).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SSL和TLS的更详细介绍，以及进一步信息的链接，请参阅维基百科上的传输层安全条目：[http://en.wikipedia.org/wiki/Transport_Layer_Security](http://en.wikipedia.org/wiki/Transport_Layer_Security)。
- en: StartTLS
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StartTLS
- en: As it is typically implemented, SSL requires that the server listen for encrypted
    traffic on a port separate from the one it uses for unencrypted traffic. All traffic
    that comes over the SSL port is assumed to be SSL-encrypted traffic. This means
    that every server that needs to provide both cleartext and encrypted services
    must listen on at least two different ports.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照通常的实现方式，SSL要求服务器在与非加密流量不同的端口上监听加密流量。所有通过SSL端口的流量都被认为是SSL加密的流量。这意味着，任何需要同时提供明文和加密服务的服务器都必须至少在两个不同的端口上监听。
- en: The multi-port requirement seemed to some to be unnecessary, inelegant, and
    wasteful. There is no reason why the client should not be able to request on a
    cleartext (non-SSL) connection that further communication between the client and
    server be encrypted. The client and server could then perform all of the SSL/TLS
    negotiation over the same connection, and not have to switch to another SSL/TLS-only
    port. This suggestion was standardized in RFC2487 as **StartTLS**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 多端口的需求对一些人来说似乎是多余的、不优雅的且浪费资源。没有理由客户端不能在明文（非SSL）连接上请求客户端和服务器之间的进一步通信加密。然后，客户端和服务器可以在同一连接上完成所有SSL/TLS协商，而不必切换到另一个仅支持SSL/TLS的端口。这个建议在RFC2487中被标准化为**StartTLS**。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Which to Pick: StartTLS or LDAPS?**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择哪个：StartTLS还是LDAPS？**'
- en: The standardized way of implementing SSL/TLS in LDAP v.3 is to use the StartTLS
    method. This method should be implemented whenever possible. However, external
    considerations (such as network firewalling or clients without StartTLS support)
    may require that you use LDAPS and a dedicated SSL/TLS-protected port. LDAPS support
    is now listed as deprecated, though it is not yet slated for removal from OpenLDAP.
    Both options can be used on the same server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在LDAP v.3中实现SSL/TLS的标准方法是使用StartTLS方法。此方法应该尽可能实现。然而，外部因素（例如网络防火墙或不支持StartTLS的客户端）可能要求您使用LDAPS和专用的SSL/TLS保护端口。目前，LDAPS支持已被列为过时，但尚未从OpenLDAP中移除。两种方法可以在同一服务器上同时使用。
- en: In a StartTLS-supporting server, if the client sends the server the command
    `STARTTLS` then the server will begin the TLS encryption process. Assuming the
    TLS negotiation is successful, the client and server will then continue their
    transactions using encrypted traffic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持StartTLS的服务器中，如果客户端向服务器发送命令`STARTTLS`，则服务器将开始TLS加密过程。如果TLS协商成功，客户端和服务器将继续使用加密流量进行通信。
- en: StartTLS has the obvious advantage of requiring only one listening port per
    server. And, it makes it possible for clients and servers to communicate in cleartext
    for unimportant data, and then switch over to TLS when security becomes important.
    Since encryption is resource intensive, requiring extra processing power to encrypt
    and decrypt messages, streamlining services the StartTLS way can improve performance
    and free up resources for other tasks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: StartTLS显然的优势是每个服务器只需要一个监听端口。而且，它使得客户端和服务器可以在处理不重要数据时进行明文通信，当安全性变得重要时再切换到TLS。由于加密是资源密集型的，需要额外的处理能力来加密和解密消息，通过StartTLS方式简化服务可以提高性能，并释放资源用于其他任务。
- en: There is a drawback for StartTLS though. Since both encrypted and cleartext
    traffic are sent over the same port, the method of simply blocking a port to prevent
    insecure data transmissions (by using a firewall for instance) is not effective
    with StartTLS. Security measures must be capable of inspecting transmissions at
    the protocol level.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，StartTLS 有一个缺点。由于加密流量和明文流量通过同一个端口发送，单纯通过阻止端口来防止不安全的数据传输（例如使用防火墙）在 StartTLS
    中并不有效。安全措施必须能够在协议级别检查传输。
- en: In order to improve security services in such cases, OpenLDAP provides methods
    of testing the **security strength factor (SSF)** of a connection to see if it
    is encrypted (and if so, if the encryption scheme is strong enough). We will look
    at SSF in more detail later in this chapter in the section on *Using* *Security*
    *Strength* *Factors*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高此类情况下的安全服务，OpenLDAP 提供了测试连接**安全强度因子（SSF）**的方法，以检查连接是否加密（如果是，加密方案是否足够强大）。我们将在本章后面的*使用*
    *安全* *强度* *因子*部分更详细地讨论 SSF。
- en: At this point, you should have a fairly good idea of how SSL and TLS function.
    Now we will move on to more practical matters. We will create our own CA, and
    our own certificate, and then configure OpenLDAP to support SSL/TLS and StartTLS.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对 SSL 和 TLS 的工作原理有了相当清晰的理解。现在我们将进入更实际的部分。我们将创建我们自己的证书颁发机构（CA），并生成我们自己的证书，然后配置
    OpenLDAP 以支持 SSL/TLS 和 StartTLS。
- en: Creating an SSL/TLS CA
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 SSL/TLS 证书颁发机构（CA）
- en: In order to create a Certificate Authority and generate certificates, you will
    need to have OpenSSL installed. Since many Ubuntu packages, including the OpenLDAP
    packages, require OpenSSL, it should be installed already.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建证书颁发机构并生成证书，你需要安装 OpenSSL。由于许多 Ubuntu 包（包括 OpenLDAP 包）都需要 OpenSSL，它应该已经安装好了。
- en: If you build from source, as detailed in [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source"), you may also enable support for SSL/TLS using the OpenSSL
    libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是从源代码构建的，如[附录 A](apa.html "附录 A. 从源代码构建 OpenLDAP")中详细描述的那样，你也可以通过 OpenSSL
    库启用 SSL/TLS 支持。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have a certificate already, you can skip this section and move to the
    *Configuring* *StartTLS* section. OpenLDAP uses certificates in the PEM format.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有了证书，可以跳过本节并转到*配置* *StartTLS* 部分。OpenLDAP 使用 PEM 格式的证书。
- en: The first thing we will need to do is create our new CA.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建新的证书颁发机构（CA）。
- en: While it is possible to manually configure your CA using the `openssl` command
    line tool, it is much simpler to use the `CA.pl` Perl script that is included
    with OpenSSL. This script streamlines many of the configuration options for OpenSSL,
    and the first thing that we will use it for is creating the environment for our
    new CA.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 `openssl` 命令行工具手动配置 CA，但使用随 OpenSSL 附带的 `CA.pl` Perl 脚本要简单得多。这个脚本简化了
    OpenSSL 的许多配置选项，我们首先使用它来创建我们新的 CA 环境。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ubuntu maintains documentation on creating a new Certificate Authority the "long
    way" (creating all of the files by hand). This documentation is detailed and well
    worth reading. While I will follow the conventions established there, I will be
    using the `CA.pl` script to do most of the heavy lifting ([https://help.ubuntu.com/community/OpenSSL](https://help.ubuntu.com/community/OpenSSL)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 维护了关于以“长方式”创建新的证书颁发机构（手动创建所有文件）的文档。这份文档详细且值得阅读。虽然我会遵循那里建立的惯例，但我将使用 `CA.pl`
    脚本来完成大部分繁重的工作（[https://help.ubuntu.com/community/OpenSSL](https://help.ubuntu.com/community/OpenSSL)）。
- en: 'You can put the CA environment anywhere on your system. Some prefer to keep
    CA files with the rest of the SSL configuration at `/etc/ssl/`. Others prefer
    keeping the certificate authority in a user directory so that it does not get
    overwritten during system upgrades (an unlikely, but possible, event). In keeping
    with the Ubuntu suggestion to keep CA info in a user''s home directory, I will
    just put mine in my home directory, `/home/mbutcher/`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 CA 环境放在系统的任何位置。有些人喜欢将 CA 文件与其他 SSL 配置一起保存在 `/etc/ssl/` 目录下。也有一些人喜欢将证书颁发机构保存在用户目录中，以避免在系统升级时被覆盖（虽然这不太可能，但也有这种可能）。根据
    Ubuntu 的建议，我将把它保存在我的用户主目录下，路径为 `/home/mbutcher/`：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the `CA.pl` script is not in `$PATH`, so you will need to type in
    the entire path to the script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CA.pl` 脚本不在 `$PATH` 中，因此你需要输入脚本的完整路径。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Finding CA.pl**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找 CA.pl**'
- en: Different operating system distributions will put `CA.pl` in different places.
    If running `which CA.pl` does not return any results, you may want to consult
    the man pages for SSL (`man config` or `man CA.pl`), or use the `find` or `slocate`
    utilities to find the `CA.pl` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统发行版会将 `CA.pl` 放在不同的位置。如果运行 `which CA.pl` 没有返回任何结果，你可能需要查阅 SSL 的手册页（`man
    config` 或 `man CA.pl`），或者使用 `find` 或 `slocate` 工具来查找 `CA.pl` 文件。
- en: The argument `-newca` instructs `CA.pl` to set up a new certificate authority
    environment. This will generate a directory structure along with a number of files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `-newca` 指示 `CA.pl` 设置一个新的证书颁发机构环境。这将生成一个目录结构，并包含多个文件。
- en: 'The first thing that `CA.pl` will do is prompt you to enter a CA file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl` 首先会提示你输入一个 CA 文件：'
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hit *Enter* to create a new CA certificate. `CA.pl` will then generate a new
    key and then prompt you for a password:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 *Enter* 创建一个新的 CA 证书。然后，`CA.pl` 会生成一个新的密钥，并提示你输入密码：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once you have entered and re-entered your password, `CA.pl` will collect some
    information from you about your organization:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入并重新输入了密码，`CA.pl` 将收集一些关于你所在组织的信息：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`CA.pl` walks you through the process of creating a main certificate. The highlighted
    lines in the code listing are those where you will have to provide information
    at an interactive prompt. After setting the country, state, and city name for
    my locale, we set the **Organization Name** to **Example.Com**. While we left
    the **Organizational Unit** field blank, you can use that to further specify what
    part of the organization this CA is a member of.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl` 会引导你完成创建主证书的过程。代码列表中高亮的行是你在交互式提示中需要提供信息的地方。设置好国家、州和城市名称后，我们将 **组织名称**
    设置为 **Example.Com**。虽然我们将 **组织单位** 字段留空，但你可以利用这个字段进一步指定这个 CA 属于组织的哪个部分。'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should consider using the same fields in your certificate that you used
    for your root DN when you set up your directory information tree in the previous
    two chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该考虑在证书中使用与你在前两章设置目录信息树时使用的根 DN 相同的字段。
- en: Usually the **Common Name** and **Email Address** fields should contain information
    about the organization. Sometimes **Common Name** is used for the server name
    (as will be the case when we create our certificate). Sometimes, it is used for
    contact information. In the case that follows, we used my name and email. If the
    CA is to be the "official" CA for your organization, you should set this to the
    official contact person for certificate inquiries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，**公共名称** 和 **电子邮件地址** 字段应包含有关组织的信息。有时，**公共名称** 用于服务器名称（如我们创建证书时）。有时，它也用于联系信息。在接下来的例子中，我们使用了我的名字和电子邮件。如果
    CA 是你组织的“官方” CA，你应该将其设置为证书查询的官方联系人。
- en: 'Next, `CA.pl` will begin the process of generating a certificate request for
    the CA certificate. In other words, `CA.pl` will create a new certificate that
    will be the CA''s own certificate. The first step in doing this is to create a
    certificate request. We will need to set a challenging password for the certificate
    request. We can also set a company name too. With the above information, `CA.pl`
    will continue the process of generating a new certificate:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`CA.pl` 将开始生成 CA 证书的证书请求。换句话说，`CA.pl` 将创建一个新的证书，作为 CA 自己的证书。第一步是创建证书请求。我们需要为证书请求设置一个复杂的密码，也可以设置公司名称。有了上述信息，`CA.pl`
    将继续生成新证书的过程：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will be prompted to enter a pass phrase. This is the pass phrase we created
    first (when prompted to **Enter PEM pass phrase**). If we enter the pass phrase
    correctly, `CA.pl` will generate our new certificate and display its contents
    on the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被提示输入密码短语。这是我们首先创建的密码短语（当提示输入 **PEM 密码短语** 时）。如果我们正确输入密码短语，`CA.pl` 将生成新的证书，并在屏幕上显示其内容。
- en: We have now created a Certificate Authority. Now we are ready to start generating
    a certificate to be used by SLAPD.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个证书颁发机构。现在，我们准备开始生成一个供 SLAPD 使用的证书。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Due to a bug in some versions of `CA.pl`, you may have to `cd` into the `./demoCA`
    directory (the directory that `CA.pl -newca` created) and add a symbolic link
    to itself: `ln -s ./demoCA`. This is because `CA.pl` occasionally expects to find
    files in the current directory (`./`), which it assumes to be `demoCA/`, and sometimes
    it expects to find files in `./demoCA` (which, of course, is equivalent to `demoCA/demoCA/`).
    You can also fix this simply by editing the `dir=` line under `[CA_default]` in
    the `/etc/ssl/openssl.cnf` file, and setting it to an absolute path.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些版本的`CA.pl`存在bug，您可能需要`cd`进入`./demoCA`目录（`CA.pl -newca`创建的目录），并为其添加一个符号链接：`ln
    -s ./demoCA`。这是因为`CA.pl`有时会期望在当前目录（`./`）中找到文件，它假设该目录是`demoCA/`，有时它期望在`./demoCA`中找到文件（这当然等同于`demoCA/demoCA/`）。您也可以通过简单地编辑`/etc/ssl/openssl.cnf`文件中`[CA_default]`下的`dir=`行，并将其设置为绝对路径来解决此问题。
- en: Creating a Certificate
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建证书
- en: 'Creating a certificate is a two-step process:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建证书是一个两步过程：
- en: We need to generate the Certificate Request.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要生成证书请求。
- en: We need to sign the request with the CA's signature.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要用CA的签名来签署请求。
- en: Let's see these steps in detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这些步骤。
- en: Creating a New Certificate Request
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的证书请求
- en: The first step in creating a valid SSL certificate is to create a Certificate
    Request. In the process, we will specify what information we want to show up on
    the certificate.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效的SSL证书的第一步是创建证书请求。在这个过程中，我们将指定我们希望在证书上显示的信息。
- en: There are a few ways to generate Certificate Requests. For example, you can
    use the `openssl` command line tool and specifying a number of command line parameters.
    But, following our previous example, we will use `CA.pl` and let the application
    prompt us for information as is necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以生成证书请求。例如，您可以使用`openssl`命令行工具并指定一系列命令行参数。但是，按照我们之前的示例，我们将使用`CA.pl`并让应用程序在需要时提示我们输入信息。
- en: 'To generate a new request we will run `CA.pl -newreq`. In the next example
    the highlighted lines are lines that require us to enter information:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成新的请求，我们将运行`CA.pl -newreq`。在下一个示例中，突出显示的行是需要我们输入信息的行：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should look familiar. It is similar in most respects to the process of
    generating a Certificate Authority.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉。在大多数方面，它与生成证书颁发机构的过程相似。
- en: First, we will be prompted to enter a pass phrase. We will use this pass phrase
    in a few moments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将被提示输入一个密码短语。我们将在稍后使用这个密码短语。
- en: Next, we will be asked to supply information about the organization that this
    certificate will represent. As before the fields are Country Name, State/Province
    Name, Locality, Organization Name, Organizational Unit, Common Name (of the contact
    person), and the Email for the contact person. Again, as before, we entered the
    information for Example.Com.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要提供有关该证书所代表的组织的信息。和之前一样，字段包括国家名、州/省名、城市、组织名、组织单位、联系人常用名和联系人的电子邮件地址。同样，像之前一样，我们输入了Example.Com的相关信息。
- en: This time, however, we set the Common Name field to be the domain name of the
    server that the certificate is for—`example.com`. It is very important that you
    use the correct domain name for the server. During the certificate negotiation
    process clients will check the Common Name field to see if it matches the domain
    name of the server. If the names do not match the user may get an error message,
    or the client application may simply terminate the connection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次我们将“常用名称”字段设置为证书所对应的服务器域名——`example.com`。正确使用服务器的域名非常重要。在证书协商过程中，客户端会检查“常用名称”字段，看它是否与服务器的域名匹配。如果域名不匹配，用户可能会收到错误信息，或者客户端应用程序可能会直接终止连接。
- en: The extra *password* and *optional* *company* *name* are sometimes used in the
    certificate request process. Since we are doing the requesting and the signing
    ourselves we don't need to complete either of these fields.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的*密码*和*可选* *公司* *名称*有时会在证书请求过程中使用。由于我们自己在请求和签署过程中进行操作，因此不需要填写这些字段。
- en: 'Now we should have two files in the CA directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在CA目录中有两个文件：
- en: One called `newreq.pem`, which contains a base-64 encoded representation of
    our certificate request
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是创建名为`newreq.pem`的文件，里面包含我们证书请求的base-64编码表示。
- en: One called `newkey.pem`, which contains the base-64 encoded private key
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是创建名为`newkey.pem`的文件，里面包含base-64编码的私钥。
- en: We are now ready to move on to the second step.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续进行第二步了。
- en: Signing the Certificate Request
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签署证书请求
- en: 'The Certificate Request has all of the information required for a certificate,
    but it still lacks the digital signature of the CA. The next step, then, will
    be to use the CA we created previously to sign this new certificate. To do this,
    we will run `CA.pl -signreq`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 证书请求包含了证书所需的所有信息，但仍然缺少 CA 的数字签名。那么，下一步就是使用我们之前创建的 CA 来签署这个新证书。为此，我们将运行 `CA.pl
    -signreq`：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `CA.pl -signcert` command looks for `newreq.pem` and then begins the signing
    process. First, we need to enter the pass phrase for the CA. If that is correct,
    then `CA.pl` will display the certificate in `newreq.pem` and ask if we want to
    sign it. Finally, it will ask us to commit these changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`CA.pl -signcert` 命令会查找 `newreq.pem` 文件，然后开始签名过程。首先，我们需要输入 CA 的密码短语。如果密码正确，`CA.pl`
    会显示 `newreq.pem` 中的证书，并询问是否要签署它。最后，它会要求我们提交这些更改。'
- en: Once the changes are committed a new file will be created, named `newcert.pem`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改被提交，将会创建一个名为 `newcert.pem` 的新文件。
- en: 'There are two important files that we now have:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有两个重要的文件：
- en: '`newkey.pem`, which contains the private key'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newkey.pem`，它包含私钥。'
- en: '`newcert.pem`, which contains the signed certificate.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newcert.pem`，它包含签名后的证书。'
- en: We've just got a few loose ends to tie up, and then we can move on to configuring
    SLAPD to use SSL/TLS.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要处理几个小问题，然后就可以继续配置 SLAPD 以使用 SSL/TLS。
- en: Configuring and Installing the Certificates
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置和安装证书
- en: We have only three more steps to do, here. The first one has to do with the
    pass phrase we set on our certificate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要完成剩下的三个步骤。第一个步骤与我们在证书中设置的密码短语有关。
- en: Remove the Pass Phrase from the Key
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除密钥的密码短语
- en: Be very careful here! When generating our certificate request, we set a pass
    phrase on the certificate. This encrypted the `newkey.pem` file with a pass phrase.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要非常小心！在生成证书请求时，我们为证书设置了一个密码短语。这使得 `newkey.pem` 文件使用密码短语进行了加密。
- en: If you use a key file that is encrypted with a pass phrase, then every time
    you use this certificate, you will have to enter a password. This means, in our
    case, that every time we start OpenLDAP, we will have to enter a pass phrase.
    Unless we have stringent security requirements (and are willing to put up with
    the hassle of typing the pass phrase every time we start or restart the server),
    we probably do not want the key file to be encrypted.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是带有密码短语加密的密钥文件，那么每次使用这个证书时，你都必须输入密码。这意味着，在我们的例子中，每次启动 OpenLDAP 时，我们都需要输入密码短语。除非我们有严格的安全要求（并且愿意忍受每次启动或重启服务器时输入密码短语的麻烦），否则我们可能不希望密钥文件被加密。
- en: 'So, we will need to create an unencrypted version of the key file using the
    `openssl` command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要使用 `openssl` 命令创建一个未加密版本的密钥文件：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what we get:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的结果：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example the command `openssl rsa` executes the OpenSSL RSA tool, which
    will decrypt the key. Using `< newkey.pem`, we sent the file contents of `newkey.pem`
    into `openssl` to be decrypted. Then, using `> clearkey.pem` we directed `openssl`
    to write the cleartext key file to the `clearkey.pem` file. In order to complete
    this operation, `openssl` prompts for the pass phrase. Now `clearkey.pem` has
    the unencrypted private key for our certificate.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，命令 `openssl rsa` 执行了 OpenSSL RSA 工具，它将解密密钥。通过 `< newkey.pem`，我们将 `newkey.pem`
    文件的内容传递给 `openssl` 进行解密。然后，通过 `> clearkey.pem`，我们指示 `openssl` 将明文密钥文件写入 `clearkey.pem`
    文件。为了完成此操作，`openssl` 会提示输入密码短语。现在，`clearkey.pem` 文件包含了我们证书的未加密私钥。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `clearkey.pem` file now contains an unencrypted private key. This file should
    be protected from misuse. You should set strict permissions on this file so that
    other users of the system cannot access it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearkey.pem` 文件现在包含了一个未加密的私钥。此文件应该受到保护，以防止滥用。你应该为此文件设置严格的权限，以确保系统中的其他用户无法访问它。'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The openssl Program**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenSSL 程序**'
- en: 'The `openssl` program performs dozens of SSL-related functions, from generating
    certificates to emulating a network-based SSL client. Its syntax is notoriously
    difficult though. That is why we have been using the `CA.pl` wrapper script to
    perform common tasks. But some tasks can only be done with the `openssl` command.
    Should you need them though, `openssl` has excellent man pages: `man openssl`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 程序执行了几十个与 SSL 相关的功能，从生成证书到模拟基于网络的 SSL 客户端。其语法通常比较复杂。这也是为什么我们使用 `CA.pl`
    包装脚本来执行常见任务的原因。但有些任务只能通过 `openssl` 命令来完成。如果需要，`openssl` 有非常出色的手册页面：`man openssl`。'
- en: Relocate the Certificates
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移动证书
- en: The second task is to move our new certificate and key to a useful location
    on the server, and give the PEM files useful names as well. If this certificate
    is to be used by lots of different services, it might make sense to locate it
    in the shared directory. But for our cases we will only be using the SSL certificate
    for LDAP, so we can put the files in `/etc/ldap/` (or `/usr/local/etc/openldap/`
    if you built from source).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是将我们的新证书和密钥移动到服务器上的一个有用位置，并给PEM文件命名。如果这个证书需要被多个不同的服务使用，可能可以考虑将其放在共享目录中。但在我们的情况下，我们只会将SSL证书用于LDAP，所以我们可以将文件放在`/etc/ldap/`（如果您是从源代码构建的，可以放在`/usr/local/etc/openldap/`）。
- en: 'The two files with which we are concerned are `newcert.pem` and `clearkey.pem`.
    We need to rename and move those two keys:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关注的两个文件是`newcert.pem`和`clearkey.pem`。我们需要重命名并移动这两个密钥：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we need to set permissions and ownership on the certificate files. Since
    we did not add a pass phrase to the key, we should also make sure that only the
    OpenLDAP user can read the key file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为证书文件设置权限和所有权。由于我们没有给密钥添加密码短语，我们还应确保只有OpenLDAP用户能够读取该密钥文件：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line changes the owner and group of the two PEM files to the `root`
    user and the `root` group. The second line sets the mode so that only the owner
    can read the file, and no one else has any access.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将两个PEM文件的所有者和组更改为`root`用户和`root`组。第二行设置权限，使得只有文件所有者能够读取该文件，其他人无法访问。
- en: If you are running OpenLDAP as a user other than root (and it is a good idea
    to do so), then the files should be owned by that user instead of root; for example
    `chown oenldap example.com.*.pem`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以非root用户运行OpenLDAP（这样做是个好主意），那么这些文件应该由该用户而非root用户拥有；例如`chown oenldap example.com.*.pem`。
- en: Install the CA Certificate
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装CA证书
- en: 'The third task is to install the CA''s public certificate so that other applications
    on the system can use that certificate to verify the authenticity of the certificate
    we just generated. First, we need to copy the CA certificate to the local certificate
    database for Ubuntu. In the process we will give it a user-friendly name:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个任务是安装CA的公用证书，以便系统上的其他应用程序可以使用该证书来验证我们刚生成的证书的真实性。首先，我们需要将CA证书复制到Ubuntu本地的证书数据库。在此过程中，我们将为它提供一个用户友好的名称：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then, edit the `/etc/ca-certificates.conf` file, and add `Example.Com.crt` at
    the end of the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑`/etc/ca-certificates.conf`文件，并在文件末尾添加`Example.Com.crt`。
- en: 'Finally, run `update-ca-certificates`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`update-ca-certificates`：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The CA certificate has now been installed. The `/etc/ssl/certs` directory is
    now the authoritative source for CA certificates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: CA证书现在已经安装。`/etc/ssl/certs`目录现在是CA证书的权威来源。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UNIX and Linux systems other than Ubuntu and Debian may not have the `update-ca-certificates`
    script. Consult the system documentation to find out how to update the certificate
    database on such systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Ubuntu和Debian之外的UNIX和Linux系统可能没有`update-ca-certificates`脚本。请查阅系统文档，了解如何在这些系统中更新证书数据库。
- en: 'Optional: Clean Up'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可选：清理
- en: 'If you want, you can do a little clean-up in the CA directory. Delete the encrypted
    key file and the certificate request file, both of which are in the `demoCA/`
    directory:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以在CA目录中做一些清理。删除加密的密钥文件和证书请求文件，这两个文件都位于`demoCA/`目录中：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, make sure `clearkey.pem` is no longer present in the `demoCA/` directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，确保`clearkey.pem`不再出现在`demoCA/`目录中。
- en: Now we are ready to configure OpenLDAP to use our new certificates. First, we
    will configure StartTLS support, which is the easiest, then we will configure
    SSL/TLS support on the LDAPS port, port 636.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好配置OpenLDAP以使用我们的新证书了。首先，我们将配置StartTLS支持，这是最简单的，然后我们将在LDAPS端口636上配置SSL/TLS支持。
- en: Configuring StartTLS
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置StartTLS
- en: In the previous sections we created our new certificate and key, and placed
    the two files in the `/etc/ldap` directory. In this section we will set up StartTLS
    (which we introduced earlier in this chapter in the StartTLS section). Setting
    up StartTLS requires only a few extra lines in the `slapd.conf` file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们创建了新证书和密钥，并将这两个文件放置在`/etc/ldap`目录中。在本节中，我们将设置StartTLS（我们在本章的StartTLS部分已经介绍过）。配置StartTLS只需要在`slapd.conf`文件中增加几行。
- en: Again, StartTLS is the standard way (according to RFC 4511) of providing SSL/TLS
    security to OpenLDAP. For security reasons support for StartTLS should be provided
    whenever practical.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，StartTLS是为OpenLDAP提供SSL/TLS安全性的一种标准方式（根据RFC 4511）。出于安全原因，应在实际操作中提供对StartTLS的支持。
- en: 'In the `slapd.conf` file, just before the `BDB Database Configuration` section,
    insert the SSL/TLS options:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `slapd.conf` 文件中，在 `BDB 数据库配置` 部分之前，插入 SSL/TLS 选项：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Basically, there are only three directives we need to specify to get StartTLS
    working:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要指定三个指令就可以使 StartTLS 工作：
- en: The first directive, `TLSCACertificatePath`, tells SLAPD where to find all of
    the CA certificates that it will need for verifying certificates. The definitive
    location is, as we saw before, the `/etc/ssl/certs/` directory.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个指令 `TLSCACertificatePath` 告诉 SLAPD 在哪里找到所有它需要用于验证证书的 CA 证书。绝对位置是，正如我们之前看到的，`/etc/ssl/certs/`
    目录。
- en: The second directive, `TLSCertificateFile`, specifies the location of the signed
    certificate.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个指令 `TLSCertificateFile` 指定了已签名证书的位置。
- en: The third directive, `TLSCertificateKeyFile`, specifies the location of the
    corresponding key file, which has the private encryption key for the certificate.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个指令 `TLSCertificateKeyFile` 指定了相应密钥文件的位置，该文件具有证书的私有加密密钥。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are a handful of other TLS-specific directives that allow you to provide
    detailed constraints on TLS connections (such as which suites of ciphers can be
    used, and whether the client needs to provide a certificate to the server). Complete
    documentation on these can be found in the TLS section of the `slapd.conf` man
    page: `man slapd.conf`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他特定于 TLS 的指令，允许您对 TLS 连接提供详细的约束（例如可以使用哪些密码套件，以及是否需要客户端向服务器提供证书）。关于这些的完整文档可以在
    `slapd.conf` 手册的 TLS 部分找到：`man slapd.conf`。
- en: That's all we need to get SLAPD to perform StartTLS. Restart SLAPD so that the
    changes take effect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使 SLAPD 执行 StartTLS 所需的所有内容。重新启动 SLAPD 以使更改生效。
- en: Configuring Client TLS
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置客户端 TLS
- en: We do need to add a directive or two to `ldap.conf`—the configuration file that
    the OpenLDAP clients use. As with SLAPD, we need to direct the clients to the
    correct location of the new CA certificate so that they can verify the server
    certificate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要在 `ldap.conf` 中添加一两个指令——这是 OpenLDAP 客户端使用的配置文件。与 SLAPD 类似，我们需要将客户端指向新的
    CA 证书的正确位置，以便它们可以验证服务器证书。
- en: 'At the bottom of the `ldap.conf` file we can add the appropriate directive:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ldap.conf` 文件的底部，我们可以添加适当的指令：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Clients will use this directive to locate the CA certificates for checking digital
    signatures on the certificates they get from servers. If you know that you are
    only going to use certificates signed by a specific CA, you can use the `TLS_CACERT`
    directive to point to a specific CA certificate file, instead of a directory containing
    one or more certificates.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将使用此指令来定位 CA 证书，以便检查从服务器获取的证书的数字签名。如果您知道您只会使用由特定 CA 签名的证书，可以使用 `TLS_CACERT`
    指令指向特定的 CA 证书文件，而不是包含一个或多个证书的目录。
- en: By default, OpenLDAP clients always perform a check on the digital signatures.
    If a server sends a certificate that was signed by a CA other than those at `/etc/ssl/certs/`
    (or whatever directory `TLS_CACERTDIR` points to), then the client will close
    the connection and print an error message to the screen.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenLDAP 客户端始终对数字签名进行检查。如果服务器发送的证书由 `/etc/ssl/certs/`（或 `TLS_CACERTDIR`
    指向的任何目录）之外的 CA 签名，那么客户端将关闭连接并在屏幕上打印错误消息。
- en: Sometimes though, the correct CA certificate is not available, and it is worthwhile
    to get the encryption support of TLS even if it is not possible to verify the
    identity of the server.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，即使无法验证服务器的身份，也值得获得 TLS 的加密支持，因此正确的 CA 证书不可用。
- en: 'In such cases you may find it necessary to change the way OpenLDAP clients
    perform identification checks. For example, it might be desirable to try to verify
    the certificate, but to continue with the connection even if there is no appropriate
    CA locally. To accomplish this, use the following directive in `slapd.conf`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可能需要更改 OpenLDAP 客户端执行身份验证检查的方式。例如，可能希望尝试验证证书，但即使没有适当的本地 CA，也希望继续连接。为此，在
    `slapd.conf` 中使用以下指令：
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, if there is no CA certificate or if the certificate sent cannot
    be verified, the session will continue, rather than exiting with an error message.
    `TLS_REQCERT` has a few different levels of checking, ranging from `strict` (always
    verify) to `never` (do not even bother trying to verify certificates).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有 CA 证书或者发送的证书无法验证，会话将继续，而不会显示错误消息。`TLS_REQCERT` 有几个不同的检查级别，从 `strict`（始终验证）到
    `never`（甚至不尝试验证证书）不等。
- en: 'At this point, we can use `ldapsearch` to test a connection. To instruct a
    client to use StartTLS, we need to use the `-Z` flag. But if just `-Z` is specified,
    if the client fails TLS negotiation with the server, it will continue with the
    transaction in clear text. In other words, with `-Z`, TLS is preferred, but not
    required. To make TLS required, we will add an extra z to the flag, making it
    `-ZZ`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以使用 `ldapsearch` 来测试连接。要指示客户端使用 StartTLS，我们需要使用 `-Z` 标志。但是，如果仅指定 `-Z`，当客户端与服务器的
    TLS 协商失败时，它将继续以明文进行事务。换句话说，使用 `-Z` 时，TLS 是优先的，但不是强制的。要使 TLS 成为必需，我们将向标志中添加一个额外的
    z，使其变为 `-ZZ`：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should prompt for a password and then return one result:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会提示输入密码，然后返回一个结果：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the result comes back like this, then TLS was successfully configured. But
    TLS can be difficult to get configured because it is strict by design. Small errors
    in configuration (like using a domain name that differs from the one in the CN
    field of the certificate) can prevent TLS from working. Consider this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果返回如下，则表示 TLS 配置成功。但由于 TLS 在设计上是严格的，配置可能会很困难。配置中的小错误（例如使用与证书中的 CN 字段不同的域名）可能会导致
    TLS 无法正常工作。考虑以下示例：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the host name specified on the command line (`localhost`) differed
    from the one in the CN field of the certificate (`example.com`). Even though,
    in this case, the two domain names are hosted on the same system, TLS will not
    accept the mismatch.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，命令行中指定的主机名（`localhost`）与证书中的 CN 字段（`example.com`）中的主机名不同。尽管在此情况下，这两个域名托管在同一系统上，TLS
    仍然不接受不匹配。
- en: 'Other common errors in TLS are:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 中的其他常见错误包括：
- en: Reversing the values of the `TLSCertificateFile` and the `TLSCertificateKeyFile`
    directives
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转 `TLSCertificateFile` 和 `TLSCertificateKeyFile` 指令的值
- en: Forgetting to install the CA certificate (which results in an error indicating
    that the server certificate cannot be verified)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记安装 CA 证书（导致出现错误，表示无法验证服务器证书）
- en: Forgetting to set the client CA path correctly in `ldap.conf`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记在 `ldap.conf` 中正确设置客户端 CA 路径
- en: Setting the read/write permissions (or the ownership) on the key file (or the
    certificate file) in such a way that the SLAPD server cannot read it
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在密钥文件（或证书文件）上设置读/写权限（或所有权），使得 SLAPD 服务器无法读取它
- en: While OpenLDAP can be forgiving in many areas, TLS configuration is not one
    of them. It pays to take extra care when configuring TLS and SSL.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OpenLDAP 在许多方面可以宽容，但 TLS 配置并不是其中之一。在配置 TLS 和 SSL 时需要特别小心。
- en: Configuring LDAPS
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 LDAPS
- en: Now that we have configured TLS, we need to take only a few additional steps
    to enable SSL/TLS on its own port. The traditional port for running dedicated
    TLS/SSL-protected LDAP traffic is port 636, the LDAPS port.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了 TLS，接下来只需执行几个额外的步骤，以便在其专用端口上启用 SSL/TLS。运行专用的 TLS/SSL 保护的 LDAP 流量的传统端口是
    636，LDAPS 端口。
- en: Most of the time it is better to use StartTLS. However, network considerations
    (like clients that do not support StartTLS or policies dictating mandatory blocking
    on ports that allow non-encrypted text) might warrant using LDAPS.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，使用 StartTLS 更好。然而，网络因素（如不支持 StartTLS 的客户端或要求强制阻塞允许非加密文本的端口的政策）可能需要使用 LDAPS。
- en: Keep in mind that LDAPS and StartTLS can both be used for the same server. SLAPD
    can accept LDAPS traffic on a dedicated port, and continue to provide the StartTLS
    feature on an LDAP port.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，LDAPS 和 StartTLS 都可以用于同一服务器。SLAPD 可以在专用端口上接受 LDAPS 流量，并继续在 LDAP 端口提供 StartTLS
    功能。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Like the StartTLS configuration, this configuration requires that the `slapd.conf`
    file have the `TLSCertificateFile`, `TLSCertificateKeyFile`, and `TLSCACertificateDir`
    directives set.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与 StartTLS 配置类似，此配置要求 `slapd.conf` 文件中设置 `TLSCertificateFile`、`TLSCertificateKeyFile`
    和 `TLSCACertificateDir` 指令。
- en: Getting SLAPD to listen on this port requires passing an additional parameter
    when starting `slapd`. In Ubuntu, as with other Debian-based distributions, configuration
    parameters can be set in the `/etc/defaults/slapd` file. In that file we just
    need to set `SLAPD_SERVICES`. When the start script is executed, SLAPD will start
    all of the services listed here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 SLAPD 监听此端口，需要在启动 `slapd` 时传递一个额外的参数。在 Ubuntu 中，与其他基于 Debian 的发行版一样，配置参数可以在
    `/etc/defaults/slapd` 文件中设置。在该文件中，我们只需要设置 `SLAPD_SERVICES`。当启动脚本执行时，SLAPD 会启动此处列出的所有服务。
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The given code tells SLAPD to listen on all available IP addresses on both
    the default LDAP (port 389) and the default LDAPS (port 636). If we wanted SLAPD
    to only listen on one address for LDAP traffic, but all addresses for LDAPS traffic,
    we could replace the above with:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的代码指示 SLAPD 在所有可用的 IP 地址上监听默认的 LDAP（端口 389）和默认的 LDAPS（端口 636）。如果我们希望 SLAPD
    只在一个地址上监听 LDAP 流量，但在所有地址上监听 LDAPS 流量，可以将上面的配置替换为：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `ldap://127.0.0.1/` tells SLAPD to only listen on the loopback address
    for LDAP traffic, while `ldaps:///` indicates that SLAPD should listen for LDAPS
    traffic on all of the IP addresses configured for this host. You will need to
    restart SLAPD in order for these changes to take effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ldap://127.0.0.1/` 告诉 SLAPD 仅在回环地址上监听 LDAP 流量，而 `ldaps:///` 则表示 SLAPD 应该在为该主机配置的所有
    IP 地址上监听 LDAPS 流量。你需要重启 SLAPD，才能使这些更改生效。
- en: 'Similarly, if you built from source and want to start `slapd` directly, the
    `-h` command line flag lets you specify which services to start:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果你是从源代码构建并且想直接启动 `slapd`，`-h` 命令行参数可以让你指定启动哪些服务：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That is all there is to configuring LDAPS. We can now test it with `ldapsearch`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 LDAPS 就这么简单。我们现在可以用 `ldapsearch` 来测试它：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two crucial differences between this `ldapsearch` and the ones we
    used when testing StartTLS:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `ldapsearch` 和我们在测试 StartTLS 时使用的有两个关键区别：
- en: The protocol for the URL specified after the `-H` flag is `ldaps://` rather
    than `ldap://`.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H` 参数后指定的 URL 协议是 `ldaps://`，而不是 `ldap://`。'
- en: There is no `-Z` or `-ZZ` flag here. Those flags tell the client to send the
    StartTLS command, and SSL/TLS over a dedicated port do not recognize the StartTLS
    command.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有 `-Z` 或 `-ZZ` 参数。这些参数告诉客户端发送 StartTLS 命令，而 SSL/TLS 通过专用端口时，不会识别 StartTLS
    命令。
- en: If you get an error doing the given search, but StartTLS is working properly,
    the first place to look is at the firewall settings. Typically, firewalls allow
    traffic on port 389, but block 636\. It is also useful to make sure that the server
    is actually listening on port 636\. You can check this from a shell prompt using
    `netstat –tcp -l`, which will print out a list of what ports are being used. If
    LDAPS (636) does not show up, then check `/etc/defaults/slapd` again to make sure
    that the `SLAPD_SERVICES` directive is set correctly.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在进行给定的搜索时遇到错误，但 StartTLS 工作正常，首先要检查的是防火墙设置。通常，防火墙会允许通过 389 端口的流量，但会阻塞 636
    端口。还可以确保服务器确实在监听 636 端口。你可以通过命令行使用 `netstat –tcp -l` 来检查，这会显示正在使用的端口列表。如果 LDAPS（636）没有出现，检查
    `/etc/defaults/slapd` 配置，确保 `SLAPD_SERVICES` 指令设置正确。
- en: Debugging with the OpenSSL Client
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 OpenSSL 客户端调试
- en: 'In some cases it is useful to be able to connect to SLAPD over LDAPS and watch
    the certificate processing. The `openssl` program can do this with its built-in
    `s_client` client application:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，能够通过 LDAPS 连接到 SLAPD 并观察证书处理过程是有用的。`openssl` 程序可以通过其内置的 `s_client` 客户端应用程序实现这一点：
- en: '[PRE24]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `-connect` parameter takes a host name followed by a colon and a port number.
    When this command is run, `openssl` will connect to a remote server using SSL,
    and perform the certificate negotiation. The entire negotiation process is written
    to the screen. If certificate negotiation succeeds, then `openssl` leaves the
    connection open, and you can type in raw protocol commands at the command line.
    To exit, just hit *CTRL*+*C*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`-connect` 参数接受主机名，后面跟一个冒号和端口号。当运行此命令时，`openssl` 将通过 SSL 连接到远程服务器，并执行证书协商。整个协商过程将显示在屏幕上。如果证书协商成功，`openssl`
    将保持连接打开，你可以在命令行输入原始协议命令。要退出，只需按 *CTRL*+*C*。'
- en: Now we have both StartTLS and TLS/SSL working. We have one more short item to
    cover in this section, and then we will move on to authentication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使 StartTLS 和 TLS/SSL 都能正常工作。我们在这一节中只剩下一个简短的内容要讲解，之后我们将进入认证部分。
- en: Using Security Strength Factors
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全强度因子
- en: There are advantages to running StartTLS. It is simpler to configure, it is
    easier (in many respects) to debug, and complex transactions can switch back and
    forth from cleartext to encryption as needed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 StartTLS 有其优势。它更容易配置，在许多方面更容易调试，且复杂的事务可以根据需要在明文和加密之间切换。
- en: 'But there is one clear drawback: we can use a standard firewall to block non-encrypted
    traffic when all clear text goes over one port and all encrypted traffic goes
    over another. But when both go over the same port, many firewalls can''t do much
    to verify that the traffic is secure.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个明显的缺点：当所有明文流量通过一个端口而所有加密流量通过另一个端口时，我们可以使用标准防火墙来阻止未加密的流量。但当两者都通过同一端口时，许多防火墙无法验证流量是否安全。
- en: But OpenLDAP does provide some tools for implementing this sort of security
    in SLAPD, instead of in a firewall.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但OpenLDAP确实提供了一些工具来在SLAPD中实现这种安全性，而不是在防火墙中实现。
- en: OpenLDAP can examine the integrity and encryption state of a connection and,
    based on those features, assign a **Security Strength Factor (SSF)** to that connection.
    An SSF is a numeric representation of the strength of the protective measures
    used.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP可以检查连接的完整性和加密状态，并根据这些特性为该连接分配一个**安全强度因子（SSF）**。SSF是用于表示保护措施强度的数字表示。
- en: Most of the SSF numbers simply reflect the key length of the encryption cipher.
    For example, since the maximum key length for **DES** is 56, when a connection
    is protected using DES, the SSF is 56\. **Triple-DES (3DES)**, which is the cipher
    used by default in Ubuntu's OpenSSL configuration, has a key length of 112\. Hence,
    its SSF is also 112\. The **AES** cipher, which is strong and can be computed
    quickly, can use different key sizes. AES-128 uses a 128-bit key, while AES-256
    uses a 256-bit key. In the case of AES then, the SSF will reflect the key size.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SSF数字只是反映了加密算法的密钥长度。例如，由于**DES**的最大密钥长度为56，当使用DES保护连接时，SSF为56。**Triple-DES
    (3DES)**，这是Ubuntu的OpenSSL配置中默认使用的加密算法，密钥长度为112。因此，它的SSF也是112。**AES**加密算法既强大又能快速计算，可以使用不同的密钥大小。AES-128使用128位密钥，而AES-256使用256位密钥。因此，AES的SSF将反映密钥大小。
- en: 'There are two special SSF numbers: 0 and 1\. An SSF of 0 indicates (as might
    be expected) that no security measures have been implemented. An SSF of 1 indicates
    that only integrity checking on the connection is being done.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的SSF数字：0和1。SSF为0表示（正如预期的那样）没有实施任何安全措施。SSF为1表示仅对连接进行完整性检查。
- en: OpenLDAP can use SSF information to determine whether a client is allowed to
    connect to the directory. SSF information can also be used in ACLs and in SASL
    configuration, effectively allowing complex rules to be built as to what conditions
    a client connection must satisfy before getting access to perform certain operations
    on the directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP可以使用SSF信息来确定客户端是否可以连接到目录。SSF信息还可以在ACL和SASL配置中使用，有效地允许构建复杂的规则，以确定客户端连接必须满足哪些条件，才能在目录上执行某些操作。
- en: We will look at SASL authentication and ACLs later in this chapter, but right
    now we will look at using SSFs in the `security` directive in `slapd.conf` as
    a way of specifying how secure a connection must be in order to access the database.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论SASL身份验证和ACL，但现在我们将看看如何在`slapd.conf`中的`security`指令中使用SSF，作为指定连接必须多安全才能访问数据库的一种方式。
- en: The security Directive
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性指令
- en: 'The `security` directive can be used in two different contexts in `slapd.conf`.
    If it is put near the top of the file, before any backend databases are defined,
    then it is placed in the *global* context and will apply to all connections. On
    the other hand, if the security directive is placed within a backend definition,
    then it will only be applied to that particular database. For example, consider
    a case where there are two backends:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`security`指令可以在`slapd.conf`中以两种不同的方式使用。如果它放在文件的顶部，在任何后端数据库定义之前，则它被放置在*全局*上下文中，并将应用于所有连接。另一方面，如果`security`指令放在某个后端定义内，则它只会应用于该特定数据库。例如，考虑一个有两个后端的情况：'
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This partial example of a `slapd.conf` file defines two directory backends.
    Now, if the `security` directive is used before the first database is defined
    (namely before the line that says `database hdb`), then it will be applied globally
    to all connections.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`slapd.conf`文件的部分示例定义了两个目录后端。现在，如果`security`指令在第一个数据库定义之前使用（即在`database hdb`那行之前），则它将全局应用于所有连接。
- en: 'But if we wanted to allow non-encrypted connections to DB 2, but allow only
    well-encrypted connections to DB 1 (which houses all of our user entries), we
    could use separate `security` directives:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想允许对数据库2的未加密连接，但只允许对数据库1（它包含所有用户条目）进行加密连接，我们可以使用不同的`security`指令：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the addition of the two highlighted lines—two separate `security` directives,
    one for each database backend.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意两个突出显示的行的添加——两个单独的 `security` 指令，每个后端数据库一个。
- en: 'Now, restarting the directory (note that the `loglevel` is set to `stats`),
    we can test out the security parameters with `ldapsearch`. First, we will try
    to search the `Users` OU with a non-TLS connection:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新启动目录（请注意 `loglevel` 设置为 `stats`），我们可以使用 `ldapsearch` 测试安全参数。首先，我们将尝试使用非
    TLS 连接搜索 `Users` OU：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the log we see entries like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中，我们看到如下条目：
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The third line indicates that the server returned error number 13: `confidentiality
    required`. This is because we did not do anything to protect the connection. Using
    simple authentication (which is not encrypted) and failing to use TLS/SSL resulted
    in the client connection having an effective SSF of 0.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行指示服务器返回错误编号 13：`confidentiality required`。这是因为我们没有采取任何措施来保护连接。使用简单的认证（未加密）并未使用
    TLS/SSL 导致客户端连接的有效 SSF 为 0。
- en: 'Next, let''s do the same search with TLS turned on:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用启用 TLS 的相同搜索：
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that in this example, the `-Z` flag is included to send the StartTLS command.
    Now, the server log says:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，包含 `-Z` 标志以发送 StartTLS 命令。现在，服务器日志显示：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are a few things to note about this result. On the second line, OpenLDAP
    reports that it is doing StartTLS. Two lines later it reports: `TLS established
    tls_ssf=256 ssf=256`. This line indicates that the TLS connection has an SSF of
    256 (since the connection is using AES-256), and that the total SSF of the connection
    is 256.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此结果有几点需要注意。在第二行，OpenLDAP 报告正在执行 StartTLS。两行后，它报告：`TLS established tls_ssf=256
    ssf=256`。此行指示 TLS 连接的 SSF 为 256（因为连接正在使用 AES-256），连接的总 SSF 为 256。
- en: 'If you look a few lines lower, on the second line that begins `BIND`, you will
    notice that there another SSF is reported: `ssf=0`. Why?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下看几行，可以看到开始 `BIND` 的第二行，您会注意到另一个报告的 SSF：`ssf=0`。为什么呢？
- en: OpenLDAP measures SSF on various aspects of the connection. First, as we can
    see above, it checks the SSF of the network connection. TLS/SSL connections are
    assigned an SSF based on their cipher strength.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: OpenLDAP 在连接的各个方面上测量 SSF。首先，正如我们上面所看到的，它检查网络连接的 SSF。基于它们的密码强度，TLS/SSL 连接被分配一个
    SSF。
- en: But during the bind phase when the client authenticates to the directory, OpenLDAP
    also measures the SSF of the authentication mechanism. The simple (`mech=SIMPLE`)
    authentication mechanism does not encrypt the password, and so it is always given
    an SSF of 0.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但在客户端对目录进行身份验证的绑定阶段期间，OpenLDAP 也测量认证机制的 SSF。简单（`mech=SIMPLE`）认证机制不会加密密码，因此始终给予
    SSF 为 0。
- en: The total SSF for the connection, however, remains at 256, with the TLS SSF
    being 256 and the SASL SSF at 0.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，连接的总 SSF 仍为 256，其中 TLS SSF 为 256，SASL SSF 为 0。
- en: A Fine-Grained security Directive
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个精细化的安全指令
- en: The `security` directive that we have looked at so far is basic. It simply requires
    that the overall SSF be 112 (3DES encryption) or greater, but we can make it more
    specific.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的 `security` 指令很基础。它只要求总 SSF 至少为 112（3DES 加密），但我们可以使其更具体。
- en: 'For example, we can simply require that any TLS connection have at least a
    128 bit key:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以简单地要求任何 TLS 连接至少有一个 128 位的密钥：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will require that all incoming connections use TLS with a strong (128 bit
    or greater) cipher.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求所有传入的连接使用具有强大（128 位或更高）的 TLS 密码。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases it is desirable to define which TLS/SSL ciphers or cipher families
    will be used. This cannot be done with the `security` directive. Instead, you
    will need to use the `TLSCipherSuite` directive, which will allow you to give
    a detailed specification for which ciphers are acceptable for TLS/SSL connections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，定义将使用哪些 TLS/SSL 密码或密码族是可取的。这不能通过 `security` 指令完成。相反，您将需要使用 `TLSCipherSuite`
    指令，允许您为 TLS/SSL 连接指定可接受的密码详细规范。
- en: 'Or, if we only wanted to define a strong SSF for connections that try to perform
    a simple bind (as opposed to an SASL bind), then we can specify an SSF just for
    simple binding:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们只想为试图执行简单绑定（而不是 SASL 绑定）的连接定义一个强 SSF，那么我们可以为简单绑定指定一个 SSF：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will require that some strong TLS cipher be used to protect the authentication
    information.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求使用一些强大的 TLS 密码来保护认证信息。
- en: Tip
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you plan to allow simple binding, and you are running on a non-secure network,
    you are strongly advised to configure TLS/SSL and require TLS encryption during
    the bind operation using the `security` directive.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划允许简单绑定，并且你正在一个不安全的网络上运行，强烈建议你配置 TLS/SSL 并在绑定操作期间通过 `security` 指令要求 TLS
    加密。
- en: 'You can also use the `update_ssf` keyword in the `security` directive to set
    the SSF necessary for updating operations. Thus you could specify that only low-grade
    encryption is needed for reading the directory, but high-grade encryption must
    be used for performing updates to directory information:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `security` 指令中使用 `update_ssf` 关键字来设置更新操作所需的 SSF。因此，你可以指定对于读取目录只需要低级加密，但在执行目录信息更新时必须使用高级加密：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the coming section, we will look at SASL configuration. You can use the `security`
    directive to set SSF for SASL binding as well using the `sasl=` and `update_sasl=`
    phrases.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论 SASL 配置。你也可以使用 `security` 指令通过 `sasl=` 和 `update_sasl=` 关键字来为
    SASL 绑定设置 SSF。
- en: Finally, in rare cases where OpenLDAP is listening on a local socket (that is,
    `ldapi://`), you can use `security transport=112` (or whatever cipher strength
    you desire) to ensure that traffic coming over that socket is encrypted.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在极少数情况下，当 OpenLDAP 监听本地套接字（即 `ldapi://`）时，你可以使用 `security transport=112`（或任何你需要的加密强度）来确保通过该套接字传输的流量是加密的。
- en: 'At this point, we have completed our examination of SSL and TLS. Next, we will
    move on to the second of our three aspects of security: authentication.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已完成对 SSL 和 TLS 的讨论。接下来，我们将继续研究安全性三大方面中的第二个：认证。
- en: Authenticating Users to the Directory
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将用户认证到目录
- en: As we have seen earlier in the book, OpenLDAP supports two different methods
    of binding (or authenticating) to the directory. The first is to use simple binding.
    The second is to use SASL binding. In this part we will look at each of these
    two methods of authentication.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书前面看到的，OpenLDAP 支持两种不同的绑定（或认证）方式。第一种是使用简单绑定。第二种是使用 SASL 绑定。在本部分中，我们将分别介绍这两种认证方法。
- en: It is not necessary to choose one or the other. OpenLDAP can be configured to
    do both, at which point it is up to the client as to which method will be used.
    Simple binding is easier to configure (there is very little configuration that
    must be done). But SASL is more secure and more flexible, though these benefits
    come at the cost of added complexity.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 并不需要选择其中一个。OpenLDAP 可以配置同时支持这两种方式，这时由客户端决定使用哪种方法。简单绑定更容易配置（需要的配置非常少）。但 SASL
    更安全且更灵活，尽管这些优点伴随着额外的复杂性。
- en: The basics of the bind operation and the authentication process are covered
    early in Chapter 3\. While we will review some of that materials here, you may
    find it useful to glance back at that section.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定操作和认证过程的基础知识已在第 3 章的早期部分介绍。虽然我们将在这里回顾一些相关内容，但你可能会觉得回头看看该部分的内容很有帮助。
- en: Simple Binding
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单绑定
- en: The first form of authentication we will look at is simple binding. It is simple
    not necessarily from the user's perspective, but it is definitely easier to configure,
    and the process of binding is easier on the server, too, since less processing
    is needed.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看的认证形式是简单绑定。从用户的角度来看，它不一定简单，但它肯定更容易配置，而且绑定过程对服务器来说也更简单，因为需要的处理较少。
- en: 'To perform a simple bind the server requires two pieces of information: a DN
    and a password. If both the DN and the password fields are empty then the server
    attempts to bind as the Anonymous user.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行简单绑定，服务器需要两个信息：一个 DN 和一个密码。如果 DN 和密码字段都为空，则服务器会尝试以匿名用户身份绑定。
- en: During a simple bind the client connects to the server and sends the DN and
    password information to the server, without adding any additional security. The
    password, for example, is not specially encrypted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单绑定过程中，客户端连接到服务器并将 DN 和密码信息发送给服务器，而不会添加任何额外的安全措施。例如，密码并没有特别加密。
- en: If the client is communicating over TLS/SSL, then the whole transaction will
    be encrypted, and so the password will be safe. If the client is not using TLS/SSL
    then the password will be sent over the network in cleartext. This, of course,
    is a security issue, and should be avoided (perhaps by using the `security` directive
    discussed in the previous section, or by using an SASL bind instead of a simple
    bind).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways in which client applications attempt to perform a
    simple bind. The first is sometimes called **Fast Bind**. In a Fast Bind, the
    client supplies a full DN (`uid=matt,ou=users,dc=example,dc=com`) and also a password
    (`myPassword`). It is faster than the common alternative (binding as anonymous
    and searching for the desired DN).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Cyrus SASLAuthd**, which provides SASL authentication services to other applications,
    is the application in which the term "Fast Bind" was first used. SASLAuthd is
    a useful tool for providing SASL authentication services. We will look at it again
    in the next section. Nowhere in the OpenLDAP documentation, is the term "Fast
    Bind" used.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The directory first performs, as the anonymous user, an **auth** access on the
    `userPassword` attribute of the DN that the client supplies. In an auth access
    the server compares the value of the supplied password to the value of the `userPassword`
    stored in the directory. If the `userPassword` value is hashed (with, for example,
    SSHA or SMD5), then SLAPD hashes the password that the user supplies, and then
    compares the hashes. If the values match, OpenLDAP binds the user and allows it
    to perform other LDAP operations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OpenLDAP command-line clients, when used with the `-x` option, perform simple
    binding. The clients require that you specify the entire user DN and a password,
    and they then perform a Fast Bind.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: That's a Fast Bind. But there is a second common method of doing a simple bind—a
    method designed to eliminate the requirement that the user know an entire DN.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In this second method (which is not, incidentally, called a "slow bind"), the
    client application requires that the user only know some particular unique identifier—usually
    the value of `uid` or `cn`. The client application then binds to the server as
    anonymous (or another pre-configured user) and performs a search for a DN that
    contains the matching attribute value. If it finds one (and only one) matching
    DN, then it re-binds, using the retrieved DN and the user-supplied password.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, client applications that use simple bind will need a base DN. The
    second method of performing a simple bind requires one additional piece of information
    not required in a Fast Bind: a search filter. The filter is usually something
    like `(&(uid=?)(objectclass=inetOrgPerson))`, where the question mark (`?`) is
    replaced by the user-supplied value.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Using an Authentication User for Simple Binding
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While it is more convenient for the user when only a user ID or a CN is required,
    the second method we have seen may raise an additional concern: the Anonymous
    user, in order to perform the search, must have *read* access to all user records
    in the directory. This means that anyone can connect to the directory (remember,
    Anonymous has no password) and perform searches.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In many cases this isn't a problem. Allowing someone to see a list of all the
    users in the directory may not be a security concern at all. But in other cases,
    such access would not be acceptable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to work around this problem is to use a different user (rather than
    Anonymous) to perform the search for the user''s DN. In the last chapter, we created
    just such an account. Here is the LDIF record we used:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The purpose of this account is to log into the server and perform searches for
    DNs. In other words, it conducts the same job as the Anonymous user, but it adds
    a little more security, since clients that use the `uid=authenticate` account
    will have to have the appropriate password, too.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: To make this clear let's look at the case where a client, configured to use
    the Authenticate account, binds a user that identifies himself as `matt` with
    the password `myPassword`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a step-by-step breakdown of what happens when doing a bind operation
    this way:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Client connects to the server and starts a bind operation with the DN `uid=autenticate,ou=system,dc=example,dc=com`
    and the password `secret`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server, as Anonymous, compares the Authenticate password, `secret`, with
    the value of the `userPassword` attribute for the `uid=autenticate,ou=system,dc=example,dc=com`
    record.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the above succeeds, then the client (now logged in as the Authenticate user)
    performs a search with the filter: `(&(uid=matt)(objectclass=inetOrgPerson))`.
    Since `uid` is unique, the search should return either 0 or 1 record.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If one matching DN is found (in our case, it would be `uid=matt,ou=user,dc=example,dc=com`),
    then the client tries to re-bind as this DN, and using the password the user initially
    supplies to the client (`myPassword`).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server, as Anonymous, compares the user-supplied password, `myPassword`,
    with the value of the `userPassword` attribute of `uid=matt,ou=user,dc=example,dc=com`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the password comparison succeeds then the client application can continue
    performing LDAP operations as `uid=matt,ou=user,dc=example,dc=com`.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process is lengthy and it requires that the client application be configured
    with bind DN and password information for the Authenticate user, but it adds an
    additional layer of security to an Anonymous bind and search.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at three different ways of performing a simple
    bind. Each of these methods is useful in particular circumstances, and when used
    in conjunction with SSL/TLS, simple binding does not pose a significant security
    threat when the password is transmitted across the network.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simple Binding Directives in slapd.conf**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: There are only a few directives in `slapd.conf` that have any bearing on simple
    binding. Simple binding is allowed by default. To prevent SLAPD from accepting
    simple bind operations, you can use the `require SASL` directive which will require
    that all bind operations are SASL bind operations. Additionally, the `security`
    directive provides the `simple_bind=` SSF check, which can be used to require
    a minimum SSF for simple bind operations. This is covered in more detail in the
    section entitled *The* *security* *Directive*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book we will examine several third party applications that use
    simple binding when connecting to the directory.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: But there are times when it is desirable to have an even more secure authentication
    process, or when the bind-search-rebind method of simple binding is too much for
    the client to do. In such cases using SASL binding may be even better.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: SASL Binding
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SASL provides a second method of authenticating to the OpenLDAP directory. SASL
    works by supplanting the simple bind method outlined above with a more robust
    authentication process.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SASL standard is defined in RFC 2222 ( [http://www.rfc-editor.org/rfc/rfc2222.txt](http://www.rfc-editor.org/rfc/rfc2222.txt)).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: SASL supports a number of different kinds of underlying authentication mechanisms,
    ranging from login/password combinations to more complex configurations like **One-Time
    Passwords (OTP)** and even **Kerberos** ticket-based authentication.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: While SASL provides dozens of different configuration options, we will cover
    only one. We will configure SASL for doing **DIGEST-MD5** authentication. It is
    slightly more difficult to set up than some SASL mechanisms, but does not require
    the detailed configuration involved in **GSSAPI** or Kerberos.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will integrate our SASL work with our SSL/TLS work,
    and use the **SASL EXTERNAL mechanism** for authenticating to the directory with
    client SSL certificates.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Cyrus SASL documentation (at `/usr/share/doc/libsasl2` or available online
    at [http://asg.web.cmu.edu/sasl/](http://asg.web.cmu.edu/sasl/)) provides information
    on implementing other mechanisms.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: In DIGEST-MD5 authentication, the user's password will be encrypted by the SASL
    client, sent across the network in its encrypted form only, then decrypted by
    the server and compared to a cleartext version of the password.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The advantage to using DIGEST-MD5 is that the password is protected when transmitted
    over the network. The disadvantage, however, is that the passwords must be stored
    on the server in cleartext.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with the way simple bind works. In a simple bind the password
    itself is not encrypted when crossing the network, but the copy of the password
    stored in the database is stored in an encrypted format (unless you configure
    OpenLDAP otherwise).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when SSL/TLS is used, all data transmitted over the connection
    is encrypted, including passwords.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring SASL is more complex than configuring simple bind operations. There
    are two parts to configuring SASL support:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Configuration of Cyrus SASL
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration of OpenLDAP
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Cyrus SASL
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we installed OpenLDAP in Chapter 2, one of the packages we installed was
    Cyrus SASL (the library was named `libsasl2`). We will also need the SASL command-line
    tools, which are included in the `sasl2-bin` package:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Included in this package are the `saslpasswd2` program and the SASL testing
    client and server applications.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to start configuring.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The SASL Configuration File
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The SASL library can be used by numerous applications, and each application
    can have its own SASL configuration file. SASL configuration files are stored
    in the `/usr/lib/sasl2` directory. In that directory, we will create a configuration
    file for OpenLDAP. The file, `slapd.conf`, looks like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse this `slapd.conf`, located at `/usr/lib/sasl2` with the main
    `slapd.conf` file at `/etc/ldap/`. These are two different files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: As usual, lines that begin with the `pound sign (#)` are comments. The second
    line determines how SASL will try to check passwords. For example, SASL comes
    with a stand-alone server, **saslauthd**, which will handle password checking.
    In our case though, we want to use the `auxprop` plugin, which does the password
    checking itself, rather than querying the `saslauthd` server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The last line tells SASL where the password database (which stores a cleartext
    version of all of the passwords) is located. The standard location for this database
    is `/etc/sasldb2`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Setting a User Password
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As we get started, we will store the SASL password in the `/etc/sasldb2` database.
    To add a password to the database we use the `saslpasswd2` program:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we have to run the above using `sudo` because the password file is
    owned by root. Both `sudo` and `saslpasswd2` will prompt you to enter a password.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-c` argument for `saslpasswd2` indicates that we want the user ID to be
    created if it does not already exist. `-u example.com` sets the **SASL realm**.
    SASL uses realms as a way to partition the authentication name space. Client applications
    typically provide SASL with three pieces of information: the username, the password,
    and the realm. By default, clients will send their domain name as the realm.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Using realms, it is possible to give the same user name different passwords
    for different applications or application contexts. For example, `matt` in realm
    `example.com` can have one password, while `matt` in realm `testing.example.com`
    can have a different password.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes we need only one realm, and we will name it `example.com`.
    When the given command is run it will prompt for a password for user `matt`, and
    then prompt for a password confirmation. If the passwords match, it will store
    the password in clear text in the SASL password database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to configure OpenLDAP.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SLAPD for SASL Support
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The OpenLDAP side of SASL configuration is done in the `slapd.conf` file for
    the server, and the `ldap.conf` file for the client. In this section, we will
    focus on the SLAPD server.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'When OpenLDAP receives a SASL authentication request it receives four pieces
    of information from the client. The four fields of information it gets are:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: This field contains the ID that the user supplied when authenticating.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Realm: This field contains the SASL realm in which the user is authenticated.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SASL Mechanism: This field indicates which authentication system (mechanism)
    was used. Given our SASL configuration, this should be DIGEST-MD5.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication Information: This field is always set to `auth` to indicate
    that the user needs authentication.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of this information is compacted into one DN-like string that looks like
    this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The order of the fields above is the same as the order of the bulleted list:
    User-name, realm, SASL mechanism, and authentication information. Note however,
    that the realm is not required and might not always be present. If SASL does not
    use any realm information, the realm field will be omitted.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we do not have any records in our LDAP with DNs like the SASL string
    above. So, in order to correlate the authenticated SASL user with a user in the
    LDAP, we need to set up some method of converting the above DN-like string into
    a DN that is structured like the DNs in the directory. So we want to make the
    given string into something like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There are two ways of doing this mapping. We can either configure a simple string
    replacement rule to convert the SASL information string to a DN like the last
    one, or we could perform a search of the directory for an entry with a `uid` that
    is `matt`, and then, if a match is found, use that matching entry's DN.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Each of these two methods has its advantages and disadvantages. Using string
    replacement is faster, but it is less flexible, and it may not be sufficient for
    complex directory information trees. Using string replacement it may be necessary
    to use several `authz-regexp` directives in a row, each one with a different regular
    expression and replacement string.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Searching for the user on the other hand, can be much more flexible in a directory
    with lots of subtrees. But it will incur the overhead of doing an additional search
    of the LDAP tree, and it may require tweaking ACLs to allow pre-authentication
    searches.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods use the same directive in `slapd.conf`: the `authz-regexp` directive.
    Let''s look at an example of each method, beginning with the string replacement
    method.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Using a Replacement String in authz-regexp
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `authz-regexp` directive takes two parameters: a regular expression for
    getting information out of the SASL DN-like string, and a replacement function
    (which is different depending on whether we do string replacement or a search).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: 'For our regular expression we want to take the username from the SASL information
    and map it to the `uid` field in a DN. We don''t really need any of the information
    in the other three SASL fields, so our regular expression is fairly simple:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This rule starts at the beginning of the line (`^`) and looks for an entry that
    starts with `uid=`. The next part, `([^,]+)`, stores characters after `uid=` and
    before a comma (`,`) in a special variable called `$1`. The rule reads "match
    as many characters as possible (but at least one character) that are not commas
    and store them in the first variable (`$1`)."
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, the rule (using `.*` to match anything) skips over the realm (if
    there is one) and the mechanism, and then looks for a match at the end of the
    line: `cn=auth$` (where the dollar sign (`$`) indicates a line ending).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the regular expression is run we should have a variable, `$1`, which contains
    the user''s name. Now we can use that value in a replacement rule, setting the
    `uid` value to the value of `$1`. The entire `authz-regexp` line looks like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After the `authz-regexp` directive, I have inserted the regular expression we
    just looked at. After the regular expression comes the replacement rule, which
    instructs SLAPD to insert the value of `$1` in the `uid` field of this template
    DN.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The `authz-regexp` directive can go anywhere in the `slapd.conf` file before
    the first `database` directive.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `authz-regexp` is the only necessary directive for configuring SASL,
    we can now test SLAPD from the command line, without making any additional changes
    to `slapd.conf`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Previously, we have used the `-x` flag, combined with `-W` and `-D`, to do a
    simple bind with a full DN and a password.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: With SASL however, we don't need the full DN. All we need is a shortened connection
    string. So, instead of using the `-x`, `-W`, and `-D` flags, we just use `-U matt@example.com`.
    The `-U` flag takes a SASL username and (optionally) a realm. The realm is appended
    to the username, separated by the *at* sign (`@`). So, in the given example, we
    are connecting with username `matt` and realm `example.com`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Next, `ldapsearch` prompts for a password (see the highlighted line in the example).
    This is not our LDAP password, but our SASL password—the one in the account we
    created when we ran `saslpasswd2`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'To review, what is happening in the previous command is this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The client is connecting to SLAPD requesting an SASL bind.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLAPD uses the SASL subsystem (which checks the `/usr/lib/sasl/slapd.conf` file
    for settings) to tell the client how to authenticate. In this case, it tells the
    client to use DIGEST-MD5.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends the authentication information to SLAPD.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLAPD performs the translation specified in `authz-regexp`.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLAPD then checks the client's response (using the SASL subsystem) against the
    information in `/etc/sasldb2`.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the client authentication succeeds, OpenLDAP runs the search and returns
    the results to the client.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are ready to look at using `authz-regexp` to search the directory with
    a specific filter.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Using a Search Filter in authz-regexp
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this case, we want to search the directory for an entry that matches the
    username (`uid`) received during the SASL bind. Recall that the SASL authentication
    information comes in a string that looks like this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the last case, we mapped the given directly on to a DN of the form:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But what do we do if we don't know, for example, if the user `matt` is in the
    Users OU or the System OU? A simple mapping function will not work. We need to
    search the directory. We will do this by changing the last argument in our `authz-regexp`
    directive.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new `authz-regexp` directive looks like this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This regular expression is the same as the one in the previous example. But
    the second argument to `authz-regexp` is an LDAP URL.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an overview of writing and using LDAP URLs see [Appendix B](apb.html "Appendix B. LDAP
    URLs").
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'This LDAP URL instructs SLAPD to search in the base `dc=example,dc=com` (using
    a subtree (`sub`) search) for an entry whose `uid` equals the value of `$1`, which
    gets replaced by the value retrieved from the regular expression in the first
    argument to `authz-regexp`. If the user `matt` attempts to authenticate, for example,
    the URL will look like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When SLAPD performs that search against our directory information tree, it will
    get a single record back—the record with the DN `uid=matt,ou=Users,dc=example,dc=com`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example using `ldapsearch`. It is the same example used in the previous
    section, and it should have the same results even though we are using the LDAP
    search method:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A Note on ACLs and Search Filters
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When SLAPD reads the search filter, it performs a search of the directory. But
    the search is done as the Anonymous user. What this means is that we will need
    to make sure that the Anonymous user will need to have the requisite permissions
    to search the directory using the filter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our last example, the Anonymous user will need to be able to search the
    `dc=example,dc=com` subtree for `uid` values. The ACLs that we created in Chapter
    2 do not grant the Anonymous user any such permission. We will need to add one
    rule to our ACLs in order to allow the search to operate successfully:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This rule, which should appear at the top of the list of ACLs, grants read access
    to the `uid` attribute to `anonymous` and to any authenticated users on the system.
    The important part, in this example, is that Anonymous gets read access.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that by adding this rule, we are making it possible for unauthenticated
    users to see what user IDs exist in the database. Depending on the nature of your
    directory data, this may be a security issue. If this is a problem you can either
    use the string replacement method (remember, you can use several `authz-regexp`
    expressions in a row to handle more complex pattern matching), or you can try
    to reduce exposure to the `uid` field by building more restrictive ACLs
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will take a more detailed look at ACLs.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Failure of Mapping
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases the mapping done by `authz-regexp` will fail. That is, SLAPD will
    search the directory (using the search filter) and not find any matches. The user,
    however, is authenticated, and SLAPD will not fail to bind.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, what will happen is that the user will bind as the SASL DN. Thus,
    the effective DN may be something like:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It makes no difference that there is no actual record in the directory with
    that username. The client will still be able to access the directory.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: But this DN is also subject to ACLs, so you can write access controls targeted
    at users who have authenticated through SASL but who do not have a DN corresponding
    to a record in the directory.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Removing the Need to Specify the Realm
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In our configuration all of the users are in the same realm, `example.com`.
    Rather than typing that the username and the realm be typed in every time, we
    can configure a default realm in `slapd.conf` by adding the following directive:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we restart the server with this new modification, we can now run an `ldapsearch`
    without having to specify the realm:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This time, passing `-U matt` was sufficient for authentication. SLAPD automatically
    inserted the default realm into the SASL information.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the SASL Configuration
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Getting the correct SASL configuration can be frustrating. One way of improving
    your ability to debug is to configure logging in such a way that you can see what
    is going on during a SASL transaction. The `trace` debugging level (`1`) can be
    used to watch what is happening in SASL. You can either set the debug level in
    `slapd.conf` to trace (or just the digit `1`), or you can run `slapd` in the foreground
    on the command line:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Following this log, we can see the initial SASL string, `uid=matt,cn=DIGEST-MD5,cn=auth`,
    and watch as it is normalized, run through the regular expression, and converted
    to `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The `ldapwhoami` client and the `slapauth` utility are also useful when attempting
    to debug SASL. An example of using `ldapwhoami` to evaluate the results of `authz-regexp`
    is given in the next section.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Using Client SSL/TLS Certificates to Authenticate
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SASL and SSL/TLS can be used in combination to perform **SASL EXTERNAL authentication**.
    In SASL EXTERNAL authentication the SASL module relies upon an external source,
    in this case a client's X.509 certificate, as a source of identity.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Using this configuration a client with an appropriately signed certificate can
    bind to SLAPD without having to enter a username and password, but in a way that
    is still secure.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: How does this work? Just as it is possible to issue a server a certificate for
    SSL/TLS communication, it is also possible to issue one to a user or client. We
    have discussed already how a certificate provides, in a secure way, identity information
    about a server. A client certificate can serve the same purpose.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Authentication, using SASL EXTERNAL works like this:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The client and server communicate with SSL/TLS protection, either using LDAPS
    or using StartTLS
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the server sends its certificate, it requests that the client also provide
    a certificate
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client sends its own certificate, which includes the following
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity information
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A public key
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of a certificate authority that the server will recognize
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The server, after verifying the certificate, passes the identity information
    on to SLAPD through the SASL subsystem
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLAPD then uses that information to bind
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the certificate sent by the client contains all of the information needed
    to verify the client's identity, no login/password combination is needed.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring the SASL EXTERNAL mechanism requires the following steps:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Create a new client certificate
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the client to send the certificate
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure SLAPD to correctly handle client certificates
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure SLAPD to correctly translate the identity information provided in
    the client certificate
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a New Client Certificate
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a new client certificate is not significantly different from creating
    a server certificate. We will use the same certificate authority that we created
    earlier in this chapter.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new certificate request:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This process is just like the one before, though the fields are completed specifically
    for the user who is represented by this certificate. For example, if we were generating
    this certificate for Barbara, we would complete the **Common Name** and **Email
    Address** fields with her information.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What should go in the Common Name field?**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Earlier we used the CN field to store a domain name. What should go in an individual's
    CN field? One option is to use the user's full name. A more pragmatic option is
    to use an identifier that is used in the user's LDAP DN (such as the value of
    the user's `uid` attribute). This makes mapping from a certificate to an LDAP
    record easier.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the new request (`newreq.pem`) and key (`newkey.pem`). The next
    thing to do is sign the certificate with our CA''s digital signature:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, we have the signed certificate stored in the file `newcert.pem`.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to do is to move these files to a location that will be convenient
    for the user. In this case, we will make a new directory in the user''s home directory
    and move the files into that directory:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In these three lines, we make a new directory for the certs. In this case, the
    new `certs/` directory is in the user's home directory.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Then we move the newly-created certificate files into the new directory. We
    could rename these files but for now the generic name will suffice.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to make sure that the user has access to his or her certificates.
    This is done with the `chown` command.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The certificates are ready to use.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Client
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we need to do is configure the client to use the certificate
    and key. This is done by creating `.ldaprc` file in the user's home directory.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **.ldaprc file** is a "personal" version of an `ldap.conf` file. It supports
    all of the directives normally included in `ldap.conf`, plus a couple of special
    directives, like the `TLS_CERT` and `TLS_KEY` directives.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Since I am the user `mbutcher`, I will create this file in my own home directory:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now we can edit the `.ldaprc` file. This file needs to indicate that the client
    is using the SASL EXTERNAL mechanism. Also, it must contain directives about the
    certificate and key files that we want to use. Additionally, it is not a bad idea
    to specify the location of the CA certificates (or even to the specific certificate
    for the CA that signed the server's certificate), though this is usually done
    at a global level with the `ldap.conf` file.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.ldaprc` file then, looks like this:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first directive, `SASL_MECH`, indicates what SASL mechanism the client is
    using. In our case the client is using the `EXTERNAL` SASL mechanism.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: The `TLS_CERT` directive points to the location of the client's signed X.509
    certificate, and the `TLS_KEY` directive indicates the location of the client's
    private key file.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: The `TLS_CACERT` directive points to the specific certificate used for signing
    the server's certificate. This will be used by the client libraries to verify
    the identity of the server during SSL/TLS negotiation.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: At this point the client is ready. Now we need to configure SLAPD.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Server
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SLAPD needs to do a few things in order to make the SASL EXTERNAL mechanism
    work:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: It must request a certificate from the client (otherwise the client will not
    present one)
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to translate the identity information given in the client certificate
    into a DN that is meaningful in our environment
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set the server to request a client certificate is a matter of adding one
    directive. In the global section of the `slapd.conf` file, before any database
    directive is specified, the `TLSVerifyClient` directive should be added:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Only the highlighted line is new. The other lines we added earlier in the chapter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '`TLSVerifyClient` determines whether SLAPD will take steps to request and verify
    client certificates. There are four possible values:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '`never`: Never request a client certificate. This is the *default*. If no certificate
    is requested the client will not provide one. Hence SASL EXTERNAL authentication
    cannot be used when the `TLSVerifyClient` is set to `never`.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allow`: This will cause SLAPD to request a certificate from the client but
    if the client does not provide one, or if the provided one is not good (for example
    if the signature cannot be verified), the session will continue.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`: In this case SLAPD will request a certificate from the client. If the
    client does not provide a certificate the session will continue. However, if the
    client provides a certificate that is bad, the session will terminate.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`demand`: This will cause SLAPD to require a certificate from the client. If
    the client does not provide one, or if the provided one is not good, the session
    will terminate.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last example we set `TLSVerifyClient` to `try`. This simply means that
    if the client submits a certificate, it must be a valid certificate (with a known
    CA signature) before SLAPD will allow the connection. But it will also allow clients
    to connect without supplying a certificate (though such clients will not be able
    to use SASL EXTERNAL authentication).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: If we wanted to force clients to provide a certificate then we would use the
    `demand` keyword instead of `try`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have SSL/TLS configured correctly. Now, we need to add one
    additional step: we need to map the identity provided by the certificate (which
    happens to be a DN) onto a DN for a directory user.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Translating the certificate DN into another DN is not strictly necessary. A
    user can bind using a certificate DN even if it is not in the directory. ACLs
    can be written to target such DNs too.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'The DN in the client certificate we create looks like this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that this is one long line.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'The DN contains the information we entered when running `CA.pl -newreq`. What
    we want to do is translate this DN into the DN of the corresponding LDAP record:
    `uid=matt,ou=users,dc=example,dc=com`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: How is this translation done? Using the `authz-regexp` directive that we examined
    earlier in the section on SASL authentication.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two fields in the certificate''s identity string that are particularly
    helpful in identifying the user: `email` and `cn`. Thus, a simple regular expression
    can capture these two fields:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This will assign the email address to `$1`, and the CN to `$2`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: From here we could either specify an LDAP URL with a filter for looking up DNs
    by email address, or we could substitute the CN for the UID field used in the
    LDAP DN (since the CN maps cleanly onto UID).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this second method, and create `authz-regexp` that looks like this:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This directive maps the CN value of the certificate DN to the UID attribute
    in the LDAP authorization DN. Thus, when a client connects with a certificate
    with the DN `dn:email=matt@example.com,cn=matt,o=example.com,l=chicago,st=illinois,c=us`,
    SLAPD will translate that into the DN `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to test things out.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Testing with ldapwhoami
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ideal client for testing this process is `ldapwhoami`. This will allow us
    to connect and bind with SASL EXTERNAL. In addition it will indicate whether or
    not `authz-regexp` mapped the certificate DN to our LDAP DN.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'After restarting SLAPD to load the changes, we can test the server:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, let''s take a closer look at the command entered:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `-ZZ` flag requires that StartTLS negotiation be done successfully. Using
    only one `Z` will attempt StartTLS, but not close the connect if the negotiations
    fail. Using `-ZZ` is always a good idea when attempting authentication with the
    SASL EXTERNAL mechanism.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `-H 'ldap://example.com'` parameter provides the URL of the SLAPD
    server. Remember that for StartTLS negotiation to work, here, the domain in the
    LDAP URL must match the domain in the server's certificate.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when this command is executed? First, the user is prompted for
    a pass phrase:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This prompt is actually generated by the SSL/TLS subsystem (OpenSSL). Recall
    that the key that we generated is protected by a pass phrase. In order to read
    the key file, the OpenSSL subsystem requires the pass phrase.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'But didn''t I say that the SASL EXTERNAL method can obviate the need for entering
    a password? Yes, it can—but to do so, we would need to remove the passphrase from
    the key as we did when generating the server certificate:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then the `TLS_KEY` directive in `.ldaprc` would need to be adjusted to point
    to the `clearkey.pem` file.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Removing the pass phrase may be desirable in some circumstances, and undesirable
    in others. Keep in mind that removing the pass phrase from the key will make it
    easier for the certificate to be hijacked by someone else. A key without a pass
    phrase should be carefully protected by permissions and other means.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the user''s pass phrase has been entered, SASL authentication begins:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As can be seen here, the SASL EXTERNAL mechanism is used, and the SASL username
    is set to `emailAddress=matt@example.com,CN=Matt,O=Example.Com,L=Chicago,ST=Illinois,C=US`.
    Finally, the SASL security strength factor is set to 0 because no SASL security
    mechanism has been used. Instead, the security mechanisms are *external* to SASL.
    Since we are using SSL/TLS with an AES-256 encyrpted certificate, the overall
    SSF will still be 256.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'One important detail to note is that SLAPD will normalize the DN. In normalized
    form the DN will look like this:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `emailAddress` attribute has been converted to `email`, and all uppercase
    strings have been converted to lowercase. The `authz-regexp` that we looked at
    above operates on this normalized version of the DN.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the last few lines of output are the results of the LDAP Who Am I?
    operation:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: According to SLAPD, the client is currently performing directory operations
    with an effective DN of `uid=matt,ou=users,dc=example,dc=com`. This means that
    our mapping was successful.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'What would the output look like if the `authz-regexp` mapping was not successful?
    It would look something like this:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The highlighted portion shows the result of the Who Am I? operation. The DN
    returned is simply the normalized form of the certificate DN—not the desired LDAP
    DN.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Going Further with SASL
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SASL is a flexible tool for handling authentication. Here we have looked at
    only two SASL mechanisms: DIGEST-MD5 and EXTERNAL. But there are many other possibilities.
    It can be used in conjunction with robust network authentication systems like
    Kerberos. It can take advantage of secure One Time Password systems, like Opiekeys.
    And it can be used as an interface to more standard password storage systems,
    like PAM (Pluggable Authentication Modules).'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: While such configurations are outside of the scope of this book, there are many
    resources available. The SASL documentation (installed locally on Ubuntu in `/usr/local/doc/libsasl/index.html`),
    and the OpenLDAP Administrator's Guide ([http://openldap.org](http://openldap.org)),
    both provide more information about different SASL configurations.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Now we will move on from authentication to authorization, and turn our attention
    to ACLs.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Authorization with ACLs
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve looked at connection security and authentication. Now we are ready to
    look at the last aspect of security: authorization. What we are specifically interested
    in is controlling access to information in our directory tree. Who should be able
    to access a record? Under what conditions? And how much of that record should
    they be able to see? These are the sorts of questions that we will address in
    this section.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of ACLs
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary way that OpenLDAP controls access to directory data is through Access
    Control Lists (ACLs). When the SLAPD server processes a request from a client,
    it evaluates whether the client has permissions to access the information it has
    requested. To do this evaluation SLAPD sequentially evaluates each of the ACLs
    in the configuration files, applying the appropriate rules to the incoming request.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously in this chapter, we have looked at *authentication* using simple
    and SASL binding. ACLs provide *authorization* services, which determine what
    information a given DN has access to.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: ACLs were introduced in Chapter 2 in the section entitled *ACLs*. This section
    will develop the basic examples discussed there.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: An ACL is just a fancy configuration directive (the `access` directive) for
    SLAPD. Like certain other directives, the `access` directive can be used multiple
    times. There are two different places in the SLAPD configuration where ACLs can
    be placed. Firstly, they can be placed in the global configuration outside of
    a database section (that is, near the top of the configuration file). Rules that
    are placed at this level will apply globally to all backends. In the next chapter
    we will look at the case where a single directory has multiple backends.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, ACLs may be placed within a backend section (somewhere beneath a `database`
    directive). In this case, the ACLs will only be used when handling requests for
    information within database. In Chapter 2, we put our ACLs within the backend
    section, and we did not create any global `access` directives.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: How does all of this work out in practice? When are global rules used, and when
    are backend-specific rules used? If a backend has no specific ACLs, then the global
    rules will apply. If a backend does have ACLs, then the global rules will only
    be applied if none of the backend-specific rules apply. If the request is for
    a record which is not stored in any backend, such as the Root DSE or the `cn=subschema`
    entry, then only the global rules will be applied.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Within their context ACLs are evaluated top-down, from the first directive in
    the configuration file to the last. So, when backend-specific rules are tested,
    SLAPD begins testing with the first rule on the list and continues sequentially
    until either a stopping rule matches or SLAPD reaches the end of the list.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2 we put the ACLs directly in the `slapd.conf` configuration file.
    In this section we will put them in their own file and use the `include` directive
    in `slapd.conf` to direct SLAPD to load the ACL file. This will allow us to separate
    the potentially lengthy ACLs from the rest of the configuration file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the format of an ACL, and then we will move on to
    some examples which will help clarify the intricacies of the ACL method.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'An access directive looks like this:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '`access to` [*resources*]'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '`by` [*who*] [*type* *of* *access* *granted*] [*control*]'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '`by` [*who*] [*type* *of* *access* *granted*] [*control*]'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: An `access` directive can have one `to` phrase, and any number of `by` phrases.
    We will take a look at the `access to` phrase first, then the `by` phrase.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Access to [resources]
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `access to` part, an ACL specifies what is to be restricted in the directory
    tree by this rule. In the given rule we used `[resources]` as a placeholder for
    this section. An ACL can restrict by DN, by attribute, by filter, or by a combination
    of these. We will first look at restricting by DN.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Access using DN
  id: totrans-548
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To restrict access to a particular DN, we would use something like this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `by * none` phrase simply rejects access to anyone. We will cover this and
    other rules when we discuss the `by` phrase later in this chapter.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: The rule would restrict access to that specific DN. Any time a request is received
    that needs access to the DN `uid=matt,ou=Users,dc=example,dc=com`, SLAPD would
    evaluate this rule to determine whether that request is authorized to access this
    record.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to a specific DN can be useful at times, but there are several
    other supported options to the DN access specifier that come in useful for more
    general rule-making.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to restrict access to subtrees of a DN, or even by DN patterns.
    For example, if we wanted to write a rule that restricted access to entries beneath
    the Users OU, we could use an `access` clause like this:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this example the rule restricts access to the OU and any records subordinate
    to it. This is accomplished by using `dn.subtree` (or the synonym `dn.sub`). In
    our directory information tree there are a number of user records in the Users
    OU subtree. These records are children of the Users OU. The DN `uid=matt,ou=Users,dc=example,dc=com`,
    for example, is in the subtree, and an attempt to access the record would trigger
    this rule.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with `dn.subtree`, there are three other keywords for adding structural
    restrictions to the DN access specifier:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '`dn.base`: Restrict access to this particular DN. This is the default, and
    `dn.exact` and `dn.baselevel` are synonyms of `dn.base`.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dn.one`: Restrict access to any entries immediately below this DN. `dn.onelevel`
    is a synonym.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dn.children`: Restrict access to the children (subordinate) entries of this
    DN. This is similar to subtree, except that the given DN itself is not restricted
    by the rule.'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `dn` clause accepts one other modifier that can be used to do sophisticated
    pattern matching: `dn.regex`. The `dn.regex` access specifier can process POSIX
    extended regular expressions. Here is an example of a simple regular expression
    in `dn.regex`:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This example would restrict access to any DN with the pattern `uid=SOMETHING,ou=Users,dc=example,dc=com`,
    where `SOMETHING` can be any string that is at least one character long and has
    no commas (`,`) in it. Regular expressions are a powerful tool for writing ACLs.
    We will discuss them more in the section *Getting* *More* *from* *Regular* *Expressions*
    after we look at the `by` phrase.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Access using attrs
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to restricting access to records by DN, we can also restrict access
    to one or more attributes within records. This is done using the `attrs` access
    specifier.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples we''ve seen, when we restricted access we were restricting
    access at a record level. The `attrs` restriction works at a finer-grained level:
    it restricts access to particular attributes within records.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a case where we want to limit access to the `homePhone`
    attribute of all records in our directory information tree. This can be done with
    the following access phrase:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `attrs` specifier takes a list of one or more attributes. In the given
    example, we just restricted access to the `homePhone` attribute. If we wanted
    to block access to `homePostalAddress` as well, we could modify the `attrs` list
    accordingly:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s say that we wanted to restrict access to all of the attributes in the
    `organizationalPerson` object class. One way of doing this would be to create
    one long list: `attrs`=`title`, `x121Address`, `registeredAddress`, `destinationIndicator`,....
    But such a method would be time-consuming, difficult to read, and clumsy.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, there is a convenient shorthand notation for this:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This notation should be used carefully, however. This code does not just restrict
    access to the attributes explicitly defined in `organizationalPerson`, but also
    all of the attributes already defined in the `person` object class. Why? Because
    the `organizationalPerson` object class is a subclass of `person`. Therefore,
    all of the attributes of `person` are attributes of `organizationalPerson`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it useful to restrict access to all attributes *not* required or
    allowed by a particular object class. For example, consider the case where the
    only attributes we want to restrict are those that are not specified in the `organizationalPerson`
    object class. We can do that by replacing the *at* sign (`@`) with an exclamation
    point (`!`):'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This will restrict access to any attributes unless they are allowed or required
    by the `organizationalPerson` object class.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two special names that can be specified in the attributes list but
    that do not actually match an attribute. These two names are `entry` and `children`.
    So we have two cases:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: If `attrs=entry` is specified, then the record itself is restricted.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `attrs=children`, then the records that are children of this record are restricted.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two key words are not particularly useful in cases where only an `attrs`
    specifier is used, but they can be much more useful when `attrs` and `dn` specifiers
    are used in conjunction.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is useful to restrict by the value of an attribute (rather than
    by an attribute name). For example, we may want to restrict access to any `givenName`
    attribute that has the value `Matt`. This sort of thing can be accomplished using
    the `val` (value) specifier:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Like the `dn` specifier, the `val` specifier has `regex`, `subtree`, `base`,
    `one`, `exact`, and `children` styles.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `val` specifier you can have no more than one attribute in the
    `attrs` list. The `val` specifier will not work on object class lists either.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'With `val.regex` you can use regular expressions for matching. We can modify
    the last example to restrict access to any `givenName` that starts with the letter
    `M`:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In cases where the attribute value is a DN (like the `member` attribute for
    a `groupOfNames` object), the `regex`, `subtree`, `base`, `one`, and `children`
    styles can be used to restrict access based on the DN in the attribute value.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Tip
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Specifying an Alternate Matching Rule**'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `val` comparison uses the equality matching rule. You can select
    a different matching rule however, by inserting a slash (`/`) after `val`, and
    then entering the name or OID of the matching rule:`access to attrs=givenName
    val/caseIgnoreMatch="matt"`.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Access using Filters
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the lesser used but surprisingly powerful features of the `access` phrase
    is support for LDAP search filters as a means of restricting access to records.
    We looked at the LDAP filter syntax at the beginning of Chapter 3 when we discussed
    the search operation. Here we will use filters to restrict access to parts of
    a record.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'Filters provide a way to support value matching for entire records (instead
    of just attribute values, as is done with `attrs`). For example, using filters
    we can restrict access to all records that contain the object class `simpleSecurityObject`:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will restrict access to any record in the directory information tree that
    has the object class `simpleSecurityObject`. Any legal LDAP filter can be used
    in a filter specifier. For example, we could restrict access to all records that
    have the given name Matt, the given name Barbara, or the surname Kant:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This code uses the "or" (disjunction) operator to indicate that if the request
    needs access to records that have given names with the values of Matt or Barbara,
    or if the request needs access to a record with the surname Kant, this rule should
    be applied.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Combining Access Specifiers
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have looked at three different access specifiers: `dn`, `attrs`, and `filter`.
    And in the previous sections we have used each. Now we will combine them to create
    even more specific access rules.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of combination is as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '`access to` [*dn*] [*filter*] [*attrs*] [*val*]'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dn` and `filter` specifiers come first, as they both deal with records
    as a whole. Then `attrs` (and `val`), which function at the attribute level, come
    next. Let''s say that we want to restrict access to records in the Users OU just
    in the cases where the record has an `employeeNumber` attribute. To do this we
    can use a combination of a DN specifier and a filter:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This ACL will only restrict access when the request is for records in the `ou=Users,dc=example,dc=com`
    subtree and the `employeeNumber` field exists and has some value.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion, we can limit access to attributes for records in a certain
    subtree. For example, consider the case where we want to restrict access to the
    `description` attribute, but only for records that are in the the System OU. We
    can do this by combining the DN and attribute specifiers:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: By this rule, a client could access the record with DN `uid=authenticate,ou=System,dc=example,dc=com`,
    but it would not be able to access the `description` attribute of that record.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: By carefully combining these access specifiers it is possible to articulate
    exact access restrictions. We will see some more in action as we continue on to
    the `by` phrase.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: By [who] [type of access granted] [control]
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `by` phrase contains three parts:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: The **who field** indicates what entities are allowed to access the resource
    identified in the access phrase
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **access field** (type of access granted) indicates what can be done with
    the resource
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third optional part, which is usually left off, is the **control field**
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get the gist of this distinction, consider the `by` phrase that we have
    been working with in the previous sections: `by * none`. In this `by` phrase,
    the `who` field is `*` (an asterisk character), and the access field is `none`.
    The control field is omitted in this example.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: The `*` is the universal wildcard. It matches any entity, including anonymous
    and all DNs. The `none` access type indicates that no permissions at all should
    be granted to the entity identified in the `who` specifier. In other words, `by
    * none` means that no access should be granted to anyone.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The directory manager (`cn=Manager,dc=example,dc=com`), specified in the `slapd.conf`
    file with the `rootdn` directive, is an exception. It cannot be restricted by
    any access control. Thus, `by * none` does not apply to the manager.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the `who` field in detail, but before getting to that, let's
    examine the access field.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: The Access Field
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are six distinct privileges that a client can have, in regards to an
    entry or attribute. There is also a seventh privilege specifier that equates to
    the removal of all privileges:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '`w`: Writes access to a record or attribute.'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`r`: Reads access to a record or attribute.'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`s`: Searches access to a record or attribute.'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`c`: Accesses to run a comparison operation on a record or attribute.'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`x`: Accesses to perform a server-side authentication operation on a record
    or attribute.'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`d`: Accesses to information about whether or not a record or attribute exists
    (''d'' stands for ''disclose'').'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0`: Does not allow access to the record or attribute. This is equivalent to
    `-wrscxd`.'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These seven privileges can be specified in a `by` clause. To set one or more
    of these access privileges, use the `=` (equals) sign.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to allow the server to compare a record''s `givenName` field to
    a `givenName` specified by a client, we could use the following ACL:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This will allow any client to attempt a compare operation. But that is the
    only operation it will allow. By this rule, no one can read from or write to this
    attribute. How does this work out in practice? When we use the `ldapsearch` client
    to attempt to read the value of the `givenName` attribute, we do not get any information
    about the `givenName`:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The only thing the server returns for our query is the DN of the record that
    matches the filter. No `givenName` attribute is returned.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we use the `ldapcompare` client, we can ask the server to tell
    us whether or not the DN has a `givenName` field with the value ''Matt'':'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `ldapcompare` client sends a DN and an attribute/value pair to the server,
    and asks the server to compare the supplied attribute value with the server's
    copy of the attribute value for the record with the given DN.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Here the `ldapcompare` client will request that the SLAPD server look up the
    record for `uid=matt,ou=Users,dc=example,dc=com` and check to see if the `givenName`
    attribute has the value 'Matt'. The server will answer `TRUE`, `FALSE`, or (if
    there is an error) `UNDEFINED`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the server responded `TRUE`. This indicates that the server performed
    the comparison, and the values matched. The combination of the `ldapsearch` and
    `ldapcompare` examples should illustrate how the ACL worked: while the server-side
    compare operation is permitted, the client does not have access to read the attribute
    value.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple access privileges can be granted in one `by` phrase. To modify in
    order to allow reading (`r`), comparing (`c`), and disclosing (`d`) on the `givenName`
    attribute, we can use the following ACL:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, both the `ldapsearch` and `ldapcompare` commands that we ran should succeed.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where permissions are inherited from other ACLs (we will look
    at some later). In such cases, we can selectively add or remove specific permissions
    by using `+` (plus sign) to add and `–` (minus sign) to remove.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we know that all the users already have compare (`c`) and disclose
    (`d`) on all the attributes, but we want to add *read* privileges just for the
    `givenName` attribute, we can use the following ACL:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An access control that grants compare and disclose, and then continues processing
    might look something like this: `access to attrs=givenName,sn by * =cd break`.
    This uses the `break` control to instruct SLAPD to continue processing ACLs. If
    this rule appeared in the SLAPD configuration above the rule `access to attrs=giveName
    by * +r`, then a request to the `givenName` attribute would have the effective
    permissions `=rcd`.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if we needed to remove the compare operation just for the `givenName`
    attribute, we could use a `by` clause like `by * -c`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'The `0` access privilege removes all privileges. It cannot be used with the
    `+` or `–` operators, it can only be used with the `=` operator. The following
    ACL removes all privileges for all users to the `givenName` attribute:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This is the same as the `by` clause: `by * -wrscdx`.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'These access controls are good for fine-grained control, but sometimes it is
    nice to have shortcuts. OpenLDAP has seven shortcuts that handle common configurations
    of access controls:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Privileges |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
- en: '| `none` | `0` |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
- en: '| `disclose` | `d` |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
- en: '| `auth` | `xd` |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
- en: '| `compare` | `cxd` |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
- en: '| `search` | `scxd` |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
- en: '| `read` | `rscxd` |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
- en: '| `write` | `wrscxd` |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
- en: 'The `none` keyword we have seen before and it is the same as `=0`. Looking
    at the other keywords and their associated privilege, a pattern emerges: each
    keyword adds one new privilege, to the privileges of the previous keyword. Thus,
    `auth` has the `=d` privilege from `disclose`, plus the `x` privilege, and `compare`
    has `=xd` from `auth` and adds the `c` privilege. The `write` keyword at the bottom
    has all privileges.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: Because this general accumulation of privileges captures the usual use cases
    while remaining more readable, keywords are used more frequently than privilege
    strings. In most of our examples from here on, we will use the keyword unless
    there is a specific reason to use the privilege string instead.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of the seven keywords, `disclose`, `auth`, `compare`, `search`, `read`, and
    `write` can be prefixed with one of two prefixes: `self` and `realself`. The `self`
    prefix indicates that if the value in question refers to the user''s DN, then
    the user may have certain privileges. Thus `selfwrite` indicates that the user
    has `=wrscxd` permissions if and only if the value of the attribute in question
    is the user''s DN.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: The `realself` prefix is similar, but it carries the additional stipulation
    that the DN not be proxied. These prefixes are particularly useful when dealing
    with groups and other membership-based records.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following ACL allows a user `write` access to the `uniqueMember`
    attribute only if the `uniqueMember` attribute contains that user''s DN: `access
    to attrs=uniqueMember by users selfwrite`.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the access field we will move on to the `who` field.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: The who Field
  id: totrans-672
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have always used `*` in the `who` field. However, the `who` field is the
    richest of the ACL fields, providing twenty-three distinct forms, most of which
    can be used in combinations. In order to efficiently cover ground, we will cover
    the major forms on their own, and then group similar forms together and treat
    them as units.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: The five most frequently used forms are `*`, `anonymous`, `self`, `users`, and
    `dn`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: The * and anonymous Specifiers
  id: totrans-675
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `*` specifier, as we have already seen, is a global match. It matches any
    client, including the anonymous user.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'The `anonymous` specifier matches only clients that bind to the directory as
    the Anonymous user (see Chapter 3 for details on the Anonymous user). This refers,
    then, to clients that have not authenticated to the directory. Since the process
    of authentication requires that the client connect Anonymously, and then attempt
    to bind as a DN with a specific password, the anonymous user almost always needs
    permissions to perform an `auth` operation, in which the client sends the DN and
    password to the directory and asks the directory to verify that the information
    is correct. For that reason, you will likely need an ACL that looks like this:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This grants the Anonymous user the ability to do an auth operation. Note that
    every ACL ends with an implicit phrase: `by * none`. In other words, if permissions
    are not explicitly specified none are granted.'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Note that the ACL above does not allow users to modify their own passwords.
    That's where the `self` specifier comes in.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: The self Specifier
  id: totrans-681
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `self` specifier is used to specify access controls for a DN on its own
    record. Thus, we can use the `self` specifier to allow a user to modify her or
    his own `userPassword` value:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we log in as `uid=matt,ou=Users,dc=example,dc=com` and try to modify the
    `userPassword` value of our own record (`dn: uid=matt,ou=Users,dc=example,dc=com`),
    SLAPD will allow us to change the password. But it will not (according to the
    rule above) allow us to modify anyone else''s `userPassword` value.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `self` specifier can be further modified with a `level` style. The `level`
    style indicates whether (and how many) parent records or child records are to
    be treated as if they were part of `self`. The `level` style takes an integer
    index. Positive integers refer to parents, while negative integers refer to children.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Thus `access to` `ou` `by` `self.level{1}` `write` indicates that the current
    DN has write permissions to the `ou` of its parent. Likewise, `access` `to` `ou`
    `by` `self.level{-1}` `write` indicates that the current DN has write permission
    to the `ou` of any of its immediate children.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: The users Specifier
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `users` specifier refers to any authenticated client. The anonymous user
    is not included in `users` because it represents a client that has not authenticated.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: 'This specifier comes in very handy when you need to allow anyone who has authenticated
    access to some resources. For example, in an enterprise directory we would likely
    want to allow all users the ability to see each other''s names, telephone numbers,
    and email addresses:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The dn Specifier
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `dn` specifier performs similarly in the `by` phrase to the role it plays
    in the `access` `to` phrase. It specifies one or more DNs. The `dn` has the `regex`,
    `base`, `one`, `subtree`, and `children` modifiers, all of which perform the same
    way here as they did in the `access` `to` phrase. Here''s an example using a few
    different DN patterns:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This rule restricts access to the description attributes of anything in the
    System OU subtree. The user `uid=barbara,ou=Users,dc=example,dc=com` has write
    permissions to the description, while any child users of the System OU have *read*
    permissions. Users with DNs of the form `uid=SOMETHING,ou=Users,dc=example,dc=com`
    also have *read* access to the description.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the regular DN modifiers, a `dn` in the `by` clause can also
    have a `level` modifier. Level allows the ACL author to specify exactly how many
    levels down a `by` phrase should go. Recall that the `dn.one` specifier indicates
    that any record directly below the specified DN is to be granted the specified
    permissions. For example `by` `dn.one="ou=Users,dc=example,dc=com"` `read` grants
    any direct descendant of the Users OU read permissions. So `uid=matt,ou=Users,dc=example,dc=com`
    would be granted read access, but `uid=jake,ou=Temp,ou=Users,dc=example,dc=com`
    would not be granted such access because he is two levels down. The `dn.level`
    specifier lets us arbitrarily specify how many levels to descend. For example,
    `by` `dn.level{2}="ou=Users,dc=example,dc=com"` `read` would allow both `matt`
    and `jake` read access.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Proxy Authentication and Real DNs**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: 'If SLAPD is set up to allow Proxy Authentication, in which case one DN is used
    for authentication, and then another DN is used for performing other directory
    operations, it is sometimes useful to write ACLs based on the DN used for authentication
    (the real DN). The `realdn` specifier can be used for this. It functions just
    like the `dn` specifier, except that it operates on the real DN. Also, `realanonymous`,
    `realusers`, `realdnattr`, and `realself` can be used to restrict based on the
    real DN. See the `slapd.access` man page for more: `man` `slapd.access`.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Groups and Members
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it is useful to grant group members the access to an object. For example,
    if you have an Administrators group, you may wish to grant any member of that
    group write access to all of the records in the System OU.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: One might expect that the way to set permissions for group members is simply
    to use the group as the value of a `dn` specifier in an ACL. However, that is
    not the case since the `dn` specifier refers to the group record as a whole, and
    has nothing at all to do with the members of the group, each of which has its
    own record elsewhere in the directory.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what we need is a way to search the member attributes of a particular
    group record, and then grant access to the DNs listed in the record. The group
    specifier provides exactly this sort of capability.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'Group evaluation can be done with the `group` specifier. In its simplest form
    it is used like this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This ACL will grant members of the `cn=Admins,ou=Groups,dc=example,dc=com` group
    write access to anything in the System OU, while giving all other users read-only
    permissions.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Order Matters**'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: ACL by phrase are evaluated sequentially, and by default SLAPD will stop processing
    `by` phrases when it hits a match. In other words, if the by phrases in the above
    rule were reversed, members of LDAP Admins would never be given write permission
    because they would always match the `by` `users` `read` phrase. Evaluation of
    the ACL would stop before group membership was checked.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: But the ACL above will only work on groups whose object class is `groupOfNames`,
    and whose membership attribute is `member`. This is because groupOfNames is the
    default grouping object class, and member is the default membership attribute.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created our LDAP Admins group in Chapter 3, it was not `groupOfNames`,
    nor did it use the `member` attribute for membership. Our record looked like this:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We used the `groupOfUniqueNames` object class and the `uniqueMember` membership
    attribute. In order to get the ACL to match these constraints we will need to
    specify the object class and membership attribute in the `group` specifier:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Note the change in the highlighted line. Using slashes (`/`) we have specified
    first the object class then the membership attribute that should be used to determine
    who what entries represent members. When this `by` phrase is evaluated, SLAPD
    will find the DN `cn=LDAP` `Admins,ou=Groups,dc=example,dc=com`, check to see
    if it has object class `groupOfUniqueMembers`, and then grant write permissions
    to a DN if it is specified in a uniqueMember attribute.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Using this expanded notation, you can use other membership-based records as
    groups. For example, you can use the `organizationalRole` object class with the
    `roleOccupant` membership attribute.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'Like many other specifiers, the group specifier also supports regular expressions
    with the `regex` style. Thus, we could create a rule that would allow members
    of any group in OU Groups write access to the System OU by expanding our last
    example:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The second and third lines should be combined into one long line in `slapd.conf`.
    The regular expression in the group specifier would match any DN with a CN component
    at the beginning. For all such entries, if the object class is `groupOfUniqueMembers`,
    then the SLAPD will grant membership to a user who is a `uniqueMember` of one
    of those groups.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Member-Based Record Access
  id: totrans-720
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if a group member needs to modify the record of the group to whom she
    or he belongs? One way to allow this is with the `dnattr` specifier. The `dnattr`
    specifier grants access to a record only if the client''s DN appears in a certain
    attribute of the record. For example, the following example allows a group member
    (`uniqueMember`) of a group (which is a `groupOfUniqueNames` object) access to
    the group record:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The second line specifies that if the client's DN is in the list of values for
    the `uniqueMember` attribute, then that client should be given write access to
    the entire group record. Other users, according to the third line, will have read
    access.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: Network, Connections, and Security
  id: totrans-724
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SLAPD can use information about the client's connection (including network and
    security information) in access control lists. This feature provides an additional
    layer of network security that complements SSL/TLS and SASL.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are network or connection level specifiers:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '`peername`: This is used to specify a range of IP addresses (for `ldap://`
    and `ldaps://`).'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sockname`: This is used to specify a socket file for an LDAPI listener (`ldapi://`).'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`: This is used to specify a domain name for `ldap://` and `ldaps://`
    listeners.'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sockurl`: This is used to specify a socket file in URL format (`ldapi://var/run/ldapi`)
    for an LDAPI listener.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssf`: The overall security strength factor (SSF) of the connection.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transport_ssf`: The SSF for the underlying transport layer of the network.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tls_ssf`: The SSF for the SSL/TLS connection. This works with SSL/TLS connections
    on LDAPS listeners and Start TLS on LDAP listeners.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sasl_ssf`: The SSF of the SASL connection.'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSF specifiers (`ssf`, `transport_ssf`, `tls_ssf`, and `sasl_ssf`) perform
    the same checks as the SSF parameters to the SLAPD `security` directive (discussed
    in the first part of this chapter). In this case, however, SSFs may be used to
    selectively restrict (or grant) access to portions of the directory information
    tree. SSF specifiers require an integer value for the level of security desired.
    For example, using `ssf=256` will require that the overall SSF of a connection
    be 256\. But `tls_ssf=56` will require that the SSF of the TLS/SSL layer be at
    least 56, regardless of what the SSF of the SASL configuration is. For more information
    on SSFs, see the section earlier in this chapter entitled *Using* *Security* *Strength*
    *Factors*.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following ACL will only grant *write* access to the specified
    DN when the client has connected with a strong SASL cipher:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This rule allows users to modify their own records only if they have authenticated
    with SASL using a security mechanism with a strength of 128 (DIGEST-MD5) or more.
    All other users would only get read access.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Combining Specifiers in a by Phrase**'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: As the rule above illustrates, multiple specifiers can be used in a single by
    phrase. When this happens all specifiers must be matched before the indicated
    rights will be granted (or denied).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: The `peername` specifier is used for setting restrictions based on information
    about the IP connection. It can be used to complement other components in network
    security, like SSL/TLS. The `peername` specifier can take an IP address or a range
    of IP addresses (using subnet masks) and can also specify a source port.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: The following rule grants write access to local connections, read access to
    connections on the local LAN (address from 10.40.0.0 through 10.40.0.255), and
    denies access to all other clients. Remember, every rule ends with an implicit
    `by` `*` `none`.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that the `peername` specifier requires the ip style for specifying an IP
    address. It also supports the `regex` style (`access` `to` `*` `by` `peername.regex="^IP=10\`.`40\`.`0\`.`[0-9]+:[0-9]+$"`
    `write`) and the `path` specifier to replicate the behavior of `sockname`.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Regular Expressions for IP Addresses**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'For an IP address, the format of the string used in regular expression evaluation
    is this: `IP=<address>:<port>`. If you are creating a precise regular expression
    make sure to deal with the `IP=` prefix and the port information. A regular expression
    like this will fail: `peername.regex="^10.40.12[0-9]$"`. Why? Because it is missing
    the `IP=` and port information.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 'A more useful version of the rule above would deny access to anything in the
    directory if it was not in the particular ranges, but would leave further access
    controls to rules appearing later in the ACL list. This can be done using the
    special `break` control described in the next section. We could also added SSF
    information, so connections coming over non-local connections must also use strong
    SSL/TLS encryption. Here is the rule:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The above rule might appear difficult to read, but here is what it does:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: If the connection is local (coming over 127.0.0.1 or `localhost`), then SLAPD
    allows further processing of the ACL list (that's what `break` does). Whether
    or not the user then gets access to resources is dependent on other rules.
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the connection comes from an address on the LAN and it is using strong SSL/TLS
    encryption, then SLAPD will continue processing the ACL list.
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under any other connecting circumstances the connection is rejected. For example,
    if a connection comes from the LAN but does not use sufficiently strong SSL/TLS,
    the connection will be closed. This behavior is caused by the implicit `by` `*`
    `none` phrase.
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on the `break` control, see the section called *The* *Control* *Field*.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is more useful to be able to specify which domain names (rather
    than which IP addresses) should be granted access. This can be done with the `domain`
    specifier:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In the example above, the second line provides write access to any client connection
    coming from the domain name `main.example.com`. The third line grants read access
    to the domain `example.com`, and any subdomain of `example.com`. So, if a server
    with the domain name `test2.example.com` made a request, it would be granted access
    under the third rule. However, `testexample.com` would not match because it is
    not a subdomain of `example.com`—it is a different domain altogether.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: When SLAPD encounters a domain specifier in an ACL, it takes the IP address
    of the client connection and does a reverse DNS lookup to get the host name. In
    light of this there are two things to keep in mind when using the domain specifier.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: First, the name returned by a reverse DNS lookup may not be what you expect
    based on a forward DNS lookup. For example, doing a DNS lookup on `ldap.example.com`
    returns the address 10.40.0.23\. However, doing a reverse DNS lookup on 10.40.0.23
    returns `mercury.example.com`. Why?
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'It is because `ldap.example.com` is in DNS parlance, a **CNAME record**, and
    `mercury.example.com` is an **A record**. Practically speaking, what this means
    is that `ldap.example.com` is an alias to the server''s real (**canonical**) name,
    which is `mercury.example.com`. The practical consequence is this: when you write
    an ACL using the `domain` specifier, make sure you use the A record domain name,
    not the CNAME record name. Otherwise, SLAPD will apply the rule to the wrong domain
    name.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Looking up DNS Information**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many tools for looking up DNS information. Most Linux distributions,
    including Ubuntu Linux, provide the `host` and `dig` commands for command-line
    DNS lookups. The `host` command gives brief sentence-like information like this:
    `ldap.example.com` `is` `an` `alias` `for` `mercury.example.com`. The `dig` command,
    in contrast, gives detailed technical information.'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to keep in mind when considering the domain specifier is that
    it is less reliable than using IP address information. DNS addresses can be spoofed,
    which means another server on the network can claim to be `ldap.example.com` and
    send traffic that looks, to SLAPD, like it is coming from the real `ldap.example.com`.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: One way to diminish the risk of this is to use client-side SSL/TLS certificates
    and configure SLAPD to require that the client send a signed certificate to authenticate
    before it can perform any other directory operations. Unfortunately, client-side
    certificates cannot be selectively required through ACLs. Instead you will have
    to use the directive `TLSVerifyClient` `demand` in the `slapd.conf` file.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: The `sockname` and `sockurl` specifiers are used for servers that run with UNIX
    local socket Inter Process Communication (IPC) instead of network sockets. These
    directives can be used to restrict local connections that use the IPC layer instead
    of connecting through the IP network.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-768
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is uncommon to run LDAPI. Generally it is used only in situations where IP
    network connections cannot or should not be used. In typical cases, local clients
    connect to SLAPD over LDAP, using the URL `ldap://localhost/` rather than using
    LDAPI.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could use the following ACL to allow only local (LDAPI) connections
    to write to the record, while users who connected through a different mechanism
    could only read the record:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The second line indicates that only LDAPI connections that connect through a
    particular LDAPI socket file should gain write access to the DN. All other clients
    (`users`) will get read permissions.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced Step: Using the set Specifier'
  id: totrans-773
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the syntax we have examined just now, there is an experimental
    type of `by` phrase—the **set** syntax. The `set` syntax can be used to create
    a compact and powerful set of conditions for access. Since it allows Boolean operators,
    and has a method for accessing attribute values, a single rule in the `set` syntax
    can accomplish what would otherwise take tremendously complex ACLs.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind the `set` syntax is this. By using a rule composed of
    conditions joined by operators, SLAPD creates a set of objects which have access
    to the record in question. If the result of an evaluation of a `set` specifier
    is a set that contains one or more members, then the `by` phrase is considered
    a match and permissions are applied. If, on the other hand, the set is empty,
    then SLAPD will continue evaluating the `by` phrases for that rule to see if it
    can find another match.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `set` specifier uses operations of the sort used in set theory. When using
    the set specifier you may find it helpful to think in terms of set theory, with
    sets (lists of items) and set operations, such as union (`&`) and intersection
    (`|`).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple ACL using a `set` specifier to replicate the behavior of the
    `group` specifier. It provides write access to records in the System OU only to
    clients in the LDAP Admins group. All others get read access only:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The second line, highlighted above, contains the `set` specifier, which contains
    a `set` statement. The text in the square brackets specifies a DN, which is the
    DN of the LDAP Admins group. To access the values of the `uniqueMember` attribute
    we append `/uniqueMember` to the DN. When SLAPD expands this, it will contain
    the set of all `uniqueMembers` in the LDAP `Admins` `group`. In set-theoretic
    notation (which is not used by OpenLDAP, but which is helpful to understand what
    is happening), the set of group members would look like this:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There are two members (the two `uniqueMembers`) for the LDAP Admins group.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: 'The `&` (ampersand) operator performs a union operation on two sets. The **user
    keyword** expands to the set that contains one member: the DN of the current client.
    So, if I perform a search, binding as `uid=matt,ou=users,dc=example,dc=com`, then
    the user set will contain one record:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When the `&` operator is applied, it will generate the intersection of the
    two sets. That is, the resulting set will contain only members that are in both
    of the original sets. Since only the record for UID `matt` is in both, the resulting
    set will contain just the DN for `matt`:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The resulting set is not empty so it is considered a match. The result of the
    set evaluation, then, is that the `uid=matt,ou=users,dc=example,dc=com` will be
    granted access based on the `set` specifier.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sets are case-sensitive, and always use the normalized DN form. What this means
    is that the DNs in sets should always be lowercase.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a case though, when the user is not a member of the LDAP Admins group.
    If `uid=david,ou=users,dc=example,dc=com` binds, can he perform read and write
    operations? When the set specifier is run, the first of the two sets (group membership)
    will evaluate to the same thing it did above:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'But the user keyword will expand to this:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'There are no items in the intersection of these two sets, so the resulting
    set, after the `&` operator is applied, is an empty set:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: There are no matches, so this `by` phrase fails to apply. The last line in our
    ACL (`by` `users` `none`) will then apply, and the `uid=david` will be given no
    access permissions.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example. We will use the set specifier to implement
    a rule where, when a client DN tries to access a record DN, it is given write
    access only if the two DNs are the same, or else it is given read access if they
    are in the same OU. Otherwise, the client DN is denied access to the record DN.
    Here''s the ACL:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The first line indicates that this rule will apply to the record `dc=example,dc=com`
    and everything under it.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'The second line takes the intersection of the sets generated by two keywords:
    `this` and `user`. The `this` keyword expands to the set containing the DN of
    the requested record. The `user` keyword, as we saw, expands to the DN of the
    client.'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if the client `uid=david,ou=users,dc=example,dc=com` requests access to
    its own record, the resulting set operation will be as follows:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Since both sets contain the same member, the resulting set (the intersection
    of the two) is `{` `uid=david,ou=users,dc=example,dc=com` `}`. The end set is
    not empty, so the user will be granted write access.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the third line of the given ACL. This rule will return a non-empty
    set whenever the requested DN and the client DN both have the same value for the
    `ou` attribute. If `uid=david,ou=users,dc=example,dc=com` requests the record
    for `uid=matt,ou=users,dc=example,dc=com`, then SLAPD will check the values of
    their respective OU attributes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 'The set identified by `this/ou` will be expanded to contain the values of all
    of the OU attributes in the requested record (the record for `uid=matt,ou=users,dc=example,dc=com`).
    This set is:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Note that in this case the value is not a DN, but a string. Sets can perform
    matching operations on strings as well as DNs.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: 'The set identified by `user/ou` will be expanded to contain the values of all
    of the OU attributes in the client''s record. The record for `uid=david,ou=users,dc=example,dc=com`
    contains one value for the `ou` attribute, and the resulting set will contain
    that one attribute value:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: SLAPD will compute the intersection of `{` `'Users'` `}` `&` `{` `'Users'` },
    which is `{` `'Users'` `}`. Since the set is not empty, `uid=david,ou=users,dc=example,dc=com`
    will be granted access to read the record of `uid=matt,ou=users,dc=example,dc=com`.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set` specifier provides one way of granting access to a record *only*
    in the case that a record contains a certain attribute. If we only want to grant
    write access to records with the title attribute, we can use the following rule:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In this ACL, if the requested record has a single `title` attribute, then the
    result of the evaluation of the above rule will be a set containing one element.
    However, if the record attribute has no title attribute, then the resulting set
    will be empty, and write access will not be granted.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'In our directory the record of `uid=matt,ou=users,dc=example,dc=com` has the
    following title attribute:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'But the record `uid=barbara,ou=users,dc=example,dc=com` does not have a title
    attribute at all. So if the record for `uid=matt` was requested, then the resulting
    set, based on the above ACL, would be:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: So if an authenticated user attempted to access the record for `uid=matt`, SLAPD
    would grant access. In contrast, the set for `uid=barbara` would be `{}`, the
    empty set. So a user trying to access the record having `uid=barbara` would be
    denied access.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a similar set specifier, we could grant access to a record depending
    not only on the existence of an attribute, but on its value too:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: According to the above rule, write access will be granted for anything in the
    Users OU only if the entry has an `objectclass` attribute with the value `person`.
    Note that in this case the square brackets are used to define a string literal.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'If a client were to access the record `uid=barbara,ou=users,dc=example,dc=com`,
    the first part of our `set` statement would evaluate to the following set:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Those are the three object classes for the `uid=barbara` record. The other
    part, `[person]`, would be expanded to this set:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: When the union is computed, the result would be the set `{'person'}` and so
    write access would be granted.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: 'These are just a few of the basic operations that can be done with the `set`
    specifier. Unfortunately, `set` is not documented in the `slapd.access` man page.
    However, there is a lengthy and informative article on using set in the OpenLDAP
    official FAQ-O-Matic: [http://www.openldap.org/faq/data/cache/1133.html](http://www.openldap.org/faq/data/cache/1133.html).'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: The control Field
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last field in the `by` phrase is the control field. There are only three
    possible values for the control field: `stop`, `break`, and `continue`. If no
    control field is specified, `stop` is assumed. For example, `by` `*` `none` is
    the same as `by` `*` `none` `stop`.'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'The first value, `stop`, indicates that if that particular by clause matches,
    no further checking of ACLs for matching should occur. Consider the following
    (admittedly contrived) case:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: If I bind as `uid=matt,ou=Users,dc=example,dc=com` and try to modify my `employeeNumber`,
    will I be allowed to? No, I will not.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason I will not be able to modify the record is because I will only have
    the permissions granted by the first `by` phrase: `by` `users` `=cd` (remember,
    `by` `users` `=cd` is the same as `by` `users=cd` `stop`). As soon as SLAPD sees
    that I match the first `by` phrase of the first ACL, it will stop testing ACLs.
    Thus it will never reach the rule that grants my DN `+r` access, nor will it reach
    the rule that grants all users `+w` to the `employeeNumber` attribute.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of the `stop` control, which is used implicitly by all three
    rules.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if I wanted to make sure that after the first `by` phrase SLAPD continues
    to evaluate phrases within the ACL, I could re-write the ACLs using the `continue`
    control:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: After running the same test on these rules, the DN `uid=matt,ou=Users,dc=example,dc=com`
    would have the permissions `=cdr`.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` control instructs SLAPD to continue processing all of the `by`
    phrases in the *current* *ACL*. Once it is done evaluating that ACL though, it
    will not continue to look for matches in other ACLs.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: In order to tell SLAPD to look at different rules for matches, we would have
    to use the `break` control. When SLAPD encounters an applicable clause that ends
    with a `break` control, it stops processing the current ACL but continues looking
    at other ACLs to see if they apply.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to get write permissions with our ACL we would want the following ACLs:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Now what will happen when the user with UID `matt` attempts accesses an `employeeNumber`?
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: First, the `by` phrase of the first ACL will be evaluated, and `matt` will be
    granted `=cd`. Because of the `continue` control, SLAPD will then examine the
    second `by` clause, which will also match for the user `matt`. Thus, `matt` will
    have `=rcd` when the processing of the first ACL completes.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: Due to the `break` control the second ACL will also be evaluated, and `matt`
    will be granted `+w` as well, bringing his final permissions up to `=wrcd`.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: Using the `continue` and `break` controls is one way to incrementally handle
    permissions. In complex configurations, judicious use of `continue` and `break`
    can make maintaining ACLs much easier, and can reduce the total number of ACLs.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: Getting More from Regular Expressions
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections we have looked at using regular expressions in both
    the `access` `to` phrase and the `by` phrase. But we can use both in conjunction.
    We can store information about the matches identified in the `access` `to` phrase,
    and use that information later in the `by` phrases.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: 'To temporarily store matching information in an `access` `to` phrase we can
    surround the regular expression with parentheses. Here''s an example:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This ACL grants a client the DN access to read a record DN only if both the
    client DN and the record DN are in the same part of the directory tree (that is,
    if both are in the same OU).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the given ACL we used parentheses to capture the match
    from the regular expression `[^,]+`, which will be the value of the `ou=` component
    of the DN. Again, `[^,]+` says "match all charcters that are not '`,`'."
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second line we used the `dn.children` specifier but supplemented it
    with an extra keyword: `expand`. The `expand` keyword tells SLAPD to substitute
    matches from the `access` `to` clause into this phrase.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Because of the `expand` keyword, the variable `$1` is substituted with the value
    of the match in the first line. Everything captured between '`(`' and '`)`' in
    the regular expression will be stored in `$1`.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: Variable names are assigned in order. The first set of parenthesis in the regular
    `access` `to` phrase gets stored in `$1`. If a second set of parenthesis existed,
    the matching information inside of those would be stored in `$2` and so on for
    each additional set of parenthesis.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want an ACL like this:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This rule would grant a client DN access to read and write any entries subordinate
    to its own record but deny other uses the ability to even read those entries.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Address books are sometimes implemented in OpenLDAP by storing a user''s addresses
    as subordinate entries to the user''s own entry in the directory. There is an
    example of this in the OpenLDAP FAQ-O-Matic: [http://www.openldap.org/faq/data/cache/1005.html](http://www.openldap.org/faq/data/cache/1005.html)'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the first line stores two variables. The UID goes in `$1` and the
    OU goes in `$2`. These are expanded in the second line.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use matches from the `access` `to` phrase in regular
    expressions in the `by` phrase:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the first line only the results of the second regular expression are captured
    and stored in a variable. The second line also contains a regular expression,
    and it makes use of the `$1` variable to retrieve the value of the OU from the
    first line. Note that `dn.children,expand` was replaced with `dn.regex`. The `expand`
    keyword need not be added for regular expressions.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: The rule grants write access to a client DN for any user record that is in the
    same OU of that directory tree.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at some simple, though useful, regular expressions in these ACLs.
    But much more complex regular expressions can be composed, making ACLs even more
    powerful. As you compose more advanced regular expressions you may find some other
    sources of information helpful. Along with the `slapd.access` man page, the POSIX
    extended regular expressions man page (`man` `regex`) may turn out to be useful
    as well.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Debugging ACLs
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging ACLs can be frustrating. They are complex, security sensitive, and
    require detailed testing. But there are three tools that make the debugging and
    testing process easier.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: The first is just the `ldapsearch` command-line client. It can be used to carefully
    craft filters designed to test the processing of ACLs. The `ldapcompare` tool
    also comes in handy when you need to test comparison operations.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: But it is also useful to make the most of LDAP's logging directives. The `trace`
    and `acl` debugging levels each provide detailed information about ACL processing.
    The `acl` level, for example, records each ACL evaluation. This can be very useful
    in determining what rules are run and when. We find the `trace` debugging level
    to be useful as well, as it provides information about how each evaluation was
    performed, including how regular expressions were expanded.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-870
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Running SLAPD in the Foreground**'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it is easier to test ACLs by running SLAPD in the foreground, instead
    of as a daemon process, and printing debugging and logging information to standard
    out. For example, we can print ACL and trace debugging out this way: `slapd` `-d`
    `"acl,trace"`. Note that you will want to run this command as the appropriate
    user (such as `openldap`). To terminate the process use the *Ctrl*-*C* keyboard
    combination.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `slapacl` command line utility provides a detail-oriented tool
    for evaluating ACLs directly. Since it does not connect to the SLAPD server over
    the LDAP protocol it allows more direct testing of just the ACLs.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can check whether or not a particular SASL user, `matt`, can
    access the record `cn=LDAP` `Admins,ou=Groups,dc=example,dc=com` and *read* the
    value of the `description` attribute:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `-U` `matt` param specifies the SASL user name. The `-b` `"cn=LDAP` `Admins,ou=Groups,`
    `dc=example,dc=com"` param indicates which record we want to test against, and
    the last field, `"description/read"` indicates the attribute and the access level.
    This will simply return `ALLOWED` if the ACLs allow read access, or `DENIED` otherwise.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we can test other LDAP operations. For example, we can test whether
    a user has permissions to `compare`:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In this example we have included the response. The first response line indicates
    how the SASL DN was resolved, and the second line indicates that compare access
    on `uid` was allowed.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: 'The `slapacl` program essentially runs its own SLAPD and as such, it can be
    set to print complete processing logs to the screen. For example, to turn on trace
    debugging we can just add the `-d` `trace` param to the given command:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: As you can see`slapacl` provides detailed evaluation information in this case.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: Using the LDAP command-line clients, detailed logging, and the `slapacl` command,
    debugging and testing ACLs can be done effectively.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: A Practical Example
  id: totrans-884
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part of the chapter, we have taken a low-level look at ACLs in OpenLDAP.
    We have covered many of the details of the ACL system. Now it is time to implement
    what we have covered so far to create a generic set of ACLs for our directory
    information tree.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 2 we created a bare-bones set of ACLs in our `slapd.conf` file.
    Here''s what we created then:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now, we will create a new, more practical list of ACLs.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is move the ACLs out of `slapd.conf` and into a
    separate file: `acl.conf`. This will keep the lengthy list of ACLs separate from
    the rest of our configuration. To do this we will replace the ACLs above with
    an `include` directive:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When SLAPD is started it will include the contents of `/etc/ldap/acl.conf` at
    the location where the `include` statement appears. Recall that ACLs are backend-specific.
    Each different database can have its own ACLs (and multiple databases can be defined
    in the same `slapd.conf` file). So it is important to put the `include` directive
    after the database `directive` in `slapd.conf`.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: Now we will begin editing the `acl.conf` file. The rules that we will write
    will be simple, and designed for a directory where most of the directory users
    are allowed to view most of the information in the directory. A higher-security
    directory may have a far more complex list of ACLs.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Since ACLs are evaluated in order from top to bottom we want to carefully craft
    our rules so that important restrictions are implemented right away.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are network-based access rules they should usually appear at the top
    of the ACL list so that they are evaluated first. For example, if we want to restrict
    access to the entire database if the host is not in our LAN, we would use the
    following rule:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: By this rule only access from the localhost (127.0.0.1) and from inside of our
    10.40.0.0 subnet will be allowed to access the directory. Since the `break` control
    is specified, later rules may modify the `none` permission, granting clients more
    permissions. All other connections will be closed immediately.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to grant members of the LDAP Admins group write access to everything
    in the `dc=example,dc=com` tree:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This immediately grants write access to the members of the LDAP Admins group.
    For all other clients though, SLAPD will continue processing.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No ACLs need to be written for the directory manager, the DN specified in the
    `slapd.conf` directive `rootdn`. This DN always has full access to the directory
    information tree, and ACLs will have no effect on this user.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to make sure that the `userPassword` field is available to the
    anonymous user for authentication purposes. We also want to allow users to be
    able to modify their own passwords, but otherwise we want `userPassword` unavailable
    for reading and writing by others. Note that by the previous rule the LDAP Admins
    will also be able to modify passwords for users.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In some cases, other users may need `auth` access to the password as well, in
    which case you may need to add `by` `users` `auth` to the given list.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: We also need to grant access to the `uid` attribute if we are using the `ldap://`
    URL form for SASL binding in the `authz-regexp` directive. This is because the
    filter in the LDAP URL is run as anonymous (see the discussion in the *Configuring*
    *SLAPD* *for* *SASL* *Support Subsection*).
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we don''t want to let users try to modify their own `uid`, since
    `uid` is used in the DN:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Now Anonymous and all authenticated users will be able to access the `uid` attribute
    of any record in the directory to which they have access.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: There are also a few other attributes we don't want users to be able to modify—even
    in their own records.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t want users to try to modify their OU attributes, since OU attributes
    are also used in DNs. We also don''t want them to be able to modify their `employeeNumber`
    or their `employeeType`:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'We have a special account, `uid=Authenticate,ou=System,dc=example,dc=com`,
    which will be used on occasion to help with bind requests. This user should not
    have access to anything else other than what we specified:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Again, the last line instructs SLAPD to continue processing ACLs for users who
    aren't having the authentication account. This line will also stop the anonymous
    user from browsing the rest of the tree since the implicit rule at the end, `by`
    `*` `none`, will catch the anonymous user.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-915
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `uid=Authenitcate` user was already granted, in an earlier rule, access
    to the `uid` attribute, which is the attribute that this account will use to search
    for user information needed to bind.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we don''t want regular users (DNs in the Users OU) to be able
    to access records in the System OU of our directory (which is typically used for
    system accounts). We can implement this with the following rule:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This denies access to users in the Users OU, but allows other users (like System
    accounts) access to these records.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to give every user the ability to read and write records below
    its own, but restrict others from accessing those records. This makes it possible
    for users to store their own information (like address books) inside of the directory:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Finally, the last rule we want is a default rule. This rule should answer the
    question, "What do we want to happen when no other rules are matched?" We want
    users to be able to modify their own records and see the records of others:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now our list of ACLs is complete. Altogether, this is what they look like:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: While they certainly won't meet all needs, these rules provide a good starting
    point for balancing security and usability of the directory. Furthermore, they
    set the stage for some of the things we will be doing later in this book.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters of this book, the mentioned ACLs will be revisited and fine-tuned
    to allow additional features, like directory replication.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter has been OpenLDAP security, and we have covered a
    lot of ground. We began with connection-level security, where we configured SSL/TLS
    encryption for our directory server. We used StartTLS over the standard LDAP port,
    and also configured the older (LDAP v2) LDAPS protocol on port 636\. Next, we
    looked at the process of authenticating to the LDAP. In that part we covered both
    simple binding and SASL binding. Finally, we took a detailed look at access control
    lists (ACLs), finishing the chapter with a basic set of ACLs.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look at advanced configuration of OpenLDAP's SLAPD
    server. We will configure our server to host multiple backend databases and we
    will use directory overlays to add powerful additional features to our SLAPD server.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
