<html><head></head><body>
		<div id="_idContainer058">
			<h1 id="_idParaDest-181"><em class="italic"><a id="_idTextAnchor183"/>Chapter 12</em>: Abstracting Memory Access – Introduction to the Regmap API: a Register Map Abstraction</h1>
			<p>Before the Regmap API was developed, there was redundant code for the device drivers dealing with SPI, I2C, or memory-mapped devices. Many of these drivers contained some very similar code for accessing hardware device registers. </p>
			<p>The following figure shows how SPI, I2C, and memory-mapped related APIs were used standalone before Regmap was introduced:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B17934_12_001.jpg" alt="Figure 12.1 – I2C, SPI, and memory-mapped access before Regmap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – I2C, SPI, and memory-mapped access before Regmap</p>
			<p>The Regmap API<a id="_idIndexMarker956"/> was introduced in version v3.1 of the Linux kernel and proposes a solution that factors out and unifies these similar register access codes, saving code and making it much easier to share infrastructure. It is then just a matter of how to initialize and to configure a <strong class="source-inline">regmap</strong> structure, and process any read/write/modify operations fluently, whether it is SPI, I2C, or memory-mapped.</p>
			<p>The following diagram depicts this API unification:</p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B17934_12_002.jpg" alt="Figure 12.2 - I2C, SPI, and memory-mapped access after Regmap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2 - I2C, SPI, and memory-mapped access after Regmap</p>
			<p>The previous figure shows how Regmap unified transactions between devices and their respective bus frameworks. In this chapter, we will cover as much as possible of the whole aspect of the APIs this framework offers, from initialization to complex use cases.</p>
			<p>This chapter will walk through the Regmap framework via the following topics: </p>
			<ul>
				<li>Introduction to the Regmap data structures</li>
				<li>Handling Regmap initialization</li>
				<li>Using Regmap register access functions</li>
				<li>Regmap-based SPI driver example – putting it all together</li>
				<li>Leveraging Regmap from the userspace</li>
			</ul>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor184"/>Introduction to the Regmap data structures</h1>
			<p>The <a id="_idIndexMarker957"/>Regmap framework, which is enabled via the <strong class="source-inline">CONFIG_REGMAP</strong> kernel <a id="_idIndexMarker958"/>configuration option, is made of a few data structures, among which the most important are <strong class="source-inline">struct regmap_config</strong>, which represents the Regmap configuration, and <strong class="source-inline">struct regmap</strong>, which is the Regmap instance itself. That said, all of the Regmap data structures are defined in <strong class="source-inline">include/linux/regmap.h</strong>. It then goes without saying that this header must be included in all Regmap-based drivers:</p>
			<p class="source-code">#include &lt;linux/regmap.h&gt;</p>
			<p>Including the <a id="_idIndexMarker959"/>preceding header is sufficient to make the most out of the Regmap<a id="_idIndexMarker960"/> framework. With this header, a lot of data structures will be made available, among which, <strong class="source-inline">struct regmap_config</strong> is the most important, which we will describe in the next section.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor185"/>Understanding the struct regmap_config structure</h2>
			<p><strong class="source-inline">struct regmap_config</strong> stores<a id="_idIndexMarker961"/> the configuration of the register map during the driver's lifetime. What you set there affects the memory read/write operations. This is the most important structure, which is defined as follows:</p>
			<p class="source-code">struct regmap_config {</p>
			<p class="source-code">    const char *name;</p>
			<p class="source-code">    int reg_bits;</p>
			<p class="source-code">    int reg_stride;</p>
			<p class="source-code">    int pad_bits;</p>
			<p class="source-code">    int val_bits;</p>
			<p class="source-code">    bool (*writeable_reg)(struct device *dev, </p>
			<p class="source-code">                          unsigned int reg);</p>
			<p class="source-code">    bool (*readable_reg)(struct device *dev, </p>
			<p class="source-code">                         unsigned int reg);</p>
			<p class="source-code">    bool (*volatile_reg)(struct device *dev, </p>
			<p class="source-code">                         unsigned int reg);</p>
			<p class="source-code">    bool (*precious_reg)(struct device *dev, </p>
			<p class="source-code">                         unsigned int reg);</p>
			<p class="source-code">    bool disable_locking;</p>
			<p class="source-code">    regmap_lock lock;</p>
			<p class="source-code">    regmap_unlock unlock;</p>
			<p class="source-code">    void *lock_arg;</p>
			<p class="source-code">    int (*reg_read)(void *context, unsigned int reg,</p>
			<p class="source-code">                    unsigned int *val);</p>
			<p class="source-code">    int (*reg_write)(void *context, unsigned int reg,</p>
			<p class="source-code">                    unsigned int val);</p>
			<p class="source-code">    bool fast_io;</p>
			<p class="source-code">    unsigned int max_register;</p>
			<p class="source-code">    const struct regmap_access_table *wr_table;</p>
			<p class="source-code">    const struct regmap_access_table *rd_table;</p>
			<p class="source-code">    const struct regmap_access_table *volatile_table;</p>
			<p class="source-code">    const struct regmap_access_table *precious_table;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    const struct reg_default *reg_defaults;</p>
			<p class="source-code">    unsigned int num_reg_defaults;</p>
			<p class="source-code">    enum regcache_type cache_type;</p>
			<p class="source-code">    const void *reg_defaults_raw;</p>
			<p class="source-code">    unsigned int num_reg_defaults_raw;</p>
			<p class="source-code">    unsigned long read_flag_mask;</p>
			<p class="source-code">    unsigned long write_flag_mask;</p>
			<p class="source-code">    bool use_single_rw;</p>
			<p class="source-code">    bool can_multi_write;</p>
			<p class="source-code">    enum regmap_endian reg_format_endian;</p>
			<p class="source-code">    enum regmap_endian val_format_endian;</p>
			<p class="source-code">    const struct regmap_range_cfg *ranges;</p>
			<p class="source-code">    unsigned int num_ranges;</p>
			<p class="source-code">}</p>
			<p>Don't be afraid of how big this structure is. All the elements are self-explanatory. However, for more<a id="_idIndexMarker962"/> clarity, let's expand on their meanings here:</p>
			<ul>
				<li><strong class="source-inline">reg_bits</strong> is a mandatory field, which is the number of valid bits in a register's address. This is the size in bits of register addresses.</li>
				<li><strong class="source-inline">reg_stride</strong> represents a value that valid register addresses must be a multiple of. If set to <strong class="source-inline">0</strong>, a value of <strong class="source-inline">1</strong> will be used. If set to <strong class="source-inline">4</strong>, for example, an address will be considered valid only if this address is a multiple of <strong class="source-inline">4</strong>.</li>
				<li><strong class="source-inline">pad_bits</strong> is the number of bits of padding between the register and value. This is the number of bits to (left) shift the register value when formatting.</li>
				<li><strong class="source-inline">val_bits</strong> represents the number of bits used to store a register's value. It is a mandatory field.</li>
				<li><strong class="source-inline">writeable_reg</strong> is an optional callback function. If provided, it is used by the Regmap subsystem when a register needs to be written. Before writing into a register, this function is automatically called to check whether the register can be written to or not. The following is an example of using such a function:<p class="source-code">static bool foo_writeable_register(struct device *dev,</p><p class="source-code">                                    unsigned int reg)</p><p class="source-code">{</p><p class="source-code">    switch (reg) {</p><p class="source-code">    case 0x30 ... 0x38:</p><p class="source-code">    case 0x40 ... 0x45:</p><p class="source-code">    case 0x50 ... 0x57:</p><p class="source-code">    case 0x60 ... 0x6e:</p><p class="source-code">    case 0x70 ... 0x75:</p><p class="source-code">    case 0x80 ... 0x85:</p><p class="source-code">    case 0x90 ... 0x95:</p><p class="source-code">    case 0xa0 ... 0xa5:</p><p class="source-code">    case 0xb0 ... 0xb2:</p><p class="source-code">        return true;</p><p class="source-code">    default:</p><p class="source-code">        return false;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">readable_reg</strong> is the same as <strong class="source-inline">writeable_reg</strong> but for all register read operations.</li>
				<li><strong class="source-inline">volatile_reg</strong> is an<a id="_idIndexMarker963"/> optional callback function called every time a register needs to be read or written through the Regmap cache. If the register is volatile, the function should return true. A direct read/write is then performed on the register. If false is returned, it means the register is cacheable. In this case, the cache will be used for a read operation, and the cache will be written in the case of a write operation:<p class="source-code">static bool foo_volatile_register(struct device *dev,</p><p class="source-code">                                    unsigned int reg)</p><p class="source-code">{</p><p class="source-code">    switch (reg) {</p><p class="source-code">    case 0x24 ... 0x29:</p><p class="source-code">    case 0xb6 ... 0xb8:</p><p class="source-code">        return true;</p><p class="source-code">    default:</p><p class="source-code">        return false;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">precious_reg</strong>: Some devices are sensitive to reads on some of their registers, especially for things such as clear on read interrupt status registers. With this set, this optional callback must return true if the specified register falls in this case, which<a id="_idIndexMarker964"/> will present the core (<strong class="source-inline">debugfs</strong>, for example) from internally generating any reads of it. This way, only explicit reads by the driver will be allowed.</li>
				<li><strong class="source-inline">disable_locking</strong> tells whether the following lock/unlock callbacks should be used or not. If false, it means not to use any locking mechanisms. It means this <strong class="source-inline">regmap</strong> object is either protected by external means or is guaranteed not to be accessed from multiple threads.</li>
				<li><strong class="source-inline">lock</strong>/<strong class="source-inline">unlock</strong> are optional lock/unlock callbacks, overriding default lock/unlock functions of <strong class="source-inline">regmap</strong>, based on spinlock or mutex, depending on whether accessing the underlying device may put the caller to sleep or not.</li>
				<li><strong class="source-inline">lock_arg</strong> will be used as the only argument of lock/unlock functions (ignored if regular lock/unlock functions are not overridden). </li>
				<li><strong class="source-inline">reg_read</strong>: Your device may not support simple I2C/SPI read operations. You'll then have no choice but to write your own customized read function. <strong class="source-inline">reg_read</strong> should then point to that function. That said, most devices do not need that.</li>
				<li><strong class="source-inline">reg_write</strong> is the same as <strong class="source-inline">reg_read</strong> but for write operations.</li>
				<li><strong class="source-inline">fast_io</strong> indicates that the register IO is fast. If set, the <strong class="source-inline">regmap</strong> will use a spinlock instead of a mutex to perform locking. This field is ignored if custom lock/unlock (not discussed here) functions are used (see the fields <strong class="source-inline">lock</strong>/<strong class="source-inline">unlock</strong> of <strong class="source-inline">struct regmap_config</strong> in the kernel sources). It should be used only for "nobus" cases (MMIO devices), since accessing I2C, SPI, or similar buses may put the caller to sleep.</li>
				<li><strong class="source-inline">max_register</strong>: This optional<a id="_idIndexMarker965"/> element specifies the maximum valid register address above which no operation is permitted.</li>
				<li><strong class="source-inline">wr_table</strong>: Instead of providing a <strong class="source-inline">writeable_reg</strong> callback, you could provide a <strong class="source-inline">regmap_access_table</strong> object, which is a structure holding a <strong class="source-inline">yes_ranges</strong> and a <strong class="source-inline">no_range</strong> field, both pointers to <strong class="source-inline">struct regmap_range</strong>. Any register that belongs to a <strong class="source-inline">yes_range</strong> entry is considered as writeable and is considered as not writeable if belonging to <strong class="source-inline">no_range</strong>.</li>
				<li><strong class="source-inline">rd_table</strong> is the same as <strong class="source-inline">wr_table</strong>, but for any read operation.</li>
				<li><strong class="source-inline">volatile_table</strong>: Instead of <strong class="source-inline">volatile_reg</strong>, you could provide <strong class="source-inline">volatile_table</strong>. The principle is then the same as <strong class="source-inline">wr_table</strong> or <strong class="source-inline">rd_table</strong>, but for caching mechanisms.</li>
				<li><strong class="source-inline">precious_table</strong>: As above, for precious registers.</li>
				<li><strong class="source-inline">reg_defaults</strong> is an array of elements of type <strong class="source-inline">reg_default</strong>, where each <strong class="source-inline">reg_default</strong> element is a <strong class="source-inline">{reg, value}</strong> structure that represents power-on reset values for a register. This is used with the cache so that a read of an address that exists in this array, and that has not been written since power-on reset, will return the default register value in this array without performing any read transactions on the device. An example of this is the IIO device driver, whose link is the following: <a href="https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c">https://elixir.bootlin.com/linux/v5.10/source/drivers/iio/light/apds9960.c</a>. </li>
				<li><strong class="source-inline">num_reg_defaults</strong> is the number of elements in <strong class="source-inline">reg_defaults</strong>.</li>
				<li><strong class="source-inline">cache_type</strong>: The actual cache type, which can be either <strong class="source-inline">REGCACHE_NONE</strong>, <strong class="source-inline">REGCACHE_RBTREE</strong>, <strong class="source-inline">REGCACHE_COMPRESSED</strong>, or <strong class="source-inline">REGCACHE_FLAT</strong>.</li>
				<li><strong class="source-inline">read_flag_mask</strong>: This is the mask to be applied in the top bytes of the register when doing a read. Normally, the highest bit in the top byte of a write or read operation in SPI or I2C is set to differentiate write and read operations. </li>
				<li><strong class="source-inline">write_flag_mask</strong>: The mask to be set in the top bytes of the register when doing a write.</li>
				<li><strong class="source-inline">use_single_rw</strong> is a <a id="_idIndexMarker966"/>Boolean that, if set, will instruct the register map to convert any bulk write or read operation on the device into a series of single write or read operations. This is useful for devices that do not support bulk read or write, or either.</li>
				<li><strong class="source-inline">can_multi_write</strong> only targets write operations. If set, it indicates that this device supports the multi-write mode of bulk write operations. If clear, multi-write requests will be split into individual write operations.</li>
			</ul>
			<p>You should look at <strong class="source-inline">include/linux/regmap.h</strong> for more details on each element. The following is an example of the initialization of <strong class="source-inline">regmap_config</strong>:</p>
			<p class="source-code">static const struct regmap_config regmap_config = {</p>
			<p class="source-code">    .reg_bits       = 8,</p>
			<p class="source-code">    .val_bits       = 8,</p>
			<p class="source-code">    .max_register   = LM3533_REG_MAX,</p>
			<p class="source-code">    .readable_reg   = lm3533_readable_register,</p>
			<p class="source-code">    .volatile_reg   = lm3533_volatile_register,</p>
			<p class="source-code">    .precious_reg   = lm3533_precious_register,</p>
			<p class="source-code">};</p>
			<p>The preceding example shows how to build a basic register map configuration. Though only a few elements are set in the configuration data structure, enhanced configuration can be set up by learning about each element that we have described.</p>
			<p>Now that we have learned about Regmap configuration, let's see how to use this configuration with the initialization API that corresponds to our needs.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor186"/>Handling Regmap initialization</h1>
			<p>As we said earlier, the<a id="_idIndexMarker967"/> Regmap API supports SPI, I2C, and memory-mapped register access. Their respective support can be enabled in the kernel thanks to the <strong class="source-inline">CONFIG_REGMAP_SPI</strong>, <strong class="source-inline">CONFIG_REGMAP_I2C</strong>, and <strong class="source-inline">CONFIG_REGMAP_MMIO</strong> kernel configuration options. It can go far beyond that and managing IRQs as well, but this is out of the scope of this book. Depending on the memory access method you need to support in the driver, you will have to call either <strong class="source-inline">devm_regmap_init_i2c()</strong>, <strong class="source-inline">devm_regmap_init_spi()</strong>, or <strong class="source-inline">devm_ regmap_init_mmio()</strong> in the probe function. To write generic drivers, Regmap is the best choice you can make.</p>
			<p>The Regmap API is generic and homogenous, and initialization only changes between bus types. Other functions are the same. It is a good practice to always initialize the register map in the probe function, and you must always fill the <strong class="source-inline">regmap_config</strong> elements prior to initializing the register map using one of the following APIs: </p>
			<p class="source-code">struct regmap *devm_regmap_init_spi(struct spi_device *spi,</p>
			<p class="source-code">                            const struct regmap_config);</p>
			<p class="source-code">struct regmap *devm_regmap_init_i2c(struct i2c_client *i2c,</p>
			<p class="source-code">                            const struct regmap_config);</p>
			<p class="source-code">struct regmap * devm_regmap_init_mmio(</p>
			<p class="source-code">                        struct device *dev,</p>
			<p class="source-code">                        void __iomem *regs,</p>
			<p class="source-code">                        const struct regmap_config *config)</p>
			<p>These are resource-managed APIs whose allocated resources are automatically freed when the device leaves the system or when the driver is unloaded. In the preceding prototypes, the return value will be a pointer to a valid <strong class="source-inline">struct regmap</strong> object or an <strong class="source-inline">ERR_PTR()</strong> error on failure. <strong class="source-inline">regs</strong> is a pointer to a memory-mapped IO region (returned by <strong class="source-inline">devm_ioremap_resource()</strong> or any <strong class="source-inline">ioremap*</strong> family function). <strong class="source-inline">dev</strong> is the device (<strong class="source-inline">struct device</strong>) to interact with in the case of a memory-mapped <strong class="source-inline">regmap</strong>, and <strong class="source-inline">spi</strong> and <strong class="source-inline">i2c</strong> are respectively SPI or I2C devices to interact with in the case of SPI- or I2C-based <strong class="source-inline">regmap</strong>.</p>
			<p>Calling one of these functions is sufficient to start interacting with the underlying device. Whether the Regmap <a id="_idIndexMarker968"/>is an I2C, SPI, or a memory-mapped register map, if it has not been initialized with a resource managed API variant, it must be freed with the <strong class="source-inline">regmap_exit()</strong> function:</p>
			<p class="source-code">void regmap_exit(struct regmap *map)</p>
			<p>This function simply releases a previously allocated register map.</p>
			<p>Now that the register access method has been defined, we can jump to the device access functions, which allow reading from or writing into device registers.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor187"/>Using Regmap register access functions</h1>
			<p>Remap register access <a id="_idIndexMarker969"/>methods handle data parsing, formatting, and transmission. In most cases, device accesses are performed with <strong class="source-inline">regmap_read()</strong>, <strong class="source-inline">regmap_write()</strong>, and <strong class="source-inline">regmap_update_bits()</strong>, which are the three important APIs when it comes to writing/reading data into/from the device. Their respective prototypes are the following:</p>
			<p class="source-code">int regmap_read(struct regmap *map, unsigned int reg,</p>
			<p class="source-code">                 unsigned int *val);</p>
			<p class="source-code">int regmap_write(struct regmap *map, unsigned int reg,</p>
			<p class="source-code">                 unsigned int val);</p>
			<p class="source-code">int regmap_update_bits(struct regmap *map,</p>
			<p class="source-code">                 unsigned int reg, unsigned int mask,</p>
			<p class="source-code">                 unsigned int val);</p>
			<p><strong class="source-inline">regmap_write()</strong> writes data to the device. If set in <strong class="source-inline">regmap_config</strong>, <strong class="source-inline">max_register</strong> will be used to check whether the register address that needs to be accessed is greater or lower. If the register address passed is lower or equal to <strong class="source-inline">max_register</strong>, then the next operation will be performed; otherwise, the Regmap core will return an invalid I/O error (<strong class="source-inline">-EIO</strong>). Right after, the <strong class="source-inline">writeable_reg</strong> callback is called. The callback must return true before going to the next step. If it returns false, then <strong class="source-inline">-EIO</strong> is returned, and the write operation is stopped. If <strong class="source-inline">wr_table</strong> is set instead of <strong class="source-inline">writeable_reg</strong>, then the following happens: </p>
			<ul>
				<li>If the register <a id="_idIndexMarker970"/>address lies in <strong class="source-inline">no_ranges</strong>, then <strong class="source-inline">-EIO</strong> is returned.</li>
				<li>If the register address lies in <strong class="source-inline">yes_ranges</strong>, the next step is performed.</li>
				<li>If the register address is not present in <strong class="source-inline">yes_range</strong> or <strong class="source-inline">no_range</strong>, then <strong class="source-inline">-EIO</strong> is returned, and the operation is terminated.</li>
			</ul>
			<p>If <strong class="source-inline">cache_type != REGCACHE_NONE</strong>, then caching is enabled. In this case, the cache entry is first updated with the new value, and then a write to the hardware is performed. Otherwise, no caching action is performed. If the <strong class="source-inline">reg_write</strong> callback is provided, it is used to perform the write operation. Otherwise, the generic Regmap's write function will be executed to write the data into the specified register address.</p>
			<p><strong class="source-inline">regmap_read()</strong> reads data from the device. It works exactly like <strong class="source-inline">regmap_write()</strong> with appropriate data structures (<strong class="source-inline">readable_reg</strong> and <strong class="source-inline">rd_table</strong>). Therefore, if provided, <strong class="source-inline">reg_read</strong> is used to perform the read operation; otherwise, the generic register map read function will be performed.</p>
			<p><strong class="source-inline">regmap_update_bits()</strong> is a three-in-one function. It performs a read/modify/write cycle on the specified register address. It is a wrapper on <strong class="source-inline">_regmap_update_bits</strong>, which looks like the following:</p>
			<p class="source-code">static int _regmap_update_bits(struct regmap *map,</p>
			<p class="source-code">             unsigned int reg, unsigned int mask,</p>
			<p class="source-code">             unsigned int val, bool *change,</p>
			<p class="source-code">             bool force_write)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    unsigned int tmp, orig;</p>
			<p class="source-code">    if (change)</p>
			<p class="source-code">        *change = false;</p>
			<p class="source-code">    if (regmap_volatile(map, reg) &amp;&amp;</p>
			<p class="source-code">                   map-&gt;reg_update_bits) {</p>
			<p class="source-code">        ret = map-&gt;reg_update_bits(map-&gt;bus_context,</p>
			<p class="source-code">                                   reg, mask, val);</p>
			<p class="source-code">        if (ret == 0 &amp;&amp; change)</p>
			<p class="source-code">            *change = true;</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        ret = _regmap_read(map, reg, &amp;orig);</p>
			<p class="source-code">        if (ret != 0)</p>
			<p class="source-code">            return ret;</p>
			<p class="source-code">        tmp = orig &amp; ~mask;</p>
			<p class="source-code">        tmp |= val &amp; mask;</p>
			<p class="source-code">        if (force_write || (tmp != orig)) {</p>
			<p class="source-code">            ret = _regmap_write(map, reg, tmp);</p>
			<p class="source-code">            if (ret == 0 &amp;&amp; change)</p>
			<p class="source-code">                *change = true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p>This way, the bits <a id="_idIndexMarker971"/>you need to update must be set to <strong class="source-inline">1</strong> in <strong class="source-inline">mask</strong>, and corresponding bits should be set to the value you need to give to them in <strong class="source-inline">val</strong>. </p>
			<p>As an example, to set the first and third bits to <strong class="source-inline">1</strong>, <strong class="source-inline">mask</strong> should be <strong class="source-inline">0b00000101</strong>, and the value should be <strong class="source-inline">0bxxxxx1x1</strong>. To clear the seventh bit, <strong class="source-inline">mask</strong> must be <strong class="source-inline">0b01000000</strong> and the value should be <strong class="source-inline">0bx0xxxxxx</strong>, and so on.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor188"/>Bulk and multiple registers reading/writing APIs</h2>
			<p><strong class="source-inline">regmap_multi_reg_write()</strong> is one of the APIs that allows you to write multiple registers to the device. Its<a id="_idIndexMarker972"/> prototype looks like this:</p>
			<p class="source-code">int regmap_multi_reg_write(struct regmap *map,</p>
			<p class="source-code">                    const struct reg_sequence *regs,</p>
			<p class="source-code">                    int num_regs)</p>
			<p>In this prototype, <strong class="source-inline">regs</strong> is an array of elements of type <strong class="source-inline">reg_sequence</strong>, which represents register/value pairs for sequences of writes with an optional delay in microseconds to be applied after each write. The following is the definition of this data structure:</p>
			<p class="source-code">struct reg_sequence {</p>
			<p class="source-code">    unsigned int reg;</p>
			<p class="source-code">    unsigned int def;</p>
			<p class="source-code">    unsigned int delay_us;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">reg</strong> is the register address, <strong class="source-inline">def</strong> is the register value, and <strong class="source-inline">delay_us</strong> is the delay to be applied after the register write in microseconds.</p>
			<p>The following is a usage of such a sequence:</p>
			<p class="source-code">static const struct reg_sequence foo_default_regs[] = {</p>
			<p class="source-code">    { FOO_REG1,       0xB8 },</p>
			<p class="source-code">    { BAR_REG1,       0x00 },</p>
			<p class="source-code">    { FOO_BAR_REG1,   0x10 },</p>
			<p class="source-code">    { REG_INIT,       0x00 },</p>
			<p class="source-code">    { REG_POWER,      0x00 },</p>
			<p class="source-code">    { REG_BLABLA,     0x00 },</p>
			<p class="source-code">};</p>
			<p class="source-code">static int probe ( ...)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    ret = regmap_multi_reg_write(my_regmap,</p>
			<p class="source-code">                          foo_default_regs,</p>
			<p class="source-code">                          ARRAY_SIZE(foo_default_regs));</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>In the preceding, we have learned how to use our first multi-register write API, which takes a set of registers along with their values. </p>
			<p>There are also <strong class="source-inline">regmap_bulk_read()</strong> and <strong class="source-inline">regmap_bulk_write()</strong>, which can be used to read/write multiple registers<a id="_idIndexMarker973"/> from/to the device. Their<a id="_idIndexMarker974"/> usage fits for large blocks of data and they are defined as follows:</p>
			<p class="source-code">int regmap_bulk_read(struct regmap *map,</p>
			<p class="source-code">                     unsigned int reg, void *val,</p>
			<p class="source-code">                     size_tval_count);</p>
			<p class="source-code">int regmap_bulk_write(struct regmap *map,</p>
			<p class="source-code">                      unsigned int reg,</p>
			<p class="source-code">                      const void *val, size_t val_count);</p>
			<p>In the parameters in the preceding functions, <strong class="source-inline">map</strong> is the register map to operate on and <strong class="source-inline">reg</strong> is the register address from where the read/write operation must start. In the case of the read, <strong class="source-inline">val</strong> will contain the read value; it must be allocated to store at least the <strong class="source-inline">count</strong> value in the native register size for the device. In the case of the write operation, <strong class="source-inline">val</strong> must point to the data array to write to the device. Finally, <strong class="source-inline">count</strong> is the number of elements in <strong class="source-inline">val</strong>.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor189"/>Understanding the Regmap caching system</h2>
			<p>Obviously, Regmap supports <a id="_idIndexMarker975"/>data caching. Whether the cache system is used or not<a id="_idIndexMarker976"/> depends on the value of the <strong class="source-inline">cache_type</strong> field in <strong class="source-inline">regmap_config</strong>. Looking at <strong class="source-inline">include/linux/regmap.h</strong>, accepted values are as follows:</p>
			<p class="source-code">/* An enum of all the supported cache types */</p>
			<p class="source-code">enum regcache_type {</p>
			<p class="source-code">   REGCACHE_NONE,</p>
			<p class="source-code">   REGCACHE_RBTREE,</p>
			<p class="source-code">   REGCACHE_COMPRESSED,</p>
			<p class="source-code">   REGCACHE_FLAT,</p>
			<p class="source-code">};</p>
			<p>The cache type is set to <strong class="source-inline">REGCACHE_NONE</strong> by default, meaning that the cache is disabled. Other values simply define how the cache should be stored.</p>
			<p>Your device may have a predefined power-on reset value in certain registers. Those values can be stored in an array so that any read operation returns the value contained in the array. However, any write operation affects the real register in the device and updates the content in the array. It is a kind of a cache that we can use to speed up access to the device. That array is <strong class="source-inline">reg_defaults</strong>. Looking at the source, its structure looks like this:</p>
			<p class="source-code">struct reg_default {</p>
			<p class="source-code">    unsigned int reg;</p>
			<p class="source-code">    unsigned int def;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">reg</strong> is the register address and <strong class="source-inline">def</strong> is the register default value. <strong class="source-inline">reg_defaults</strong> is ignored if <strong class="source-inline">cache_type</strong> is set to none. If the <strong class="source-inline">default_reg</strong> element is not set but you still enable the cache, the corresponding cache structure will be created for you.</p>
			<p>It is quite simple to use. Just<a id="_idIndexMarker977"/> declare it and pass it as a parameter to the <strong class="source-inline">regmap_config</strong> structure. Let's <a id="_idIndexMarker978"/>have a look at the LTC3589 regulator driver in <strong class="source-inline">drivers/regulator/ltc3589.c</strong>:</p>
			<p class="source-code">static const struct reg_default ltc3589_reg_defaults[] = {</p>
			<p class="source-code">{ LTC3589_SCR1,   0x00 },</p>
			<p class="source-code">{ LTC3589_OVEN,   0x00 },</p>
			<p class="source-code">{ LTC3589_SCR2,   0x00 },</p>
			<p class="source-code">{ LTC3589_VCCR,   0x00 },</p>
			<p class="source-code">{ LTC3589_B1DTV1, 0x19 },</p>
			<p class="source-code">{ LTC3589_B1DTV2, 0x19 },</p>
			<p class="source-code">{ LTC3589_VRRCR,  0xff },</p>
			<p class="source-code">{ LTC3589_B2DTV1, 0x19 },</p>
			<p class="source-code">{ LTC3589_B2DTV2, 0x19 },</p>
			<p class="source-code">{ LTC3589_B3DTV1, 0x19 },</p>
			<p class="source-code">{ LTC3589_B3DTV2, 0x19 },</p>
			<p class="source-code">{ LTC3589_L2DTV1, 0x19 },</p>
			<p class="source-code">{ LTC3589_L2DTV2, 0x19 },</p>
			<p class="source-code">};</p>
			<p class="source-code">static const struct regmap_config ltc3589_regmap_config = {</p>
			<p class="source-code">        .reg_bits = 8,</p>
			<p class="source-code">        .val_bits = 8,</p>
			<p class="source-code">        .writeable_reg = ltc3589_writeable_reg,</p>
			<p class="source-code">        .readable_reg = ltc3589_readable_reg,</p>
			<p class="source-code">        .volatile_reg = ltc3589_volatile_reg,</p>
			<p class="source-code">        .max_register = LTC3589_L2DTV2,</p>
			<p class="source-code">        .reg_defaults = ltc3589_reg_defaults,</p>
			<p class="source-code">        .num_reg_defaults = ARRAY_SIZE(ltc3589_reg_defaults),</p>
			<p class="source-code">        .use_single_rw = true,</p>
			<p class="source-code">        .cache_type = REGCACHE_RBTREE,</p>
			<p class="source-code">};</p>
			<p>Any read operation on <a id="_idIndexMarker979"/>any one of the registers present in the array will immediately <a id="_idIndexMarker980"/>return the value in the array. However, a write operation will be performed on the device itself and will update the affected register in the array. This way, reading the <strong class="source-inline">LTC3589_VRRCR</strong> register will return <strong class="source-inline">0xff</strong> and write any value in that register, and it will update its entry in the array so that any new read operation will return the last written value directly from the cache.</p>
			<p>Now that we are able to use the Regmap APIs to access the device registers whatever the underlying bus is these devices sit on, the time has come for us to summarize the knowledge we have learned so far in a practical example.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor190"/>Regmap-based SPI driver example – putting it all together</h1>
			<p>All the steps involved in setting <a id="_idIndexMarker981"/>up Regmap, from configuration to device register access, can be enumerated as follows:</p>
			<ul>
				<li>Setting up a <strong class="source-inline">struct regmap_config</strong> object according to the device characteristics. Defining the register range if needed, default values if any, <strong class="source-inline">cache_type</strong> if needed, and so on. If custom read/write functions are needed, pass them to the <strong class="source-inline">reg_read</strong>/<strong class="source-inline">reg_write</strong> fields.</li>
				<li>In the <strong class="source-inline">probe</strong> function, allocating a register map using <strong class="source-inline">devm_regmap_init_i2c()</strong>, <strong class="source-inline">devm_regmap_init_spi()</strong>, or <strong class="source-inline">devm_regmap_init_mmio()</strong> depending on the connection with the underlying device – I2C, SPI, or memory-mapped.</li>
				<li>Whenever you need to read/write from/into registers, calling <strong class="source-inline">remap_[read|write]</strong> functions.</li>
				<li>When done with the register map, assuming you used resource-managed APIs, you have nothing else to do as devres core will take care of releasing the Regmap resources; otherwise, you'll have to call <strong class="source-inline">regmap_exit()</strong> to free the register map <a id="_idIndexMarker982"/>allocated in the probe.</li>
			</ul>
			<p>Let's now materialize these steps in a real driver example that takes advantage of the Regmap framework.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor191"/>A Regmap example</h2>
			<p>To achieve our <a id="_idIndexMarker983"/>goal, let's first describe a fake SPI device for which we can write a driver using the Regmap framework. For understandability, let's use the following characteristics:</p>
			<ul>
				<li>The device supports 8-bit register addressing and 8-bit register values.</li>
				<li>The maximum address that can be accessed in this device is <strong class="source-inline">0x80</strong> (it does not necessarily mean that this device has <strong class="source-inline">0x80</strong> registers).</li>
				<li>The write mask is <strong class="source-inline">0x80</strong>, and the valid address ranges are as follows:<ul><li><strong class="source-inline">0x20</strong> to <strong class="source-inline">0x4F</strong> </li><li><strong class="source-inline">0x60</strong> to <strong class="source-inline">0x7F</strong></li></ul></li>
				<li>Since the device supports simple SPI read/write operations, there is no need to provide a custom read/write function.</li>
			</ul>
			<p>Now that we are done with the device and the Regmap specifications, we can start writing the code. </p>
			<p>The following includes the required header to deal with Regmap:</p>
			<p class="source-code">#include &lt;linux/regmap.h&gt;</p>
			<p>Depending on the APIs needed in the driver, other headers might be included.</p>
			<p>Then, we define our private data structure as follows:</p>
			<p class="source-code">struct private_struct</p>
			<p class="source-code">{</p>
			<p class="source-code">    /* Feel free to add whatever you want here */</p>
			<p class="source-code">    struct regmap *map;</p>
			<p class="source-code">    int foo;</p>
			<p class="source-code">};</p>
			<p>Then, we <a id="_idIndexMarker984"/>define a read/write register range, that is, registers that are allowed to be accessed:</p>
			<p class="source-code">static const struct regmap_range wr_rd_range[] =</p>
			<p class="source-code">{</p>
			<p class="source-code">    {</p>
			<p class="source-code">            .range_min = 0x20,</p>
			<p class="source-code">            .range_max = 0x4F,</p>
			<p class="source-code">    },{</p>
			<p class="source-code">            .range_min = 0x60,</p>
			<p class="source-code">            .range_max = 0x7F</p>
			<p class="source-code">    },</p>
			<p class="source-code">}; </p>
			<p class="source-code">struct regmap_access_table drv_wr_table =</p>
			<p class="source-code">{</p>
			<p class="source-code">    .yes_ranges =   wr_rd_range,</p>
			<p class="source-code">    .n_yes_ranges = ARRAY_SIZE(wr_rd_range),</p>
			<p class="source-code">};</p>
			<p class="source-code">struct regmap_access_table drv_rd_table =</p>
			<p class="source-code">{</p>
			<p class="source-code">    .yes_ranges =   wr_rd_range,</p>
			<p class="source-code">    .n_yes_ranges = ARRAY_SIZE(wr_rd_range),</p>
			<p class="source-code">};</p>
			<p>However, it must be noted that if <strong class="source-inline">writeable_reg</strong> and/or <strong class="source-inline">readable_reg</strong> are set, there is no need to provide <strong class="source-inline">wr_table</strong> and/or <strong class="source-inline">rd_table</strong>.</p>
			<p>After that, we define the callback that will be called any time a register is accessed for a write or a read operation. Each callback must return true if it is allowed to perform the specified <a id="_idIndexMarker985"/>operation on the register:</p>
			<p class="source-code">static bool writeable_reg(struct device *dev,</p>
			<p class="source-code">                          unsigned int reg)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (reg&gt;= 0x20 &amp;&amp;reg&lt;= 0x4F)</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    if (reg&gt;= 0x60 &amp;&amp;reg&lt;= 0x7F)</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p class="source-code">static bool readable_reg(struct device *dev,</p>
			<p class="source-code">                         unsigned int reg)</p>
			<p class="source-code">{</p>
			<p class="source-code">    if (reg&gt;= 0x20 &amp;&amp;reg&lt;= 0x4F)</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    if (reg&gt;= 0x60 &amp;&amp;reg&lt;= 0x7F)</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p>Now that all <a id="_idIndexMarker986"/>Regmap-related operations have been defined, we can implement the driver's <strong class="source-inline">probe</strong> method as follows:</p>
			<p class="source-code">static int my_spi_drv_probe(struct spi_device *dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct regmap_config config;</p>
			<p class="source-code">    struct private_struct *priv;</p>
			<p class="source-code">    unsigned char data;</p>
			<p class="source-code">    /* setup the regmap configuration */</p>
			<p class="source-code">    memset(&amp;config, 0, sizeof(config));</p>
			<p class="source-code">    config.reg_bits = 8;</p>
			<p class="source-code">    config.val_bits = 8;</p>
			<p class="source-code">    config.write_flag_mask = 0x80;</p>
			<p class="source-code">    config.max_register = 0x80;</p>
			<p class="source-code">    config.fast_io = true;</p>
			<p class="source-code">    config.writeable_reg = drv_writeable_reg;</p>
			<p class="source-code">    config.readable_reg = drv_readable_reg;</p>
			<p class="source-code">    /* </p>
			<p class="source-code">     * If writeable_reg and readable_reg are set,</p>
			<p class="source-code">     * there is no need to provide wr_table nor rd_table.</p>
			<p class="source-code">     * Uncomment below code only if you do not want to use</p>
			<p class="source-code">     * writeable_reg nor readable_reg.</p>
			<p class="source-code">     */</p>
			<p class="source-code">    //config.wr_table = drv_wr_table;</p>
			<p class="source-code">    //config.rd_table = drv_rd_table;</p>
			<p class="source-code">    /* allocate the private data structures */</p>
			<p class="source-code">    /* priv = kzalloc */</p>
			<p class="source-code">    /* Init the regmap spi configuration */</p>
			<p class="source-code">    priv-&gt;map = devm_regmap_init_spi(dev, &amp;config);</p>
			<p class="source-code">    /* Use devm_regmap_init_i2c in case of i2c bus */</p>
			<p class="source-code">    /* </p>
			<p class="source-code">     * Let us write into some register</p>
			<p class="source-code">     * Keep in mind that, below operation will remain same</p>
			<p class="source-code">     * whether you use SPI, I2C, or memory mapped Regmap.</p>
			<p class="source-code">     * It is and advantage when you use regmap.</p>
			<p class="source-code">     */ </p>
			<p class="source-code">    regmap_read(priv-&gt;map, 0x30, &amp;data);</p>
			<p class="source-code">    [...] /* Process data */</p>
			<p class="source-code">    data = 0x24;</p>
			<p class="source-code">    regmap_write(priv-&gt;map, 0x23, data); /* write new value */</p>
			<p class="source-code">    /* set bit 2 (starting from 0) and bit 6</p>
			<p class="source-code">     * of register 0x44 */</p>
			<p class="source-code">    regmap_update_bits(priv-&gt;map, 0x44,</p>
			<p class="source-code">                       0b00100010, 0xFF);</p>
			<p class="source-code">    [...] /* Lot of stuff */     </p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>In the <a id="_idIndexMarker987"/>preceding <strong class="source-inline">probe</strong> method, there are even more commands than code. We simply needed to demonstrate how the device specification could be translated into a register map configuration and used as main access functions to the device registers.</p>
			<p>Now that we are done with Regmap from within the kernel, let's see how user space can make the most out of this framework in the next section.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor192"/>Leveraging Regmap from the user space</h1>
			<p>Register maps <a id="_idIndexMarker988"/>can be monitored from the user space via the debugfs file<a id="_idIndexMarker989"/> system. First, debugfs needs to be enabled via the <strong class="source-inline">CONFIG_DEBUG_FS</strong> kernel configuration option. Then, debugfs can be mounted using the following command:</p>
			<p class="source-code">mount -t debugfs none /sys/kernel/debug</p>
			<p>After that, the debugfs register map implementation can be found under <strong class="source-inline">/sys/kernel/debug/regmap/</strong>. This debugfs view implemented by <strong class="source-inline">drivers/base/regmap/regmap-debugfs.c</strong> in kernel sources contains a register cache (mirror) for drivers/peripherals based on the Regmap API.</p>
			<p>From the Regmap main debugfs directory, we can get the list of devices whose drivers are based on the Regmap API using the following command:</p>
			<p class="source-code">root@jetson-nano-devkit:~# ls -l /sys/kernel/debug/regmap/</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 4-003c-power-slave</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 4-0068</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 700e3000.mipical</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 702d3000.amx</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 702d3100.amx</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 hdaudioC0D3-hdaudio</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 tegra210-admaif</p>
			<p class="source-code">drwxr-xr-x   2 root  root   0 Jan  1  1970 tegra210-adx.0</p>
			<p class="source-code">[...]</p>
			<p class="source-code">root@jetson-nano-devkit:~#</p>
			<p>In each directory, there<a id="_idIndexMarker990"/> can be one or more of the <a id="_idIndexMarker991"/>following files:</p>
			<ul>
				<li><strong class="source-inline">access</strong>: An encoding of the various access permissions to each register in respect of the pattern <strong class="source-inline">readable writable volatile precious</strong>:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/access </strong></p><p class="source-code"><strong class="bold">00: y y y n</strong></p><p class="source-code"><strong class="bold">01: y y y n</strong></p><p class="source-code"><strong class="bold">02: y y y n</strong></p><p class="source-code"><strong class="bold">03: y y y n</strong></p><p class="source-code"><strong class="bold">04: y y y n</strong></p><p class="source-code"><strong class="bold">05: y y y n</strong></p><p class="source-code"><strong class="bold">06: y y y n</strong></p><p class="source-code"><strong class="bold">07: y y y n</strong></p><p class="source-code"><strong class="bold">08: y y y n</strong></p><p class="source-code"><strong class="bold">[...]</strong></p><p class="source-code"><strong class="bold">5c: y y y n</strong></p><p class="source-code"><strong class="bold">5d: y y y n</strong></p><p class="source-code"><strong class="bold">5e: y y y n</strong></p></li>
			</ul>
			<p>For example, the line <strong class="source-inline">5e: y y y n</strong> means that the register at address <strong class="source-inline">5e</strong> is readable, writeable, volatile, but not precious.</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The driver name associated with the register map. Check for the corresponding driver. For example, the <strong class="source-inline">702d3000.amx</strong> register map entry:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/702d3000.amx/name </strong></p><p class="source-code"><strong class="bold">tegra210-amx</strong></p></li>
			</ul>
			<p>There are, however, Regmap entries starting with <strong class="source-inline">dummy-</strong> as follows:</p>
			<p class="source-code"><strong class="bold">root@raspberrypi4-64:~# ls -l /sys/kernel/debug/regmap/</strong></p>
			<p class="source-code"><strong class="bold">drwxr-xr-x  2 root root 0 Jan 1 1970 dummy-avs-monitor@fd5d2000</strong></p>
			<p class="source-code"><strong class="bold">root@raspberrypi4-64:~#</strong></p>
			<p>This kind of entry<a id="_idIndexMarker992"/> is set when there are no <a id="_idIndexMarker993"/>associated <strong class="source-inline">/dev</strong> entries (<strong class="source-inline">devtmpfs</strong>). You can check this by printing the underlying device name, which will be <strong class="source-inline">nodev</strong> as follows:</p>
			<p class="source-code"><strong class="bold">root@raspberrypi4-64:~# cat /sys/kernel/debug/regmap/dummy-avs-monitor\@fd5d2000/name </strong></p>
			<p class="source-code"><strong class="bold">nodev</strong></p>
			<p class="source-code"><strong class="bold">root@raspberrypi4-64:~#</strong></p>
			<p>You can look for the suffix name after <strong class="source-inline">dummy-</strong> to find the relevant node in the device tree, for example, <strong class="source-inline">dummy-avs-monitor@fd5d2000</strong>:</p>
			<p class="source-code">avs_monitor: avs-monitor@7d5d2000 {</p>
			<p class="source-code">    compatible = "brcm,bcm2711-avs-monitor",</p>
			<p class="source-code">                 "syscon", "simple-mfd";</p>
			<p class="source-code">    reg = &lt;0x7d5d2000 0xf00&gt;;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<ul>
				<li><strong class="source-inline">cache_bypass</strong>: Puts the register map into cache-only mode. If enabled, writes to the register map will only update the hardware and not the cache directly:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/702d3000.amx/cache_bypass </strong></p><p class="source-code"><strong class="bold">N</strong></p></li>
			</ul>
			<p>To enable cache bypassing, you should echo <strong class="source-inline">Y</strong> in this file as follows:</p>
			<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# echo Y &gt; /sys/kernel/debug/regmap/702d30[579449.571475] tegra210-amx tegra210-amx.0: debugfs cache_bypass=Y forced</strong></p>
			<p class="source-code"><strong class="bold">00.amx/cache_bypass </strong></p>
			<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~#</strong></p>
			<p>This will <a id="_idIndexMarker994"/>additionally print a message in <a id="_idIndexMarker995"/>the kernel log buffer.</p>
			<ul>
				<li><strong class="source-inline">cache_dirty</strong>: Indicates that HW registers were reset to default values and that hardware registers do not match the cache state. The read value can be either <strong class="source-inline">Y</strong> or <strong class="source-inline">N</strong>.</li>
				<li><strong class="source-inline">cache_only</strong>: Echoing <strong class="source-inline">N</strong> in this file will disable caching for this register map and in the meantime, will trigger cache syncing, while writing <strong class="source-inline">Y</strong> will force registers in this register map to be cached only. Reading this file value will return <strong class="source-inline">Y</strong> or <strong class="source-inline">N</strong> according to the current caching enabled state. Any write happening while this value is true will be cached (only the register cache will be updated, no hardware changes will occur).</li>
				<li><strong class="source-inline">range</strong>: The valid register ranges of the register map:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/range </strong></p><p class="source-code"><strong class="bold">0-5e</strong></p></li>
				<li><strong class="source-inline">rbtree</strong>: Provides how much memory overhead the <strong class="source-inline">rbtree</strong> cache adds:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/rbtree </strong></p><p class="source-code"><strong class="bold">0-5e (95)</strong></p><p class="source-code"><strong class="bold">1 nodes, 95 registers, average 95 registers, used 175 bytes</strong></p></li>
				<li><strong class="source-inline">registers</strong>: The file <a id="_idIndexMarker996"/>used to read and write the<a id="_idIndexMarker997"/> actual registers associated with the register map:<p class="source-code"><strong class="bold">root@jetson-nano-devkit:~# cat /sys/kernel/debug/regmap/4-003c-power-slave/registers </strong></p><p class="source-code"><strong class="bold">00: d2</strong></p><p class="source-code"><strong class="bold">01: 1f</strong></p><p class="source-code"><strong class="bold">02: 00</strong></p><p class="source-code"><strong class="bold">03: dc</strong></p><p class="source-code"><strong class="bold">04: 0f</strong></p><p class="source-code"><strong class="bold">05: 00</strong></p><p class="source-code"><strong class="bold">06: 00</strong></p><p class="source-code"><strong class="bold">07: 00</strong></p><p class="source-code"><strong class="bold">08: 02</strong></p><p class="source-code"><strong class="bold">[...]</strong></p><p class="source-code"><strong class="bold">5c: 35</strong></p><p class="source-code"><strong class="bold">5d: 81</strong></p><p class="source-code"><strong class="bold">5e: 00</strong></p><p class="source-code"><strong class="bold">#</strong></p></li>
			</ul>
			<p>In the preceding output, the register address is shown first, then its content after.</p>
			<p>This section is quite short but is a concise description of Regmap monitoring from the user space. It allows reading and writing register content, and in some circumstances, changing the behavior of the underlying Regmap.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor193"/>Summary</h1>
			<p>This chapter is all about register access related Regmap APIs. Its simplicity should give you an idea of how useful and widely used it is. This chapter has shown everything you need to know about the Regmap API. Now you should be able to convert any standard SPI/I2C/memory-mapped driver into Regmap. </p>
			<p>The next chapter will cover IRQ management under Linux, however, two chapters after, we will cover IIO devices, a framework for analog-to-digital converters. Those kinds of devices always sit on top of SPI/I2C buses. It could be a challenge for us, at the end of that chapter, to write an IIO driver using the Regmap API.</p>
		</div>
	</body></html>