- en: Put On the Monitors Cap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring disk usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the execution time for a command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting information about logged in users, boot logs, and boot failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing the top ten CPU– consuming processes in an hour
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring command outputs with watch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging access to files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging with syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing log files with `logrotate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring user logins to find intruders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring remote disk usage health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining active user hours on a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring and optimizing power usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring disk activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking disks and filesystems for errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining disk health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting disk statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A computing system is a set of hardware and the software components that control
    it. The software includes the operating system kernel which allocates resources
    and many modules that perform individual tasks, ranging from reading disk data
    to serving web pages.
  prefs: []
  type: TYPE_NORMAL
- en: An administrator needs to monitor these modules and applications to confirm
    that they are working correctly and to understand whether resources need to be
    reallocated (moving a user partition to a larger disk, providing a faster network,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides both interactive programs for examining the system's current
    performance and modules for logging performance over time.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the commands that monitor system activity and discusses
    logging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring disk usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disk space is always a limited resource. We monitor disk usage to know when
    it's running low, then search for large files or folders to delete, move, or compress.
    This recipe illustrates disk monitoring commands.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `du` (disk usage) and `df` (disk free) commands report disk usage. These
    tools report what files and folders are consuming disk space and how much space
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find the disk space used by a file (or files), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the disk usage for all files inside a directory, along with the individual
    disk usage for each file shown in each line, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option outputs results for all files in the specified directory or
    directories recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Running `du DIRECTORY` will output a similar result, but it will show only the
    size consumed by subdirectories. However, this does not show the disk usage for
    each of the files. For printing the disk usage by files, `-a` is mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `du` command can be used on a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `du` command includes options to define how the data is reported.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying disk usage in KB, MB, or blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the disk usage command displays the total bytes used by a file.
    A more human-readable format is expressed in units such as KB, MB, or GB. The
    `-h` option displays the results in a human-readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the grand total sum of disk usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-c` option will calculate the total size used by files or directories,
    as well as display individual file sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use it like one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `-c` option can be used with options such as `-a` and `-h` to produce the
    usual output, with an extra line containing the total size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-s` option (summarize), will print the grand total as the output. The
    `-h` flag can be used with it to print in a human-readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Printing sizes in specified units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-b`, `-k`, and `-m` options will force `du` to print the disk usage in
    specified units. Note that these cannot be used with the `-h` option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the size in bytes (by default):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the size in kilobytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the size in megabytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the size in the given `BLOCK` size specified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, `BLOCK_SIZE` is specified in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the file size returned is not intuitively obvious. With the `-b`
    option, `du` reports the exact number of bytes in the file. With other options,
    `du` reports the amount of disk space used by the file. Since disk space is allocated
    in fixed-size chunks (commonly 4 K), the space used by a 400-byte file will be
    a single block (4 K):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Excluding files from the disk usage calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `--exclude` and `-exclude-from` options cause `du` to exclude files from
    the disk usage calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-exclude` option can be used with wildcards or a single filename:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `--exclude` option will exclude one file or files that match a pattern.
    The `-exclude-from` option allows more files or patterns to be excluded. Each
    filename or pattern must be on a single line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-max-depth` option restricts how many subdirectories du will examine.
    A depth of `1` calculates disk usage in the current directory. A depth of `2` calculates
    usage in the current directory and the next subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `-x` option limits `du` to a single filesystem. The default behavior for
    du is to follow links and mount points.
  prefs: []
  type: TYPE_NORMAL
- en: The `du` command requires read permission for all files, and read and execute
    for all directories. The `du` command will throw an error if the user running
    it does not have proper permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the ten largest size files from a given directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Combine the `du` and sort commands to find large files that should be deleted
    or moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` option makes du display the size of all the files and directories in
    the `SOURCE_DIR`. The first column of the output is the size. The `-k` option
    causes it to be displayed in kilobytes. The second column contains the file or
    folder name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-n` option to `sort` performs a numerical sort. The `-1` option specifies
    column `1` and the `-r` option reverses the sort order. The `head` command extracts
    the first ten lines from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the drawbacks of this one-liner is that it includes directories in the
    result. We can improve the one-liner to output only the large files with the `find`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The find command selects only filenames for du to process, rather than having
    du traverse the filesystem to select items to report.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the du command reports the number of bytes that a file requires. This
    is not necessarily the same as the amount of disk space the file is consuming.
    Space on the disk is allocated in blocks, so a 1-byte file will consume one disk
    block, usually between 512 and 4096 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The next section describes using the `df` command to determine how much space
    is actually available.
  prefs: []
  type: TYPE_NORMAL
- en: Disk free information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `du` command provides information about the usage, while `df` provides
    information about free disk space. Use `-h` with `df` to print the disk space
    in a human-readable format. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `df` command can be invoked with a folder name. In that case, it will report
    free space for the disk partition that contains that directory. This is useful
    if you don''t know which partition contains a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the execution time for a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Execution time is the criteria for analyzing an application's efficiency or
    comparing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `time` command measures an application's execution time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `time` command executes `APPLICATION`. When `APPLICATION` is complete, the
    `time` command reports the real, system, and user time statistics to `stderr`
    and sends the APPLICATION's normal output to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An executable binary of the `time` command is found in `/usr/bin/time`. If you
    are running bash, you'll get the shell built-in `time` by default. The shell built-in
    `time` has limited options. Use an absolute path (`/usr/bin/time`) to access the
    extended functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-o` option will write the time statistics to a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The filename must appear immediately after the `-o` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-a` flag can be used with `-o` to append the time statistics to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` option specifies the statistics to report and the format for the output.
    A format string includes one or more parameters prefixed with a `%`. Format parameters
    include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Real time: `%e`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User time: `%U`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System time: `%S`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System Page size: `%Z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a formatted output by combining these parameters with extra text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `%U` parameter specifies user time.
  prefs: []
  type: TYPE_NORMAL
- en: The **time** command sends the target application's output to `stdout` and the
    time command output to `stderr`. We can redirect the output with a redirection
    operator (`>`) and redirect the time information output with the (`2>`) error
    redirection operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The format command can report memory usage as well as timing information. The
    `%M` flag shows the maximum memory used in KB and `%Z` parameter causes the time
    command to report the system page size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the output of the target application is unimportant, so the
    standard output is directed to `/dev/null` rather than being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The time command reports these times by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real**: This is the wall clock time-the time from start to finish of the
    command. This is the elapsed time including time slices used by other processes
    and the time the process spends when blocked (for example, time spent waiting
    for I/O to complete).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: This is the amount of CPU time spent in user-mode code (outside the
    kernel) within the process. This is the CPU time used to execute the process.
    Other processes, and the time these processes spend when blocked do not count
    toward this figure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sys**: This is the amount of CPU time spent in the kernel within the process;
    the CPU time spent in system calls within the kernel, as opposed to the library
    code, which runs in the user space. Like user time, this is only the CPU time
    used by the process. Refer to the following table for a brief description of the
    kernel mode (also known as supervisor mode) and the system call mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many details regarding a process can be reported by the `time` command. These
    include exit status, number of signals received, and number of context switches
    made. Each parameter can be displayed when a suitable format string is supplied
    to the `-f` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the interesting parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%C` | This shows the name and command-line arguments of the command being
    timed. |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | This shows the average size of the process''s unshared data area,
    in kilobytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `%E` | This shows the elapsed real (wall clock) time used by the process
    in [hours:] minutes:seconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | This shows the exit status of the command. |'
  prefs: []
  type: TYPE_TB
- en: '| `%k` | This shows the number of signals delivered to the process. |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | This shows the number of times the process was swapped out of the
    main memory. |'
  prefs: []
  type: TYPE_TB
- en: '| `%Z` | This shows the system''s page size in bytes. This is a per-system
    constant, but varies between systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | This shows the percentage of the CPU that this job got. This is just
    user + system times divided by the total running time. It also prints a percentage
    sign. |'
  prefs: []
  type: TYPE_TB
- en: '| `%K` | This shows the average total (data + stack + text) memory usage of
    the process, in Kilobytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | This shows the number of times that the program was context-switched
    voluntarily, for instance, while waiting for an I/O operation to complete. |'
  prefs: []
  type: TYPE_TB
- en: '| `%c` | This shows the number of times the process was context-switched involuntarily
    (because the time slice expired). |'
  prefs: []
  type: TYPE_TB
- en: Collecting information about logged in users, boot logs, and boot failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux supports commands to report aspects of the runtime system including logged
    in users, how long the computer has been powered on, and boot failures. This data
    is used to allocate resources and diagnose problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe introduces the who, w, users, uptime, last, and lastb commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `who` command reports information about the current users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This output lists the login name, the TTY used by the users, login time, and
    remote hostname (or X display information) about logged in users.
  prefs: []
  type: TYPE_NORMAL
- en: '**TTY** (the term comes from **TeleTYpewriter**) is the device file associated
    with a text terminal that is created in `/dev` when a terminal is newly spawned
    by the user (for example, `/dev/pts/3`). The device path for the current terminal
    can be found out by executing the `tty` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `w` command provides more detailed information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This first line lists the current time, system uptime, number of users currently
    logged on, and the system load averages for the past 1, 5, and 15 minutes. Following
    this, the details about each login session are displayed with each line containing
    the login name, the TTY name, the remote host, login time, idle time, total CPU
    time used by the user since login, CPU time of the currently running process,
    and the command line of their current process.
  prefs: []
  type: TYPE_NORMAL
- en: Load average in the `uptime` command's output indicates system load. This is
    explained in more detail in [Chapter 10](20129291-0a5b-43a8-ad0c-54c74992d0e3.xhtml),
    *Administration Calls*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The users command lists only the name of logged-in users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If a user has multiple sessions open, either by logging in remotely several
    times or opening several terminal windows, there will be an entry for each session.
    In the preceding output, the `slynux` user has opened three terminals sessions.
    The easiest way to print unique users is to filter the output through `sort` and
    `uniq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `tr` command replaces each `' '` character with `'\n'`. Then a combination
    of `sort` and `uniq` reduces the list to a unique entry for each user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uptime` command reports how long the system has been powered on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The time that follows the `up` word is how long the system has been powered
    on. We can write a one-liner to extract the uptime only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This uses `sed` to replace the line of output with only the string between the
    word up and the comma before users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `last` command provides a list of users who have logged onto the system
    since the `/var/log/wtmp` file was created. This may go back a year or more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `last` command reports who logged in, what `tty` they were assigned, where
    they logged in from (IP address or local terminal), the login, logout, and session
    time. Reboots are marked as a login by a pseudo-user named `reboot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `last` command allows you to define a user to get only information about
    that user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'USER can be a real user or the pseudo-user `reboot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lastb` command will give you a list of the failed login attempts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `lastb` command must be run as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Both `last` and `lastb` report the contents of `/var/log/wtmp`. The default
    is to report month, day, and time of the event. However, there may be multiple
    years of data in that file, and the month/day can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-F` flag will report the full date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Listing the top ten CPU– consuming processes in an hour
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CPU is another resource that can be exhausted by a misbehaving process.
    Linux supports commands to identify and control the processes hogging the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command displays details about the processes running on the system.
    It reports details such as CPU usage, running commands, memory usage, and process
    status. The `ps` command can be used in a script to identify who consumed the
    most CPU resource over an hour. For more details on the `ps` command, refer to
    [Chapter 10](20129291-0a5b-43a8-ad0c-54c74992d0e3.xhtml), *Administration Calls*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This shell script monitors and calculates CPU usages for one hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CPU usage data is generated by the first loop that runs for one hour (3600
    seconds). Once each minute, the `ps -eocomm,pcpu` command generates a report on
    the system activity at that time. The `-e` option specifies to collect data on
    all processes, not just this session's tasks. The `-o` option specifies an output
    format. The `comm` and `pcpu` words specify reporting the command name and percentage
    of CPU, respectively. This `ps` command generates a line with the command name
    and current percentage of CPU usage for each running process. These lines are
    filtered with `grep` to remove lines where there was no CPU usage (%CPU is 0.0)
    and the `COMMAND %CPU` header. The interesting lines are appended to a temporary
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The temporary file is named `/tmp/cpu_usage.$$`. Here, `$$` is a script variable
    that holds the process ID (PID) of the current script. For example, if the script's
    PID is `1345`, the temporary file will be named `/tmp/cpu_usage.1345`.
  prefs: []
  type: TYPE_NORMAL
- en: The statistics file will be ready after one hour and will contain 60 sets of
    entries, corresponding to the system status at each minute. The `awk` script sums
    the total CPU usage for each process into an associative array named process.
    This array uses the process name as array index. Finally, `awk` sorts the result
    with a numeric reverse sort according to the total CPU usage and uses head to
    limit the report to the top 10 usage entries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using awk for advanced text processing* recipe of [Chapter 4](22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml),
    *Texting and Driving*, explains the `awk` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using head and tail for printing the last or first 10 lines* recipe of
    [Chapter 3](19219dcb-e034-408e-8fe2-db6daa9278c8.xhtml), *File In, File Out*,
    explains the `tail` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring command outputs with watch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The watch command will execute a command at intervals and display that command's
    output. You can use a terminal session and the screen command described in [chapter
    10](20129291-0a5b-43a8-ad0c-54c74992d0e3.xhtml), *Administration Calls* to create
    a customized dashboard to monitor your systems with watch.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `watch` command monitors the output of a command on the terminal at regular
    intervals. The syntax of the `watch` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This command will update the output at a default interval of two seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-n SECONDS` option defines the time interval for updating the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `watch` command can be used with any command that generates output. Some
    commands change their output frequently, and the changes are more important than
    the entire output. The watch command will highlight the difference between consecutive
    runs. Note that this highlight only lasts until the next update.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the differences in the watch output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-d` option highlights differences between successive runs of the command
    being watched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Logging access to files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many reasons you may need to be notified when a file is accessed.
    You might want to know when a file is modified so it can be backed up, or you
    might want to know when files in `/bin` are modified by a hacker.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `inotifywait` command watches a file or directory and reports when an event
    occurs. It doesn't come by default with every Linux distribution. You have to
    install the `inotify-tools` package. It requires the `inotify` support in the
    Linux kernel. Most new GNU/Linux distributions compile the `inotify` support into
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `inotify` command can monitor a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous script will log create, move, and delete events in the given path.
    The `-m` option causes watch to stay active and monitor changes continuously,
    rather than exiting after an event happens. The `-r` option enables a recursive
    watch of the directories (symbolic links are ignored). The `-e` option specifies
    the list of events to be watched and `-q` reduces the verbose messages and prints
    only the required ones. This output can be redirected to a log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The events that `inotifywait` can check include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `access` | When a read happens to a file |'
  prefs: []
  type: TYPE_TB
- en: '| `modify` | When file contents are modified |'
  prefs: []
  type: TYPE_TB
- en: '| `attrib` | When metadata is changed |'
  prefs: []
  type: TYPE_TB
- en: '| `move` | When a file undergoes a move operation |'
  prefs: []
  type: TYPE_TB
- en: '| `create` | When a new file is created |'
  prefs: []
  type: TYPE_TB
- en: '| `open` | When a file undergoes an open operation |'
  prefs: []
  type: TYPE_TB
- en: '| `close` | When a file undergoes a close operation |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | When a file is removed |'
  prefs: []
  type: TYPE_TB
- en: Logging with syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files related to daemons and system processes are located in the `/var/log`
    directory. These log files use a standard protocol called **syslog**, handled
    by the `syslogd` daemon. Every standard application makes use of `syslogd` to
    log information. This recipe describes how to use `syslogd` to log information
    from a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files help you deduce what is going wrong with a system. It is a good practice
    to log progress and actions with log file messages. The logger command will place
    data into log files with `syslogd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some of the standard Linux log files. Some distributions use different
    names for these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Log file** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/boot.log` | Boot log information |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/httpd` | Apache web server log |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/messages` | Post boot kernel information |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/auth.log``/var/log/secure` | User authentication log |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/dmesg` | System boot up messages |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/mail.log``/var/log/maillog` | Mail server log |'
  prefs: []
  type: TYPE_TB
- en: '| `/var/log/Xorg.0.log` | X server log |'
  prefs: []
  type: TYPE_TB
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `logger` command allows scripts to create and manage log messages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a message in the syslog file `/var/log/messages`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `/var/log/messages` log file is a general purpose log file. When the `logger`
    command is used, it logs to `/var/log/messages` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-t` flag defines a tag for the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `-p` option to logger and configuration files in `/etc/rsyslog.d` control
    where log messages are saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save to a custom file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new configuration file in `/etc/rsyslog.d`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a pattern for a priority and the log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the log daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` option will log the lines from another file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using head and tail for printing the last or first 10 lines* recipe of
    [Chapter 3](19219dcb-e034-408e-8fe2-db6daa9278c8.xhtml), *File In, File Out*,
    explains the head and tail commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing log files with logrotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files keep track of events on the system. They are essential for debugging
    problems and monitoring live machines. Log files grow as time passes and more
    events are recorded. Since the older data is less useful than the current data,
    log files are renamed when they reach a size limit and the oldest files are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `logrotate` command can restrict the size of the log file. The system logger
    facility appends information to the end of a log file without deleting earlier
    data. Thus a log file will grow larger over time. The `logrotate` command scans
    log files defined in the configuration file. It will keep the last 100 kilobytes
    (for example, specified S*IZE = 100 k*) from the log file and move the rest of
    the data (older log data) to a new file `logfile_name.1`. When the old-data file
    (`logfile_name.1`) exceeds `SIZE`, `logrotate` renames that file to `logfile_name.2`
    and starts a new `logfile_name.1`. The `logrotate` command can compress the older
    logs as `logfile_name.1.gz`, `logfile_name.2.gz`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The system's `logrotate` configuration files are held in `/etc/logrotate.d`.
    Most Linux distributions have many files in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a custom configuration for a log file (say `/var/log/program.log`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is a complete configuration. The `/var/log/program.log` string specifies
    the log file path. Logrotate will archive old logs in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `logrotate` command supports these options in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `missingok` | This ignores if the log file is missing and return without
    rotating the log. |'
  prefs: []
  type: TYPE_TB
- en: '| `notifempty` | This only rotates the log if the source log file is not empty.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size 30k` | This limits the size of the log file for which the rotation
    is to be made. It can be 1 M for 1 MB. |'
  prefs: []
  type: TYPE_TB
- en: '| `compress` | This enables compression with gzip for older logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `weekly` | This specifies the interval at which the rotation is to be performed.
    It can be weekly, yearly, or daily. |'
  prefs: []
  type: TYPE_TB
- en: '| `rotate 5` | This is the number of older copies of log file archives to be
    kept. Since 5 is specified, there will be `program.log.1.gz`, `program.log.2.gz`,
    and so on up to `program.log.5.gz`. |'
  prefs: []
  type: TYPE_TB
- en: '| `create 0600 root root` | This specifies the mode, user, and the group of
    the log file archive to be created. |'
  prefs: []
  type: TYPE_TB
- en: The options in the table are examples of what can be specified. More options
    can be defined in the `logrotate` configuration file. Refer to the man page at
    `http://linux.die.net/man/8/logrotate`, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring user logins to find intruders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files can be used to gather details about the state of the system and attacks
    on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a system connected to the Internet with SSH enabled. Many attackers
    are trying to log in to the system. We need to design an intrusion detection system
    to identify users who fail their login attempts. Such attempts may be of a hacker
    using a dictionary attack. The script should generate a report with the following
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: User that failed to log in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address of the attacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host mapping for the IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time when login attempts occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A shell script can scan the log files and gather the required information. Login
    details are recorded in `/var/log/auth.log` or `/var/log/secure`. The script scans
    the log file for failed login attempts and analyzes the data. It uses the `host`
    command to map the host from the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The intrusion detection script resembles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The output resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `intruder_detect.sh` script defaults to using `/var/log/auth.log` as input.
    Alternatively, we can provide a log file with a command-line argument. The failed
    logins are collected in a temporary file to reduce processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a login attempt fails, SSH logs lines are similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The script `greps` for the `Failed passw` string and puts those lines in `/tmp/failed.$$.log`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to extract the users who failed to login. The `awk` command
    extracts the fifth field from the end (the user name) and pipes that to sort and
    `uniq` to create a list of the users.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the unique IP addresses are extracted with a regular expression and the
    `egrep` command.
  prefs: []
  type: TYPE_NORMAL
- en: Nested for loops iterate through the IP address and users extracting the lines
    with each IP address and user combination. If the number of attempts for this
    IP/User combination is > 0, the time of the first occurrence is extracted with
    `grep`, head, and cut. If the number of attempts is > 1, then the last time is
    extracted using tail instead of head.
  prefs: []
  type: TYPE_NORMAL
- en: This login attempt is then reported with the formatted `printf` command.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the temporary file is removed.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring remote disk usage health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disks fill up and sometimes wear out. Even RAIDed storage systems can fail if
    you don't replace a faulty drive before the others fail. Monitoring the health
    of the storage systems is part of an administrator's job.
  prefs: []
  type: TYPE_NORMAL
- en: The job gets easier when an automated script checks the devices on the network
    and generates a one-line report, the date, IP address of the machine, device,
    capacity of device, used space, free space, percentage usage, and alert status.
    If the disk usage is under 80 percent, the drive status is reported as `SAFE`.
    If the drive is getting full and needs attention, the status is reported as `ALERT`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script uses SSH to log in to remote systems, collect disk usage statistics,
    and write them to a log file in the central machine. This script can be scheduled
    to run at a particular time.
  prefs: []
  type: TYPE_NORMAL
- en: The script requires a common user account on the remote machines so the `disklog`
    script can log in to collect data. We should configure auto-login with SSH for
    the common user (the *Password-less auto-login with SSH* recipe of [Chapter 8](5ba784d5-fa8b-4840-b4c5-cac906e484f9.xhtml),
    *The Old-Boy Network*, explains auto-login).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cron` utility will schedule the script to run at regular intervals. For
    example, to run the script every day at 10 a.m., write the following entry in
    `crontab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Run the `crontab -e` command and add the preceding line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the script manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the previous script resembles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `disklog.sh` script accepts the log file path as a command-line argument
    or uses the default log file. The `-e $logfile` checks whether the file exists
    or not. If the log file does not exist, it is initialized with a column header.
    The list of remote machine IP addresses can be hardcoded in `IP_LIST`, delimited
    with spaces, or the `nmap` command can be used to scan the network for available
    nodes. If you use the `nmap` call, adjust the IP address range for your network.
  prefs: []
  type: TYPE_NORMAL
- en: A for loop iterates through each of the IP addresses. The `ssh` application
    sends the `df -H` command to each node to retrieve the disk usage information.
    The `df` output is stored in a temporary file. A `while` loop reads that file
    line by line and invokes `awk` to extract the relevant data and output it. An
    `egrep` command extracts the percent full value and strips `%`. If this value
    is less than 80, the line is marked `SAFE`, else it's marked `ALERT`. The entire
    output string must be redirected to the `log` file. Hence, the `for` loop is enclosed
    in a subshell `()` and the standard output is redirected to the log file.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Scheduling with a cron* recipe in [Chapter 10](20129291-0a5b-43a8-ad0c-54c74992d0e3.xhtml),
    *Administration Calls*, explains the `crontab` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining active user hours on a system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe makes use of the system logs to find out how many hours each user
    has spent on the server and ranks them according to the total usage hours. A report
    is generated with the details, including rank, user, first logged in date, last
    logged in date, number of times logged in, and total usage hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The raw data about user sessions is stored in a binary format in the `/var/log/wtmp`
    file. The `last` command returns details about login sessions. The sum of the
    session hours for each user is that user's total usage hours.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This script will determine the active users and generate the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output resembles the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `active_users.sh` script reads from `/var/log/wtmp` or a `wtmp` log file
    defined on the command line. The `last -f` command extracts the log file contents.
    The first column in the log file is the username. The `cut` command extracts the
    first column from the log file. The `sort` and `uniq` commands reduce this to
    a list of unique users.
  prefs: []
  type: TYPE_NORMAL
- en: The script's outer loop iterates through the users. For each user, `grep` is
    used to extract the log lines corresponding to a particular user.
  prefs: []
  type: TYPE_NORMAL
- en: The last column of each line is the duration of this login session. These values
    are summed in the inner `while read t` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The session duration is formatted as `(HOUR:SEC)`. This value is extracted with
    awk to report the last field and then piped to `tr -d` to remove the parentheses.
    A second `awk` command converts the *HH::MM* string to minutes and the minutes
    are totaled. When the loop is complete, the total minutes are converted to hours
    by dividing `$minutes` with 60.
  prefs: []
  type: TYPE_NORMAL
- en: The first login time for a user is the last line in the temporary file of user
    data. This is extracted with tail and `awk`. The number of login sessions is the
    number of lines in this file, calculated with `wc`.
  prefs: []
  type: TYPE_NORMAL
- en: The users are sorted by the total usage hours with sort's `-nr` option for the
    numeric and descending order and `-k4` to specify the sort column (usage hour).
    Finally, the output of the sort is passed to `awk`, which prefixes each line with
    a line number representing the rank of each user.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring and optimizing power usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Battery capacity is a critical resource on mobile devices, such as notebook
    computers and tablets. Linux provides tools that measure power consumption, one
    such command is `powertop`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `powertop` application doesn't come preinstalled with many Linux distributions,
    you will have to install it using your package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `powertop` application measures per-module power consumption and supports
    interactively optimizing power consumption:'
  prefs: []
  type: TYPE_NORMAL
- en: 'With no options, `powertop` presents a display on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `powertop` command takes measurements and displays detailed information
    about power usage, the processes using the most power, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-html` tag will cause `powertop` to take measurements over a period of
    time and generate an HTML report with the default filename `PowerTOP.html`, which
    you can open using any web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In the interactive mode, you can optimize power usage. When `powertop` is running,
    use the arrow or tab keys to switch to the Tunables tab; this shows a list of
    attributes `powertop` can tune to for consuming less power. Choose the ones you
    want, press Enter to toggle from Bad to Good.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to monitor the power consumption from a portable device's battery,
    it is required to remove the charger and use the battery for `powertop` to make
    measurements.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring disk activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular naming convention for monitoring tools is to end the name with the
    `'top'` word (the command used to monitor processes). The tool to monitor disk
    I/O is called `iotop`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **iotop** application doesn't come preinstalled with most Linux distributions,
    you will have to install it using your package manager. The iotop application
    requires root privileges, so you'll need to run it as `sudo` or root user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `iotop` application can either perform continuous monitoring or generate
    reports for a fixed period:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For continuous monitoring, use the command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `-o` option tells `iotop` to show only those processes that are doing active
    I/O while it is running, which reduces the noise in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-n` option tells iotop to run for *N* times and exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-p` option monitors a specific process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`PID` is the process you wish to monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: In most modern distributions, instead of finding the PID and supplying it to
    `iotop`, you can use the `pidof` command and write the preceding command as follows: #
    iotop -p `pidof cp`
  prefs: []
  type: TYPE_NORMAL
- en: Checking disks and filesystems for errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux filesystems are incredibly robust. Despite that, a filesystem can become
    corrupted and data can be lost. The sooner you find a problem, the less data loss
    and corruption you need to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard tool for checking filesystems is `fsck`. This command is installed
    on all modern distributions. Note that you'll need to run `fsck` as root or via
    a `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux will run `fsck` automatically at boot time if the filesystem has been
    unchecked for a long time or there is a reason (unsafe reboot after a power glitch)
    to suspect it's been corrupted. You can run `fsck` manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for errors on a partition or filesystem, pass the path to `fsck`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-A` flag checks all the filesystems configured in `/etc/fstab`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This will go through the `/etc/fstab` file, checking each filesystem. The `fstab`
    file defines the mapping between physical disk partitions and mount points. It's
    used to mount filesystems during boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-a` option instructs `fsck` to automatically attempt to fix errors, instead
    of interactively asking us whether or not to repair them. Use this option with
    caution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-N` option simulates the actions `fsck` will perform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fsck` application is a frontend for filesystem specific `fsck` applications.
    When we run `fsck`, it detects the type of the filesystem and runs the appropriate
    `fsck.fstype` command, where `fstype` is the type of the filesystem. For example,
    if we run `fsck` on an `ext4` filesystem, it will end up calling the `fsck.ext4`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, `fsck` supports only the common options across all filesystem-specific
    tools. To find more detailed options, read the application specific man pages
    such as `fsck.ext4`.
  prefs: []
  type: TYPE_NORMAL
- en: It's very rare, but possible, for `fsck` to lose data or make a badly damaged
    filesystem worse. If you suspect severe corruption of a filesystem, you should
    use the `-N` option to list the actions that `fsck` will perform without actually
    performing them. If `fsck` reports more than a dozen problems it can fix or if
    these include damaged directory structures, you may want to mount the drive in
    the read-only mode and try to extract critical data before running `fsck`.
  prefs: []
  type: TYPE_NORMAL
- en: Examining disk health
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern disk drives run for years with no problems, but when a disk fails, it's
    a major disaster. Modern disk drives include a **Self-Monitoring, Analysis, and
    Reporting Technology** (**SMART**) facility to monitor the disk's health so you
    can replace an ailing drive before a major failure occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux supports interacting with the drives SMART utilities via the `smartmontools`
    package. This is installed by default on most distributions. If it''s not present,
    you can install it with your package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user interface to `smartmontools` is the `smartctl` application. This application
    initiates tests on the disk drive and reports the status of the SMART device.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `smartctl` application accesses the raw disk device, you must have
    root access to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-a` option reports the full status of a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be a header of basic information, a set of raw data values
    and the test results. The header includes details about the drive being tested
    and a datestamp for this report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The raw data values include error counts, spin-up time, power-on hours, and
    more. The last two columns (`WHEN_FAILED` and `RAW_VALUE`) are of particular interest.
    In the following sample, the device has been powered on 9823 hours. It was powered
    on and off 11 times (servers don''t get power-cycled a lot) and the current temperature
    is 30° C. When the value for power on gets close to the manufacturer''s **Mean
    Time Between Failures** (**MTBF**), it''s time to start considering replacing
    the drive or moving it to a less critical system. If the Power Cycle count increases
    between reboots, it could indicate a failing power supply or faulty cables. If
    the temperature gets high, you should consider checking the drive''s enclosure.
    A fan may have failed or a filter might be clogged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The last section of the output will be the results of the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-t` flag forces the SMART device to run the self-tests. These are non-destructive
    and can be run on a drive while it is in service. SMART devices can run a long
    or short test. A short test will take a few minutes, while the long test will
    take an hour or more on a large device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In a bit over two hours, this test will be completed and the results will be
    viewable with the `smartctl -a` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern disk drives are much more than a spinning metal disk. They include a
    CPU, ROM, memory, and custom signal processing chips. The `smartctl` command interacts
    with the small operating system running on the disk's CPU to requests tests and
    reports.
  prefs: []
  type: TYPE_NORMAL
- en: Getting disk statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `smartctl` command provides many disk statistics and tests the drives. The
    `hdparm` command provides more statistics and examines how the disk performs in
    your system, which may be influenced by controller chips, cables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hdparm` command is standard on most Linux distributions. You must have
    root access to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-I` option will provide basic information about your device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sample output shows some of the data reported. The model number
    and firmware are the same as reported by `smartctl`. The configuration includes
    parameters that can be tuned before a drive is partitioned and a filesystem is
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `hdparm` command is a user interface into the kernel libraries and modules.
    It includes support for modifying parameters as well as reporting them. Use extreme
    caution when changing these parameters!
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `hdparm` command can test a disk''s performance. The `-t` and `-T` options
    performs timing tests on buffered and cached reads, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
