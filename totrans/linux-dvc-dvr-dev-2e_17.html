<html><head></head><body>
		<div id="_idContainer062">
			<h1 id="_idParaDest-201"><em class="italic"><a id="_idTextAnchor203"/>Chapter 14</em>: Introduction to the Linux Device Model</h1>
			<p>Until version 2.5, the Linux kernel had no way to describe and manage objects, and its code reusability was not as enhanced as it is now. In other words, there was no device topology, nor organization as we know it is in sysfs nowadays. There was no information on subsystem relationships, nor on how the system is put together. Then came the <strong class="bold">Linux Device Model</strong> (<strong class="bold">LDM</strong>), which introduced the following features:</p>
			<ul>
				<li>The concept of classes. They are used to group devices of the same type or that expose the same functionalities (for example, mice and keyboards are both input devices).</li>
				<li>Communication with the user space through a virtual filesystem, allowing you to manage and enumerate devices and the properties they expose from user space.</li>
				<li>Object life cycle management using reference counting.</li>
				<li>A power management facility, allowing you to handle the order in which devices should shut down.</li>
				<li>The reusability of the code. Classes and frameworks expose interfaces, behaving like a contract that any driver that registers with them must respect.</li>
				<li>An <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>)-like programming style and encapsulation in the kernel.</li>
			</ul>
			<p>In this chapter, we will take advantage of LDM and export some properties to the user space through the sysfs filesystem. To do this, we will cover the following topics:</p>
			<ul>
				<li>Introduction to LDM data structures </li>
				<li>Getting deeper inside LDM</li>
				<li>Overview of the device model from sysfs</li>
			</ul>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor204"/>Introduction to LDM data structures</h1>
			<p>The Linux device model introduced<a id="_idIndexMarker1081"/> device hierarchy. It is built on top of a few data structures. Among these is the bus, which is represented in the kernel as an instance of <strong class="source-inline">struct bus_type</strong>; the device driver, which is represented by a <strong class="source-inline">struct device_driver</strong> structure; and the device, which is the last element and is represented as an instance of the <strong class="source-inline">struct device</strong> structure. In this section, we will introduce all those structures and learn how they interact each with other.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor205"/>The bus data structure</h2>
			<p>A bus is a channel link between<a id="_idIndexMarker1082"/> devices and the processor. The hardware entity that manages the bus and exports its protocol to devices<a id="_idIndexMarker1083"/> is called the bus controller. For example, the USB controller provides USB support, while the I2C controller<a id="_idIndexMarker1084"/> provides I2C bus support. However, the bus controller, being a device on its own, must be registered like any device. It will be the parent of the devices that need to sit on this bus. In other words, every device sitting on the bus must have its parent field pointing to the bus device. A bus is represented in the kernel by the <strong class="source-inline">struct bus_type</strong> structure, which has the following definition:</p>
			<p class="source-code">struct bus_type {</p>
			<p class="source-code">    const char        *name;</p>
			<p class="source-code">    const char        *dev_name;</p>
			<p class="source-code">    struct device     *dev_root;</p>
			<p class="source-code">    const struct attribute_group **bus_groups;</p>
			<p class="source-code">    const struct attribute_group **dev_groups;</p>
			<p class="source-code">    const struct attribute_group **drv_groups;</p>
			<p class="source-code">    int (*match)(struct device *dev,</p>
			<p class="source-code">                 struct device_driver *drv);</p>
			<p class="source-code">    int (*probe)(struct device *dev);</p>
			<p class="source-code">    void (*sync_state)(struct device *dev);</p>
			<p class="source-code">    int (*remove)(struct device *dev);</p>
			<p class="source-code">    void (*shutdown)(struct device *dev);</p>
			<p class="source-code">    int (*suspend)(struct device *dev, pm_message_t state);</p>
			<p class="source-code">    int (*resume)(struct device *dev);</p>
			<p class="source-code">    const struct dev_pm_ops *pm;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>Only the elements<a id="_idIndexMarker1085"/> that are relevant to this book have been listed here; let's take a look at them in more detail:</p>
			<ul>
				<li><strong class="source-inline">match</strong> is a callback that's invoked whenever a new device or driver is added to this bus. The callback must be smart enough and should return a nonzero value when there is a match between a device and a driver, both given as parameters. The main purpose of the <strong class="source-inline">match</strong> callback is to allow a bus to determine if a particular device can be handled by a given driver or the other logic if the given driver supports a given device. Most of the time, this verification is done by a simple string comparison (device and driver name, whether it's a table and device tree-compatible property, and so on). For enumerated devices (PCI, USB), verification is done by comparing the device IDs that are supported by the driver with the device ID of the given device, without sacrificing bus-specific functionality.</li>
				<li><strong class="source-inline">probe</strong> is a callback that's invoked when a new device or driver is added to this bus after the match has occurred. This function is responsible for allocating the specific bus device structure and calling the given driver's <strong class="source-inline">probe</strong> function, which is supposed to manage the device (allocated earlier).</li>
				<li><strong class="source-inline">remove</strong> is called when a device leaves this bus.</li>
				<li><strong class="source-inline">suspend</strong> is a method that's called when a device on the bus needs to be put into sleep mode. </li>
				<li><strong class="source-inline">resume</strong> is called when a device on the bus must be brought out of sleep mode.</li>
				<li><strong class="source-inline">pm</strong> is the set of power management operations for this bus, which may also call driver-specific power management operations.</li>
				<li><strong class="source-inline">drv_groups</strong> is a pointer to a list (array) of <strong class="source-inline">struct attribute_group</strong> elements, each of which<a id="_idIndexMarker1086"/> has a pointer to a list (array) of <strong class="source-inline">struct attribute</strong> elements. It represents the default attributes of the device drivers on the bus. The attributes that are passed to this field will be given to every driver that's registered with the bus. Those attributes can be found in the driver' directory in <strong class="source-inline">/sys/bus/&lt;bus-name&gt;/drivers/&lt;driver-name&gt;</strong>.</li>
				<li><strong class="source-inline">dev_groups</strong> represents the default attributes of the devices on the bus. Any attributes that are passed (through the list/array of <strong class="source-inline">struct attribute_group</strong> elements) to this field will be given to every device that's registered with the bus. Those attributes can be found in the device's directory in <strong class="source-inline">/sys/bus/&lt;bus-name&gt;/devices/&lt;device-name&gt;</strong>.</li>
				<li><strong class="source-inline">bus_group</strong> holds the set (group) of default attributes that are added automatically when the bus is registered with the core. </li>
			</ul>
			<p>Apart from defining <strong class="source-inline">bus_type</strong>, the bus driver must define a bus-specific driver structure that extends the generic <strong class="source-inline">struct device_driver</strong>, as well as a bus-specific device structure that extends the generic <strong class="source-inline">struct device</strong> structure. Both are part of the device model core. The bus driver must also allocate a bus-specific device structure for each physical device that's discovered when probing. It's also in charge of setting up the device's bus and parent fields, as well as registering them with the LDM core. These fields must point to the <strong class="source-inline">bus_type</strong> and the <strong class="source-inline">bus_device</strong> structures that are defined in the bus driver The LDM core uses them to build device hierarchy and initialize other fields.</p>
			<p>Each bus internally<a id="_idIndexMarker1087"/> manages two important lists: the list of devices that have been added and sitting on it, and the list of drivers that have been registered with it. Whenever you add/register or remove/unregister a device/driver with the bus, the corresponding list is updated<a id="_idIndexMarker1088"/> with the new entry. The bus driver must provide helper functions to register/unregister device drivers that can handle devices on that bus, as well as helper functions to register/unregister devices sitting on the bus. These helper functions always wrap the generic functions that are provided by the LDM core, which are <strong class="source-inline">driver_register()</strong>, <strong class="source-inline">device_register()</strong>, <strong class="source-inline">driver_unregister()</strong>, and <strong class="source-inline">device_unregister()</strong>.</p>
			<p>Now, let's start writing a new bus infrastructure called <strong class="source-inline">PACKT</strong>. <strong class="source-inline">PACKT</strong> is going to be our bus; the devices that will be sitting on this bus will be <strong class="source-inline">PACKT</strong> devices, while their drivers will be <strong class="source-inline">PACKT</strong> drivers. Let's start writing the helpers that will allow us to register the <strong class="source-inline">PACKT</strong> devices and drivers:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * Let's write and export symbols that people</p>
			<p class="source-code"> * writing drivers for packt devices must use.</p>
			<p class="source-code"> */</p>
			<p class="source-code">int packt_register_driver(struct packt_driver *driver)</p>
			<p class="source-code">{    </p>
			<p class="source-code">    driver-&gt;driver.bus = &amp;packt_bus_type;</p>
			<p class="source-code">    return driver_register(&amp;driver-&gt;driver);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL(packt_register_driver);</p>
			<p class="source-code">void packt_unregister_driver(struct packt_driver *driver)</p>
			<p class="source-code">{</p>
			<p class="source-code">    driver_unregister(&amp;driver-&gt;driver);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL(packt_unregister_driver);</p>
			<p class="source-code">int packt_register_device(struct packt_device *packt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    packt-&gt;dev.bus = &amp;packt_bus_type;</p>
			<p class="source-code">    return device_register(&amp;packt-&gt;dev);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL(packt_device_register);</p>
			<p class="source-code">void packt_unregister_device(struct packt_device *packt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    device_unregister(&amp;packt-&gt;dev);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL(packt_unregister_device);</p>
			<p>Now that we've created the registration<a id="_idIndexMarker1089"/> helpers, let's write the only function that allows us to allocate a new <strong class="source-inline">PACKT</strong> device and register this device with the <strong class="source-inline">PACKT</strong> core:</p>
			<p class="source-code">struct packt_device * packt_device_alloc(const char *name,</p>
			<p class="source-code">                                          int id)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct packt_device    *packt_dev;</p>
			<p class="source-code">    int                    status;</p>
			<p class="source-code">    packt_dev = kzalloc(sizeof(*packt_dev), GFP_KERNEL);</p>
			<p class="source-code">    if (!packt_dev)</p>
			<p class="source-code">        return NULL;</p>
			<p class="source-code">    /* devices on the bus are children of the bus device */</p>
			<p class="source-code">    strcpy(packt_dev-&gt;name, name);</p>
			<p class="source-code">    packt_dev-&gt;dev.id = id;</p>
			<p class="source-code">    dev_dbg(&amp;packt_dev-&gt;dev,</p>
			<p class="source-code">      "device [%s] registered with PACKT bus\n",</p>
			<p class="source-code">       packt_dev-&gt;name);</p>
			<p class="source-code">    return packt_dev;</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL_GPL(packt_device_alloc);</p>
			<p>The <strong class="source-inline">packt_device_alloc()</strong> function allocates a bus-specific device<a id="_idIndexMarker1090"/> structure that must be used to register a <strong class="source-inline">PACKT</strong> device with the bus. At this stage, we should expose the helpers that allow us to allocate a <strong class="source-inline">PACKT</strong> controller device and register it – that is, register a new <strong class="source-inline">PACKT</strong> bus. To do this, we must define the <strong class="source-inline">PACKT</strong> controller data structure, like so:</p>
			<p class="source-code">struct packt_controller {</p>
			<p class="source-code">    char name[48];</p>
			<p class="source-code">    struct device dev;    /* the controller device */</p>
			<p class="source-code">    struct list_head  list;</p>
			<p class="source-code">    int (*send_msg) (stuct packt_device *pdev,</p>
			<p class="source-code">                       const char *msg, int count);</p>
			<p class="source-code">    int (*recv_msg) (stuct packt_device *pdev,</p>
			<p class="source-code">                        char *dest, int count);</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">name</strong> represents the controller's name, <strong class="source-inline">dev</strong> represents the underlying struct device associated with this controller, <strong class="source-inline">list</strong> is used to insert this controller into the system's global list of <strong class="source-inline">PACKT</strong> controllers, and <strong class="source-inline">send_msg</strong> and <strong class="source-inline">recv_msg</strong> are hooks that must be provided<a id="_idIndexMarker1091"/> by the controller to access the <strong class="source-inline">PACKT</strong> devices that are sitting on it:</p>
			<p class="source-code">/* system global list of controllers */</p>
			<p class="source-code">static LIST_HEAD(packt_controller_list);</p>
			<p class="source-code">struct packt_controller</p>
			<p class="source-code">    *packt_alloc_controller(struct device *dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct packt_controller *ctlr;</p>
			<p class="source-code">    if (!dev)</p>
			<p class="source-code">        return NULL;</p>
			<p class="source-code">    ctlr = kzalloc(sizeof(packt_controller), GFP_KERNEL);</p>
			<p class="source-code">    if (!ctlr)</p>
			<p class="source-code">        return NULL;</p>
			<p class="source-code">    device_initialize(&amp;ctlr-&gt;dev);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return ctlr;</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL_GPL(packt_alloc_controller);</p>
			<p class="source-code">int packt_register_controller(</p>
			<p class="source-code">                           struct packt_controller *ctlr)</p>
			<p class="source-code">{</p>
			<p class="source-code">    /* must provide at least on hook */</p>
			<p class="source-code">if (!ctlr-&gt;send_msg &amp;&amp; !ctlr-&gt;recv_msg){</p>
			<p class="source-code">        pr_err("Registering PACKT controller failure\n");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    device_add(&amp;ctlr-&gt;dev);</p>
			<p class="source-code">    [...] /* other sanity check */</p>
			<p class="source-code">    list_add_tail(&amp;ctlr-&gt;list, &amp;packt_controller_list);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL_GPL(packt_register_controller);</p>
			<p>In these two functions, we have demonstrated what the controller allocation and registration<a id="_idIndexMarker1092"/> operations look like. The allocation method allocates memory and does some basic initialization, leaving room for the driver to do the rest. Note that after registering a controller, it will appear under <strong class="source-inline">/sys/devices</strong> in sysfs. Any devices that are added to this bus will appear under <strong class="source-inline">/sys/devices/packt-0/</strong>.</p>
			<h3>Bus registration</h3>
			<p>The bus controller<a id="_idIndexMarker1093"/> is a device itself, and in most cases, buses are memory-mapped platform devices (even buses are, which support device enumeration). For example, the PCI controller is a platform device and so is its respective driver. We should<a id="_idIndexMarker1094"/> use the <strong class="source-inline">bus_register(struct *bus_type)</strong> function to register a bus with the kernel. The <strong class="source-inline">PACKT</strong> bus structure looks as follows:</p>
			<p class="source-code">/* This is our bus structure */</p>
			<p class="source-code">struct bus_type packt_bus_type = {</p>
			<p class="source-code">    .name     = "packt",</p>
			<p class="source-code">    .match    = packt_device_match,</p>
			<p class="source-code">    .probe    = packt_device_probe,</p>
			<p class="source-code">    .remove   = packt_device_remove,</p>
			<p class="source-code">    .shutdown = packt_device_shutdown,</p>
			<p class="source-code">};</p>
			<p>Now that the basic bus operations have been defined, we need to register the <strong class="source-inline">PACKT</strong> bus framework and make it available for both the controller and slave drivers. The bus controller is a device itself; it must be registered with the kernel and will be used as the parent of the device that's sitting on the bus. This is done<a id="_idIndexMarker1095"/> in the bus controller's probe or <strong class="source-inline">init</strong> function. In the case of the <strong class="source-inline">PACKT</strong> bus, the code would be as follows:</p>
			<p class="source-code">static int __init packt_init(void)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int status;</p>
			<p class="source-code">    status = bus_register(&amp;packt_bus_type);</p>
			<p class="source-code">    if (status &lt; 0)</p>
			<p class="source-code">        goto err0;</p>
			<p class="source-code">    status = class_register(&amp;packt_master_class);</p>
			<p class="source-code">    if (status &lt; 0)</p>
			<p class="source-code">        goto err1;</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">err1:</p>
			<p class="source-code">    bus_unregister(&amp;packt_bus_type);</p>
			<p class="source-code">err0:</p>
			<p class="source-code">    return status;</p>
			<p class="source-code">}</p>
			<p class="source-code">postcore_initcall(packt_init);</p>
			<p>When a device is registered by the bus controller driver, the <strong class="source-inline">parent</strong> member of the device must point to the bus controller device (this should be done by the device driver) and its <strong class="source-inline">bus</strong> property must point to the <strong class="source-inline">PACKT</strong> bus type (this is done by the core) to build the physical device tree. To register a <strong class="source-inline">PACKT</strong> device, you must call <strong class="source-inline">packt_device_register()</strong>, which should take as an argument a <strong class="source-inline">PACKT</strong> device allocated with <strong class="source-inline">packt_device_alloc()</strong>:</p>
			<p class="source-code">int packt_device_register(struct packt_device *packt)</p>
			<p class="source-code">{</p>
			<p class="source-code">    packt-&gt;dev.bus = &amp;packt_bus_type;</p>
			<p class="source-code">    return device_register(&amp;packt-&gt;dev);</p>
			<p class="source-code">}</p>
			<p class="source-code">EXPORT_SYMBOL(packt_device_register);</p>
			<p>Now that we are done<a id="_idIndexMarker1096"/> with bus registration, let's look at the driver's infrastructure and see how it is designed.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>The driver data structure</h2>
			<p>A driver is a set of methods<a id="_idIndexMarker1097"/> that allow us to drive a given device. A global device hierarchy allows all the system's devices to be represented in the same way. This makes it simple<a id="_idIndexMarker1098"/> for the core to navigate the device tree and perform tasks such as properly ordered power management transitions.</p>
			<p>Each device driver is represented as an instance of <strong class="source-inline">struct device_driver</strong>, which is defined like so:</p>
			<p class="source-code">struct device_driver {</p>
			<p class="source-code">    const char        *name;</p>
			<p class="source-code">    struct bus_type   *bus;</p>
			<p class="source-code">    struct module     *owner;</p>
			<p class="source-code">    const struct of_device_id   *of_match_table;</p>
			<p class="source-code">    const struct acpi_device_id  *acpi_match_table;</p>
			<p class="source-code">    int (*probe) (struct device *dev);</p>
			<p class="source-code">    int (*remove) (struct device *dev);</p>
			<p class="source-code">    void (*shutdown) (struct device *dev);</p>
			<p class="source-code">    int (*suspend) (struct device *dev,</p>
			<p class="source-code">                    pm_message_t state);</p>
			<p class="source-code">    int (*resume) (struct device *dev);</p>
			<p class="source-code">    const struct attribute_group **groups;</p>
			<p class="source-code">    const struct dev_pm_ops *pm;</p>
			<p class="source-code">};</p>
			<p>Let's look at the elements<a id="_idIndexMarker1099"/> in this data structure:</p>
			<ul>
				<li><strong class="source-inline">name</strong> represents the driver's name. It can be used for matching, by comparing it with the device's name.</li>
				<li><strong class="source-inline">bus</strong> represents the bus where this driver sits on. The <strong class="source-inline">bus</strong> driver must fill this field.</li>
				<li><strong class="source-inline">module</strong> represents the module that owns this driver. In 99% of cases, you must set this field to <strong class="source-inline">THIS_MODULE</strong>.</li>
				<li><strong class="source-inline">of_match_table</strong> is a pointer to the array of <strong class="source-inline">struct of_device_id</strong>. The <strong class="source-inline">struct of_device_id</strong> structure is used to perform open firmware matches through a special file called the device tree, which is passed<a id="_idIndexMarker1100"/> to the kernel during the boot process:<p class="source-code">struct of_device_id {</p><p class="source-code">    char       compatible[128];</p><p class="source-code">    const void *data;</p><p class="source-code">};</p></li>
				<li><strong class="source-inline">suspend</strong> and <strong class="source-inline">resume</strong> are power management callbacks that are invoked to put the device to sleep or wake it up from a sleep state, respectively. The <strong class="source-inline">remove</strong> callback is called when the device is physically removed from the system or when its reference count reaches <strong class="source-inline">0</strong>. The <strong class="source-inline">remove</strong> callback is also called during system reboot.</li>
				<li><strong class="source-inline">probe</strong> is the probe callback that runs when you're attempting to bind a driver to a device. The bus driver is in charge of calling the device driver's probe function.</li>
				<li><strong class="source-inline">group</strong> is a pointer to a list (array) of <strong class="source-inline">struct attribute_group</strong> and is used as a default<a id="_idIndexMarker1101"/> attribute for the driver. Prefer this method instead of creating an attribute separately.</li>
			</ul>
			<p>Now that we are familiar with the driver data structure and all its elements, let's learn what APIs the kernel provides so that we can register it.</p>
			<h3>Driver registration</h3>
			<p>The low-level <strong class="source-inline">driver_register()</strong> function is used to register a device driver with the bus<a id="_idIndexMarker1102"/> and it is added to the bus's driver list. When a device driver registers with the bus, the core travels through the list of devices on this same bus and calls the bus's match callback for each device that does not have a driver. It does this to find out if there are any devices that the driver can handle.</p>
			<p>The following is the declaration of our driver infrastructure:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * Bus specific driver structure</p>
			<p class="source-code"> * You should provide your device's probe</p>
			<p class="source-code"> * and remove functions.</p>
			<p class="source-code"> */</p>
			<p class="source-code">struct packt_driver {</p>
			<p class="source-code">    int     (*probe)(struct packt_device *packt);</p>
			<p class="source-code">    int     (*remove)(struct packt_device *packt);</p>
			<p class="source-code">    void    (*shutdown)(struct packt_device *packt);</p>
			<p class="source-code">    struct device_driver driver;</p>
			<p class="source-code">    const struct i2c_device_id *id_table;</p>
			<p class="source-code">};</p>
			<p class="source-code">#define to_packt_driver(d) \</p>
			<p class="source-code">        container_of(d, struct packt_driver, driver)</p>
			<p class="source-code">#define to_packt_device(d) container_of(d, \</p>
			<p class="source-code">                             struct packt_device, dev)</p>
			<p>In our example, there are two helper macros to get the <strong class="source-inline">PACKT</strong> device and the <strong class="source-inline">PACKT</strong> driver, given a generic <strong class="source-inline">struct device</strong> or <strong class="source-inline">struct driver</strong>.</p>
			<p>Then comes the structure<a id="_idIndexMarker1103"/> that's used to identify a <strong class="source-inline">PACKT</strong> device, which is defined as follows:</p>
			<p class="source-code">struct packt_device_id {</p>
			<p class="source-code">    char name[PACKT_NAME_SIZE];</p>
			<p class="source-code">    kernel_ulong_t driver_data;   /* Data private to the driver */</p>
			<p class="source-code">};</p>
			<p>The device and the device driver are bound together when they match. Binding is the process of associating a device with a device driver, and it is performed by the bus framework.</p>
			<p>Now, let's get back to registering our drivers with our <strong class="source-inline">PACKT</strong> bus. The drivers must use <strong class="source-inline">packt_register_driver(struct packt_driver *driver)</strong>, which is a wrapper around <strong class="source-inline">driver_register()</strong>. The <strong class="source-inline">driver</strong> parameter must have been filled in before registering the <strong class="source-inline">PACKT</strong> driver. The LDM core provides helper functions for iterating over the list of drivers that have been registered with the bus:</p>
			<p class="source-code">int bus_for_each_drv(struct bus_type * bus,</p>
			<p class="source-code">                struct device_driver * start, void * data,</p>
			<p class="source-code">                int (*fn)(struct device_driver *, void *));</p>
			<p>This helper iterates<a id="_idIndexMarker1104"/> over the bus's list of drivers and calls the <strong class="source-inline">fn</strong> callback for each driver in the list.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor207"/>The device data structure </h2>
			<p><strong class="source-inline">struct device</strong> is the generic data structure<a id="_idIndexMarker1105"/> that's used to describe and characterize each device on the system, whether it is physical or not. It contains details about the physical attributes of the device and provides proper linkage information to help build suitable device trees and reference counting:</p>
			<p class="source-code">struct device {</p>
			<p class="source-code">    struct device *parent;</p>
			<p class="source-code">    struct kobject kobj;</p>
			<p class="source-code">    const struct device_type *type;</p>
			<p class="source-code">    struct bus_type      *bus;</p>
			<p class="source-code">    struct device_driver *driver;</p>
			<p class="source-code">    void    *platform_data;</p>
			<p class="source-code">    void    *driver_data;</p>
			<p class="source-code">    struct device_node      *of_node;</p>
			<p class="source-code">    struct class *class;</p>
			<p class="source-code">    const struct attribute_group **groups;</p>
			<p class="source-code">    void    (*release)(struct device *dev);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>The preceding data structure has been shortened for the sake of readability. That said, let's take a look at the elements<a id="_idIndexMarker1106"/> that have been provided:</p>
			<ul>
				<li><strong class="source-inline">parent</strong> represents the device's parent and is used to build the device tree hierarchy. When registered with a bus, the bus driver is responsible for setting this field with the bus device.</li>
				<li><strong class="source-inline">bus</strong> represents the bus where this device sits. The bus driver must fill this field.</li>
				<li><strong class="source-inline">type</strong> identifies the device's type.</li>
				<li><strong class="source-inline">kobj</strong> is the kobject and handles reference counting and device model support.</li>
				<li><strong class="source-inline">of_node</strong> is a pointer to the open firmware (device tree) node associated with the device. It is up to the bus driver to set this field.</li>
				<li><strong class="source-inline">platform_data</strong> is a pointer to the platform data that's specific to the device. It's usually declared in a board-specific file during device provisioning.</li>
				<li><strong class="source-inline">driver_data</strong> is a pointer to private data for the driver.</li>
				<li><strong class="source-inline">class</strong> is a pointer to the class that this device belongs to.</li>
				<li><strong class="source-inline">group</strong> is a pointer to a list (array) of <strong class="source-inline">struct attribute_group</strong> and is used as the default attributes for the device. You should use this instead of creating the attributes separately.</li>
				<li><strong class="source-inline">release</strong> is a callback that's called when the device reference count reaches zero. The bus has the responsibility<a id="_idIndexMarker1107"/> of setting up this field. The <strong class="source-inline">PACKT</strong> bus driver shows you how to do that.</li>
			</ul>
			<p>Now that we have described the device's structure, let's learn how to make it part of the system by registering it.</p>
			<h3>Device registration</h3>
			<p><strong class="source-inline">device_register()</strong> is a function that's provided by the LDM core<a id="_idIndexMarker1108"/> to register a device with the bus. After this call, the bus's list of drivers is iterated over to find the driver that supports this device; then, this device is added to the bus's device list. <strong class="source-inline">device_register()</strong> internally calls <strong class="source-inline">device_add()</strong>:</p>
			<p class="source-code">int device_add(struct device *dev)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    bus_probe_device(dev);</p>
			<p class="source-code">        if (parent)</p>
			<p class="source-code">                klist_add_tail(&amp;dev-&gt;p-&gt;knode_parent,</p>
			<p class="source-code">                            &amp;parent-&gt;p-&gt;klist_children);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>The helper function that's provided by the kernel<a id="_idIndexMarker1109"/> to iterate over the bus's device list is <strong class="source-inline">bus_for_each_dev</strong>. It's defined as follows:</p>
			<p class="source-code">int bus_for_each_dev(struct bus_type * bus,</p>
			<p class="source-code">                    struct device * start, void * data,</p>
			<p class="source-code">                    int (*fn)(struct device *, void *));</p>
			<p>Whenever a device is added, the core invokes the matching method of the bus driver (<strong class="source-inline">bus_type-&gt;match</strong>). If the matching function succeeds, the core will invoke the probing function of the bus driver (<strong class="source-inline">bus_type-&gt;probe</strong>), given that both the device and driver matched as parameters. Then, it is up to the bus driver to invoke the probing method of the device's driver (that is, <strong class="source-inline">driver-&gt;probe</strong>). For our <strong class="source-inline">PACKT</strong> bus driver, the function that's used to register a device is <strong class="source-inline">packt_device_register(struct packt_device *packt)</strong>, which internally calls <strong class="source-inline">device_register()</strong>. Here, the parameter is a <strong class="source-inline">PACKT</strong> device that's been allocated with <strong class="source-inline">packt_device_alloc()</strong>.</p>
			<p>The bus-specific device data structure is then defined as follows:</p>
			<p class="source-code">/*</p>
			<p class="source-code"> * Bus specific device structure</p>
			<p class="source-code"> * This is what a PACKT device structure looks like</p>
			<p class="source-code"> */</p>
			<p class="source-code">struct packt_device {</p>
			<p class="source-code">    struct module        *owner;</p>
			<p class="source-code">    unsigned char        name[30];</p>
			<p class="source-code">    unsigned long        price;</p>
			<p class="source-code">    struct device        dev;</p>
			<p class="source-code">};</p>
			<p>In the preceding code, <strong class="source-inline">dev</strong> is the underlying <strong class="source-inline">struct device</strong> structure for the device model, while <strong class="source-inline">name</strong> is the name<a id="_idIndexMarker1110"/> of the device. </p>
			<p>Now that we have defined the data structure, let's learn about the underlying mechanisms of LDM. </p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Getting deeper inside LDM</h1>
			<p>So far, we have discussed buses, drivers, and devices, which were used to build the system device topology. While<a id="_idIndexMarker1111"/> this is true, the previous topics were the tip of the iceberg. Under the hood, LDM relies on the three lowest level data structures, which are <strong class="source-inline">kobject</strong>, <strong class="source-inline">kobj_type</strong>, and <strong class="source-inline">kset</strong>. These are used to link the objects.</p>
			<p>Before we go any further, let's define some of the terms that will be used throughout this chapter:</p>
			<ul>
				<li><strong class="bold">sysfs</strong>: sysfs is an in-memory<a id="_idIndexMarker1112"/> virtual filesystem that shows the hierarchy of kernel objects, abstracted by instances of <strong class="source-inline">struct kobject</strong>.</li>
				<li><strong class="bold">Attribute</strong>: An attribute (or sysfs attribute) appears<a id="_idIndexMarker1113"/> as a file in sysfs. From within the kernel, it can be mapped to anything: a variable, a device property, a buffer, or anything useful to the driver that may need to be exported to the world.</li>
			</ul>
			<p>In this section, we will learn how each of these structures is involved in the device model.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor209"/>Understanding the kobject structure</h2>
			<p><strong class="source-inline">struct kobject</strong>, which means kernel<a id="_idIndexMarker1114"/> object (also abbreviated as <strong class="bold">kobject</strong> throughout this chapter) is the core data structure of the device model as it is the core of the concepts behind the sysfs. For each directory that's found in sysfs, there is a <strong class="source-inline">struct kobject</strong> wandering around somewhere within the kernel. Additionally, a kobject can export<a id="_idIndexMarker1115"/> one or more attributes, which appear in that Kobject's sysfs directory as files. Now, let's get back to the code – <strong class="source-inline">struct kobject</strong> is defined in the kernel like so:</p>
			<p class="source-code">struct kobject {</p>
			<p class="source-code">    const char              *name;</p>
			<p class="source-code">    struct list_head        entry;</p>
			<p class="source-code">    struct kobject          *parent;</p>
			<p class="source-code">    struct kset             *kset;</p>
			<p class="source-code">    struct kobj_type        *ktype;</p>
			<p class="source-code">    struct sysfs_dirent     *sd;</p>
			<p class="source-code">    struct kref             kref;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, only the main elements<a id="_idIndexMarker1116"/> have been listed. Let's take a look at them in more detail:</p>
			<ul>
				<li><strong class="source-inline">name</strong> is the name of this kobject. It can be modified using the <strong class="source-inline">kobject_set_name(struct kobject *kobj, const char *name)</strong> function. It is used as the name of this <strong class="source-inline">kobject</strong> directory.</li>
				<li><strong class="source-inline">parent</strong> is a pointer to another kobject, which is considered the parent of this kobject. It is used to build topologies and to describe the relationship between objects.</li>
				<li><strong class="source-inline">sd</strong> points to a <strong class="source-inline">struct sysfs_dirent</strong> structure that represents the directory of this kobject in sysfs. <strong class="source-inline">name</strong> will be used as the name of this directory. If <strong class="source-inline">parent</strong> is set, then this directory will be a sub-directory in the parent's directory.</li>
				<li><strong class="source-inline">kref</strong> provides reference counting for the kobject. It helps track whether an object is still in use or not and potentially releases it if it's not being used anymore. Alternatively, it can prevent it from being removed if it's still in use. When it's used from within a kernel object, its initial value is <strong class="source-inline">1</strong>.</li>
				<li><strong class="source-inline">ktype</strong> describes the kobject. Every kobject is given a set of default attributes when it is created. The <strong class="source-inline">ktype</strong> element, which belongs to the <strong class="source-inline">struct kobj_type</strong> structure, is used to specify these default attributes. Such a structure allows kernel objects to share common operations (<strong class="source-inline">sysfs_ops</strong>), whether those objects<a id="_idIndexMarker1117"/> are functionally related or not.</li>
				<li><strong class="source-inline">kset</strong> tells us which set (group) of objects this object belongs to.</li>
			</ul>
			<p>Before a kobject can be used, it must be (exclusively) dynamically allocated and then initialized. To do so, drivers<a id="_idIndexMarker1118"/> can use the <strong class="source-inline">kzalloc()</strong> (or <strong class="source-inline">kmalloc()</strong>) or <strong class="source-inline">kobject_create()</strong> function. With <strong class="source-inline">kzalloc()</strong>, the object is allocated and empty and must be initialized using another API, <strong class="source-inline">kobject_init()</strong>.  With <strong class="source-inline">kobject_create()</strong>, allocation and initialization are implicit. These APIs are defined as follows:</p>
			<p class="source-code">void kobject_init(struct kobject *kobj,</p>
			<p class="source-code">                  struct kobj_type *ktype)</p>
			<p class="source-code">struct kobject *kobject_create(void)</p>
			<p>In the preceding code, <strong class="source-inline">kobject_init()</strong> expects, in its first parameter, a kobject that has been initially allocated, via <strong class="source-inline">kzalloc()</strong> for example. The second parameter, <strong class="source-inline">ktype</strong>, is mandatory, so it can't be <strong class="source-inline">NULL</strong>; otherwise, the kernel will complain (<strong class="source-inline">dump_stack()</strong>). <strong class="source-inline">kobject_create()</strong>, on the other hand, expects nothing; it does allocation and initialization implicitly (it calls <strong class="source-inline">kzalloc()</strong> and <strong class="source-inline">kobject_init()</strong> internally). On success, it returns a freshly initialized kobject object.</p>
			<p>Once a kobject has been initialized, the driver can use <strong class="source-inline">kobject_add()</strong> to link this object with the system, creating a sysfs directory entry for this kobject. Where this directory will be created depends on the parent element of the kobject being set or not. That said, if this parent is not set, it can be specified while adding the kobject to the system using <strong class="source-inline">kobject_add()</strong>, which is defined as follows:</p>
			<p class="source-code">int kobject_add(struct kobject *kobj, struct kobject *parent,</p>
			<p class="source-code">                const char *fmt, ...);</p>
			<p>In the preceding function, <strong class="source-inline">kobj</strong> is the kernel object to be added to the system and <strong class="source-inline">parent</strong> is its parent. The <strong class="source-inline">kobject</strong> directory<a id="_idIndexMarker1119"/> will be created as a sub-directory of its parent. If <strong class="source-inline">parent</strong> is <strong class="source-inline">NULL</strong>, the directory will be created under <strong class="source-inline">/sys/</strong> directly.</p>
			<p>Instead of using <strong class="source-inline">kobject_init()</strong> or <strong class="source-inline">kobject_create()</strong> and then <strong class="source-inline">kobject_add()</strong> individually, it is possible to use <strong class="source-inline">kobject_init_and_add()</strong>, which groups their actions. It's defined like so:</p>
			<p class="source-code">int kobject_init_and_add(struct kobject *kobj,</p>
			<p class="source-code">                         struct kobj_type *ktype,</p>
			<p class="source-code">                         struct kobject *parent,</p>
			<p class="source-code">                         const char *fmt, ...);</p>
			<p>In the preceding interface, the object needs to be allocated first. There is another helper that will implicitly allocate, initialize, and add the kobject with the system. This function is <strong class="source-inline">kobject_create_and_add()</strong> and it's defined as follows:</p>
			<p class="source-code">struct kobject * kobject_create_and_add(const char *name,</p>
			<p class="source-code">                                     struct kobject *parent);</p>
			<p>The preceding function takes the name of the kobject that will be used as the directory name, as well as a parent kobject whose created directory will be a sub-directory. Passing <strong class="source-inline">NULL</strong> as the second parameter will result in the directory being created under <strong class="source-inline">/sys/</strong> directly.</p>
			<p>That said, some predefined kobjects in the kernel<a id="_idIndexMarker1120"/> already represent some directories under <strong class="source-inline">/sys/</strong>. Let's look at a few of them:</p>
			<ul>
				<li><strong class="source-inline">kernel_kobj</strong>: This kobject is responsible for the <strong class="source-inline">/sys/kernel</strong> directory.</li>
				<li><strong class="source-inline">mm_kobj</strong>: This is responsible for <strong class="source-inline">/sys/kernel/mm</strong>.</li>
				<li><strong class="source-inline">fs_kobj</strong>: This is the filesystem kobject and it's responsible for <strong class="source-inline">/sys/fs</strong>.</li>
				<li><strong class="source-inline">hypervisor_kobj</strong>: This is responsible for <strong class="source-inline">/sys/hypervisor</strong>.</li>
				<li><strong class="source-inline">power_kobj</strong>: This is a power management kobject that's used at the origin of <strong class="source-inline">/sys/power</strong>.</li>
				<li><strong class="source-inline">firmware_kobj</strong>: This is the firmware kobject that<a id="_idIndexMarker1121"/> owns the <strong class="source-inline">/sys/firmware</strong> directory.</li>
			</ul>
			<p>Once you're done with a kobject, the driver should release it. The low-level function<a id="_idIndexMarker1122"/> you can use to release a kobject is <strong class="source-inline">kobject_release()</strong>. However, this API does not consider other potential users of the kobject. It is raw and dummy. It is recommended to use <strong class="source-inline">kobject_put()</strong> instead, which will decrement the kobject's reference counter and then release this kobject if the new reference counter value is <strong class="source-inline">0</strong>. Remember that when a kobject is initialized, the reference counter value is set to <strong class="source-inline">1</strong>. Moreover, it is also recommended that users wrap the kobject's usage into the <strong class="source-inline">kobject_get()</strong> and <strong class="source-inline">kobject_put()</strong> functions, where <strong class="source-inline">kobject_get()</strong> will just increment the reference counter value.</p>
			<p>These APIs have the following prototypes:</p>
			<p class="source-code">void kobject_put(struct kobject * kobj);</p>
			<p class="source-code">struct kobject *kobject_get(struct kobject *kobj);</p>
			<p>In the preceding code, <strong class="source-inline">kobject_get()</strong> takes the kobject to increase the reference counter as a parameter and returns this same kobject once the parameter has been initialized. <strong class="source-inline">kobject_put()</strong> will decrement 1 from the reference counter and, if the new value is <strong class="source-inline">0</strong>, <strong class="source-inline">kobject_release()</strong> will be automatically called on the object, which will release it.</p>
			<p>The following code shows how to combine <strong class="source-inline">kobject_create()</strong>, <strong class="source-inline">kobject_init()</strong>, and <strong class="source-inline">kobject_add()</strong> to create and add a kernel object to the system:</p>
			<p class="source-code">/* Somewhere */</p>
			<p class="source-code">static struct kobject *mykobj;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">mykobj = kobject_create();</p>
			<p class="source-code">if (!mykobj)</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">kobject_init(mykobj, &amp;my_ktype);</p>
			<p class="source-code">if (kobject_add(mykobj, NULL, "%s", "hello")) {</p>
			<p class="source-code">    pr_info("ldm: kobject_add() failed\n");</p>
			<p class="source-code">    kobject_put(mykobj);</p>
			<p class="source-code">    mykobj = NULL;</p>
			<p class="source-code">    return -1;</p>
			<p class="source-code">}</p>
			<p>As we can see, we could use<a id="_idIndexMarker1123"/> an all-in-one function, such as <strong class="source-inline">kobject_create_and_add()</strong>, which internally calls <strong class="source-inline">kobject_create()</strong> and <strong class="source-inline">kobject_add()</strong>. The following excerpt from <strong class="source-inline">drivers/base/core.c</strong> shows how to use it:</p>
			<p class="source-code">static struct kobject * class_kobj   = NULL;</p>
			<p class="source-code">static struct kobject * devices_kobj = NULL;</p>
			<p class="source-code">/* Create /sys/class */</p>
			<p class="source-code">class_kobj = kobject_create_and_add("class", NULL);</p>
			<p class="source-code">if (!class_kobj)</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">/* Create /sys/devices */</p>
			<p class="source-code">devices_kobj = kobject_create_and_add("devices", NULL);</p>
			<p class="source-code">if (!devices_kobj)</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p>Keep in mind that for each <strong class="source-inline">struct kobject</strong>, the corresponding kobject directory can be found in <strong class="source-inline">/sys/</strong>, and the upper directory<a id="_idIndexMarker1124"/> is pointed out by <strong class="source-inline">kobj-&gt;parent</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Since it is mandatory to provide a <strong class="source-inline">kobj_type</strong> while initializing a kobject, all-in-one helpers use a default and kernel-provided <strong class="source-inline">kobj_type</strong>; that is, <strong class="source-inline">dynamic_kobj_ktype</strong>. Therefore, unless you have a good reason to initialize your <strong class="source-inline">kobj_type</strong> (most of the time, this will be if you wish to populate some default attributes), you should use <strong class="source-inline">kobject_create*()</strong> variants, which use the kernel-provided kobject type instead of <strong class="source-inline">kobject_init*()</strong>, which would require providing your own initialized <strong class="source-inline">kobj_type</strong>.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor210"/>Understanding the kobj_type structure</h2>
			<p>A <strong class="source-inline">struct kobj_type</strong> structure, which means<a id="_idIndexMarker1125"/> kernel object type, is a data structure that defines the behavior of a kobject element and controls what happens to this kobject when it is created or destroyed. Additionally, a <strong class="source-inline">kobj_type</strong> contains the default attributes of the kobject, as well as the hooks that allow it to operate on these attributes. </p>
			<p>Because most devices of the same type have the same attributes, these attributes are isolated and stored in the <strong class="source-inline">ktype</strong> element. This allows them to be managed flexibly. Every kobject must have an associated <strong class="source-inline">kobj_type</strong> structure. Its data structure is defined as follows:</p>
			<p class="source-code">struct kobj_type {</p>
			<p class="source-code">    void (*release)(struct kobject *);</p>
			<p class="source-code">    const struct sysfs_ops sysfs_ops;</p>
			<p class="source-code">    struct attribute **default_attrs;</p>
			<p class="source-code">};</p>
			<p>In the preceding data structure, <strong class="source-inline">release</strong> is a callback that's called on the release path of the kobject to give drivers a chance to release resources that have been allocated for the kobject. This callback is implicitly run when <strong class="source-inline">kobject_put()</strong> is about to free the kobject. <strong class="source-inline">default_attrs</strong> is an array of pointers to <strong class="source-inline">attribute</strong> structures. This field lists the attributes to be created<a id="_idIndexMarker1126"/> for every kobject of this type, while <strong class="source-inline">sysfs_ops</strong> provides a set of methods that allow you to access those attributes.</p>
			<p>The following code shows the definition of the <strong class="source-inline">struct sysfs_ops</strong> data structure in the kernel:</p>
			<p class="source-code">struct sysfs_ops {</p>
			<p class="source-code">    ssize_t (*show)(struct kobject *kobj,</p>
			<p class="source-code">                   struct attribute *attr, char *buf);</p>
			<p class="source-code">    ssize_t (*store)(struct kobject *kobj,</p>
			<p class="source-code">                   struct attribute *attr, const char *buf,</p>
			<p class="source-code">                   size_t size);</p>
			<p class="source-code">};</p>
			<p>In the preceding code, <strong class="source-inline">show</strong> is the callback that's invoked in response to a read operation of an attribute being exposed by this <strong class="source-inline">kobj_type</strong> – that is, whenever an attribute is read from the user space. <strong class="source-inline">buf</strong> is the output buffer. The buffer's size is fixed and is <strong class="source-inline">PAGE_SIZE</strong> in length. The data that must be exposed must be put inside <strong class="source-inline">buf</strong>, preferably using <strong class="source-inline">scnprintf()</strong>. Finally, if the callback succeeds, it must return the size (in bytes) of the data that was written into the buffer, or a negative error if it fails. Each attribute should contain/provide a single, human-readable value or property, according to the sysfs rules; if you have a lot of data to return, you should consider breaking it into numerous attributes. </p>
			<p><strong class="source-inline">store</strong> is called for writing purposes – that is, when users write something into an attribute. Its <strong class="source-inline">buf</strong> parameter is <strong class="source-inline">PAGE_SIZE</strong> at most but it can be smaller. It must return the size (in bytes) of the data that was read from the buffer on success or a negative error on failure (or if an unwanted value is received).</p>
			<p>The <strong class="source-inline">attr</strong> pointer is passed as an argument into both methods and can be utilized to determine which attribute is being accessed. It is frequent for <strong class="source-inline">show</strong>/<strong class="source-inline">store</strong> methods to perform a series of tests you can perform on the attribute name to achieve that. Other implementations, on the other hand, wrap the attribute's structure in an enclosing data structure that provides the data that's required to return the attribute's value (<strong class="source-inline">struct kobject_attribute</strong>, <strong class="source-inline">struct device_attribute</strong>, <strong class="source-inline">struct driver_attribute</strong>, and <strong class="source-inline">struct class_attribute</strong> are some examples); in this case, the <strong class="source-inline">container_of</strong> macro is used to obtain a pointer to the embedding structure. This is the method that's used by <strong class="source-inline">kobj_sysfs_ops</strong>, which represents the operations<a id="_idIndexMarker1127"/> that are provided by <strong class="source-inline">dynamic_kobj_ktype</strong>. Both methods are demonstrated in the examples provided with this book.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor211"/>Understanding the kset structure</h2>
			<p>The purpose of <strong class="source-inline">struct kset</strong> is mainly to group related kernel objects<a id="_idIndexMarker1128"/> together. <strong class="source-inline">kset</strong> stands for kernel object sets, which can be interpreted as a collection of kobjects. In other words, a <strong class="source-inline">kset</strong> gathers related kobjects into a single place, such as all <em class="italic">block devices</em>. </p>
			<p>The <strong class="source-inline">kset</strong> data structure is defined in the kernel like so:</p>
			<p class="source-code">struct kset {</p>
			<p class="source-code">    struct list_head list; </p>
			<p class="source-code">    spinlock_t list_lock;</p>
			<p class="source-code">    struct kobject kobj;</p>
			<p class="source-code"> };</p>
			<p>All the elements in the data structure are quite self-explanatory. Simply put, <strong class="source-inline">list</strong> is a linked list of all kobjects in <strong class="source-inline">kset</strong>, <strong class="source-inline">list_lock</strong> is a spinlock that protects linked list access (while adding or removing kobject elements in <strong class="source-inline">kset</strong>), and <strong class="source-inline">kobj</strong> represents the base class kobject for the set. This kobject will be used as the default parent of kobjects to be added in the set with a <strong class="source-inline">NULL</strong> parent.</p>
			<p>Each registered <strong class="source-inline">kset</strong> corresponds to a sysfs directory that's created on behalf of its <strong class="source-inline">kobj</strong> element. A <strong class="source-inline">kset</strong> can be created and added using the <strong class="source-inline">kset_create_and_add()</strong> function and removed with <strong class="source-inline">kset_unregister()</strong>. The following code shows the definitions for both:</p>
			<p class="source-code">struct kset * kset_create_and_add(const char *name,</p>
			<p class="source-code">                      const struct kset_uevent_ops *u,</p>
			<p class="source-code">                      struct kobject *parent_kobj);</p>
			<p class="source-code">void kset_unregister (struct kset * k);</p>
			<p>In the preceding APIs, <strong class="source-inline">name</strong> is the name of <strong class="source-inline">kset</strong>, which is also used as the name of the directory<a id="_idIndexMarker1129"/> that will be created for <strong class="source-inline">kset</strong>. The <strong class="source-inline">u</strong> parameter is a pointer to a <strong class="source-inline">struct uevent_ops</strong>, which represents a set of <strong class="bold">user event</strong> (<strong class="bold">uevent</strong>) operations that are called<a id="_idIndexMarker1130"/> whenever a change is made to <strong class="source-inline">kset</strong> so that, for example, it can add new environment variables or filter out the uevents if so desired. This parameter can be (and most of the time is) <strong class="source-inline">NULL</strong>. Finally, <strong class="source-inline">parent_kobj</strong> is the parent kobject of <strong class="source-inline">kset</strong>.</p>
			<p>Adding a kobject to the set is as simple as specifying its <strong class="source-inline">.kset</strong> field for the right <strong class="source-inline">kset</strong>:</p>
			<p class="source-code">static struct kobject foo_kobj, bar_kobj;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">example_kset = kset_create_and_add("kset_example",</p>
			<p class="source-code">                           NULL, kernel_kobj);</p>
			<p class="source-code"> /* since we have a kset for this kobject,</p>
			<p class="source-code">  * we need to set it before calling into the kobject core.</p>
			<p class="source-code">  */</p>
			<p class="source-code">foo_kobj.kset = example_kset;</p>
			<p class="source-code">bar_kobj.kset = example_kset;</p>
			<p class="source-code"> </p>
			<p class="source-code">retval = kobject_init_and_add(&amp;foo_kobj, &amp;foo_ktype,</p>
			<p class="source-code">                              NULL, "foo_name");</p>
			<p class="source-code">retval = kobject_init_and_add(&amp;bar_kobj, &amp;bar_ktype,</p>
			<p class="source-code">                              NULL, "bar_name");</p>
			<p>Once you're done with your <strong class="source-inline">kset</strong>, it can be released with <strong class="source-inline">kset_unregister()</strong>, after which it will be dynamically deallocated when it is no longer in use. The following code will release our example's <strong class="source-inline">kset</strong>:</p>
			<p class="source-code">kset_unregister(example_kset);</p>
			<p>Now that we are familiar with kobjects and type<a id="_idIndexMarker1131"/> structures, let's learn how to deal with non-default sysfs attributes.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor212"/>Working with non-default attributes</h2>
			<p>Attributes are sysfs files that are exported to the user space via kobjects. While default attributes<a id="_idIndexMarker1132"/> might be enough most of the time, you can add other attributes. An attribute can be readable, writable, or both, from the user space. </p>
			<p>An attribute definition looks as follows:</p>
			<p class="source-code">struct attribute {</p>
			<p class="source-code">        char              *name;</p>
			<p class="source-code">        struct module     *owner;</p>
			<p class="source-code">        umode_t           mode;</p>
			<p class="source-code">};</p>
			<p>In the attribute data structure, <strong class="source-inline">name</strong> is the name of the attribute, which is also the name of the corresponding file entry. <strong class="source-inline">owner</strong> is the attribute owner – most of the time, this is <strong class="source-inline">THIS_MODULE</strong> – and <strong class="source-inline">mode</strong> specifies the read/write permissions<a id="_idIndexMarker1133"/> for this attribute in <strong class="bold">user-group-other</strong> (<strong class="bold">ugo</strong>) format.</p>
			<p>Default attributes are very convenient to use but are not flexible enough. Moreover, simple attributes cannot be read or written except by their <strong class="source-inline">kobj_type</strong> sysfs ops, which means that if there are too many attributes, the branches in the show/store functions will be messy. To address this, the kobject core provides a mechanism where each attribute is embedded in an enclosing and special data structure: <strong class="source-inline">struct kobj_attribute</strong>. This data structure exposes the wrapper routines for reading and writing.</p>
			<p><strong class="source-inline">struct kobj_attribute</strong> (defined in <strong class="source-inline">include/linux/kobject.h</strong>) looks as follows:</p>
			<p class="source-code">struct kobj_attribute {</p>
			<p class="source-code"> struct attribute attr;</p>
			<p class="source-code"> ssize_t (*show)(struct kobject *kobj,</p>
			<p class="source-code">                 struct kobj_attribute *attr, char *buf);</p>
			<p class="source-code"> ssize_t (*store)(struct kobject *kobj,</p>
			<p class="source-code">                 struct kobj_attribute *attr,</p>
			<p class="source-code">                 const char *buf, size_t count);</p>
			<p class="source-code">};</p>
			<p>In this data structure, <strong class="source-inline">attr</strong> is the attribute representing the file to be created, <strong class="source-inline">show</strong> is a pointer to a function<a id="_idIndexMarker1134"/> that will be called when the file is read from the user space, and <strong class="source-inline">store</strong> is a pointer to a function that will be called when the file is written, again from the user space.</p>
			<p>Using the enclosing <strong class="source-inline">kobj_attribute</strong> structure makes developments more generic and extends attribute flexibility. This way, a pointer to <strong class="source-inline">attr</strong> is passed to either the <strong class="source-inline">store</strong> or <strong class="source-inline">show</strong> function and can be used not only to determine which attribute is being accessed but also to retrieve the enclosing data structure (that is, <strong class="source-inline">kobj_attribute</strong>) that this attribute's <strong class="source-inline">show</strong>/<strong class="source-inline">store</strong> method can be invoked from. To do so, you can use the <strong class="source-inline">container_of</strong> macro to obtain a pointer to the embedding structure. </p>
			<p>The following is an excerpt from <strong class="source-inline">lib/kobject.c</strong> that demonstrates this generic mechanism in both the <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> methods of a kernel-provided sysfs operations element: <strong class="source-inline">kobj_sysfs_ops</strong>. This element is also the sysfs operations data structure (the <strong class="source-inline">kobj_type-&gt;sysfs_ops</strong> element) that's used by <strong class="source-inline">dynamic_kobj_ktype</strong>:</p>
			<p class="source-code">static ssize_t kobj_attr_show(struct kobject *kobj,</p>
			<p class="source-code">                     struct attribute *attr, char *buf)</p>
			<p class="source-code">{</p>
			<p class="source-code">   struct kobj_attribute *kattr;</p>
			<p class="source-code">   ssize_t ret = -EIO;</p>
			<p class="source-code">   kattr = container_of(attr, struct kobj_attribute, attr);</p>
			<p class="source-code">   if (kattr-&gt;show)</p>
			<p class="source-code">       ret = kattr-&gt;show(kobj, kattr, buf);</p>
			<p class="source-code">   return ret;</p>
			<p class="source-code">}</p>
			<p class="source-code">static ssize_t kobj_attr_store(struct kobject *kobj,</p>
			<p class="source-code">                          struct attribute *attr, </p>
			<p class="source-code">                          const char *buf, size_t count)</p>
			<p class="source-code">{</p>
			<p class="source-code">   struct kobj_attribute *kattr;</p>
			<p class="source-code">   ssize_t ret = -EIO;</p>
			<p class="source-code">   kattr = container_of(attr, struct kobj_attribute, attr);</p>
			<p class="source-code">   if (kattr-&gt;store)</p>
			<p class="source-code">       ret = kattr-&gt;store(kobj, kattr, buf, count);</p>
			<p class="source-code">   return ret;</p>
			<p class="source-code">}</p>
			<p class="source-code">const struct sysfs_ops kobj_sysfs_ops = {</p>
			<p class="source-code">   .show  = kobj_attr_show,</p>
			<p class="source-code">   .store = kobj_attr_store,</p>
			<p class="source-code">};</p>
			<p>In the preceding code, the <strong class="source-inline">container_of</strong> macro does everything. This also reassures us that with<a id="_idIndexMarker1135"/> this approach, we remain compatible with all the bus-, device-, class-, and driver-related kobject implementations, as we will see in the next section. </p>
			<p>Let's go back to the APIs. You will probably always know which attributes you wish to expose in advance; thus, the attributes will almost always be declared statically. To help with this, the kernel provides the <strong class="source-inline">__ATTR</strong> macro for initializing <strong class="source-inline">kobj_attribute</strong>. This macro is defined as follows:</p>
			<p class="source-code">#define __ATTR(_name, _mode, _show, _store) {         \</p>
			<p class="source-code">    .attr = {.name = __stringify(_name),              \</p>
			<p class="source-code">           .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },\</p>
			<p class="source-code">     .show   = _show,                              \</p>
			<p class="source-code">     .store = _store,                               \</p>
			<p class="source-code">}</p>
			<p>In the preceding macro definition, <strong class="source-inline">_name</strong> will be stringified and used as the attribute name, <strong class="source-inline">_mode</strong> represents the attribute mode, and <strong class="source-inline">_show</strong> and <strong class="source-inline">_store</strong> are pointers to the attribute's <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> methods, respectively.</p>
			<p>The following is an example of two attribute's declarations, <strong class="source-inline">bar</strong> and <strong class="source-inline">foo</strong> (this example will be used as a base later in this section):</p>
			<p class="source-code">static struct kobj_attribute foo_attr =</p>
			<p class="source-code">    __ATTR(foo, 0660, attr_show, attr_store);</p>
			<p class="source-code">static struct kobj_attribute bar_attr =</p>
			<p class="source-code">    __ATTR(bar, 0660, attr_show, attr_store);</p>
			<p>In the preceding example, we have two attributes with the <strong class="source-inline">0660</strong> permission. The first attribute is named <strong class="source-inline">foo</strong>, the second one is named <strong class="source-inline">bar</strong>, and both use the same <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> methods.</p>
			<p>Now, we must create the underlying file. The low-level kernel APIs that are used to add/remove attributes from the sysfs filesystem are <strong class="source-inline">sysfs_create_file()</strong> and <strong class="source-inline">sysfs_remove_file()</strong>, respectively. They are defined<a id="_idIndexMarker1136"/> as follows:</p>
			<p class="source-code">int sysfs_create_file(struct kobject * kobj,</p>
			<p class="source-code">                      const struct attribute * attr);</p>
			<p class="source-code">void sysfs_remove_file(struct kobject * kobj,</p>
			<p class="source-code">                        const struct attribute * attr);</p>
			<p><strong class="source-inline">sysfs_create_file()</strong> returns 0 on success or a negative error on failure. <strong class="source-inline">sysfs_remove_file()</strong> must be given the same parameters to remove the file attributes. </p>
			<p>Let's use these APIs to add our <strong class="source-inline">bar</strong> and <strong class="source-inline">foo</strong> attributes to the system:</p>
			<p class="source-code">struct kobject *demo_kobj;</p>
			<p class="source-code">int err;</p>
			<p class="source-code">demo_kobj = kobject_create_and_add("demo", kernel_kobj);</p>
			<p class="source-code">if (!demo_kobj) {</p>
			<p class="source-code">    pr_err("demo: demo_kobj registration failed.\n");</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">}</p>
			<p class="source-code">err = sysfs_create_file(demo_kobj, &amp;foo_attr.attr);</p>
			<p class="source-code">if (err)</p>
			<p class="source-code">    pr_err("unable to create foo attribute\n");</p>
			<p class="source-code">err = sysfs_create_file(demo_kobj, &amp;bar_attr.attr);</p>
			<p class="source-code">if (err){</p>
			<p class="source-code">    sysfs_remove_file(demo_kobj, &amp;foo_attr.attr);</p>
			<p class="source-code">    pr_err("unable to create bar attribute\n");</p>
			<p class="source-code">}</p>
			<p>Once the preceding code has been executed, the <strong class="source-inline">bar</strong> and <strong class="source-inline">foo</strong> files will be visible in sysfs, in the <strong class="source-inline">/sys/demo</strong> directory. In our example, we used the <strong class="source-inline">__ATTR</strong> macro to define<a id="_idIndexMarker1137"/> our attributes. We had to specify the name, the mode, and the <strong class="source-inline">show</strong>/<strong class="source-inline">store</strong> methods. The kernel provides convenience macros for the most frequent cases to make specifying attributes and writing code more succinct, readable, and easier. These macros<a id="_idIndexMarker1138"/> are as follows:</p>
			<ul>
				<li><strong class="source-inline">__ATTR_RO(name)</strong>: This assumes that <strong class="source-inline">name_show</strong> is the show callback's name and sets the mode to <strong class="source-inline">0444</strong>.</li>
				<li><strong class="source-inline">__ATTR_WO(name)</strong>: This assumes that <strong class="source-inline">name_store</strong> is the store function's name and is restricted to mode <strong class="source-inline">0200</strong>, which means root write access only.</li>
				<li><strong class="source-inline">__ATTR_RW(name)</strong>: This assumes that <strong class="source-inline">name_show</strong> and <strong class="source-inline">name_store</strong> are for the <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> callbacks' names, respectively, and sets the mode to <strong class="source-inline">0644</strong>.</li>
				<li><strong class="source-inline">__ATTR_NULL</strong>: This is used as a list terminator. It sets both names to <strong class="source-inline">NULL</strong> and is used as an end of list indicator (see <strong class="source-inline">kernel/workqueue.c</strong>).</li>
			</ul>
			<p>All these macros only expect the name of the attribute as a parameter. The difference with these macros is that unlike <strong class="source-inline">__ATTR</strong>, whose <strong class="source-inline">store</strong>/<strong class="source-inline">show</strong> function names can be arbitrary, the attributes here are built under the assumption that the <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> methods are named <strong class="source-inline">&lt;attribute_name&gt;_show</strong> and<strong class="source-inline"> &lt;attribute_name&gt;_store</strong>, respectively. The following code demonstrates this with the <strong class="source-inline">__ATTR_RW_MODE</strong> macro, which is defined as follows:</p>
			<p class="source-code">#define __ATTR_RW_MODE(_name, _mode) {                 \</p>
			<p class="source-code">    .attr = { .name = __stringify(_name),              \</p>
			<p class="source-code">          .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },\</p>
			<p class="source-code">    .show   = _name##_show,                            \</p>
			<p class="source-code">    .store  = _name##_store,                          \</p>
			<p class="source-code">}</p>
			<p>As we can see, the <strong class="source-inline">.show</strong> and <strong class="source-inline">.store</strong> fields are set with their attribute<a id="_idIndexMarker1139"/> names suffixed with <strong class="source-inline">_show</strong> and <strong class="source-inline">_store</strong>, respectively. Let's take a look at the following example:</p>
			<p class="source-code">static struct kobj_attribute attr_foo = __ATTR_RW(foo);</p>
			<p>The preceding attribute declaration assumes that the <strong class="source-inline">show</strong> and <strong class="source-inline">store</strong> methods are defined as <strong class="source-inline">foo_show</strong> and <strong class="source-inline">foo_store</strong>, respectively.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you need to provide a single store/show operation pair for all the attributes, you should probably define these attributes with <strong class="source-inline">__ATTR</strong>. However, if processing the attributes requires providing a show/store pair per attribute, you can use the other attribute definition macros.  </p>
			<p>The following code shows the implementation of the show/store function for our previously defined <strong class="source-inline">foo</strong> and <strong class="source-inline">bar</strong> attributes:</p>
			<p class="source-code">static ssize_t attr_store(struct kobject *kobj,</p>
			<p class="source-code">                      struct kobj_attribute *attr,</p>
			<p class="source-code">                      const char *buf, size_t count)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int value, ret;</p>
			<p class="source-code">    ret = kstrtoint(buf, 10, &amp;value);</p>
			<p class="source-code">    if (ret &lt; 0)</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">    if (strcmp(attr-&gt;attr.name, "foo") == 0)</p>
			<p class="source-code">        foo = value;</p>
			<p class="source-code">    else /* if (strcmp(attr-&gt;attr.name, "bar") == 0) */</p>
			<p class="source-code">        bar = value;</p>
			<p class="source-code">    return count;</p>
			<p class="source-code">}</p>
			<p class="source-code">static ssize_t attr_show(struct kobject *kobj,</p>
			<p class="source-code">                      struct kobj_attribute *attr,</p>
			<p class="source-code">                    char *buf)</p>
			<p class="source-code">{</p>
			<p class="source-code">    int value;</p>
			<p class="source-code">    if (strcmp(attr-&gt;attr.name, "foo") == 0)</p>
			<p class="source-code">        value = foo;</p>
			<p class="source-code">    else</p>
			<p class="source-code">        value = bar;</p>
			<p class="source-code">     return sprintf(buf, "%d\n", value);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, instead of providing a pair of show/store operations per attribute, we have used the same function<a id="_idIndexMarker1140"/> pair for all the attributes, and we differentiated the attributes by their respective names. This is a common practice when you're using the generic <strong class="source-inline">kobject_attribute</strong> instead of framework-specific attributes. This is because they sometimes impose different show/store function names for each attribute since they do not rely on the <strong class="source-inline">__ATTR</strong> macro for defining attributes.  </p>
			<h3>Working with binary attributes</h3>
			<p>So far, we have become familiar<a id="_idIndexMarker1141"/> with the sysfs statement and mentioned that an attribute must store a single property/value in a human-readable text format, as well as that such an attribute has a <strong class="source-inline">PAGE_SIZE</strong> limit. However, there could be situations, although rare, which would require larger data to be exchanged in binary format, for example, all with random access. An example of such a situation is a device firmware transfer, where the user space would upload some binary data to be pushed to the hardware or PCI devices, exposing part or all of their configuration address spaces.</p>
			<p>To cover those cases, the sysfs framework provides<a id="_idIndexMarker1142"/> binary attributes. Note that these attributes are for sending/receiving binary data that is not interpreted/manipulated by the kernel at all. It should <em class="italic">only</em> be used as a pass-through to and from hardware, with no interpretation by the kernel. The only manipulations you can perform are some checks on the magic number and size, for example.</p>
			<p>Now, let's get back to the code A binary attribute is represented using a <strong class="source-inline">struct bin_attribute</strong> and is defined as follows:</p>
			<p class="source-code">struct bin_attribute {</p>
			<p class="source-code">    struct attribute attr;</p>
			<p class="source-code">    size_t     size;</p>
			<p class="source-code">    void             *private;</p>
			<p class="source-code">    ssize_t (*read)(struct file *filp,</p>
			<p class="source-code">              struct kobject *kobj,</p>
			<p class="source-code">              struct bin_attribute *attr,</p>
			<p class="source-code">              char *buffer, loff_t off, size_t count);</p>
			<p class="source-code">    ssize_t (*write)(struct file *filp,</p>
			<p class="source-code">             struct kobject *kobj,</p>
			<p class="source-code">             struct bin_attribute *attr,</p>
			<p class="source-code">             const char *buffer, </p>
			<p class="source-code">             loff_t off, size_t count);</p>
			<p class="source-code">    int (*mmap)(struct file *filp, struct kobject *kobj,</p>
			<p class="source-code">                  struct bin_attribute *attr,</p>
			<p class="source-code">                  struct vm_area_struct *vma);</p>
			<p class="source-code">};</p>
			<p>In the preceding code, <strong class="source-inline">attr</strong> is the underlying classic attribute for this binary attribute and holds the name, owner, and permissions for the binary attribute. <strong class="source-inline">size</strong> represents the maximum<a id="_idIndexMarker1143"/> size of the binary attribute (or zero if there is no maximum limit). <strong class="source-inline">private</strong> is a field that can be used for any convenience. Most of the time, it is assigned the buffer of the binary attribute. The <strong class="source-inline">read()</strong>, <strong class="source-inline">write()</strong>, and <strong class="source-inline">mmap()</strong> functions are optional and work similarly to the normal <strong class="source-inline">char</strong> driver equivalents. In their parameters, <strong class="source-inline">filp</strong> is an opened file pointer instance that's associated with the attribute and <strong class="source-inline">kobj</strong> is the underlying <strong class="source-inline">kobject</strong> associated with this this binary attribute. <strong class="source-inline">buffer</strong> is the output or input buffer for read or write operations, respectively. <strong class="source-inline">off</strong> is the same offset argument that's found in all read or write methods for all types of files. It refers to the offset from the start of the file – that is, offset into the binary data. Finally, <strong class="source-inline">count</strong> is the number of bytes to read or write.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Though binary attributes may not have size limitations, larger data is always requested/sent on a <strong class="source-inline">PAGE_SIZE</strong> chunk basis. This means that, for example, the <strong class="source-inline">write()</strong> function can be called multiple times for a single load. However, this split is handled by the kernel, which means it's transparent for the driver. The disadvantage is that sysfs has no way of signaling the end of a series of write operations, so code that implements a binary attribute must figure it out some other way.</p>
			<p>For a binary attribute to be created, it must be allocated and initialized. Like classic attributes, there are two ways to allocate binary attributes – either statically or dynamically. For static allocation, the framework provides the low-level <strong class="source-inline">__BIN_ATTR</strong> macro, which is defined as follows:</p>
			<p class="source-code">#define __BIN_ATTR(_name, _mode, _read, _write, _size) {  \</p>
			<p class="source-code">   .attr = { .name = __stringify(_name), .mode = _mode }, \</p>
			<p class="source-code">   .read    = _read,                        \</p>
			<p class="source-code">   .write   = _write,                       \</p>
			<p class="source-code">    .size      = _size,                          \</p>
			<p>It works similarly to the <strong class="source-inline">__ATTR</strong> macro. In terms of parameters, <strong class="source-inline">_name</strong> is the binary attribute name, <strong class="source-inline">_mode</strong> represents its permissions, <strong class="source-inline">_read</strong> and <strong class="source-inline">_write</strong> are the read and write functions, respectively, and <strong class="source-inline">_size</strong> is the size of the binary attribute.</p>
			<p>Like classic attributes, binary attributes<a id="_idIndexMarker1144"/> have their own high-level helper macros to ease the process of defining them. Some of these macros are as follows:</p>
			<p class="source-code">BIN_ATTR_RO(name, size)</p>
			<p class="source-code">BIN_ATTR_WO(name, size)</p>
			<p class="source-code">BIN_ATTR_RW(name, size)</p>
			<p>These macros declare a single instance of <strong class="source-inline">struct bin_attribute</strong>, whose corresponding variable is named <strong class="source-inline">bin_attribute_&lt;name&gt;</strong>, as shown in the following <strong class="source-inline">BIN_ATTR</strong> definition:</p>
			<p class="source-code">#define BIN_ATTR_RW(_name, _size)         \</p>
			<p class="source-code">struct bin_attribute bin_attr_##_name =   \</p>
			<p class="source-code">                __BIN_ATTR_RW(_name, _size)</p>
			<p>Moreover, like classic attributes, these high-level macros expect the read/write methods to be named <strong class="source-inline">&lt;attribute_name&gt;_read</strong> and <strong class="source-inline">&lt;attribute_name&gt;_write</strong>, respectively, as shown in the following <strong class="source-inline">__BIN_ATTR_RW</strong> definition:</p>
			<p class="source-code">#define __BIN_ATTR_RW(_name, _size) \</p>
			<p class="source-code"> __BIN_ATTR(_name, 0644, _name##_read, _name##_write, \</p>
			<p class="source-code">             _size)</p>
			<p>For dynamic allocation, a simple <strong class="source-inline">kzalloc()</strong> is enough. However, dynamically allocated binary attributes must be initialized using <strong class="source-inline">sysfs_bin_attr_init()</strong>, as shown here:</p>
			<p class="source-code">void sysfs_bin_attr_init(strict bin_attribute *bin_attr)</p>
			<p>After this, the driver must set other properties, such as the underlying attribute's mode, name, and permission, and optionally the read/write/map functions.</p>
			<p>Unlike classic attributes, which can be set<a id="_idIndexMarker1145"/> up as default attributes, binary attributes must be created explicitly. This can be done using <strong class="source-inline">sysfs_create_bin_file()</strong>, as follows:</p>
			<p class="source-code">int sysfs_create_bin_file(struct kobject *kobj, </p>
			<p class="source-code">                          struct bin_attribute *attr);</p>
			<p>This function returns <strong class="source-inline">0</strong> on success or a negative error on failure. Once you're done with a binary attribute, it can be removed with <strong class="source-inline">sysfs_remove_bin_file()</strong>, which is defined as follows:</p>
			<p class="source-code">int sysfs_remove_bin_file(struct kobject *kobj, </p>
			<p class="source-code">                          struct bin_attribute *attr);</p>
			<p>The following is an excerpt (whose full version can be found in <strong class="source-inline">drivers/i2c/i2c-slave-eeprom.c</strong>) of a concrete example highlighting the use of a binary attribute that's been allocated and initialized dynamically: </p>
			<p class="source-code">struct eeprom_data {</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    struct bin_attribute bin;</p>
			<p class="source-code">    u8 buffer[];</p>
			<p class="source-code">};</p>
			<p class="source-code">static int i2c_slave_eeprom_probe(</p>
			<p class="source-code">                             struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct eeprom_data *eeprom;</p>
			<p class="source-code">    int ret;</p>
			<p class="source-code">    unsigned int size = FIELD_GET(I2C_SLAVE_BYTELEN,</p>
			<p class="source-code">                                  id-&gt;driver_data) + 1;</p>
			<p class="source-code">    eeprom = devm_kzalloc(&amp;client-&gt;dev,</p>
			<p class="source-code">                sizeof(struct eeprom_data) + size,</p>
			<p class="source-code">                GFP_KERNEL);</p>
			<p class="source-code">    if (!eeprom)</p>
			<p class="source-code">        return -ENOMEM;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    sysfs_bin_attr_init(&amp;eeprom-&gt;bin);</p>
			<p class="source-code">    eeprom-&gt;bin.attr.name = "slave-eeprom";</p>
			<p class="source-code">    eeprom-&gt;bin.attr.mode = S_IRUSR | S_IWUSR;</p>
			<p class="source-code">    eeprom-&gt;bin.read = i2c_slave_eeprom_bin_read;</p>
			<p class="source-code">    eeprom-&gt;bin.write = i2c_slave_eeprom_bin_write;</p>
			<p class="source-code">    eeprom-&gt;bin.size = size;</p>
			<p class="source-code">    ret = sysfs_create_bin_file(&amp;client-&gt;dev.kobj,</p>
			<p class="source-code">                                  &amp;eeprom-&gt;bin);</p>
			<p class="source-code">    if (ret)</p>
			<p class="source-code">        return ret;</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">};</p>
			<p>Upon unloading the path<a id="_idIndexMarker1146"/> of the module or when the device leaves, the associated binary file is removed, as follows: </p>
			<p class="source-code">static int i2c_slave_eeprom_remove(struct i2c_client *client)</p>
			<p class="source-code">{</p>
			<p class="source-code">   struct eeprom_data *eeprom = i2c_get_clientdata(client);</p>
			<p class="source-code">   sysfs_remove_bin_file(&amp;client-&gt;dev.kobj, &amp;eeprom-&gt;bin);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">   return 0;</p>
			<p class="source-code">}</p>
			<p>Then, when it comes to implementing<a id="_idIndexMarker1147"/> the read/write function, data can be moved back and forth using <strong class="source-inline">memcpy()</strong>, as shown here:</p>
			<p class="source-code">static ssize_t i2c_slave_eeprom_bin_read(struct file *filp,</p>
			<p class="source-code">          struct kobject *kobj, struct bin_attribute *attr,</p>
			<p class="source-code">          char *buf, loff_t off, size_t count)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct eeprom_data *eeprom;</p>
			<p class="source-code">    eeprom = dev_get_drvdata(kobj_to_dev(kobj));</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    memcpy(buf, &amp;eeprom-&gt;buffer[off], count);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    return count;</p>
			<p class="source-code">}</p>
			<p class="source-code">static ssize_t i2c_slave_eeprom_bin_write(</p>
			<p class="source-code">         struct file *filp, struct kobject *kobj,</p>
			<p class="source-code">         struct bin_attribute *attr,</p>
			<p class="source-code">         char *buf, loff_t off, size_t count)</p>
			<p class="source-code">{</p>
			<p class="source-code">     struct eeprom_data *eeprom;</p>
			<p class="source-code">     eeprom = dev_get_drvdata(kobj_to_dev(kobj));</p>
			<p class="source-code">[...]</p>
			<p class="source-code">     memcpy(&amp;eeprom-&gt;buffer[off], buf, count);</p>
			<p class="source-code">[...]</p>
			<p class="source-code">    return count;</p>
			<p class="source-code">}</p>
			<p>In the preceding excerpt, the offset (the <strong class="source-inline">off</strong> parameter) points to where<a id="_idIndexMarker1148"/> the data should be read/written, and <strong class="source-inline">count</strong> determines the size of this data.</p>
			<h3>The concept of attribute group</h3>
			<p>So far, we have learned how to individually<a id="_idIndexMarker1149"/> add (binary) attributes by calling the <strong class="source-inline">sysfs_create_file()</strong> or <strong class="source-inline">sysfs_create_bin_file()</strong> function. While this is enough if we have a few attributes to add, it may become painful as the number of attributes grows, either upon adding or removing them. The driver will have to loop over the attributes to create each of them or invoke <strong class="source-inline">sysfs_create_file()</strong> as many times as there are attributes. Here is where the attribute group comes in. It relies on the <strong class="source-inline">struct attribute_group</strong> structure, which is defined as follows:</p>
			<p class="source-code">struct attribute_group {</p>
			<p class="source-code">    const char        *name;</p>
			<p class="source-code">    umode_t           (*is_visible)(struct kobject *,</p>
			<p class="source-code">                         struct attribute *, int);</p>
			<p class="source-code">    umode_t           (*is_bin_visible)(struct kobject *,</p>
			<p class="source-code">                         struct bin_attribute *, int);</p>
			<p class="source-code">    struct attribute  **attrs;</p>
			<p class="source-code">    struct bin_attribute   **bin_attrs;</p>
			<p class="source-code">};</p>
			<p>If it is unnamed, an attribute group will place all the attributes directly in the kobject's directory when defining<a id="_idIndexMarker1150"/> a group of attributes. If, however, a <strong class="source-inline">name</strong> is supplied, a subdirectory will be created for the attributes, with the directory's name being the name of the attribute group. <strong class="source-inline">is_visible()</strong> is an optional callback that intends to return the permissions associated with a specific attribute in the group. It will be called repeatedly for each (non-binary) attribute in the group. This callback must then return the read/write permission of the attribute, or <strong class="source-inline">0</strong> if the attribute is not supposed to be accessed at all. <strong class="source-inline">is_bin_visible()</strong> is the counterpart of <strong class="source-inline">is_visible()</strong> for binary attributes. The returned value/permission will replace the static permissions that have been defined in <strong class="source-inline">struct attribute</strong>.  The <strong class="source-inline">attrs</strong> element is a pointer to a <strong class="source-inline">NULL</strong> terminated list of attributes, while <strong class="source-inline">bin_attrs</strong> is its counterpart for binary attributes.</p>
			<p>The kernel functions that are used to add/remove group attributes to/from the filesystem are as follows:</p>
			<p class="source-code">int sysfs_create_group(struct kobject *kobj,</p>
			<p class="source-code">                       const struct attribute_group *grp)</p>
			<p class="source-code">void sysfs_remove_group(struct kobject * kobj,</p>
			<p class="source-code">                        const struct attribute_group * grp)</p>
			<p>Back to our demo example with  standard attributes, the two <strong class="source-inline">bar</strong> and <strong class="source-inline">foo</strong> attributes can be embedded into a <strong class="source-inline">struct attribute_group</strong>. This will allow us adding these to the system in a single shot, using one function call as follows:</p>
			<p class="source-code">static struct kobj_attribute foo_attr =</p>
			<p class="source-code">    __ATTR(foo, 0660, attr_show, attr_store);</p>
			<p class="source-code">static struct kobj_attribute bar_attr =</p>
			<p class="source-code">    __ATTR(bar, 0660, attr_show, attr_store);</p>
			<p class="source-code">/* attrs is aa array of pointers to attributes */</p>
			<p class="source-code">static struct attribute *demo_attrs[] = {</p>
			<p class="source-code">    &amp;bar_foo_attr.attr,</p>
			<p class="source-code">    &amp;bar_attr.attr,</p>
			<p class="source-code">    NULL,</p>
			<p class="source-code">};</p>
			<p class="source-code">static struct attribute_group my_attr_group = {</p>
			<p class="source-code">    .attrs = demo_attrs,</p>
			<p class="source-code">    /*.bin_attrs = demo_bin_attrs,*/</p>
			<p class="source-code">};</p>
			<p>Finally, to create the attributes<a id="_idIndexMarker1151"/> in a single shot, we need to use <strong class="source-inline">sysfs_create_group()</strong>, as shown in the following code:</p>
			<p class="source-code">struct kobject *demo_kobj;</p>
			<p class="source-code">int err;</p>
			<p class="source-code">demo_kobj = kobject_create_and_add("demo", kernel_kobj);</p>
			<p class="source-code">if (!demo_kobj) {</p>
			<p class="source-code">    pr_err("demo: demo_kobj registration failed.\n");</p>
			<p class="source-code">    return -ENOMEM;</p>
			<p class="source-code">}</p>
			<p class="source-code">err = sysfs_create_group(demo_kobj, &amp;foo_attr.attr);</p>
			<p>Here, we have demonstrated the importance of creating a group of attributes and how easy it is to use their APIs. While we have been generic so far, in the next section, we'll learn how to create framework-specific attributes.</p>
			<h3>Creating symbolic links</h3>
			<p>Drivers can create/remove symbolic links<a id="_idIndexMarker1152"/> on existing kobjects (directories) using <strong class="source-inline">sysfs_{create|remove}_link()</strong> functions, as shown here:</p>
			<p class="source-code">int sysfs_create_link(struct kobject * kobj,</p>
			<p class="source-code">                     struct kobject * target, char * name); </p>
			<p class="source-code">void sysfs_remove_link(struct kobject * kobj, char * name);</p>
			<p>This allows an object to exist in more than one place or even create a shortcut. The <strong class="source-inline">create</strong> function will create a symbolic link called <strong class="source-inline">name</strong> that points to the remote <strong class="source-inline">target</strong> kobject's sysfs entry. The link will be created in the <strong class="source-inline">kobj</strong> kobject directory. A well-known example is devices appearing in both <strong class="source-inline">/sys/bus</strong> and <strong class="source-inline">/sys/devices</strong> since a bus controller is first a device on its own before exposing a bus. However, note that any symbolic links that are created will be persistent (unless the system is rebooted), even after target removal. Thus, the driver must consider that when the associated device leaves the system or when the module is unloaded. </p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor213"/>Overview of the device model from sysfs</h1>
			<p>sysfs is a non-persistent<a id="_idIndexMarker1153"/> virtual filesystem that provides a global view of the system and exposes the kernel objects<a id="_idIndexMarker1154"/> hierarchy (topology) using their kobjects. Each kobject<a id="_idIndexMarker1155"/> shows up as a directory. The files in these directories represent the kernel variables that are exported by the related kobject. These files are called attributes<a id="_idIndexMarker1156"/> and can be read or written.</p>
			<p>If any registered kobject creates a directory in sysfs, where the directory is created depends on the parent of this kobject (which is also a kobject, thus highlighting internal object hierarchies). In sysfs, top-level directories represent the common ancestors of object hierarchies or the subsystems that the objects belong to. </p>
			<p>These top-level sysfs directories can be found in the <strong class="source-inline">/sys/</strong> directory, as follows:</p>
			<p class="source-code">/sys$ tree -L 1</p>
			<p class="source-code">├── block</p>
			<p class="source-code">├── bus</p>
			<p class="source-code">├── class</p>
			<p class="source-code">├── dev</p>
			<p class="source-code">├── devices</p>
			<p class="source-code">├── firmware</p>
			<p class="source-code">├── fs</p>
			<p class="source-code">├── hypervisor</p>
			<p class="source-code">├── kernel</p>
			<p class="source-code">├── module</p>
			<p class="source-code">└── power</p>
			<p><strong class="source-inline">block</strong> contains a directory per block device on the system. Each of these contains subdirectories for partitions on the device. <strong class="source-inline">bus</strong> contains the registered bus on the system. <strong class="source-inline">dev</strong> contains the registered<a id="_idIndexMarker1157"/> device nodes in a raw way (no hierarchy), with each being a symbolic link<a id="_idIndexMarker1158"/> to the real device in the <strong class="source-inline">/sys/devices</strong> directory. The <strong class="source-inline">devices</strong> directory gives the real view of the topology of devices in the system. <strong class="source-inline">firmware</strong> shows a system-specific tree of low-level subsystems such as ACPI, EFI, and OF (device tree). <strong class="source-inline">fs</strong> lists the filesystems that are used on the system. <strong class="source-inline">kernel</strong> holds the kernel configuration options and status information. Finally, <strong class="source-inline">module</strong> is a list of loaded modules and <strong class="source-inline">power</strong> is the system power management control interface from the user space.</p>
			<p>Each of these directories corresponds to a kobject, some of which are exported as kernel symbols. These are as follows:</p>
			<ul>
				<li><strong class="source-inline">kernel_kobj</strong>, which corresponds to <strong class="source-inline">/sys/kernel</strong>.</li>
				<li><strong class="source-inline">power_kobj</strong>, which corresponds to <strong class="source-inline">/sys/power</strong>.</li>
				<li><strong class="source-inline">firmware_kobj</strong>, which corresponds to <strong class="source-inline">/sys/firmware</strong>. It's exported in the <strong class="source-inline">drivers/base/firmware.c</strong> source file.</li>
				<li><strong class="source-inline">hypervisor_kobj</strong>, which corresponds to <strong class="source-inline">/sys/hypervisor</strong>. It's exported in the <strong class="source-inline">drivers/base/hypervisor.c</strong> source file.</li>
				<li><strong class="source-inline">fs_kobj</strong>, which corresponds to <strong class="source-inline">/sys/fs</strong>. This is exported in the <strong class="source-inline">fs/namespace.c</strong> source file.</li>
			</ul>
			<p>For the rest, <strong class="source-inline">class/</strong>, <strong class="source-inline">dev/</strong> and <strong class="source-inline">devices/</strong> are created at boot<a id="_idIndexMarker1159"/> time by the <strong class="source-inline">devices_init()</strong> function in <strong class="source-inline">drivers/base/core.c</strong> in the kernel<a id="_idIndexMarker1160"/> sources, <strong class="source-inline">block/</strong> is created in <strong class="source-inline">block/genhd.c</strong>, and <strong class="source-inline">bus/</strong> is created as a <strong class="source-inline">kset</strong> in <strong class="source-inline">drivers/base/bus.c</strong>. </p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor214"/>Creating device-, driver-, bus- and class-related attributes</h2>
			<p>So far, we have learned how<a id="_idIndexMarker1161"/> to create dedicated kobjects to populate attributes<a id="_idIndexMarker1162"/> inside. However, the device, driver, bus, and class<a id="_idIndexMarker1163"/> frameworks provide attribute abstractions<a id="_idIndexMarker1164"/> and file creation, where the attributes that are created are directly tied to the respective framework in the appropriate kobject directory.</p>
			<p>To do so, each framework provides a framework-specific attribute data structure that encloses the default attribute and allows us to provide a custom show/store callback. These are <strong class="source-inline">struct device_attribute</strong>, <strong class="source-inline">struct driver_attribute</strong>, <strong class="source-inline">struct bus_atttribute</strong>, and <strong class="source-inline">struct class_attribute</strong> for the device, driver, bus, and class frameworks, respectively. They are defined like <strong class="source-inline">kboj_attribute</strong> is but use different names. Let's look at their respective data structures:</p>
			<ul>
				<li>Devices have the following attribute data structure:<p class="source-code">struct driver_attribute {</p><p class="source-code">    struct attribute attr;</p><p class="source-code">    ssize_t (*show)(struct device_driver *driver,</p><p class="source-code">                char *buf);</p><p class="source-code">    ssize_t (*store)(struct device_driver *driver,</p><p class="source-code">                const char *buf, size_t count);</p><p class="source-code">};</p></li>
				<li>Classes<a id="_idIndexMarker1165"/> have the following<a id="_idIndexMarker1166"/> attribute<a id="_idIndexMarker1167"/> data<a id="_idIndexMarker1168"/> structure:<p class="source-code">struct class_attribute {</p><p class="source-code">    struct attribute attr;</p><p class="source-code">    ssize_t (*show)(struct class *class,</p><p class="source-code">             struct class_attribute *attr, char *buf);</p><p class="source-code">    ssize_t (*store)(struct class *class,</p><p class="source-code">             struct class_attribute *attr,</p><p class="source-code">             const char *buf, size_t count);</p><p class="source-code">};</p></li>
				<li>The bus framework has the following attribute data structure:<p class="source-code">struct bus_attribute {</p><p class="source-code">    struct attribute  attr;</p><p class="source-code">    ssize_t (*show)(struct bus_type *bus, char *buf);</p><p class="source-code">    ssize_t (*store)(struct bus_type *bus,</p><p class="source-code">                 const char *buf, size_t count);</p><p class="source-code">};</p></li>
				<li>Devices have the following attribute data structure:<p class="source-code">struct device_attribute {</p><p class="source-code">    struct attribute  attr;</p><p class="source-code">    ssize_t (*show)(struct device *dev,</p><p class="source-code">                 struct device_attribute *attr,</p><p class="source-code">                 char *buf);</p><p class="source-code">    ssize_t (*store)(struct device *dev,</p><p class="source-code">                       struct device_attribute *attr,</p><p class="source-code">                       const char *buf, size_t count);</p><p class="source-code">};</p></li>
			</ul>
			<p>The preceding device-specific data structure's <strong class="source-inline">show</strong> function takes an additional <strong class="source-inline">count</strong> parameter, whereas the others do not.</p>
			<p>They can be dynamically<a id="_idIndexMarker1169"/> allocated with <strong class="source-inline">kzalloc()</strong> and initialized by setting<a id="_idIndexMarker1170"/> the fields of their inner attribute elements<a id="_idIndexMarker1171"/> and providing the appropriate callback<a id="_idIndexMarker1172"/> functions. However, each framework provides a set of macros to statically allocate, initialize, and assign a single instance of their respective attribute data structure. Let's look at these macros:</p>
			<ul>
				<li>The bus infrastructure provides the following macros:<p class="source-code">BUS_ATTR_RW(_name)</p><p class="source-code">BUS_ATTR_RO(_name)</p><p class="source-code">BUS_ATTR_WO(_name)</p></li>
			</ul>
			<p>With these bus framework-specific macros, the resulting bus attribute variable is named <strong class="source-inline">bus_attr_&lt;_name&gt;</strong>. For example, the variable name that results from <strong class="source-inline">BUS_ATTR_RW(foo)</strong> will be <strong class="source-inline">bus_attr_foo</strong> and will be of the <strong class="source-inline">struct bus_attribute</strong> type.</p>
			<ul>
				<li>For drivers, the following macros are provided:<p class="source-code">DRIVER_ATTR_RW(_name)</p><p class="source-code">DRIVER_ATTR_RO(_name)</p><p class="source-code">DRIVER_ATTR_WO(_name)</p></li>
			</ul>
			<p>These driver-specific attribute definition macros will name the resulting variable using the <strong class="source-inline">driver_attr_&lt;_name&gt;</strong> pattern. Therefore, the variable that results from <strong class="source-inline">DRIVER_ATTR_RW(foo)</strong> will be of the <strong class="source-inline">struct driver_attribute</strong> type and will be named <strong class="source-inline">driver_attr_foo</strong>.</p>
			<ul>
				<li>The class framework works with the following macros:<p class="source-code">CLASS_ATTR_RW(_name)</p><p class="source-code">CLASS_ATTR_RO(_name)</p><p class="source-code">CLASS_ATTR_WO(_name)</p></li>
			</ul>
			<p>Using these class-specific<a id="_idIndexMarker1173"/> macros, the resulting variable<a id="_idIndexMarker1174"/> will be of the <strong class="source-inline">struct class_atribute</strong> type and will be named<a id="_idIndexMarker1175"/> based on the <strong class="source-inline">class_attr_&lt;_name&gt;</strong> pattern. Thus, the resulting<a id="_idIndexMarker1176"/> variable name of <strong class="source-inline">CLASS_ATTR_RW(foo)</strong> will be <strong class="source-inline">class_attr_foo</strong>.</p>
			<ul>
				<li>Finally, device-specific attributes can be statically allocated and initialized using the following macros:<p class="source-code">DEVICE_ATTR(_name, _mode, _show, _store)</p><p class="source-code">DEVICE_ATTR_RW(_name)</p><p class="source-code">DEVICE_ATTR_RO(_name)</p><p class="source-code">DEVICE_ATTR_WO(_name)</p></li>
			</ul>
			<p>Device-specific attributes definition macros use their own pattern for variable names, which is <strong class="source-inline">dev_attr_&lt;_name&gt;</strong>. Thus, for example, <strong class="source-inline">DEVICE_ATTR_RO(foo)</strong> will result in a <strong class="source-inline">struct device_attribute</strong> object named <strong class="source-inline">dev_attr_foo</strong>.</p>
			<p>Because all these macros are built on top of <strong class="source-inline">__ATTR_RW</strong>, <strong class="source-inline">__ATTR_RO</strong>, and <strong class="source-inline">__ATTR_WO</strong>, they statically allocate and initialize a single instance of the framework-specific attribute data structure and assume the show/store functions are named <strong class="source-inline">&lt;attribute_name&gt;_show</strong> and <strong class="source-inline">&lt;attribute_name&gt;_store</strong>, respectively (remember, this is because they do not rely on the <strong class="source-inline">__ATTR</strong> macro). There is an exception for <strong class="source-inline">DEVICE_ATTR()</strong>, which uses the show/store function as it was passed, without any suffix or prefix. This exception is because <strong class="source-inline">DEVICE_ATTR</strong> relies on <strong class="source-inline">__ATTR</strong> to define attributes.</p>
			<p>As we have seen, all these framework-specific macros use a predefined prefix to name the resulting framework-specific attribute object variable. Let's take a look at the following class attribute:</p>
			<p class="source-code">static CLASS_ATTR_RW(foo);</p>
			<p>This will create a static variable of the <strong class="source-inline">struct class_attribute</strong> type named <strong class="source-inline">class_attr_foo</strong> and will assume<a id="_idIndexMarker1177"/> that its show and store functions<a id="_idIndexMarker1178"/> are named <strong class="source-inline">foo_show</strong> and <strong class="source-inline">foo_store</strong>, respectively. This can be referenced<a id="_idIndexMarker1179"/> in a group using its inner<a id="_idIndexMarker1180"/> attribute element, as shown here:</p>
			<p class="source-code">static struct attribute *fake_class_attrs[] = {</p>
			<p class="source-code">    &amp;class_attr_foo.attr,</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    NULL,</p>
			<p class="source-code">};</p>
			<p class="source-code">static struct attribute_group fake_attr_group = {</p>
			<p class="source-code">    .attrs = fake_class_attrs,</p>
			<p class="source-code">};</p>
			<p>The most important thing when it comes to creating the respective files is that the driver can select the appropriate API from the following list:</p>
			<p class="source-code">int device_create_file(struct device *device,</p>
			<p class="source-code">            const struct device_attribute *entry);</p>
			<p class="source-code">int driver_create_file(struct device_driver *driver,</p>
			<p class="source-code">            const struct driver_attribute *attr);</p>
			<p class="source-code">int bus_create_file(struct bus_type *bus,</p>
			<p class="source-code">            struct bus_attribute *);</p>
			<p class="source-code">int class_create_file(struct class *class,</p>
			<p class="source-code">            const struct class_attribute *attr)</p>
			<p>Here, the <strong class="source-inline">device</strong>, <strong class="source-inline">driver</strong>, <strong class="source-inline">bus</strong>, and <strong class="source-inline">class</strong> arguments are the respective device, driver, bus, and class entities<a id="_idIndexMarker1181"/> that the attribute must be added to. Moreover, the attribute<a id="_idIndexMarker1182"/> will be created in the directory that corresponds<a id="_idIndexMarker1183"/> to the inner kobject of each entity, as shown<a id="_idIndexMarker1184"/> in the following code:</p>
			<p class="source-code">int device_create_file(struct device *dev,</p>
			<p class="source-code">                   const struct device_attribute *attr)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    error = sysfs_create_file(&amp;dev-&gt;kobj, &amp;attr-&gt;attr);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p class="source-code">int class_create_file(struct class *cls,</p>
			<p class="source-code">                    const struct class_attribute *attr)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    error =</p>
			<p class="source-code">        sysfs_create_file(&amp;cls-&gt;p-&gt;class_subsys.kobj,</p>
			<p class="source-code">                          &amp;attr-&gt;attr);</p>
			<p class="source-code">    return error;</p>
			<p class="source-code">}</p>
			<p class="source-code">int bus_create_file(struct bus_type *bus,</p>
			<p class="source-code">                   struct bus_attribute *attr)</p>
			<p class="source-code">{</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    error =</p>
			<p class="source-code">        sysfs_create_file(&amp;bus-&gt;p-&gt;subsys.kobj,</p>
			<p class="source-code">                           &amp;attr-&gt;attr);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>To kill two birds<a id="_idIndexMarker1185"/> with one stone, the<a id="_idIndexMarker1186"/> preceding code<a id="_idIndexMarker1187"/> also shows that <strong class="source-inline">device_create_file()</strong>, <strong class="source-inline">bus_create_file()</strong>, <strong class="source-inline">driver_create_file()</strong> and <strong class="source-inline">class_create_file()</strong> all make an internal<a id="_idIndexMarker1188"/> call to <strong class="source-inline">sysfs_create_file()</strong>.</p>
			<p>Once you're done with each respective attribute object, the appropriate removal method must be invoked. The following code shows the possible options:</p>
			<p class="source-code">void device_remove_file(struct device *device,</p>
			<p class="source-code">             const struct device_attribute *entry);</p>
			<p class="source-code">void driver_remove_file(struct device_driver *driver,</p>
			<p class="source-code">                const struct driver_attribute *attr);</p>
			<p class="source-code">void bus_remove_file(struct bus_type *,</p>
			<p class="source-code">                struct bus_attribute *);</p>
			<p class="source-code">void class_remove_file(struct class *class,</p>
			<p class="source-code">                       const struct class_attribute *attr);</p>
			<p>Each of these APIs expects the same arguments as those that are passed when the attributes are created.</p>
			<p>Now that you know how the inner show/store functions of the <strong class="source-inline">kobj_atribute</strong> elements are invoked, it should be obvious to you how those framework-specific show/store functions are invoked as well. </p>
			<p>Let's have a look at the device's implementation. The device framework has an internal <strong class="source-inline">kobj_type</strong> that implements device-specific show and store functions. These functions take in the inner attribute element as one of their arguments. After that, the <strong class="source-inline">container_of</strong> macro retrieves a pointer for the enclosing data structure (which is the framework-specific attribute data structure) that the framework-specific show and store functions are invoked from.</p>
			<p>The following<a id="_idIndexMarker1189"/> is an<a id="_idIndexMarker1190"/> excerpt<a id="_idIndexMarker1191"/> from <strong class="source-inline">drivers/base/core.c</strong> that shows<a id="_idIndexMarker1192"/> the device-specific <strong class="source-inline">sysfs_ops</strong> implementation:</p>
			<p class="source-code">static ssize_t dev_attr_show(struct kobject *kobj,</p>
			<p class="source-code">                            struct attribute *attr,</p>
			<p class="source-code">                            char *buf)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct device_attribute *dev_attr = to_dev_attr(attr);</p>
			<p class="source-code">    struct device *dev = kobj_to_dev(kobj);</p>
			<p class="source-code">    ssize_t ret = -EIO;</p>
			<p class="source-code">    if (dev_attr-&gt;show)</p>
			<p class="source-code">          ret = dev_attr-&gt;show(dev, dev_attr, buf);</p>
			<p class="source-code">    if (ret &gt;= (ssize_t)PAGE_SIZE) {</p>
			<p class="source-code">        print_symbol("dev_attr_show:</p>
			<p class="source-code">                        %s returned bad count\n",</p>
			<p class="source-code">                    (unsigned long)dev_attr-&gt;show);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p class="source-code">static ssize_t dev_attr_store(struct kobject *kobj,</p>
			<p class="source-code">                      struct attribute *attr,</p>
			<p class="source-code">                      const char *buf, size_t count)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct device_attribute *dev_attr = to_dev_attr(attr);</p>
			<p class="source-code">    struct device *dev = kobj_to_dev(kobj);</p>
			<p class="source-code">    ssize_t ret = -EIO;</p>
			<p class="source-code">    if (dev_attr-&gt;store)</p>
			<p class="source-code">        ret = dev_attr-&gt;store(dev, dev_attr, buf, count);</p>
			<p class="source-code">    return ret;</p>
			<p class="source-code">}</p>
			<p class="source-code">static const struct sysfs_ops dev_sysfs_ops = {</p>
			<p class="source-code">    .show     = dev_attr_show,</p>
			<p class="source-code">    .store    = dev_attr_store,</p>
			<p class="source-code">};</p>
			<p>Note that in the preceding code, <strong class="source-inline">to_dev_attr()</strong>, which is the macro that makes use of <strong class="source-inline">container_of</strong>, is defined as follows:</p>
			<p class="source-code">#define to_dev_attr(_attr) \</p>
			<p class="source-code">       container_of(_attr, struct device_attribute, attr)</p>
			<p>The principle<a id="_idIndexMarker1193"/> is the same<a id="_idIndexMarker1194"/> for the<a id="_idIndexMarker1195"/> bus (in <strong class="source-inline">drivers/base/bus.c</strong>), driver (in <strong class="source-inline">drivers/base/bus.c</strong>), and<a id="_idIndexMarker1196"/> class (in <strong class="source-inline">drivers/base/class.c</strong>) attributes.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor215"/>Making a sysfs attribute poll- and select-compatible</h2>
			<p>Though this is not a requirement<a id="_idIndexMarker1197"/> for dealing with sysfs attributes, the main idea<a id="_idIndexMarker1198"/> here is to allow the <strong class="source-inline">poll()</strong> or <strong class="source-inline">select()</strong> system calls to be used on a given attribute to passively wait for a change. This change could be firmware becoming available, an alarm notification, or information that the attribute value has changed. While the user would sleep on the file waiting for a change, the driver must invoke <strong class="source-inline">sysfs_notify()</strong>to release any sleeping user.</p>
			<p>This notification API is defined as follows:</p>
			<p class="source-code">void sysfs_notify(struct kobject *kobj, const char *dir,</p>
			<p class="source-code">                  const char *attr)</p>
			<p>If the <strong class="source-inline">dir</strong> parameter is not <strong class="source-inline">NULL</strong>, it is used to find a subdirectory from within the directory of <strong class="source-inline">kobj</strong>, which contains the attribute (presumably created by <strong class="source-inline">sysfs_create_group</strong>). This call will cause any polling process to wake up and process the event (which might be reading the new value, handling the alarm, and so on). </p>
			<p class="callout-heading">Note</p>
			<p class="callout">There will be no notifications without this function call; therefore, any polling process will end up waiting indefinitely (unless a timeout was specified in the system call).</p>
			<p>The following code, which shows the <strong class="source-inline">store()</strong> function of an attribute, is provided with this book:</p>
			<p class="source-code">static ssize_t store(struct kobject *kobj,</p>
			<p class="source-code">                     struct attribute *attr,</p>
			<p class="source-code">                     const char *buf, size_t len)</p>
			<p class="source-code">{</p>
			<p class="source-code">    struct d_attr *da = container_of(attr, struct d_attr, </p>
			<p class="source-code">                                      attr);</p>
			<p class="source-code">    sscanf(buf, "%d", &amp;da-&gt;value);</p>
			<p class="source-code">    pr_info("sysfs_foo store %s = %d\n",</p>
			<p class="source-code">             a-&gt;attr.name, a-&gt;value);</p>
			<p class="source-code">    if (strcmp(a-&gt;attr.name, "foo") == 0){</p>
			<p class="source-code">        foo.value = a-&gt;value;</p>
			<p class="source-code">        sysfs_notify(mykobj, NULL, "foo");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    else if(strcmp(a-&gt;attr.name, "bar") == 0){</p>
			<p class="source-code">        bar.value = a-&gt;value;</p>
			<p class="source-code">        sysfs_notify(mykobj, NULL, "bar");</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return sizeof(int);</p>
			<p class="source-code">}</p>
			<p>In the preceding code, it makes sense to call <strong class="source-inline">sysfs_notify()</strong> once the value has been updated so that the user code can read the accurate value.</p>
			<p>The user code<a id="_idIndexMarker1199"/> can directly pass the opened attribute file to <strong class="source-inline">poll()</strong> or <strong class="source-inline">select()</strong> without having to read the initial content<a id="_idIndexMarker1200"/> of this attribute. Doing so is at the convenience of the developer. However, note that upon notification, <strong class="source-inline">poll()</strong> returns <strong class="source-inline">POLLERR|POLLPRI</strong> (as are flags, which users must request while invoking <strong class="source-inline">poll()</strong>), while <strong class="source-inline">select()</strong> returns the file descriptor, whether it is waiting for read, write, or exception events.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor216"/>Summary</h1>
			<p>By completing this chapter, you should be familiar with LDM, its data structures (bus, class, device, and driver), and its low-level data structures, which are <strong class="source-inline">kobject</strong>, <strong class="source-inline">kset</strong>, <strong class="source-inline">kobj_type</strong>, and <strong class="source-inline">attributes</strong> (or a group of these). You should now know how objects are represented within the kernel (device topology) and be able to create an attribute (or group) that exposes your device or driver features and properties through sysfs. </p>
			<p>In the next chapter, we will cover the <strong class="bold">IIO</strong> (<strong class="bold">Industrial I/O</strong>) framework, which heavily uses the power of sysfs.</p>
		</div>
	</body></html>