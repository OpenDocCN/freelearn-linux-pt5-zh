- en: 6 Encryption Technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Join our book community on Discord
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://packt.link/SecNet](https://packt.link/SecNet)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may work for a super-secret government agency, or you may be just a regular
    Joe or Jane citizen. Either way, you still have sensitive data that you need to
    protect from prying eyes. Business secrets, government secrets, personal secrets—it
    doesn''t matter; it all needs protection. Locking down users home directories
    with restrictive permissions settings, as we saw in *Chapter 3*, *Securing Normal
    User Accounts*, is only part of the puzzle; we also need encryption. This encryption
    will provide three things for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: This ensures that only people who are authorized to see
    the data can see it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: This ensures that the original data hasn''t been altered by
    unauthorized people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: This ensures that sensitive data is always available, and
    can''t be deleted by unauthorized people.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two general types of data encryption that we'll look at in this chapter
    are meant to protect data at rest and data in transit. We'll begin with using
    file, partition, and directory encryption to protect data at rest. We'll wrap
    up with a look at using OpenSSL to protect data in transit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting directories with eCryptfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using VeraCrypt for the cross-platform sharing of encrypted containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL and the Public Key Infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commercial certificate authorities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating keys, certificate requests, and certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an on-premises certificate authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a certificate authority to an operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenSSL and the Apache web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up mutual authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re ready to get cryptic, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: GNU Privacy Guard (GPG)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll begin with **GNU Privacy Guard** (**GPG**). This is a free open source
    implementation of Phil Zimmermann's Pretty Good Privacy, which he created back
    in 1991\. You can use either one of them to either encrypt or cryptographically
    sign files or messages. In this section, we'll focus strictly on GPG.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some advantages of using GPG:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses strong, hard-to-crack encryption algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the private/public key scheme, which eliminates the need to transfer
    a password to a message or file recipient in a secure manner. Instead, just send
    along your public key, which is useless to anyone other than the intended recipient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use GPG to just encrypt your own files for your own use, the same as
    you'd use any other encryption utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to encrypt email messages, allowing you to have true end-to-end
    encryption for sensitive emails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few GUI-type frontends available to make it somewhat easier to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But, as you might know, there are also some disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Using public keys instead of passwords is great when you work directly only
    with people who you implicitly trust. But for anything beyond that, such as distributing
    a public key to the general population so that everyone can verify your signed
    messages, you're dependent upon a web-of-trust model that can be very hard to
    set up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the end-to-end encryption of email, the recipients of your email must also
    have GPG set up on their systems and know how to use it. That might work in a
    corporate environment, but lots of luck getting your friends to set that up. (I've
    never once succeeded in getting someone else to set up email encryption.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use a standalone email client, such as Mozilla Thunderbird, you can install
    a plugin that will encrypt and decrypt messages automatically. But every time
    a new Thunderbird update is released, the plugin breaks, and it always takes a
    while before a new working version gets released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you could get other people to set up their email clients with GPG, it’s
    still not the perfect privacy solution. That’s because the email **metadata**--the
    email addresses of the sender and the recipient--can’t be encrypted. So, hackers,
    advertisers, or government agencies can still see who you’re exchanging email
    messages with, and use that information to build a profile that tells them a lot
    about your activities, your beliefs, and what kind of a person you are. If you
    really need complete privacy, your best bet is to go with a private messenger
    solution, such as the **Session** messenger. (That however, is beyond the scope
    of this book.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with its numerous weaknesses, GPG is still one of the best ways to share
    encrypted files and emails. GPG comes preinstalled on most Linux distros. So,
    you can use any of your *newer* virtual machines for these demos. (I say *newer*,
    because the procedure will differ slightly on older distros, such as CentOS 7.)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – creating your GPG keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a text-mode AlmaLinux machine, the first thing you need to do is to install
    the `pinentry` package. Do that with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (Note that you won’t have to do this with either a GUI-mode AlmaLinux machine
    or with Ubuntu Server.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create your pair of GPG keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that since you're setting this up for yourself, you don't need `sudo` privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that this command does is to create a populated `.gnupg` directory
    in your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll then be asked to select which kinds of keys you want. We''ll just go
    with the default `RSA and RSA`. RSA keys are stronger and harder to crack than
    the older DSA keys. Elgamal keys are good, but they may not be supported by older
    versions of GPG:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For decent encryption, you'll want to go with a key of at least 3,072 bits,
    because anything smaller is now considered vulnerable. (This is according to the
    newest guidance from the U.S. National Institute of Standards and Technology,
    or NIST.) That’s now the default on our newest Linux distros, so you’re already
    good there. On older distros, such as CentOS 7, the default is only 2048 bits,
    so you’ll need to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select how long you want the keys to remain valid before they automatically
    expire. For our purposes, we''ll go with the default `key does not expire`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide your personal information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On older Linux distros, this could take a while, even when you''re doing all
    of the recommended things to create entropy. On newer Linux distros, the random
    number generator works more efficiently, so you can disregard the notice about
    how the key generation could take a long time. Here’s what you’ll see when the
    process has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the keys did get created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'While you''re at it, take a look at the files that you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These files are your public and private keyrings, a revocation database, and
    a trusted users database.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – symmetrically encrypting your own files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may find GPG useful for encrypting your own files, even when you never
    plan to share them with anyone else. For this, you''ll use symmetric encryption,
    which involves using your own private key for encryption. Before you try this,
    you''ll need to generate your keys, as I outlined in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric key encryption is, well, just that, symmetric. It's symmetric in the
    sense that the key that you would use to encrypt a file is the same key that you
    would use to decrypt the file. That's great for if you're just encrypting files
    for your own use. But if you need to share an encrypted file with someone else,
    you'll need to figure out a secure way to give that person the password. I mean,
    it's not like you'd want to just send the password in a plain-text email.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In addition to your own user account, you''ll also need a user account for
    Maggie. On AlmaLinux, create her account like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, create Maggie’s account like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s encrypt a super-secret file that we just can''t allow to fall into the
    wrong hands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `-c` option indicates that I chose to use symmetric encryption
    with a passphrase for the file. The passphrase that you enter will be for the
    file, not for your private key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at your new set of files. One slight flaw with this is that GPG makes
    an encrypted copy of the file, but it also leaves the original, unencrypted file
    intact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get rid of that unencrypted file with `shred`. We''ll use the `-u` option
    to delete the file, and the `-z` option to overwrite the deleted file with zeros:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't look like anything happened, because `shred` doesn't give you any
    output. But `ls -l` will prove that the file is gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if I were to look at the encrypted file with `less secret_squirrel_stuff.txt.gpg`,
    I would be able to see its contents after being asked to enter my private key
    passphrase. Try this for yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As long as my private key remains loaded into my keyring, I''ll be able to
    view my encrypted file again without having to reenter the passphrase. Now, just
    to prove to you that the file really is encrypted, I''ll create a shared directory,
    and move the file there for others to access. Again, go ahead and give it a try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When I go into that directory to view the file with `less`, I can still see
    its contents without having to reenter my passphrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, let''s see what happens when Maggie tries to view the file. Use `su
    - maggie` to switch to her account, and have her try:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And when she hits the *Y* key to see it anyway, she gets this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Poor Maggie really wants to see my file, but all she can see is encrypted gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: What I've just demonstrated is another advantage of GPG. After entering your
    private key passphrase once, you can view any of your encrypted files without
    having to manually decrypt them, and without having to reenter your passphrase.
    With other symmetric file encryption tools, such as `bcrypt`, you wouldn't be
    able to view your files without manually decrypting them first.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s now say that you no longer need to have this file encrypted, and
    you want to decrypt it in order to let other people see it. Exit Maggie''s account
    by typing `exit`. Then, just use `gpg` with the `-d` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This works differently from how it worked on older Linux distros. On our newer
    distros, we now have to use the `-o` option along with the filename of the decrypted
    file that we want to create. Also, note that the `-o` option has to come before
    the `-d` option, or else you’ll get an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – encrypting files with public keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this lab, you''ll learn about how to encrypt and share a file with GPG public
    key encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a user account for Frank, as you did for Maggie in the previous
    lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a key set for both yourself and for Frank, as I''ve already shown you.
    Next, extract your own public keys into an `ASCII` text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Log in as Frank, and repeat this command for him.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the participants in this would send their keys to each other either
    through an email attachment or by placing the keys in a shared directory. In this
    case, you and Frank will receive each other''s public key files and place them
    into your respective `.gnupg` directories. Once that''s done, import each other''s
    keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the good stuff. Create a super-secret message for Frank, asymmetrically
    encrypt it (`-e`), and sign it (`-s`). Signing the message is the verification
    that the message really is from you, rather than from an impostor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the first thing you have to do is to enter the passphrase for your private
    key. Where it says to enter the user ID, enter `frank`, since he''s the intended
    recipient of your message. But look at the line after that, where it says `There
    is no assurance this key belongs to the named user`. That''s because you still
    haven''t trusted Frank''s public key. We''ll get to that in a bit. The last line
    of the output again says to enter a user ID so that we can designate multiple
    recipients. But Frank is the only one you care about right now, so just hit the
    *Enter* key to break out of the routine. This results in a `.gpg` version of your
    message to Frank:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The final step on your end is to send Frank his encrypted message file by whatever
    means available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When Frank receives his message, he''ll use the `-d` option to view it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Frank enters the passphrase for his private key, and he sees the message. At
    the bottom, he sees the warning about how your public key isn''t trusted, and
    that `There is no indication that the signature belongs to the owner`. Let''s
    say that you and Frank know each other personally, and he knows for a fact that
    the public key really is yours. He then adds your public key to the trusted list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line of this output is the command prompt for the `gpg` shell. Frank
    is concerned with trust, so he''ll enter the `trust` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Frank has known you for quite a while, and he knows for a fact that you''re
    the one who sent the key. So, he chooses option `5` for ultimate trust. Once Frank
    logs out and logs back in, that trust will take effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With no more warning messages, this looks much better. At your end, do the same
    thing with Frank's public key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see in the screen output in *step 8*, you can assign the marginal,
    full, or ultimate trust level to someone else''s public key. Space doesn''t permit
    me to provide a full explanation of the trust levels, but you can read a rather
    colorful explanation here: PGP Web of Trust: Core Concepts Behind Trusted Communication
    — [https://www.linux.com/tutorials/pgp-web-trust-core-concepts-behind-trusted-communication/.](https://www.linux.com/tutorials/pgp-web-trust-core-concepts-behind-trusted-communication/.)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What's so very cool about this is that even though the whole world may have
    your public key, it's useless to anyone who isn't a designated recipient of your
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how to sign a file *without* encrypting it.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – signing a file without encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a file isn''t secret but you still need to ensure authenticity and integrity,
    you can just sign it without encrypting it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an unencrypted message for Frank and then sign it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, this creates a `.gpg` version of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Send the message to Frank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in as Frank. Have him try to open it with `less`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: On older Linux distros, you’ll see a lot of gibberish because of the signature,
    but you’ll also see the plain-text message. On newer Linux distros, you’ll only
    see the plain-text message, without the gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have Frank use `gpg` with the `--verify` option to verify that the signature
    really does belong to you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This wraps it up for our discussion of encrypting individual files. Let's now
    take a look at encrypting block devices and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting partitions with Linux Unified Key Setup (LUKS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Being able to encrypt individual files can be handy, especially if you want
    to share sensitive files with other users. But, other types of encryption are
    also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block encryption**: We can use this for either whole-disk encryption or to
    encrypt individual partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File-level encryption**: We''d use this to encrypt individual directories
    without having to encrypt the underlying partitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containerized Encryption**: Using third-party software that doesn''t come
    with any Linux distribution, we can create encrypted, cross-platform containers
    that can be opened on either Linux, macOS, or Windows machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux Unified Key Setup** (**LUKS**) falls into the first category. It''s
    built into pretty much every Linux distribution, and directions for use are the
    same for each. LUKS is now the default encryption mechanism for pretty much all
    of the newest Linux distros.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering if there's any performance impact with all of this disk
    encryption business. Well, with today's fast CPUs, not really. I run Fedora with
    full-disk encryption on a low-spec, Core i5 laptop, and other than having to enter
    the disk-encryption password when I first boot up, I don't even notice that encryption
    is taking place.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Okay, let's look at encrypting a disk while installing the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Disk encryption during operating system installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you install most any Linux-based operating system, you have the option
    of encrypting the drive during the installation. Just click the **Encryption**
    option on the drive setup screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_01.png](img/file37.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_01.png
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, I just let the installer create the default partitioning scheme.
    On this AlmaLinux 9 machine, that means that the `/` filesystem and the `swap`
    partition will both be encrypted logical volumes. (I'll cover that in a moment.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the installation can continue, I have to create a passphrase to mount
    the encrypted disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_02.png](img/file38.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_02.png
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, whenever I reboot the system, I need to enter this passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_03.png](img/file39.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_03.png
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than actually encrypting a normal disk partition, the installer will
    set up encrypted **logical volumes**. Once the machine is up and running, I can
    look at the list of logical volumes. Here, I see both the `/` logical volume and
    the `swap` logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at the list of **physical volumes**. Actually, there''s only
    one physical volume in the list, and it''s listed as a `luks` physical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the `/etc/` directory, you’ll find the `crypttab` file, which contains an
    entry for this physical volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the underlying physical volume is encrypted, which means that
    both the `/` and the `swap` logical volumes are also encrypted. That's a good
    thing because leaving the swap space unencrypted—a common mistake when setting
    up disk encryption manually—can lead to data leakage. (We’ll talk more about this
    `crypttab` file in just a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – adding an encrypted partition with LUKS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There may be times when you''ll need to either add another encrypted drive
    to an existing machine or encrypt a portable device, such as a USB memory stick.
    This procedure works for both scenarios. Also, the procedure is the same for all
    of the Linux distros that we’re using, so it doesn’t matter which virtual machine
    you use. Follow these steps to add an encrypted partition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bump the size up to 20 GB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_05.png](img/file40.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_05.png
  prefs: []
  type: TYPE_NORMAL
- en: 'After rebooting the machine, you''ll now have a `/dev/sdb` drive to play with.
    We can see that here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the drive in `gdisk`. Use the entire drive for the partition, and leave
    the partition type set at the default type `8300`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'View the details about your new `/dev/sdb1` partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use `cryptsetup` to convert the partition to LUKS format. In this command,
    the `-v` signifies verbose mode, and the `-y` signifies that you''ll have to enter
    your passphrase twice in order to properly verify it. Note that when it says to
    type `yes` all in uppercase, it really does mean to type it in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the information about your new encrypted partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot more to the output than I can show here, but you get the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Map the partition to a device name. You can name the device pretty much whatever
    you want. For now, just name this one `secrets`. I know, it''s a corny name. In
    real life, you won''t want to make it so obvious where you''re storing your secrets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Look in the `/dev/mapper/` directory. You''ll see your new `secrets` device
    listed as a symbolic link to some sort of `dm` device. (In this case, it’s `dm-1`.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `dmsetup` to look at the information about your new device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Format the partition in the usual manner. You can use any filesystem that''s
    supported by your Linux distro. On a production server, that will generally mean
    either XFS or EXT4\. Just for fun, let’s go with XFS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a mount point and mount the encrypted partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `mount` command to verify that the partition is mounted properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the LUKS partition to mount automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only missing piece of the puzzle is to configure the system to automatically
    mount the LUKS partition upon boot-up. To do that, configure two different files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/etc/crypttab**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/fstab**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you encrypted the `sda` drive while installing the operating system, you''ll
    already have a `crypttab` file that contains information about that drive. It
    would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields describe the name and location of the encrypted partition.
    The third field is for the encryption passphrase. If it's set to `none`, as it
    is here, then the passphrase will have to be manually entered upon boot-up.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `fstab` file, we have the entry that actually mounts the partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Well, there are actually two entries in this case, because we have two logical
    volumes, `/` and `swap`, on top of the encrypted physical volume. The `UUID` line
    is the `/boot/` partition, which is the only part of the drive that isn't encrypted.
    Now, let's add our new encrypted partition so that it will mount automatically,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – configuring the LUKS partition to mount automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this lab, you''ll set up the encrypted partition that you created in the
    previous lab to automatically mount when you reboot the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is where it would be extremely helpful to remotely log in to your virtual
    machine from your desktop host machine. By using a GUI-type terminal, be it Terminal
    from a Linux or macOS machine or Cygwin from a Windows machine, you'll have the
    ability to perform copy-and-paste operations, which you won't have if you work
    directly from the virtual machine terminal. (Trust me, you don't want to be typing
    in those long UUIDs.)
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The first step is to obtain the UUID of the encrypted partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy that UUID and paste it into the `/etc/crypttab` file. (If a `cryptab`
    file isn’t already there, just create a new one.) Also, note that you''ll paste
    the UUID in twice. The first time, you''ll prepend it with `luks-`, and the second
    time you''ll append it with `UUID=`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `/etc/fstab` file, adding the last line in the file for your new encrypted
    partition. Note that you again have to use `luks-`, followed by the UUID number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When editing the `fstab` file for adding normal, unencrypted partitions, I always
    like to do `sudo mount -a` to check the `fstab` file for typos. That won't work
    with LUKS partitions though, because `mount` won't recognize the partition until
    the system reads in the `crypttab` file, and that won't happen until I reboot
    the machine. So, just be extra careful with editing `fstab` when adding LUKS partitions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Now for the moment of truth. Reboot the machine to see if everything works.
    Use the `mount` command to verify that your endeavors have been successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although it''s possible to include passwords or keys in the `/etc/crypttab`
    file, my own preference is to not do so. If you must do so, be sure that the passwords
    or keys are stored on an encrypted `/` partition, for which you''ll always have
    to enter a password upon boot-up. You can read more about that here: Store the
    passphrase of encrypted disk in `/etc/crypttab` encrypted: [https://askubuntu.com/questions/181518/store-the-passphrase-of-encrypted-disk-in-etc-crypttab-encrypted](https://askubuntu.com/questions/181518/store-the-passphrase-of-encrypted-disk-in-etc-crypttab-encrypted)'
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we've seen LUKS, let's move on to eCryptfs.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting directories with eCryptfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encrypting entire partitions is cool, but you might, at times, just need to
    use file-level encryption to encrypt an individual directory. For that, we can
    use eCryptfs. We'll need to use our Ubuntu machines for this, because Red Hat
    and its offspring no longer include eCryptfs. (It was in Red Hat 6 and CentOS
    6, but it's no longer even available for installation in any newer versions.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s possible to use eCryptfs on a LUKS-encrypted disk. But, it’s not at all
    necessary, and I really don’t recommend it.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hands-on lab – encrypting a home directory for a new user account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In *Chapter* 3, Securing Normal User Accounts, I showed you how Ubuntu allows
    you to encrypt a user''s home directory as you create his or her user account.
    To review, let''s see the command for creating Goldie''s account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it hasn''t already been done, install the `ecryptfs-utils` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'On an Ubuntu VM, create Goldie''s account with an encrypted directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Have Goldie log in. Have her unwrap her mount passphrase, write it down, and
    store it in a secure place. She''ll need it if she ever needs to recover a corrupted
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When you use `adduser --encrypt-home`, home directories for new users will automatically
    be set to a restrictive permissions value that will keep everyone out except for
    the owner of the directory. This happens even on Ubuntu 20.04 when you leave the
    `adduser.conf` file set with its default settings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private directory within an existing home directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say that you have users on your Ubuntu servers who, for whatever strange
    reason, don't want to encrypt their entire home directories, and want to keep
    the `755` permissions settings on their home directories so that other people
    can access their files. But they also want a private directory that nobody but
    them can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of encrypting an entire home directory, any user can create an encrypted
    private directory within his or her own home directory. Let''s check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it hasn''t already been done, install the `ecryptfs-utils` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To create this private directory, use the interactive `ecryptfs-setup-private`
    utility. If you have admin privileges, you can do this for other users. Users
    without admin privileges can do it for themselves. For our demo, let's say that
    Charlie, my big Siamese/Gray Tabby guy, needs his own encrypted private space.
    (Who knew that cats had secrets, right?)
  prefs: []
  type: TYPE_NORMAL
- en: Create Charlie's account in the normal manner, *without* the encrypted home
    directory option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, log in as Charlie and have him create his own private directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For the login passphrase, Charlie enters his normal password or passphrase
    for logging in to his user account. He could have let the system generate its
    own mount passphrase, but he decided to enter his own. Since he did enter his
    own mount passphrase, he didn''t need to do the `ecryptfs-unwrap-passphrase` command
    to find out what the passphrase is. But, just to show how that command works,
    let''s say that Charlie entered `TurkeyLips` as his mount passphrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it's a horribly weak passphrase, but for our demo purposes, it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have Charlie log out, and then log back in. After this, he can start using
    his new private directory. Also, you can see that he has three new hidden directories
    within his home directory. All three of these new directories are only accessible
    by Charlie, even if he set his top-level home directory so that it’s open to everybody:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `grep ''ecryptfs'' *` command in the `/etc/pam.d` directory. You''ll
    see that PAM is configured to automatically mount users'' encrypted directories
    whenever they log in to the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All righty, then. We now know how to encrypt users' home directories. Now, let's
    find out how to encrypt other directories.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – encrypting other directories with eCryptfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Encrypting other directories is a simple matter of mounting them with the `ecryptfs`
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `secrets2` directory in the top level of the filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `mount` with the `-t ecryptfs` option to encrypt the directory. Note that
    you’ll list the directory name twice, because the it will be used as its own mount
    point. From the menu, choose `1` to enter your desired passphrase, and choose
    the encryption algorithm and the key length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Go with the default of `aes`, and `16` bytes for the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go with the default of `no` for `plaintext passthrough`, and with `yes` for
    filename encryption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Go with the default `Filename Encryption Key` and verify the mounting options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning only comes up when you mount the directory for the first time.
    For the final two questions, type `yes` in order to prevent that warning from
    coming up again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Just for fun, create a file within your new encrypted `secrets2` directory,
    and then unmount the directory. Then, try to do a directory listing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: By choosing to encrypt filenames, nobody can even tell what files you have when
    the directory is unmounted. When you're ready to access your encrypted files again,
    just remount the directory the same as you did before.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting the swap partition with eCryptfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re just encrypting individual directories with eCryptfs instead of
    using LUKS whole-disk encryption, you''ll need to encrypt your swap partition
    in order to prevent accidental data leakage. Fixing that problem requires just
    one simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Don't mind the warning about the missing `/dev/mapper/cryptswap1` file. It will
    get created the next time you reboot the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Using VeraCrypt for cross-platform sharing of encrypted containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once upon a time, there was TrueCrypt, a cross-platform program that allowed
    the sharing of encrypted containers across different operating systems. But the
    project was always shrouded in mystery because its developers would never reveal
    their identities. And then, right out of the blue, the developers released a cryptic
    message about how TrueCrypt was no longer secure, and shut down the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'VeraCrypt is the successor to TrueCrypt, and it allows the sharing of encrypted
    containers across Linux, Windows, macOS, and FreeBSD machines. Although LUKS and
    eCryptfs are good, VeraCrypt offers more flexibility in certain ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, VeraCrypt offers cross-platform sharing, whereas LUKS and eCryptfs
    don't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VeraCrypt allows you to encrypt either whole partitions or whole storage devices,
    or to create virtual encrypted disks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not only can you create encrypted volumes with VeraCrypt, you can also hide
    them, giving you plausible deniability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VeraCrypt comes in both command-line and GUI variants, so it's appropriate for
    either server use or for the casual desktop user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like LUKS and eCryptfs, VeraCrypt is free open source software, which means
    that it's free to use, and that the source code can be audited for either bugs
    or backdoors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on lab – getting and installing VeraCrypt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to install VeraCrypt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download VeraCrypt from here: [https://www.veracrypt.fr/en/Downloads.html](https://www.veracrypt.fr/en/Downloads.html)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Linux version of VeraCrypt comes two ways. First, there’s `.tar.bz2` file,
    which contains a set of universal installer scripts that should work on any Linux
    distribution. Once you extract the `.tar.bz2` archive file, you''ll see three
    scripts for GUI installation and two for console-mode installation. There are
    scripts for both 32-bit and 64-bit versions of Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The executable permission is already set, so all you have to do to install
    is this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You'll need sudo privileges, but the installer will prompt you for your sudo
    password. After reading and agreeing to a rather lengthy license agreement, the
    installation only takes a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: End of lab
  prefs: []
  type: TYPE_NORMAL
- en: More recently, the VeraCrypt developers have also begun supplying `.deb` and
    `.rpm` installer packages for specific Linux distros. For Debian/Ubuntu-type systems,
    use `sudo dpkg -i` to install the `.deb` file. On RHEL/CentOS/AlmaLinux/SUSE systems,
    use `sudo rpm -Uvh` to install the `.rpm` file. Note that you might receive an
    error message telling you to install other packages as dependencies. Also, note
    that there’s no `.rpm` package for the RHEL/AlmaLinux 9 distros. Not to worry
    though, because I’ve just verified that the CentOS 8 package works just fine on
    AlmaLinux 9.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hands-on lab – creating and mounting a VeraCrypt volume in console mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I haven't been able to find any documentation for the console-mode variant of
    VeraCrypt, but you can see a list of the available commands just by typing `veracrypt`.
    For this demo, you'll create a 2 GB encrypted directory. But you can just as easily
    do it elsewhere, such as on a USB memory stick.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new encrypted volume, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take you into an easy-to-use interactive utility. For the most part,
    you''ll be fine just accepting the default options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For the filesystem, the default option of `FAT` gives you the best cross-platform
    compatibility between Linux, macOS, and Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Select your password and a **PIM** (short for **Personal Iterations Multiplier**).
    For my PIM, I entered `8891`. (High PIM values give better security, but they
    will also cause the volume to take longer to mount.) Then, type at least 320 random
    characters in order to generate the encryption key. (This is where it would be
    handy to have my cats walking across my keyboard):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'After you hit the **Enter** key, be patient, because the final generation of
    your encrypted volume will take a few moments. Here, you see that my 2 GB `good_stuff`
    container has been successfully created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Mount this container in order to use it. Begin by creating a mount point directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `veracrypt` utility to mount your container on this mount point:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what VeraCrypt volumes you have mounted, use `veracrypt -l`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: End of lab. That's all there is to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using VeraCrypt in GUI mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Desktop users of any of the supported operating systems can install the GUI
    variant of VeraCrypt. Be aware, though, that you can''t install both the console-mode
    variant and the GUI variant on the same machine, because one will overwrite the
    other. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_06.png](img/file41.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_06.png
  prefs: []
  type: TYPE_NORMAL
- en: Since the main focus of this book is server security, I won't go into the details
    of the GUI version here. But it's fairly self-explanatory, and you can view the
    full VeraCrypt documentation on their website.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get VeraCrypt from here: [https://www.veracrypt.fr/en/Home.html](https://www.veracrypt.fr/en/Home.html).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenSSL and the public key infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With OpenSSL, we can encrypt information on the fly as it goes across the network.
    There's no need to manually encrypt our data before we send it across the network
    because OpenSSL encryption happens automatically. This is important because online
    commerce and banking couldn't exist without it.
  prefs: []
  type: TYPE_NORMAL
- en: The **Secure Sockets Layer** (**SSL**) is the original in-transit encryption
    protocol. Ironically, even though we're using the OpenSSL suite of programs and
    libraries, we no longer want to use SSL. Instead, we now want to use the **Transport
    Layer Security** (**TLS**) protocol . SSL is full of legacy code and a lot of
    vulnerabilities that go along with that legacy code. TLS is newer, and is much
    more secure. But, even when working with TLS, we can still use the OpenSSL suite.
  prefs: []
  type: TYPE_NORMAL
- en: One reason that the older SSL protocol is so bad is because of past government
    regulations, especially here in the U.S., that prohibited the use of strong encryption.
    For the first few years of the public Internet, U.S. website operators couldn't
    legally implement encryption keys that were longer than a measly 40 bits. Even
    back then, a 40-bit key didn't provide a whole lot of security. But the U.S. government
    considered strong encryption as a type of munition, and tried to control it so
    that the governments of other countries couldn't use it. Meanwhile, an Australian
    outfit named Fortify started producing a strong encryption plugin that people
    could install in their Netscape web browsers. This plugin allowed the use of 128-bit
    encryption, and my geek buddies and I all eagerly installed it on our own machines.
    Looking back, I'm not sure that it did a lot of good, because website operators
    in the U.S. were still prohibited from using strong encryption keys on their web
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazingly, the Fortify outfit still has their website up. You can still download
    the Fortify plugin, even though it''s now completely useless. Here’s a screenshot
    of the Fortify website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_07.png](img/file42.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_07.png
  prefs: []
  type: TYPE_NORMAL
- en: An encrypted SSL/TLS session uses both symmetric and asymmetric mechanisms.
    For acceptable performance, it uses symmetric encryption to encrypt the data in
    transit. But symmetric encryption requires a private key to be exchanged between
    the two communication partners. To do that, SSL/TLS first negotiates an asymmetric
    session using the same public key exchange mechanism that we looked at in the
    GPG section.
  prefs: []
  type: TYPE_NORMAL
- en: Once that asymmetric session is set up, the two communication partners can safely
    exchange the private key that they'll use for the symmetric session.
  prefs: []
  type: TYPE_NORMAL
- en: Commercial certificate authorities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make this magic work, you need to install a security certificate onto your
    web server. The certificate serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: It contains the public key that's needed to set up an asymmetric key-exchange
    session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, it can verify the identity of, or authenticate, your website. So,
    for example, users can theoretically be sure that they're connected to their real
    bank, instead of to Joe Hacker's Bank of Crooks and Criminals that's disguised
    as their bank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you shop for a certificate, you''ll find quite a few vendors, which are
    all referred to as **certificate authorities**, or **CAs**. Most CAs, including
    vendors such as Thawte, Symantec, GoDaddy, and Let''s Encrypt, among others, offer
    several different grades of certificates. To help explain the differences between
    the grades of certificates, here''s a screenshot from the GoDaddy site:'
  prefs: []
  type: TYPE_NORMAL
- en: At the left-hand side of the list, at the cheapest price, is the **standard**
    **Domain Verification** **(DV)** offering. Vendors advertise this type of certificate
    as for use where all you really care about is encryption. Identity verification
    is limited to domain verification, which means that yeah, records for your site
    have been found on a publicly accessible DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: At the right, we see the **premium** **Extended Verification** (**EV**) offering.
    This is the top-of-the-line, highest-grade certificate that certificate vendors
    offer. With this extended verification grade of certificate, you have to jump
    through some hoops to prove that you are who you really are and that your website
    and your business are both legit. It used to be that both Firefox and Chrome would
    show a green High-Assurance bar in the URL of any site with an EV certificate,
    but they no longer do, for reasons that I’ll explain in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, just how good is this **Premium SSL EV** certificate with rigorous identity
    testing? Well, not quite as good as I thought. Two days after I wrote this explanation
    about the different types of certificates for the previous edition of this book,
    I received the latest edition of the *Bulletproof TLS Newsletter* from Feisty
    Duck Publishing. The big news was that Google and Mozilla decided to remove the
    green high assurance bar from future editions of Chrome and Firefox. Their reasons
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The green high assurance bar is meant to help users avoid phishing attacks.
    But for that to be useful, users have to notice that the high assurance bar is
    even there. Studies have shown that most people don't even notice it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ian Carrol, a security researcher, questions the value of extended validation
    certificates. As an experiment, he was able to register a bogus certificate for
    Stripe, Inc., which is a legitimate company. The certificate vendor finally did
    notice their mistake and revoked the certificate, but it's something that shouldn't
    have happened in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of everything else, it's also possible to register extended validation
    certificates with incorrect information. This indicates that the verification
    process isn't quite as thorough as the certificate vendors would have us believe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But in spite of these occasional problems, I still believe that extended validation
    certificates are useful. When I access my bank account, I like to believe that
    extra identity verification is never a bad thing.
  prefs: []
  type: TYPE_NORMAL
- en: Something else that's rather curious is that certificate vendors still market
    their certificates as SSL certificates. Don't be fooled, though. As long as the
    website owners configure their servers correctly, they'll be using the more secure
    TLS protocol, rather than SSL.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Let''s Encrypt** is a fairly new organization that has the goal of ensuring
    that all websites everywhere are set up with encryption. It''s a worthy goal,
    but it has also introduced a new problem. Here’s what the Let''s Encrypt website
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_09.png](img/file43.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_09.png
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a certificate from one of the traditional vendors, you have to use
    the OpenSSL utility to create your keys and a certificate request. Then, you'll
    submit the certificate request, proof of identity if applicable, and your payment
    to the certificate authority. Depending upon which grade of certificate you purchase,
    you'll have to wait anywhere from one to several days before you get the certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Let's Encrypt is totally free of charge, and you don't have to jump through
    hoops to get the certificate. Instead, you configure your web server to automatically
    obtain a new Let's Encrypt certificate each time you set up a new website. If
    Let's Encrypt sees that your new site has a valid record on a publicly accessible
    DNS server, it will automatically create and install the certificate on your server.
    Other than having to configure your web server to use Let's Encrypt, it's no fuss,
    no muss.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with Let's Encrypt is that it's even easier to abuse than the extended
    validation certificates. Shortly after Let's Encrypt began operation, criminals
    began setting up domains that appeared to be subdomains of legitimate business
    websites. So, people see that the website is encrypted and that the domain name
    seems to be legit, and they merrily enter their credentials without giving things
    a second thought. Let's Encrypt is handy and useful for legitimate purposes, but
    be aware of its downside, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before you choose a certificate vendor, do some research. Sometimes, even the
    big name vendors have problems. A few years ago, Google removed Symantec from
    Chrome's list of trusted certificate authorities because Symantec had allegedly
    violated industry best practices several times. That's rather ironic, considering
    that Symantec has had a long history of being a trusted vendor of security products.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we've covered the basics of SSL/TLS encryption, let's see how to implement
    it with the OpenSSL suite.
  prefs: []
  type: TYPE_NORMAL
- en: Creating keys, certificate signing requests, and certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The good news is that, regardless of which *newer* Linux distribution we're
    on, this procedure is the same. (I say *newer*, because the newest versions of
    Ubuntu and RHEL/AlmaLinux use OpenSSL version 3\. Some of the Version 3 commands
    are different from what you’ll see on the older versions.) The not-so-good news
    is that OpenSSL can be a bit tricky to learn because it has loads of sub-commands,
    each with its own set of options and arguments. Bear with me, and I'll break it
    down the best I can.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a self-signed certificate with an RSA key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A self-signed certificate is useful when all you need is encryption, or for
    testing purposes. There''s no identity verification involved with self-signed
    certificates, so you never want to use them on servers that your users need to
    trust. Let''s say that I need to test my new website setup before putting it into
    production, and I don''t want to do my testing with a for-real key and certificate.
    I''ll create the key and the self-signed certificate with one single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**openssl**: I''m using OpenSSL with just my normal user privileges. For now,
    I''m doing everything in my own home directory, so there''s no need for root or
    sudo privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**req**: This is the sub-command for managing certificate signing requests
    (CSRs). When creating self-signed certificates, OpenSSL will create a temporary
    CSR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-newkey rsa:2048**: I''m creating an RSA keypair that''s 2,048 bits in length.
    I''d actually like to use something a bit longer, but that might impact server
    performance when setting up the TLS handshake. (Again, this is preceded by only
    a single dash.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-nodes**: This means that I''m not encrypting the private key that I''m about
    to create. If I were to encrypt the private key, I would have to enter the private
    key passphrase every time I restart the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-keyout donnie-domain.key-x509**: I''m creating the private key with the
    name `donnie-domain.key-x509`. The `x509` part indicates that this will be used
    for a self-signed certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-days 365**: The certificate will expire in one year.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-out donnie-domain.crt**: Finally, I''m creating the `donnie-domain.crt`
    certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you run this command, you'll be prompted to enter information about your
    business and your server. (We'll look at that in just a moment.) After creating
    this key and certificate, I'll need to move them to their proper locations and
    configure my web server to find them. (We'll also touch on that in a bit.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypting the private key is an optional step, which I didn''t do. If I were
    to encrypt the private key, I would have to enter the passphrase every time that
    I restart the web server. That could be problematic if there are any web server
    admins who don''t have the passphrase. And, even though this sounds counter-intuitive,
    encrypting the private key that''s on the web server doesn''t really help that
    much with security. Any malicious person who can get physical access to the web
    server can use memory forensics tools to get the private key from system memory,
    even if the key is encrypted. But if you plan to make a backup of the key to store
    elsewhere, definitely encrypt that copy. So now, let''s make an encrypted backup
    copy of my private key that I can safely store somewhere other than on the web
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two things to look at here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rsa -aes256** means that I''m using the AES256 encryption algorithm to encrypt
    an RSA key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ensure that I made a copy instead of overwriting the original unencrypted
    key, I specified `donnie-domain-encrypted.key-x509` as the name for the copy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a self-signed certificate with an Elliptic Curve key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The only part of this that's different is the `ec:<(openssl ecparam -name secp384r1)`
    part. It looks strange, but it's really quite logical. When creating an EC key,
    you have to specify a parameter with the `ecparam` command. You'll normally see
    this as two separate `openssl` commands, but it's handier to combine the two commands
    together as one command within another command. The inner `openssl` command is
    feeding its output back to the outer `openssl` command via the input redirection
    symbol (`<`). The `-name secp384r1` part means that we're creating a 384-bit EC
    key with the `secp384` named curve algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an RSA key and a Certificate Signing Request
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Normally, we won''t use a self-signed certificate for anything that''s meant
    for the general public to interface with. Instead, we want to obtain a certificate
    from a commercial CA because we want users to know that they''re connecting to
    a server for which the identity of its owners has been verified. To obtain a certificate
    from a trusted CA, you''ll first need to create a key and a **Certificate Signing
    Request** (**CSR**). Let''s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**openssl**: I''m using OpenSSL with just my normal user privileges. For now,
    I''m doing everything in my own home directory, so there''s no need for root or
    sudo privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**req**: This is the sub-command for managing CSRs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--out CSR.csr**: The `--out` means that I''m creating something. In this
    case, I''m creating the CSR with the name `CSR.csr`. All CSRs will have the `.csr`
    filename extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-new**: This is a new request. (And yes, this is preceded by a single dash,
    unlike the `out` in the previous line that''s preceded by two dashes.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-newkey rsa:2048**: I''m creating an RSA key pair that''s 2,048 bits in length.
    I''d actually like to use something a bit longer, but that will impact server
    performance when setting up the TLS handshake. (Again, this is preceded by only
    a single dash.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-nodes**: This means that I''m not encrypting the private key that I''m about
    to create. If I were to encrypt the private key, I would have to enter the private
    key passphrase every time I restart the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-keyout server-privatekey.key**: Finally, I''m creating the private key with
    the name `server-privatekey.key`. Since this key isn''t for a self-signed certificate,
    I didn''t put the `-x509` at the end of the key''s filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now look at a snippet from the command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: So, I've entered my information about my company location, name, and website
    name. Note the bottom where it asks me for a **challenge password**. This password
    doesn't encrypt either the key or the certificate. Rather, it's just a shared
    secret between the certificate authority and me that's embedded into the certificate.
    I'll need to keep it in a safe place in case I ever need to reinstall the certificate.
    (And, for goodness' sake, when you do this for real, pick a better password than
    `TurkeyLips`.)
  prefs: []
  type: TYPE_NORMAL
- en: As before, I didn't encrypt the private key. But if you need to make a backup
    copy, just follow the procedure that you saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a certificate from a commercial CA, go to their website and follow
    their directions. When you receive your certificate, install it in the proper
    place in your web server and configure the web server to find it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EC key and a CSR
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Up until a few years ago, you would have wanted to use RSA keys on your web
    servers. They don''t have the security weaknesses that certain other key types
    have, and they''re widely supported by pretty much every web browser. But RSA
    keys do have two weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Even at the standard 2,048-bit length, they require more computational power
    than other key types. Increasing the key length for better security could degrade
    web server performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA doesn't offer **Perfect Forward Secrecy** (**PFS**). In other words, if
    someone were to capture a session key that's produced by the RSA algorithm, they
    would be able to decrypt material from the past. If the same person were to capture
    a session key that was produced by a PFS algorithm, they would only be able to
    decrypt the current communication stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new-fangled EC algorithms instead of the creaky old RSA solves both
    of these problems. But if you pick up a book from even a couple of years ago,
    you'll see that it recommends using RSA keys for backward compatibility with older
    web browsers. That's partly because certain operating systems, along with their
    associated proprietary web browsers, lingered on for far longer than they should
    have. (*I'm looking at you, Windows XP.*) Now though, as I sit here writing this
    in October 2022, I think it's safe to start ignoring the needs of anyone who refuses
    to move on from these antiquated platforms. I mean, Windows XP and Windows 7 both
    reached end-of-life several years ago. So, let's get with the times, people.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike what we just saw with the RSA keys, we can't create the EC private key
    and the CSR all with one simple command. With EC, we need to do this in two separate
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I''ll create the private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '**genpkey -algorithm EC**: The `genpkey` command is a fairly recent addition
    to OpenSSL and is now the recommended way to create private keys. Here, I''m telling
    it to create a key with the EC algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-out eckey.pem**: I''m creating the `eckey.pem` key, which is in the **Privacy
    Enhanced Mail** (**PEM**) format. The RSA keys that I created in the previous
    section were also PEM keys, but I used the `.key` filename extension on them.
    You can use either the `.key` or the `.pem` filename extension, and they''ll both
    work. But if you use the `.pem` extension, everyone who looks at them can tell
    at a glance that they are PEM keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-pkeyopt ec_paramgen_curve:P-384**: This tells OpenSSL to create an EC key
    that''s 384 bits in length. A beautiful thing about EC is that its shorter-length
    keys provide the same encryption strength as the longer RSA keys. In this case,
    we have a 384-bit key that''s actually stronger than a 2,048-bit RSA key. And,
    it requires less computational power. (I call that a total win!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-pkeyopt ec_param_enc:named_curve**: This is the encoding method that I''m
    using for the EC parameters. It has to be set to either `named_curve or explicit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, I''ll create a CSR and sign it with my new private key, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The output that I didn't include is the same as what you saw in the RSA key
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The final steps are the same as before. Choose a CA and let them tell you how
    to submit the CSR. When they issue the certificate, install it on your web server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an on-premises CA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Buying a certificate from a commercial CA is good when you're dealing with the
    general public on a website that they need to trust. But for an organization's
    own internal use, it's not always necessary or feasible to buy commercial certificates.
    Let's say that your organization has a group of developers who need their own
    client certificates to access the development server. Buying a commercial certificate
    for each developer would be costly, and it would require the development server
    to have a publicly accessible domain name so that the commercial CA can do domain
    verification. Even going with the free-of-charge Let's Encrypt certificates isn't
    a good option, because that would also require that the development server have
    a publicly accessible domain name. Option 2 is to go with self-signed certificates.
    But that won't work because client authentication doesn't work with self-signed
    certificates. That leaves Option 3, setting up a private, on-premises CA.
  prefs: []
  type: TYPE_NORMAL
- en: If you search around on the web, you'll find lots of guides for setting up your
    own private CA. But almost all of them are woefully outdated, and most of them
    are for setting up a CA with OpenSSL. There's nothing wrong with using OpenSSL
    for a CA, except that setting it up is a rather convoluted, multi-stage process.
    Then, when you finally do have it set up, you have to use complex commands from
    the command line in order to do anything. What we want is something a bit more
    user-friendly for both you and your users.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – setting up a Dogtag CA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dogtag PKI is much simpler to set up, and it has a nice web interface that OpenSSL
    doesn't have. It's available in the normal repositories of Debian/Ubuntu and RHEL/AlmaLinux,
    but under different package names. In the Debian/Ubuntu repositories, the package
    name is `dogtag-pki`. In the RHEL/AlmaLinux repositories, the name is `pki-ca`.
    (For some reason that I don't understand, you'll never see Red Hat folk use the
    "Dogtag" name.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we install the Dogtag packages, we need to do a couple of simple chores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Either create a record in a local DNS server for the Dogtag server, or create
    an entry for it in its own `/etc/hosts` file
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this on either your AlmaLinux 9 or your Ubuntu 22.04 VM, and I’ll
    give directions for both. To access the Dogtag dashboard, we''ll use a second
    Linux VM with a desktop environment installed. With all this out of the way, let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On your server virtual machine, set an FQDN, substituting your own for the
    one that I''m using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `/etc/hosts` file to add a line like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Use your virtual machine's own IP address and FQDN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, increase the number of file descriptors that your system can have open
    at one time. (Otherwise, you''ll get a warning message when you run the directory
    server installer.) Do that by editing the `/etc/security/limits.conf` file. At
    the end of the file, add these two lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Reboot the machine so that the new hostname and file descriptor limits can take
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dogtag stores its certificate and user information in an LDAP database. In
    this step, we''ll install the LDAP server package, along with the Dogtag package.
    For AlmaLinux 9, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu 22.04, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an LDAP Directory Server (DS) instance by first creating an `instance.inf`
    file in the root user’s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: (Yes, I know that it’s bad practice to put passwords into plain-text configuration
    files. That’s okay, though. We’ll take care of that in just a bit.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now use this `instance.inf` file, along with the `dscreate` utility,
    to create the Directory Server instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it''s time to create the CA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Accept all the defaults until you get to the very end. When it asks **Begin
    Installation?**, type `Yes`. When you get to the Directory Server part, enter
    the password that you used to create the DS instance in the previous step. Note
    that you'll be offered the choice to access the LDAP DS instance via a secure
    port. But since we're setting up LDAP and Dogtag on the same machine, this isn't
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that the Dogtag service will automatically start by enabling the `pki-tomcatd.target`.
    Do that with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'After everything is set up, you’ll no longer need the `instance.inf` file that
    holds your password in plain-text. Get rid of it by doing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll access the Dogtag web interface via port `8443/tcp`. On the AlmaLinux
    machine, open that port like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Ubuntu machine, assuming that you’re using the Uncomplicated Firewall,
    open the port like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'On another Linux virtual machine that has a desktop interface, edit the `/etc/hosts`
    file to add the same line that you added to the server `hosts` file in *step 2*.
    Then, open the Firefox web browser on that machine and navigate to the Dogtag
    dashboard. In keeping with the example in this scenario, the URL would look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll receive a warning about the certificate being invalid because it''s
    self-signed. That''s normal, because every CA has to start with a self-signed
    certificate, and you haven''t yet imported this certificate into your trust store.
    Temporarily add the exception and continue. (In other words, clear the checkmark
    from the **Add permanently** box. You''ll see why in the next lab.) Click through
    the links until you reach this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![19501_06_10.png](img/file44.png)'
  prefs: []
  type: TYPE_IMG
- en: 19501_06_10.png
  prefs: []
  type: TYPE_NORMAL
- en: Click the **SSL End Users Services** link. This is where end users can request
    the various types of certificates. Click the back button to return to the previous
    screen. This time, click on the **Agent Services** link. You won't be able to
    go there because it requires you to install a certificate into your web browser
    for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The certificate that you need to install is in the `/root/.dogtag/pki-tomcat/`
    directory of your Dogtag VM. Copy this file to the VM on which you''re using Firefox
    to access the Dogtag dashboard. Do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Of course, substitute your own username and IP address. Note that the file will
    automatically land in your own home directory, and that its ownership will change
    from root to your own username.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the VM with Firefox, import the certificate into Firefox. From the Firefox
    menu, choose **Settings**, then **Privacy and Security**. At the very bottom of
    the screen, click on **View Certificates**. Click the **Your Certificates** tab
    at the top and the **Import** button at the bottom. Navigate to your home directory
    and choose the certificate that you just sent over from the Dogtag server VM.
    Once the import operation is complete, you should see the **PKI Administrator**
    certificate in the list of imported certificates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![19501_06_11.png](img/file45.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 19501_06_11.png
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now try to access the **Agent Services** page. You'll be allowed access once
    you confirm that you want to use the certificate that you just imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a users need to request a certificate for their own use, they'll use `openssl`
    to create a key and a CSR, as I've already shown you earlier in this chapter.
    They'll then go to the SSL End User Services page and paste the contents of their
    CSR into the box for the certificate that they're requesting. An administrator
    will then go to the Agent Services page to approve the request and issue the certificate.
    (To help familiarize yourself with Dogtag, I encourage you to click around on
    the web interface, exploring all the options.)
  prefs: []
  type: TYPE_NORMAL
- en: Adding a CA to an operating system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the major web browsers, such as Firefox, Chrome, and Chromium, come
    with their own pre-defined database of trusted CAs and their associated certificates.
    When you create a private CA, you'll need to import the CA certificate into your
    browser's trust store. Otherwise, your users will keep receiving messages about
    how the sites that they're viewing are using untrusted certificates. Indeed, that's
    the case with our Dogtag server. Any user who accesses it to request a certificate
    will receive a warning about how the CA is using a non-trusted certificate. We'll
    fix that by exporting the CA certificate from the Dogtag server and importing
    it into all of your users' browsers. Let's dig in, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – exporting and importing the Dogtag CA certificate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Dogtag web portal doesn''t have an option for this, so we''ll have to use
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: In your home directory of the Dogtag server, create the `password.txt` file.
    On the first line of the file, insert the password for the server's certificate.
    (It's the password that you set when you ran the `pkispawn` command.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the server key and certificate like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Run an `ls -l` command to verify that the `pki-server.p12` file was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with the `p12` file is that it contains both the server''s private
    key and its certificate. But to add a certificate to the CA section of your browser''s
    trusted store, you have to have just the certificate without the key. Extract
    the certificate like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Transfer this new `pki-server.crt` file to a machine with a graphical desktop.
    In Firefox, open **Settings/Privacy & Security**. Click the **View Certificates**
    button at the bottom. Click the **Authorities** tab and import the new certificate.
    Select **Trust this CA to identify websites** and to **Trust this CA to identify
    email users**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![19501_06_12.png](img/file46.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 19501_06_12.png
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Close Firefox and then open it again to ensure that the certificate takes effect.
    Navigate to the Dogtag portal. This time, you shouldn't receive any warning messages
    about using an untrusted certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing the CA into Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With either Firefox or Chrome, you'll import the CA certificate directly into
    the browser's trust store, regardless of which operating system you're running.
    But if you're stuck running one of Microsoft's own proprietary browsers on that
    off-brand operating system that's known as Windows, then you'll need to import
    the certificate into the Windows trust store instead of into the browser. Fortunately,
    that's incredibly easy to do. After you copy the certificate to the Windows machine,
    just open up Windows File Explorer and double-click on the certificate file. Then,
    click the **Install Certificate** button on the pop-up dialog box. If your organization
    is running an Active Directory domain, just ask one of the AD administrators to
    import it into Active Directory for you.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL and the Apache web server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A default installation of any web server isn't all that secure, so you'll need
    to harden it up a bit. One way to do that is by disabling the weaker SSL/TLS encryption
    algorithms. The general principles apply to all web servers, but for our examples,
    we'll just look at Apache. (The topic of web server hardening is quite extensive.
    For the present, I'll confine the discussion to hardening the SSL/TLS configuration.)
    You can use either Ubuntu 22.04 or AlmaLinux 9 for this section, but the package
    names and configuration files are different between the two distros. The configurations
    also differ between CentOS 7 and AlmaLinux 9, so we'll look at them as well. But,
    before I can explain the configuration options, I need to say a word or two about
    the history of the SSL/TLS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1990s, engineers at Netscape invented the SSL protocol. Version 1 never
    saw the light of day, so the first released version was SSL version 2 (SSLv2).
    SSLv2 had its share of weaknesses, many of which were addressed in SSLv3\. At
    the insistence of Microsoft, the next version was renamed Transport Layer Security
    (TLS) version 1 (TLSv1). (I have no idea why Microsoft objected to the SSL name.)
    The current version is TLSv1.3, which is finally now supported by most Linux distros.
    By default, Apache still supports some of the older protocols. Our goal is to
    disable those older protocols. Only a couple of years ago, that would have meant
    disabling SSLv2 and SSLv3 and leaving TLSv1 through TLSv1.2, due to questionable
    browser support for anything newer. Now, though, I think it's safe to disable
    support for anything older than TLSv1.3\. When I wrote the Second Edition of this
    book back in 2019, Apple Safari was the only major browser that didn’t support
    TLSv1.3\. Fortunately, even Apple is now on board with the newest TLS.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening Apache SSL/TLS on Ubuntu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this demo, we''ll use two Ubuntu 22.04 virtual machines. We''ll install
    Apache on the first one and `sslscan` on the second one. (This `sslscan` package
    isn’t available in the AlmaLinux repository.):'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Apache on your Ubuntu machine, just do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This also installs the `mod_ssl` package, which contains the libraries and configuration
    files for SSL/TLS implementation.
  prefs: []
  type: TYPE_NORMAL
- en: And, of course, if you have a firewall enabled, be sure that port `443/tcp`
    is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Apache service is already enabled and running, so you don''t have to mess
    with that. But you do need to enable the default SSL site and the SSL module with
    these three commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look at the SSL/TLS configuration, let''s set up a scanner machine
    to externally test our configuration. On the second Ubuntu VM, install the `sslscan`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'On the scanner machine, scan the Ubuntu machine on which you installed Apache,
    substituting the IP address of your own machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note the algorithms and the protocol versions that are supported. You should
    see that SSLv2, SSLv3, TLSv1.0, and TLSv1.1 are all disabled. TLSv1.2 and TLSv1.3
    are the only ones that are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Ubuntu VM with Apache, edit the `/etc/apache2/mods-enabled/ssl.conf`
    file. Look for the line that says this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Apache daemon to make this change take effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Scan this machine again, and note the output. You should see that the older
    TLSv1.2 protocol has also now been disabled. So, congratulations! You've just
    made a quick and easy security upgrade to your web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's take a look at RHEL 9/AlmaLinux 9.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening Apache SSL/TLS on RHEL 9/AlmaLinux 9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this demo, you''ll install Apache and `mod_ssl` on an AlmaLinux 9 VM. (Unlike
    on Ubuntu, you have to install these as two separate packages.) Use the same scanner
    VM that you used in the previous lab. A new feature of the RHEL 8/9 distros is
    that you can now set system-wide crypto policies for most of your services and
    applications that require cryptography. We''ll take a quick look at it here, and
    again in *Chapter 7*, *SSH Hardening*:'
  prefs: []
  type: TYPE_NORMAL
- en: Before doing anything, shut down your AlmaLinux 9 VM and create a snapshot from
    the VirtualBox console. That’s because in just a bit, you’ll need to go back to
    a clean snapshot in order to test the crypto policies feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On your AlmaLinux 9 VM, install Apache and `mod_ssl`, and start the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Open port `443` on the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'From the scanner VM, scan the Apache VM, substituting your own IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As you just saw on the Ubuntu server, nothing older than TLSv1.2 is supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on the Apache VM, view the status of the system-wide crypto configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: You should see `DEFAULT` as the output. With `DEFAULT`, you get TLSv1.2 as the
    minimum protocol version along with the goodness of TLSv1.3\. But you'll also
    see some TLSv1.2 algorithms that we can do without.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shut down the Apache VM. Go to the VirtualBox console and restore the snapshot
    that you created in Step 1, in order to get rid of the Apache installation. Then,
    restart the virtual machine and set the crypto policy to `FUTURE`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: I had a good reason for having you create and restore the snapshot before setting
    `FUTURE` mode. It’s just that if you install Apache before setting `FUTURE` mode,
    you’ll no longer be able to start Apache. So, if you want to run your Apache webserver
    with `FUTURE` mode, you’ll need to set `FUTURE` mode first, then install Apache.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Reboot the Apache VM so that the `FUTURE` mode will take effect. Verify that
    `FUTURE` mode has taken effect by doing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Install the `mod_ssl` and Apache packages, and start Apache as you did in Step
    2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scan the webserver VM as you did in Step 4\. You'll see that TLSv1.2 is still
    enabled, but with a much smaller list of enabled algorithms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two other crypto policy modes besides the two that I've shown here.
    `LEGACY` mode enables some really old algorithms that we don't want to use unless
    it's absolutely necessary to support older clients. But, as I keep saying, anyone
    who's using a client that's that old needs to upgrade. There's also the `FIPS`
    mode, which you might need to use if you’re doing business with the U.S. government.
    Even though the `update-crypto-policies` utility appears to work with `FIPS` mode,
    Red Hat recommends against doing that. Instead, they recommend setting `FIPS`
    mode as you install the operating system. We’ll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Setting FIPS mode on RHEL 9/AlmaLinux 9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: FIPS stands for Federal Information Processing Standards, and is a set of cybersecurity
    requirements for people and companies who want to do business with the United
    States government. Setting your server to run in `FIPS` mode involves more than
    just disabling some weak encryption algorithms. It also involves installing a
    set of modules that help harden other aspects of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the `update-crypto-policies` utility has an option for setting
    `FIPS` mode, you’ll never use it. To set `FIPS` mode on a machine on which the
    operating system has already been installed, you’d instead use the `sudo fips-mode-setup
    --enable` command. But, Red Hat even recommends against doing that. Instead, they
    recommend setting `FIPS` mode as you install the operating system. Their concern
    is that setting `FIPS` mode after installing the operating system might leave
    behind encryption keys that were created with non-`FIPS` algorithms. Instead,
    they recommend setting `FIPS` mode as you install the operating system. Fortunately,
    that’s easy. All you have to do is interrupt the installer’s boot process and
    make a quick edit to the kernel configuration. Here’s how to do it as you create
    a new AlmaLinux VM:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new AlmaLinux VM and boot up the AlmaLinux installer. Hit the **Up
    arrow** key to highlight the **Install AlmaLinux** option. Instead of hitting
    the **Enter** key to continue, hit the **Tab** key to bring up the kernel options.
    Here’s what you should see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/file47.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'At the bottom of the screen, add `fips=1` to the end of the kernel option line.
    It should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/file48.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Hit the Enter key and continue installation as you normally would.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the installation is complete and the VM has rebooted, check the status
    of `FIPS` mode, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Finally, install `mod_ssl` and Apache. Open the the firewall port and scan the
    VM with `sslscan`, as you did in the previous exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End of lab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one caveat that you should know about when setting `FIPS` mode on any
    RHEL 9-type distro. It’s that the current version of the FIPS standard is version
    140-3\. However, at the time of this writing in October 2022, RHEL 9 and its offspring
    still only meet the standards for FIPS 140-2\. The Red Hat documentation gives
    no insight into when that might change.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why I’m not covering `FIPS` mode on Ubuntu, it’s just that
    it’s not possible to set `FIPS` mode on the free-of-charge version of Ubuntu.
    If you want to run Ubuntu in `FIPS` mode, you’ll have to purchase a support contract.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, let’s take a quick look at the legacy CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening Apache SSL/TLS on RHEL 7/CentOS 7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Okay, I did say that we'd look at doing this on a CentOS 7 machine. But, I'll
    make it brief.
  prefs: []
  type: TYPE_NORMAL
- en: You'll install Apache and `mod_ssl` on CentOS 7 the same way that you did on
    AlmaLinux 9, except that you'll use the `yum` command instead of the `dnf` command.
    As with AlmaLinux, you'll need to enable and start Apache with `systemctl`, but
    you won't need to enable the ssl site or the ssl module. And, of course, make
    sure that port `443` is open on the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you do an sslscan of a CentOS 7 machine, you''ll see a very long list
    of supported algorithms, from TLSv1 through TLSv1.2\. Even with TLSv1.2, you''ll
    see a few really bad things, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DES` and `SHA` in these lines indicate that we''re supporting use of the
    antiquated **Data Encryption Standard** (**DES**) and version 1 of the **Secure
    Hash Algorithm** (**SHA**). That is not good. Get rid of them by editing the `/etc/httpd/conf.d/ssl.conf`
    file. Look for these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Change them to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload Apache with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Scan the machine again, and you'll see a lot fewer supported algorithms. (And
    by the way, one advantage of the new TLSv1.3 is that it completely gets rid of
    these legacy algorithms.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at how users can identify themselves to a server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up mutual authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you access your bank's secure website, your web browser requires that the
    web server authenticate itself to the browser. In other words, the browser demands
    to see the server's certificate for the website so that it can verify if it's
    valid. This way, you have some assurance that you're logging in to the bank's
    real, genuine website instead of a counterfeit site. You then have to authenticate
    yourself to the web server, but you'll normally do that with a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: If a web server is set up to allow it, users can instead authenticate themselves
    with a certificate. This way, there's no password for the bad guys to either steal
    or crack. You already saw how this is done when you imported Dogtag's `ca_admin_cert.p12`
    certificate into your web browser. This certificate gave you the awesome power
    to access Dogtag's administrator page. Your normal end users won't have this certificate,
    so all they can access is just the end-user page where they can request certificates.
  prefs: []
  type: TYPE_NORMAL
- en: The major web servers—Apache, Nginx, lighttpd, and some others—support mutual
    authentication. Space doesn't permit me to go into the details of setting this
    up on a server, but the documentation for whichever server you use will cover
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s get back to the future!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing quantum-resistant encryption algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve likely heard of quantum computers, which have nothing to do with the
    old *Quantum Leap* show on television. This new type of computer is still in the
    experimental stage, and likely will remain there for some time to come. Still,
    there’s a lot of hype about what they’ll be like when they finally are ready for
    production use. Supposedly, they’ll be way more powerful than the current generation
    of computers, and they’ll supposedly be able to easily crack even the strongest
    of the current encryption algorithms. Indeed, that’s a rather scary prediction.
    (Perhaps it’s fitting that I’m typing this on Halloween, the scariest day of the
    year.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though there’s some skepticism about whether this dire prediction will
    come true, or of whether production-grade quantum computers will even see the
    light of day, the U.S. federal government is taking this seriously. Here’s the
    list of quantum-resistant algorithms that the National Institutes of Standards
    and Technology (NIST) currently recommends:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CRYSTALS-Kyber**: This one is for general encryption. Cloudflare, Amazon,
    and IBM already use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRYSTALS-Dilithium**: This is for encrypted digital signatures. NIST recommends
    this one as the primary signature algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FALCON**: This is also a signature algorithm. NIST recommends it for whenever
    you need a signature that’s smaller than what CRYSTALS-Dilithium can provide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SPHINCS+**: This is the third signature algorithm, which is slower and larger
    than the first two. It uses a different approach than what the first two use,
    which is why NIST recommends it as a backup, in case the first two get hacked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how do we know that a particular encryption algorithm is resistant to quantum
    computer hacking if viable quantum computers don’t yet exist? Well, I wish that
    I could tell you, but I can’t. At any rate, you might not have to worry too much
    abut this just yet, but it’s still worthwhile to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s wrap this baby up and move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, we've covered a lot of ground in this chapter. We began by using
    GPG to encrypt, sign, and share encrypted files. We then looked at various methods
    of encrypting drives, partitions, directories, and sharable containers. After
    that, we looked at how to use OpenSSL to create keys, CSRs, and certificates.
    But since we don't want to use self-signed certificates all the time and commercial
    certificates aren't always necessary, we looked at how to set up a private CA
    with Dogtag. We then looked at simple ways to harden the TLS configuration on
    the Apache web server, and we touched on the subject of mutual authentication.
    Finally, we saw an introduction to quantum-resistant encryption algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we had plenty of hands-on labs. That's good, because after all,
    idle hands are the devil's workshop, and we certainly don't want any of that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at ways to harden Secure Shell. I'll see you
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which of the following is not an advantage of GPG?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses strong, hard-to-crack algorithms.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It works well for sharing secrets with people you don't know.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Its public/private key scheme eliminates the need to share passwords.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use it to encrypt files that you don’t intend to share, for your own
    personal use.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to send an encrypted message to Frank. What must you do before you
    can encrypt his message with GPG so that you don't have to share a password?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nothing. Just encrypt the message with your own private key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Import Frank's private key into your keyring and send Frank your private key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Import Frank's public key into your keyring and send Frank your public key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Just import Frank's public key into your keyring.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Just import Frank's private key into your keyring.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following would be the proper choice for whole-disk encryption
    on a Linux system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bitlocker
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VeraCrypt
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: eCryptfs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: LUKS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you use eCryptfs to encrypt users' home directories and you're not using
    whole-disk encryption, what other action must you take in order to prevent leakage
    of sensitive data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that users use strong private keys.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encrypt the swap partition.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You must use eCryptfs in whole-disk mode.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In which of the following scenarios would you use VeraCrypt?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you want to implement whole-disk encryption.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you just want to encrypt users' home directories.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you'd prefer to use a proprietary, closed source encryption system.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever you need to create encrypted containers that you can share with Windows,
    macOS, and BSD users.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to ensure that your web browser trusts certificates from the Dogtag
    CA. How do you do it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You use `pki-server` to export the CA certificate and key, and then use `openssl
    pkcs12` to extract just the certificate. Then, import the certificate into your
    browser.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You import the `ca_admin.cert` certificate into your browser.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You import the `ca_admin_cert.p12` certificate into your browser.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You import the `snakeoil.pem` certificate into your browser.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explanations about TLS and OpenSSL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenSSL Tutorial-How do SSL certificate, private keys, and CSRs work?: [https://phoenixnap.com/kb/openssl-tutorial-ssl-certificates-private-keys-csrs](https://phoenixnap.com/kb/openssl-tutorial-ssl-certificates-private-keys-csrs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transport Layer Security version 1.3 in Red Hat 8: [https://www.redhat.com/en/blog/transport-layer-security-version-13-red-hat-enterprise-linux-8](https://www.redhat.com/en/blog/transport-layer-security-version-13-red-hat-enterprise-linux-8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OpenSSL website: [https://www.openssl.org/](https://www.openssl.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Feisty Duck Publishing, who offer books, training, and newsletters about OpenSSL:
    [https://www.feistyduck.com/](https://www.feistyduck.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problems with EV certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome browser moving EV UI to Page Info: [https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/ev-to-page-info.md](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/security/ev-to-page-info.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extended Validation is Broken: [https://www.cyberscoop.com/easy-fake-extended-validation-certificates-research-shows/](https://www.cyberscoop.com/easy-fake-extended-validation-certificates-research-shows/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EV Certificates issued with "Default City" as the location: [https://groups.google.com/forum/#!topic/mozilla.dev.security.policy/1oReSOPCNy0](https://groups.google.com/forum/#!topic/mozilla.dev.security.policy/1oReSOPCNy0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EV certificates issued with erroneous information: [https://twitter.com/Scott_Helme/status/1163546360328740864](https://twitter.com/Scott_Helme/status/1163546360328740864)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Problems with free Let''s Encrypt certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CyberCriminals abusing free Let''s Encrypt certificates: [https://www.infoworld.com/article/3019926/cyber-criminals-abusing-free-lets-encrypt-certificates.html](https://www.infoworld.com/article/3019926/cyber-criminals-abusing-free-lets-encrypt-certificates.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dogtag CA:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to increase the number of file descriptors in Linux: [https://www.tecmint.com/increase-set-open-file-limits-in-linux/](https://www.tecmint.com/increase-set-open-file-limits-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dogtag PKI Wiki: [https://www.dogtagpki.org/wiki/PKI_Main_Page](https://www.dogtagpki.org/wiki/PKI_Main_Page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Import CA into Linux and Windows: [https://thomas-leister.de/en/how-to-import-ca-root-certificate/](https://thomas-leister.de/en/how-to-import-ca-root-certificate/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Red Hat (Dogtag) Certificate Authority Documentation: [https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/](https://access.redhat.com/documentation/en-us/red_hat_certificate_system/9/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RHEL 9/AlmaLinux 9:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting system-wide cryptographic policies: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/using-the-system-wide-cryptographic-policies_security-hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIPS
  prefs: []
  type: TYPE_NORMAL
- en: 'FIPS home page: [https://www.nist.gov/itl/fips-general-information](https://www.nist.gov/itl/fips-general-information)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Red Hat in FIPS mode: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantum-resistant encryption
  prefs: []
  type: TYPE_NORMAL
- en: 'NIST announces quantum-resistant algorithms: [https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms](https://www.nist.gov/news-events/news/2022/07/nist-announces-first-four-quantum-resistant-cryptographic-algorithms)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some people are skeptical about quantum-computing: [https://www.fudzilla.com/news/55434-quantum-computing-is-neither-dead-or-alive](https://www.fudzilla.com/news/55434-quantum-computing-is-neither-dead-or-alive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
