<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Taming vi"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Taming vi</h1></div></div></div><p>You may have some experience with vi, or what is now known as Vim (which is when simply put—vi improved). All too often, I find that those first experiences have never been good ones or to be looked back upon with much fondness. Guiding you through the initially unfathomable regime of vi, we are going to make sure that you are the master of vi and you leave wanting to use this tool from the gods. vi is like everything else in the sense that you just need to stick with it in the early days and keep practicing. Remember how you persevered for many hours riding your bicycle as a toddler and became a master, despite a few bruised knees? I want you to persevere with vi too. We will start with a little command-line magic to make the whole <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) experience a better one. We <a class="indexterm" id="id0"/>will then be ready to start our black-belt experience in vi.</p><p>In this chapter, we will go through the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CLI trickery</strong></span> – shortcuts that you will love</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vim and vi</strong></span>: In this section, you will learn to differentiate between these twins and meet their graphical cousin</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Getting the .vimrc setup the way you like</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Search and replace</strong></span>: In this section, you will learn how to quickly find and replace text within files from both inside and outside Vim</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Learning to remove extraneous comments from a file with a few deft key strokes</strong></span></li></ul></div><div class="section" title="CLI trickery – shortcuts that you will love"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>CLI trickery – shortcuts that you will love</h1></div></div></div><p>So before we dice into the wonderful world of text editing that is vi, we will warm up with a few<a class="indexterm" id="id1"/> exercises on the keyboard. Linux is my passion, as is automation. I am always keen to create scripts to carry out tasks so that those tasks become repeatedly correct. Once the script is created and tested, we will have the knowledge and faith that it will run in the same way every time and we will not make mistakes or miss critical steps, either because it gets boring or we are working late on a Friday night and just want to go home. Scripting itself is just knowing the command line <a class="indexterm" id="id2"/>well and being able to use it at its best. This truth remains across all systems that you will work with.</p><p>On the command line, we may try a little more black magic by executing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd dir1 || mkdir dir1 &amp;&amp; cd dir1</strong></span>
</pre></div><p>With this, we <a class="indexterm" id="id3"/>have used the <code class="literal">cd</code> command to enter the <code class="literal">dir1</code> directory. The double pipe or vertical bar indicates that we will attempt the next command only if the first command fails. This means that if we fail to switch to the <code class="literal">dir1</code> directory, we will run the <code class="literal">mkdir dir1</code> command to create it. If the directory creation succeeds, we then change into that directory.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>The <code class="literal">||</code> part denotes that the second command will run only on the failure of the first. The <code class="literal">&amp;&amp;</code> part denotes that the second command will run only if the first command succeeds.</p></div></div><p>The command history is a little more and hugely better than just an up arrow key! Consider the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir dir1</strong></span>
<span class="strong"><strong>$ cd !$</strong></span>
</pre></div><p>The <code class="literal">!$</code> part represents the last argument, so in this way, the second line evaluates to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd dir1</strong></span>
</pre></div><p>In this way, we can rewrite the initial command sequence, by combining both concepts, to create the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd dir1 || mkdir !$ &amp;&amp; cd !$</strong></span>
</pre></div><p>We can repeat the last command as well as the last argument. More importantly, we can specify the start characters for the last command. If it was merely the last command, then the up arrow key would suffice. If we were working on a web server configuration, we may want to edit the configuration file with vi, start the service, and then test with a command-line browser. We can represent these tasks using the following three commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># vi /etc/httpd/conf/httpd.conf</strong></span>
<span class="strong"><strong># service httpd restart</strong></span>
<span class="strong"><strong>w3m localhost</strong></span>
</pre></div><p>Having run these three commands in the correct order, hoping for success, we may notice that we still have issues and that we need to start re-editing the configuration file for Apache, the<a class="indexterm" id="id4"/> web server. We can now abbreviate the command list to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># !v</strong></span>
<span class="strong"><strong># !s</strong></span>
<span class="strong"><strong># !w</strong></span>
</pre></div><p>The <code class="literal">!v</code> command<a class="indexterm" id="id5"/> will rerun the last command in my history that begins with <a class="indexterm" id="id6"/>a <code class="literal">v</code>, and likewise with <code class="literal">s</code> and <code class="literal">w</code>. This way, we can appear to be <a class="indexterm" id="id7"/>terribly proficient and working really quickly, thus gaining more time to do what really interests us, perhaps a short 9 holes?</p><p>In a similar fashion to our first glance at the history using the <code class="literal">!$</code> symbols to represent the last argument, we can use <code class="literal">!?73</code>. This would look for <code class="literal">73</code> anywhere as an argument or part of an argument. With my current history, this would relate to the date command we ran earlier. Let's take a look:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ !?73</strong></span>
</pre></div><p>With my history, the sequence will expand to and run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ date --date "73 days ago"</strong></span>
</pre></div><p>Looking at my command history from the last command run to the first, we search for <code class="literal">73</code> anywhere as a command argument. We make a note that we exclusively look for <code class="literal">73</code>, meaning we are looking for the character <code class="literal">7</code> followed by the character <code class="literal">3</code>. We have to then bear in mind that we would also match <code class="literal">273</code> or <code class="literal">733</code> if they existed in my history.</p><p>Having mastered a little of the Bash shell history functions, we should practice to make this second nature.</p></div></div>
<div class="section" title="Vim and vi"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Vim and vi</h1></div></div></div><p>Ah yes, Vim<a class="indexterm" id="id8"/> and <a class="indexterm" id="id9"/>vi! They sound like some ancient mystic potion that ensures long life and wisdom. Alas though, they are not.</p><p>The <a class="indexterm" id="id10"/>command-line text editor vi was first written in 1976 and became part of the first release of BSD Unix in 1978. Even though it is command line driven and with no <span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) or menu, a 2009 survey conducted by Linux Journal found that vi was the most popular editor, beating even gedit, the GUI GNOME editor, into second place. I am not averse to the GUI, but I find a GUI editor to be restrictive and slow. I can honestly say that the majority of, if not all, tasks can be performed by me more quickly in vi.</p><p>That being said, in CentOS, you will not find vi; vi is purely a default alias that is provided for<a class="indexterm" id="id11"/> convenience, and links to the <code class="literal">vim</code> command. We can view this on my CentOS 6.5 console using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ alias | grep vi</strong></span>
</pre></div><p>The output <a class="indexterm" id="id12"/>of the command should look similar to the following screenshot:</p><p> </p><div class="mediaobject"><img alt="Vim and vi" src="graphics/5902OS_01_01.jpg"/></div><p>
</p><p>Vim is a contraction of <span class="strong"><strong>Vi IMproved</strong></span> and was first publicly released in 1991 and authored by Bram Moolenaar, initially targeted at the Amiga system. It has been common in the Linux platform since the early 2000s. As the name suggests, it is based on vi and is improved; on CentOS, it is distributed with the <code class="literal">vim-enhanced</code> package. These improvements are most commonly useful with the syntax-highlighting feature available for languages such as PERL, Python, and PHP. Another such improvement is that it can work traditionally on the command line or with a GUI frontend. To install the graphical interface for Vim, you will need to add the <code class="literal">vim-X11</code> package as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># yum install -y vim-X11</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>One limitation, of course, is that you will require the X11 server to be running. In an enterprise, the server will often run without a GUI and you can connect using secure shell to a command-line shell only.</p></div></div><p>If you are new to vi, then using the graphical version can be helpful, as the menus also display the command-line shortcuts. To edit a file with vi or Vim on the command line, we can simply use a command similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi &lt;filename-to-edit&gt;</strong></span>
</pre></div><p>It is possible to use the graphical version of an editor when you are working on the CentOS desktop as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gvim &lt;filename-to-edit&gt;</strong></span>
</pre></div><p>or</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vimx -g &lt;filename-to-edit&gt;</strong></span>
</pre></div><p>I would <a class="indexterm" id="id13"/>recommend using the <code class="literal">gvim</code> command, as it doesn't require the additional <a class="indexterm" id="id14"/>option <a class="indexterm" id="id15"/>and causes less confusion. Starting <code class="literal">vimx</code> without the <code class="literal">-g</code> option just starts the normal Vim program.</p></div>
<div class="section" title="Getting the .vimrc setup the way you like"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Getting the .vimrc setup the way you like</h1></div></div></div><p>As with many programs in Linux, Vim has the option to read settings from a run-control file. This can be centralized via the <code class="literal">/etc/vimrc</code> file, or for each user via the <code class="literal">~/.vimrc</code> file. With<a class="indexterm" id="id16"/> this file, especially with our own version, you can <a class="indexterm" id="id17"/>customize how Vim appears and controls its functionalities.</p><p>Firstly, we will look at line numbering. Often when we edit a file, we do so as the console has reported an error on a particular line just after we have tried running a script or starting a service; we know we have a syntax error. Let's say we want to go directly to the offending line <code class="literal">97</code> of the <code class="literal">test.php</code> file. Then, we would duly type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi +97 test.php</strong></span>
</pre></div><p>This is assuming that we were in the same directory as our file. Similarly, should we want to go directly to the first occurrence of the word <code class="literal">install</code> within the <code class="literal">readme</code> file, we could issue the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ vi +/install readme</strong></span>
</pre></div><p>Then, as if by magic, we are transported to the correct line that we require. However, in the case of the word <code class="literal">search</code>, the word that was <code class="literal">search</code> is highlighted in color. If that is not desirable, then we can simply turn off that feature. Within Vim, we can type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:nohlsearch</strong></span>
</pre></div><p>If there are settings that we want to make permanent within Vim, we can edit the <code class="literal">.vimrc</code> file in our home directory. This is our own personal settings file and as such, changes made here will not affect anyone else. If we want to affect system-wide settings, then we can use the <code class="literal">/etc/vimrc</code> file. Try adding the following line to the <code class="literal">~/.vimrc</code> file to persistently disable the highlight <code class="literal">search</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>set nohlsearch</strong></span>
</pre></div><p>With this addition, each time we start Vim, the setting is ready for us. As we view our files though, from within Vim, we may prefer to have line numbering turned on. Sometimes this makes life easier, but other times, we may prefer to have line numbering off, especially in cases where we have lines starting with numbers (because the display can become confusing). To enable line numbering, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:set number</strong></span>
</pre></div><p>To turn line numbering off, we can use the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:set nonumber</strong></span>
</pre></div><p>As before, we can always put the desired start-up value in the <code class="literal">.vimrc</code> file. However, before we do this, let's look at key mappings within Vim and how we can create a shortcut<a class="indexterm" id="id18"/> to toggle line numbering on and off. We would like<a class="indexterm" id="id19"/> to create a mapping for the normal mode in Vim. This is the mode when we first enter Vim and we are not editing, just navigating the file; using the <span class="emphasis"><em>Esc</em></span> key, we can always return to the normal mode. Execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:nmap &lt;C-N&gt; : set invnumber&lt;CR&gt;</strong></span>
</pre></div><p>The <code class="literal">nmap</code> command<a class="indexterm" id="id20"/> denotes that we are making a mapping for the normal mode only. We are mapping the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>N</em></span> keys to run the sub command <code class="literal">:set invnumber</code> followed by <code class="literal">&lt;CR&gt;</code>.</p><p>With this in place, we can now use the combination of <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>N</em></span> to toggle line numbering on and off. Now we are really starting to make some steam with this product, and you can gain some appreciation of why it is so popular. Before we make the final edit to the <code class="literal">.vimrc</code> file, we will see how to navigate lines by number while in vi or Vim. Making sure that we are in the normal mode using the <span class="emphasis"><em>Esc</em></span> key, we can use <code class="literal">2G</code> or <code class="literal">2gg</code> to navigate to line 2 of the current file; likewise, <code class="literal">234G</code> or <code class="literal">234gg</code> would go to line 234 and <code class="literal">G</code> or <code class="literal">gg</code> would navigate to the end of the file. Simple but not simple enough; I would prefer to type the line number followed by the <span class="emphasis"><em>Enter</em></span> key. For this, we map the <span class="emphasis"><em>Enter</em></span> key to <span class="emphasis"><em>G</em></span>. If we choose to use the <span class="emphasis"><em>Enter</em></span> key without a preceding number, then we are taken directly to the end of the document, just as we would is we used the key <span class="emphasis"><em>G</em></span> by itself. Execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:nmap &lt;CR&gt; G</strong></span>
</pre></div><p>Now we simply type in the desired line number followed by <span class="emphasis"><em>Enter</em></span>. This in turn is interpreted as the number followed by <span class="emphasis"><em>G</em></span>. In this way, we can navigate easily to the correct line. We can persist this setting by adding the following text to the <code class="literal">.vimrc</code> file, which should now read similar to the following text as we review all the settings made within this subsection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>set nohlsearch number</strong></span>
<span class="strong"><strong>nmap &lt;C-N&gt; : set invnumber&lt;CR&gt;</strong></span>
<span class="strong"><strong>nmap &lt;CR&gt; G</strong></span>
</pre></div><p>Now sit back and enjoy what you have achieved, remembering though that practice is the key to knowledge being retained.</p></div>
<div class="section" title="Search and replace"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Search and replace</h1></div></div></div><p>So we are not exactly on a "search and destroy" mission, but if it helps by adding a little enjoyment to our learning, then we can embark upon a search and replace mission. Linux has a huge amount of power available on the command line and nothing less than the stream editor, sed. Even without entering the Vim editor, we can search for and replace text in a single <a class="indexterm" id="id21"/>file or even across multiple files. Not having to use <a class="indexterm" id="id22"/>an interactive editor opens up more administrative <a class="indexterm" id="id23"/>scope to us by being able to script updates across a single or many servers. The functionality we have in the <code class="literal">sed</code> command is available to us for use from within Vim or as a standalone application. We will be learning in this subsection how to search for and replace text within files using sed and from within Vim, building skills that we can use across CentOS and other operating systems including OS X on the Mac.</p><p>Firstly, let's take a scenario that we have recently changed our company name and we need to change all the references of <code class="literal">Dungeons</code> in a text document to <code class="literal">Dragons</code>. Using sed, we could run the command directly from the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sed -i 's/Dungeons/Dragons/g' /path/file</strong></span>
</pre></div><p>This will read the file line by line, replacing all occurrences of the string <code class="literal">Dungeons</code> with <code class="literal">Dragons</code>. The <code class="literal">-i</code> option allows for in-pace edits, meaning we edit the file without the need to redirect the output from sed to a new file. The <code class="literal">g</code> option allows for the replacement to occur across all instances of <code class="literal">Dragon</code> even if it appears more than once per line.</p><p>To do the same within Vim where we have the file open, run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:%s/Dungeons/Dragons/g</strong></span>
</pre></div><p>The percent symbol is used to specify the range as the whole document; whereas if we use the following command, we would only search lines 3 through 12 inclusive of the search string. In this case, the range is said to be lines 3 to 12 whereas with <code class="literal">%</code>, the range is the complete document.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:3,12s/Dungeons/Dragons/g</strong></span>
</pre></div><p>The range can be very useful when perhaps we want to indent some code in a file. In the following line, we again search lines 3 through to 12 and add a Tab to the start of each line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:s/3,12s/^/\t/</strong></span>
</pre></div><p>We have set the range in the previous command within Vim to represent lines <code class="literal">3</code> to <code class="literal">12</code> again. These<a class="indexterm" id="id24"/> lines may represent the contents of an <code class="literal">if</code> statement, for <a class="indexterm" id="id25"/>example, that we would like to indent. We search first for the carat symbol, <code class="literal">^</code> (the start of a line), and replace it with a tab (<code class="literal">\t</code>). There is no need for the global option as the start of a line obviously only occurs once per line. Using this method, we can quickly add indents to a file as required, and we are again Zen superheroes of Vim.</p></div>
<div class="section" title="Learning to remove extraneous comments from a file with a few deft key strokes"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Learning to remove extraneous comments from a file with a few deft key strokes</h1></div></div></div><p>Now that<a class="indexterm" id="id26"/> we are the administrator, the Zen master of search and replace, we can use these skills to tidy configuration<a class="indexterm" id="id27"/> files that <a class="indexterm" id="id28"/>often have many hundreds of commented lines within them. I do not mind documentation but when it becomes such an overwhelming majority, it can take over. Consider the <code class="literal">httpd.conf</code> Apache configuration file under <code class="literal">/etc/httpd/conf/</code>. This has 675 commented lines. We perhaps want to keep the original file as a reference. So let's first make a copy by executing the following command; we know how to do this from the <span class="emphasis"><em>Preface</em></span> of this book and if you did not read it, now is your chance to read it before a letter goes home to your parents.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># cd /etc/httpd/conf</strong></span>
<span class="strong"><strong># cp httpd.conf   httpd.conf.$(date +%F)</strong></span>
</pre></div><p>We can easily list the commented lines using the following command that counts the lines that begin with the <code class="literal">#</code> sign, a comment:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># egrep -c '^#' httpd.conf</strong></span>
</pre></div><p>On my system, we see that there are 675 such lines. Using sed or Vim, we can remove the comments, firstly, with sed, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># sed  -i '/^#/d' httpd.conf</strong></span>
</pre></div><p>Then, within Vim with the file open, it is a little different:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:g/^#/d</strong></span>
</pre></div><p>The result is the same in both examples where we have reduced the numbers of lines in the file by about two-thirds.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Summary</h1></div></div></div><p>In each chapter, I want to make sure that there has been at least one item of value that you feel you can take away with you and use; how did I do in this chapter? If you recall, we have reviewed a few shortcuts that may help us navigate the command history effectively. Quickly, we moved on to discover the text editor vi or, more commonly now, Vim. For those that need a little help getting started with Vim, we additionally have gVim available to use if we are working on the desktop. Customizing any system is important to make us feel that we own the system and it works for us. With Vim, we can use the <code class="literal">.vimrc</code> file found in our home directory. We were able to add a little bling to Vim with some extra key mapping and desirable options. From then on, it was straight down to work to see what Vim could do, and how the search and replace and delete options that we reviewed worked.</p></div></body></html>