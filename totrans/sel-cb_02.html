<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Dealing with File Labels</h1></div></div></div><p>In this chapter, we will cover how file labels are set and managed, and learn how to configure the SELinux policy ourselves to use and assign the right file labels. The recipes that this chapter covers are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining file contexts through patterns</li><li class="listitem" style="list-style-type: disc">Using substitution definitions</li><li class="listitem" style="list-style-type: disc">Enhancing an SELinux policy with file transitions</li><li class="listitem" style="list-style-type: disc">Setting resource-sensitivity labels</li><li class="listitem" style="list-style-type: disc">Configuring sensitivity categories</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Introduction</h1></div></div></div><p>Setting, resetting, and governing file labels are the most common tasks administrators have to<a id="id98" class="indexterm"/> perform on an SELinux-enabled system. The policies that are provided by policy developers as well as Linux distributions offer sane defaults to use, but many implementations harbor different locations for services and files. Companies often install their custom scripts and logfiles in nondefault locations, and many daemons can be configured to support multiple instances on the same system—each of them using a different base directory.</p><p>System administrators will know how to set context definitions through the <code class="literal">semanage</code> application and then reset the contexts of the target files using <code class="literal">setfiles</code> or <code class="literal">restorecon</code>:</p><div><pre class="programlisting">
<strong>~# semanage fcontext –a –t httpd_sys_content_t "/srv/web/zone/htdocs(/.*)?"</strong>
<strong>~# restorecon –RF /srv/web/zone/htdocs</strong>
</pre></div><p>This, however, is a local definition, which, if necessary, needs to be exported and imported in order to transfer it to other systems:</p><div><pre class="programlisting">
<strong>~# semanage export -f local_selinux.mods</strong>
<strong>~# semanage import -f local_selinux.mods</strong>
</pre></div><p>By moving context definitions into the SELinux policy realm, such definitions can be easily<a id="id99" class="indexterm"/> installed on multiple systems and managed centrally as we've seen for SELinux policy modules.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Defining file contexts through patterns</h1></div></div></div><p>SELinux <a id="id100" class="indexterm"/>policy modules can contain file context <a id="id101" class="indexterm"/>definitions through their <code class="literal">.fc</code> files. In these files, path expressions are used to point to the various locations that should match a particular file context, and class identifiers are used to differentiate file context definitions based on the file class (directories, regular files, symbolic links, and more).</p><p>In this recipe, we'll create a <code class="literal">mylogging</code> SELinux module, which defines additional path specifications for logging-related contexts. We will use direct file paths as well as regular expressions, and take a look at the various class identifiers.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec32"/>How to do it…</h2></div></div></div><p>To define a file context through an SELinux policy module, use the following approach:</p><div><ol class="orderedlist arabic"><li class="listitem">With <code class="literal">matchpathcon</code>, we can check what is the context that the SELinux tools would reset the resource to:<div><pre class="programlisting">
<strong>~# matchpathcon /service/log</strong>
<strong>/service/log  system_u:object_r:default_t</strong>
</pre></div></li><li class="listitem">Create the <code class="literal">mylogging.te</code> file in which we mention the types that are going to be used in the definition. It is a best practice to handle types that are not defined by the SELinux module itself through a different SELinux module. In this example though, we also declare <code class="literal">var_t</code> to keep the example simple:<div><pre class="programlisting">policy_module(mylogging, 0.2)
gen_require(`
  type var_t;
  type var_log_t;
  type auditd_log_t;
')</pre></div></li><li class="listitem">Next, create the <code class="literal">mylogging.fc</code> file in which we declare the path expressions and their associated file context:<div><pre class="programlisting">/service(/.*)?    gen_context(system_u:object_r:var_t,s0)
/service/log(/.*)?    gen_context(system_u:object_r:var_log_t,s0)
/service/log/audit(/.*)?    gen_context(system_u:object_r:auditd_log_t,s0)
/lxc/.*/log  -d  gen_context(system_u:object_r:var_log_t,s0)
/var/opt/oracle/listener\.log  --  gen_context(system_u:object_r:var_log_t,s0)</pre></div></li><li class="listitem">Now, build the policy module and load it:<div><pre class="programlisting">
<strong>~$ make mylogging.pp</strong>
<strong>~$ semodule –i mylogging.pp</strong>
</pre></div></li><li class="listitem">With <code class="literal">matchpathcon</code>, we can now verify whether the context known to the SELinux tools is the correct one:<div><pre class="programlisting">
<strong>~# matchpathcon /service/log</strong>
<strong>/service/log  system_u:object_r:var_log_t</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec33"/>How it works…</h2></div></div></div><p>An <a id="id102" class="indexterm"/>SELinux policy module contains everything<a id="id103" class="indexterm"/> SELinux needs to properly handle a set of policy rules. This includes the rules themselves (which are declared in a <code class="literal">.te</code> file) with optional interface declarations (in the <code class="literal">.if</code> files), which define interfaces that other policies can call in order to generate specific SELinux rules. The third and final part of an SELinux policy module is the related file contexts file —hence the <code class="literal">.fc</code> file suffix.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Context declarations in a <code class="literal">.fc</code> file do not automatically enforce and set these contexts. These are merely definitions used by the SELinux utilities and libraries when a relabeling operation occurs.</p></div></div><p>This contexts file contains, per line:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A path expression to which an absolute file path should match</li><li class="listitem" style="list-style-type: disc">An optional class identifier to discern contexts (files, directories, sockets, symbolic links, and so on)</li><li class="listitem" style="list-style-type: disc">The context to be assigned to this path</li></ul></div><p>Each part of the context definition is whitespace delimited:</p><div><pre class="programlisting">&lt;path&gt;  [&lt;class identifier&gt;]  &lt;context&gt;</pre></div><p>The lines can be ordered to the policy developers' liking. Most developers order paths in an alphabetical order with grouping based on the top-level directory.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec09"/>Path expressions</h3></div></div></div><p>The <a id="id104" class="indexterm"/>regular expression support in the SELinux tools and<a id="id105" class="indexterm"/> libraries is <a id="id106" class="indexterm"/>based on <strong>Perl-Compatible Regular Expressions</strong> (<strong>PCRE</strong>).</p><p>Of all possible expressions, the simplest expression to use is the one without globbing, such as the following code:</p><div><pre class="programlisting">/var/opt/oracle/listener\.log</pre></div><p>An important part of this is the escape of the period—if we don't escape the period, then the PCRE support would treat the period as any character matching not only a <code class="literal">listener.log</code> file, but also <code class="literal">listener_log</code> or <code class="literal">listenerslog</code>.</p><p>A very <a id="id107" class="indexterm"/>common expression is the one that matches a particular<a id="id108" class="indexterm"/> directory and all subdirectories and files inside, which is represented in the following example:</p><div><pre class="programlisting">/service(/.*)?</pre></div><p>This<a id="id109" class="indexterm"/> ensures that there is always a context<a id="id110" class="indexterm"/> definition for a file or directory within.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec10"/>The order of processing</h3></div></div></div><p>Given <a id="id111" class="indexterm"/>the exhaustive list of path expressions that a regular system<a id="id112" class="indexterm"/> has, a file path can match multiple rules, so which one will the SELinux utilities use?</p><p>Basically, the SELinux utilities follow the principle of <em>most specific first</em>. Given two lines A and B, this is checked in the following order, where the first match wins:</p><div><ol class="orderedlist arabic"><li class="listitem">If line A has a regular expression in it and B doesn't, then B is more specific.</li><li class="listitem">If the number of characters before the first regular expression in line A is less than the number of characters before the first regular expression in line B, then B is more specific.</li><li class="listitem">If the number of characters in line A is less than the number of characters in line B, then line B is more specific.</li><li class="listitem">If line A does not specify an SELinux type (so that the context part of it is <code class="literal">&lt;&lt;none&gt;&gt;</code>) and line B does, then line B is more specific.</li></ol></div><p>The SELinux utilities will load in the definitions given through the files available at <code class="literal">/etc/selinux/mcs/contexts/files/</code>, but will give preference to the ones in <code class="literal">file_contexts.local</code> (and then <code class="literal">file_contexts.homedirs</code>) as those are the definitions made by the system administrator locally. However, if a local definition uses a regular expression and a policy-provided definition doesn't, then the policy-provided definition is still used. This is the only exception to the preference rules between the various context files.</p><p>The SELinux <a id="id113" class="indexterm"/>utilities provide a tool called <code class="literal">findcon</code> (part of the <code class="literal">setools</code> or <code class="literal">setools-console</code> package) that can be used to analyze this ordering, which shows the matching patterns within a single (!) context definition file and orders them from least specific to most specific:</p><div><pre class="programlisting">
<strong>~$ findcon /etc/selinux/mcs/contexts/files/file_contexts -p /var/log/aide</strong>
<strong>/.*    system_u:object_r:default_t:s0</strong>
<strong>/var/.*    system_u:object_r:var_t:s0</strong>
<strong>/var/log/.*  system_u:object_r:var_log_t:s0</strong>
<strong>/var/log/aide(/.*)?  system_u:object_r:aide_log_t:s0</strong>
</pre></div><p>If only <a id="id114" class="indexterm"/>the actual context definition is needed (and not the full <a id="id115" class="indexterm"/>set of matching expressions with the precedence order<a id="id116" class="indexterm"/> as <code class="literal">findcon</code> shows), then <code class="literal">matchpathcon</code> can be used instead:</p><div><pre class="programlisting">
<strong>~# matchpathcon /var/log/aide</strong>
<strong>/var/log/aide  system_u:object_r:aide_log_t:s0</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec11"/>Class identifiers</h3></div></div></div><p>The second part of the context definition is an optional part—a class identifier. Through a class identifier, developers can tell the SELinux utilities that a context definition is only applicable if the path expression matches a particular file class. If the class identifier is omitted, then<a id="id117" class="indexterm"/> any class matches.</p><p>If a <a id="id118" class="indexterm"/>class identifier is shown, then one (per line) of the following<a id="id119" class="indexterm"/> identifiers can be used:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The '<code class="literal">--</code>' identifier is <a id="id120" class="indexterm"/>used for regular files</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-d</code>' identifier <a id="id121" class="indexterm"/>is used for directories</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-l</code>' identifier<a id="id122" class="indexterm"/> is used for symbolic links</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-b</code>' identifier<a id="id123" class="indexterm"/> is used for block devices</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-c</code>' identifier<a id="id124" class="indexterm"/> is used for character devices</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-p</code>' identifier<a id="id125" class="indexterm"/> is used for FIFO files</li><li class="listitem" style="list-style-type: disc">The '<code class="literal">-s</code>' identifier<a id="id126" class="indexterm"/> is used for sockets</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec12"/>Context declaration</h3></div></div></div><p>The final <a id="id127" class="indexterm"/>part of a context definition is the context itself that is to<a id="id128" class="indexterm"/> be assigned to all matching resources. It is generated through the <code class="literal">gen_context</code> macro, as follows:</p><div><pre class="programlisting">gen_context(system_u:object_r:var_t,s0)</pre></div><p>The <code class="literal">gen_context</code> macro is used to differentiate context definitions based on policy features. If the <a id="id129" class="indexterm"/>target policy does not support MLS, then only the first argument (<code class="literal">system_u:object_r:var_t</code>, in the example) is used. If the policy supports MLS but only a single sensitivity (<code class="literal">s0</code>), then <code class="literal">:s0</code> is appended to the context. Otherwise, the second argument (coincidentally also <code class="literal">s0</code> in the example) is appended (with a colon in front).</p><p>Generally, contexts only differ on the SELinux type. The SELinux owner and SELinux role of the resource usually remain <code class="literal">system_u</code> and <code class="literal">object_r</code> respectively.</p><p>A special value for the context is <code class="literal">&lt;&lt;none&gt;&gt;</code>, like in the following definition:</p><div><pre class="programlisting">/proc  -d  &lt;&lt;none&gt;&gt;</pre></div><p>This<a id="id130" class="indexterm"/> tells the SELinux utilities that they should never try to <a id="id131" class="indexterm"/>set the context of this resource. Whenever an administrator<a id="id132" class="indexterm"/> triggers a filesystem relabeling operation, these specific locations will not have their label changed (regardless of their current label). This does <em>not</em> mean that an existing context should be removed!</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec34"/>There's more...</h2></div></div></div><p>In the recipe, we covered how to define labels in great detail. If many changes are made, it makes sense to force a relabel on the entire system. On Red Hat systems, this can be accomplished by creating a flag file and rebooting the system:</p><div><pre class="programlisting">
<strong>~# touch /.autorelabel</strong>
<strong>~# reboot</strong>
</pre></div><p>On Gentoo systems, the entire system can be relabeled using the <code class="literal">rlpkg</code> command:</p><div><pre class="programlisting">
<strong>~# rlpkg -a -r</strong>
</pre></div><p>On Red Hat systems, the command to relabel the system is called <code class="literal">fixfiles</code>:</p><div><pre class="programlisting">
<strong>~# fixfiles relabel</strong>
</pre></div><p>This is<a id="id133" class="indexterm"/> also needed if a system has been (temporarily) booted without SELinux support or with SELinux disabled as files will be created that have no file context. When an SELinux-enabled system is booted again, it will mark those files as <code class="literal">unlabeled_t</code>, which is a type that most domains have no access to (SELinux-wise).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Using substitution definitions</h1></div></div></div><p>Sometimes, applications and their resources get installed at different locations than expected<a id="id134" class="indexterm"/> by the SELinux policy. Trying to accommodate this by defining additional context definitions for each and every subdirectory can easily become unmanageable.</p><p>To help administrators, the SELinux utilities support substitution entries, which tell SELinux "if a path starts with <em>this</em>, then label it as if it starts with <em>that</em>". Administrators can set such <a id="id135" class="indexterm"/>a substitution (which is called an <strong>equivalence class</strong>) using <code class="literal">semanage</code>, as follows:</p><div><pre class="programlisting">
<strong>~# semanage fcontext –a –e / /mnt/chroots/bind</strong>
</pre></div><p>In this example, any location under <code class="literal">/mnt/chroots/bind/</code> will be labeled as if it started from the main <code class="literal">/</code> directory (so <code class="literal">/mnt/chroots/bind/etc/</code> becomes <code class="literal">etc_t</code> as <code class="literal">/etc/</code> is <code class="literal">etc_t</code>).</p><p>Target locations for <code class="literal">chroots</code> are a good use case for this. A <code class="literal">chroot</code> is an alternate location<a id="id136" class="indexterm"/> on the filesystem, which will act as the root filesystem for one or a set of applications.</p><p>For <a id="id137" class="indexterm"/>administrators who want to set substitutions across multiple systems, it is not possible to make this part of an SELinux policy module. The file that we need to manage is called <code class="literal">file_contexts.subs</code> (there is also one that ends with <code class="literal">.subs_dist</code> and is managed by the Linux distribution, which we will not touch). Having <a id="id138" class="indexterm"/>that said, we can always look at how to update this file in a more or less sane manner.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec35"/>Getting ready</h2></div></div></div><p>The easiest method would be to use a central configuration management utility, such as Puppet, CFEngine, Chef, or Ansible, as these systems allow administrators to force the content of specific files to a particular value. The use of a configuration management tool is an entire book in itself, so this is outside the scope of this book. If you do want to pursue this, remember that the <code class="literal">file_contexts.subs</code> file is (also) managed by the <code class="literal">semanage</code> command. Administrators<a id="id139" class="indexterm"/> might want to add in local definitions that the central configuration management utility isn't aware of (and thus might revert the change).</p><p>In this recipe, we'll cover a generic approach, but it does require that there is a way to do both a file transfer followed by a single line command (executed with proper permissions). This, however, shouldn't be much of a challenge to most system administrators.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec36"/>How to do it…</h2></div></div></div><p>In order to apply changes to a wide range of systems, follow the next set of steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Apply the change locally to the system:<div><pre class="programlisting">
<strong>~# semanage fcontext -a -e / /mnt/chroot/bind</strong>
</pre></div></li><li class="listitem">Export the definitions to a single file:<div><pre class="programlisting">
<strong>~# semanage export -f local_selinux.mods</strong>
</pre></div></li><li class="listitem">Edit the <code class="literal">local_selinux.mods</code> file and remove all entries that are not related to the change but need to be distributed.</li><li class="listitem">Distribute the resulting file to the target systems.</li><li class="listitem">Apply the changes locally to the system:<div><pre class="programlisting">
<strong>~# semanage import -f local_selinux.mods</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec37"/>How it works…</h2></div></div></div><p>The <code class="literal">semanage fcontext</code> command instantiates an equivalence class for <code class="literal">/mnt/chroot/bind/</code>, which has all subdirectories and files inside of it labeled as if they were at /. This <a id="id140" class="indexterm"/>ensures that administrators do not need to define a large amount of file contexts for each and every <code class="literal">chroot</code> location they manage.</p><p>However, this<a id="id141" class="indexterm"/> might become problematic as <code class="literal">semanage fcontext</code> only applies changes locally, and on a larger infrastructure, the same settings might need to be applied to multiple systems. For this, <code class="literal">semanage export</code> and <code class="literal">semanage import</code> can be used.</p><p>The <a id="id142" class="indexterm"/>output of the <code class="literal">semanage export</code> command is a set of instructions for <code class="literal">semanage</code> and follows the syntax of the <code class="literal">semanage</code> commands to the letter.</p><p>When exporting the <code class="literal">semanage</code> definitions, the first set of commands that are stored are the <code class="literal">delete all</code> statements such as <code class="literal">fcontext -D</code> (delete all locally made <code class="literal">semanage fcontext</code> settings). Of course, if we only need to distribute the substitution definitions, then deleting all previously made local statements is incorrect. Hence, the need to manually edit the <code class="literal">local_selinux.mods</code> file. If only the equivalence class definition needs to be distributed, then the file might just contain the following:</p><div><pre class="programlisting">fcontext -a -e / /mnt/chroot/bind</pre></div><p>The exported file can then be distributed to all target systems and loaded through the <code class="literal">semanage import</code> command effectively applying the same set of changes to the system.</p><p>If the definition was already applied on a system, then the <code class="literal">import</code> command will fail:</p><div><pre class="programlisting">
<strong>~# semanage import -f local_selinux.mods</strong>
<strong>ValueError: Equivalence class for /mnt/chroot/bind already exists</strong>
</pre></div><p>It is important to note here that if one command in the file fails to apply, then none of the commands in the file are applied (the file is processed in one go). This is why the <code class="literal">delete all</code> rules are originally made part of the exported set of commands.</p><p>This makes distributed management of such settings more challenging if locally applied changes need to be kept as well, unless the distributed set of changes are singular (one exported instruction, which is allowed to fail).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec38"/>There's more...</h2></div></div></div><p>Most files inside the <code class="literal">/etc/selinux/mcs/contexts/</code> location shouldn't be managed through any tool except either the Linux distribution package management system (through the installation of the base SELinux policy) or <code class="literal">semanage</code>.</p><p>That being said, most files inside this location don't change much (except for the <code class="literal">files/file_contexts</code> file). It might be beneficial to hook into the package management system to update these files (if supported) or bluntly take over the management <a id="id143" class="indexterm"/>of these files, assuming you track the changes that the distribution would make closely.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec39"/>See also</h2></div></div></div><p>The following resources dive deeper into the topics discussed in this recipe:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To find <a id="id144" class="indexterm"/>out more about the various configuration files, check out <a class="ulink" href="http://selinuxproject.org/page/PolicyConfigurationFiles">http://selinuxproject.org/page/PolicyConfigurationFiles</a></li><li class="listitem" style="list-style-type: disc">The interaction of SELinux with <code class="literal">chroots</code> is discussed in more detail in <a class="link" href="ch09.html" title="Chapter 9. Aligning SELinux with DAC">Chapter 9</a>, <em>Aligning SELinux with DAC</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Enhancing an SELinux policy with file transitions</h1></div></div></div><p>Up until now, we've only handled the configuration part on file contexts: if we would ask SELinux <a id="id145" class="indexterm"/>utilities to relabel files, then the <a id="id146" class="indexterm"/>changes we made would come into effect. However, unless you run with the <code class="literal">restorecond</code> daemon checking out all possible file modifications (which would really be a resource hog) or run <code class="literal">restorecon</code> manually against all files regularly, the newly defined contexts will not be applied to the files.</p><p>What we need to do is modify the local SELinux policy so that, upon creation of these files, the Linux kernel automatically assigns the right label to those files. This is handled through file<a id="id147" class="indexterm"/> transitions, which is a specific case of a <strong>type transition</strong>.</p><p>In a type transition, we configure a policy so that if a given domain creates a file (or other resource class) inside a directory with a specified label, then the created object should automatically get a specific label. Policy-wise, this is written as follows:</p><div><pre class="programlisting">type_transition &lt;domain&gt; &lt;directory_label&gt;:&lt;resource_class&gt; &lt;specific_label&gt;</pre></div><p>SELinux has also added in support for named file transitions (from Linux 2.6.39 onwards, and available in Gentoo, Fedora 16+, and Red Hat Enterprise Linux 7+). In that case, such a transition only occurs if the created resource matches a particular filename exactly (so no regular expressions):</p><div><pre class="programlisting">type_transition &lt;domain&gt; &lt;directory_label&gt;:&lt;resource_class&gt; &lt;specific_label&gt; &lt;filename&gt;</pre></div><p>Through the reference policy macro's, this is supported with the <code class="literal">filetrans_pattern</code> definition.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec40"/>Getting ready</h2></div></div></div><p>In order to properly define file transitions, we need to know what the source domain is that is responsible for creating the resource. For instance, a <code class="literal">/var/run/snort/</code> directory might be created by an <code class="literal">init</code> script, but if there is no file transition, then this directory will be created with the type of the parent directory (which is <code class="literal">var_run_t</code>) instead of the proper type (<code class="literal">snort_var_run_t</code>).</p><p>So make <a id="id148" class="indexterm"/>sure to write down all the involved labels (as an example, we will use <code class="literal">initrc_t</code> for an <code class="literal">init</code> script, <code class="literal">var_run_t</code> for the<a id="id149" class="indexterm"/> parent directory, and <code class="literal">snort_var_run_t</code> for the target directory) before embarking on this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How to do it…</h2></div></div></div><p>Defining a file transition can<a id="id150" class="indexterm"/> be done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Search through the SELinux policies to see if there is an interface that will provide a file transition from a given domain to <code class="literal">snort_run_t</code>:<div><pre class="programlisting">
<strong>~$ sefindif filetrans.*snort_var_run_t</strong>
</pre></div></li><li class="listitem">Assuming that none have been found, search for interfaces that allow <code class="literal">initrc_t</code> created resources to transition to a given type:<div><pre class="programlisting">
<strong>~$ sefindif filetrans.*initrc_t</strong>
<strong>system/init.if: interface(`init_daemon_pid_file',`</strong>
<strong>system/init.if:   files_pid_filetrans(initrc_t, $1, $2, $3)</strong>
</pre></div></li><li class="listitem">Bingo! Now, let's create an enhancement for the snort SELinux module (through a <code class="literal">mysnort</code> policy file) with the following declaration in it:<div><pre class="programlisting">policy_module(mysnort, 0.1)
gen_require(`
  type snort_t;
  type snort_var_run_t;
')
# If initrc_t creates a directory called "snort" in a var_run_t dir,
# make sure this one is immediately labeled as snort_var_run_t.
init_daemon_pid_file(snort_var_run_t, dir, "snort")</pre></div></li><li class="listitem">Build<a id="id151" class="indexterm"/> the new policy and load it. Then check with <code class="literal">sesearch</code> if a type transition is indeed declared:<div><pre class="programlisting">
<strong>~$ sesearch –s initrc_t –t var_run_t –T | grep "snort"</strong>
<strong>type_transition initrc_t var_run_t : dir snort_var_run_t "snort"</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How it works…</h2></div></div></div><p>Linux distributions that support SELinux already provide an SELinux policy that works in a majority of deployments. The default policy is extensive and works mostly out of the box. If specific changes are needed, chances are that these particular SELinux rules are already defined (as part of policy interfaces) and only need to be instantiated and loaded.</p><p>Policy<a id="id152" class="indexterm"/> interfaces usually exist in the following<a id="id153" class="indexterm"/> two types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interfaces whose subject is delivered through an argument, and where the object (against which operations are performed) and perhaps target (in our case, to which a transition should occur) are hardcoded</li><li class="listitem" style="list-style-type: disc">Interfaces whose subject is hardcoded and where the object, target, or both are arguments to the interface</li></ul></div><p>An example of the first interface type that can be used in our example would look like the following code:</p><div><pre class="programlisting">interface(`snort_generic_pid_filetrans_pid',`
  gen_require(`
    type snort_var_run_t;
  ')
  files_pid_filetrans($1, snort_var_run_t, dir, $2)
')</pre></div><p>We could then call this interface like this:</p><div><pre class="programlisting">snort_generic_pid_filetrans_pid(initrc_t, "snort")</pre></div><p>However, such interfaces would be a burden to maintain. For every daemon support added to the system, the <code class="literal">init</code> policy would need to be changed with a named file transition together with the newly added policy rules for the daemon. Considering the amount of daemons that can run on a system, the <code class="literal">init</code> policy would literally be filled with a massive amount of named file transitions—at least one for every daemon.</p><p>The interface declaration that we encountered in the example is much more manageable. The interface is meant to be called by the daemon policy itself and immediately ensures that the <code class="literal">initrc_t</code> type can create directories of the given type (<code class="literal">snort_var_run_t</code>) inside<a id="id154" class="indexterm"/> the generic run directory (<code class="literal">var_run_t</code>). New additions to the policy leave the <code class="literal">init</code> policy at rest, making maintenance <a id="id155" class="indexterm"/>of the policies easier.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec13"/>Finding the right search pattern</h3></div></div></div><p>To find<a id="id156" class="indexterm"/> the right pattern, we use the <code class="literal">sefindif</code> interface<a id="id157" class="indexterm"/> to search through the available interfaces. Finding the right expression is a matter of experience.</p><p>As we know, we want to search for file transitions, the line we are looking for will contain <code class="literal">filetrans_pattern</code>. Then, one of the arguments involved is the type we are going to transition to (<code class="literal">snort_var_run_t</code>). So the expression we used in the example was changed to <code class="literal">filetrans.*snort_var_run_t</code>. As that didn't result in anything, the next search involved the domain from which a transition has to be made (<code class="literal">initrc_t</code>) so that the expression<a id="id158" class="indexterm"/> was changed to <code class="literal">filetrans.*initrc_t</code>.</p><p>However, let's assume we don't know that <code class="literal">filetrans_pattern</code> needs to be searched for. The type itself (<code class="literal">snort_var_run_t</code>) or domain (<code class="literal">initrc_t</code>) might be sufficient to search through, like in the following searches:</p><div><pre class="programlisting">
<strong>~$ sefindif snort_var_run_t</strong>
<strong>~$ sefindif initrc_t</strong>
</pre></div><p>From the resulting list of interfaces, we can then see if an interface is available that suits our needs.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec14"/>Patterns</h3></div></div></div><p>Patterns such as <code class="literal">filetrans_pattern</code> are important supporting definitions inside the reference<a id="id159" class="indexterm"/> policy. They bundle a set of permissions related to a<a id="id160" class="indexterm"/> functional approach (such as read files, which are handled through a <code class="literal">read_files_pattern</code>) and are not tied to a particular type (unlike interfaces).</p><p>The need for patterns comes from the very fine-grained access controls that SELinux has on Linux activities. Reading a file is a nice example: it is not sufficient to just allow a type to perform the <code class="literal">read</code> action:</p><div><pre class="programlisting">allow initrc_t snort_var_run_t:file read;</pre></div><p>Most applications first check the attributes of the file (<code class="literal">getattr</code>) and open the file before they can read the file. Depending on the purpose, they might also want to lock the file or perform I/O operations on it through <code class="literal">ioctl</code>. So instead of just the preceding access vector, the rule was changed to:</p><div><pre class="programlisting">allow initrc_t snort_var_run_t:file { getattr lock open read ioctl }</pre></div><p>The reference policy provides a single permission set for this called <code class="literal">read_file_perms</code>, which<a id="id161" class="indexterm"/> turns the access vector into the following:</p><div><pre class="programlisting">allow initrc_t snort_var_run_t:file read_file_perms;</pre></div><p>Second, the policy developers often want to allow a domain to read a file inside a directory that is labeled similarly. For instance, a <code class="literal">snort_var_run_t</code> file can be at <code class="literal">/var/run/snort/snort.pid</code> with the <code class="literal">/var/run/snort/</code> directory also being labeled as <code class="literal">snort_var_run_t</code>. So we would also need to grant the <code class="literal">initrc_t</code> type search rights inside the directory—which again is a set of permissions as can be seen from the <code class="literal">search_dir_perms</code> definition:</p><div><pre class="programlisting">
<strong>~$ seshowdef search_dir_perms</strong>
<strong>define(`search_dir_perms',`{ getattr search open }')</strong>
</pre></div><p>Instead of creating multiple rules for this, a pattern is created, called <code class="literal">read_files_pattern</code>, which looks like the following:</p><div><pre class="programlisting">
<strong>~$ seshowdef read_files_pattern</strong>
<strong>define(`read_files_pattern',`</strong>
<strong>  allow $1 $2:dir search_dir_perms;</strong>
<strong>  allow $1 $3:file read_file_perms;</strong>
<strong>')</strong>
</pre></div><p>This <a id="id162" class="indexterm"/>allows policy developers to use a single call:</p><div><pre class="programlisting">read_files_pattern(initrc_t, snort_var_run_t, snort_var_run_t)</pre></div><p>To see the various patterns supported for policy development, use <code class="literal">sefinddef</code> with the '<code class="literal">define.*_pattern</code>' expression:</p><div><pre class="programlisting">
<strong>~$ sefinddef define.*_pattern</strong>
</pre></div><p>Using <a id="id163" class="indexterm"/>patterns allows developers to create readable policy rules using<a id="id164" class="indexterm"/> a functional approach rather than a full sum-up of each individual access vector.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec43"/>There's more...</h2></div></div></div><p>In the <code class="literal">snort_generic_pid_filetrans_pid</code> interface presented earlier, we used a named file transition: the transition occurs only if the filename passed on as the last argument matches the filename of the file created.</p><p>Named file transitions take precedence over normal file transitions. A good example for this are the file transitions supported for the <code class="literal">initrc_t</code> domain:</p><div><pre class="programlisting">
<strong>~# semanage –s initrc_t –t var_run_t –T</strong>
<strong>Found 2 semantic te rules:</strong>
<strong>  type_transition initrc_t var_run_t : file initrc_var_run_t;</strong>
<strong>  type_transition initrc_t var_run_t : dir initrc_var_run_t;</strong>
<strong>Found 16 named file transition rules:</strong>
<strong>type_transition initrc_t var_run_t : dir udev_var_run_t "udev";</strong>
<strong>type_transition initrc_t var_run_t : dir tor_var_run_t "tor";</strong>
<strong>…</strong>
</pre></div><p>In this case, if an <code class="literal">init</code> script creates a directory called <code class="literal">udev</code> or <code class="literal">tor</code> (or any of the other transition <a id="id165" class="indexterm"/>rules that <a id="id166" class="indexterm"/>are not shown in the example), then a proper file transition occurs. If the filename doesn't match, then a transition occurs to the <code class="literal">initrc_var_run_t</code> type.</p><p>File transitions on regular files and directories are the most common, but transitions can also <a id="id167" class="indexterm"/>occur on various other classes, such as sockets, FIFO files, symbolic <a id="id168" class="indexterm"/>links, and <a id="id169" class="indexterm"/>more.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec44"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Domain transitions (which assign a different context to a process rather than a file) are covered in <a class="link" href="ch03.html" title="Chapter 3. Confining Web Applications">Chapter 3</a>, <em>Confining Web Applications</em> in more detail and are used in <a class="link" href="ch04.html" title="Chapter 4. Creating a Desktop Application Policy">Chapter 4</a>, <em>Creating a Desktop Application Policy</em> and <a class="link" href="ch05.html" title="Chapter 5. Creating a Server Policy">Chapter 5</a>, <em>Creating a Server Policy</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Setting resource-sensitivity labels</h1></div></div></div><p>When an SELinux policy is MLS-enabled and supports multiple sensitivities (which is not the case <a id="id170" class="indexterm"/>with MCS, as MCS only has a single sensitivity), then SELinux can govern information flow and access between a domain and one or more resources based on the clearance of the domain and the sensitivity level of the resource. But even with a single sensitivity (as is the case with MCS), SELinux has additional constraint support to ensure that domains cannot access resources that have one of the categories assigned that the domain doesn't have clearance for.</p><p>A sensitivity level consists of a sensitivity (<code class="literal">s0</code> is generally being used for the lowest sensitivity and <code class="literal">s15</code>—which is a policy build-time constant and thus can be configured—is the highest sensitivity) together with a category set (which can be a list such as <code class="literal">c0,c5,c8.c10</code>).</p><p>A security clearance is similar to a sensitivity level but shows a sensitivity range (such as <code class="literal">s0-s3</code>) instead of a single sensitivity level. A security clearance can be seen as a range going from the lowest sensitivity level to the highest sensitivity level allowed by the domain.</p><p>When policies are being developed for such systems, context definitions and policy rules can take sensitivities into account. In this recipe, we will do the two most common operations for<a id="id171" class="indexterm"/> MLS-enabled systems:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define a context with a higher-level sensitivity</li><li class="listitem" style="list-style-type: disc">Set the clearance of a process policy-wise on a domain transition</li></ul></div><p>To accomplish this, we will use the snort intrusion detection system as an example, forcing it to be always executed with the <code class="literal">s3</code> sensitivity and all possible categories.</p><p>This example will also show us how to substitute an existing policy rather than enhance it, as we are going to update a definition that would otherwise collide with the existing definition.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec45"/>How to do it…</h2></div></div></div><p>To modify an existing domain to support specific sensitivity levels, execute the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Copy the <code class="literal">snort.te</code> and <code class="literal">snort.fc</code> files from the distribution policy repository to the local environment:<div><pre class="programlisting">
<strong>~$ cp ${POLICY_LOCATION}/policy/modules/contrib/snort.* ${DEVROOT}/local</strong>
</pre></div></li><li class="listitem">Rename<a id="id172" class="indexterm"/> the files to <code class="literal">mysnort</code> (or <code class="literal">customsnort</code>), so we always know this is a customized policy. Don't forget to update the <code class="literal">policy_module</code> call in the <code class="literal">.te</code> file.</li><li class="listitem">Open the <code class="literal">mysnort.te</code> file and look for the <code class="literal">init_daemon_domain</code> call. Substitute the call with the following:<div><pre class="programlisting">init_ranged_daemon_domain(snort_t, snort_exec_t,  s3:mcs_allcats)</pre></div></li><li class="listitem">In <code class="literal">mysnort.fc</code>, label the snort resources with the <code class="literal">s3</code> sensitivity. For instance, for the snort binary, label it as follows:<div><pre class="programlisting">/usr/bin/snort  --  gen_context(system_u:object_r:snort_exec_t,s3)</pre></div></li><li class="listitem">Build the <code class="literal">mysnort</code> policy, remove the currently loaded snort SELinux policy module, and load the <code class="literal">mysnort</code> one:<div><pre class="programlisting">
<strong>~# /etc/init.d/snort stop</strong>
<strong>~# semodule –r snort</strong>
<strong>~# semodule –i mysnort.pp</strong>
</pre></div></li><li class="listitem">Relabel all files related to snort and then start snort again.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How it works…</h2></div></div></div><p>There are three important aspects to this recipe:</p><div><ol class="orderedlist arabic"><li class="listitem">We replace the entire policy rather than create an enhancement.</li><li class="listitem">We update the policy to use a ranged daemon domain.</li><li class="listitem">We update the file contexts to use the right sensitivity.</li></ol></div><p>The file context update is obvious but the reason for fully replacing the policy might not be.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec15"/>Full policy replacement</h3></div></div></div><p>In <a id="id173" class="indexterm"/>the example, we copied the existing <a id="id174" class="indexterm"/>policy for the snort SELinux module and made the updates in the copy, rather than trying to enhance the policy by creating an additional module.</p><p>This is needed because we are making changes to the SELinux policy that are mutually exclusive to the already running SELinux policy. For instance, the file context changes would confuse SELinux as it would then have two fully matching definitions through policy modules, but each with a different resulting context.</p><p>In the <a id="id175" class="indexterm"/>example, we only copied the type enforcement declarations (<code class="literal">snort.te</code>) and file context declarations (<code class="literal">snort.fc</code>). If we would copy the interface definitions as well (<code class="literal">snort.if</code>), the policy build would give us a warning that there are duplicate interface definitions—the ones provided by the Linux distribution are still on the system after all.</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec16"/>Ranged daemon domain</h3></div></div></div><p>In <a id="id176" class="indexterm"/>the SELinux policy itself, we <a id="id177" class="indexterm"/>substituted the <code class="literal">init_daemon_domain(snort_t, snort_exec_t)</code> entry with the following:</p><div><pre class="programlisting">init_<strong>ranged_</strong>daemon_domain(snort_t, snort_exec_t<strong>, s3:mcs_allcats</strong>)</pre></div><p>Let's take a look at the contents of this interface:</p><div><pre class="programlisting">
<strong>~$ seshowif init_ranged_daemon_domain</strong>
<strong>interface(`init_ranged_daemon_domain',`</strong>
<strong>  gen_require(`</strong>
<strong>    type initrc_t;</strong>
<strong>  ')</strong>
<strong>  init_daemon_domain($1, $2)</strong>
<strong>  ifdef(`enable_mcs',`</strong>
<strong>    range_transition initrc_t $2:process $3;</strong>
<strong>  ')</strong>
<strong>  ifdef(`enable_mls',`</strong>
<strong>    range_transition initrc_t $2:process $3;</strong>
<strong>    mls_rangetrans_target($1)</strong>
<strong>  ')</strong>
<strong>')</strong>
</pre></div><p>The newly called interface calls the original <code class="literal">init_daemon_domain</code>, but enhances it with MCS- and MLS-related logic. In both cases, it calls <code class="literal">range_transition</code> so that when the snort <code class="literal">init</code> script (running as <code class="literal">initrc_t</code>) transitions to the <code class="literal">snort_t</code> domain, then the active sensitivity range is also changed to the third parameter.</p><p>In our case, the third parameter is <code class="literal">s3:mcs_allcats</code>, where <code class="literal">mcs_allcats</code> is a definition that expands to all categories supported by the policy (such as <code class="literal">c0.c255</code> if the policy supports 256 categories).</p><p>In case of MLS, it also calls <code class="literal">mls_rangetrans_target</code>, which is an interface that sets an attribute to the <code class="literal">snort_t</code> domain, which is needed for the MLS constraints enabled in the policy.</p><p>From <a id="id178" class="indexterm"/>the expanded code, we can see <a id="id179" class="indexterm"/>that there are <code class="literal">ifdef()</code> statements. These are blocks of SELinux policy rules that are enabled (or ignored) based on build-time parameters. The <code class="literal">enable_mcs</code> and <code class="literal">enable_mls</code> parameters are set if an MCS or MLS policy is enabled. Other often used build-time parameters are distribution selections (such as <code class="literal">distro_redhat</code> if the SELinux policy rules are specific for Red Hat Enterprise Linux and Fedora systems) and <code class="literal">enable_ubac</code> (which is when user-based access control is enabled).</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec17"/>Constraints</h3></div></div></div><p>Most, if not <a id="id180" class="indexterm"/>all, SELinux policy development focuses on <a id="id181" class="indexterm"/>type enforcement rules and context<a id="id182" class="indexterm"/> definitions. SELinux does support various other statements, one of which is the <code class="literal">constrain</code> statement used to implement constraints.</p><p>A constraint restricts permissions further based on a set of expressions that cover not only the type of the object or subject, but also SELinux role and SELinux user. The constraint that is related to the <code class="literal">mlsrangetrans</code> attribute (which is set by the <code class="literal">mls_rangetrans_target</code> interface) looks like the following:</p><div><pre class="programlisting">mlsconstrain process transition
  (( h1 dom h2 ) and
   (( l1 eq l2 ) or ( t1 == mlsprocsetsl ) or
    (( t1 == privrangetrans ) and ( t2 == mlsrangetrans ))));</pre></div><p>The constraint tells us the following things about a transition:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The transition can occur only when the highest sensitivity level of the subject (domain/actor) dominates the highest sensitivity level of the object</li><li class="listitem" style="list-style-type: disc">The lowest sensitivity level of the subject is the same as the lowest sensitivity level of the object</li><li class="listitem" style="list-style-type: disc">If not, then the type of the subject has to have the <code class="literal">mlsprocsetsl</code> attribute set</li><li class="listitem" style="list-style-type: disc">If not, then both of the following statements have to be true:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The type of the subject has the <code class="literal">privrangetrans</code> attribute set</li><li class="listitem" style="list-style-type: disc">The type of the object has the <code class="literal">mlsrangetrans</code> attribute set</li></ul></div></li></ul></div><p>Domination means that the sensitivity level of the first security level is equal to or higher than the sensitivity level of the second security level, and the categories of the first security level are the same or a superset of the categories of the second security level.</p><p>Constraints in the SELinux policy are part of the base policy set—this means that we are not able<a id="id183" class="indexterm"/> to add constraints through loadable <a id="id184" class="indexterm"/>SELinux policies. If we want to include additional constraints, we would need to build the entire policy ourselves, patching the <code class="literal">constraints</code>, <code class="literal">mls</code>, and <code class="literal">mcs</code> files inside the policy repository's <code class="literal">policy/</code> subdirectory.</p><p>Knowing about constraints is important, but we probably never need to write constraints ourselves.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec47"/>See also</h2></div></div></div><p>The <a id="id185" class="indexterm"/>SELinux project site is a good start for learning about constraints and their related statements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id186" class="indexterm"/>MLS statements at  <a class="ulink" href="http://selinuxproject.org/page/NB_MLS">http://selinuxproject.org/page/NB_MLS</a></li><li class="listitem" style="list-style-type: disc">The<a id="id187" class="indexterm"/> constraint statements at <a class="ulink" href="http://selinuxproject.org/page/ConstraintStatements">http://selinuxproject.org/page/ConstraintStatements</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Configuring sensitivity categories</h1></div></div></div><p>Although <a id="id188" class="indexterm"/>MCS policies are MLS-enabled, they are configured to only support a single sensitivity (namely <code class="literal">s0</code>). Yet even with this limitation, an MCS policy can be very useful, for instance, in situations where a system hosts services for multiple customers. This is because MCS can still benefit from security clearances based on categories.</p><p>Unlike sensitivities, categories are more like a discretionary access control system. Categories are meant to be used by users (or administrators) to label files and other resources as being a member of one or more categories. Access to those resources is then based on the clearance level of the process and the categories assigned to the resource. Categories are also not hierarchically structured.</p><p>An example of a use case where categories play a major role is in multitenant deployments: systems that host one or more services for multiple tenants (multiple customers), which, of course, require proper security segregation so that one tenant cannot access resources of another tenant.</p><p>In most cases, administrators will try to separate those services through the runtime user (and group membership). This is, however, not always possible. There are situations where these separate processes still need to run as the same runtime user (although with support for additional Linux security subsystems—such as capabilities—the number of situations has significantly reduced again).</p><p>In this<a id="id189" class="indexterm"/> recipe, we'll configure a system to use multiple categories to differentiate between resources of different customers for a web server that the customers also have shell access to. Through categories, we can provide more protection for the resources of other customers, in case one of the customers is able to execute an exploit that would elevate their privileges.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec48"/>Getting ready</h2></div></div></div><p>You need to prepare a system for the multiple tenants. For instance, we can host the entire website content in <code class="literal">/srv/web/&lt;companyname&gt;/</code> and have the web server configuration at <code class="literal">/etc/apache/conf/&lt;companyname&gt;/</code>.</p><p>In this recipe, as an example, we will configure the system for two companies called <code class="literal">CompanyX</code> and <code class="literal">CompanyY</code>. Each company also has a regular user (<code class="literal">userX</code> for the first company and <code class="literal">userY</code> for the second).</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec49"/>How to do it…</h2></div></div></div><p>To instantiate different categories, follow this approach:</p><div><ol class="orderedlist arabic"><li class="listitem">Settle on the category naming (and numbers) for different customers and configure those in the <code class="literal">setrans.conf</code> file inside <code class="literal">/etc/selinux/mcs/</code>:<div><pre class="programlisting">s0:c100=CompanyX
s0-s0:c100=CompanyXClearance
s0:c101=CompanyY
s0-s0:c101=CompanyYClearance</pre></div></li><li class="listitem">Restart the <code class="literal">mcstrans</code> service so that it is aware of this configuration.</li><li class="listitem">List the categories to make sure that the changes are properly interpreted:<div><pre class="programlisting">
<strong>~$ chcat –L</strong>
<strong>s0    SystemLow</strong>
<strong>s0-s0:c0.c1023  SystemLow-SystemHigh</strong>
<strong>s0:c0.c1023  SystemHigh</strong>
<strong>s0:c100    CompanyX</strong>
<strong>s0-s0:c100  CompanyXClearance</strong>
<strong>s0:c101    CompanyY</strong>
<strong>s0-s0:c101  CompanyYClearance</strong>
</pre></div></li><li class="listitem">Create SELinux users that have clearance to handle the right categories:<div><pre class="programlisting">
<strong>~# semanage user –a –L s0 –r CompanyXClearance –R "user_r" userX_u</strong>
<strong>~# semanage user –a –L s0 –r CompanyYClearance –R "user_r" userY_u</strong>
</pre></div></li><li class="listitem">Configure<a id="id190" class="indexterm"/> the Linux users (logins) with the right security clearance:<div><pre class="programlisting">
<strong>~# semanage login –m –s userX_u userX</strong>
<strong>~# semanage login –m –s userX_u userY</strong>
</pre></div></li><li class="listitem">Set the right category on the company resources:<div><pre class="programlisting">
<strong>~# chcon –l CompanyX –R /srv/web/www.companyX.com/ /etc/apache/conf/companyX/</strong>
<strong>~# chcon –l CompanyY –R /srv/web/www.companyY.com/ /etc/apache/conf/companyY/</strong>
</pre></div></li><li class="listitem">Configure the Apache <code class="literal">init</code> scripts to launch Apache with the right security level by launching it through <code class="literal">runcon</code>. For instance, on a Red Hat Enterprise Linux 6 system for the first company's web server, the following script is used:<div><pre class="programlisting">LANG=$HTTPD_LANG daemon --pidfile=${pidfile} runcon –t httpd_t –l CompanyX $httpd $OPTIONS</pre></div></li><li class="listitem">(Re)start the web server and validate that it is running with the right security level:<div><pre class="programlisting">
<strong>~# ps –efZ | grep httpd</strong>
</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec50"/>How it works…</h2></div></div></div><p>We started by configuring the system so that we can name categories and ranges rather than having to use the integer representations. Next, we created an SELinux user for each company and assigned each (regular) Linux account to the right SELinux user. After updating the contexts of all company-related files, we configured Apache to start in the right context.</p><div><div><div><div><h3 class="title"><a id="ch02lvl3sec18"/>The mcstrans and setrans.conf files</h3></div></div></div><p>The <code class="literal">setrans.conf</code> file is<a id="id191" class="indexterm"/> a regular text file that the<a id="id192" class="indexterm"/> MCS transition daemon (<code class="literal">mcstransd</code>) uses to substitute the real <a id="id193" class="indexterm"/>security level (such as <code class="literal">s0:c100</code>) with a human<a id="id194" class="indexterm"/> readable string (such as <code class="literal">CompanyX</code>).</p><p>The Linux utilities themselves (such as <code class="literal">ls</code> and <code class="literal">ps</code>) use the SELinux libraries to get information about the contexts of files and processes. These libraries then connect with the <code class="literal">mcstransd</code> process (through the <code class="literal">/var/run/setrans/.setrans-unix</code> socket), sending the real security level and retrieving the human-readable representation for it.</p><p>It is important to remember that this is only a representation and not how the security level is stored. In other words, do not use this in file context definition files (that is, the SELinux policy <code class="literal">.fc</code> files).</p></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec19"/>SELinux users and Linux user mappings</h3></div></div></div><p>In the<a id="id195" class="indexterm"/> example, an SELinux user is created for each <a id="id196" class="indexterm"/>company. This SELinux user is given<a id="id197" class="indexterm"/> the clearance to work with resources<a id="id198" class="indexterm"/> tagged with the category of the respective companies. The <a id="id199" class="indexterm"/>real Linux accounts are then mapped to this SELinux user.</p><p>From the example, we see that there are two definitions for each company:</p><div><pre class="programlisting">s0:c100    CompanyX
s0-s0:c100  CompanyXClearance</pre></div><p>The first one is a security level and can be assigned to both resources as well as processes (users). The second one is a security clearance (a range). In this particular example, the clearance tells us that the high security level (which can be seen as <em>what the process is allowed to access</em>) are the resources of the company (<code class="literal">s0:c100</code>), and the low security level (which can be seen as <em>the security level of the process itself</em> ) is just <code class="literal">s0</code>.</p><p>The users for the company, therefore, have clearance to access the files (and other resources) that have their company's category assigned to it. However, all activities performed by these user accounts do not get this category by default—the users will need to use <code class="literal">chcon</code> to set the category, as follows:</p><div><pre class="programlisting">
<strong>~$ chcon –l CompanyX public_html/index.html</strong>
</pre></div><p>It is possible to give the users the security level itself rather than the clearance. When that occurs, any resource created by the user will also get the proper category set. But, do not use this as a way to confine resources—users can always remove categories from resources.</p><p>Granting the security level can be done on the SELinux user level, but it is also possible to do this<a id="id200" class="indexterm"/> through the SELinux user mapping as long as the<a id="id201" class="indexterm"/> range passed on is dominated <a id="id202" class="indexterm"/>by the range set on the SELinux <a id="id203" class="indexterm"/>user level. For instance, to set <code class="literal">CompanyX</code> (<code class="literal">s0:c100</code>) as <a id="id204" class="indexterm"/>the security level rather than <code class="literal">CompanyXClearance</code>, which is the default for users mapped to the <code class="literal">userX_u</code> SELinux user, the following command can be used:</p><div><pre class="programlisting">
<strong>~# semanage login –m –r CompanyX user1</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch02lvl3sec20"/>Running Apache with the right context</h3></div></div></div><p>The last <a id="id205" class="indexterm"/>change made in the <a id="id206" class="indexterm"/>example was to configure the system to start the web server with the right security level. This is done through the <code class="literal">runcon</code> command, where <a id="id207" class="indexterm"/>we pass on the sensitivity level (and not the security clearance) to make sure that every resource created through the web server inherits the right category as well as the target type.</p><p>The SELinux policy knows that if an <code class="literal">init</code> script launches the Apache binary (<code class="literal">httpd</code>), then this application has to run in the <code class="literal">httpd_t</code> domain. However, now the <code class="literal">init</code> script launches <code class="literal">runcon</code>—which the SELinux policy sees as a regular binary—so the application would continue to run in the <code class="literal">initrc_t</code> domain. Hence, we need to pass on the target type (<code class="literal">httpd_t</code>). On systems with an SELinux policy without unconfined domains, forgetting<a id="id208" class="indexterm"/> this would prevent the web server to run. On systems with an SELinux policy with unconfined domains, this might result in the web server to run in an unconfined domain (<code class="literal">initrc_t</code>), effectively disabling the SELinux protections we need for the web server!</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec51"/>See also</h2></div></div></div><p>The following are some more examples on multitenancy and how SELinux interacts with it:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">sVirt (<a class="ulink" href="http://selinuxproject.org/page/SVirt">http://selinuxproject.org/page/SVirt</a>) uses SELinux categories<a id="id209" class="indexterm"/> to segregate virtual guests from one another</li><li class="listitem" style="list-style-type: disc">Linux containers, such <a id="id210" class="indexterm"/>as through the LXC project (<a class="ulink" href="https://linuxcontainers.org">https://linuxcontainers.org</a>), use SELinux for further isolation of containers from the main system</li><li class="listitem" style="list-style-type: disc">Apache has support for multitenancy through the <code class="literal">mod_selinux</code> module, which is covered in <a class="link" href="ch03.html" title="Chapter 3. Confining Web Applications">Chapter 3</a>, <em>Confining Web Applications</em></li></ul></div></div></div></body></html>