<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Herding Cats – Taking Control of Processes</h1></div></div></div><p>All too often, Linux administrators without the insight that you have, will leave services running as shipped after a Vanilla install of CentOS. We know how important it is to be able to justify each running process and service on systems that we manage, and in this chapter, you will gain the insight to manage this. While we are here, we will take a look at the new Upstart services that are replacing the System V scripts, which we have become so accustomed to. Here is a list of sections we will go through in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Managing services with Upstart</strong>: Investigate how to control services in CentOS 6.5 using Upstart and the <code class="literal">/etc/init</code> and <code class="literal">/etc/event.d</code> directories</li><li class="listitem" style="list-style-type: disc"><strong>Creating your own Upstart script</strong>: Learn how to create custom startup script for Upstart to manage your own needs at system boot</li><li class="listitem" style="list-style-type: disc"><strong>Managing processes</strong>: Gain practice with the p series of tools from the package procps to manage running processes: ps, pstree, pgrep, pmap, and pkill</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Managing services with Upstart</h1></div></div></div><p>For <a class="indexterm" id="id222"/>many years now, we have become used to managing services with System V init scripts that date back many years. However, without the desire<a class="indexterm" id="id223"/> to improve and the dedicated melioris<a class="indexterm" id="id224"/>m of so many in the open source community, we would not move on and improve. In CentOS 6.5, we now see some services being managed from the configurations within the <code class="literal">/etc/init</code> directory. These services make use of Upstart. This may be short-lived, as the beta release of Red Hat Enterprise Linux 7 uses a similar service manager, systemd, which is likely to prevail over Upstart. That said, both Upstart and systemd are managed in a very similar way, so visiting Upstart here is not an issue.</p><p>Firstly, we can check to see that we are indeed using <code class="literal">upstart</code> using the following command:</p><div><pre class="programlisting">
<strong># yum list upstart</strong>
</pre></div><p>The output<a class="indexterm" id="id225"/> from the preceding command should list the <a class="indexterm" id="id226"/>package as being installed. The service uses the <code class="literal">/etc./init</code> directory for its configuration and from here, we can see the services that utilize Upstart. Using the <code class="literal">rpm</code> command, we can check which package created this directory:</p><div><pre class="programlisting">
<strong># rpm -qf /etc/init</strong>
</pre></div><p>The output shows the directory belonging to the <code class="literal">upstart</code> package. On CentOS, we have just a few services that are controlled via Upstart; however, we will see that it is very easy to configure our own services as required using this mechanism.</p><p>Within the <code class="literal">/etc/init</code> directory, we can see that the consoles screens are managed by <code class="literal">upstart</code> with the <code class="literal">tty.conf</code> file, and we can also see the <code class="literal">splash-manager.conf</code> file. This service is enabled for reboot and poweroff, runlevel 0 and 6, to request the Plymouth splash screens (remember Plymouth from <a class="link" href="ch02.html" title="Chapter 2. Cold Starts">Chapter 2</a>, <em>Cold Starts</em>). The beauty of both Upstart and systemd is that we do not need to manage the symbolic links in the run control directories the way we required with older System V scripts. Taking a look inside the <code class="literal">/etc/init/spash-manager.conf</code> file, we can see when the service will run and that this is provided directly without reference to the old symbolic links. The following is an example of an Upstart directive:</p><div><pre class="programlisting">start on starting rc RUNLEVEL=[06]</pre></div><p>The preceding line states that Upstart will run the scripts contained in the configuration file on starting and on changing to runlevel 0 and 6. It is as simple as that. The configuration may also contain everything that is required to run the service; this file becomes the autonomous service we have been looking for, self-contained in the single configuration file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Creating your own Upstart script</h1></div></div></div><p>One <a class="indexterm" id="id227"/>of the best ways in which you can learn about these services is to create your own configuration file containing the Upstart script and all the associated conditions for our service. The configuration file will require the extension of <code class="literal">.conf</code> and has to be created in the <code class="literal">/etc/init</code> directory. For the purpose of this demonstration, we will create a simple service with the well-researched and inventive name: <code class="literal">sample</code>.</p><p>Using the text editor vi to create the <code class="literal">/etc/init/sample.conf</code> file, the service begins to take shape:</p><div><pre class="programlisting">#/etc/init/sample.conf
description "Simple demonstration upstart script"
author "The Urban Penguin"
start on runlevel [35]
script
  logger -p local1.info "Starting upstart service"
end script</pre></div><p>The <a class="indexterm" id="id228"/>service itself does nothing other than use the logger program to write to the syslog daemon; we can read the output from the <code class="literal">/var/log/messages</code> logfile. You, of course, could adjust the service to do more; however, this acts as a great start in demonstrating how compact the services can be.</p><p>We can test the service using the <code class="literal">/sbin/initctl</code> command:</p><div><pre class="programlisting">
<strong># initctl start sample</strong>
<strong># tail -n 1 /var/log/messages</strong>
</pre></div><p>The service can be manually started as we have shown here, if not manually started, it will start automatically, or at least send the message to the logfile when the system enters runlevel 3 or 5.</p><div><img alt="Creating your own Upstart script" src="img/5920OS_05_01.jpg"/></div><p>Along with the script option that we used here, we can additionally run pre or post scripts, especially useful where the service is a binary and we need to endure a certain environment in which it can run. There is an <code class="literal">exec</code> directive that can be used in place of the <code class="literal">script</code> directive where a single binary should run in place of the script. The full life cycle of an upstart service includes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pre-start</li><li class="listitem" style="list-style-type: disc">Post-start</li><li class="listitem" style="list-style-type: disc">Main (using exec or script)</li><li class="listitem" style="list-style-type: disc">Pre-stop</li><li class="listitem" style="list-style-type: disc">Post-stop</li></ul></div><p>The advantages that we gain from using Upstart and/or systemd is that we are no longer restricted to only starting services for given runlevels; we can also start these services for events such as disks (or block devices) being added or other services being started. Many of these event driven services can be found in the <code class="literal">/etc/event.d</code> directory.</p><p>We can <a class="indexterm" id="id229"/>control Upstart services using the <code class="literal">/sbin/initctl</code> command. To view the options available, the following command can be used with the <code class="literal">help</code> option:</p><div><pre class="programlisting">
<strong># initctl help</strong>
</pre></div><p>The output will show that the <code class="literal">version</code> option can be used to check the version of Upstart in use, as seen in the following screenshot:</p><div><img alt="Creating your own Upstart script" src="img/5920OS_05_02.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Managing processes</h1></div></div></div><p>The <a class="indexterm" id="id230"/>bulk of this chapter will visit the <code class="literal">procps</code> package and the p series commands that we can use to manage our processes to make sure that we can fully appreciate the power that these tools can offer from the command line.</p><p>Many administrators are accustomed to using the <code class="literal">ps</code> command to determine the running process, and often the output is then piped to <code class="literal">grep</code> to search for a given process name. Although there is nothing incorrect with this as such, we may prefer to use tools that streamline these steps and are specifically designed tools for the purpose. For the moment, we will ignore the <code class="literal">/ps</code> command in preference of more specific tools with a real purpose to their binary lives.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Using the pgrep command</h2></div></div></div><p>The <code class="literal">/usr/bin/pgrep</code> command<a class="indexterm" id="id231"/> really does <a class="indexterm" id="id232"/>become a snap-in replacement for the <code class="literal">ps</code> and <code class="literal">grep</code> pipelines we use all too often. For example, if I start my Apache web server, I can easily check the<a class="indexterm" id="id233"/> <strong>Process IDs</strong> (<strong>PIDs</strong>) in use by the service:</p><div><pre class="programlisting">
<strong># service httpd start</strong>
<strong># pgrep httpd</strong>
</pre></div><p>The output of the command follows:</p><div><img alt="Using the pgrep command" src="img/5920OS_05_03.jpg"/></div><p>From the output, I can see the lowest PID, in my case <strong>3950</strong>. This will be the main daemon process <a class="indexterm" id="id234"/>that will spawn the child processes. Knowing how much we enjoy the easy life, we can see how effortlessly we can the child <a class="indexterm" id="id235"/>processes to the parent using the <code class="literal">pstree</code> command with the parent process as the argument. There are eight child processes in my case, no need to use my thumbs to count these.</p><div><pre class="programlisting">
<strong># pstree 3950</strong>
</pre></div><p>Here's the output to the preceding command:</p><div><img alt="Using the pgrep command" src="img/5920OS_05_04.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Using the pstree command</h2></div></div></div><p>This <a class="indexterm" id="id236"/>utility is so under used; I am sure that <a class="indexterm" id="id237"/>many administrators just know to execute the command without arguments or options. We have seen with the previous example how powerful it can be, but of course there is much more.</p><p>The <code class="literal">pstree</code> command, when run without arguments or options, will list the process tree from PID 1 through all running processes showing each in a hierarchical form linked<a class="indexterm" id="id238"/> by <strong>parent process ID</strong> (<strong>PPID</strong>) and PID.</p><p>To take it a step further, we can use the <code class="literal">-h</code> option, which will highlight the process tree in which we run <code class="literal">pstree</code>:</p><div><pre class="programlisting">
<strong>$ pstree -h</strong>
</pre></div><p>The following screenshot shows the highlighted extract from <code class="literal">pstree</code>:</p><div><img alt="Using the pstree command" src="img/5920OS_05_05.jpg"/></div><p>We can see <a class="indexterm" id="id239"/>from the previous screenshot<a class="indexterm" id="id240"/> that we have run <code class="literal">pstree</code> from a <code class="literal">gnome-terminal</code> in which we had been running the Bash shell in a <strong>substituted user</strong> (<strong>SU</strong>)<a class="indexterm" id="id241"/> environment; it is all laid out clearly for us to see.</p><p>Running something similar, we can highlight the process tree for the <code class="literal">httpd</code> process running at PID <code class="literal">3950</code> using the following command:</p><div><pre class="programlisting">
<strong>$ pstree -h 3950</strong>
</pre></div><p>On my system, this can be seen in the following extract from the screenshot:</p><div><img alt="Using the pstree command" src="img/5920OS_05_06.jpg"/></div><p>Using <code class="literal">pstree</code> with the <code class="literal">-a</code> option will show the process and any arguments used when it was started. This can be useful to see that a service is taking the correct configuration options:</p><div><pre class="programlisting">
<strong>$ pstree -a</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Using the pkill command</h2></div></div></div><p>When<a class="indexterm" id="id242"/> we <a class="indexterm" id="id243"/>reconsider from where we started this chapter, with the understanding that many administrators are accustomed to using the <code class="literal">ps</code> command and piped to <code class="literal">grep</code>, we should question the need to run the <code class="literal">ps</code> command in the first place. Perhaps we do this in order to kill a process. We did show earlier in this chapter how we can simplify and streamline the <code class="literal">ps</code>/<code class="literal">grep</code> pipeline with <code class="literal">pgrep</code>; the reality though, is that, we can streamline it further with <code class="literal">pkill</code>. Let's assume that we are running CentOS as a desktop, and while running the Firefox web browser we notice that is has become unresponsive, we can simply use the <code class="literal">pkill</code> to resolve the issue:</p><div><pre class="programlisting">
<strong>$ pkill firefox</strong>
</pre></div><p>Of course, the process names in Linux are case sensitive, but you do get used to the names of those processes that you may often need to whip into shape with a little <code class="literal">pkill</code>.</p><p>We can also kill all processes owned by a particular user. They may have done something really bad, and their session is totally unresponsive. We could try:</p><div><pre class="programlisting">
<strong># pkill -9 -U bob</strong>
</pre></div><p>The preceding command will send the kill signal (<code class="literal">-9</code>) to all processes owned by the user <code class="literal">bob</code>.</p><p>If it is just processes in one terminal that we need to concern ourselves with, then we could use the following command:</p><div><pre class="programlisting">
<strong># pkill -9 -t tty2</strong>
</pre></div><p>This will kill all processes running in the <code class="literal">tty2</code> console. If we own the running processes, we can execute the <code class="literal">pkill</code> command as our own account. If we don't own those processes, then the commands need to be run as root. We have been using the <code class="literal">-9</code> signal in the last few examples, as we want to be sure to remove all process. It may be better to run the commands in the following way for best practice:</p><div><pre class="programlisting">
<strong># pkill -15 -t tty2</strong>
<strong># pkill -9 -t tty2</strong>
</pre></div><p>In this way, we issue the terminate signal first (<code class="literal">-15</code>) and then the kill (<code class="literal">-9</code>). In this way, processes are shutdown gracefully if they respond to the initial terminate request; those that are unresponsive to the terminate signal are then cleaned up with the final kill.</p><p>Just because a process does not respond to the terminate request, it does not mean that the process has hung; the bash shell, for example, does not respond to a terminate request, it has to be killed outright. This is just how the program is written.</p><p>To see a list of signals that can be issued, we should use the <code class="literal">/usr/bin/kill</code> command with the <code class="literal">-l</code> (list) option as follows:</p><div><pre class="programlisting">
<strong>$ kill -l</strong>
</pre></div><p>An extract from the output can be seen in the following screen capture:</p><div><img alt="Using the pkill command" src="img/5920OS_05_07.jpg"/></div><p>Although many <a class="indexterm" id="id244"/>possible signals exist, they <a class="indexterm" id="id245"/>must be written into the program if it is to respond to the signal. This is where the <code class="literal">-9</code> or <code class="literal">-sigkill</code> option is useful, although abrupt, the signal works directly with <code class="literal">init</code> to remove the process rather than relying on the application to respond.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Using the pmap command</h2></div></div></div><p>Another<a class="indexterm" id="id246"/> useful tool from the <code class="literal">procps</code> package <a class="indexterm" id="id247"/>that we can use to gain information on running processes is the <code class="literal">pmap</code> command. This can be used to print a memory map for a running process. In simple terms, it will show you how much memory is being used by the process and any library modules that it uses.</p><p>To gain information on the PID for the current shell, we can use the special variable <code class="literal">$$</code>; thus, <code class="literal">pmap $$</code> will show me the process map for my current shell:</p><div><pre class="programlisting">
<strong>$ pmap $$</strong>
</pre></div><p>The output looks most impressive; firstly we see that <code class="literal">$$</code> on this system resolves to the PID 7259 and <code class="literal">/bin/bash</code>. As the process map continues, we see the address column followed by the size of memory in use by each component of <code class="literal">/bin/bash</code>.</p><p>From the following partial screenshot, we can see the output that you can expect from the <code class="literal">pmap</code> command:</p><div><img alt="Using the pmap command" src="img/5920OS_05_08.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Summary</h1></div></div></div><p>In this chapter, we have been able to while away a little boondoggle time, learning about the <code class="literal">procps</code> package in CentOS Linux and all the treasures that it can reveal. The tools therein are a gold mine to administrators and can save us all valuable time where we elect the most effective tool to be used in the examining processes. Putting this into practice, we have seen the effortless use that can be made from the <code class="literal">pgrep</code> and <code class="literal">pkill</code> commands in streamlining our process management, while tools such as <code class="literal">pmap</code> are more useful for diagnosing system resource usage.</p><p>As we get ready to venture into the next chapter, we will look at some of the valuable shortcuts that we can use when managing users on a CentOS 6.5 system.</p></div></body></html>