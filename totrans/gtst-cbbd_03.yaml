- en: Chapter 3. Installing an Operating System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a Cubieboard is only useful if you can actually use it and eventually
    develop and/or play with it. The preinstalled OS might or might not be adequate
    for this. Very often, Android is preinstalled on these devices, as the SoC used
    is usually found in Android devices, and the manufacturer mostly or only supports
    it. While BSD or Minix are also operating systems that are being developed by
    various developers, this book will limit itself to Linux as an operating system.
    The first few sections of this chapter will dig a little deeper into the concepts
    for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding out where the SoC chip decides to boot from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between an OS image and a clean install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading and installing Fedora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting the freshly installed OS from an SD card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic concepts on using Fedora and connecting to a wired network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining Fedora via the Package Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting the Cubieboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it might seem natural that the system simply boots, there is a lot more
    to it. The Allwinner series of SoCs has something called a **Boot Read Only Memory**
    (**BROM**). The BROM is really a small program embedded into the chip itself that
    always gets executed first. This program has a few drivers for a minimal set of
    hardware to ensure that it is small and simple.
  prefs: []
  type: TYPE_NORMAL
- en: First, the BROM will try to find a valid bootloader on the first SD card, also
    called the MMC slot. If nothing is found there, the NAND is checked for a valid
    bootloader. Again, if nothing is found there, the second MMC slot is checked.
    If nothing is found there either, the first SPI bus is probed for an SPI memory
    flash chip and checked for a valid bootloader. Finally, if all of the preceding
    methods fail, the FEL mode is entered. The FEL mode is a recovery mode where it
    is possible to upload a piece of code over a USB connection and execute it. This
    can be useful to recover a board when it fails to boot and the first MMC slot
    is not available to boot from. The FEL mode does not have to be initiated. One
    might wonder why two MMC slots are being probed. Sometimes, manufacturers include
    an embedded MMC chip, or eMMC, in their design, which unlike an SD or MMC card
    looks like a regular chip, similar to a NAND flash chip, but behaves and looks
    like an MMC card. By probing the two MMC slots, you can have a board that uses
    an eMMC chip on the board while still having the first MMC slot available for
    use cases such as boot recovery. The Cubietruck is available with various combinations
    of these storage options.
  prefs: []
  type: TYPE_NORMAL
- en: OS image installation background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many sites and forums on the Internet speak of firmware or ROMs when talking
    about an installation for an embedded device. It all sounds very mysterious initially,
    but this is far from the truth. A ROM is nothing more than a full disk image,
    which, in turn, can be written to storage, which the board can boot from. The
    name *ROM* is derived from the fact that the data used to be stored in a ROM chip.
    Many of the OS images that can be found for Allwinner development boards are tailored
    to a very specific board. This is not surprising, as the chip used might be the
    same on a range of boards, but certain attached peripherals might be completely
    different; one board may have different memory chips for example. Another board
    might not have an onboard flash and rely completely on the secondary MMC slot
    for its OS. It is almost impossible to have a single disk image that works on
    all these different combinations of hardware, and thus a clean installation sounds
    like quite a sensible approach. While distributions are slowly starting to support
    the ARM-based systems, it is still not easy to have a common installer that can
    install the distribution to any ARM-based board. To bridge these worlds, a few
    linux-sunxi community members and Red Hat employees have developed a hybrid installation
    of Fedora, where a generic image is downloaded, configured, and finally launched
    in the installer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and preparing Fedora
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There have been several releases of Fedora for the A10, A10S, A13, and A20 series
    of SoCs. As this book focuses on the most recent version, Fedora 20-r1, the latest
    version is recommended. Additionally, if fails, Fedora 20-r1 can be written to
    an SD card, which can be used as a recovery boot disk. The first step in this
    endeavor is to download this disk image. About 2 GB of free disk space is required.
  prefs: []
  type: TYPE_NORMAL
- en: Fedora for this chapter can be downloaded from the Packt Publishing website
    in the **Help & Support** section of the book's **Support** page.
  prefs: []
  type: TYPE_NORMAL
- en: The next few steps assume that there is a Linux computer available. If this
    is not the case, the preinstalled OS on the Cubieboard can also be used; while
    a little bit trickier, it should be quite possible. If the preinstalled OS is
    Android, then a terminal application will be required that might not be installed.
    Do note that on Mac OSX, the device path names will be different. Finally, a virtual
    machine can also be used, but a detailed explanation of that is out of the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mac OSX uses device nodes that are similar to Linux but slightly different.
    For example, the second partition on an inserted USB stick can be called at `/dev/sdb2`
    on Linux, where on OSX however, this would translate to `/dev/disk2s2`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the OS image to the SD card
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the image needs to be written to a microSD card that is at least 4 GiB
    in size.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next few steps will delete all the content on the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: The microSD card should be connected to the PC. If there is no card reader available,
    a USB to microSD card reader can be used instead. The `xzcat` command is used
    to decompress the downloaded `xz-compressed` archive onto the SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, it is assumed that the microSD card is inserted into
    a USB card reader and has been assigned the device node, `/dev/sdd`. It is up
    to the reader to determine the proper device node on the system, but `dmesg` or
    one of the installed graphical disk utilities can provide an answer here. An example
    output with the SD card found on the device node `/dev/sdd` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command might require root privileges; to do so, prefix `dmesg` with `sudo`.
    The filename used here should match the file downloaded. A cache-flush via the
    `sync` command is forced upon successful completion. Flushing the cache is important
    so that we know all the data that has actually been written to the SD card and
    it is not held up in the cache. This process might take quite a while—10 minutes
    is commonly reported commonly reported. The following command is an example of
    writing the image to an SD card and flushing the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Writing the OS image should be possible on Linux, OSX, the BSDs, Solaris, and
    many modern POSIX-based systems. On Windows, a little more care is required. A
    program such as 7-Zip can be used to decompress the image, and an image writer
    such as WinDD can be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: When done, remove the USB device and reinsert it to force re-reading of the
    SD card's partition table. Opening a file manager will, in most cases, show the
    newly created partitions on the SD card, one named `u-boot` and the other `rootfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the bootloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bootloader is very device-specific and can even vary between production
    runs of the same board. This is because the memory initialization is performed
    by the bootloader and thus can be different. To do this, a setup script is preinstalled
    in addition to several bootloaders and several kernels for the various generations
    of SoCs. This script needs to be executed from the partition labeled `u-boot`
    on the microSD card. If the currently running OS mounts the partitions automatically,
    the `mount` command can be used to find the mount point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the microSD card is mounted on `/media/u-boot`, and
    the setup script should be run from there. This path should be adjusted as needed.
    The following is an example showing a sample output of the available boards. The
    bootloader is being installed using the Cubietruck. It may be required to prefix
    the command with `bash` to force `bash` to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If no Linux system is available, the setup script should be able to run from
    within the native Android. However, an ADB or a terminal application will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will now provide a list of supported boards. Find the exact board being
    used, and run the command again with the selected board as the parameter. Note
    that only a small selection will be displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing the bootloader](img/1572OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After setting up the board, unmount the microSD card followed by a sync to
    ensure all the data is written properly. Let us take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the environment that this script is being run on, a graphical
    version can be launched instead; the idea, however, is identical: choose the correct
    board and the script will write the image to the correct place.'
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the operating system installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connect a monitor, USB keyboard, and USB mouse, and insert the microSD card
    into the Cubieboard. Each board has a default output configured upon the first
    boot. For many headless boards, this will be the HDMI port. For tablets or systems
    with LCD screens, it will be the LCD screen. While not strictly required, connecting
    the UART, as mentioned in the previous chapter, can be helpful in case things
    go wrong, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the operating system installation](img/1572OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying power will boot the device, and after a few minutes and a few intentional
    reboots to resize the partition on the SD card, the Fedora installer should pop
    up. If there is no output on the monitor, refer to [Appendix D](apd.html "Appendix D. Troubleshooting
    the Common Pitfalls"), *Troubleshooting the Common Pitfalls*. Also, refer to the
    following screenshot to see Fedora''s first graphical installer screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the operating system installation](img/1572OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If a mouse or, at least, a keyboard is connected, various parameters for the
    system can be set up. Verify that at least the time zone is correct, and set up
    a password for the root user. Also, a new user should be created for regular use
    of the system, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the operating system installation](img/1572OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating a user and finishing the installation and a short reboot, a
    login screen should appear, allowing the newly created user to log in. It is now
    possible to log in to the desktop, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the operating system installation](img/1572OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The desktop environment that will be encountered is called **Xfce4**, where
    the letters only have a historic meaning, and the number indicates the version.
    Version 4 has been in active development since 2003\. Xfce4 is a very lightweight
    desktop environment and is the default for Fedora on ARM to keep the strain light
    on the available system resources. Xfce4 might ask the new user a question or
    two on how the desktop should appear, but the default settings should work fine
    and were used in this example as well. Feel free to explore this new desktop,
    launch some applications, or just browse the Internet. Refer to the following
    screenshot to see the default desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finishing the operating system installation](img/1572OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Precautionary measures for installing updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there is a perfectly usable desktop environment now, one of the very common
    tasks is to keep the OS up-to-date and thus secure. Fedora comes with a graphical
    frontend to the Yum command-line tool called **Yum Extender**. Before going there,
    however, a warning needs to be issued. At this point, Fedora, like all other distributions,
    does not officially support the Allwinner range of SoCs. This has one major drawback
    when updating the OS. The updater, be it Yum or Yum Extender, will also try to
    update the kernel and bootloader configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the Fedora 20-r1 release will try to update
    the kernel and bootloader configuration, causing an unbootable device. However,
    it can easily be fixed by inserting the SD card into a working system and running
    the `select-device.sh` script as before. To prevent this corruption, edit the
    file at the `/etc/yum.conf` location, and add the following line to that file,
    which will force Yum to ignore any kernel updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The kernel exclusion should be added to any recent release of Fedora because
    it might not be applicable to the later versions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the kernel and bootloader live in their own partition, not having the
    `u-boot` partition mounted can avoid the need to update the bootloader and kernel.
    In the next chapter, the reader will be able to edit his/her `fstab` file without
    any difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the OS and installing updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, the Yum Extender can be used conveniently from the GUI
    to update the system or install new packages. The Yum Extender can be found under
    the **Administration** tab in **Applications Menu**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining the OS and installing updates](img/1572OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the Yum Extender is an administrator''s application, the current user will
    have to authorize its use. Assuming this, the user will be granted administrative
    privileges. The first user of the system will have these privileges. Refer to
    the following screenshot for a view of **Yum Extender**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining the OS and installing updates](img/1572OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the **Select All** button followed by **Apply** will start installing
    all the new updates to the system. Depending on the `speed` class of the SD card,
    this can take a long time. While preparing the illustrations for this chapter
    on an 8 GB class 4 SD card, the process took 5 minutes short of 6 hours. Thus,
    it is recommended to use at least a class 10 or a better SD card. While using
    the OS, a class 4 card, even though slow, is usable however.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It might be wise to hold out updating the SD card for a Friday evening, for
    example, where the process can take all weekend without bothering anybody.
  prefs: []
  type: TYPE_NORMAL
- en: If a warning, as illustrated in the following screenshot, appears during the
    update process, it is safe to accept it. It is a notification to import a missing
    GPG key. In this case, it was sanctioned by the Fedora project as can be seen
    in the e-mail address used. This message may come up early in the update process,
    in the first 10 minutes or so.
  prefs: []
  type: TYPE_NORMAL
- en: '![Maintaining the OS and installing updates](img/1572OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding more software to the OS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing additional software is very easy thanks to Package Managers that
    have been present in Linux distributions for years. The Yum Extender can not only
    be used to update the OS, but also to add new software to the system, as seen
    in the following screenshot, which demonstrates Firefox being installed. Optionally,
    the command-line version, yum, can be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding more software to the OS](img/1572OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having gone through this chapter, you should have no problem creating a fresh
    SD card with a full Xfce4-based Fedora operating system. Also, keeping it up-to-date
    and adding new software should not be a problem at all. All thanks to a hybrid-disk
    image of Fedora!
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will do an installation in a more in-depth fashion manually
    and focus more on a command line-based interface, as this is often used on server
    setups, embedded systems, and so on. An entire installation will be performed
    manually from scratch to learn how to create a customized system.
  prefs: []
  type: TYPE_NORMAL
