- en: Texting and Driving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching and mining text inside a file with grep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cutting a file column-wise with cut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `sed` to perform text replacement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `awk` for advanced text processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the frequency of words used in a given file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing or decompressing JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging multiple files as columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the n^(th) word or column in a file or line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing text between line numbers or patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing lines in the reverse order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing e-mail address and URLs from text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a sentence in a file containing a word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a pattern with text in all the files in a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text slicing and parameter operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell scripting includes many problem-solving tools. There is a rich set of
    tools for text processing. These tools include utilities, such as `sed`, `awk`,
    `grep`, and `cut`, which can be combined to perform text processing needs.
  prefs: []
  type: TYPE_NORMAL
- en: These utilities process files by character, line, word, column, or row to process
    text files in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are a basic pattern-matching technique. Most text-processing
    utilities support regular expressions. With regular expression strings, we can
    filter, strip, replace, and search within text files.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes a collection of recipes to walk you through many solutions
    to text processing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are at the heart of pattern-based text-processing. To use
    regular expressions effectively, one needs to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Everyone who uses `ls` is familiar with glob style patterns. Glob rules are
    useful in many situations, but are too limited for text processing. Regular expressions
    allow you to describe patterns in finer detail than glob rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical regular expression to match an e-mail address might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this looks weird, don't worry; it is really simple once you understand the
    concepts through this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions** are composed of text fragments and symbols with special
    meanings. Using these, we can construct a regular expression to match any text.
    Regular expressions are the basis for many tools. This section describes regular
    expressions, but does not introduce the Linux/Unix tools that use them. Later
    recipes will describe the tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions consist of one or more elements combined into a string.
    An element may be a position marker, an identifier, or a count modifier. A position
    marker anchors the regular expression to the beginning or end of the target string.
    An identifier defines one or more characters. The count modifier defines how many
    times an identifier may occur.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at some sample regular expressions, let's look at the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Position markers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A position marker anchors a regular expression to a position in the string.
    By default, any set of characters that match a regular expression can be used,
    regardless of position in the string.
  prefs: []
  type: TYPE_NORMAL
- en: '| **regex** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | This specifies that the text that matches the regular expression must
    start at the beginning of the string | `^tux` matches a line that starts with
    `tux` |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | This specifies that the text that matches the regular expression must
    end with the last character in the target string | `tux$` matches a line that
    ends with `tux` |'
  prefs: []
  type: TYPE_TB
- en: Identifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifiers are the basis of regular expressions. These define the characters
    that must be present (or absent) to match the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: '| **regex** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `A` character | The regular expression must match this letter. | `A` will
    match the letter A |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | This matches any one character. | `"Hack."` matches `Hack1`, `Hacki`,
    but not `Hack12` or `Hackil`; only one additional character matches |'
  prefs: []
  type: TYPE_TB
- en: '| `[]` | This matches any one of the characters enclosed in the brackets. The
    enclosed characters may be a set or a range. | `coo[kl]` matches `cook` or `cool`;
    [0-9] matches any single digit |'
  prefs: []
  type: TYPE_TB
- en: '| `[^]` | This matches any one of the characters except those that are enclosed
    in square brackets. The enclosed characters may be a set or a range. | `9[^01]`
    matches `92` and `93`, but not `91` and `90`; `A[^0-9]` matches an `A` followed
    by anything except a digit |'
  prefs: []
  type: TYPE_TB
- en: Count modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Identifier may occur once, never, or many times. The Count Modifier defines
    how many times a pattern may appear.
  prefs: []
  type: TYPE_NORMAL
- en: '| **regex** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `?` | This means that the preceding item must match one or zero times | `colou?r`
    matches `color` or `colour`, but not `colouur` |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | This means that the preceding item must match one or more times | `Rollno-9+`
    matches `Rollno-99` and `Rollno-9`, but not `Rollno-` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | This means that the preceding item must match zero or more times |
    `co*l` matches `cl`, `col`, and `coool` |'
  prefs: []
  type: TYPE_TB
- en: '| `{n}` | This means that the preceding item must match n times | `[0-9]{3}`
    matches any three-digit number; `[0-9]{3}` can be expanded as `[0-9][0-9][0-9]`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `{n,}` | This specifies the minimum number of times the preceding item should
    match | `[0-9]{2,}` matches any number that is two digits or longer |'
  prefs: []
  type: TYPE_TB
- en: '| `{n, m}` | This specifies the minimum and maximum number of times the preceding
    item should match | `[0-9]{2,5}` matches any number that has two digits to five
    digits |'
  prefs: []
  type: TYPE_TB
- en: Other
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are other characters that fine–tune how a regular expression will be parsed.
  prefs: []
  type: TYPE_NORMAL
- en: '| `()` | This treats the terms enclosed as one entity | `ma(tri)?x` matches
    `max` or `matrix` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | This specifies alternation-; one of the items on either of side
    of `&#124;` should match | `Oct (1st &#124; 2nd)` matches `Oct 1st` or `Oct 2nd`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `\` | This is the escape character for escaping any of the special characters
    mentioned previously | `a\.b` matches `a.b`, but not `ajb`; it ignores the special
    meaning of `.` because of `\` |'
  prefs: []
  type: TYPE_TB
- en: For more details on the regular expression components available, you can refer
    to [http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a few examples of regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This regular expression would match any single word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The initial `+` characters say we need 1 or more spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `[a-zA-Z]` set is all upper– and lower–case letters. The following plus
    sign says we need at least one letter and can have more.
  prefs: []
  type: TYPE_NORMAL
- en: The final `+` characters say we need to terminate the word with one or more
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would not match the last word in a sentence. To match the last word in
    a sentence or the word before a comma, we write the expression like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `[?,\.]?` phrase means we might have a question mark, comma, or a period,
    but at most one. The period is escaped with a backslash because a bare period
    is a wildcard that will match anything.
  prefs: []
  type: TYPE_NORMAL
- en: It's easier to match an IP address. We know we'll have four three-digit numbers
    separated by periods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `[0-9]` phrase defines a number. The `{1,3}` phrase defines the count as
    being at least one digit and no more than three digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define an IP address using the `[[:digit:]]` construct to define
    a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We know that an IP address is in the range of four integers (each from 0 to
    255), separated by dots (for example, `192.168.0.2`).
  prefs: []
  type: TYPE_NORMAL
- en: This regex will match an IP address in the text being processed. However, it
    doesn't check for the validity of the address. For example, an IP address of the
    form `123.300.1.1` will be matched by the regex despite being an invalid IP.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are parsed by a complex state machine that tries to find
    the best match for a regular expression with a string of target text. That text
    can be the output of a pipe, a file, or even a string you type on the command
    line. If there are multiple ways to fulfill a regular expression, the engine will
    usually select the largest set of characters that match.
  prefs: []
  type: TYPE_NORMAL
- en: For example, given the string `this is a test` and a regular expression `s.*s`,
    the match will be `s is a tes`, not `s is`.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the regular expression components available, you can refer
    to [http://www.linuxforu.com/2011/04/sed-explained-part-1/](http://www.linuxforu.com/2011/04/sed-explained-part-1/).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous tables described the special meanings for characters used in regular
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Treatment of special characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions use some characters, such as `$`, `^`, `.`, `*`, `+`, `{`,
    and `}`, as special characters. But, what if we want to use these characters as
    normal text characters? Let's see an example of a regex, `a.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: This will match the character `a`, followed by any character (due to the `.`
    character), which is then followed by the `txt` string. However, we want `.` to
    match a literal `.` instead of any character. In order to achieve this, we precede
    the character with a backward slash `\` (doing this is called escaping the character).
    This indicates that the regex wants to match the literal character rather than
    its special meaning. Hence, the final regex becomes `a\.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions can be tough to understand. Fortunately, there are utilities
    available to help in visualizing regex. The page at [http://www.regexper.com](http://www.regexper.com)
    lets you enter a regular expression and creates a graph to help you understand
    it. Here is a screenshot describing a simple regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05265_04_image.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching and mining text inside a file with grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you forget where you left your keys, you've just got to search for them.
    If you forget what file has some information, the `grep` command will find it
    for you. This recipe will teach you how to locate files that contain patterns.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `grep` command is the magic Unix utility for searching text. It accepts
    regular expressions and can produce reports in various formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Search `stdin` for lines that match a pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Search a single file for lines that contain a given pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this performs the same search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Search multiple files for lines that match a pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To highlight the matching pattern, use the `-color` option. While the option
    position does not matter, the convention is to place options first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grep` command uses basic regular expressions by default. These are a subset
    of the rules described earlier. The `-E` option will cause `grep` to use the **Extended
    Regular Expression** syntax. The `egrep` command is a variant of `grep` that uses
    extended regular expression by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-o` option will report only the matching characters, not the entire line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-v` option will print all lines, except those containing `match_pattern`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-v` option added to `grep` inverts the match results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-c` option will count the number of lines in which the pattern appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that `-c` counts the number of matching lines, not the number
    of times a match is made. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Even though there are six matching items, `grep` reports `2`, since there are
    only two matching lines. Multiple matches in a single line are counted only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'To count the number of matching items in a file, use this trick:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-n` option will print the line number of the matching string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If multiple files are used, the `-c` option will print the filename with the
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-b` option will print the offset of the line in which a match occurs.
    Adding the `-o` option will print the exact character or byte offset where the
    pattern matches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Character positions are numbered from `0`, not from `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-l` option lists which files contain the pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The inverse of the `-l` argument is `-L`. The `-L` argument returns a list of
    nonmatching files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `grep` command is one of the most versatile Linux/Unix commands. It also
    includes options to search through folders, select files to search, and more options
    for identifying patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Recursively searching many files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recursively search for a text in files contained in a file hierarchy, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this command, `.` specifies the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The options `-R` and `-r` mean the same thing when used with `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`test_function()` exists in line number 16 of `miscutils/test.c`. The `-R`
    option is particularly useful if you are searching for a phrase in a website or
    source code tree. It is equivalent to this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Ignoring case in patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-i` argument matches patterns without considering the uppercase or lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: grep by matching multiple patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `-e` argument specifies multiple patterns for matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the lines that contain either of the patterns and output one
    line for each match. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple patterns can be defined in a file. The `-f` option will read the file
    and use the line-separated patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Including and excluding files in a grep search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`grep` can include or exclude files in which to search with wild card patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To recursively search only for the `.c` and `.cpp` files, use the -include
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that `some{string1,string2,string3}` expands as `somestring1 somestring2
    somestring3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `-exclude` flag to exclude all `README` files from the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--exclude-dir` option will exclude the named directories from the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To read a list of files to exclude from a file, use `--exclude-from FILE`.
  prefs: []
  type: TYPE_NORMAL
- en: Using grep with xargs with the zero-byte suffix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `xargs` command provides a list of command-line arguments to another command.
    When filenames are used as command-line arguments, use a zero-byte terminator
    for the filenames instead of the default space terminator. Filenames can contain
    space characters, which will be misinterpreted as name separators, causing a filename
    to be broken into two filenames (for example, `New file.txt` might be interpreted
    as two filenames `New` and `file.txt`). Using the zero-byte suffix option solves
    this problem. We use `xargs` to accept `stdin` text from commands such as `grep`
    and `find`. These commands can generate output with a zero-byte suffix. The `xargs`
    command will expect `0` byte termination when the `-0` flag is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create some test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-l` option tells `grep` to output only the filenames where a match occurs.
    The `-Z` option causes `grep` to use the zero-byte terminator (`\0`) for these
    files. These two options are frequently used together. The `-0` argument to `xargs`
    makes it read the input and separate filenames at the zero-byte terminator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Silent output for grep
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, instead of examining at the matched strings, we are only interested
    in whether there was a match or not. The quiet option (`-q`), causes `grep` to
    run silently and not generate any output. Instead, it runs the command and returns
    an exit status based on success or failure. The return status is `0` for success
    and nonzero for failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `grep` command can be used in quiet mode, for testing whether a match text
    appears in a file or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `silent_grep.sh` script accepts two command-line arguments, a match word
    (`Student`), and a file name (`student_data.txt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Printing lines before and after text matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context-based printing is one of the nice features of `grep`. When grep finds
    lines that match the pattern, it prints only the matching lines. We may need to
    see *n* lines before or after the matching line. The `-B` and `-A` options display
    lines before and after the match, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-A` option prints lines after a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-B` option prints lines before the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-A` and `-B` options can be used together, or the `-C` option can be used
    to print the same number of lines before and after the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are multiple matches, then each section is delimited by a `--` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Cutting a file column-wise with cut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cut command splits a file by column instead of lines. This is useful for
    processing files with fixed-width fields, **Comma Separated Values** (**CSV**
    files), or space delimited files such as the standard log files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cu`t command extracts data between character locations or columns. You
    can specify the delimiter that separates each column. In the `cut` terminology,
    each column is known as a **field**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The -f option defines the fields to extract:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`FIELD_LIST` is a list of columns that are to be displayed. The list consists
    of column numbers delimited by commas. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second and the third columns are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `cut` command also reads input from `stdin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Tab* is the default delimiter for fields. Lines without delimiters will be
    printed. The `-s` option will disable printing lines without delimiter characters.
    The following commands demonstrate extracting columns from a tab delimited file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract multiple fields provide multiple field numbers separated by commas,
    using the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--complement` option will display all the fields except those defined
    by `-f`. This command displays all fields except `3`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-d` option will set the delimiter. The following command shows how to
    use `cut` with a colon-separated list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cut` command has more options to define the columns displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the range of characters or bytes as fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A report with fixed-width columns will have varying numbers of spaces between
    the columns. You can't extract values based on field position, but you can extract
    them based on the character location. The `cut` command can select based on bytes
    or characters as well as fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s unreasonable to enter every character position to extract, so cut accepts
    these notations as well as the comma-separated list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `N-` | From the *N^(th)* byte, character, or field, to the end of the line
    |'
  prefs: []
  type: TYPE_TB
- en: '| `N-M` | From the *N^(th)* to *M^(th)* (included) byte, character, or field
    |'
  prefs: []
  type: TYPE_TB
- en: '| `-M` | From the first to *M^(th)* (included) byte, character, or field |'
  prefs: []
  type: TYPE_TB
- en: 'We use the preceding notations to specify fields as a range of bytes, characters,
    or fields with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-b` for bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` for characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` for defining fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the second to fifth characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Display the first two characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Replace `-c` with `-b` to count in bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-output-delimiter` option specifies the output delimiter. This is particularly
    useful when displaying multiple sets of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Using sed to perform text replacement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sed` stands for **stream editor**. It''s most commonly used for text replacement.
    This recipe covers many common `sed` techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sed` command can replace occurrences of a pattern with another string.
    The pattern can be a simple string or a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, `sed` can read from `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you use the `vi` editor, you will notice that the command to replace the
    text is very similar to the one discussed here. By default, `sed` only prints
    the substituted text, allowing it to be used in a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-I` option will cause `sed` to replace the original file with the modified
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example replaces the first occurrence of the pattern in each line.
    The `-g` parameter will cause `sed` to replace every occurrence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/#g` option will replace from the *N^(th)* occurrence onwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sed` command treats the character following `s` as the command delimiter.
    This allows us to change strings with a `/` character in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'When the delimiter character appears inside the pattern, we have to escape
    it using the `\` prefix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`\|` is a delimiter appearing in the pattern replaced with escape.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sed` command supports regular expressions as the pattern to be replaced
    and has more options to control its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Removing blank lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expression support makes it easy to remove blank lines. The `^$` regular
    expression defines a line with nothing between the beginning and end == a blank
    line. The final `/d` tells sed to delete the lines, rather than performing a substitution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Performing replacement directly in the file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a filename is passed to `sed`, it usually prints to `stdout`. The `-I`
    option will cause `sed` to modify the contents of the file in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, replace all three-digit numbers with another specified number
    in a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding one-liner replaces three-digit numbers only. `\b[0-9]\{3\}\b`
    is the regular expression used to match three-digit numbers. `[0-9]` is the range
    of digits from `0` to `9`. The `{3}` string defines the count of digits. The backslash
    is used to give a special meaning for `{` and `}` and `\b` stands for a blank,
    the word boundary marker.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s a useful practice to first try the `sed` command without `-i` to make
    sure your regex is correct. After you are satisfied with the result, add the `-i`
    option to make changes to the file. Alternatively, you can use the following form
    of `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `sed` will perform the replacement on the file and also create
    a file called `file.bak`, which contains the original contents.
  prefs: []
  type: TYPE_NORMAL
- en: Matched string notation ()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `&` symbol is the matched string. This value can be used in the replacement
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `\w\+` regex matches every word. Then, we replace it with `[&]`, which
    corresponds to the word that is matched.
  prefs: []
  type: TYPE_NORMAL
- en: Substring match notation (\1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`&` corresponds to the matched string for the given pattern. Parenthesized
    portions of a regular expression can be matched with `\#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command replaces `digit 7` with `7`. The substring matched is
    `7`. `\(pattern\)` matches the substring. The pattern is enclosed in `()` and
    is escaped with backslashes. For the first substring match, the corresponding
    notation is `\1`, for the second, it is `\2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`([a-z]\+\)` matches the first word and `\([A-Z]\+\)` matches the second word;
    `\1` and `\2` are used for referencing them. This type of referencing is called
    **back referencing**. In the replacement part, their order is changed as `\2 \1`,
    and hence, it appears in the reverse order.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining multiple expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiple `sed` commands can be combined with pipes, patterns separated by semicolons,
    or the `-e PATTERN` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command is equivalent to the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Quoting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sed` expression is commonly quoted with single quotes. Double quotes can
    be used. The shell will expand double quotes before invoking sed. Using double
    quotes is useful when we want to use a variable string in a `sed` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '`$text` is evaluated as `hello`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using awk for advanced text processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` command processes data streams. It supports associative arrays, recursive
    functions, conditional statements, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The structure of an `awk` script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `awk` command can also read from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: An `awk` script includes up to three parts–:`BEGIN`, `END`, and a common statement
    block with the pattern match option. These are optional and any of them can be
    absent in the script.
  prefs: []
  type: TYPE_NORMAL
- en: Awk will process the file line by line. The commands following `BEGIN` will
    be evaluated before `<code>awk</code>` starts processing the file. Awk will process
    each line that matches PATTERN with the commands that follow PATTERN. Finally,
    after processing the entire file, `<CODE>awk</CODE>` will process the commands
    that follow `END`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a simple `awk` script enclosed in single quotes or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will report the number of lines in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `awk` command processes arguments in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it executes the commands in the `BEGIN { commands }` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, `awk` reads one line from the file or `stdin`, and executes the `commands`
    block if the optional pattern is matched. It repeats this step until the end of
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the end of the input stream is reached, it executes the `END { commands
    }` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `BEGIN` block is executed before `awk` starts reading lines from the input
    stream. It is an optional block. The commands, such as variable initialization
    and printing the output header for an output table, are common comamnds in the
    `BEGIN` block.
  prefs: []
  type: TYPE_NORMAL
- en: The `END` block is similar to the `BEGIN` block. It gets executed when `awk`
    completes reading all the lines from the input stream. This is commonly printing
    results after analyzing all the lines.
  prefs: []
  type: TYPE_NORMAL
- en: The most important block holds the common commands with the pattern block. This
    block is also optional. If it is not provided, `{ print }` gets executed to print
    each line read. This block gets executed for each line read by `awk`. It is like
    a `while` loop, with statements to execute inside the body of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a line is read, `awk` checks whether the pattern matches the line. The
    pattern can be a regular expression match, conditions, a range of lines, and so
    on. If the current line matches the pattern, `awk` executes the commands enclosed
    in `{ }`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pattern is optional. If it is not used, all lines are matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: When `print` is used without an argument, `awk` prints the current line.
  prefs: []
  type: TYPE_NORMAL
- en: The print command can accept arguments. These arguments are separated by commas,
    they are printed with a space delimiter. Double quotes are used as the concatenation
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will display this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `echo` command writes a single line into the standard output. Hence, the
    statements in the `{ }` block of `awk` are executed once. If the input to `awk`
    contains multiple lines, the commands in `awk` will be executed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concatenation is done with quoted strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '`{ }` is like a block in a loop, iterating through each line of a file.'
  prefs: []
  type: TYPE_NORMAL
- en: It's a common practice to place initial variable assignments such as `var=0;`
    in the `BEGIN` block. The `END{}` block contains commands to print the results.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` command differs from commands such as `grep`, `find`, and `tr`, in
    that it does more than a single function with options to change the behavior.
    The `awk` command is a program that interprets and executes programs and includes
    special variables just like the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Special variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some special variables that can be used with `awk` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NR`: This stands for the current record number, which corresponds to the current
    line number when `awk` uses lines as records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NF`: This stands for the number of fields, and corresponds to the number of
    fields in the current record being processed. The default field delimiter is a
    space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$0`: This is a variable that contains the text of the current record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1`: This is a variable that holds the text of the first field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$2`: This is a variable that holds the text of the second field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We can print the last field of a line as `print $NF`, the next to last as `$(NF-1)`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`awk` also supports a `printf()` function with the same syntax as in C.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command prints the second and third field of every line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use NR to count the number of lines in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we only use the `END` block. Awk updates `NR` as each line is read. When
    `awk` reaches the end of the file, NR will contain the last line number. You can
    sum up all the numbers from each line of `field 1` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Passing an external variable to awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `-v` argument, we can pass external values other than `stdin` to
    `awk`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a flexible alternate method to pass many variable values from outside
    `awk`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'When an input is given through a file rather than standard input, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, variables are specified as key-value pairs, separated
    by a space, and `(v1=$var1 v2=$var2 )` as command arguments to `awk` soon after
    the `BEGIN`, `{ }`, and `END` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a line explicitly using getline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` program reads an entire file by default. The `getline` function will
    read one line. This can be used to read header information from a file in the
    `BEGIN` block and then process actual data in the main block.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is `getline var`. The `var` variable will contain the line. If `getline`
    is called without an argument, we can access the content of the line with `$0`,
    `$1`, and `$2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Filtering lines processed by awk with filter patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can specify conditions for lines to be processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Setting delimiters for fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the delimiter for fields is a space. The `-F` option defines a different
    field delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We can set the output field separator by setting `OFS="delimiter"` in the `BEGIN`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the command output from awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Awk can invoke a command and read the output. Place a command string within
    quotes and use the vertical bar to pipe the output to `getline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The following code reads a single line from `/etc/passwd` and displays the login
    name and home folder. It resets the field separator to a `:` in the `BEGIN` block
    and invokes `grep` in the main block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Associative arrays in Awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Awk supports variables that contain a number or string and also supports associative
    arrays. An associative array is an array that''s indexed by strings instead of
    numbers. You can recognize an associative array by the index within square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'An array can be assigned a value with the equal sign, just like simple user-defined
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Using loop inside awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Awk supports a numeric `for` loop with a syntax similar to `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Awk also supports a list style for loop that will display the contents of an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to collect data into an array and then display
    it. This script reads lines from `/etc/password`, splits them into fields at the
    `:` markers, and creates an array of names in which the index is the login ID
    and the value is the user''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: String manipulation functions in awk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The language of `awk` includes many built-in string manipulation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length(string)`: This returns the string length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index(string, search_string)`: This returns the position at which `search_string`
    is found in the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split(string, array, delimiter)`: This populates an array with the strings
    created by splitting a string on the delimiter character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`substr(string, start-position, end-position)`: This returns the substring
    of the string between the start and end character offsets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub(regex, replacement_str, string)`: This replaces the first occurring regular
    expression match from the string with `replacment_str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gsub(regex, replacment_str, string)`: This is like `sub()`, but it replaces
    every regular expression match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match(regex, string)`: This returns whether a regular expression (regex) match
    is found in the string. It returns a non-zero output if a match is found, otherwise
    it returns zero. Two special variables are associated with `match()`. They are
    `RSTART` and `RLENGTH`. The `RSTART` variable contains the position at which the
    regular expression match starts. The `RLENGTH` variable contains the length of
    the string matched by the regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the frequency of words used in a given file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computers are good at counting. We frequently need to count items such as the
    number of sites sending us spam, the number of downloads different web pages get,
    or how often words are used in a piece of text. This recipes show how to calculate
    word usage in a piece of text. The techniques are also applicable to log files,
    database output, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the associative arrays of `awk` to solve this problem in different
    ways. **Words** are alphabetic characters, delimited by space or a period. First,
    we should parse all the words in a given file and then the count of each word
    needs to be found. Words can be parsed using regex with tools such as `sed`, `awk`,
    or `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just explored the logic and ideas about the solution; now let''s create
    the shell script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will generate this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `egrep` command converts the text file into a stream of words, one word
    per line. The `\b[[:alpha:]]+\b` pattern matches each word and removes whitespace
    and punctuation. The `-o` option prints the matching character sequences as one
    word in each line.
  prefs: []
  type: TYPE_NORMAL
- en: The `awk` command counts each word. It executes the statements in the `{ }`
    block for each line, so we don't need a specific loop for doing that. The count
    is incremented by the `count[$0]++` command, in which `$0` is the current line
    and `count` is an associative array. After all the lines are processed, the `END{}`
    block prints the words and their count.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of this procedure can be modified using other tools we''ve looked
    at. We can merge capitalized and non-capitalized words into a single count with
    the `tr` command, and sort the output using the sort command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Arrays and associative arrays* recipe in [Chapter 1](195d920d-33c2-41d6-bd33-37d75f9c37f1.xhtml),
    *Shell Something Out*, explains arrays in Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing or decompressing JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is widely used in websites. While developing the JavaScript code,
    we use whitespaces, comments, and tabs for readability and maintenance of the
    code. This increases the file size, which slows page loading. Hence, most professional
    websites use compressed JavaScript speed page loading. This compression (also
    known as **minified JS**) is accomplished by removing the whitespace and newline
    characters. Once JavaScript is compressed, it can be decompressed by replacing
    enough whitespace and newline characters to make it readable. This recipe produces
    similar functionality in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to write a JavaScript compressor tool as well as a decompressing
    tool. Consider the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Our script needs to perform these steps to compress the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove newline and tab characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove duplicated spaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace comments that look like `/* content */`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To decompress or to make the JavaScript more readable, we can use the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace `;` with `;\n`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace `{` with `{\n`, and `}` with `\n}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using these steps, we can use the following command chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following decompression script makes the obfuscated code readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a limitation in the script: that it even gets rid of extra spaces
    where their presence is intentional. For example, if you have a line like the
    following:                 `var a = "hello world"`'
  prefs: []
  type: TYPE_NORMAL
- en: The two spaces will be converted into one space. You can fix problems such as
    this using the pattern-matching tools we have discussed. Also, when dealing with
    a mission-critical JavaScript code, it is advised that you use well-established
    tools to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compression command performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing the `\n` and `\t` characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing extra spaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing comments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '`:` is used as a `sed` delimiter to avoid the need to escape `/` since we need
    to use `/*` and `*/`.'
  prefs: []
  type: TYPE_NORMAL
- en: In sed, `*` is escaped as `\*`.
  prefs: []
  type: TYPE_NORMAL
- en: '`.*` matches all the text in between `/*` and `*/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing all the spaces preceding and suffixing the `{`, `}`, `(`, `)`, `;`,
    `:`, and `,` characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `sed` statement works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/ \?\([{}();,:]\) \?/` in the `sed` code is the match part, and `/\1 /g` is
    the replacement part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\([{}();,:]\)` is used to match any one character in the `[ { }( ) ; , : ]`
    set (spaces inserted for readability). `\(` and `\)` are group operators used
    to memorize the match and back reference in the replacement part. `(` and `)`
    are escaped to give them a special meaning as a group operator.`\?` precedes and
    follows the group operators to match the space character that may precede or follow
    any of the characters in the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the replacement part, the match string (that is, the combination of `:`,
    a space (optional), a character from the set, and again an optional space) is
    replaced with the character matched. It uses a back reference to the character
    matched and memorized using the group operator `()`. Back-referenced characters
    refer to a group match using the `\1` symbol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The decompression command works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s/;/;\n/g` replaces `;` with `;\n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s/{/{\n\n/g` replaces `{` with `{\n\n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s/}/\n\n}/g` replaces `}` with `\n\n}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Translating with tr* recipe in [Chapter 2](36986eeb-141a-496a-a6b1-4f78f612c14e.xhtml),
    *Have a Good Command*, explains the `tr` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merging multiple files as columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The can command can be used to merge two files by row, one file after the other.
    Sometimes we need to merge two or more files side by side, joining the lines from
    file 1 with the lines from file 2.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `paste` command performs column-wise concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The default delimiter is tab. We can specify the delimiter with `-d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Cutting a file column-wise with cut* recipe in this chapter explains how
    to extract data from text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing the nth word or column in a file or line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to extract a few columns of useful data from a file. For example,
    in a list of students ordered by their scores, we want to get the fourth highest
    scorer. This recipe shows how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` command is frequently used for this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the fifth column, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We can print multiple columns and insert a custom string between the columns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command will print the permission and filename of each file in
    the  current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Cutting a file column-wise with cut * recipe in this chapter explains how
    to extract data from text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing text between line numbers or patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may need to print a selected portion of a file, either a range of line numbers
    or a range matched by a start and end pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Awk`, `grep`, or `sed` will select lines to print, based on condition. It''s
    simplest to use `grep` to print lines that include a pattern. Awk is the most
    versatile tool.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To print the text between line numbers or patterns, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the lines of a text in a range of line numbers, `M` to `N`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Awk can read from `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `M` and `N` with numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the lines of text between a `start_pattern` and `end_pattern`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The patterns used in `awk` are regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using awk for advanced text processing* recipe in this chapter explains
    the `awk` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing lines in the reverse order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe may not seem useful, but it can be used to emulate the stack data
    structure in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to accomplish this is with the `tac` command (the reverse of
    cat). The task can also be done with `awk`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will first see how to do this with `tac`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of `tac` is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tac` command can also read from `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The default line separator for `tac` is `\n`. The -s option will redefine this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This `awk` script will print lines in the reverse order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '`\` in the shell script is used to break a single-line command sequence into
    multiple lines.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `awk` script stores each of the lines into an associative array using the
    line number as the index (`NR` returns the line number). After reading all the
    lines, `awk` executes the `END` block. The `NR` variable is maintained by `awk`.
    It holds the current line number. When `awk` starts the END block, `NR` is the
    count of lines. Using `lno=NR` in the `{ }` block iterates from the last line
    number to `0`, to print the lines in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing e-mail address and URLs from text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing elements such as e-mail addresses and URLs is a common task. Regular
    expressions make finding these patterns easy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The regular expression pattern to match an e-mail address is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using extended regular expressions (`+`, for instance), we should
    use `egrep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `egrep` regex pattern for an HTTP URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions are easy to design part-by-part. In the e-mail regex, we
    all know that an e-mail address takes the `name@domain.some_2-4_letter_suffix`
    form. Writing this pattern in the regex language will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '`[A-Za-z0-9.]+` means we need one or more characters in the `[]` block (`+`
    means at least one, maybe more). This string is followed by an `@` character.
    Next, we will see the domain name, a string of letters or numbers, a period, and
    then 2-4 more letters. The `[A-Za-z0-9]+` pattern defines an alpha-numeric string.
    The `\.` pattern means that a literal period must appear. The `[a-zA-Z]{2,4}`
    pattern defines 2, 3, or 4 letters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP URL is similar to an e-mail, but we don''t need the `name@` match part
    of the e-mail regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using regular expressions* recipe in this chapter explains how to use regular
    expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a sentence in a file containing a word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing a sentence that contains a specific word is a simple task with regular
    expressions. This recipe demonstrates techniques for solving similar problems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sed` is the best utility for making substitutions. This recipe uses `sed`
    to replace the matched sentence with a blank.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a file with some text to carry out the substitutions. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the sentence containing the words `mobile phones`, use the following
    `sed` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: This recipe assumes that no sentence spans more than one line, for example,
    a sentence should always begin and end on the same line in the text.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sed` regex `'s/ [^.]*mobile phones[^.]*\.//g'` has the `'s/substitution_pattern/replacement_string/g`
    format. It replaces every occurrence of `substitution_pattern` with the replacement
    string.
  prefs: []
  type: TYPE_NORMAL
- en: The substitution pattern is the regex for a sentence. Every sentence begins
    with a space and ends with `.`. The regular expression must match the text in
    the format `"space" some text MATCH_STRING some text "dot"`. A sentence may contain
    any characters except a "dot", which is the delimiter. The `[^.]` pattern matches
    any character except a period`.` The `*` pattern defines any number of those characters.
    The `mobile phones` text match string is placed between the pattern for non-period
    characters. Every match sentence is replaced by `//` (nothing).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    the `sed` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using regular expressions* recipe in this chapter explains how to use regular
    expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing a pattern with text in all the files in a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to replace a particular text with a new text in every file in
    a directory. An example would be changing a common URI everywhere in a website's
    source directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use `find` to locate the files to have text modified. We can use `sed`
    to do the actual replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the `Copyright` text with the `Copyleft` word in all `.cpp` files,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use `find` on the current directory (`.`) to find the files with a `.cpp`
    suffix. The find command uses -`print0` to print a null separated list of files
    (use `-print0` when filenames have spaces in them). We pipe the list to `xargs`,
    which will pass the filenames to `sed`, which makes the modifications.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall, `find` has an `-exec` option, which can be used to run a command
    on each of the files that match the search criteria. We can use this option to
    achieve the same effect or replace the text with a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: These commands perform the same function, but the first form will call `sed`
    once for every file, while the second form will combine multiple filenames and
    pass them together to `sed`.
  prefs: []
  type: TYPE_NORMAL
- en: Text slicing and parameter operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks through some simple text-replacement techniques and parameter-expansion
    shorthands available in Bash. A few simple techniques can help avoid writing multiple
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get into the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace some text from a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The `line` word is replaced with `REPLACED`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can produce a substring by specifying the start position and string length,
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Print from the fifth character onwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Print eight characters starting from the fifth character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The first character in a string is at position `0`. We can count from the last
    letter as `-1`. When `-1` is inside a parenthesis, `(-1)` is the index for the
    last letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using sed to perform text replacement* recipe in this chapter explains
    other character manipulation tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
