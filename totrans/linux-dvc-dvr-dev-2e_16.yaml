- en: '*Chapter 13*: Demystifying the Kernel IRQ Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux is a system on which devices notify the kernel about events by means of
    **interrupt requests** (**IRQs**), though some devices are polled. The CPU exposes
    IRQ lines, shared or not, used by connected devices so that when a device needs
    the CPU, it sends a request to the CPU. When the CPU gets this request, it stops
    its actual job and saves its context, in order to serve the request issued by
    the device. After serving the device, its state is restored back to exactly where
    it stopped when the interruption occurred.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will deal with the APIs that the kernel offers to manage
    IRQs and the ways in which multiplexing can be done. Moreover, we will analyze
    and look closer at **interrupt controller** driver writing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, in this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Brief presentation of interrupts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding interrupt controllers and interrupt multiplexing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving into advanced peripheral IRQ management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demystifying per-CPU interrupts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brief presentation of interrupts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On many platforms, a special device is responsible for managing IRQ lines.
    That device is the interrupt controller and it stands between the CPU and the
    interrupt lines it manages. The following is a diagram that shows the interactions
    that take place:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Interrupt controller and IRQ lines'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_13_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Interrupt controller and IRQ lines
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only can devices raise interrupts, but some processor operations can do
    that too. There are then two different kinds of interrupts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous interrupts, called **exceptions**, are produced by the CPU while
    processing instructions. These are **non-maskable interrupts** (**NMIs**) and
    result from a critical malfunction such as hardware failure. They are always processed
    by the CPU.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous interrupts, called **interrupts**, are issued by other hardware
    devices. These are normal and **maskable interrupts**. These are what we will
    discuss in the next sections of this chapter.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before getting deeper into interrupt management in the Linux kernel, let's talk
    a bit more about exceptions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions are consequences of programming errors, handled by the kernel, which
    sends a signal to the program and tries to recover from the error. These are classified
    into two categories, enumerated as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Processor-detected exceptions**: Those the CPU generates in response to an
    anomalous condition, which are divided into three groups:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faults, which can generally be corrected (bogus instruction).
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Traps, which occur in the user process (invalid memory access, division by zero),
    are also a mechanism to switch to kernel mode in response to a system call. If
    the kernel code does cause a trap, it immediately panics.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Aborts – the serious errors.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmed exceptions**: These are requested by the programmer and handled
    like traps.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have introduced the different families of interrupts, let's learn
    how they are implemented from within the interrupt controller.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Understanding interrupt controllers and interrupt multiplexing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a single interrupt from the CPU is usually not enough. Most systems
    have tens or hundreds of them. Now comes interrupt controller, which allows them
    to be multiplexed. Very often, architecture or platform-specific implementations
    offer specific facilities, such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Masking/unmasking individual interrupts
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting priorities
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMP affinity
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exotic features, such as wake-up interrupts
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IRQ management and interrupt controller drivers both rely on the concept of
    the IRQ domain, which is built on top of the following structures:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`struct irq_chip`: This is the interrupt controller data structure. This structure
    also implements a set of methods that allow to drive the interrupt controller
    and that are directly called by core IRQ code.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irqdomain`: This provides the following options:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the interrupt controller's firmware node (`fwnode`)
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A function for converting an IRQ's firmware description into an ID local to
    this interrupt controller (`hwirq`, also called hardware IRQ number)
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to retrieve the Linux view (`virq`, also called virtual IRQ number) of
    an IRQ from `hwirq`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_desc`: This structure is Linux''s view of an interrupt. It contains
    all the information about the interrupt as well as one-to-one mapping to the Linux
    interrupt number.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_action`: This structure is used to describe an IRQ handler.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct irq_data`: This structure is embedded in the `struct irq_desc` structure
    and provides us with the following information:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that is relevant to the IRQ chip managing this interrupt.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both `virq` and `hwirq`.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to `struct irq_chip` (the IRQ chip data structure). Note that most
    IRQ chip-related function calls are given `irq_data` as a parameter, from which
    you can obtain the corresponding `struct irq_desc`.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the preceding data structures are part of the IRQ domain API. An interrupt
    controller is represented in the kernel by an instance of the `struct irq_chip`
    structure, which describes the actual hardware device, and some methods used by
    the IRQ core. The following code block shows its definition:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following list explains the meanings of the elements in the structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`parent_device`: This is a pointer to the parent of this IRQ chip.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name for the`/proc/interrupts` file.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_enable`: This hook enables the interrupt. If not set (if `NULL`), it defaults
    to `chip->unmask`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_disable`: This disables the interrupt.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_ack`: This callback acknowledges an interrupt. It is unconditionally invoked
    by `handle_edge_irq()` and, therefore, must be defined (even an empty shell) for
    IRQ controller drivers that use `handle_edge_irq()` to handle interrupts. For
    such controllers, this callback is invoked at the start of the interrupt. Some
    controllers do not need this. Linux calls this function as soon as an interrupt
    is raised, long before it is serviced. This function is mapped to `chip->disable()`
    in some implementations so that if another interrupt request pokes on the line,
    it will not cause another interrupt until after the current interrupt request
    has been handled.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_mask`: This is the hook that masks an interrupt source in the hardware
    so that it cannot be raised anymore.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_unmask`: This hook unmasks an interrupt source.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_eoi`: Linux invokes this `chip->enable()` to reverse operations done in
    `chip->ack()`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_affinity`: This sets the CPU affinity only on SMP machines. In such
    machines, this function is used to specify the CPU on which the interrupt will
    be handled. This function is unused in single-processor environments, as interrupts
    are always services on the same single CPU.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_retrigger`: This retriggers the interrupt in the hardware, which resends
    an IRQ to the CPU.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_type`: This sets the flow type, such as `IRQ_TYPE_LEVEL`, of an IRQ.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_set_wake`: This enables/disables the power management wake-on of an IRQ.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_bus_lock`: This function locks access to slow bus (I2C) chips. Locking
    a mutex here is sufficient.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_bus_sync_unlock`: This function syncs and unlocks slow bus (I2C) chips,
    and unlocks the mutex previously locked.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_get_irqchip_state` and `irq_set_irqchip_state`: These return or set the
    internal state of an interrupt, respectively.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipi_send_single` and `ipi_send_mask`: These are used, respectively, to send
    **inter-processor interrupts** (**IPIs**) either to a single CPU or to a set of
    CPUs defined by a mask. IPIs are used on SMP systems to generate a CPU remote
    interrupt from the local CPU. We will discuss this later in the chapter, in the
    *Demystifying per-CPU interrupts* section.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each interrupt controller is given a domain, which is to the controller what
    an address space is to a process (see [*Chapter 10*](B17934_10_Epub.xhtml#_idTextAnchor146),
    *Understanding the Linux Kernel Memory Allocation*). The interrupt controller
    domain is described in the kernel with a `struct irq_domain` structure. It manages
    mappings between hardware IRQ numbers and Linux IRQ numbers (that is, virtual
    IRQs). It is the hardware interrupt number translation object. The following code
    block shows its definition:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the sake of readability, only elements that are relevant to us have been
    listed. The following list tells us their meanings:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the interrupt domain.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops`: This is a pointer to the IRQ domain methods.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_data`: This is a private data pointer for use by the owner. Not touched
    by the IRQ domain core code.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags`: This hosts per-IRQ domain flags.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapcount`: This is the number of mapped interrupts in this IRQ domain.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like all the remaining elements, `fwnode` is optional. It is a pointer to the
    **device tree** (**DT**) node associated with the IRQ domain. Used when decoding
    DT interrupt specifiers.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interrupt controller driver creates and registers an IRQ domain by calling
    one of the `irq_domain_add_<mapping_method>()` functions, where `<mapping_method>`
    is the method by which `hwirq` should be mapped to Linux `virq`. These functions
    are described in the following list:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '`irq_domain_add_linear()`: This uses a fixed-size table indexed by the `hwirq`
    number. When an `hwirq` number is mapped, an `irq_desc` object is allocated for
    this `hwirq` and the IRQ number is stored in the table. This linear mapping is
    suitable for controllers or domains that have a fixed and small number of `hwirq`
    (~ < 256). The inconvenience of this mapping is the table size, being as large
    as the largest possible `hwirq` number. Therefore, the IRQ number lookup time
    is fixed, and IRQ descriptors are allocated for in-use IRQs only. Most drivers
    should use linear mapping. This function has the following prototype:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`irq_domain_add_tree()`: With this mapping, the IRQ domain maintains the mapping
    between `virqs` (Linux IRQ numbers) and `hwirsq` (Hardware interrupt numbers)
    in a radix tree. An `irq_desc` object is allocated when an `hwirq` is mapped,
    and this hardware IRQ number is used as the radix tree''s lookup key. If the `hwirq`
    number can be very large, then the treemap is a viable solution because it does
    not require allocating a table as large as the largest `hwirq` number. The drawback
    is that the `hwirq`-to-IRQ-number lookup is affected by the number of entries
    in the table. Very few drivers should need this mapping. There are fewer than
    10 users of this API in the kernel. It has the prototype shown in the following
    code block:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`irq_domain_add_nomap()`: You will probably never use this method. Nonetheless,
    its entire description is available in `Documentation/IRQ-domain.txt`, in the
    kernel source tree. Its prototype is shown in the following code block:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In these functions, `of_node` is a pointer to the interrupt controller's DT
    node. `size` corresponds to the number of interrupts in the domain. `ops` represent
    map/unmap domain callbacks, and `host_data` is the controller's private data pointer.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'When it is initially created, the IRQ domain is empty (no mapping). A mapping
    is created and added as and when the IRQ chip driver calls `irq_create_mapping()`,
    which has the following prototype:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding function, `domain` is the domain to which this hardware interrupt
    belongs, or `NULL` for the default domain; `hwirq` represents the hardware interrupt
    number in that domain space.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'If a mapping for the `hwirq` number doesn''t already exist in the IRQ domain,
    the function will allocate a new Linux IRQ descriptor (`struct irq_desc`) structure,
    returning a virtual interrupt number at the same time. Then, it will associate
    it with the `hwirq` number (by means of the `irq_domain_associate()` function,
    which in turn invokes the `irq_domain_ops.map` callback so that the driver can
    perform any required hardware setup). To understand this paragraph, we need to
    describe the IRQ domain operation data structure (`struct irq_domain_ops`), which
    is defined in the following code block:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Elements in the data structure have been limited to the scope of this chapter.
    Nonetheless, the complete data structure can be found in `include/linux/irqdomain.h`
    in the kernel source. The following list tells us the meanings of the elements
    we have enumerated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '`map`: This creates or updates mapping between a `virq` number and an `hwirq`
    number. This callback is invoked only once for a given mapping. It generally maps
    the `virq` number with a given handler using `irq_set_chip_and_handler()`, so
    that calling either `generic_handle_irq()` or `handle_nested_irq()` will trigger
    this handler. The function `irq_set_chip_and_handler()` is defined as in the following
    code block:'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this function, `irq` is the Linux IRQ given as a parameter to the `map()`
    function, and `chip` is your IRQ chip. There are, however, dummy controllers that
    need almost nothing in their `irq_chip` structure. In this case, the driver passes
    `dummy_irq_chip`, defined in `kernel/irq/dummychip.c`, which is a kernel-predefined
    `irq_chip` structure defined for such controllers. `handle` determines the interrupt
    flow handler, the one that calls the real handler registered using `request_irq()`.
    Its value depends on the IRQ being edge- or level-triggered. In either case, `handle`
    should be set to `handle_edge_irq` or `handle_level_irq`. Both are kernel helper
    functions that do some operations before and after calling the real IRQ handler.
    An example is shown in this code block:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`xlate`: Given a DT node with an interrupt specifier, this hook decodes the
    hardware interrupt number in that specifier along with its Linux interrupt type
    value. Depending on the `#interrupt-cells` value specified in the DT controller
    node, the kernel provides generic translation functions:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_domain_xlate_twocell()`: Generic translation function to be used for direct
    two-cell binding. It works with a device tree IRQ specifier with two-cell bindings
    where the cell values map directly to the `hwirq` number and Linux IRQ flags.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq_domain_xlate_onecell()`: Generic `xlate` for direct one-cell bindings.'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Irq_domain_xlate_onetwocell()`: Generic `xlate` for one- or two-cell bindings.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of domain operation is given in the following code block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When an interrupt is received, the `irq_find_mapping()` function is used to
    find the Linux IRQ number from the `hwirq` number. Of course, the mapping must
    exist prior to being returned. A Linux IRQ number is always tied to a `struct
    irq_desc` structure, which is the structure by which Linux describes an IRQ and
    has the following definition:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Some fields in this data structure are intentionally missing. For the remainder,
    the following list gives us their definitions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`kstat_irqs`: This is the per-CPU IRQ statistics since boot.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handle_irq`: This is the high-level IRQ events handler.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: This represents the list of the IRQ actions for this descriptor.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irqs_unhandled`: This is the stats field for spurious unhandled interrupts.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lock`: This represents locking for SMP.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads_active`: This is the number of IRQ action threads currently running
    for this descriptor.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wait_for_threads`: This represents the wait queue for `sync_irq` to wait for
    threaded handlers.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nr_actions`: This is the number of installed actions on this descriptor.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_suspend_depth` and `force_resume_depth`: This represents the number of
    `irqaction` instances on an IRQ descriptor that have `IRQF_NO_SUSPEND` or `IRQF_FORCE_RESUME`
    flags set.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir`: This represents the `/proc/irq/` procfs entry.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This names the flow handler, visible in the `/proc/interrupts` output.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When registering an interrupt handler, this handler is added to the end of
    the `irq_desc.action` list associated with that interrupt line. For instance,
    each call to `request_irq()` (or the threaded version, `request_threaded_irq()`)
    creates and adds one `struct irqaction` structure to the end of the `irq_desc.action`
    list (knowing that `irq_desc` is the descriptor for this interrupt). For a shared
    interrupt, this field will contain as many `irqaction` objects as there are handlers
    registered. An IRQ action data structure has the following definition:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The meanings of each element in this data structure are as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '`handler`: This is the non-threaded (hard) interrupt handler function.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the device name.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_id`: This is a cookie to identify the device.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`percpu_dev_id`: This is a per-CPU cookie to identify the device.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next`: This is a pointer to the next IRQ action for shared interrupts.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`irq`: This is the Linux interrupt number (`virq`).'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flags`: This represents the IRQ flags (see `IRQF_*`).'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_fn`: This is the threaded interrupt handler function for threaded interrupts.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread`: This is a pointer to the thread structure in case of threaded interrupts.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_flags`: This represents the flags related to the thread.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thread_mask`: This is a bitmask for keeping track of thread activity.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir`: This points to the `/proc/irq/NN/<name>/` entry.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the definition of important fields in the `struct irq_data`
    structure, which is per-IRQ chip data passed down to chip functions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following list gives the meanings of elements in this data structure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '`irq`: This is the interrupt number (Linux IRQ number).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`: 这是中断编号（Linux IRQ 编号）。'
- en: '`hwirq`: This is the hardware interrupt number, local to the `irq_data.domain`
    interrupt domain.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hwirq`: 这是硬件中断编号，局部于 `irq_data.domain` 中断域。'
- en: '`chip`: This represents the low-level interrupt controller hardware access.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip`: 这是低级中断控制器硬件访问。'
- en: '`domain`: This represents the interrupt translation domain, responsible for
    mapping between the `hwirq` number and the Linux IRQ number.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`: 这是中断翻译域，负责在 `hwirq` 编号和 Linux IRQ 编号之间进行映射。'
- en: '`chip_data`: This is platform-specific, per-chip private data for the chip
    methods, to allow shared chip implementations.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip_data`: 这是平台特定的、每个芯片私有的数据，用于芯片方法，以便共享芯片实现。'
- en: Now that we are familiar with the data structures of the IRQ framework, we can
    go a bit further and study how interrupts are requested and propagated all along
    the processing chain.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了 IRQ 框架的数据结构，我们可以更进一步，研究中断是如何被请求并在处理链中传播的。
- en: Diving into advanced peripheral IRQ management
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究高级外设 IRQ 管理
- en: In [*Chapter 3*](B17934_03_Epub.xhtml#_idTextAnchor039), *Dealing with Kernel
    Core Helpers*, we introduced peripheral IRQs, using `request_irq()` and `request_threaded_irq()`.
    With the former, you register a handler (top half) that will be executed in an
    atomic context, from which you can schedule a bottom half using one of the mechanisms
    discussed in that same chapter. On the other hand, with the `_threaded` variant,
    you can provide top and bottom halves to the function, so that the former will
    be run as the hard IRQ handler, which may decide to raise the second and threaded
    handler or not, which will be run in a kernel thread.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B17934_03_Epub.xhtml#_idTextAnchor039)，*处理内核核心助手* 中，我们介绍了外设 IRQ，使用
    `request_irq()` 和 `request_threaded_irq()`。在前者中，您注册一个处理程序（上半部），该处理程序将在原子上下文中执行，从中您可以使用本章讨论的机制之一调度下半部。而在
    `_threaded` 变体中，您可以为函数提供上半部和下半部，这样前者将作为硬 IRQ 处理程序运行，可能会决定是否提升第二个并在线程中运行的处理程序。
- en: 'The problem with those approaches is that sometimes, drivers requesting an
    IRQ do not know about the nature of the interrupt controller that provides this
    IRQ line, especially when the interrupt controller is a discrete chip (typically
    a GPIO expander connected over SPI or I2C buses). Now comes the `request_any_context_irq()`function
    with which drivers requesting an IRQ know whether the handler will run in a thread
    context, and call `request_threaded_irq()` or `request_irq()` accordingly. This
    means that whether the IRQ associated with our device comes from an interrupt
    controller that may not sleep (memory-mapped one) or from one that can sleep (behind
    an I2C/SPI bus), there will be no need to change the code. Its prototype is shown
    in the following code block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的问题在于，有时请求 IRQ 的驱动程序并不了解提供此 IRQ 线路的中断控制器的性质，尤其是在中断控制器是独立芯片（通常是通过 SPI 或 I2C
    总线连接的 GPIO 扩展器）时。此时，`request_any_context_irq()` 函数应运而生，驱动程序请求 IRQ 时，可以知道处理程序是否会在线程上下文中运行，并相应地调用
    `request_threaded_irq()` 或 `request_irq()`。这意味着，无论与我们的设备相关的 IRQ 是来自可能不会休眠的中断控制器（内存映射的）还是来自能够休眠的中断控制器（通过
    I2C/SPI 总线），都不需要更改代码。其原型如下代码块所示：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are the meanings of each parameter in the function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是函数中每个参数的含义：
- en: '`irq`: This represents the interrupt line to allocate.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`: 这是要分配的中断线。'
- en: '`handler`: This is the function to be called when the IRQ occurs. Depending
    on the context, this function might run as a hard IRQ or might be threaded.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`: 这是 IRQ 发生时调用的函数。根据上下文，这个函数可能作为硬 IRQ 运行，也可能是线程化的。'
- en: '`flags`: This represents the interrupt type flags. It is the same as those
    in `request_irq()`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`: 这是中断类型标志。与 `request_irq()` 中的标志相同。'
- en: '`name`: This will be used for debugging purposes to name the interrupt in `/proc/interrupts`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这将用于调试目的，在 `/proc/interrupts` 中命名中断。'
- en: '`dev_id`: This is a cookie passed back to the handler function.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_id`: 这是一个传递回处理函数的 cookie。'
- en: '`request_any_context_irq()` means that you can either get a hard IRQ or a threaded
    one. It works in the same way as the usual `request_irq()`, except that it checks
    whether the IRQ is configured as nested or not, and calls the right backend. In
    other words, it selects either a hard IRQ or threaded handling method depending
    on the context. This function returns a negative value on failure. On success,
    it returns either `IRQC_IS_HARDIRQ` or `IRQC_IS_NESTED`. A use case is shown in
    the following code block:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code is an excerpt of the driver sample of an input device driver.
    The advantage of using `request_any_context_irq()` is that you do not need to
    care about what can be done in the IRQ handler, since the context in which the
    handler will run depends on the interrupt controller that provides the IRQ line.
    In our example, if the GPIO belongs to a controller sitting on an I2C or SPI bus,
    the handler will be threaded. Otherwise (memory mapped), the handler will run
    in a hard IRQ context.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IRQ and propagation
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram with a GPIO controller whose interrupt
    line is connected to a native GPIO on the SoC:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Interrupt propagation'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_13_002.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Interrupt propagation
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'IRQs are always processed based on the Linux IRQ number (not `hwirq`). The
    general function to request an IRQ on a Linux system is `request_threaded_irq()`.
    `request_irq()` is a wrapper on `request_threaded_irq()` which just don''t provide
    the bottom half. The following code block shows its prototype:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When called, the function extracts `struct irq_desc` associated with the IRQ
    using the `irq_to_desc()` macro. It then allocates a new `struct irqaction` structure
    and sets it up, filling parameters such as handler and flags. The following code
    block is an excerpt:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That same function finally inserts/registers the descriptor in the proper IRQ
    list by invoking the `__setup_irq()` (by means of `setup_irq()`) function, defined
    in `kernel/irq/manage.c`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when an IRQ is raised, the kernel executes some assembler code in order
    to save the current state and jumps to the arch-specific handler, `handle_arch_irq`.
    For ARM architectures, this handler is set with the value of the `handle_irq`
    field in `struct machine_desc` of the platform in the `setup_arch()` function
    implemented in `arch/arm/kernel/setup.c`. The assignation is done as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For SoCs that use the ARM `handle_irq` callback is set with `gic_handle_irq`,
    in either `drivers/irqchip/irq-gic.c` or `drivers/irqchip/irq-gic-v3.c`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`gic_handle_irq()` calls `handle_domain_irq()`, which executes `generic_handle_irq()`,
    in turn calling `generic_handle_irq_desc()`, which ends by calling `desc->handle_irq()`.
    The whole chain can be seen in `arch/arm/kernel/irq.c`. Now, `handle_irq` is the
    actual call for the flow handler, which we registered as `mcp23016_irq_handler`
    in the diagram.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '`gic_hande_irq()` is a GIC interrupt handler. `generic_handle_irq()` will execute
    the handler of the SoC''s GPIO4 IRQ, which will look for GPIO pins that issued
    the interrupt, and call `generic_handle_irq_desc()`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Chaining IRQs
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section describes how the interrupt handlers of a parent call its children's
    interrupt handlers, in turn calling their children's interrupt handlers, and so
    on. The kernel offers two approaches on how to call interrupt handlers for child
    devices in the IRQ handler of the parent (interrupt controller) device. These
    are the chained and nested methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Chained interrupts
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach is used for SoC's internal GPIO controllers, which are memory-mapped
    and which do not put the caller to sleep when these are accessed. Chained means
    that those interrupts are just chains of function calls (for example, SoC's GPIO
    module interrupt handler is being called from the GIC interrupt handler, just
    as a function call). `generic_handle_irq()` is used for interrupts chaining. Child
    IRQ handlers are called from inside the parent's hard IRQ handler. This means
    that even from within the child interrupt handlers, we are still in an atomic
    context (HW interrupt), and the driver must not call functions that may sleep.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Nested interrupts
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With this flow, function calls are nested, which means interrupt handlers are
    not invoked in the parent's handler. `handle_nested_irq()` is used for creating
    nested interrupt child IRQs. Handlers are called inside a new thread created for
    this purpose. This method is used by controllers that sit on slow buses such as
    SPI or I2C (such as GPIO expanders), and whose access may sleep (I2C and SPI access
    routines may sleep). Nested interrupt handlers that run in a process context can
    call any sleeping function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying per-CPU interrupts
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common ARM interrupt controller, GIC in the ARM multi-core processor,
    supports three types of interrupts:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU private interrupts**: These interrupts are private per CPU. If triggered,
    such a per-CPU interrupt will exclusively be serviced on the target CPU or CPU
    to which it is bound. Private interrupts can be split into two families:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private peripheral interrupts** (**PPIs**): These are private and can only
    be generated by hardware bound to the CPU.'
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software-generated interrupts** (**SGIs**): Unlike PPIs, these are generated
    by the software. Thanks to this, SGIs are usually used as interrupt IPIs for inter-core
    communication on multi-core systems, meaning that one CPU can generate an interrupt
    (by writing the appropriate message, made of the interrupt ID and the target CPU
    to the GIC controller) to (an)other CPU(s). This is what we will talk about in
    this section.'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared peripheral interrupts** (**SPIs**) (not to be confused with the SPI
    bus): These are the classical interrupts that we have discussed so far. Such interrupts
    can route to any CPU.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In systems with an interrupt controller that supports private interrupts per
    core, some of the IRQ controller registers will be banked so that they're only
    accessible from one core (for example, a core will only be able to read/write
    its own interrupt configuration). Usually, to be able to do so, some interrupt
    controller registers are banked per CPU; a CPU can enable its local interrupt
    by writing to its banked registers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The distributor block and the CPU interface block are logically partitioned
    in the GIC. Interacting with interrupt sources, the distributor block prioritizes
    interrupts and delivers them to the CPU interface block. The CPU interface block
    links to the system's processors and manages priority masking and preemption for
    the processors to which it is linked.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The GIC can support up to 8 CPU interfaces, each of which can handle up to
    1,020 interrupts. Interrupt ID numbers 0–1019 are assigned by the GIC as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Interrupt numbers 0–31 are interrupts that are private to a CPU interface.
    These private interrupts are banked in the distributor block and split as follows:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SGIs use banked interrupt numbers 0–15.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PPIs use banked interrupt numbers 16–31\. In SMP systems, for example, a per-CPU
    timer provided by clock event devices can generate such interrupts.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SPIs use interrupt numbers 32–1,019.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remaining interrupts are reserved, that is, interrupt numbers 1020–1023.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are familiar with ARM GIC interrupt families, we can focus on the
    family we are interested in, that is, SGIs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: SGIs and IPIs
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ARM processors, there are 16 SGIs, numbered from 0 to 15, but the Linux
    kernel registers only a few of them: eight (from 0 to 7) to be precise. SGI8 to
    SGI15 are free for now. Registered SGIs are those defined in `enum ipi_msg_type`,
    which is defined as the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Their respective descriptions can be found in an array of strings, or `ipi_types`,
    defined in the following code block:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'IPIs are registered in the `set_smp_ipi_range()` function, defined in the following
    code block:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code block, each IPI is registered with `request_percpu_irq()`
    on a per-CPU basis. We can see that IPIs have the same handler, `ipi_handler()`,
    defined as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The underlying function executed in the handler is `do_handle_IPI()`, defined
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From the preceding function,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`IPI_WAKEUP`: This is used to wake up and boot a secondary CPU. It is mostly
    issued by the boot CPU.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPI_RESCHEDULE`: The Linux kernel uses rescheduling interrupts to tell another
    CPU core to schedule a thread. The scheduler on SMP systems does this to distribute
    the load over multiple CPU cores. As a general rule, it is ideal to have as many
    processes running on all the cores in lower power (lower clock frequencies) rather
    than have one busy core running at full speed while other cores are sleeping.
    When the scheduler needs to offload work from one core to another sleeping core,
    the scheduler sends a kernel IPI message to that sleeping core, causing it to
    wake up from its low-power sleep and begin running a process. These IPI events
    are reported by `powertop` as `Rescheduling Interrupts`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPI_TIMER`: This is the timer broadcast interrupt. This IPI emulates a timer
    interrupt on an idle CPU. It is sent by the broadcast clock event/tick device
    to CPUs represented in `tick_broadcast_mask`, which is the bitmap that represents
    the list of processors that are in a sleeping mode. Tick devices and broadcast
    masks are discussed in [*Chapter 3*](B17934_03_Epub.xhtml#_idTextAnchor039), *Dealing
    with Kernel Core Helpers*.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPI_CPU_STOP`: When a kernel panic occurs on one CPU, other CPUs are instructed
    to dump their stack and to stop execution via the `IPI_CPU_STOP` IPI message.
    The target CPUs are not shut down or taken offline; instead, they stop execution
    and are placed in a low-power loop, in a **wait for event** (**WFE**) state.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPI_CALL_FUNC`: This is used to run a function in another processor context.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IPI_IRQ_WORK`: This is used to run a work in a hardware IRQ context. The kernel
    offers a bunch of mechanisms to defer works to a later time, especially out of
    the hardware interrupt context. There might, however, be the occasional need to
    run a work in a hardware interrupt context and there is no hardware conveniently
    signaling interrupts at the time. To achieve that, an IPI is used to run the work
    in a hardware interrupt context. This is mainly used in code running from non-maskable
    interrupts, which needs to be able to interact with the rest of the system.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On a running system, you can look for available IPIs from the `/proc/interrupt`
    file, as shown in the following code block:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the command output shown here, the first column is the IPI identifier and
    the last one is the description of the IPI. The columns in between are their respective
    numbers of executions on each CPU.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, IRQ multiplexing has no more secrets from you. We have discussed the most
    important element of IRQ management in Linux systems: the IRQ domain API. You
    have the basics to understand existing interrupt controller drivers, as well as
    their binding from within the DT. IRQ propagation has been discussed in order
    to explore what happens between the request and the handler invocation.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we deal with a completely different topic: the Linux device
    model.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
