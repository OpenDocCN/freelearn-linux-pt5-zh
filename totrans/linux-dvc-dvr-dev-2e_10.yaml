- en: '*Chapter 8*: Writing I2C Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**I2C** stands for **Inter-Integrated Circuit**. It is a serial, multi-master,
    and asynchronous bus invented by Philips (now NXP), though multi-master mode is
    not widely used. I2C is a two-wire bus, respectively named **Serial Data** (**SDA**)
    and **Serial Clock** (**SCL**, or **SCK**). An I2C device is a chip that interacts
    with another device via an I2C bus. On this bus, both SDA and SCL are open-drain/open
    collectors, meaning that each can drive its output low, but neither can drive
    its output high without having pull-up resistors. SCL is generated by the master
    to synchronize data (carried by SDA) transfer over the bus. Both the slave and
    master can send data (not at the same time, of course), thus making SDA a bidirectional
    line. That said, the SCL signal is also bidirectional since the slave can *stretch*
    the clock by keeping the SCL line low. The bus is controlled by the master, which
    in our case is part of the **System on Chip** (**SoC**). This bus is frequently
    used in embedded systems to connect serial EEPROM, RTC chips, GPIO expanders,
    temperature sensors, and so on.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows various devices (also known as slaves) connected
    to an I2C bus:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – I2C bus and device representation'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_08.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – I2C bus and device representation
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can represent the Linux kernel I2C framework
    as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The CPU is the master hosting the I2C controller, also known as the I2C adapter,
    which implements the I2C protocol and manages the bus segment that's hosting the
    I2C devices. In the kernel I2C framework, the adapter is managed by a platform
    driver while the slave is driven by an I2C driver. However, both drivers use APIs
    provided by the I2C core. In this chapter, we will be focusing on I2C (slave)
    device drivers, though references to the adapter will be mentioned if necessary.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Back to the hardware, I2C clock speed varies from 10 kHz to 100 kHz, and from
    400 kHz to 2 MHz. There are no strict data transfer speed requirements for I2C,
    and all the slaves sitting on a given bus will use the same clock speed that the
    bus has been configured with. This is unlike `drivers/i2c/busses/i2c-imx.c` in
    the kernel source, and the I2C specifications can be found at [https://www.nxp.com/docs/en/user-guide/UM10204.pdf](https://www.nxp.com/docs/en/user-guide/UM10204.pdf).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that we will be dealing with an I2C device driver, in this
    chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: I2c framework abstraction in the Linux kernel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The I2C driver abstraction and architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How not to write I2C device drivers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I2C framework abstractions in the Linux kernel
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Linux kernel I2C framework is made up of a few data structures, with the
    most important being as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`i2c_adapter`: Used to abstract the I2C master device. It is used to identify
    a physical I2C bus.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2c_algorithm`: This abstracts the I2C bus transaction interface. Here, transaction
    means to transfer, such as read or write operations.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2c_algorithm`：它抽象了 I2C 总线事务接口。这里的事务意味着传输，例如读取或写入操作。'
- en: '`i2c_client`: Used to abstract a slave device sitting on the I2C bus.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2c_client`：用于抽象表示位于 I2C 总线上的从设备。'
- en: '`i2c_driver`: The driver of the slave device. It contains a set of specific
    driving functions to deal with the device.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2c_driver`：从设备的驱动程序。它包含一组特定的驱动功能，用于处理该设备。'
- en: '`i2c_msg`: This is the low-level representation of one segment of an I2C transaction.
    This data structure defines the device address, the transaction flags (if it''s
    a transmit or receive, for example), a pointer to the data to send/receive, and
    the size of the data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2c_msg`：这是 I2C 事务一个段的低级表示。该数据结构定义了设备地址、事务标志（例如，它是传输还是接收）、指向要发送/接收的数据的指针，以及数据的大小。'
- en: Since the scope of this chapter is limited to slave device drivers, we will
    focus on the last three data structures. However, to help you understand this,
    we need to introduce both the adapter and algorithm data structures.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的范围仅限于从设备驱动程序，我们将重点关注最后三个数据结构。不过，为了帮助您理解这一点，我们需要介绍适配器和算法数据结构。
- en: A brief introduction to struct i2c_adapter
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对 `struct i2c_adapter` 的简要介绍
- en: 'The kernel uses `struct i2c_adapter` to represent a physical I2C bus, along
    with the algorithms that are necessary to access it. It is defined as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内核使用 `struct i2c_adapter` 来表示一个物理的 I2C 总线，并包含访问该总线所需的算法。它的定义如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding data structure, we have the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，我们有以下内容：
- en: '`owner`: Most of the time, this is set with `THIS_MODULE`. This is the owner,
    and it''s used for reference counting.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`：大多数情况下，这个值被设置为 `THIS_MODULE`。它是所有者，并用于引用计数。'
- en: '`algo`: This is a set of callbacks that are used by the controller (the master)
    driver to drive the I2C line. These callbacks allow you to generate the signal
    that''s needed for the I2C access cycle.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`algo`：这是一个回调函数集，由控制器（主设备）驱动程序用于驱动 I2C 线路。这些回调允许你生成访问 I2C 总线所需的信号。'
- en: 'The algorithm''s data structure has the following definition:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的数据结构有如下定义：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding data structure, the unimportant fields have been omitted.
    Let''s look at each element in the excerpt:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，已省略不重要的字段。让我们看一下摘录中的每个元素：
- en: '`master_xfer`: This is the core transfer function. It must be provided for
    this algorithm driver to have plain I2C access. It is invoked when an I2C device
    driver needs to communicate with the underlying I2C device. However, if it is
    not implemented (if `NULL`), the `smbus_xfer` function is called instead.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master_xfer`：这是核心传输函数。对于该算法驱动程序提供的基本 I2C 访问，必须提供此函数。当 I2C 设备驱动程序需要与底层 I2C
    设备通信时，会调用此函数。然而，如果它未实现（如果是 `NULL`），则会调用 `smbus_xfer` 函数。'
- en: '`smbus_xfer`: This is a function pointer that is set by the I2C controller
    driver if its algorithm driver can perform SMBus accesses. It is used whenever
    an I2C chip driver wants to communicate with the chip device using the SMBus protocol.
    If it is `NULL`, the `master_xfer` function is used instead and the SMBus is emulated.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`smbus_xfer`：这是一个函数指针，如果 I2C 控制器驱动程序的算法驱动程序可以执行 SMBus 访问，它会被 I2C 控制器驱动程序设置。每当
    I2C 芯片驱动程序希望使用 SMBus 协议与芯片设备通信时，就会使用它。如果它是 `NULL`，则使用 `master_xfer` 函数，SMBus 会被模拟。'
- en: '`functionality`: This is a function pointer that''s called by the I2C core
    to determine the capabilities of the adapter. It informs you about what kind of
    reads and writes the I2C adapter driver can do.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functionality`：这是一个函数指针，由 I2C 核心调用，用于确定适配器的功能。它通知您该 I2C 适配器驱动程序可以进行何种类型的读取和写入操作。'
- en: 'In the preceding code, `functionality` is a sanity callback. Either the core
    or device drivers can invoke it (through `i2c_check_functionality()`) to check
    whether the given adapter can provide the I2C access we need before we initiate
    this access. For example, 10-bit addressing mode is not supported by all adapters.
    Thus, it is safe to call `i2c_check_functionality(client->adapter, I2C_FUNC_10BIT_ADDR)`
    in the chip driver to check whether it is supported by the adapter. All the flags
    are in the form of `I2C_FUNC_XXX`. Though each can be checked individually, the
    I2C core has split them into logical functions, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`functionality` 是一个健全性回调函数。核心或设备驱动程序可以调用它（通过 `i2c_check_functionality()`）来检查在我们启动访问之前，给定的适配器是否能够提供所需的
    I2C 访问。例如，并不是所有的适配器都支持 10 位寻址模式。因此，在芯片驱动中调用 `i2c_check_functionality(client->adapter,
    I2C_FUNC_10BIT_ADDR)` 来检查适配器是否支持这一功能是安全的。所有的标志都是以 `I2C_FUNC_XXX` 的形式表示的。虽然每个标志可以单独检查，但
    I2C 核心已经将它们拆分为逻辑功能，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the preceding code, you can check the `I2C_FUNC_SMBUS_BYTE` flag to make
    sure that the adapter supports SMBus byte-oriented commands.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以检查 `I2C_FUNC_SMBUS_BYTE` 标志，以确保适配器支持 SMBus 字节定向命令。
- en: This introduction to I2C controllers will be referenced in other sections as
    needed. It may make sense to understand this first, even though the main purpose
    of this chapter is to discuss the I2C client driver, which we will do in the next
    section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍关于 I2C 控制器的内容将在后续章节中根据需要进行参考。尽管本章的主要目的是讨论 I2C 客户端驱动程序（我们将在下一节中讨论），但理解这些内容可能会更有意义。
- en: I2C client and driver data structures
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C 客户端和驱动程序数据结构
- en: 'The first and most evident data structure is the `struct i2c_client` structure,
    which is declared like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最明显的数据结构是 `struct i2c_client` 结构，它的声明方式如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding data structure, which holds the properties of the I2C device,
    `flags` represents the device flags, the most important of which is the one telling
    us whether this is a 10-bit chip address. `addr` contains the chip address. In
    the case of a 7-bit address chip, it will be stored in the lower 7 bits. `name`
    contains the device name, which is limited to `I2C_NAME_SIZE` (set to `20` in
    `include/linux/mod_devicetable.h`) characters. `adapter` is the adapter (remember,
    it is the I2C bus) that this device sits on. `dev` is the underlying device structure
    for the device model, and `irq` is the interrupt line that's been assigned to
    the device.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，包含 I2C 设备的属性，`flags` 表示设备标志，其中最重要的是表示是否为 10 位芯片地址的标志。`addr` 包含芯片地址。对于
    7 位地址芯片，它将存储在最低的 7 位中。`name` 包含设备名称，限制为 `I2C_NAME_SIZE` （在 `include/linux/mod_devicetable.h`
    中设置为 `20`）个字符。`adapter` 是设备所在的适配器（记住，它是 I2C 总线）。`dev` 是设备模型的底层设备结构，`irq` 是分配给设备的中断线。
- en: 'Now that we are familiar with the I2C device data structure, let''s focus on
    its driver, which is abstracted by `struct i2c_driver`. It can be declared like
    so:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 I2C 设备的数据结构，让我们关注它的驱动程序，它由 `struct i2c_driver` 抽象表示。它可以这样声明：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s look at each element in the data structure:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据结构中的每个元素：
- en: '`probe`: A callback for device binding that should return 0 on success or the
    appropriate error code on failure.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe`：设备绑定的回调函数，成功时应返回 0，失败时返回相应的错误代码。'
- en: '`remove`: A callback for device unbinding. It must undo what has been done
    in `probe`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：设备解绑的回调函数。它必须撤销在 `probe` 中所做的操作。'
- en: '`shutdown`: A callback for device shutdown.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：设备关闭的回调函数。'
- en: '`probe_new`: The new driver model interface. This will deprecate the legacy
    `probe` method to get rid of its commonly unused second parameter (that is, the
    `struct i2c_device_id` parameter).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe_new`：新的驱动程序模型接口。它将废弃传统的 `probe` 方法，以去除其常用的未使用第二个参数（即 `struct i2c_device_id`
    参数）。'
- en: '`driver`: The underlying device driver model''s driver structure.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`：底层设备驱动模型的驱动程序结构。'
- en: '`id_table`: The list of I2C devices that are supported by this driver.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_table`：该驱动程序支持的 I2C 设备列表。'
- en: 'The third and last data structure of this series is `struct i2c_msg`, which
    represents one operation of an I2C transaction. It is declared like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该系列的第三个也是最后一个数据结构是 `struct i2c_msg`，它代表一次 I2C 事务的一个操作。它的声明方式如下：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Each element in this data structure is self-explanatory. Let''s look at them
    in more detail:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构中的每个元素都可以自我解释。让我们更详细地看看它们：
- en: '`addr`: This is always the slave address.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr`：这始终是从设备地址。'
- en: '`flags`: Because a transaction may be made of several operations, this element
    represents the flags of this operation. It should be set to `0` in the case of
    a write operation (that the master sends to the slave). However, it can be ORed
    with either `I2C_M_RD` if it''s a read operation (the master reads from the slave)
    or `I2C_M_TEN` if the device is a 10-bit chip address.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：因为一个事务可能由多个操作组成，因此该元素表示此操作的标志。如果是写操作（主设备发送给从设备），则应将其设置为 `0`。但是，如果是读操作（主设备从从设备读取数据），则可以将其与
    `I2C_M_RD` 或 `I2C_M_TEN` 进行或运算，`I2C_M_TEN` 适用于 10 位芯片地址的设备。'
- en: '`length`: This is the size of data in the buffer. In a read operation, it corresponds
    to the number of bytes to be read from the device and is stored in `buf`. In the
    case of a write operation, it represents the number bytes in `buf` to write to
    the device.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是缓冲区中数据的大小。在读取操作中，它对应于要从设备读取的字节数，并存储在 `buf` 中。在写操作中，它表示要写入设备的 `buf`
    中的字节数。'
- en: '`buf`: This is the read/write buffer, which must be allocated as per `length`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf`：这是读/写缓冲区，必须根据 `length` 分配。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Since `i2c_msg.len` is `u16`, you must ensure you are always less than 216 (64k)
    away with your read/write buffer.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 `i2c_msg.len` 是 `u16` 类型，您必须确保您的读/写缓冲区的大小始终小于 216（64k）。
- en: Now that we have discussed the most important I2C data structures, let's look
    at the APIs (most of which involve the I2C adapter under the hood) that are exposed
    by the I2C core to get the most out of our devices.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了最重要的 I2C 数据结构，让我们看看 I2C 核心暴露的 API（大多数涉及 I2C 适配器的底层实现），以便充分利用我们的设备。
- en: I2C communication APIs
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C 通信 API
- en: Once the driver and the data structure have been initialized, communication
    between the slave and the master can take place. Serial bus transactions are just
    simple matters of register access, either to get or set their content. I2C devices
    respect this principle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦驱动程序和数据结构初始化完成，从属设备和主设备之间的通信就可以开始。串行总线事务仅仅是简单的寄存器访问问题，无论是读取还是写入其内容。I2C 设备遵循这一原则。
- en: Plain I2C communication
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通 I2C 通信
- en: 'We will start from the lowest level – `i2c_transfer()` is the core function
    that''s used to transfer I2C messages. Other APIs wrap this function, which is
    backed by `algo->master_xfer` of the adapter. The following is its prototype:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最低层开始——`i2c_transfer()` 是用于传输 I2C 消息的核心函数。其他 API 封装了此函数，背后由适配器的 `algo->master_xfer`
    支持。以下是其原型：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With `i2c_transfer()`, no stop bit is sent between bytes in the same read/write
    operation of the same transaction. This is useful for devices that require no
    stop bit between address write and data read, for example. The following code
    shows how it can be used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `i2c_transfer()` 时，在同一事务的相同读/写操作中，字节之间不会发送停止位。这对于那些在地址写入和数据读取之间不需要停止位的设备很有用，例如。以下代码展示了它的使用方式：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the device requires a stop bit in the middle of a read sequence, you should
    split your transaction into two parts (two operations) – `i2c_transfer` for address
    write (a transaction with a single write operation), and another `i2c_transfer`
    for data read (a transaction with a single read operation), as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备在读取序列中间需要一个停止位，您应该将事务拆分为两部分（两个操作）——`i2c_transfer` 用于地址写入（包含单次写操作的事务），另一个
    `i2c_transfer` 用于数据读取（包含单次读操作的事务），如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Otherwise, you can use alternative APIs, such as `i2c_master_send` and `i2c_master_recv`,
    respectively:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以使用其他替代 API，如 `i2c_master_send` 和 `i2c_master_recv`，分别用于发送和接收数据：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These APIs are both implemented on top of `i2c_transfer()`. `i2c_master_send()`
    actually implements an I2C transaction with a single write operation, while `i2c_master_recv()`
    does the same with a single read operation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 API 都是在 `i2c_transfer()` 的基础上实现的。`i2c_master_send()` 实际上实现了一个包含单次写操作的 I2C
    事务，而 `i2c_master_recv()` 则实现了一个包含单次读操作的 I2C 事务。
- en: 'The first argument is the I2C device to be accessed. The second parameter is
    the read/write buffer, while the third represents the number of bytes to read
    or write. The returned value is the number of bytes being read/written. The following
    code is a simplified version of our previous excerpt:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要访问的 I2C 设备。第二个参数是读/写缓冲区，第三个参数表示要读取或写入的字节数。返回值是读取/写入的字节数。以下代码是我们之前摘录的简化版：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, we are familiar with how plain I2C APIs are implemented in the kernel.
    However, there is a category of devices we need to address – SMBus-compatible
    devices – which are not to be confused with I2C ones, even though they sit on
    the same physical bus.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经熟悉了内核中如何实现普通的 I2C API。然而，我们还需要处理一类设备——SMBus 兼容设备——这些设备不能与 I2C 设备混淆，尽管它们位于同一物理总线上。
- en: System Management Bus (SMBus)-compatible functions
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统管理总线（SMBus）兼容的函数
- en: SMBus is a two-wire bus developed by Intel and is very similar to I2C. Moreover,
    it is a subset of I2C, which means I2C devices are SMBus-compatible, but not the
    reverse. SMBus is a subset of I2C, which means I2C controllers support most SMBus
    operations. However, this is not true for SMBus controllers as they may not support
    all the protocol options that an I2C controller will. Therefore, it is better
    to use SMBus methods in case you have doubts about the chip you are writing the
    driver for.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SMBus 是由英特尔开发的双线总线，与 I2C 非常相似。更重要的是，SMBus 是 I2C 的子集，这意味着 I2C 设备兼容 SMBus，但反之则不然。SMBus
    是 I2C 的子集，这意味着 I2C 控制器支持大多数 SMBus 操作。然而，对于 SMBus 控制器来说并非如此，因为它们可能不支持 I2C 控制器所支持的所有协议选项。因此，如果你对所编写驱动的芯片有疑问，最好使用
    SMBus 方法。
- en: 'The following are some examples of SMBus APIs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 SMBus API 的示例：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A complete list of SMBus APIs is available in `include/linux/i2c.h` in the
    kernel sources. Each function is self-explanatory. The following example shows
    a simple read/write operation that''s using SMBus-compatible APIs to access an
    I2C GPIO expander:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 SMBus API 列表可以在内核源代码的 `include/linux/i2c.h` 中找到。每个函数都是自解释的。以下示例展示了一个简单的读写操作，使用
    SMBus 兼容的 API 访问 I2C GPIO 扩展器：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The SMBus part is as simple as the list of APIs that are available. Now that
    we can access the device either using plain I2C functions or SMBus functions,
    we can start implementing the body of our I2C driver.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SMBus 部分非常简单，仅包含可用的 API 列表。现在，我们可以使用普通的 I2C 函数或 SMBus 函数访问设备，接下来我们可以开始实现 I2C
    驱动程序的主体部分。
- en: The I2C driver abstraction and architecture
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C 驱动程序抽象和架构
- en: The `struct i2c_driver` structure, as we saw in the previous section, contains
    the driving methods that are needed to handle the I2C devices it is responsible
    for. Once added to the bus, the device will need to be probed, which makes the
    `i2c_driver.probe_new` method the entry point of the driver.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，`struct i2c_driver` 结构体包含了处理其负责的 I2C 设备所需的驱动方法。一旦设备被添加到总线上，它就需要被探测，这使得
    `i2c_driver.probe_new` 方法成为驱动程序的入口点。
- en: Probing the I2C device
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探测 I2C 设备
- en: 'The `probe()` callback in the `struct i2c_driver` structure is invoked any
    time an I2C device is instantiated on the bus and claims this driver. It is responsible
    for the following tasks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct i2c_driver` 结构中的 `probe()` 回调函数每次当一个 I2C 设备在总线上实例化并声明使用该驱动程序时都会被调用。它负责以下任务：'
- en: Checking whether the I2C bus controller (the I2C adapter) supports the functionalities
    needed by the device using the `i2c_check_functionality()` function
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `i2c_check_functionality()` 函数检查 I2C 总线控制器（I2C 适配器）是否支持设备所需的功能。
- en: Checking whether the device is the one we expected
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查设备是否是我们预期的设备
- en: Initializing the device
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化设备
- en: Setting up device-specific data if necessary
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，设置特定设备的数据
- en: Registering with the appropriate kernel frameworks
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册到适当的内核框架中
- en: 'Formerly, the probing callback was assigned to the `probe` element of `struct
    i2c_driver` and had the following prototype:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，探测回调函数是分配给 `struct i2c_driver` 的 `probe` 元素，并且具有以下原型：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because the second argument is rarely used, this callback has been deprecated
    in favor of `probe_new`, which has the following prototype:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二个参数很少使用，这个回调函数已经被弃用，取而代之的是 `probe_new`，其原型如下：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding prototype, the `struct i2c_client` pointer represents the I2C
    device itself. This parameter is prebuilt and initialized by the core according
    to the device's description, which is done either in the device tree or in the
    board file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`struct i2c_client` 指针代表了 I2C 设备本身。这个参数由内核根据设备的描述预构建并初始化，这些描述可以在设备树或板文件中完成。
- en: 'It is not recommended to access the device early in the `probe` method. Because
    each I2C adapter has different capabilities, it is better to request for it to
    know what capabilities it supports and adapt the driver''s behavior accordingly:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在 `probe` 方法中过早地访问设备。由于每个 I2C 适配器具有不同的能力，因此最好先请求设备以了解其支持的功能，并根据这些信息调整驱动程序的行为：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we checked whether the underlying adapter supports
    the type/command the device needs. Only after a successful sanity check, we can
    safely access the device and go further by allocating resources of any kind and
    registering with other frameworks if necessary.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们检查了底层适配器是否支持设备所需的类型/命令。只有在通过了成功的健全性检查后，我们才能安全地访问设备，并在必要时进一步分配资源并与其他框架注册。
- en: Implementing the i2c_driver.remove method
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`i2c_driver.remove`方法
- en: 'The `i2c_driver.remove` callback must undo what has been done in the `probe`
    function. It must unregister from each framework that was registered with `probe`
    and release each resource that was requested. This callback has the following
    prototype:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_driver.remove`回调必须撤销在`probe`函数中所做的工作。它必须从每个在`probe`中注册的框架中注销，并释放请求的每个资源。该回调具有以下原型：'
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding line of code, `client` is the same I2C device data structure
    that was passed by the core to the `probe` method. This means that whatever data
    you have stored at probing time can be retrieved here. For example, you may need
    to process some cleaning or any other stuff based on the private data you set
    up in the `probe` function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，`client`是核心传递给`probe`方法的相同I2C设备数据结构。这意味着你在探测时存储的任何数据都可以在这里检索。例如，你可能需要根据在`probe`函数中设置的私有数据来处理一些清理工作或其他操作：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example is simple and may represent most cases that you will see
    in drivers. Since this callback is supposed to return zero on success, the failure
    reasons may include that the device can't power down, is still in use, and so
    on. This means that there may be situations where you will want to consult the
    device and perform some additional operations in this callback function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例简单且可能代表你在驱动程序中看到的大多数情况。由于此回调应在成功时返回零，失败的原因可能包括设备无法关机、设备仍在使用中等。这意味着可能会有一些情况，在这些情况下你需要查询设备并在此回调函数中执行一些额外的操作。
- en: At this stage in the development process, all the callbacks have been prepared.
    Now, it is time for the driver to register with the I2C core, as we'll see in
    the next section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程的这个阶段，所有回调都已准备好。现在，是时候让驱动程序向I2C核心注册了，我们将在下一节中看到这一点。
- en: Driver initialization and registration
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动程序初始化和注册
- en: 'I2C drivers register and unregister themselves with the core using the `i2c_add_driver()`
    and `i2c_del_driver()` APIs, respectively. The former is a macro that''s backed
    by the `i2c_register_driver()` function. The following code shows their respective
    prototypes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: I2C驱动程序通过`i2c_add_driver()`和`i2c_del_driver()`API与核心进行注册和注销。前者是一个宏，背后由`i2c_register_driver()`函数实现。以下代码展示了它们各自的原型：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In both functions, `drv` is the I2C driver structure that had been set up previously.
    The registration API returns zero on success or a negative error code on failure.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数中，`drv`是先前设置的I2C驱动程序结构。注册API在成功时返回零，失败时返回负错误代码。
- en: 'Driver registration mostly takes place in the module initialization while unregistering
    this driver is usually done in module exit method. The following is a typical
    demonstration of I2C driver registering:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的注册通常发生在模块初始化中，而注销此驱动程序通常在模块退出方法中完成。以下是I2C驱动程序注册的典型示例：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the driver needs to do nothing else but register/unregister the driver during
    module initialization/cleanup, then the `module_i2c_driver()` macro can be used
    to reduce the preceding code, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果驱动程序在模块初始化/清理过程中只需要注册/注销驱动程序，那么可以使用`module_i2c_driver()`宏来简化前面的代码，如下所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This macro will be expanded at build time to the appropriate initialization/exit
    methods in the module, which will take care of registering/unregistering the I2C
    driver.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏将在构建时扩展为模块中的适当初始化/退出方法，这些方法将处理I2C驱动程序的注册/注销。
- en: Provisioning devices in the driver
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在驱动程序中配置设备
- en: 'For the matching loop to be invoked with our I2C driver, the `i2c_driver.id_table`
    field must be set with a list of I2C device IDs, each described by an instance
    of the `struct i2c_device_id` data structure, which has the following definition:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让匹配循环在我们的I2C驱动程序中被调用，`i2c_driver.id_table`字段必须设置为I2C设备ID的列表，每个ID由`struct i2c_device_id`数据结构的一个实例描述，其定义如下：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding data structure, `name` is a descriptive name for the device,
    while `driver_data` is the driver state data, which is private to the driver.
    It can be set with a pointer to a per-device data structure, for example. Additionally,
    for device matching and module (auto)loading purposes, this same device ID array
    needs to be given to the `MODULE_DEVICE_TABLE` macro.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述数据结构中，`name`是设备的描述性名称，而`driver_data`是驱动程序状态数据，它是驱动程序私有的。它可以设置为指向每个设备的数据结构，例如。此外，为了设备匹配和模块（自动）加载的目的，这个设备ID数组还需要传递给`MODULE_DEVICE_TABLE`宏。
- en: 'However, this does not concern device tree matching. For a device node in the
    device tree to match our driver, the `i2c_driver.device.of_match_table` element
    of our driver must be set with a list of elements of the `struct of_device_id`
    type. Each entry in that list will describe an I2C device that can be matched
    from the device tree. The following is the definition of this data structure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这与设备树匹配无关。为了使设备树中的设备节点与我们的驱动程序匹配，我们的驱动程序的`i2c_driver.device.of_match_table`元素必须设置为一个包含`struct
    of_device_id`类型元素的列表。该列表中的每个条目将描述一个可以从设备树中匹配的I2C设备。以下是该数据结构的定义：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding data structure, `compatible` is a quite descriptive string
    that can be used in the device tree to match this driver, while `data` can point
    to anything, such as a per-device resource. In the same way, for module (auto)loading
    due to a device tree match, this list must be given to the `MODULE_DEVICE_TABLE`
    macro.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述数据结构中，`compatible`是一个相当描述性的字符串，可以用于设备树中匹配该驱动程序，而`data`则可以指向任何内容，例如每个设备的资源。同样，为了设备树匹配后的模块（自动）加载，这个列表必须传递给`MODULE_DEVICE_TABLE`宏。
- en: 'The following is an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, for module loading after a device tree match, we need to do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于设备树匹配后的模块加载，我们需要做以下工作：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The excerpt shows the final content for `i2c_driver`, with the respective device
    table pointers set:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该摘录展示了`i2c_driver`的最终内容，设置了相应的设备表指针：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we can see what an I2C driver structure would look like
    once it has been set up.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以看到一旦设置完毕，I2C驱动程序结构将是什么样子。
- en: Instantiating I2C devices
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化I2C设备
- en: 'We will be using the device tree declaration because the board file, though
    used in old drivers so far, is an era far behind us. I2C devices must be declared
    as children (sub-nodes) of the bus node they sit on. The following are the properties
    that are required for their binding:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用设备树声明，因为尽管板文件目前还在旧驱动程序中使用，但它已经是一个远离我们的时代。I2C设备必须作为它们所在总线节点的子节点（子节点）进行声明。以下是它们绑定所需的属性：
- en: '`reg`: This represents the address of the device on the bus.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`：表示设备在总线上的地址。'
- en: '`compatible`: This is a string that is used to match the device with a driver.
    It must match an entry in the driver''s `of_match_table`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compatible`：这是一个用于将设备与驱动程序匹配的字符串。它必须与驱动程序的`of_match_table`中的一个条目匹配。'
- en: 'The following is an example declaration of two I2C devices on the same adapter:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是同一适配器上声明的两个I2C设备的示例：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding sample declares an RTC chip at address `0x68` and an EEPROM at
    address `0x55` on the same bus, which is the SoC's I2C bus number 2\. The I2C
    core will rely on the `compatible` string property and the `i2c_device_id` table
    to bind devices and drivers. A first attempt is made to match the device by compatible
    string (the `OF` style, which is the device tree); if it fails, then the I2C core
    tries to match the device by the `id` table.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例声明了一个地址为`0x68`的RTC芯片和一个地址为`0x55`的EEPROM，它们都位于同一个总线上，即SoC的I2C总线2。I2C核心将依赖于`compatible`字符串属性和`i2c_device_id`表来绑定设备和驱动程序。第一次尝试是通过兼容字符串（即`OF`样式，即设备树）来匹配设备；如果失败，I2C核心将尝试通过`id`表来匹配设备。
- en: How not to write I2C device drivers
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何不编写I2C设备驱动程序
- en: Deciding not to write the device driver consists of writing the appropriate
    user code to deal with the underlying hardware. Though it is user code, the kernel
    always intervenes to ease the development process. I2C adapters are exposed by
    the kernel in the user space as character devices in the form of `/dev/i2c-<X>`,
    where `<X>` is the bus number. Once you have opened the character device file
    that corresponds to the adapter your device sits on, there is a series of commands
    you can execute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 决定不编写设备驱动程序的做法是编写适当的用户代码来处理底层硬件。尽管这是用户代码，但内核始终会介入以简化开发过程。I2C适配器在用户空间由内核以字符设备的形式暴露，路径为`/dev/i2c-<X>`，其中`<X>`是总线号。一旦你打开了与设备所在适配器相对应的字符设备文件，你就可以执行一系列命令。
- en: 'First, the required headers for dealing with I2C devices from the user space
    are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用于从用户空间处理 I2C 设备的所需头文件如下：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following are the possible commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能的命令：
- en: '`ioctl(file, I2C_FUNCS, unsigned long *funcs)`: This command is probably the
    first command you should issue. It is the equivalent of `i2c_check_functionality()`
    in the kernel, which returns the necessary adapter functionality (in the `*funcs`
    argument). The returned flags are also in the form of `I2C_FUNC_*`:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl(file, I2C_FUNCS, unsigned long *funcs)`：此命令可能是您应该发出的第一个命令。它相当于内核中的 `i2c_check_functionality()`，用于返回所需的适配器功能（在
    `*funcs` 参数中）。返回的标志也以 `I2C_FUNC_*` 形式表示：'
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ioctl(file, I2C_TENBIT, long select)`: Here, you can select whether the slave
    you need to talk to is a 10-bit address chip (`select = 1`) or not (`select =
    0`).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl(file, I2C_TENBIT, long select)`：在这里，您可以选择与之通信的从设备是否是 10 位地址芯片（`select
    = 1`）或不是（`select = 0`）。'
- en: '`ioctl(file, I2C_SLAVE, long addr)`: This is used to set the chip address you
    need to talk to on this adapter. The address is stored in the 7 lower bits of
    `addr` (except for 10-bit addresses, which are passed in the 10 lower bits in
    this case). This chip may already be in use, in which case you can use `I2C_SLAVE_FORCE`
    to force usage.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl(file, I2C_SLAVE, long addr)`：此命令用于设置您需要在此适配器上与之通信的芯片地址。地址存储在 `addr`
    的低 7 位中（对于 10 位地址，地址会传递在低 10 位中）。该芯片可能已在使用中，此时您可以使用 `I2C_SLAVE_FORCE` 强制使用。'
- en: '`ioctl(file, I2C_RDWR, struct i2c_rdwr_ioctl_data *msgset)`: You can use this
    to perform combined plain I2C read/write transactions without stop bit in between.
    The structure of interest is `struct i2c_rdwr_ioctl_data`, which has the following
    definition:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl(file, I2C_RDWR, struct i2c_rdwr_ioctl_data *msgset)`：您可以使用此命令执行不间断的
    I2C 读写操作。感兴趣的结构体是 `struct i2c_rdwr_ioctl_data`，其定义如下：'
- en: '[PRE30]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is an example of using this IOCTL:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此 IOCTL 的示例：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also use the `read()` and `write()` calls to make plain I2C transactions
    (once the address has been set with `I2C_SLAVE`).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `read()` 和 `write()` 调用进行简单的 I2C 事务（在使用 `I2C_SLAVE` 设置地址后）。
- en: '`ioctl(file, I2C_SMBUS, struct i2c_smbus_ioctl_data *args)`: This command is
    used to issue an SMBus transfer. The main structure argument has the following
    prototype:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl(file, I2C_SMBUS, struct i2c_smbus_ioctl_data *args)`：此命令用于发起 SMBus 传输。主要的结构体参数具有如下原型：'
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding data structure, `read_write` determines the direction of the
    transfer – `I2C_SMBUS_READ` to read and `I2C_SMBUS_WRITE` to write. `command`
    is a command that can be interpreted by the chip. It may be a register address,
    for example. `size` is the message''s length, while `buf` is the message buffer.
    Note that standardized sizes are already exposed by the I2C core. These are `I2C_SMBUS_BYTE`,
    `I2C_SMBUS_BYTE_DATA`, `I2C_SMBUS_WORD_DATA`, `I2C_SMBUS_BLOCK_DATA`, and `I2C_SMBUS_I2C_BLOCK_DATA`,
    for 1, 2, 3, 5, and 8 bytes, respectively. The full list is available at `include/uapi/linux/i2c.h`.
    The following is an example that shows how to do an SMBus transfer in the user
    space:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述数据结构中，`read_write` 决定传输方向——`I2C_SMBUS_READ` 为读取，`I2C_SMBUS_WRITE` 为写入。`command`
    是芯片可以解释的命令，例如可能是寄存器地址。`size` 是消息的长度，而 `buf` 是消息缓冲区。请注意，I2C 核心已经暴露了标准化的大小。这些大小分别是
    `I2C_SMBUS_BYTE`、`I2C_SMBUS_BYTE_DATA`、`I2C_SMBUS_WORD_DATA`、`I2C_SMBUS_BLOCK_DATA`
    和 `I2C_SMBUS_I2C_BLOCK_DATA`，用于 1、2、3、5 和 8 字节。完整列表请参见 `include/uapi/linux/i2c.h`。以下是一个示例，展示了如何在用户空间进行
    SMBus 传输：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since you can use a simple `read()`/`write()` system call to do a plain I2C
    transfer (even though a stop bit is sent after each transfer), the I2C core provides
    the following APIs to perform an SMBus transfer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您可以使用简单的 `read()`/`write()` 系统调用来执行基本的 I2C 传输（尽管每次传输后都会发送停止位），I2C 核心提供了以下
    API 来执行 SMBus 传输：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You are encouraged to use these functions instead of IOCTLs. If a failure occurs,
    all of these transactions will return `-1`; you can check `errno` for a better
    understanding of what went wrong. On success, the `*_write_*` transactions will
    return 0, while the `*_read_*` transactions will return the read value, except
    for `*_read_block_*`, which will return the number of values that have been read.
    In block-oriented operations, buffers don't need to be longer than 32 bytes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您使用这些函数，而不是使用 IOCTL。如果发生错误，所有这些事务将返回 `-1`；您可以检查 `errno` 以更好地理解出了什么问题。在成功的情况下，`*_write_*`
    事务将返回 0，而 `*_read_*` 事务将返回读取的值，除了 `*_read_block_*`，它将返回已读取的值的数量。在面向块的操作中，缓冲区不需要超过
    32 字节。
- en: 'Apart from the APIs, which would require that you write some code, you can
    use a CLI package, `i2ctools`, which is shipped with the following tools:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`i2cdetect`: A command that enumerates the I2C devices sitting on a given adapter.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2cget`: This is used to dump the content of device registers.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i2cset`: This is used to set the content of device registers.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how to use user space APIs and commands or command-line
    tools to communicate with I2C devices. While all these may be useful for prototyping,
    it could be difficult to handle devices that support interrupts or other kernel-based
    resources, such as clocks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at I2C device drivers. Now, it's time for you to
    pick any I2C device on the market and write the corresponding driver, along with
    the necessary device tree support. This chapter talked about the kernel I2C core
    and its associated API, including device tree support, to give you the necessary
    skills to talk with I2C devices. You should now be able to write efficient probe
    functions and register them with the kernel I2C core.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the skills we have learned in this chapter
    to develop an SPI device driver.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
