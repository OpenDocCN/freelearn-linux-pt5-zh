<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-214"><a id="_idTextAnchor231"/>11</h1>
<h1 id="_idParaDest-215"><a id="_idTextAnchor232"/>Working with Virtual Machines</h1>
<p>In this chapter, you will learn about <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) on Linux. For starters, you will learn how virtualization works and how to create and use VMs. You will learn about one of the most widely used virtualization and hypervisor technologies on Linux, called <strong class="bold">Kernel-based Virtual Machine</strong> (<strong class="bold">KVM</strong>). The topics in this chapter will prepare you for the future of Linux, as it is the foundation of every modern cloud technology. If you wish to remain up to date in a constantly changing landscape, this chapter will be an essential starting point for your journey.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Introduction to virtualization on Linux</li>
<li>Understanding Linux KVM</li>
<li>Working with basic KVM commands</li>
<li>Advanced KVM management</li>
<li>Provisioning VMs using cloud-init</li>
<li>Public key authentication with SSH</li>
</ul>
<h1 id="_idParaDest-216"><a id="_idTextAnchor233"/>Technical requirements</h1>
<p>No special technical requirements are needed, just a working installation of Linux on your system. We will mainly use Debian GNU/Linux 12 for our examples, but we will also show you how to install KVM in Fedora and openSUSE.</p>
<h1 id="_idParaDest-217"><a id="_idTextAnchor234"/>Introduction to virtualization on Linux</h1>
<p><strong class="bold">Virtualization</strong> <a id="_idIndexMarker1717"/>is a way to <a id="_idIndexMarker1718"/>make more efficient use of computer hardware. It is basically an abstraction layer that takes advantage of the computer’s resources. In this section, you will learn about the types of VMs, how they work on Linux, and how to deploy and manage them.</p>
<h2 id="_idParaDest-218"><a id="_idTextAnchor235"/>Efficiency in resource usage</h2>
<p>The abstraction <a id="_idIndexMarker1719"/>layer that virtualization uses is a software layer that allows more efficient use of all the computer’s components. This in turn allows better use of all the physical machine’s capabilities and resources.</p>
<p>Before going any further into<a id="_idIndexMarker1720"/> virtualization, let’s give you an example. In our testing laboratory, we have several physical machines, in the form of laptops and small form factor desktop computers (Intel NUCs) that we use as servers. Each of the systems has significant resources available, more than enough to run the services we need. For instance, our least performant systems are a 5th-generation Intel NUC with an Intel i3 CPU with four processing cores and 16 GB of RAM and a 7th-generation Intel NUC with a four-core Intel Pentium and 12 GB of RAM. Those two systems have plenty of resources that could be more efficiently used by using VMs.</p>
<p>For running a local web service or any kind of server on our local network, those resources can be split between various VMs with ease. For example, each physical system could host four different VMs, each using a single CPU core, and at least 2 GB of memory and all the necessary storage capacities. This way, one single machine will work as if there were four different ones. This is way more efficient than using individual machines for separate tasks.</p>
<p>In the following diagram, we are comparing the load on a single computer versus the same load divided between several VMs. This way of using the same hardware resources is more efficient:</p>
<div><div><img alt="Figure 11.1 – Comparison between single computer use and using multiple VMs" src="img/B19682_11_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Comparison between single computer use and using multiple VMs</p>
<p>Nonetheless, as we will use the hypervisor on top of a host OS, we will have to keep some resources for the OS’s <a id="_idIndexMarker1721"/>use, so the number of VMs will be smaller. Here is a diagram of how the VMs work on a host OS:</p>
<div><div><img alt="Figure 11.2 – How virtualization works on a host OS" src="img/B19682_11_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – How virtualization works on a host OS</p>
<p>The preceding diagram shows the scheme of how virtualization works when used on a host OS. As we will see in the following sections, it is not the only type of virtualization.</p>
<p>It is important to note that efficiency is not related <a id="_idIndexMarker1722"/>solely to the hardware resources used. A significant aspect of the efficient use of hardware in data centers is related to increased energy efficiency and a reduction of the carbon footprint. In this respect, virtualization<a id="_idIndexMarker1723"/> has played a major role for many decades in changing the usage patterns of servers inside data centers. Overall, virtualization and containerization are significant players in the fight against climate change.</p>
<p>In the following sections, we will give you a short introduction to hypervisors and VMs.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor236"/>Introduction to hypervisors</h2>
<p>The software layer <a id="_idIndexMarker1724"/>that virtualization<a id="_idIndexMarker1725"/> is based on is called a <strong class="bold">hypervisor</strong>. The physical resources are divided and used as virtual computers, better <a id="_idIndexMarker1726"/>known as VMs. By using VMs, the limits of physical hardware are overcome by the <a id="_idIndexMarker1727"/>process of <strong class="bold">emulation</strong>. This has a lot of advantages, enabling the hardware to be used more effectively.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The process of emulation is basically an imitation process through which a piece of software replicates (or imitates) the functions of another system. In our case, the hypervisor (the virtualization software layer) is simulating the use of hardware as if it were a different system altogether. This allows the hardware resources a computer has to be used more effectively.</p>
<p>Hypervisors can be used either on top of an existing OS (<em class="italic">type 2</em>) or directly on bare metal (hardware) (<em class="italic">type 1</em>). For each of these types, there are various solutions that can be used, particularly on Linux. For a Linux OS, examples of each type are as follows:</p>
<ul>
<li>Examples of hypervisors that run on top of a host OS (type 2) are Oracle VirtualBox and VMware Workstation/Fusion</li>
<li>Examples of hypervisors that run directly on bare metal (type 1) are Citrix Xen Server and VMware ESXi</li>
<li>KVM is mostly classified <a id="_idIndexMarker1728"/>as a bare-metal hypervisor (type 1), while its underlying system is a full OS, thus it is classified as a host <a id="_idIndexMarker1729"/>hypervisor<a id="_idIndexMarker1730"/> at the same time (type 2)</li>
</ul>
<p>In this chapter, we will exclusively use KVM as the hypervisor of choice.</p>
<h1 id="_idParaDest-220"><a id="_idTextAnchor237"/>Understanding Linux KVMs</h1>
<p>A VM is similar to a standalone computer. It is a software-based emulator that has access to the host computer’s resources. It uses the host’s CPU, RAM, storage, networking interface(s), and ports. Not only that, but it is a virtual environment that has<a id="_idIndexMarker1731"/> the same functions as a physical computer; it is also seen as a virtual computer.</p>
<p>The resources for each VM are managed by the hypervisor. It can relocate resources between existing VMs or create new VMs. The VMs are isolated from each other and from the host computer. As multiple VMs can exist on a single computer, each VM can use different guest OSes. For example, if you use a Windows machine and want to try out Linux, a popular solution would be to create a VM with the Linux distribution that you want to try. The same goes for Mac users, too. An OS installed inside a VM runs similarly to an OS installed on bare metal. The user experience could vary from one hypervisor to the other, and so could the resource efficiency and response times. From our experience, we prefer running VMs from KVM rather than running from any other hypervisor, mainly because<a id="_idIndexMarker1732"/> of the comprehensive <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>). However, use cases could be different from one user to another.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor238"/>Choosing the hypervisor</h2>
<p>In this chapter, we<a id="_idIndexMarker1733"/> chose the KVM hypervisor. As an optional solution, if you use the GNOME desktop environment, you will have access to GNOME Boxes. As both KVM and GNOME Boxes are directly available from Linux repositories, we consider them to be the better solutions for newcomers to Linux. Both KVM and GNOME Boxes share parts of <code>libvirt</code> and <code>qemu</code> code (to be detailed in the next section), and in this respect, we consider them to both be the same hypervisor, which is KVM.</p>
<p>In <a href="B19682_01.xhtml#_idTextAnchor030"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing Linux</em>, you first encountered the use of a hypervisor to set up a Linux VM. We showed you how to use VMware solutions and VirtualBox to set up a Linux VM. The details used then should be sufficient for any user, whether they are experienced or a newbie. VirtualBox has several features that make it a fair candidate for your<a id="_idIndexMarker1734"/> hypervisor solution, but in our opinion, it still lacks the finesse of KVM. In the next section, we will walk you through KVM.</p>
<h2 id="_idParaDest-222"><a id="_idTextAnchor239"/>Using the KVM hypervisor</h2>
<p>The KVM <a id="_idIndexMarker1735"/>hypervisor is an open source virtualization project available on all major Linux distributions. It is a modern hypervisor that uses specific kernel modules to take <a id="_idIndexMarker1736"/>advantage of all the benefits that the Linux kernel has to offer, including memory support, scheduler, nested virtualization, GPU pass-through, and so on.</p>
<h3>KVM in detail – QEMU and libvirt</h3>
<p>KVM uses <code>libvirt</code>. The KVM’s interface with <code>libvirt</code>, specifically in GNOME, is <code>virt-manager</code>. The CLI <a id="_idIndexMarker1740"/>for <code>libvirt</code> is called <code>virsh</code>.</p>
<p>The <code>libvirt</code> API provides a <a id="_idIndexMarker1741"/>common library for managing VMs. It is the management layer for VM creation, modification, and provision. It is running in the <a id="_idIndexMarker1742"/>background as a daemon <a id="_idIndexMarker1743"/>called <code>libvirtd</code> that manages <a id="_idIndexMarker1744"/>the connections with the hypervisor at the client’s request.</p>
<p>QEMU is both an emulator and a virtualizer. When used as an emulator, QEMU <a id="_idIndexMarker1745"/>uses <strong class="bold">dynamic binary translation</strong> methods to operate. This means that it can use different types of OS on the host machine, even if they are designed for different architectures. Dynamic binary translations are used in <strong class="bold">software-based virtualization</strong>, where hardware<a id="_idIndexMarker1746"/> is emulated to execute instructions in virtualized environments. This way, QEMU emulates the machine’s CPU, using a specific binary translator <a id="_idIndexMarker1747"/>method called <strong class="bold">Tiny Code Generator</strong> (<strong class="bold">TCG</strong>), which transforms the binary code for different types of architectures.</p>
<p>When used as a virtualizer, QEMU uses what is known as a <strong class="bold">hardware-based virtualization</strong>, where the binary<a id="_idIndexMarker1748"/> translation is not used, because the instructions are executed directly on the host CPU. The<a id="_idIndexMarker1749"/> differences between software- and<a id="_idIndexMarker1750"/> hardware-assisted virtualization are shown in<a id="_idIndexMarker1751"/> the following diagram:</p>
<div><div><img alt="Figure 11.3 – Comparison between software- and hardware-assisted virtualization" src="img/B19682_11_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Comparison between software- and hardware-assisted virtualization</p>
<p>As you can see in the diagram, instructions have different paths when using software- and <a id="_idIndexMarker1752"/>hardware-assisted virtualization. In software-assisted virtualization, when dynamic binary translations are used, the user’s unprivileged instructions <a id="_idIndexMarker1753"/>are sent directly to the hardware, while the guest OS privileged instructions are first sent to the hypervisor before getting to the hardware. In hardware-assisted virtualization, the user’s unprivileged instructions are sent to the hypervisor first, and then sent to the hardware, while the privileged instructions from the guest OS have the same path as in software-assisted virtualization. This ensures a certain level of isolation for the guest OS, thereby achieving better performance and less complexity.</p>
<p>In the following section, we will show you how to install and configure QEMU on a Debian 12 machine. We consider Debian to be a sufficiently lightweight distribution, offering the necessary stability for a virtualization host OS. Some commands can be replicated on Ubuntu as well.</p>
<h3>Installing the hypervisor on major Linux distributions</h3>
<p>Installing QEMU is a straightforward task. All you need to do is to run the package installer utility of your distribution, with some specified<a id="_idIndexMarker1754"/> package names. In our case, we will show you how to install it on major Linux distributions such as Debian/Ubuntu, Fedora, and openSUSE:</p>
<ul>
<li><strong class="bold">Installing on </strong><strong class="bold">Debian/Ubuntu Linux</strong><p class="list-inset">Run the following command:</p><pre class="source-code">
<strong class="bold">sudo apt install qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils virtinst libvirt-daemon virt-manager</strong></pre></li> <li><strong class="bold">Installing on </strong><strong class="bold">Fedora Linux</strong><p class="list-inset">Run the following command:</p><pre class="source-code">
<strong class="bold">sudo dnf group install --with-optional virtualization</strong></pre></li> <li><strong class="bold">Installing on </strong><strong class="bold">openSUSE Linux</strong><p class="list-inset">Run the following commands:</p><pre class="source-code">
<strong class="bold">sudo zypper install -t pattern kvm_server kvm_tools</strong>
<strong class="bold">sudo zypper install libvirt-daemon</strong></pre></li> </ul>
<p>Once all the necessary packages are installed, you can enable and start the <code>libvirtd</code> daemon with the following commands (valid for all Linux distributions showcased in this section):</p>
<pre class="console">
sudo systemctl start libvirtd
sudo systemctl enable libvirtd</pre> <p>Once the packages are installed and the daemon is started and enabled, a safe action to take is to check whether your machine is compatible with KVM requirements. To do this, use the <code>virt-host-validate</code> command as a root user or by using <code>sudo</code>. We are running the command on a Debian GNU/Linux 12 host, but it can be used on other Linux distributions as well:</p>
<pre class="console">
sudo virt-host-validate</pre> <p>Once the command is running, you may receive a couple of errors or warnings regarding QEMU or <strong class="bold">Linux Containers</strong> (<strong class="bold">LXC</strong>) – which is a technology <a id="_idIndexMarker1755"/>used to run isolated <a id="_idIndexMarker1756"/>systems, similar to how KVM works – depending on your system (there’s more on LXC in <a href="B19682_12.xhtml#_idTextAnchor257"><em class="italic">Chapter 12</em></a>). In our case, the output shows one error regarding LXC compatibility, as shown in the following screenshot:</p>
<div><div><img alt="Figure 11.4 – Running the host validation program" src="img/B19682_11_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Running the host validation program</p>
<p>However, this error will not limit our use of <code>libvirt</code> and QEMU, so we do not intend to resolve it here.</p>
<p>After seeing that there are <a id="_idIndexMarker1757"/>no compatibility issues regarding QEMU, we can proceed to creating our first VM using the CLI. Thus, we will start using KVM-specific commands.</p>
<h1 id="_idParaDest-223"><a id="_idTextAnchor240"/>Working with basic KVM commands</h1>
<p>One of the first commands that you will use when working with KVM is the one used for creating a VM. Other commands, as <a id="_idIndexMarker1758"/>shown in the following sections, are the ones used to start, stop, delete, or pause an already existing VM.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor241"/>Creating a VM using the command line</h2>
<p>Before creating<a id="_idIndexMarker1759"/> our first VM using <code>libvirt</code>, we must check and see whether our default bridge network configuration was created. We can verify this by using the following command:</p>
<pre class="console">
sudo virsh net-list</pre> <p>This command shows if the default bridge configuration was created and if it is running. In our case, the bridge connection is not running, thus we will need to set it up ourselves. The command used to start the default bridge network is as follows:</p>
<pre class="console">
sudo virsh net-start default</pre> <p>Once it has been started, the network bridge is not set up for automatic start, thus we will use the following command to set it for automatic start:</p>
<pre class="console">
sudo virsh net-autostart default</pre> <p>Now, the output is as follows:</p>
<div><div><img alt="Figure 11.5 – Enabling the default bridge connection" src="img/B19682_11_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Enabling the default bridge connection</p>
<p>Now that the default bridge connection has been enabled and set for <code>autostart</code>, we can create our first VM. In order to create a VM, follow <a id="_idIndexMarker1760"/>these steps:</p>
<ol>
<li>First, we will need to download the image file of the OS to use inside the VM. For our example, we will create a new VM with Ubuntu 22.04.2 LTS server edition. We can download the ISO image with the following command:<pre class="source-code">
<code>/var/lib/libvirt/images</code>.</li>
<li>Once the Ubuntu image is downloaded, we will use the <code>virt-install</code> command to create the first VM on our<a id="_idIndexMarker1761"/> host system. We will create one VM that will use a single <code>virt-install</code> command used is the following (run as root):</p><pre class="source-code">
<code>--virt-type</code>: Type of the new VM</li><li><code>--name</code>: The name of the new VM</li><li><code>--memory</code>: The amount of RAM used by the VM</li><li><code>--vcpus</code>: The number of virtual CPUs used by the new VM</li><li><code>--disk size</code>: The amount of storage used</li><li><code>--os-variant</code>: The type of guest OS</li><li><code>--network</code>: The bridge network used</li><li><code>--cdrom</code>: The location of the guest OS ISO file</li></ul><p class="list-inset">The command will start a new <code>virt-viewer</code> window, which will start the OS installation process. Similarly, by using the command with the <code>–graphics=vnc</code> argument, <code>virt-install</code> will start <code>virt-viewer</code>, which is the default tool for displaying the graphical console using the VNC protocol.</p></li> </ol>
<p>Simply knowing how to<a id="_idIndexMarker1762"/> create a VM is not sufficient for a system administrator. This is why, in the next section, we will show you some basic VM management tools to use.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor242"/>Basic VM management</h2>
<p>The basic VM tasks can be done using the <code>virsh</code> command when using the CLI, or Virtual<a id="_idIndexMarker1763"/> Machine Manager when using a graphical user interface. In the following, we will show you the basic commands to use while inside a CLI.</p>
<p>To list the existing VM guests, use the <code>virsh </code><code>list</code> command:</p>
<pre class="console">
sudo virsh list</pre> <p>Be aware that listing the VMs cannot <a id="_idIndexMarker1764"/>be done by just anyone. This is why the following note needs to be considered.</p>
<p class="callout-heading">Important note</p>
<p class="callout">When trying to list the existing guest VMs, you will not get a valid output when using a regular user. You will need to be logged in as <code>root</code> or use <code>sudo</code> to see the list of VMs.</p>
<p>The following screenshot shows some basic commands used to manage VMs, together with their output:</p>
<div><div><img alt="Figure 11.6 – Commands for VM management" src="img/B19682_11_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Commands for VM management</p>
<p>Here is a short explanation of the <a id="_idIndexMarker1765"/>commands you see in the preceding figure. To change the state of a VM, such as starting, stopping, and pausing, use the following commands:</p>
<ul>
<li><code>sudo virsh </code><code>destroy ubuntu-vm1</code></li>
<li><code>sudo virsh </code><code>reboot ubuntu-vm1</code></li>
<li><code>sudo virsh </code><code>suspend ubuntu-vm1</code></li>
<li><code>sudo virsh </code><code>start ubuntu-vm1</code></li>
<li><code>sudo virsh </code><code>resume ubuntu-vm1</code></li>
<li><code>sudo virsh </code><code>undefine ubuntu-vm1</code></li>
</ul>
<p>For all the options available for <code>virsh</code>, please refer to the manual pages using the following command:</p>
<pre class="console">
man virsh</pre> <p>The command-line tools for managing VMs are powerful and offer various options. If we consider the<a id="_idIndexMarker1766"/> fact that, most of the time, a system administrator will be using the CLI rather than the GUI, the ability to use command-line tools is of the utmost importance.</p>
<p>In the following section, we will show you some advanced KVM management practices.</p>
<h1 id="_idParaDest-226"><a id="_idTextAnchor243"/>Advanced KVM management</h1>
<p>Using KVM is so much more than just creating VMs and starting or stopping them. VM management can be much more complex, starting with VM automated installation, storage and resources management, and up to <a id="_idIndexMarker1767"/>VM orchestration. Some of these topics are out of the scope of this book, but we will still show you how to master your VMs on your Linux-powered systems.</p>
<p>By now, we only have one VM. For the purpose of the exercises in this section, we will create two more VMs, all running the same Ubuntu OS that we used for the first VM. We will create <code>ubuntu-vm2</code> and <code>ubuntu-vm3</code> VMs using the following commands:</p>
<ul>
<li>For <code>ubuntu-vm2</code>:<pre class="source-code">
<code>ubuntu-vm3</code>:<pre class="source-code">
<strong class="bold">sudo virt-install --virt-type=kvm --name ubuntu-vm3 --vcpus=2 --memory=2048 --os-variant=ubuntufocal --cdrom=/var/lib/libvirt/images/ubuntu-22.04.2-live-server-amd64.iso --network=default --disk size=20 --noautoconsole</strong></pre></li> </ul>
<p>Now, we have three VMs running <a id="_idIndexMarker1768"/>on our system and we can begin managing them. In the next section, we will show you how to find out the IP of a VM and how to connect to it.</p>
<h2 id="_idParaDest-227"><a id="_idTextAnchor244"/>Connecting to a VM</h2>
<p>Most of the time, we would like to connect to<a id="_idIndexMarker1769"/> a running VM from a terminal and not use the integrated console provided by the VM manager. In order to be able to do this, we will need to know the VM’s IP address. A simple run of the <code>ip neighbor</code> command will show us all the IP addresses on our local network, but this will not provide the relevant information we need, such as the VM’s name.</p>
<p>On our system, when running the <code>ip neighbor</code> command, the output is as follows:</p>
<div><div><img alt="Figure 11.7 – Viewing the IP addresses on the local network" src="img/B19682_11_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Viewing the IP addresses on the local network</p>
<p>From the output, we can see that three of the IP addresses are from the default virtual network that is set up by KVM (<code>virbr0</code>). This is the first information that tells us the IP addresses used by our VMs. But which IP is which VM? To find out more information, we will use the following commands:</p>
<pre class="console">
sudo virsh list --all</pre> <p>The preceding command is used to list all the existing VMs. The output (as seen in <em class="italic">Figure 11</em><em class="italic">.8</em>) shows the names of the VMs. In order to see the IP addresses associated with each one, we will use the<a id="_idIndexMarker1770"/> following command:</p>
<pre class="console">
sudo virsh domifaddr [vm name]</pre> <p>The <code>[vm name]</code> represents one of the VM names from the <code>virsh list</code> command’s output. In the following screenshot, you can see the output of the previous commands:</p>
<div><div><img alt="Figure 11.8 – Showing the IP addresses for VMs" src="img/B19682_11_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Showing the IP addresses for VMs</p>
<p>Now that we know the IP addresses of every VM we created, we can connect to any of the VMs using SSH (more on installing and configuring SSH in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>). Considering that we already have openSSH installed on both our host system and the target VM, the simplest way to connect using SSH is as follows:</p>
<pre class="console">
ssh packt@192.168.122.129</pre> <p>In the previous command, we used the <code>ssh</code> command, we specified the user (in our case <code>packt</code>) and the IP address of the VM (in our case, <code>192.168.122.129</code>, which is <code>ubuntu-vm1</code> that we created earlier). The prompt (as shown in the following figure) asks you for confirmation, saves the key to the list of known hosts, and then connects you to the machine:</p>
<p class="IMG---Figure"><img alt="Figure 11.9 – Connect to a VM through SSH" src="img/B19682_11_9.png"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Connect to a VM through SSH</p>
<p>Another way to connect to a <a id="_idIndexMarker1771"/>VM is by using the <code>virt-viewer</code> command:</p>
<pre class="console">
virt-viewer --connect qemu:///system ubuntu-vm1</pre> <p>This command will open a new console window using the <code>virt-viewer</code> utility and connect to the VM you specify (in our case, <code>ubuntu-vm1</code> again) without using the SSH protocol:</p>
<div><div><img alt="Figure 11.10 – Connecting to VM using virt-viewer" src="img/B19682_11_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Connecting to VM using virt-viewer</p>
<p class="callout-heading">Important note</p>
<p class="callout">The connection remains active inside the terminal where you initiated the command. Thus, if you press <em class="italic">Ctrl</em> + <em class="italic">C</em>, the connection will be terminated and the new console window will close. Take into consideration that only the connection will be terminated and the VM will still be running.</p>
<p>We have shown you how to use the command line to create VMs, for basic management, and to connect to a virtual machine. However, you can also use GUI tools. All modern Linux distributions <a id="_idIndexMarker1772"/>that use GNOME as the desktop environment will offer at least two useful tools: the Virtual Machine Manager and GNOME Boxes. The former is simply the GUI for <code>libvirt</code>, and the latter is a <a id="_idIndexMarker1773"/>new and simple way to provision VMs for immediate use inside GNOME based on QEMU/KVM technology. We will let you discover these GUI tools as they are pretty straightforward and not difficult to use. You could start creating new VMs using the Virtual Machine Manager. In the next section, we will show you how to clone VMs.</p>
<h2 id="_idParaDest-228"><a id="_idTextAnchor245"/>Cloning VMs</h2>
<p>We have already created three different VMs on our host system. However, there are times when you might want to clone an existing VM instead of creating a new one.</p>
<p>Before starting to clone a VM, we need to stop or suspend it. We will do this using the <code>suspend</code> or the <code>shutdown</code> commands. We<a id="_idIndexMarker1774"/> will stop one of our VMs, as shown:</p>
<pre class="console">
sudo virsh shutdown ubuntu-vm1</pre> <p>This command will shut down the <code>ubuntu-vm1</code> VM. In order to clone it, we will use the <code>virt-clone</code> command. Let’s say that we want to name the clone <code>ubuntu-vm1-clone1</code>. We will use the following command:</p>
<pre class="console">
sudo virt-clone --original ubuntu-vm1 --name ubuntu-vm1-clone1 --auto-clone</pre> <p>The output of the command is shown in the following screenshot:</p>
<div><div><img alt="Figure 11.11 – Cloning virtual machines using virt-clone" src="img/B19682_11_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Cloning virtual machines using virt-clone</p>
<p>Now that the clone has been created, we can start it using the <code>virsh start</code> command. Cloning a VM will also <em class="italic">transfer</em> all the original VM’s configuration regarding the number of vCPUs, RAM, bridge networking configuration, the same MAC address, and even the same IP address. This can become a real headache and needs to be solved.</p>
<p>One way to solve this is to directly <a id="_idIndexMarker1775"/>connect to the VM’s console (not through SSH) and run the <code>ip addr show</code> command. This will enable the DHCP client to automatically assign an IP address to the host. In the next section, we will show you another useful way to manage cloning with VM templates.</p>
<h2 id="_idParaDest-229"><a id="_idTextAnchor246"/>Creating VM templates</h2>
<p>Another useful way to overcome<a id="_idIndexMarker1776"/> the issue described in the previous section is to first create a VM template before cloning. By creating a template, you make sure that all the configuration files will not persist, including MAC and IP configuration, user settings, or SSH host keys.</p>
<p>To create a template, follow these steps:</p>
<ol>
<li>We will use the <code>virt-sysprep</code> utility. In Debian 12, we will install the <code>libguestfs-tools</code> utility, which contains the <code>virt-sysprep</code>, using the following command:<pre class="source-code">
<strong class="bold">sudo apt install libguestfs-tools</strong></pre></li> <li>Now that the utility is installed, we will use it to create a template. But first, we will create a new VM running Ubuntu and use it as a template. We will use the following command to create the new VM:<pre class="source-code">
<strong class="bold">sudo virt-install --virt-type=kvm --name ubuntu-template --vcpus=2 --memory=2048 --os-variant=ubuntufocal --cdrom=/var/lib/libvirt/images/ubuntu-22.04.2-live-server-amd64.iso --network=default --disk size=20 –noautoconsole</strong></pre></li> <li>After finishing the OS installation, make sure that it is up to date with all the available packages.</li>
<li>Proceed only after<a id="_idIndexMarker1777"/> ensuring that the VM is turned off. As a precautionary method, you could first copy the file with a different name:<pre class="source-code">
<code>virt-sysprep</code> utility:<pre class="source-code">
<code>virt-sysprep</code> command is preparing the VM by resetting all the configuration files that might have been created. The following is an excerpt from the output:</p></li> </ol>
<div><div><img alt="Figure 11.12 – Creating a template with virt-sysprep" src="img/B19682_11_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Creating a template with virt-sysprep</p>
<ol>
<li value="6">Now that the template is prepared, you can do either of the following:<ul><li>Undefine the domain by using the <code>virsh undefine</code> command. This command removes the<a id="_idIndexMarker1778"/> configuration of the VM but leaves the <code>qcow2</code> file that it created so that you could use it when creating a new VM.</li><li>Keep the VM (in our case, the one named <code>ubuntu-template</code>) and use it as a clone template, as intended.</li></ul><p class="list-inset">The choice is yours, but we are inclined towards the second option, as it is already configured and thus is much easier to use. When using only the <code>qcow2 </code>file, you still have to configure (setting CPUs, RAM, networking, etc.) the VM prior to using it.</p></li>
</ol>
<p>Now that you know how to clone a VM and how to create templates, let’s see other ways to manage VMs. In the next section, we will show you how to obtain information about the VMs you work with, from the command line.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor247"/>Obtaining VM and host resource information</h2>
<p>When you’re working at the command line, some<a id="_idIndexMarker1779"/> information is not as visible as<a id="_idIndexMarker1780"/> when working with the GUI tools. To see if we still have the necessary sources for creating new VMs, we will need to use the <code>virsh nodeinfo</code> command to obtain information about the host machine:</p>
<div><div><img alt="Figure 11.13 – Finding host information with the nodeinfo command" src="img/B19682_11_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Finding host information with the nodeinfo command</p>
<p>In our case, as seen in the preceding image, the host has 16 vCPUs available and 48 GB of RAM, meaning that we still have <a id="_idIndexMarker1781"/>resources available for some new VMs. We know that when we created the VMs<a id="_idIndexMarker1782"/> we allocated 2 vCPUs and 2 GB of RAM for each one. As we now have five VMs (as shown in the following image), it means that we use 10 out of 16 vCPUs and 10 GB out of 48 GB RAM:</p>
<div><div><img alt="Figure 11.14 – Listing the existing VMs" src="img/B19682_11_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Listing the existing VMs</p>
<p>But what if we do not know how many resources the existing VMs use? There is a command that can help us with that. It is called <code>virsh dominfo</code>. Let’s see the resources that one of our VMs is using, for example, <code>ubuntu-vm1</code>:</p>
<div><div><img alt="Figure 11.15 – Showing the VMs’ resource usage" src="img/B19682_11_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Showing the VMs’ resource usage</p>
<p>In the preceding image, you can see that our VM is using 2 vCPUs and 2 GB of RAM. You can check the resource usage for<a id="_idIndexMarker1783"/> every VM that you manage. Besides vCPUs and RAM, you can also manage virtual disks for <a id="_idIndexMarker1784"/>existing VMs. To see the disk usage for a VM you can use the <code>virt-df</code> command:</p>
<div><div><img alt="Figure 11.16 – Showing disk usage for a VM" src="img/B19682_11_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Showing disk usage for a VM</p>
<p>We have used the <code>-d</code> option for showing <code>libvirt</code> domain guests and the <code>-h</code> option to show the results in a human-readable format. The <code>virt-df</code> command is similar to the <code>df</code> command (see <a href="B19682_06.xhtml#_idTextAnchor124"><em class="italic">Chapter 6</em></a>).</p>
<p>Knowing the resource usage is the first step in managing the resources that you have. In the following section, we will show you how to change the amount of resources a VM is using.</p>
<h2 id="_idParaDest-231"><a id="_idTextAnchor248"/>Managing VM resource usage</h2>
<p>As shown earlier, knowing<a id="_idIndexMarker1785"/> how many resources a VM is using can prove of great value. You would need to be able to modify the resources already in use if you run out of resources. You have tools available to modify the amount of vCPUs and RAM an existing VM is using. For example, let’s change the resources for our <code>ubuntu-vm1-clone1</code> VM from 2 vCPUs to 1 vCPU and from 2 GB of RAM to 1 GB of RAM. The command we will use is <code>virsh setvcpus</code>, and we will use it as follows:</p>
<div><div><img alt="Figure 11.17 – Changing the vCPU count for a VM" src="img/B19682_11_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Changing the vCPU count for a VM</p>
<p>We can also change the amount of RAM used with the <code>virsh setmem</code> and <code>virsh </code><code>setmaxmem</code> commands:</p>
<div><div><img alt="Figure 11.18 – Changing the memory used by a VM" src="img/B19682_11_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Changing the memory used by a VM</p>
<p>We can now check the resources<a id="_idIndexMarker1786"/> used by the <code>ubuntu-vm1-clone1</code> VM using the <code>virsh dominfo</code> command, as shown in the following screenshot:</p>
<div><div><img alt="Figure 11.19 – Checking the resources for a VM" src="img/B19682_11_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – Checking the resources for a VM</p>
<p>As you can see, the resources used by the VM have been changed according to your new settings. Now that you know how to manage KVMs, which is a required asset for a Linux system administrator. In the next section, we will show you how to automate KVM VM provisioning using <strong class="bold">cloud-init</strong>.</p>
<h1 id="_idParaDest-232"><a id="_idTextAnchor249"/>Provisioning VMs using cloud-init</h1>
<p>When you’re dealing with only one VM, things can be relatively simple. But when we have to create hundreds of VMs, manual creation can be daunting. One useful tool you can use for such a task is <strong class="bold">cloud-init</strong>. Another tool that is suitable for this kind of task is <strong class="bold">Ansible</strong> (there’s more on Ansible in <a href="B19682_17.xhtml#_idTextAnchor359"><em class="italic">Chapter 17</em></a>). In this section, we will cover only cloud-init. It was developed<a id="_idIndexMarker1787"/> by Canonical to be used as a tool for configuring VM instances on cloud platforms, and it is written in Python. Currently, it is considered an industry standard for provisioning cloud images. In the next subsection, we will briefly explain to you how cloud-init works.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor250"/>Understanding how cloud-init works</h2>
<p>According to the official cloud-init documentation, it is based on several configuration sources, specific boot stages, user data formats, vendor data, and instance<a id="_idIndexMarker1788"/> metadata. The concept of boot stages is specific to cloud-init architecture, as it configures the entire instance during specific stages of the boot process. It provides a way for managing completely working instances that have networking, boot sequence, and local configuration files configured.</p>
<p>Cloud-init is available on most widely used Linux distributions, such as Ubuntu, Debian, Red Hat Enterprise Linux, Fedora, SUSE, and openSUSE. We will use one of our Debian 12 systems as a host and install and configure cloud-init on it. We will show you how in the following subsection.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor251"/>Installing and configuring cloud-init</h2>
<p>Even if its main purpose is to be used for cloud deployments, cloud-init can also be used locally. We will use it to deploy VMs on our local system. As a prerequisite for using cloud-init, a hypervisor should already <a id="_idIndexMarker1789"/>be installed on your system, such as KVM. For the guest image, cloud-init uses specific cloud images that are already available from almost <a id="_idIndexMarker1790"/>every Linux distribution provider. For example, we are planning on deploying Ubuntu VMs, thus we will need Ubuntu-optimized cloud images, which are available at <a href="https://cloud-images.ubuntu.com/">https://cloud-images.ubuntu.com/</a>. Let’s look at the steps required to prepare the image for deployment:</p>
<ol>
<li>First, we will install the <code>cloud-image-utils</code> additional package and then the <code>cloud-init</code> package:<pre class="source-code">
<strong class="bold">sudo apt install cloud-image-utils cloud-init</strong></pre></li> <li>The next step is to create a new directory for the new cloud images:<pre class="source-code">
<strong class="bold">mkdir local-cloud-images &amp;&amp; cd local-cloud-images</strong></pre></li> <li>The next step is to download<a id="_idIndexMarker1791"/> the cloud image:<pre class="source-code">
<strong class="bold">wget https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img</strong></pre></li> <li>Then we get details for the<a id="_idIndexMarker1792"/> cloud image file:<pre class="source-code">
<strong class="bold">qemu-img info jammy-server-cloudimg-amd64.img</strong></pre></li> <li>Then we resize the image:<pre class="source-code">
<code>.qcow2</code> base image:<pre class="source-code">
<code>libvirt</code> directory:<pre class="source-code">
<code>meta-data</code>) and another file for user data (called <code>user-data</code>). They are <code>/var/lib/libvirt/image/</code>) to store the new configuration files. We will use the following commands as root:<pre class="source-code">
<code>meta-data</code> file will not be populated just yet. We will edit the <code>user-data</code> file first.</li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">At this point, we will need a pair of SSH keys to use to connect with the new VM we plan to create. As we have not shown you yet how to work with SSH keys, we will provide you with the needed information in the next subsection. Go ahead and read the <em class="italic">Public key authentication with SSH</em> section, then get back to this point, where we will continue configuring our cloud-init files.</p>
<p class="list-inset">Let’s create the <code>user-data</code> file and <a id="_idIndexMarker1794"/>add the following<a id="_idIndexMarker1795"/> information:</p>
<div><div><img alt="Figure 11.20 – The user-data file contents" src="img/B19682_11_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – The user-data file contents</p>
<ol>
<li value="10">After the <code>user-data</code> file editing is finished, we can continue and create a disk image that will contain the configuration files. We will use the <code>cloud-localds</code> command from the <code>cloud-image-utils</code> package we installed earlier:<pre class="source-code">
<code>user-data</code> file we created. The<a id="_idIndexMarker1797"/> preparations are finished and we can start deploying. We will deploy our VM using the following command:<pre class="source-code">
<strong class="bold">sudo virt-install --name vm01 --virt-type kvm --vcpus 1 --memory 2048 --disk path=/var/lib/libvirt/images/ubuntu.qcow2,device=disk --disk path=/var/lib/libvirt/images/cloud-init/ubuntu-provisioning.qcow2,device=cdrom --os-type linux --os-variant generic --import --network network=default --noautoconsole</strong></pre></li> <li>If you get any errors regarding the network activation, you might have to use the following commands to activate the default network:<pre class="source-code">
<code>virt-install</code> command, the output will be as shown as follows:</li>
</ol>
<div><div><img alt="Figure 11.21 – Creating a new VM" src="img/B19682_11_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – Creating a new VM</p>
<ol>
<li value="14">We now have deployed a new VM using cloud-init. We can verify that it is running by using the <code>sudo virsh list</code> command or by using the Virtual Manager GUI. We will verify if the VM is running, we will find out the IP address and connect to it using SSH. We will use the<a id="_idIndexMarker1798"/> following commands: <code>sudo virsh list</code> to check the <a id="_idIndexMarker1799"/>state of the VM, <code>sudo virsh domifaddr vm01</code> to find its IP, and <code>ssh packt@192.168.122.32</code> to connect to it. The output is shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 11.22 – Connecting to the new VM using SSH" src="img/B19682_11_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – Connecting to the new VM using SSH</p>
<p>We have successfully created and connected to a new VM using cloud-init. After finishing this section, you now possess the ability to deploy VMs using cloud-init. However, we have only scratched the surface of what cloud-init can do, so if you feel like you would like to learn more about it, please use the official documentation or any of the titles provided in the <em class="italic">Further reading</em> section at the end of the chapter.</p>
<p>In the next section, we will show you how to use public key authentication with SSH.</p>
<h1 id="_idParaDest-235"><a id="_idTextAnchor252"/>Public key authentication with SSH</h1>
<p><code>.ssh</code> directory in your user’s home directory. To generate a new pair of keys, you will have to use the <code>ssh-keygen</code> command.</p>
<p>It can be used with options, the most relevant ones being: <code>-t</code> to specify the type of encryption algorithm used, <code>-b</code> to specify the number of bits. Used with no option, the <code>ssh-keygen</code> command will use the RSA encryption algorithm and a 3,072-bit key. The following is the output for using the command as is:</p>
<div><div><img alt="Figure 11.23 – Using the ssh-keygen to create a pair of SSH keys" src="img/B19682_11_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – Using the ssh-keygen to create a pair of SSH keys</p>
<p>As mentioned earlier, the two keys are stored inside the <code>.ssh</code> directory. One will be called <code>id_rsa</code> and the other <code>id_rsa.pub</code>. For our use case, configuring cloud-init, we will need to use the public key. Thus, we will need to concatenate the contents of the <code>id_rsa.pub</code> file and copy the key. In our case, the contents are as follows:</p>
<div><div><img alt="Figure 11.24 – The SSH public key" src="img/B19682_11_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – The SSH public key</p>
<p>However, if we need to use those keys to connect to a cloud instance of a virtual private server or a VM, the public key needs to be safely copied to that machine or instance. For this, we will use the <code>ssh-copy-id</code> command. When using the command, we will need to provide a username and an IP address or hostname for the destination machine. For example, if we were to<a id="_idIndexMarker1802"/> copy the SSH public key to a VM that has the IP <code>192.168.122.48</code> and a user <code>packt</code>, we would use the following command:</p>
<pre class="console">
ssh-copy-id packt@192.168.122.48</pre> <p>More details on how to install <a id="_idIndexMarker1803"/>and configure an SSH server will be provided in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>. The information shown here is sufficient for our cloud-init task.</p>
<p>Virtualization is an <a id="_idIndexMarker1804"/>important part of computing, providing the technology needed to take advantage of the tremendous computing power that modern systems provide. It gives you the ability to get the most out of your investment in hardware technology.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor253"/>Summary</h1>
<p>In this chapter, we emphasized the importance of virtualization on a Linux system. We showed you how to create and manage VMs using KVM. You know how to clone, template, and manage resources for VMs; and you know how virtualization works and how to install the QEMU/KVM hypervisor on Linux. With those assets, you are prepared to start your path into virtualization with no fears.</p>
<p>In the next chapter, we will introduce you to Docker container technologies.</p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor254"/>Exercises</h1>
<p>Here’s a brief quiz about some of the essential concepts that were covered in this chapter:</p>
<ol>
<li>Enumerate and describe the types of hypervisors.</li>
<li>Practice by installing a hypervisor on many Linux hosts.</li>
<li>Verify whether your hypervisor is working correctly.<p class="list-inset"><code>virt-host-validate</code>.</p></li>
<li>Can you think of significant differences between major hypervisors?<p class="list-inset"><strong class="bold">Hint</strong>: Test KVM and VirtualBox for example, and make a comparison.</p></li>
<li>How can you find the IP addresses of VMs?<p class="list-inset"><code>virsh </code><code>domifaddr</code> command.</p></li>
</ol>
<h1 id="_idParaDest-238"><a id="_idTextAnchor255"/>Further reading</h1>
<p>For more information on the topics covered in this chapter, you can refer to the following Packt books:</p>
<ul>
<li><em class="italic">Mastering KVM Virtualization – Second Edition</em>, Vedran D<a id="_idTextAnchor256"/>akic, Humble Devassy Chirammal, Prasad Mukhedkar, Anil Vettathu</li>
<li><em class="italic">KVM Virtualization Cookbook</em>, Konstantin Ivanov</li>
</ul>
<p>For detailed information about the inner workings of cloud-init, visit the official documentation website at <a href="https://cloudinit.readthedocs.io/en/latest/explanation/index.html">https://cloudinit.readthedocs.io/en/latest/explanation/index.html</a>.</p>
</div>
</body></html>