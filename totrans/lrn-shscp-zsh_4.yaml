- en: Chapter 4. Globbing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Globbing
- en: 'In this chapter, we will get to know one of the most powerful features of zsh:
    filename generation. We will learn new ways of dealing with the system''s files
    and directories and even expand the functionalities of some of the more traditional
    commands by applying parameter substitution and modifiers. The chapter also serves
    as an introduction to zmv, a built-in function that provides a number of useful
    functionalities to deal with both the mundane and the more complex tasks regarding
    files. We will learn to use zmv for renaming, copying, and linking files based
    on our newly learned patterns. Feeling excited already?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 zsh 中最强大的功能之一：文件名生成。我们将学习处理系统文件和目录的新方法，甚至通过应用参数替换和修改器扩展一些更传统的命令的功能。本章还作为介绍
    zmv 的一部分，这是一个内置功能，提供了许多有用的功能来处理文件的日常和更复杂的任务。我们将学会如何使用 zmv 根据我们新学到的模式来重命名、复制和链接文件。已经感到兴奋了吗？
- en: Quoting your strings
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用你的字符串
- en: 'A safe way of declaring your string variables involves the usage of quotes.
    Think of it as a way of telling the function "*here* starts and *over here* ends
    my string". Although not necessary on this particular example, you can quote a
    phrase when using `echo` as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安全声明字符串变量的一种方式涉及使用引号。把它看作是告诉函数“*这里*开始，*这里*结束我的字符串”的一种方式。虽然在这个特定示例中不是必需的，但是你可以在使用
    `echo` 时引用短语，如下所示：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Single quotes are treated as delimiters by the shell and as such, they are
    completely ignored. The same rule applies to the `print` built-in function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号被 shell 视为分隔符，因此它们完全被忽略。相同的规则适用于 `print` 内置函数：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, what''s the point of using quotes then? Well, imagine for a moment that
    your output looks something like the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用引号的意义是什么呢？好吧，想象一下，你的输出看起来像以下这样：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Yes, that will trigger a continuation line, so there''s seemingly no way around
    it, save for using quotes. Let''s try it again:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这将触发一个续行，所以看起来似乎没有其他方法，除非使用引号。让我们再试一次：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, as a rule of thumb, we use single quotes when there are special characters
    on our string as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个经验法则，当我们的字符串中有特殊字符时，我们使用单引号如下所示：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, what's it that makes these special? Well, earlier in this book, we saw
    that comments are defined by a `#` sign; we can use the `*` character as a wildcard
    that matches filenames and the `\` character can be used for escaping sequences
    with special meaning. Think of all these as *special characters* that will never
    literally mean what the keyboard says, unless you quote them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是什么让这些特别呢？嗯，在本书的早些部分，我们看到注释是由 `#` 符号定义的；我们可以使用 `*` 字符作为匹配文件名的通配符，而 `\` 字符可用于转义具有特殊含义的序列。把所有这些都当作
    *特殊字符*，除非引用它们，否则它们永远不会字面上意味着键盘上显示的内容。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some special characters need to be "escaped". This means that they will have
    a different meaning other than the characters they represent, unless there's a
    `\` character before them, that is.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些特殊字符需要“转义”。这意味着除了它们表示的字符之外，它们还会有不同的含义，除非有一个 `\` 字符在它们之前。
- en: 'For example, `echo *.rb` will list all the files that have an `.rb` extension.
    If you wanted to list a directory named `*.rb`—weird, I know—you would have to
    call `echo` escaping the `*` special character as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`echo *.rb` 将列出所有具有 `.rb` 扩展名的文件。如果你想列出一个名为 `*.rb` 的目录——很奇怪，我知道——你需要调用 `echo`
    并转义 `*` 特殊字符，如下所示：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also worth noting is that `\` is actually a special character, so in cases
    where a literal backslash is required, you will need to escape it too:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另外需要注意的是，`\` 实际上是一个特殊字符，因此在需要字面上使用反斜杠的情况下，你需要对它进行转义：
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we saw in the previous chapter, a single backslash (`\`) will only trigger
    a continuation line.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中看到的，一个单独的反斜杠（`\`）只会触发一个续行。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can make the shell output the raw string by supplying the `(q)` argument:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供 `(q)` 参数来使 shell 输出原始字符串：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Double quotes
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双引号
- en: Okay, so what happens when we need to use the niceties of the special characters
    and also need them to appear as their literal representations? Enter the double
    quotes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么当我们需要使用特殊字符的优点，并且需要它们显示为它们的字面值时会发生什么？进入双引号。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The option `RC_QUOTES` allows you to use single quotes within a single-quoted
    string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 `RC_QUOTES` 允许你在单引号字符串内部使用单引号：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Double quotes work by allowing you to retain the value of any string and also
    enabling *parameter substitution* and *shell expansion* within them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号的工作原理是允许你保留任何字符串的值，并在其中启用 *参数替换* 和 *shell 扩展*。
- en: 'Take a long, hard look at the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 认真看看以下示例：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The shell works inside the double quotes by executing the command within the
    `$()` construct before anything else. In this particular case, we are using the
    `whoami` program to tell the current user ID—`gfestari` in this particular case—(if
    that's also your name, then *hello*, long-lost brother).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: shell 会在双引号内执行 `$()` 结构中的命令，先于其他任何操作。在这个特定的例子中，我们使用 `whoami` 程序来告诉当前用户的 ID——在这个例子中是
    `gfestari`——（如果那也是你的名字，*你好*，久违的兄弟）。
- en: The shell then moves on to expand the environment variable `$HOME`, which holds
    the current user's home folder currently pointing at `/Users/gfestari` on my system.
    Notice how the single quotes are treated like any other character within double
    quotes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，shell 会扩展环境变量 `$HOME`，该变量指向当前用户的主文件夹，在我的系统中指向 `/Users/gfestari`。注意单引号在双引号内像任何其他字符一样被处理。
- en: Getting started with Globbing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Globbing
- en: Filename Generation, popularly known as **Globbing** (as in, Global substitution),
    is the ability of the shell to generate filenames from patterns. This is but the
    name for the process that allows the shell to read a pattern and generate a series
    of filenames; as a matter of fact, you might notice you have been using Globbing
    for quite a while in this book, the only difference is, we're now formally introducing
    the feature. Also, be aware that whenever we mention *filenames* in this text,
    it means both file *and* folder names, as you can use pretty much the same patterns
    to match both.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名生成，广为人知的 **Globbing**（即，全局替换），是 shell 从模式生成文件名的能力。这仅仅是允许 shell 读取模式并生成一系列文件名的过程的名称；事实上，你可能已经在本书中使用
    Globbing 很久了，唯一的区别是，我们现在正式介绍这个特性。此外，请注意，当我们在本文中提到 *文件名* 时，它既指文件 *也* 指文件夹名，因为你可以使用几乎相同的模式来匹配两者。
- en: The really important thing you need to remember when dealing with Globbing is
    that filename substitution happens in the shell *right before* the line you typed
    is sent to the command. In other words, you type, zsh does the substitution, and
    *only then* sends the result, an expanded string and not whatever you just typed,
    to the function or program. There are ways around this, but just be mindful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理 Globbing 时，最重要的是要记住，文件名替换发生在 shell 中的 *输入行发送到命令之前*。换句话说，你输入了内容，zsh 会做替换，*然后*
    才将扩展后的字符串，而不是你刚输入的内容，发送给函数或程序。虽然有绕过的方法，但请务必保持警觉。
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you'd like to take a deeper look at some of the features covered in this
    chapter, you can always refer to the official documentation by typing `man zshexpn`
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解本章中提到的一些特性，可以随时通过输入 `man zshexpn` 查阅官方文档。
- en: Globbing with the stars
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用星号进行 Globbing
- en: 'Globbing works by using a series of special characters known as *operators*,
    to create a pattern that is later expanded by the shell into more complex, traditional
    strings without you even noticing the extra effort required. Arguably, the most
    popular of these operators is the asterisk or star (`*`). The star works as a
    *wildcard*, allowing you to match any filenames, even if you provide no pattern
    at all:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Globbing 的工作原理是通过一系列称为 *操作符* 的特殊字符，创建一个模式，随后 shell 会扩展这个模式为更复杂的传统字符串，而你甚至不会注意到额外的工作量。可以说，这些操作符中最常用的就是星号或星号符号（`*`）。星号作为
    *通配符*，允许你匹配任何文件名，即使你根本没有提供模式：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will list any file and folder on your current directory. Notice how we
    only needed a *single star* for this. However, if we want all files with a `.txt`
    extension, we simply need to provide the appropriate pattern: anything that ends
    with the desired extension.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出当前目录中的任何文件和文件夹。注意我们只需要一个 *单一的星号* 就能做到这一点。然而，如果我们想要所有扩展名为 `.txt` 的文件，只需要提供相应的模式：任何以所需扩展名结尾的文件。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What happens is that zsh reads the `*.txt` pattern, transforms it into its literal
    meaning (all the filenames with a `txt` extension), and only then passes the result
    as the argument for `echo`, which in turn never deals with the actual pattern.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，zsh 会读取 `*.txt` 模式，将其转化为字面意义（所有具有 `txt` 扩展名的文件名），然后将结果作为 `echo` 的参数传递，而
    `echo` 实际上并不会处理模式本身。
- en: 'Arguably, the best thing the star has going on is its versatility. Just like
    a drunken sailor, a star can get along with practically anything, not just files:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，这颗星星最棒的特点就是它的多功能性。就像一个醉酒的水手，星星几乎可以与任何东西相处，不仅仅是文件：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `NO_CASE_GLOB` option if you want to make Globbing case-insensitive
    (that is, treat upper and lowercase characters as equals).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让Globbing不区分大小写（即将大写字母和小写字母视为相等），可以使用`NO_CASE_GLOB`选项。
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s not all sunshine and rainbows though. There''s a fine print detail that
    you should consider when using the star operator: hidden files. If you recall
    from [Chapter 2](ch02.html "Chapter 2. Alias and History"), *Alias and History*,
    we used an alias, `la` (or `ls -a`), in order to list the hidden files within
    a directory; otherwise, the command wouldn''t list them.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有情况都是一帆风顺的。在使用星号操作符时，有一个细节你需要注意：隐藏文件。如果你记得在[第二章](ch02.html "第2章. 别名与历史")中，*别名与历史*一节中，我们使用了`la`别名（或`ls
    -a`）来列出目录中的隐藏文件；否则，命令不会列出它们。
- en: 'Because of how big a headache it could cause you to do things like `rm *` and
    end up deleting a parent folder, most Unix shells will simply ignore hidden files
    for most commands. The same rules apply to Globbing when using the wildcard operator.
    A workaround for dealing with this behavior would be to explicitly use a pattern
    along the lines of `.*some_pattern` in order to include hidden files just like
    the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像`rm *`这样的操作可能导致删除父文件夹，给你带来麻烦，大多数Unix shell会忽略大多数命令中的隐藏文件。使用通配符操作符时，Globbing也遵循相同的规则。解决这种行为的方法是显式使用类似`.*some_pattern`的模式，以包含隐藏文件，如下所示：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We use two stars in order to list all the files that start with a dot (traditional
    hidden files in Unix) and contain a `zsh` pattern somewhere in their name. In
    other words, our startup files.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两个星号来列出所有以点开头（Unix中的传统隐藏文件）并且文件名中包含`zsh`模式的文件。换句话说，就是我们的启动文件。
- en: 'The takeaway lesson here: *you can use the star anywhere on a pattern*, you
    don''t have to limit yourself with length or just extensions; be mindful of the
    hidden files though, as a star won''t show you any hidden files, you''ll need
    something along the lines of `.*some_pattern` for that to work.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键教训是：*你可以在模式中的任何地方使用星号*，不必局限于长度或仅限于扩展名；但要注意隐藏文件，因为星号不会显示隐藏文件，你需要使用类似`.*some_pattern`的模式才能做到这一点。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can always circumvent the "ignore files starting with dots" behavior by
    setting the `GLOBDOTS` option; however, it's advisable you refrain from setting
    it permanently on your startup files as it can lead to issues such as you deleting
    the parent (`.`) directory and so on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置`GLOBDOTS`选项来绕过“忽略以点开头的文件”行为；然而，建议你不要在启动文件中永久设置该选项，因为它可能导致你删除父目录（`.`）等问题。
- en: The most important thing to keep in mind when using this option on your scripts
    or functions is ensuring a call to `setopt NO_GLOBDOTS` right before exiting.
    Most times though, you'll do just fine by using the `.*` pattern discussed previously.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本或函数中使用此选项时，最重要的是在退出前确保调用`setopt NO_GLOBDOTS`。不过大多数情况下，你只需使用之前讨论过的`.*`模式就能顺利完成。
- en: Questions for any single character
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配任意单个字符的问题
- en: 'The question mark symbol works pretty much like the star, except it matches
    a single character instead of many. For example, you can use `ls ???` to list
    the contents of any three-lettered directory, or get a bit more practical and
    use the following to list any two-lettered extension file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 问号符号的作用与星号类似，不同之处在于它匹配单个字符而非多个字符。例如，你可以使用`ls ???`来列出任何三字母的目录内容，或者更实际一点，使用以下命令列出任何两字母扩展名的文件：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can even view all files with an extension via the following, similar expression:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过以下类似的表达式查看所有具有扩展名的文件：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is similar to the wildcard qualifier; however, you won't be able to match
    any filenames with leading dots unless you explicitly declare so.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这与通配符限定符类似；然而，除非显式声明，否则你无法匹配以点开头的任何文件名。
- en: Brackets for a sequence of characters
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符序列的方括号
- en: You can use the square brackets construct to match a group of characters within
    a pattern. For example, you can use `[ML]*` to match any filename that starts
    with either an uppercase letter `M` or `L`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号构造来匹配模式中的一组字符。例如，你可以使用`[ML]*`来匹配任何以大写字母`M`或`L`开头的文件名。
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice how we need to combine the character class operator with the wildcard
    in order to denote the filenames that might have more than a single uppercase
    letter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们需要将字符类运算符与通配符结合使用，以表示可能包含多个大写字母的文件名。
- en: 'Even more useful is the use of a hyphen (or minus sign) in order to name ranges
    of contiguous characters to match. For example, you can use the `[A-Z]*` pattern
    to match any file that starts with an uppercase letter from the alphabet. Likewise,
    you can use the same pattern for contiguous natural numbers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是使用连字符（或减号）来命名连续字符的范围。例如，你可以使用`[A-Z]*`模式来匹配任何以大写字母开头的文件。同样，你也可以使用相同的模式来匹配连续的自然数：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Simple enough, right? Remember you can declare your own character classes.
    Here''s an example that matches any filename starting with any number from one
    to five or an uppercase `M`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，对吧？记住你可以声明自己的字符类。这里有一个示例，匹配任何以1到5的数字或大写字母`M`开头的文件名：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just as before, a `[.]*` pattern won't work as you might expect; in fact, it
    won't work at all.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，`[.]*`模式不会像你预期的那样工作；事实上，它根本无法工作。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A note about ranges**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于范围的说明**'
- en: If your system is using a non-English alphabet or something other than the ASCII
    character set, chances are you might expect things like `ü` to match classes like
    `[a-z]`. This behavior, however, is ruled by the `LANG` and `LC_*` family of environment
    variables and is *very* system dependent, not to mention, beyond the scope of
    this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的系统使用的是非英语字母或其他非ASCII字符集，那么你可能会期望像`ü`这样的字符匹配像`[a-z]`这样的类。然而，这种行为是由`LANG`和`LC_*`系列环境变量控制的，并且*非常*依赖于系统，甚至超出了本书的讨论范围。
- en: Using safer ranges on your scripts
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中使用更安全的范围
- en: Although nothing to write home about if you have been using any modern shell
    lately, there's a series of shortcuts that save you from boredom when working
    with the garden variety of character classes. You can access them via the `[[:shortcut:]]`
    pattern.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如果你最近使用了任何现代Shell，这个可能没什么新鲜感，但有一系列的快捷方式可以让你在处理常见的字符类时免于无聊。你可以通过`[[:shortcut:]]`模式来访问它们。
- en: 'So, for example, if you needed any letter from the alphabet (say, the range
    that includes both uppercase and lowercase English characters `[A-Za-z]`), you
    could use the `alpha` shortcut to list any filename that starts with a character
    from the alphabet like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，例如，如果你需要任何字母（比如包括大写和小写字母的范围`[A-Za-z]`），你可以使用`alpha`快捷方式来列出任何以字母字符开头的文件名，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Feeling enthusiastic about character sets already? The following table lists
    some of the popular ones:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符集感到兴奋了吗？以下表格列出了一些流行的字符集：
- en: '| Character set | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 字符集 | 描述 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ascii` | Anything from the ASCII character set (see `man ascii`) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `ascii` | ASCII字符集中的任何字符（请参阅`man ascii`） |'
- en: '| `lower` | Lowercase character |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `lower` | 小写字符 |'
- en: '| `upper` | Uppercase character |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `upper` | 大写字符 |'
- en: '| `alpha` | Letter |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `alpha` | 字母 |'
- en: '| `digit` | Number |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `digit` | 数字 |'
- en: '| `alnum` | Alphanumeric character |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `alnum` | 字母数字字符 |'
- en: '| `print` | Any printable character |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `print` | 任何可打印字符 |'
- en: '| `blank` | Space or tab character |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `blank` | 空格或制表符 |'
- en: '| `space` | Space character (tab, carriage return, newline and co.) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `space` | 空格字符（制表符、回车符、换行符等） |'
- en: '| `punct` | Anything but an `alnum` nor a `space` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `punct` | 任何既不是`alnum`也不是`space`的字符 |'
- en: 'You can combine multiple patterns and character sets; just remember that the
    innermost brackets belong to the character set, and everything else goes between
    the outermost brackets. For example, if we want all the files that start with
    either a `digit` character or the lowercase `b` letter, we might roll with the
    following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以结合多个模式和字符集；只需记住，最内层的方括号属于字符集，其他内容都放在最外层的方括号之间。例如，如果我们想要所有以`digit`字符或小写字母`b`开头的文件，可以使用以下模式：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the inner set of brackets declares the character set, while
    the `b` character is there just as though we had typed `[b]`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内层的方括号声明了字符集，而`b`字符只是作为我们输入的`[b]`。
- en: Avoiding characters
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用某些字符
- en: Okay, we have been giving patterns a warm welcome so far, but what happens when
    we want the thing that does *not* match whatever we're looking for? Turns out
    there's also an easy way to tell zsh "I want the filenames that have nothing to
    do with this particular pattern", so let's get to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止我们一直在热烈欢迎模式，但当我们想要找到那些*不*匹配我们正在寻找的内容时会发生什么呢？原来也有一种简单的方法可以告诉zsh“我想要的是那些与特定模式无关的文件名”，那么我们来看看吧。
- en: 'Suppose we have the following files in a given directory:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在某个目录下有以下文件：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And we just want to select the actual code files, the ones ending in `.c` and
    `.h`, and avoid everything ending in `.o`. With what we have learned so far, we
    could get away with something along the lines of the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只想选择实际的代码文件，即以`.c`和`.h`结尾的文件，避免选择以`.o`结尾的文件。根据我们迄今为止学到的知识，我们可以做到类似如下：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But as you can see, the more complex our requirements, the more likely we end
    up with a gigantic mess of a character class. Luckily, we can get the complement
    of a class via the caret (`^`) operator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所看到的，我们的需求越复杂，最终可能会遇到一个庞大的字符类混乱。幸运的是，我们可以通过插入符号（`^`）操作符来获取一个类的补集：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we did back there was told zsh to expand the class for those filenames
    *that do not match* the `o` extension. Notice how the rest of the pattern remains
    unchanged and the caret is immediately after the left bracket that does the actual
    negation. Feel free to read this as "anything but whatever comes inside the brackets".
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是告诉 zsh 扩展那些*不匹配*`o`扩展名的文件名的类。请注意，其余的模式保持不变，并且插入符号紧接在实际进行否定的左括号后面。你可以理解为“除了括号内的内容之外的任何东西”。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can negate a character set by using a caret before the inner brackets.
    For example, if we wish to skip files that start with an uppercase letter, we
    might as well do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在内括号前使用插入符号来否定一个字符集。例如，如果我们想跳过以大写字母开头的文件，我们可以这样做：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Handling mismatches
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理不匹配的情况
- en: So far we have seen how to make the shell interpret our patterns and attempt
    to match whatever filenames it can. During the remainder of this Globbing trip
    of ours, we'll take a look at what happens with the unlucky patterns, those that
    fail to match anything and how the shell deals with them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何让 shell 解释我们的模式并尝试匹配它能匹配的任何文件名。在接下来的 Globbing 过程中，我们将看看那些不幸的模式，哪些未能匹配任何内容，以及
    shell 如何处理它们。
- en: 'Let''s try listing some nonexistent zip files:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试列出一些不存在的 zip 文件：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It seems that zsh defaults to an error message and aborts the execution of the
    command. Luckily, there are plenty of things for us to do about it in the form
    of options.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来 zsh 默认会输出错误信息并中止命令的执行。幸运的是，有很多选项可以帮助我们应对这种情况。
- en: 'First, there''s `NULL_GLOB`, which will make the shell discard any pattern
    without a proper match. The following is an example, where a blank line gets printed
    when no matches are performed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有`NULL_GLOB`，它会让 shell 丢弃任何没有正确匹配的模式。以下是一个例子，当没有匹配时会打印空行：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This comes in handy when passing multiple patterns, but can make you call some
    programs without any arguments whatsoever, so consider that before updating your
    startup files willy-nilly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式在传递多个模式时非常有用，但有时会导致你调用一些没有任何参数的程序，因此在随便更新启动文件之前需要考虑这一点。
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first pattern (`*.c`) matches and lists all files with a `.c` extension;
    whereas the second pattern (`*.zip`) doesn't match anything and is discarded (a
    null second entry is passed to `echo`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个模式(`*.c`)匹配并列出所有`.c`扩展名的文件；而第二个模式(`*.zip`)不匹配任何内容，并被丢弃（一个空的第二个条目传递给`echo`）。
- en: 'Moving on, there''s also the `NOMATCH` option, which you can unset to achieve
    a behavior that pretty much emulates bash; any pattern that does not match is
    passed as a *literal argument* to the command. This is relatively easy to test
    with the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，还有`NOMATCH`选项，你可以取消设置它来实现类似于 bash 的行为；任何不匹配的模式都会作为*字面参数*传递给命令。通过以下示例可以轻松测试：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What do you know? Seems the manpage was right and now the failing `*.zip` pattern
    acts just as though we had called `echo '*.zip'`. This works differently from
    `NULL_GLOB`, in that the pattern is also ignored by the shell, but passed *as
    an argument* to the program regardless of it matching anything.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？似乎手册页是对的，现在失败的`*.zip`模式就像我们调用了`echo '*.zip'`一样。这与`NULL_GLOB`不同，因为该模式也会被
    shell 忽略，但无论是否匹配任何内容，都会作为*参数*传递给程序。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember you could also use `setopt NO_NOMATCH` instead of `unsetopt`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记得你也可以使用`setopt NO_NOMATCH`来代替`unsetopt`。
- en: 'Lastly, there''s an option which mimics the legacy behavior of `csh`, aptly
    named `CSH_NULL_GLOB`. Yes, naming conventions spare no expenses. Anyway, here''s
    what happens when you set it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个选项，它模仿了`csh`的遗留行为，名为`CSH_NULL_GLOB`。是的，命名惯例可谓不惜一切代价。无论如何，设置它时会发生如下情况：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Seems it''s back to the "error message and abort command" zone for us. Like
    the curious learners we are, let''s kick it up a notch and see what happens when
    dealing with multiple patterns:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们又回到了“错误信息并中止命令”的区域。作为好奇的学习者，我们不妨加大一点力度，看看当处理多个模式时会发生什么：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Ok, now that's a lot nicer. What happens is that `CSH_NULL_GLOB` will show you
    an error message and abort the command line whenever any single pattern does not
    match, but will go ahead and discard the failing patterns if there's at least
    one that matches. Think of this as the product of that night of unrestrained passion
    between zsh's default behavior and `NULL_GLOB`. And while we're at it, don't blame
    me for that mental picture.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在看起来好多了。发生的情况是，`CSH_NULL_GLOB` 会在任何单一模式不匹配时显示错误信息并中止命令行，但如果至少有一个模式匹配，它会继续执行并丢弃失败的模式。可以把它当作
    zsh 默认行为和 `NULL_GLOB` 之间那晚激情碰撞的产物。而且在此期间，别怪我带来这样的心理画面。
- en: 'Before we move on to another subject though, there''s another option you should
    familiarize yourself with when dealing with patterns. But first, let''s take a
    look at what happens when we try to pass a wrong pattern to the shell:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向另一个主题之前，还有一个你应该熟悉的选项，特别是在处理模式时。但首先，让我们看看当我们尝试将一个错误的模式传递给 shell 时会发生什么：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice how we missed the closing bracket (`]`)? The shell complains about the
    pattern and we are left with the sour taste of failed scripting. Let''s try that
    again, but now we''ll set the following option:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们错过了关闭括号（`]`）吗？shell 报告了模式错误，我们则被失败的脚本弄得有些沮丧。让我们再试一次，不过这次我们会设置以下选项：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We turned on `NO_BAD_PATTERN` (or unset `BAD_PATTERN`, whatever floats your
    boat) and guess what happened? That's right; the bad pattern *is ignored* by the
    shell expansion mechanism and passed instead as an argument to the command. Pretty
    handy if you don't want those pesky warnings while experimenting with your newly
    learned patterns.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用了 `NO_BAD_PATTERN`（或取消设置 `BAD_PATTERN`，随你喜欢），然后发生了什么？没错；不良模式*被 shell 扩展机制忽略*，而是作为参数传递给命令。如果你不想在实验新学的模式时看到那些烦人的警告，这个功能非常方便。
- en: Extended Globbing
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 Globbing
- en: 'As you might have noticed at this point, when it comes to Globbing, zsh goes
    above and beyond the call of duty and then some more. What we''ll discuss next
    is the more advanced aspects of Globbing, commonly referred to as *extended Globbing*.
    Put simply, we''ll learn a new set of characters and expressions that expand on
    what we have been using to provide even more functionality to the shell''s operations.
    However, before we ride that horse, pry open that `.zshrc` file of yours and add
    the following option:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在可能已经注意到，当涉及到 Globbing 时，zsh 总是能超出预期，做得比要求的更多。接下来我们将讨论 Globbing 的更高级部分，通常被称为*扩展
    Globbing*。简单来说，我们将学习一组新的字符和表达式，扩展我们之前使用的功能，为 shell 的操作提供更多功能。不过，在我们开始之前，先打开你的
    `.zshrc` 文件，添加以下选项：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Or call it from your terminal if you plan on adding it later on. As we'll see
    in no time, extended Globbing is there to give a special meaning to characters
    like `#`, which if you recall, is typically used for comments. Now let's get our
    hands dirty.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你打算稍后再添加它，可以从终端调用它。正如我们将很快看到的，扩展 Globbing 是为了赋予像 `#` 这样的字符特殊含义，回想一下，这个字符通常用于注释。现在让我们动手试试看。
- en: Special patterns
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊模式
- en: Zsh's vast repertoire also includes a series of shortcuts or special patterns
    that aim to make mundane tasks a bit more tolerable. We will get familiarized
    with them in this section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Zsh 丰富的功能还包括一系列快捷方式或特殊模式，旨在使日常任务变得更加容忍。在本节中，我们将熟悉这些功能。
- en: Recursive searching
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归搜索
- en: Arguably, the most popular pattern out there is recursive searching. Accessible
    through the `**/` combination, this pattern tells zsh to perform a recursive search,
    starting from the current directory and working its way inwards along the directory
    tree.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，最受欢迎的模式之一是递归搜索。通过 `**/` 组合可以访问到这个模式，它告诉 zsh 从当前目录开始进行递归搜索，并沿着目录树向内搜索。
- en: 'For example, here''s how we look for all the markdown files (files which typically
    have the `.md` extension) on the current working directory:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面是我们如何在当前工作目录中查找所有 markdown 文件（通常具有 `.md` 扩展名的文件）：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then there's also the `***/` flavor, which tells the shell to follow symbolic
    links. Be careful though, as it can lead to errors such as "file name too long",
    which is the operating system's way of telling you that either the rabbit hole
    is too deep, or you have a circular reference somewhere.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另外还有`***/`这种写法，它告诉shell跟随符号链接。不过要小心，因为它可能会导致“文件名过长”这样的错误，这是操作系统告诉你，可能是兔子洞太深，或者你在某个地方有循环引用。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that specialized tools like `find` or The Silver Searcher ([https://github.com/ggreer/the_silver_searcher](https://github.com/ggreer/the_silver_searcher))
    will run circles around the shell's directory recursion mechanism. Thus, you should
    avoid relying on it for "serious" operations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，像`find`或The Silver Searcher ([https://github.com/ggreer/the_silver_searcher](https://github.com/ggreer/the_silver_searcher))这样的专业工具在处理目录递归时会比shell的机制更高效。因此，你应该避免依赖它来进行“重要”的操作。
- en: 'As for the caveats of using the recursive pattern expression, you might eventually
    be greeted with an "argument list too long" warning from the system. This usually
    means the shell is taking up too much memory space when expanding the `**/` pattern
    into the directory structure, which in turn could happen if you have a really
    complex tree to work on. A workaround, if you insist on using the recursive expansion,
    is to pass each argument with the help of `xargs` as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用递归模式表达式的注意事项，你可能最终会收到来自系统的“参数列表过长”警告。这通常意味着在展开`**/`模式时，shell占用了太多的内存空间，这种情况通常出现在你有一个非常复杂的目录树时。如果你坚持使用递归展开的方式，解决方法是借助`xargs`将每个参数传递出去，如下所示：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I know, this example is a bit dumb as the same could be accomplished just with
    a simple `find **/*.md` for a multiple-row result. The idea here is that you get
    to know how to `pipe` the results of the find into `echo` by splitting them with
    `xargs`, so bear with me.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道，这个例子有点傻，因为用一个简单的`find **/*.md`就能实现多行结果。这里的重点是让你了解如何通过`xargs`分隔结果并将它们`pipe`到`echo`中，所以请耐心一点。
- en: 'Lastly, there''s somewhat of a hack you can use in case you want to exclude
    the current directory from the pattern:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想排除当前目录，可以使用某种技巧：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That way, only filenames that include `base_dir/any_dir` will match the pattern.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，只有包含`base_dir/any_dir`的文件名才会匹配该模式。
- en: Alternate patterns
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代模式
- en: 'Having to choose between two options and then being given a third one clearly
    inferior, can make a person rethink his decision... or so the story goes. Luckily,
    the shell is not a complex creature like us, and we can provide it with a choice
    of patterns to select should one fail. We do that by using the parentheses with
    a pipe construct, like the following example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在两个选项之间做出选择时，然后又给出一个明显较差的第三个选项，确实会让人重新思考自己的决定……或者故事是这么说的。幸运的是，shell不像我们这样复杂，我们可以为它提供一个模式选择，若一个失败，它可以选择另一个。我们通过使用带管道符号的括号构造来实现这一点，像下面这个例子：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We continue on our search for the `README` files, using a named range to specify
    the filename we want with an uppercase letter before defining either an `md` or
    a `txt` extension. Simple, right? Well, not quite. Just be careful so as not to
    start the command line with parentheses, as this might make them run in a subshell
    instead. Zsh is smart enough to discriminate between intended usages, so you'll
    probably be safe most of the time. Try not to push your luck though.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续搜索`README`文件，使用命名范围来指定我们想要的文件名，文件名前需要大写字母，后面跟上`md`或`txt`扩展名。简单吧？嗯，不完全是。小心不要让命令行以括号开头，因为这可能会让它们在子shell中运行。Zsh足够智能，可以区分预期的用法，所以大多数时候你应该是安全的。但还是不要冒险。
- en: Before we move on, it bears mentioning you can't use a pattern that contains
    a `/` character within the group alternatives we just learned. You have been warned!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，需要提到的是，你不能在我们刚刚学到的组内替代项中使用包含`/`字符的模式。你已被警告！
- en: Numeric ranges
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字范围
- en: You can make the shell match any series of digits it encounters with the `<->`
    special pattern. What makes this construct great though, is that it can match
    any series of digits without a length restriction (this is because the shell processes
    each digit independently and not as a whole integer).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以让shell匹配它遇到的任何一系列数字，使用`<->`这种特殊模式。这个构造的优势在于，它能够匹配没有长度限制的任何一系列数字（这是因为shell会独立处理每个数字，而不是把它们当作一个整体的整数）。
- en: 'Take, for example, the following directory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下目录为例：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We want to work with those files that match the `log_xxx.txt` pattern, where
    `xxx` is a digit. Let''s put what we just learned to good use:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想处理那些符合 `log_xxx.txt` 模式的文件，其中 `xxx` 是数字。让我们把刚才学到的知识付诸实践：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What if we want those logfiles from `10` upwards? Zsh has you covered:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要的是从 `10` 开始的日志文件呢？Zsh 可以帮你搞定：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the `<->` pattern can define a range with lower and upper bounds.
    Let''s try again, this time for files between `10` and `20`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`<->` 模式可以定义一个具有上下限的范围。让我们再试一次，这次匹配 `10` 到 `20` 之间的文件：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Another cool feat of this expression is that it doesn't take into account leading
    zeroes, allowing you to sort things such as `00010` and `00013`. Speaking of which,
    there's the `NUMERIC_GLOB_SORT` option, which you can also set in order to output
    a sorted numeric match of any pattern matches (and that's *any* as in, not just
    the numeric range pattern).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式的另一个酷炫之处在于它不会考虑前导零，这使得你可以排序类似 `00010` 和 `00013` 的内容。说到这一点，还有 `NUMERIC_GLOB_SORT`
    选项，你也可以设置它来输出任何模式匹配的排序数字匹配（并且是 *任何* 匹配，而不仅仅是数字范围模式）。
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Revisiting the caret operator
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新审视插入符号运算符
- en: 'As we saw earlier, we use the caret (`^`) operator to negate patterns (remember:
    "anything but what matches this"). Here''s another way to use the caret:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，插入符号（`^`）运算符用于否定模式（记住：“匹配任何不符合此模式的内容”）。这就是使用插入符号的另一种方式：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So basically, we're telling the shell to expand that pattern so as to match
    the filenames that start with `b` but do not have an `.o` extension.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，我们告诉 shell 扩展该模式，以匹配以 `b` 开头但没有 `.o` 扩展名的文件名。
- en: 'We can then safely say that the `pattern^other_pattern` expressions work by
    matching the first pattern and avoiding matches on the `other_pattern` side of
    the expression. A word of caution now that we are using special characters with
    different meanings though is, remember to wrap names or expressions that you want
    taken literally with single quotes, like in the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地说，`pattern^other_pattern` 表达式通过匹配第一个模式并避免匹配表达式中 `other_pattern` 部分来工作。不过，现在我们使用的这些具有不同含义的特殊字符，请记住要用单引号括起来你希望字面意义理解的名称或表达式，比如以下示例：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Otherwise, you might be asking for trouble.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你可能会自找麻烦。
- en: The tilde operator
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 波浪符运算符
- en: 'Similar to the caret operator''s second usage, the tilde (`~`) operator can
    be used to define a pattern that consists of a part that should match and a second
    part that shouldn''t:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于插入符号运算符的第二种用法，波浪符（`~`）运算符可以用于定义一个由应该匹配的部分和不应该匹配的第二部分组成的模式：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Basically, this is just a combination of two patterns: `b*` and `*.o`, linked
    with the "do not match what follows" operator: `~`. Again, we can read that as
    "match everything that starts with a lowercase b and does not match anything that
    ends with .o".'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这只是两个模式的组合：`b*` 和 `*.o`，通过“不要匹配后续内容”运算符 `~` 连接。我们可以这样理解：“匹配以小写字母 b 开头且不匹配以
    `.o` 结尾的所有内容”。
- en: 'If you recall, we used `b^*.o` with the caret, so the tilde version seems a
    bit more straightforward if I might say so. But don''t take my word for it. Let''s
    use the tilde to exclude, for example, any files within a temporary directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们用了 `b^*.o` 和插入符号运算符，所以如果使用波浪符，似乎更加直观。但别听我说的，试试看，举个例子，我们可以用波浪符排除临时目录中的文件：
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What happens is that the shell runs the first pattern (`**/*.sh`) and recursively
    checks for all files with the `sh` extension. The preliminary result is a list
    of possible filenames that is then matched against the second pattern (`tmp/*`).
    The filenames that match the latter are removed from the list, and we are left
    with the filenames we were searching for.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，shell 运行第一个模式（`**/*.sh`），并递归地检查所有具有 `sh` 扩展名的文件。初步结果是一个可能的文件名列表，接着与第二个模式（`tmp/*`）进行匹配。与后者匹配的文件名被从列表中移除，剩下的就是我们要找的文件名。
- en: Just for academic purposes, it might be a good time to mention that `**/` is
    equivalent to the `(*/)#` pattern. As it stands, the special operator `#` will
    match a single repeating character (in parentheses), or a recurrent expression
    (in brackets).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仅出于学术目的，可能是时候提一下，`**/` 等价于 `(*/)#` 模式。就目前而言，特殊运算符 `#` 将匹配一个重复的字符（在括号内），或者一个递归的表达式（在方括号内）。
- en: Glob qualifiers
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通配符限定符
- en: Besides operators, zsh boasts qualifiers, which are essentially a sort of filters
    you apply to your pattern in order to restrict things like matching only files
    or folders, type of permissions for those filenames, or even the owner of such
    entries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作符，zsh 还拥有限定符，本质上是您应用于模式的过滤器，用以限制诸如仅匹配文件或文件夹、文件名的权限类型，甚至是此类条目的所有者。
- en: 'So in the following example, we''ll list all the *directories* that match the
    `*tmp` pattern. Notice the `(/)` construct, that''s what intuitively sets files
    and folders apart:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下面的示例中，我们将列出所有与 `*tmp` 模式匹配的 *目录*。注意 `(/)` 构造，这正是直观地区分文件和文件夹的方式：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: What about matching only vanilla files then? Fair enough, `(.)` is your designed
    qualifier for files-only restrictions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，仅匹配普通文件呢？公平的说，`(.)` 是您为仅限文件的限制设计的限定符。
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Suddenly, a wild filename appears:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，一个神秘的文件名出现了：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have a `zsh` directory and a script file with a `.zsh` extension. Typically,
    we would roll with an `echo *zsh` construct to list both of them, or a more restrictive
    `echo *.zsh` construct if we were just looking for files with an extension; however,
    the `(.)` qualifier is arguably better suited for complex tree searches or when
    dealing with lots of similar filenames and directories.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `zsh` 目录和一个扩展名为 `.zsh` 的脚本文件。通常，我们会使用 `echo *zsh` 来列出它们两个，或者如果我们只是寻找具有特定扩展名的文件，则会使用更具限制性的
    `echo *.zsh`。然而，`(.)` 限定符无疑更适合复杂的树状搜索，或者在处理大量相似文件名和目录时更为高效。
- en: 'What follows is a "cheatsheet" for the most common qualifiers:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用限定符的“备忘单”：
- en: '`(N)`: Remove argument if no matches are found, silently ignore errors. Acts
    as a per-command `NO_GLOB` option.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(N)`：如果没有找到匹配项，则移除参数，静默忽略错误。充当每个命令的 `NO_GLOB` 选项。'
- en: '`(@)`: Symlink qualifier. Used for only selecting symbolic links.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(@)`：符号链接限定符。仅用于选择符号链接。'
- en: '`(-@)`: A special variation of the previous one. Use this to find any *broken*
    symlinks.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(-@)`：上一个限定符的特殊变体。用于查找任何 *损坏的* 符号链接。'
- en: '`(/)`: Directories only.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(/)`：仅限目录。'
- en: '`(.)`: Files only. Whatever is not either a link, directory, or any of the
    previous will be selected by this.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(.)`：仅限文件。任何不是链接、目录或之前提到的内容都会被此限定符选中。'
- en: '`(*)`: Executable files. Directories need not apply. Think of this as `(.)`
    for those files with `+x` permissions.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(*)`：可执行文件。目录不适用。可以把它看作是对那些拥有 `+x` 权限的文件的 `(.)`。'
- en: '`(r)`: File is readable by the current shell user.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(r)`：文件对当前 shell 用户可读。'
- en: '`(w)`: File is writable by the current shell user.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(w)`：文件对当前 shell 用户可写。'
- en: '`(x)`: File is executable by the current shell user.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(x)`：文件对当前 shell 用户可执行。'
- en: '`(U)`: File is owned by the current shell user.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(U)`：文件属于当前 shell 用户。'
- en: '`(R)`: File is readable by anyone.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(R)`：文件对任何人可读。'
- en: '`(W)`: File is writable by anyone.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(W)`：文件对任何人可写。'
- en: '`(X)`: File is executable by anyone.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(X)`：文件对任何人可执行。'
- en: '`(u:root:)`: File is owned by the user `root`. You can replace the `:` character
    with any another pair of symbols such as curly braces: `(u{root})`. Just refrain
    from using pipes (`|`).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(u:root:)`：文件属于用户 `root`。您可以将 `:` 字符替换为任何其他符号对，如花括号：`(u{root})`。只要避免使用管道符号（`|`）即可。'
- en: '`(on)`: Sort filenames by name. The `echo *(on)` construct will be analogous
    to `ls`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(on)`：按名称排序文件名。`echo *(on)` 的构造与 `ls` 类似。'
- en: '`(On)`: Reverse-sort filenames by name.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(On)`：按名称逆序排序文件名。'
- en: '`(oL)`: Sort filenames by file size.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(oL)`：按文件大小排序文件名。'
- en: '`(OL)`: Reverse-sort filenames by file size.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(OL)`：按文件大小逆序排序文件名。'
- en: '`(om)`: Sort filenames by modification date.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(om)`：按修改日期排序文件名。'
- en: '`(Om)`: Reverse-sort filenames by modification date.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Om)`：按修改日期逆序排序文件名。'
- en: As always, feel free to mix and match to spice up things. Like poking with `(*r^w)`
    for regular files that are readable but not writable by your user, or `(@,/)`
    for either symlinks or directories.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，随意混合搭配以增加趣味。例如，使用 `(*r^w)` 来查找当前用户可读但不可写的普通文件，或者使用 `(@,/)` 来查找符号链接或目录。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Eager to find out more about qualifiers and what have you? Fret not dear reader,
    and embrace the mystical powers of... never mind, we'll just resort to *context
    completion*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 渴望了解更多关于限定符的知识吗？亲爱的读者，别担心，来拥抱那神秘的力量……算了，我们还是使用 *上下文补全* 吧。
- en: 'Type the following, and remember to press *Tab* right after the opening parentheses:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下内容，并记得在打开括号后按 *Tab* 键：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will yield context completion for the glob qualifiers listed here (and
    many more!).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成上下文补全，用于此处列出的 glob 限定符（以及更多！）。
- en: What follows are the more complex batch of qualifiers, such as timestamps and
    file size, which require a bit more explaining before delving right into their
    usage.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是更复杂的一组限定符，如时间戳和文件大小，它们需要更多的解释才能深入了解它们的使用方法。
- en: Timestamp qualifiers
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳限定符
- en: 'Unix systems typically record three timestamps on their filesystems: modification,
    access, and change times. With that in mind, you can use the following construct
    for Globbing filenames:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统通常会在其文件系统上记录三个时间戳：修改时间、访问时间和变更时间。考虑到这一点，你可以使用以下构造来匹配文件名：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will provide you with the files modified in the last hour. You can easily
    check this result via an `ls -l` qualifier. The `m` there is the modification
    time, which is the most common type of timestamp you'll be interested in. Nevertheless,
    you could also check for either access (`(ah-1)`) or creation (`(ch-1)`) qualifiers
    within the last hour.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出过去一小时内修改过的文件。你可以通过 `ls -l` 限定符轻松查看此结果。`m` 代表修改时间，这是你最常关注的时间戳类型。不过，你也可以检查过去一小时内的访问时间（`(ah-1)`）或创建时间（`(ch-1)`）限定符。
- en: Regarding that "last hour" bit, it's represented by the `h-1` qualifier, where
    `h` stands for hour (yes, yes, I know) and could be replaced by either minutes
    (`m`), weeks (`w`), or Months (an uppercase "`M`"). Note that the default unit
    for this qualifier is days, so `(m-1)` will mean a day ago or, more precisely,
    up to 24 hours before the current system time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“过去一小时”这一部分，它由 `h-1` 限定符表示，其中 `h` 代表小时（是的，我知道），可以替换为分钟（`m`）、周（`w`）或月份（大写的
    "`M`"）。请注意，这个限定符的默认单位是天，因此 `(m-1)` 意味着一天前，或者更准确地说，是当前系统时间前最多 24 小时。
- en: 'Similarly, the plus operator can be translated as "more than", allowing you
    to describe such patterns as `(mw+3)`, which is a concise way of saying "more
    than three weeks from today". Finally, you can also specify a range by combining
    the two operators:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`+` 操作符可以翻译为“更多”，这样你就可以描述像 `(mw+3)` 这样的模式，这是一种简洁的表达方式，意思是“从今天起超过三周”。最后，你也可以通过结合这两个操作符来指定一个范围：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will provide the files modified between five and two hours.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出在五到两小时之间修改过的文件。
- en: File size qualifiers
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件大小限定符
- en: 'The last qualifier you''ll get to know today is the file size. As you might
    have guessed already, we can query filenames on the basis of their size on the
    disk:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 今天你将学习的最后一个限定符是文件大小。正如你可能已经猜到的，我们可以根据文件在磁盘上的大小来查询文件名：
- en: '`(Lm+size)`: The file size is larger than `size` megabytes. For example: `(Lm+5)`—larger
    than five megabytes.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Lm+size)`：文件大小大于 `size` 兆字节。例如：`(Lm+5)`——大于五兆字节。'
- en: '`(Lm-size)`: The file is smaller than `size` megabytes. For example: `(Lm-2)`—smaller
    than two megabytes.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Lm-size)`：文件大小小于 `size` 兆字节。例如：`(Lm-2)`——小于两兆字节。'
- en: '`(Lk+size)`: The file size is larger than `size` kilobytes. For example: `(Lk+5000)`—larger
    than 5000 kilobytes.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Lk+size)`：文件大小大于 `size` 千字节。例如：`(Lk+5000)`——大于 5000 千字节。'
- en: '`(Lk-size)`: The file is smaller than `size` kilobytes. For example: `(Lm-2000)`—smaller
    than 2000 kilobytes.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Lk-size)`：文件大小小于 `size` 千字节。例如：`(Lm-2000)`——小于 2000 千字节。'
- en: The zmv function
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zmv 函数
- en: In the previous chapter, we learned about `zle`; zsh's module in charge of the
    command line. It's time we take advantage of our newly learned Globbing skills
    and get acquainted with `zmv`, a function that was created to make copying, moving,
    and linking files a breeze.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 `zle`；这是 zsh 用于处理命令行的模块。现在是时候利用我们新学会的 Globbing 技能，来了解 `zmv` 了，它是为了让复制、移动和链接文件变得更加轻松而创建的函数。
- en: So, you ask, what's the deal with zmv? What's special about this built-in function
    in comparison to, say vanilla `cp`, is that zmv works its magic based on patterns.
    Further, as we'll see in this section, zmv is designed to be safe by default,
    which means it will ask you for a confirmation before taking on any kind of risky
    operation such as overwriting files.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会问，zmv 是怎么回事？与普通的 `cp` 相比，这个内建函数有什么特别之处呢？zmv 的魔力在于它基于模式进行操作。此外，正如我们在本节中将要看到的那样，zmv
    默认设计为安全的，这意味着它会在执行任何可能带来风险的操作（如覆盖文件）之前，要求你确认。
- en: 'Before we get started though, you should add the following to your `.zshrc`
    file, remembering to source it or restarting your terminal emulator of choice:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们开始之前，你需要将以下内容添加到你的 `.zshrc` 文件中，记得要执行或重新启动你选择的终端模拟器：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will make zsh load the function on startup, making it available to your
    session. You can now just type `zmv` and you''ll be greeted with a fairly straightforward
    set of instructions. Basically, the zmv syntax expects two patterns: one for matching
    filenames and a second one into which the results will be converted:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使zsh在启动时加载该函数，使其在会话中可用。现在你只需输入`zmv`，就能看到一套相当简单明了的指令。基本上，zmv语法需要两个模式：一个用于匹配文件名，另一个用于将结果转换成的目标模式。
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you might have guessed, zmv goes along with a great deal of Globbing, which
    is why we are only getting acquainted with it now. Here''s how we can use it to
    rename our `.txt` files into markdown (`.md`):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，zmv涉及大量的Globbing，这就是为什么我们现在才开始了解它。下面是如何用它将`.txt`文件重命名为markdown文件（`.md`）：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We used the verbose `-v` option flag, so we can learn more from the output.
    The `zmv` function works by expanding both patterns and then delegating the actual
    functionality to a more capable command such as `cp`, `ln`, or in this particular
    case, `mv`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了详细的`-v`选项标志，因此我们可以从输出中获取更多信息。`zmv`函数通过展开两个模式，然后将实际功能委托给更强大的命令，如`cp`、`ln`，或者在这个特定情况下，`mv`。
- en: 'You can use the `-W` option to allow automatic conversion of the wildcards.
    Combined with `noglob`, you can add a brand new functionality to the `mv` command,
    which resembles the special behavior of the Windows systems'' `cmd` variant:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-W`选项来自动转换通配符。结合`noglob`选项，你可以为`mv`命令增加一个全新的功能，这类似于Windows系统的`cmd`变体的特殊行为：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can now move files and rename them on the same call:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在同一个调用中移动文件并重命名它们：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As for the rest of the option flags that apply to zmv, here''s a handful of
    the most relevant:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于适用于zmv的其他选项标志，以下是一些最相关的：
- en: '`-f`: Force overwriting of destination files'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：强制覆盖目标文件'
- en: '`-i`: Interactive prompt for each operation'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`：每个操作的交互式提示'
- en: '`-n`: No execution, just print what happens'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`：不执行操作，仅打印将会发生的事情'
- en: '`-v`: Verbose—print a line as it is executed'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`：详细输出—在执行时打印每一行'
- en: '`-w`: Implicitly add parenthesis to wildcards in the pattern'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：在模式中的通配符上隐式添加括号'
- en: '`-W`: Like `-w`, but turn wildcards in replacement patterns into references'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-W`：类似于`-w`，但将替换模式中的通配符转换为引用'
- en: However, don't even think you'll need to remember these. As we'll see in the
    next chapter, you can always use *Tab* for context completion or, in zmv's particular
    case, you can get the full list by simply typing `zmv` and pressing *Return* on
    your terminal. Just know there are at least a couple of options available to you.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，别想你需要记住这些选项。正如我们将在下一章看到的那样，你可以始终使用*Tab*键进行上下文补全，或者在zmv的特殊情况下，你只需输入`zmv`并按*Return*键，就能获得完整的选项列表。只要知道至少有几个选项可供你使用。
- en: Tip
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can do what's popularly known as a dry run by passing the `-n` flag. This
    will make zmv only print out what will be done without actually doing it. This
    is by far the best way of testing and debugging your scripts before… well, you
    know, panic ensues.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递`-n`标志来执行通常所说的干跑操作。这将使zmv仅打印出将要执行的操作，而不真正执行。这是测试和调试脚本的最佳方式，避免了……你知道的，慌乱的发生。
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Should you require more advanced usage, you could use several expressions such
    as the `old_pattern` parameter. Filenames that match these will in turn be grouped
    and accessible by the `new_pattern` expression following the `$1`, `$2`, … pattern.
    For example, we can use the following for recursively renaming pictures on a folder
    tree so that their extensions are all lowercase:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更高级的用法，可以使用多个表达式，例如`old_pattern`参数。匹配这些的文件名将被分组，并可以通过`new_pattern`表达式（按照`$1`、`$2`等模式）访问。例如，我们可以使用以下方法在文件夹树上递归重命名图片，以便它们的扩展名全部为小写：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summing up, with a bit of Globbing and practice, you can get a lot of mileage
    out of your zmv usage. You just need an appropriate pattern to match and a string
    to actually use that pattern. `zmv` will actually ignore any file whose name is
    not changed during expansion and it doesn't even care if the target is supposed
    to be a directory or a simple file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，通过一些Globbing和练习，你可以充分利用zmv。你只需要一个合适的模式来匹配，并且有一个字符串来实际使用该模式。`zmv`实际上会忽略在扩展过程中没有改变名字的文件，它甚至不关心目标是否应该是一个目录还是一个普通文件。
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can access zmv's advanced documentation by typing `man zshcontrib`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入`man zshcontrib`来访问zmv的高级文档。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This is the part of our journey that requires us to pack up our things and
    wrap up the chapter. On this occasion though, we went from using Globbing as something
    we thought was "quite like a regular expression" to understanding what is actually
    a whole different beast. Luckily for us, that beast was pretty easy to tame once
    we learned the behavior of the most popular operators and qualifiers. We then
    expanded on those constructs with more special patterns and got to know **zmv**
    in order to make most of our daily tasks a breeze. Summing up, we can say that
    we:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们旅程的一个阶段，需要我们收拾东西，结束这一章。不过，这次我们从把Globbing当作“像正则表达式一样”的工具开始，最终理解它实际上是完全不同的东西。幸运的是，一旦我们学会了最常用的操作符和限定符的行为，那个“怪兽”就变得相当容易驯服。随后，我们通过更多的特殊模式扩展了这些构造，并且了解了**zmv**，使得我们的大部分日常任务变得轻松自如。总结来说，我们可以说我们：
- en: Learned about quotes, escaping symbols, and double quotes together with shell
    expansion within them
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了引号、转义符号以及双引号与其中的shell扩展。
- en: Got started with Globbing and parameter substitution within the command line
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始了命令行中的全局匹配和参数替换。
- en: Kicked it up a notch and dove headfirst into extended Globbing, learning about
    recursive searching, and operators for negating and excluding patterns
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升了技巧，深入学习了扩展Globbing，了解了递归搜索、否定和排除模式的操作符。
- en: We learned about glob qualifiers, how to use them to discriminate files by the
    system time and size
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了全局限定符，如何使用它们根据系统时间和文件大小来区分文件。
- en: And finally discovered zmv, which lets us put all of the preceding things together
    to make working with complex filenames something like a walk in the park
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后发现了zmv，它让我们将前面提到的所有内容结合起来，让处理复杂的文件名变得像散步一样轻松。
- en: Seems like we have seen a whole lot so far, which will cater to most of our
    needs. Not a bad deal, if I might say so. Actually, I might, as that's one of
    the advantages of wearing the writer's hat.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来到目前为止我们已经学到了很多，这些内容可以满足我们大部分的需求。如果我可以这么说的话，这其实是一个不错的交易。实际上，我可以这么说，因为这正是戴上写作者帽子的一大好处。
- en: The next chapter covers completion. And we have come together quite well so
    far, so I won't lie to you (again); completion is actually what makes most people
    never look back once they try zsh. You have tasted a sample of it so far, but
    there's plenty more waiting for you, right around this page.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍补全功能。到目前为止，我们已经取得了相当不错的进展，所以我不会对你说谎（再一次）；补全实际上就是让大多数人一试成主顾，永不回头的原因。你目前尝试过了一部分，但更多的精彩内容就在这一页等着你。
- en: Next up then is [Chapter 5](ch05.html "Chapter 5. Completion"), *Completion*.
    Hurry up!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是[第五章](ch05.html "Chapter 5. Completion")，*补全*。快点！
