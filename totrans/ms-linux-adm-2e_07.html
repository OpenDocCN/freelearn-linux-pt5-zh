<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-123"><a id="_idTextAnchor139"/>7</h1>
<h1 id="_idParaDest-124"><a id="_idTextAnchor140"/>Networking with Linux</h1>
<p><strong class="bold">Linux networking</strong> is a vast domain. The last few decades have seen countless volumes and references written about Linux <a id="_idIndexMarker896"/>network administration internals. Sometimes, the mere assimilation of essential concepts can be overwhelming for both novice and advanced users. This chapter provides a relatively concise overview of Linux networking, focusing on network communication layers, sockets and ports, network services and protocols, and network security.</p>
<p>We hope that the content presented in this chapter is both a comfortable introduction to basic Linux networking principles for a novice user and a good refresher for an advanced Linux administrator.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Exploring basic networking – focusing on computer networks, networking models, protocols, network addresses, and ports. We’ll also cover some practical aspects of configuring Linux network settings using the command-line Terminal.</li>
<li>Working with network services – introducing common networking servers that run on Linux.</li>
<li>Understanding network security.</li>
</ul>
<h1 id="_idParaDest-125"><a id="_idTextAnchor141"/>Technical requirements</h1>
<p>Throughout this chapter, we’ll be using the Linux command line to some extent. A working Linux distribution, installed on either a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) or a desktop platform, is highly recommended. If you don’t have one already, go back to <a href="B19682_01.xhtml#_idTextAnchor030"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing Linux</em>, which will guide you through the installation process. Most of the commands and examples illustrated in this chapter use Ubuntu and Fedora, but the same would apply to any other Linux platform.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor142"/>Exploring basic networking</h1>
<p>Today, it’s almost inconceivable to imagine a computer not connected to some sort of network or <a id="_idIndexMarker897"/>the internet. Our ever-increasing online presence, cloud computing, mobile communications, and <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) would not <a id="_idIndexMarker898"/>be possible without the highly distributed, high-speed, and scalable networks serving the underlying data traffic; yet the basic networking principles behind the driving force of the modern-day internet are decades old. Networking and communication paradigms will continue to evolve, but some of the original primitives and concepts will still have a long-lasting effect in shaping the building blocks of future communications.</p>
<p>This section will introduce you to a few of these networking essentials and, hopefully, spark your curiosity for further exploration. Let’s start with computer networks.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor143"/>Computer networks</h2>
<p>A <strong class="bold">computer network</strong> is <a id="_idIndexMarker899"/>a group of two or more <a id="_idIndexMarker900"/>computers (or nodes) connected via a physical medium (cable, wireless, optical) and communicating with each other using a standard set of agreed-upon communication protocols. At a very high level, a <strong class="bold">network communication infrastructure</strong> includes<a id="_idIndexMarker901"/> computers, devices, switches, routers, Ethernet or optical cables, wireless environments, and all sorts of network equipment.</p>
<p>Beyond the <em class="italic">physical</em> connectivity and arrangement, networks are also defined by a <em class="italic">logical</em> layout via network topologies, tiers, and the related data flow. An example of a logical <a id="_idIndexMarker902"/>networking hierarchy is the three-tiered layering of the <strong class="bold">demilitarized zone</strong> (<strong class="bold">DMZ</strong>), <em class="italic">firewall</em>, and <em class="italic">internal</em> networks. The DMZ is an organization’s outward-facing network, with an extra security layer against the public internet. A firewall controls the network traffic between the DMZ and the internal network.</p>
<p>Network devices are identified by the following aspects:</p>
<ul>
<li><strong class="bold">Network addresses</strong>: These assist <a id="_idIndexMarker903"/>with locating nodes on the network using <strong class="bold">communication protocols</strong>, such as the <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) (see more on IP in the <em class="italic">TCP/IP protocols</em> section, later in this chapter)</li>
<li><strong class="bold">Hostnames</strong>: These are user-friendly labels associated with devices that are easier to remember than network addresses</li>
</ul>
<p>A common classification criterion looks at the <em class="italic">scale</em> and <em class="italic">expansion</em> of computer networks. Let’s introduce you to <strong class="bold">local area networks</strong> (<strong class="bold">LANs</strong>) and <strong class="bold">wide area </strong><strong class="bold">networks</strong> (<strong class="bold">WANs</strong>):</p>
<ul>
<li><strong class="bold">LANs</strong>: A LAN represents <a id="_idIndexMarker904"/>a group of devices connected and located in a single physical location, such as a private residence, school, or office. A LAN can be of any size, ranging from a home network with only a few devices to large-scale enterprise networks with thousands of users and computers.<p class="list-inset">Regardless of the network’s size, a LAN’s essential characteristic is that it connects devices in a single, limited area. Examples of LANs include the home network of a single-family residence or your local coffee shop’s free wireless service.</p><p class="list-inset">For more <a id="_idIndexMarker905"/>information about LANs, you can refer to <a href="https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html">https://www.cisco.com/c/en/us/products/switches/what-is-a-lan-local-area-network.html</a>.</p><p class="list-inset">When a computer network spans multiple regions or multiple interconnected LANs, WANs come into play.</p></li>
<li><strong class="bold">WANs</strong>: A WAN is usually <a id="_idIndexMarker906"/>a network of networks, with multiple or distributed LANs communicating with each other. In this sense, we regard the internet as the world’s largest WAN. An example of a WAN is the computer network of a multinational company’s geographically distributed offices worldwide. Some WANs are built by service providers, to be leased to various businesses and institutions around the world.<p class="list-inset">WANs have <a id="_idIndexMarker907"/>several variations, depending on their type, range, and use. Typical <a id="_idIndexMarker908"/>examples of WANs <a id="_idIndexMarker909"/>include <strong class="bold">personal area networks</strong> (<strong class="bold">PANs</strong>), <strong class="bold">metropolitan area networks</strong> (<strong class="bold">MANs</strong>), and <strong class="bold">cloud</strong> or <strong class="bold">internet area </strong><strong class="bold">networks</strong> (<strong class="bold">IANs</strong>).</p><p class="list-inset">For more <a id="_idIndexMarker910"/>information about WANs, you can refer to <a href="https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html">https://www.cisco.com/c/en/us/products/switches/what-is-a-wan-wide-area-network.html</a>.</p></li>
</ul>
<p>We think that an adequate introduction to basic networking principles should always include a brief presentation of the theoretical model governing network communications in general. We’ll look at this next.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor144"/>The OSI model</h2>
<p>The <strong class="bold">Open Systems Interconnection</strong> (<strong class="bold">OSI</strong>) model is a theoretical representation of a multilayer <a id="_idIndexMarker911"/>communication mechanism between computer systems <a id="_idIndexMarker912"/>interacting over a network. The OSI model was introduced in 1983 <a id="_idIndexMarker913"/>by the <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO</strong>) to provide a standard for different computer systems to communicate with each other.</p>
<p>We can regard the OSI model as a universal framework for network communications. As the following figure shows, the OSI model defines a stack of seven layers, directing the communication flow:</p>
<div><div><img alt="Figure 7.1 – The OSI model" src="img/B19682_07_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The OSI model</p>
<p>In the layered view shown in the preceding figure, the communication flow moves from top to bottom (on the transmitting <a id="_idIndexMarker914"/>end) or bottom to top (on the receiving end). Before we look at each layer in more detail, let’s briefly explain how the OSI model and data encapsulation and decapsulation work.</p>
<h3>Data encapsulation and decapsulation in the OSI model</h3>
<p>When using the network to transfer data from one computer to another, some specific rules are followed. Inside the OSI model, the network data flows in two different ways. One way is down, from Layer 7 to Layer 1, and this is known as <strong class="bold">data encapsulation</strong>. The other way, up from Layer 1 to Layer 7, is known as <strong class="bold">data decapsulation</strong>. Data encapsulation represents the process of sending data from one computer to another, while data decapsulation represents the process of receiving data. Let’s look at these in greater detail:</p>
<ul>
<li><strong class="bold">Encapsulation</strong>: When sending data, data<a id="_idIndexMarker915"/> from one computer is converted to be sent through the network, and it receives extra information as it is being sent though all the layers of the stack. The application layer (Layer 7) is the place where the user directly interacts with the application. Then, data is sent through the presentation (Layer 6) and session (Layer 5) layers, where data is transformed into a usable format. In the transport layer (Layer 4), data is broken into smaller chunks (segments) and receives a new TCP header. Inside the network layer (Layer 3), the data is called a packet, receives an IP header, and is sent to the data link layer (Layer 2), where it is called a frame and contains both TCP and IP headers. At Layer 2, each frame receives information about the hardware addresses of the source and destination (<strong class="bold">media access control</strong> (<strong class="bold">MAC</strong>) addresses) and information about the protocols to be used in the network layer (created by the <strong class="bold">logical link control</strong> (<strong class="bold">LLC</strong>) data communication protocol). At this point, a new field is added, called <strong class="bold">Frame Check Sequence</strong> (<strong class="bold">FCS</strong>), which is used for checking errors. Then, the frames are passed through the physical layer (Layer 1).</li>
<li><strong class="bold">Decapsulation</strong>: When data is <a id="_idIndexMarker916"/>received, the process is identical, but in reverse order. This starts from the physical layer (Layer 1), where the first synchronization happens, after which the frame is sent through the data link layer (Layer 2), where an error check is done, by verifying the FCS field. This process is called a <strong class="bold">Cyclic Redundancy Check</strong> (<strong class="bold">CRC</strong>). The data, which is now a packet, is sent through all the other layers. Here, the headers that were added during the encapsulation process are stripped off until they reach the upper layers and become ready to be used on the target computer. A graphic explanation is provided in the following figure:</li>
</ul>
<div><div><img alt="Figure 7.2 – Encapsulation and decapsulation in the OSI model" src="img/B19682_07_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Encapsulation and decapsulation in the OSI model</p>
<p>Let’s look at each of these layers in detail and describe their functionality in shaping network communication.</p>
<h3>The physical layer</h3>
<p>The <strong class="bold">physical layer</strong> (or <em class="italic">Layer 1</em>) consists of the networking equipment or infrastructure connecting <a id="_idIndexMarker917"/>the devices and serving the communication, such as cables, wireless or optical environments, connectors, and switches. This layer handles <a id="_idIndexMarker918"/>the conversion between raw bit streams and the communication medium (which includes electrical, radio, or optical signals) while regulating the corresponding bit-rate control.</p>
<p>Examples <a id="_idIndexMarker919"/>of protocols operating at the physical layer include <a id="_idIndexMarker920"/>Ethernet, <strong class="bold">Universal Serial Bus</strong> (<strong class="bold">USB</strong>), and <strong class="bold">Digital Subscriber </strong><strong class="bold">Line</strong> (<strong class="bold">DSL</strong>).</p>
<h3>The data link layer</h3>
<p>The <strong class="bold">data link layer</strong> (or <em class="italic">Layer 2</em>) establishes a reliable data flow between two directly connected <a id="_idIndexMarker921"/>devices on a network, either as adjacent nodes in a WAN or <a id="_idIndexMarker922"/>as devices within a LAN. One of the data link layer’s responsibilities is flow control, adapting to the physical layer’s communication speed. On the receiving device, the data link layer corrects communication errors that originated in the physical layer. The data link layer consists of the following subsystems:</p>
<ul>
<li><strong class="bold">Media access control</strong> (<strong class="bold">MAC</strong>): This <a id="_idIndexMarker923"/>subsystem uses MAC addresses to identify <a id="_idIndexMarker924"/>and connect devices on the network. It also controls the device access permissions to transmit and receive data on the network.</li>
<li><strong class="bold">Logical link control</strong> (<strong class="bold">LLC</strong>): This <a id="_idIndexMarker925"/>subsystem identifies and encapsulates network <a id="_idIndexMarker926"/>layer protocols and performs error checking and frame synchronization while transmitting or receiving data.</li>
</ul>
<p>The protocol <a id="_idIndexMarker927"/>data units controlled by the data link layer are also known as <strong class="bold">frames</strong>. A frame is a data transmission unit that acts as a container for a single network packet. Network packets are processed at the next OSI level (<em class="italic">network layer</em>). When multiple devices access the same physical layer simultaneously, frame collisions may occur. Data link layer protocols can detect and recover from such collisions and further reduce or prevent their occurrence.</p>
<p>There are also Ethernet frames, for example, which are encapsulated data that is defined for MAC implementations. The original IEEE 802.3 Ethernet format, the 802.3 <strong class="bold">SubNetwork Access Protocol</strong> (<strong class="bold">SNAP</strong>), and the<a id="_idIndexMarker928"/> Ethernet II (extended) frame formats are also available.</p>
<p>One more example <a id="_idIndexMarker929"/>of the data link protocol is the <strong class="bold">Point-to-Point Protocol</strong> (<strong class="bold">PPP</strong>), a binary networking protocol that’s used in high-speed broadband communication networks.</p>
<h3>The network layer</h3>
<p>The <strong class="bold">network layer</strong> (or <em class="italic">Layer 3</em>) discovers the optimal communication path (or route) between <a id="_idIndexMarker930"/>devices on a network. This layer uses a routing mechanism based on the IP<em class="italic"> </em>addresses of the devices involved in the data exchange to move <a id="_idIndexMarker931"/>data packets from source to destination.</p>
<p>On the transmitting end, the network layer disassembles the data segments that originated in the <em class="italic">transport layer</em> into network packets. On the receiving end, the data frames are reassembled from the layer below (<em class="italic">data link layer</em>) into packets.</p>
<p>A protocol <a id="_idIndexMarker932"/>that operates at the network layer is the <strong class="bold">Internet Control Message Protocol</strong> (<strong class="bold">ICMP</strong>). ICMP is used by network devices to diagnose network communication issues. ICMP reports an error when a requested endpoint is not available by sending messages such as <em class="italic">destination network unreachable</em>, <em class="italic">timer expired</em>, <em class="italic">source route failed</em>, and others.</p>
<h3>The transport layer</h3>
<p>The <strong class="bold">transport layer</strong> (or <em class="italic">Layer 4</em>) operates <a id="_idIndexMarker933"/>with <strong class="bold">data segments</strong> or <strong class="bold">datagrams</strong>. This layer is <a id="_idIndexMarker934"/>mainly responsible for transferring data from a source to <a id="_idIndexMarker935"/>a destination and guaranteeing a specific <strong class="bold">quality of service</strong> (<strong class="bold">QoS</strong>). On the <a id="_idIndexMarker936"/>transmitting end, data that originated from the layer above (<em class="italic">session layer</em>) is disassembled into segments. On the receiving end, the transport layer reassembles the data packets received from the layer below (<em class="italic">network layer</em>) into segments.</p>
<p>The transport layer maintains the reliability of the data transfer through flow-control and error-control functions. The flow-control function adjusts the data transfer rate between endpoints with different connection speeds, to avoid a sender overwhelming the receiver. When the data received is incorrect, the error-control function may request the retransmission of data.</p>
<p>Examples <a id="_idIndexMarker937"/>of transport layer protocols include the <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) and<a id="_idIndexMarker938"/> the <strong class="bold">User Datagram </strong><strong class="bold">Protocol</strong> (<strong class="bold">UDP</strong>).</p>
<h3>The session layer</h3>
<p>The <strong class="bold">session layer</strong> (or <em class="italic">Layer 5</em>) controls the lifetime of the connection channels (or sessions) between devices communicating on a network. At this layer, sessions or network <a id="_idIndexMarker939"/>connections are usually defined by network addresses, sockets, and ports. We’ll explain each of these concepts in the <em class="italic">Sockets and ports</em> and <em class="italic">IP addresses</em> sections. The session layer <a id="_idIndexMarker940"/>is responsible for the integrity of the data transfer within a communication channel or session. For example, if a session is interrupted, the data transfer resumes from a previous checkpoint.</p>
<p>Some typical <a id="_idIndexMarker941"/>session layer protocols are the <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>) protocol, which is <a id="_idIndexMarker942"/>used by interprocess communications, and <strong class="bold">Network Basic Input/Output System</strong> (<strong class="bold">NetBIOS</strong>), which is a file-sharing and name-resolution protocol.</p>
<h3>The presentation layer</h3>
<p>The <strong class="bold">presentation layer</strong> (or <em class="italic">Layer 6</em>) acts as a data translation tier between the <em class="italic">application layer</em> above and the <em class="italic">session layer</em> below. On the transmitting end, this layer formats <a id="_idIndexMarker943"/>the data into a system-independent representation before sending it across the network. On the receiving end, the presentation <a id="_idIndexMarker944"/>layer transforms the data into an application-friendly format. Examples of such transformations are encryption and decryption, compression and decompression, encoding and decoding, and serialization and deserialization.</p>
<p>Usually, there is no substantial distinction between the presentation and application <a id="_idIndexMarker945"/>layers, mainly <a id="_idIndexMarker946"/>due to the relatively tight coupling of the various <a id="_idIndexMarker947"/>data formats with the applications consuming <a id="_idIndexMarker948"/>them. Standard data representation formats include the <strong class="bold">American Standard Code for Information Interchange</strong> (<strong class="bold">ASCII</strong>), <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>), <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>), <strong class="bold">Joint Photographic Experts Group</strong> (<strong class="bold">JPEG</strong>), ZIP, and others.</p>
<h3>The application layer</h3>
<p>The <strong class="bold">application layer</strong> (or <em class="italic">Layer 7</em>) is the closest to the end user in the OSI model. This layer collects <a id="_idIndexMarker949"/>or provides the input or output of application <a id="_idIndexMarker950"/>data in some meaningful way. This layer does not contain or run the applications themselves. Instead, it acts as an abstraction between applications, implementing a communication component and the underlying network. Typical examples of applications that interact with the application layer are web browsers and email clients.</p>
<p>A <a id="_idIndexMarker951"/>few <a id="_idIndexMarker952"/>examples<a id="_idIndexMarker953"/> of Layer <a id="_idIndexMarker954"/>7 protocols are the DNS protocol, the <strong class="bold">HyperText Transfer Protocol</strong> (<strong class="bold">HTTP</strong>), the <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>), and email messaging <a id="_idIndexMarker955"/>protocols, such as the <strong class="bold">Post Office Protocol</strong> (<strong class="bold">POP</strong>), <strong class="bold">Internet Message Access Protocol</strong> (<strong class="bold">IMAP</strong>), and <strong class="bold">Simple Mail Transfer </strong><strong class="bold">Protocol</strong> (<strong class="bold">SMTP</strong>)<a id="_idIndexMarker956"/>.</p>
<p>Before wrapping up, we should note that the OSI model is a generic representation of networking communication layers and provides the theoretical guidelines for how network communication works. A similar – but more practical – illustration of the networking stack is the TCP/IP model. Both these models <a id="_idIndexMarker957"/>are useful when it comes to network design, implementation, troubleshooting, and diagnostics. The OSI model gives network operators a <a id="_idIndexMarker958"/>good understanding of the full networking stack, from the physical medium to the application layer, and each level has <strong class="bold">Protocol Data Units</strong> (<strong class="bold">PDUs</strong>) and communication internals. However, the TCP/IP model is somewhat <a id="_idIndexMarker959"/>simplified, with a few of the OSI model layers collapsed into one, and it takes a rather protocol-centric approach to network communications. We’ll explore this in more detail in the next section.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor145"/>The TCP/IP network stack model</h2>
<p>The <strong class="bold">TCP/IP model</strong> is a four-layer <a id="_idIndexMarker960"/>interpretation of the OSI networking stack, where some of the equivalent OSI layers appear consolidated, as shown in the following figure:</p>
<div><div><img alt="Figure 7.3 – The OSI and TCP/IP models" src="img/B19682_07_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The OSI and TCP/IP models</p>
<p>Chronologically, the TCP/IP model <a id="_idIndexMarker961"/>is older than the OSI model. It was <a id="_idIndexMarker962"/>first suggested by the US <strong class="bold">Department of Defense</strong> (<strong class="bold">DoD</strong>) as part of an internetwork project developed by the <strong class="bold">Defense Advanced Research Projects Agency</strong> (<strong class="bold">DARPA</strong>). This project eventually became <a id="_idIndexMarker963"/>the modern-day internet.</p>
<p>The TCP/IP model layers encapsulate similar functions to their counterpart OSI layers. Here’s a summary of each layer in the TCP/IP model.</p>
<h3>The network interface layer</h3>
<p>The <strong class="bold">network interface layer</strong> is <a id="_idIndexMarker964"/>responsible for data <a id="_idIndexMarker965"/>delivery over a physical medium (such as wire, wireless, or optical). Networking protocols operating at this layer include Ethernet, Token Ring, and Frame Relay. This layer maps to the composition of the <em class="italic">physical and data link layers</em> in the OSI model.</p>
<h3>The internet layer</h3>
<p>The <strong class="bold">internet layer</strong> provides <em class="italic">connectionless</em> data delivery between nodes on a network. Connectionless protocols describe a network communication pattern where a sender transmits <a id="_idIndexMarker966"/>data to a receiver without a prior arrangement between the two. This layer <a id="_idIndexMarker967"/>is responsible for disassembling data into network packets at the transmitting end and reassembling them on the receiving end. The internet layer uses routing functions to identify the optimal path between the network nodes. This layer maps to the <em class="italic">network layer</em> in the OSI model.</p>
<h3>The transport layer</h3>
<p>The <strong class="bold">transport layer</strong> (also known as the <strong class="bold">transmission layer</strong> or the <strong class="bold">host-to-host layer</strong>) is responsible <a id="_idIndexMarker968"/>for maintaining the communication sessions <a id="_idIndexMarker969"/>between connected network nodes. The transport layer implements error-detection and correction mechanisms for reliable data delivery between endpoints. This layer maps to the <em class="italic">transport layer</em> in the OSI model.</p>
<h3>The application layer</h3>
<p>The <strong class="bold">application layer</strong> provides<a id="_idIndexMarker970"/> the data communication abstraction between software applications <a id="_idIndexMarker971"/>and the underlying network. This layer maps to the composition of the <em class="italic">session, presentation, and application layers</em> in the OSI model.</p>
<p>As discussed earlier in this chapter, the TCP/IP model is a protocol-centric representation of the networking stack. This model served as the foundation of the internet by gradually defining and developing networking protocols required for internet communications. These protocols are collectively referred to as the <em class="italic">IP suite</em>. The following section describes some of the most common networking protocols.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor146"/>TCP/IP protocols</h2>
<p>In this section, we’ll describe some widely used networking protocols. The reference provided here should not <a id="_idIndexMarker972"/>be regarded as an all-encompassing guide. There are a vast number of TCP/IP protocols, and a comprehensive study is beyond the scope of this chapter. Nevertheless, there are a handful of protocols worth exploring, frequently at work in everyday network communication and administration workflows.</p>
<p>The following list briefly describes each TCP/IP protocol and its related <strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) identifier. The RFC represents the detailed technical documentation – of a protocol, in our case – that’s usually authored by the <strong class="bold">Internet Engineering Task Force</strong> (<strong class="bold">IETF</strong>). For more <a id="_idIndexMarker973"/>information <a id="_idIndexMarker974"/>about RFC, please refer to <a href="https://www.ietf.org/standards/rfcs/">https://www.ietf.org/standards/rfcs/</a>. Here are the most widely used protocols:</p>
<ul>
<li><strong class="bold">IP</strong>: IP (<em class="italic">RFC 791</em>) identifies network nodes based on fixed-length addresses, also known as IP addresses. IP addresses <a id="_idIndexMarker975"/>will be described in more <a id="_idIndexMarker976"/>detail in the next section. The IP protocol uses datagrams as the data transmission unit and provides fragmentation and reassembly capabilities of large datagrams to accommodate small-packet networks (and avoid transmission delays). The IP protocol also provides routing functions to find the optimal data path between network nodes. IP operates at the network layer (<em class="italic">Layer 3</em>) in the OSI model.</li>
<li><strong class="bold">ARP</strong>: The <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) (<em class="italic">RFC 826</em>) is used by the IP protocol to map IP <a id="_idIndexMarker977"/>network addresses (specifically, <strong class="bold">IP version 4</strong> or <strong class="bold">IPv4</strong>) to <a id="_idIndexMarker978"/>device MAC <a id="_idIndexMarker979"/>addresses used by a data link protocol. ARP operates at the data link layer (<em class="italic">Layer 2</em>) in the OSI model.</li>
<li><strong class="bold">NDP</strong>: The <strong class="bold">Neighbor Discovery Protocol</strong> (<strong class="bold">NDP</strong>) (<em class="italic">RFC 4861</em>) is like the ARP protocol, and it also <a id="_idIndexMarker980"/>controls <strong class="bold">IP version 6</strong> (<strong class="bold">IPv6</strong>) address mapping. NDP <a id="_idIndexMarker981"/>operates within <a id="_idIndexMarker982"/>the data link layer (<em class="italic">Layer 2</em>) in the OSI model.</li>
<li><strong class="bold">ICMP</strong>: ICMP (<em class="italic">RFC 792</em>) is <a id="_idIndexMarker983"/>a supporting <a id="_idIndexMarker984"/>protocol for checking transmission issues. When a device or node is not reachable within a given timeout, ICMP reports an error. ICMP operates at the network layer (<em class="italic">Layer 3</em>) in the OSI model.</li>
<li><strong class="bold">TCP</strong>: TCP (<em class="italic">RFC 793</em>) is <a id="_idIndexMarker985"/>a connection-oriented, highly <a id="_idIndexMarker986"/>reliable communication protocol. TCP requires a logical connection (such as a <em class="italic">handshake</em>) between the nodes before initiating the data exchange. TCP operates at the transport layer (<em class="italic">Layer 4</em>) in the OSI model.</li>
<li><strong class="bold">UDP</strong>: UDP (<em class="italic">RFC 768</em>) is <a id="_idIndexMarker987"/>a connectionless <a id="_idIndexMarker988"/>communication protocol. UDP has no handshake mechanism (compared to TCP). Consequently, with UDP, there’s no guarantee of data delivery. It is also known as a <em class="italic">best-effort protocol</em>. UDP uses datagrams as the data transmission unit, and it’s suitable for network communications where error checking is not critical. UDP operates at the transport layer (<em class="italic">Layer 4</em>) in the OSI model.</li>
<li><strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>): The DHCP (<em class="italic">RFC 2131</em>) provides a framework for requesting and passing host configuration information <a id="_idIndexMarker989"/>required by devices on a TCP/IP <a id="_idIndexMarker990"/>network. DHCP enables the automatic (dynamic) allocation of reusable IP addresses and other configuration options. DHCP is considered an application layer (<em class="italic">Layer 7</em>) protocol in the OSI model, but the initial DHCP discovery mechanism operates at the data link layer (<em class="italic">Layer 2</em>).</li>
<li><code>dns.google.com</code>) into an IP address (such as <code>8.8.8.8</code>). The DNS protocol operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">HTTP</strong>: HTTP (<em class="italic">RFC 2616</em>) is the vehicular language of the internet. HTTP is a stateless application-level <a id="_idIndexMarker993"/>protocol based <a id="_idIndexMarker994"/>on the request and response between a client application (for example, a browser) and a server endpoint (for example, a web server). HTTP supports a wide variety of data formats, ranging from text to images and video streams. HTTP operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">FTP</strong>: FTP (<em class="italic">RFC 959</em>) is a <a id="_idIndexMarker995"/>standard protocol for transferring files <a id="_idIndexMarker996"/>requested by an FTP client from an FTP server. FTP operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">TELNET</strong>: The <strong class="bold">Terminal Network protocol</strong> (<strong class="bold">TELNET</strong>) (<em class="italic">RFC 854</em>) is an application-layer protocol <a id="_idIndexMarker997"/>that provides a bidirectional <a id="_idIndexMarker998"/>text-oriented network communication between a client and a server machine, using a virtual terminal connection. TELNET operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">SSH</strong>: <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) (<em class="italic">RFC 4253</em>) is a <a id="_idIndexMarker999"/>secure application-layer <a id="_idIndexMarker1000"/>protocol that encapsulates strong encryption and cryptographic host authentication. SSH uses a virtual terminal connection between a client and a server machine. SSH operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">SMTP</strong>: SMTP (<em class="italic">RFC 5321</em>) is <a id="_idIndexMarker1001"/>an application-layer <a id="_idIndexMarker1002"/>protocol for sending and receiving emails between an email client (for example, Outlook) and an email server (such as Exchange Server). SMTP supports strong encryption and host authentication. SMTP acts at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">SNMP</strong>: The <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>) (<em class="italic">RFC 1157</em>) is used for remote <a id="_idIndexMarker1003"/>device management and monitoring. SNMP <a id="_idIndexMarker1004"/>operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
<li><strong class="bold">NTP</strong>: The <strong class="bold">Network Time Protocol</strong> (<strong class="bold">NTP</strong>) (<em class="italic">RFC 5905)</em> is an internet protocol that’s used for synchronizing <a id="_idIndexMarker1005"/>the system clock of multiple <a id="_idIndexMarker1006"/>machines across a network. NTP operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model.</li>
</ul>
<p>Most of the internet protocols enumerated previously use the IP protocol to identify devices participating in the communication. Devices on a network are uniquely identified by an IP address. Let’s examine these network addresses more closely.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor147"/>IP addresses</h2>
<p>An <strong class="bold">IP address</strong> <a id="_idIndexMarker1007"/>is a fixed-length <strong class="bold">unique identifier</strong> (<strong class="bold">UID</strong>) of a device in a network. Devices locate <a id="_idIndexMarker1008"/>and communicate with each other based on IP addresses. The concept of an IP address is very similar to a postal address of a residence, whereby mail or a package would be sent to that destination based on its address.</p>
<p>Initially, IP defined the IP address as a 32-bit number known as an <strong class="bold">IPv4 address</strong>. With the growth of the internet, the total number of IP addresses in a network has been exhausted. To address this issue, a new version of the IP protocol devised a 128-bit numbering scheme for IP addresses. A 128-bit IP address is also known as an <strong class="bold">IPv6 address</strong>.</p>
<p>In the next few sections, we’ll take a closer look at the networking constructs that play an important role in IP addresses, such as IPv4 and IPv6 address formats, network classes, subnetworks, and broadcast addresses.</p>
<h3>IPv4 addresses</h3>
<p>An <code>.</code>). Each number in these four groups is an integer between <code>0</code> and <code>255</code>. An example of an IPv4 address is <code>192.168.1.53</code>.</p>
<p>The following figure shows a binary representation of an IPv4 address:</p>
<div><div><img alt="Figure 7.4 – Network classes" src="img/B19682_07_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Network classes</p>
<p>The IPv4 address <a id="_idIndexMarker1011"/>space is limited to 4,294,967,296 (2^32) addresses (roughly 4 billion). Of these, approximately 18 million are reserved for special purposes (for example, private networks), and about 270 million are multicast addresses.</p>
<p>A <strong class="bold">multicast address</strong> is a logical identifier<a id="_idIndexMarker1012"/> of a group of IP <a id="_idIndexMarker1013"/>addresses. For more information on multicast addresses, please <a id="_idIndexMarker1014"/>refer to <em class="italic">RFC </em><em class="italic">6308</em> (<a href="https://tools.ietf.org/html/rfc6308">https://tools.ietf.org/html/rfc6308</a>).</p>
<h3>Network classes</h3>
<p>In the early stages of the internet, the highest-order byte (first group) in the IPv4 address <a id="_idIndexMarker1015"/>indicated the <strong class="bold">network number</strong>. The subsequent bytes further express the network hierarchy and subnetworks, with the lowest-order <a id="_idIndexMarker1016"/>byte identifying the device itself. This scheme soon proved insufficient for network hierarchies and segregations as it only allowed for 256 (2^8) networks, denoted by the leading byte of the IPv4 address. As additional networks were added, each with its own identity, the IP address specification needed a special revision to accommodate a standard model. The <em class="italic">Classful Network</em> specification, which was introduced in 1981, addressed this problem by dividing the IPv4 address space into five classes based on the leading 4 bits of the address, as illustrated in the following figure:</p>
<div><div><img alt="Figure 7.5 – Network classes" src="img/B19682_07_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Network classes</p>
<p>For more <a id="_idIndexMarker1017"/>information on network classes, please refer to <em class="italic">RFC 870</em> (<a href="https://tools.ietf.org/html/rfc870">https://tools.ietf.org/html/rfc870</a>). In the preceding figure, the last column <a id="_idIndexMarker1018"/>specifies the default subnet mask for each of these <a id="_idIndexMarker1019"/>network classes. We’ll look at subnets (or subnetworks) next.</p>
<h3>Subnetworks</h3>
<p><strong class="bold">Subnetworks</strong> (or <strong class="bold">subnets</strong>) are logical subdivisions of an IP network. Subnets were introduced <a id="_idIndexMarker1020"/>to identify devices that belong <a id="_idIndexMarker1021"/>to the same network. The IP addresses of devices in the same network have an identical most-significant group. The subnet definition yields a logical division of an IP address into two fields: the <strong class="bold">network identifier</strong> and the <strong class="bold">host identifier</strong>. The numerical <a id="_idIndexMarker1022"/>representation of the subnet is called a <strong class="bold">subnet mask</strong> or <strong class="bold">netmask</strong>. The following <a id="_idIndexMarker1023"/>figure provides an example of a network identifier and a host identifier:</p>
<div><div><img alt="Figure 7.6 – Subnet with network and host identifiers" src="img/B19682_07_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Subnet with network and host identifiers</p>
<p>With our IPv4 address (<code>192.168.1.53</code>), we could devise a network identifier of <code>192.168.1</code>, where the host identifier is <code>53</code>. The resulting subnet mask would be as follows:</p>
<pre class="source-code">
192.168.1.0</pre> <p>We dropped the least significant group in the subnet mask, representing the host identifier (<code>53</code>), and replaced it with <code>0</code>. Here, <code>0</code> indicates the starting address in the subnet. In other words, any host identifier value in the range of <code>0</code> to <code>255</code> is allowed in the subnetwork. For example, <code>192.168.1.92</code> is a valid (and accepted) IP address in the <code>192.168.1.0</code> network.</p>
<p>An alternative <a id="_idIndexMarker1024"/>representation of subnets uses so-called <code>/</code>) and the <em class="italic">bit-length</em> of the prefix. In our case, the CIDR notation of the <code>192.168.1.0</code> subnet is this:</p>
<pre class="source-code">
192.168.1.0/24</pre> <p>The first three groups in the network address make up <em class="italic">3 x 8 = 24</em> bits, hence the <code>/</code><code>24</code> notation.</p>
<p>Usually, <code>100</code> and end with <code>125</code>. Let’s look at how we can achieve this.</p>
<p>First, let’s see the binary representation of <code>192.168.1.100</code>:</p>
<pre class="source-code">
11000000.10101000.00000001.<code>100</code>). Remember that we want the network to start with 100 and end with 125. This means that the closest binary value to the reserved 99 addresses that would not be permitted in our subnet is <em class="italic">96 = 64 + 32</em>. The equivalent binary value for it is as follows:</p>
<pre class="source-code">
<code>1</code>. These bits would be added to the 24 already reserved bits of the network address (<code>192.168.1</code>), accounting in total for <em class="italic">27 = 24 + 3</em> bits. Here’s the equivalent representation:</p>
<pre class="source-code">
11111111.11111111.11111111.11100000</pre> <p>Consequently, the resulting netmask is as follows:</p>
<pre class="source-code">
255.255.255.224</pre> <p>The CIDR notation of the corresponding subnet is shown here:</p>
<pre class="source-code">
192.168.1.96/27</pre> <p>The remaining five bits in the host identifier’s group account for <em class="italic">2^5 = 32</em> possible addresses in the subnet, starting with <code>97</code>. This would limit the maximum host identifier value to <em class="italic">127 = 96 + 32 – 1</em> (we subtract 1 to account for the starting number of 97 included in the total of 32). In this range of 32 addresses, the last IP address is reserved as a <strong class="bold">broadcast address</strong>, as shown<a id="_idIndexMarker1028"/> here:</p>
<pre class="source-code">
192.168.1.127</pre> <p>A broadcast <a id="_idIndexMarker1029"/>address is reserved as the highest number in a network <a id="_idIndexMarker1030"/>or subnet, when applicable. Back to our example, excluding the broadcast address, the maximum host IP address in the subnet is as follows:</p>
<pre class="source-code">
192.168.1.126</pre> <p>You can learn <a id="_idIndexMarker1031"/>more about subnets in <em class="italic">RFC 1918</em> (<a href="https://tools.ietf.org/html/rfc1918">https://tools.ietf.org/html/rfc1918</a>). Since we mentioned the broadcast address, let’s have a quick look at it.</p>
<h3>Broadcast addresses</h3>
<p>A <strong class="bold">broadcast address</strong> is a reserved IP address in a network or subnetwork that’s used to transmit a <a id="_idIndexMarker1032"/>collective message (data) to all devices <a id="_idIndexMarker1033"/>belonging to the network. The broadcast address is the last IP address in the network or subnet, when applicable.</p>
<p>For example, the <a id="_idIndexMarker1034"/>broadcast address of the <code>192.168.1.0/24</code> network is <code>192.168.1.255</code>. In our example in the previous section, the broadcast address of the <code>192.168.1.96/27</code> subnet is <code>192.168.1.127</code> (<em class="italic">127 = 96 + 32 – </em><em class="italic">1</em>).</p>
<p>For more information on broadcast addresses, you can refer to <a href="https://www.sciencedirect.com/topics/computer-science/broadcast-address">https://www.sciencedirect.com/topics/computer-science/broadcast-address</a>.</p>
<h3>IPv6 addresses</h3>
<p>An IPv6 <a id="_idIndexMarker1035"/>address is <a id="_idIndexMarker1036"/>a 128-bit number (16 bytes) that’s usually expressed as up to eight groups of 2-byte (16 bits) numbers, separated by a column (<code>:</code>). Each number in these eight groups is a hexadecimal number, with values between <code>0000</code> and <code>FFFF</code>. Here’s an example of an IPv6 address:</p>
<pre class="source-code">
2001:0b8d:8a52:0000:0000:8b2d:0240:7235</pre> <p>An equivalent representation of the preceding IPv6 address is shown here:</p>
<pre class="source-code">
2001:b8d:8a52::8b2d:240:7235/64</pre> <p>In the second representation, the leading zeros are omitted, and the all-zero groups (<code>0000:0000</code>) are collapsed into an empty group (<code>::</code>). The <code>/64</code> notation at the end represents the <code>1</code> and <code>128</code>.</p>
<p>In our case, with a prefix length of 64 (<em class="italic">4 x 16</em>) bits, the subnet looks like this:</p>
<pre class="source-code">
2001:b8d:8a52::</pre> <p>The subnet <a id="_idIndexMarker1038"/>represents the leading four groups (<code>2001</code>, <code>0b8d</code>, <code>8a52</code>, and <code>0000</code>), which results in a total of <em class="italic">4 x 16 = 64</em> bits. In the shortened representation of the IPv6 subnet, the leading <a id="_idIndexMarker1039"/>zeros are omitted and the all-zero group is collapsed to <code>::</code>.</p>
<p>Subnetting with IPv6 is very similar to IPv4. We won’t go into the details here since the related concepts <a id="_idIndexMarker1040"/>were presented in the <em class="italic">IPv4 addresses</em> section. For more information about IPv6, please refer to <em class="italic">RFC </em><em class="italic">2460</em> (<a href="https://tools.ietf.org/html/rfc2460">https://tools.ietf.org/html/rfc2460</a>).</p>
<p>Now that you’ve become familiar with IP addresses, it is fitting to introduce some of the related network constructs that serve the software implementation of IP addresses – that is, sockets and ports.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor148"/>Sockets and ports</h2>
<p>A <strong class="bold">socket</strong> is a <a id="_idIndexMarker1041"/>software data structure representing a network node for communication purposes. Although <a id="_idIndexMarker1042"/>a programming concept, in Linux, a <strong class="bold">network socket</strong> is ultimately <a id="_idIndexMarker1043"/>a file descriptor that’s controlled via a network <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). A socket is used by an application process for transmitting and receiving data. An application can create and delete sockets. A socket cannot be active (send or receive data) beyond the lifetime of the process that created the socket.</p>
<p>Network sockets operate at the <em class="italic">transport-layer</em> level in the OSI model. There are two endpoints to a socket connection – a sender and a receiver. Both the sender and receiver have an IP address. Consequently, a critical piece of information in the socket data structure is the <em class="italic">IP address</em> of the endpoint that owns the socket.</p>
<p>Both endpoints <a id="_idIndexMarker1044"/>create and manage their sockets via the network processes using these sockets. The sender and receiver may agree upon using multiple connections <a id="_idIndexMarker1045"/>to exchange data. Some of these connections may even run in parallel. How do we differentiate between these socket connections? The IP address by itself is not sufficient, and this is where <strong class="bold">ports</strong> come into play.</p>
<p>A <code>0</code> and <code>65535</code>. Usually, ports in the range of <code>0</code> and <code>1024</code> are assigned to the most used services on a system. These <a id="_idIndexMarker1047"/>ports are also called <strong class="bold">well-known ports</strong>. Here are a few examples of well-known ports and the related network service for each:</p>
<ul>
<li><code>25</code>: SMTP</li>
<li><code>21</code>: FTP</li>
<li><code>22</code>: SSH</li>
<li><code>53</code>: DNS</li>
<li><code>67</code>, <code>68</code>: DHCP (client = <code>68</code>, server = <code>67</code>)</li>
<li><code>80</code>: HTTP</li>
<li><code>443</code>: <strong class="bold">HTTP </strong><strong class="bold">Secure</strong> (<strong class="bold">HTTPS</strong>)</li>
</ul>
<p>Port numbers <a id="_idIndexMarker1048"/>beyond <code>1024</code> are for general use and are also <a id="_idIndexMarker1049"/>known as <strong class="bold">ephemeral ports</strong>.</p>
<p>A port is always associated with an IP address. Ultimately, a socket is a combination of an IP address and a port. For more information on network sockets, you <a id="_idIndexMarker1050"/>can refer to <em class="italic">RFC 147</em> (<a href="https://tools.ietf.org/html/rfc147">https://tools.ietf.org/html/rfc147</a>). For <a id="_idIndexMarker1051"/>well-known ports, see <em class="italic">RFC </em><em class="italic">1340</em> (<a href="https://tools.ietf.org/html/rfc1340">https://tools.ietf.org/html/rfc1340</a>).</p>
<p>Now, let’s put the knowledge we’ve gained so far to work by looking at how to configure the local networking stack in Linux.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor149"/>Linux network configuration</h2>
<p>This section describes the TCP/IP <strong class="bold">network configuration</strong> for Ubuntu and Fedora platforms, using <a id="_idIndexMarker1052"/>their latest released versions to date. The same concepts would apply to most Linux distributions, albeit some of the network configuration utilities and files involved could be different.</p>
<p>We can use the <code>ip</code> command-line utility to retrieve the system’s current IP addresses, as follows:</p>
<pre class="console">
ip addr show</pre> <p>An example of the output is shown here:</p>
<div><div><img alt="Figure 7.7 – Retrieving the current IP addresses with the ip command" src="img/B19682_07_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Retrieving the current IP addresses with the ip command</p>
<p>We’ve highlighted some <a id="_idIndexMarker1053"/>relevant information here, such as the network interface ID (<code>2: enp1s0</code>) and the IP address with the subnet prefix (<code>192.168.122.117/24</code>).</p>
<p>We’ll look at Ubuntu’s network configuration next. At the time of writing this book, the released version of Ubuntu is 22.04.2 LTS.</p>
<h3>Ubuntu network configuration</h3>
<p>Ubuntu 22.04 provides the <code>netplan</code> command-line utility for easy<a id="_idIndexMarker1054"/> network configuration. <code>netplan</code> uses a <code>netplan</code> configuration file(s) is in the <code>/etc/netplan/</code> directory, and we can access it by using the following command:</p>
<pre class="console">
ls /etc/netplan/</pre> <p>In our case, the configuration file is <code>00-installer-config.yaml</code>.</p>
<p>Changing the network configuration involves editing the <code>netplan</code> YAML configuration file. As good practice, we should always make a backup of the current configuration file before making changes. Changing a network configuration would most commonly involve setting up either a dynamic or a static IP address. We will show you how to configure both types in the next few sections. We’ll look at dynamic IP addressing first.</p>
<h4>Dynamic IP configuration</h4>
<p>To enable <a id="_idIndexMarker1056"/>a dynamic (DHCP) IP address, we must edit the <code>netplan</code> configuration file and set the <code>dhcp4</code> attribute to <code>true</code> (as shown in <em class="italic">Figure 7</em><em class="italic">.8</em>) for the network interface of our choice (<code>ens33</code>, in our case). Open the <code>00-installer-config.yaml</code> file with your text editor of choice (nano, in our case):</p>
<pre class="console">
sudo nano /etc/netplan/00-installer-config.yaml</pre> <p>Here’s the related configuration excerpt, with the relevant points highlighted:</p>
<div><div><img alt="Figure 7.8 – Enabling DHCP in the netplan configuration" src="img/B19682_07_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Enabling DHCP in the netplan configuration</p>
<p>After saving the configuration file, we can test the related changes with the following command:</p>
<pre class="console">
sudo netplan try</pre> <p>We’ll get the following response:</p>
<div><div><img alt="Figure 7.9 – Testing and accepting the netplan configuration changes" src="img/B19682_07_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Testing and accepting the netplan configuration changes</p>
<p>The <code>netplan</code> keyword validates <a id="_idIndexMarker1057"/>the new configuration and prompts the user to accept the changes. The following command applies the current changes to the system:</p>
<pre class="console">
sudo netplan apply</pre> <p>Next, we will configure a static IP address using <code>netplan</code>.</p>
<h4>Static IP configuration</h4>
<p>To set the <a id="_idIndexMarker1058"/>static IP address of a network interface, we start by editing the <code>netplan</code> configuration YAML file, as follows:</p>
<pre class="console">
sudo nano /etc/netplan/00-installer-config.yaml</pre> <p>Here’s a configuration example with a static IP address of <code>192.168.122.22/24</code>:</p>
<div><div><img alt="Figure 7.10 – Static IP configuration example with netplan" src="img/B19682_07_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Static IP configuration example with netplan</p>
<p>After saving <a id="_idIndexMarker1059"/>the configuration, we can test and accept it, and then apply changes, as we did in the <em class="italic">Dynamic IP</em> section, with the following commands:</p>
<pre class="console">
sudo netplan try
sudo netplan apply</pre> <p>For more information on the <code>netplan</code> command-line utility, see <code>netplan --help</code> or the related system manual (<code>man netplan</code>).</p>
<p>We’ll look <a id="_idIndexMarker1060"/>at the Fedora network configuration next. At the time of writing, the current released version of Fedora is 37.</p>
<h3>Fedora/RHEL network configuration</h3>
<p>Starting with Fedora 33 and RHEL 9, network configuration files are <em class="italic">no longer</em> kept in the <code>/etc/sysconfig/network-scripts/</code> directory. To learn more about the new configuration options, read the<a id="_idIndexMarker1061"/> following file:</p>
<pre class="console">
cat /etc/sysconfig/network-scripts/readme-ifcfg-rh.txt</pre> <p>The preferred method to configure the network in Fedora/RHEL is to use the <code>nmcli</code> utility. This location is deprecated and no longer used by NetworkManager in Fedora; it can still be used, but we do not recommend it. The new NetworkManager keyfiles are stored inside the <code>/</code><code>etc/NetworkManager/system-connections/</code> directory.</p>
<p>Let’s use some basic <code>nmcli</code> commands to view information about our connections. To learn about <code>nmcli</code>, read the related manual pages. First, let’s find information about our active connection using the following command:</p>
<pre class="console">
nmcli connection show</pre> <p>The output will show basic<a id="_idIndexMarker1062"/> information about the name of the connection, UUID, type, and the device used. The following screenshot shows the relevant information on our Fedora 37 VM:</p>
<div><div><img alt="Figure 7.11 – Using nmcli to view connection information" src="img/B19682_07_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Using nmcli to view connection information</p>
<p>Similar to Ubuntu, when using Fedora/RHEL, changing a network configuration would most commonly involve setting up either a dynamic or a static IP address. We will show you how to configure both types in the following sections. Let’s look at dynamic IP addressing first.</p>
<h4>Dynamic IP configuration</h4>
<p>To configure a dynamic IP address using <code>ncmli</code>, we can<a id="_idIndexMarker1063"/> run the following command:</p>
<pre class="console">
sudo nmcli connection modify 'Wired connection 1' ipv4.method auto</pre> <p>The <code>ipv4.method auto</code> directive enables DHCP. There is no output from the command; after execution, you will be returned to the prompt again. You can check if the command worked by viewing the <code>/etc/NetworkManager/system-connections/</code> directory. In our case, there is a new keyfile inside. It has the same name as our connection. The following is an excerpt:</p>
<div><div><img alt="Figure 7.12 – New configuration keyfile" src="img/B19682_07_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – New configuration keyfile</p>
<p>Next, we’ll configure a<a id="_idIndexMarker1064"/> static IP address.</p>
<h4>Static IP configuration</h4>
<p>To perform the equivalent <a id="_idIndexMarker1065"/>static IP address changes using <code>ncmli</code>, we need to run multiple commands. First, we must set the static IP address, as follows:</p>
<pre class="console">
sudo nmcli connection modify 'Wired connection 1' ipv4.address 192.168.122.3/24</pre> <p>If no previous static IP address has been configured, we recommend saving the preceding change before proceeding with the next steps. The changes can be saved with the following code:</p>
<pre class="console">
sudo nmcli connection down 'Wired connection 1'
sudo nmcli connection up 'Wired connection 1'</pre> <p>Next, we must set the gateway and DNS IP addresses, as follows:</p>
<pre class="console">
sudo nmcli connection modify 'Wired connection 1' ipv4.gateway 192.168.122.1
sudo nmcli connection modify 'Wired connection 1' ipv4.dns 8.8.8.8</pre> <p>Finally, we must disable <a id="_idIndexMarker1066"/>DHCP with the following code:</p>
<pre class="console">
sudo nmcli connection modify 'Wired connection 1' ipv4.method manual</pre> <p>After making these changes, we need to restart the <code>'Wired connection 1'</code> network interface with the following code:</p>
<pre class="console">
sudo nmcli connection down 'Wired connection 1'
sudo nmcli connection up 'Wired connection 1'</pre> <p>Now, let’s see the results of all the commands we’ve performed. After bringing the connection up again, let’s check the new IP address and the contents of the network keyfile. The following figure shows the new IP we assigned to the system (<code>192.168.122.3</code>) by using the <code>ip addr </code><code>show</code> command:</p>
<div><div><img alt="Figure 7.13 – Checking the new IP address" src="img/B19682_07_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Checking the new IP address</p>
<p>Now, let’s view the contents of the network keyfile to see the changes that were made for static IP configuration. Remember that the location of the file is <code>/etc/NetworkManager/system-connections/</code>:</p>
<div><div><img alt="Figure 7.14 – New keyfile configuration for the static IP address" src="img/B19682_07_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – New keyfile configuration for the static IP address</p>
<p>The <code>nmcli</code> utility is a powerful and useful one. At the end of this chapter, we will provide you with some useful links<a id="_idIndexMarker1067"/> for learning more about it. Next, we’ll take a look at how to configure network services on openSUSE.</p>
<h3>openSUSE network configuration</h3>
<p>openSUSE provides several tools for network configuration: <strong class="bold">Wicked</strong> and NetworkManager. According to the official SUSE documentation, Wicked is used for all types of machines, from servers to laptops and workstations, whereas NetworkManager is used only for laptop and workstation <a id="_idIndexMarker1068"/>setup and is not used for server setup. However, in openSUSE Leap, Wicked is set up by default on both desktop or server configurations, and NetworkManager is set up by default on laptop configurations.</p>
<p>For example, on our main workstation (which is a laptop), if we want to see which service is running by default on openSUSE Leap, we can use the following command:</p>
<pre class="console">
sudo systemctl status network</pre> <p>The output will show us which service is running, and in our case, it is NetworkManager:</p>
<div><div><img alt="Figure 7.15 – Checking which network service is running in openSUSE" src="img/B19682_07_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Checking which network service is running in openSUSE</p>
<p>When running the same command inside an openSUSE Leap server VM, the result is different. The output shows that Wicked is running by default. The following screenshot shows an example:</p>
<div><div><img alt="Figure 7.16 – Wicked is running inside the openSUSE server" src="img/B19682_07_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – Wicked is running inside the openSUSE server</p>
<p>As a result, we will perform<a id="_idIndexMarker1069"/> all the examples in this section on an openSUSE Leap server VM, thus using Wicked as the default network configuration tool. In the next section, we will configure dynamic IP on an openSUSE machine.</p>
<h4>Dynamic IP configuration</h4>
<p>Before setting anything up, let’s<a id="_idIndexMarker1070"/> check for active connections and devices. We can do this by using the following command:</p>
<pre class="console">
wicked show all</pre> <p>The output will show all the active devices. The following screenshot shows an excerpt from the output on our machine:</p>
<div><div><img alt="Figure 7.17 – Information about active devices" src="img/B19682_07_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – Information about active devices</p>
<p>There are two active connections, one is loopback (<code>lo</code>) and the other is on the ethernet port (<code>eth0</code>). We will only <a id="_idIndexMarker1071"/>show information related to <code>eth0</code>. The location where Wicked stores configuration files in openSUSE is <code>/etc/sysconfig/network</code>. If we do a listing of that directory, we will see that it is already populated with configuration files for existing connections:</p>
<div><div><img alt="Figure 7.18 – Location of the Wicked configuration files" src="img/B19682_07_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – Location of the Wicked configuration files</p>
<p>In our case, and maybe it will be the same for you, the file we are interested in is called <code>ifcfg-eth0</code>; we can open it with a text editor or concatenate it. Let’s take a look at the contents of the file:</p>
<div><div><img alt="Figure 7.19 – Information provided by the configuration file" src="img/B19682_07_19.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – Information provided by the configuration file</p>
<p>As shown in the preceding screenshot, the information provided is rather scarce but relevant. For a more detailed output, we can use the following command:</p>
<pre class="console">
sudo wicked show-config</pre> <p>This will provide much more<a id="_idIndexMarker1072"/> relevant information directly to the monitor. The following screenshot provides an excerpt from our output, with detailed IPv4 DHCP information:</p>
<div><div><img alt="Figure 7.20 – Detailed information provided by Wicked" src="img/B19682_07_20.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Detailed information provided by Wicked</p>
<p>To better understand this output, we recommend reading the <code>config</code> file and, if available, the <code>dhcp</code> files inside the <code>/etc/sysconfig/network</code> directory. These files provide information about specific variables and default parameters needed for configuring the network devices.</p>
<p>Dynamic IP addresses are usually set up by default when installing the operating system. If yours is not configured, all you need to do is create a configuration file inside <code>/etc/sysconfig/network</code> and give it a relevant name based on the device you are using to connect to the network, such as <code>ifcfg-eth0</code>. Inside that file, you will have to provide just three lines, as seen in <em class="italic">Figure 7</em><em class="italic">.19</em>. The following commands are needed for the actions described in this paragraph:</p>
<ul>
<li>Check your device name using the <code>ip </code><code>addr</code> command:<pre class="source-code">
<code>/</code><code>etc/sysconfig/network</code> directory:<pre class="source-code">
<strong class="bold">sudo nano /etc/sysconfig/network/ifcfg-eth0</strong></pre></li> <li>Provide relevant information for the DHCP configuration:<pre class="source-code">
<strong class="bold">BOOTPROTO='dhcp'</strong>
<strong class="bold">STARTMODE='auto'</strong>
<strong class="bold">ZONE=public</strong></pre></li> <li>Restart the Wicked service:<pre class="source-code">
<code>ping</code> command. Here’s an example:<pre class="source-code">
<strong class="bold">ping google.com</strong></pre></li> </ul>
<p>In the following section, we<a id="_idIndexMarker1073"/> will show you how to set up a static IP configuration.</p>
<h4>Static IP configuration</h4>
<p>To set up a static IP configuration, you<a id="_idIndexMarker1074"/> would need to manually provide variables for the configuration files. These files are the same ones that were presented in the previous section. The location of the files is <code>/etc/sysconfig/network</code>. For example, you can create a new file for the <code>eth0</code> device connection and provide the information you want. Let’s look at an example of using our openSUSE Leap server VM. However, before doing this, we advise you to open the manual pages for the <code>ifcfg</code> utility as they provide valuable information on the variables used for this exercise.</p>
<p>Therefore, we will set the <code>ifcfg</code> configuration file as follows:</p>
<ul>
<li>First, we will check for the IP address and the network device name; in our case, the dynamically allocated IP is <code>192.168.122.146</code> and the device’s name is <code>eth0</code>:</li>
</ul>
<div><div><img alt="Figure 7.21 – IP and device information" src="img/B19682_07_21.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – IP and device information</p>
<ul>
<li>Go to the <code>/etc/sysconfig/network</code> directory and edit the <code>ifcfg-eth0</code> file; we will use the following variables<a id="_idIndexMarker1075"/> for static IP configuration:<ul><li><code>BOOTPROTO='static'</code>: This allows us to use a fixed IP address that will be provided by using the IPADDR variable</li><li><code>STARTMODE='auto'</code>: The interface will be automatically enabled on boot</li><li><code>IPADDR='192.168.122.144'</code>: The IP address we choose for the machine</li><li><code>ZONE='public'</code>: The zone used by the <code>firewalld</code> utility</li><li><code>PREFIXLEN='24'</code>: The number of bits in the <code>IPADDR</code> variable</li></ul><p class="list-inset">This will look as follows:</p></li>
</ul>
<div><div><img alt="Figure 7.22 – New variables for static IP configuration" src="img/B19682_07_22.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – New variables for static IP configuration</p>
<ul>
<li>Save the changes to the new file and restart the Wicked daemon:<pre class="source-code">
<strong class="bold">sudo systemctl restart wickedd.service</strong></pre></li> <li>Enable the interface so that the changes appear:<pre class="source-code">
<code>ip addr show</code> command <a id="_idIndexMarker1076"/>again to check for the new IP address:</li>
</ul>
<div><div><img alt="Figure 7.23 – New IP address assigned to eth0" src="img/B19682_07_23.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – New IP address assigned to eth0</p>
<p>At this point, you know how to configure networking devices in all major Linux distributions, using their preferred utilities. We’ve merely scratched the surface of this matter, but we’ve provided sufficient information for you to start working with network interfaces in Linux. For more information, feel free to read the manual pages freely provided with your operating system. In the next section, we will approach the matter of hostname configuration.</p>
<h3>Hostname configuration</h3>
<p>To retrieve <a id="_idIndexMarker1077"/>the current hostname on a Linux machine, we can use either the <code>hostname</code> or <code>hostnamectl</code> command, as follows:</p>
<pre class="console">
hostname</pre> <p>The most convenient way to change the hostname is with the <code>hostnamectl</code> command. We can change the hostname to <code>earth</code> using the <code>set-hostname</code> parameter of the command:</p>
<pre class="console">
sudo hostnamectl set-hostname earth</pre> <p>Let’s verify the hostname change with the <code>hostname</code> command again. You could use the <code>hostnamectl</code> command to verify the hostname. The output of the <code>hostnamectl</code> command provides more detailed information compared to the <code>hostname</code> command, as shown in the following screenshot:</p>
<div><div><img alt="Figure 7.24 – Retrieving the current hostname with the different commands" src="img/B19682_07_24.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.24 – Retrieving the current hostname with the different commands</p>
<p>Alternatively, we <a id="_idIndexMarker1078"/>can use the <code>hostname</code> command to change the hostname <em class="italic">temporarily</em>, as follows:</p>
<pre class="console">
sudo hostname jupiter</pre> <p>However, this change will not survive a reboot unless we also change the hostname in the <code>/etc/hostname</code> and <code>/etc/hosts</code> files. When editing these two files, change your hostname accordingly. The following screenshot shows the succession of commands:</p>
<div><div><img alt="Figure 7.25 – The /etc/hostname and /etc/hosts files" src="img/B19682_07_25.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.25 – The /etc/hostname and /etc/hosts files</p>
<p>After the hostname reconfiguration, a logout followed by a login would usually reflect the changes. Hostnames are important for coherent network management, where each system on the network should have relevant hostnames set up. In the following section, you’ll learn about network services in Linux.</p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor150"/>Working with network services</h1>
<p>In this section, we’ll enumerate some of the most common network services running on Linux. Not all <a id="_idIndexMarker1079"/>the services mentioned here are installed or enabled by default on your Linux platform of choice. <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing</em><em class="italic"> Linux</em>, and <a href="B19682_10.xhtml#_idTextAnchor212"><em class="italic">Chapter 10</em></a>, <em class="italic">Disaster Recovery, Diagnostics, and Troubleshooting</em>, will dive deeper into how to install and configure some of them. Our focus in this section remains on what these network services are, how they work, and the networking protocols they use for communication.</p>
<p>A <strong class="bold">network service</strong> is typically a system <a id="_idIndexMarker1080"/>process that implements application layer (OSI <em class="italic">Layer 7</em>) functionality for data communication purposes. Network services are usually designed as peer-to-peer or client-server architectures.</p>
<p>In peer-to-peer networking, multiple network nodes each run their own equally privileged instance of a network service while sharing and exchanging a common set of data. Take, for example, a network of DNS servers, all sharing and updating their domain name records.</p>
<p>Client-server networking usually involves one or more server nodes on a network and multiple clients communicating with any of these servers. An example of a client-server network service is SSH. An SSH client connects to a remote SSH server via a secure Terminal session, perhaps for remote administration purposes.</p>
<p>Each of the following subsections briefly describes a network service, and we encourage you to explore topics related to these network services in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a> or other relevant titles recommended at the end of this chapter. Let’s start with DHCP servers.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor151"/>DHCP servers</h2>
<p>A <strong class="bold">DHCP server</strong> uses the DHCP protocol to enable devices on a network to request an IP address that’s been <a id="_idIndexMarker1081"/>assigned dynamically. The DHCP protocol was briefly described in the <em class="italic">TCP/IP protocols</em> section earlier in this chapter.</p>
<p>A computer <a id="_idIndexMarker1082"/>or device requesting a DHCP service sends out a broadcast message (or query) on the network to locate a DHCP server, which, in turn, provides the requested IP address and other information. Communication between the DHCP client (device) and the server uses the DHCP protocol.</p>
<p>The DHCP protocol’s initial <em class="italic">discovery</em> workflow between a client and a server operates at the data link layer (<em class="italic">Layer 2</em>) in the OSI model. Since Layer 2 uses network frames as PDUs, the DHCP discovery packets cannot transcend the local network boundary. In other words, a DHCP client can only initiate communication with a <em class="italic">local</em> DHCP server.</p>
<p>After the initial <em class="italic">handshake</em> (on Layer 2), DHCP turns to UDP as its transport protocol, using datagram sockets (<em class="italic">Layer 4</em>). Since UDP is a connectionless protocol, a DHCP client and server exchange messages without a prior arrangement. Consequently, both endpoints (client and server) require a well-known DHCP communication port for the back-and-forth data exchange. These are the well-known ports <code>68</code> (for a DHCP server) and <code>67</code> (for a DHCP client).</p>
<p>A DHCP server maintains a collection of IP addresses and other client configuration data (such as MAC addresses and domain server addresses) for each device on the network requesting a DHCP service.</p>
<p>DHCP servers <a id="_idIndexMarker1083"/>use a <strong class="bold">leasing mechanism</strong> to assign IP addresses dynamically. Leasing an IP address is subject to a <strong class="bold">lease time</strong>, either finite or infinite. When the lease of an IP address expires, the DHCP server may reassign it to a different client upon request. A device would hold on to its dynamic IP address by regularly requesting a <strong class="bold">lease renewal</strong> from the <a id="_idIndexMarker1084"/>DHCP server. Failing to do so would result in the potential loss of the device’s dynamic IP address. A late (or post-lease) DHCP request would possibly result in a new IP address being acquired if the previous address had already been allocated by the DHCP server.</p>
<p>A simple way to query the DHCP server from a Linux machine is by invoking the following command:</p>
<pre class="console">
ip route</pre> <p>This is the output of the preceding command:</p>
<div><div><img alt="Figure 7.26 – Querying the IP route for DHCP information" src="img/B19682_07_26.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.26 – Querying the IP route for DHCP information</p>
<p>The first line of the output provides the DHCP server (<code>192.168.122.1</code>).</p>
<p><a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring Linux Servers</em>, will further go into the practical details of installing and configuring a DHCP server.</p>
<p>For more <a id="_idIndexMarker1085"/>information on DHCP, please refer to <em class="italic">RFC </em><em class="italic">2131</em> (<a href="https://tools.ietf.org/html/rfc2131">https://tools.ietf.org/html/rfc2131</a>).</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor152"/>DNS servers</h2>
<p>A <code>wikipedia.org</code>) into an IP address (such as <code>208.80.154.224</code>). The name-resolution protocol is DNS, briefly described in the <em class="italic">TCP/IP protocols</em> section <a id="_idIndexMarker1088"/>earlier in this chapter. In a DNS-managed TCP/IP network, computers and devices can also identify and communicate with each other via hostnames, not just IP addresses.</p>
<p>As a reasonable analogy, DNS very much resembles an address book. Hostnames are relatively <a id="_idIndexMarker1089"/>easier to remember than IP addresses. Even in a local network, with only a few computers and devices connected, it would be rather difficult to identify (or memorize) any of the hosts by simply using their IP address. The internet relies on a globally distributed network of DNS servers.</p>
<p>There are <a id="_idIndexMarker1090"/>four different types of DNS servers: <strong class="bold">recursive servers</strong>, <strong class="bold">root servers</strong>, <strong class="bold">top-level domain</strong> (<strong class="bold">TLD</strong>) <strong class="bold">servers</strong>, and <strong class="bold">authoritative servers</strong>. All these <a id="_idIndexMarker1091"/>DNS server <a id="_idIndexMarker1092"/>types work together to bring you the internet <a id="_idIndexMarker1093"/>as you experience it in your browser.</p>
<p>A <strong class="bold">recursive DNS server</strong> is a <a id="_idIndexMarker1094"/>resolver that helps you find the destination (IP) of a website you search for. When you perform a lookup operation, a recursive DNS server is connected to different DNS servers to find the IP address that you are looking for and return it to you in the form of a website. Recursive DNS lookups are faster as they cache every query that they perform. In a recursive type of query, the DNS server calls itself and does the recursion while still sending the request to another DNS server to find the answer.</p>
<p>In contrast, an <strong class="bold">iterative DNS</strong> lookup <a id="_idIndexMarker1095"/>is done by every DNS server directly, without using caching. For example, in an iterative query, each DNS server responds with the address of another DNS server, until one of them has the matching IP address for the hostname in question and responds to the client. For more details on DNS server types, please check out the following Cloudflare learning solution: <a href="https://www.cloudflare.com/learning/dns/what-is-dns/">https://www.cloudflare.com/learning/dns/what-is-dns/</a>.</p>
<p>DNS servers <a id="_idIndexMarker1096"/>maintain (and possibly share) a <a id="_idIndexMarker1097"/>collection of <code>/etc/resolv.conf</code>.</p>
<p>To query <a id="_idIndexMarker1099"/>the DNS server managing the local machine, we can query the <code>/etc/resolv.conf</code> file by running the following code:</p>
<pre class="console">
cat /etc/resolv.conf | grep nameserver</pre> <p>The preceding code <a id="_idIndexMarker1100"/>yields the following output:</p>
<div><div><img alt="Figure 7.27 – Querying DNS server using /etc/resolv.conf" src="img/B19682_07_27.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.27 – Querying DNS server using /etc/resolv.conf</p>
<p>A simple way to query name-server data for an arbitrary host on a network is by using the <code>nslookup</code> tool. If you don’t have the <code>nslookup</code> utility installed on your system, you may do so with the commands outlined here.</p>
<p>On Ubuntu/Debian, run the following command:</p>
<pre class="console">
sudo apt install dnsutils</pre> <p>On Fedora, run this command:</p>
<pre class="console">
sudo dnf install bind-utils</pre> <p>For example, to query the name-server information for a computer named <code>neptune.local</code> in our local network, we can run the following command:</p>
<pre class="console">
nslookup neptune.local</pre> <p>The output is shown here:</p>
<div><div><img alt="Figure 7.28 – Querying name-server information with nslookup" src="img/B19682_07_28.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.28 – Querying name-server information with nslookup</p>
<p>We can also use the <code>nslookup</code> tool interactively. For example, to query the name-server information for <code>wikipedia.org</code>, we can simply run the following command:</p>
<pre class="console">
nslookup</pre> <p>Then, in the interactive prompt, we must enter <code>wikipedia.org</code>, as illustrated here:</p>
<div><div><img alt="Figure 7.29 – Using the nslookup tool interactively" src="img/B19682_07_29.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.29 – Using the nslookup tool interactively</p>
<p>To exit <a id="_idIndexMarker1101"/>the interactive shell mode, press <em class="italic">Ctrl</em> + <em class="italic">C</em>. Here’s a <a id="_idIndexMarker1102"/>brief explanation of the information shown in the preceding output:</p>
<ul>
<li><code>127.0.0.53</code>) and port (<code>53</code>) of the DNS server running locally</li>
<li><code>wikipedia.org</code>)</li>
<li><code>91.198.174.192</code>) and IPv6 (<code>2620:0:862:ed1a::1</code>) addresses that correspond to the lookup domain (<code>wikipedia.org</code>)</li>
</ul>
<p><code>nslookup</code> is also capable of reverse DNS search when providing an IP address. The following command retrieves the name server (<code>dns.google</code>) corresponding to the IP address <code>8.8.8.8</code>:</p>
<pre class="console">
nslookup 8.8.8.8</pre> <p>The preceding command yields the following output:</p>
<div><div><img alt="Figure 7.30 – Reverse DNS search with nslookup" src="img/B19682_07_30.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.30 – Reverse DNS search with nslookup</p>
<p>For more information on the <code>nslookup</code> tool, you can refer to the <code>nslookup</code> system reference manual (<code>man nslookup</code>).</p>
<p>Alternatively, we can use the <code>dig</code> command-line utility. If you don’t have the <code>dig</code> utility installed on your system, you can do so by installing the <code>dnsutils</code> package on Ubuntu/Debian or <code>bind-utils</code> on Fedora platforms. The related commands for installing the packages <a id="_idIndexMarker1103"/>were shown previously with <code>nslookup</code>.</p>
<p>For example, the <a id="_idIndexMarker1104"/>following command retrieves the name-server information for the <code>google.com</code> domain:</p>
<pre class="console">
dig google.com</pre> <p>This is the result (see the highlighted <code>ANSWER SECTION</code>):</p>
<div><div><img alt="Figure 7.31 – DNS lookup with dig" src="img/B19682_07_31.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.31 – DNS lookup with dig</p>
<p>To perform <a id="_idIndexMarker1105"/>a reverse DNS lookup with <code>dig</code>, we must specify the <code>-x</code> option, followed <a id="_idIndexMarker1106"/>by an IP address (for example, <code>8.8.4.4</code>), as follows:</p>
<pre class="console">
dig -x 8.8.4.4</pre> <p>This command yields the following output (see the highlighted <code>ANSWER SECTION</code>):</p>
<div><div><img alt="Figure 7.32 – Reverse DNS lookup with dig" src="img/B19682_07_32.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.32 – Reverse DNS lookup with dig</p>
<p>For more <a id="_idIndexMarker1107"/>information about the <code>dig</code> command-line utility, please refer to the related system manual (<code>man dig</code>).</p>
<p>The DNS protocol <a id="_idIndexMarker1108"/>operates at the application layer (<em class="italic">Layer 7</em>) in the OSI model. The standard DNS service’s well-known port is <code>53</code>.</p>
<p><a href="B19682_08.xhtml#_idTextAnchor164"><em class="italic">Chapter 8</em></a>, <em class="italic">Linux </em><em class="italic">Shell Scripting</em>, will cover the practical details of installing and configuring a DNS server in more detail. For more information on DNS, you can refer to <em class="italic">RFC </em><em class="italic">1035</em> (<a href="https://www.ietf.org/rfc/rfc1035.txt">https://www.ietf.org/rfc/rfc1035.txt</a>).</p>
<p>The DHCP and DNS network services are arguably the closest to the TCP/IP networking stack while playing a crucial role when computers or devices are attached to a network. After all, without proper IP addressing and name resolution, there’s no network communication.</p>
<p>There’s a lot more to distributed networking and related application servers than just strictly the pure network management stack performed by DNS and DHCP servers. In the following sections, we’ll take a quick tour of some of the most relevant application servers running across distributed Linux systems.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor153"/>Authentication servers</h2>
<p>Standalone Linux systems typically use the default authentication mechanism, where user credentials <a id="_idIndexMarker1109"/>are stored in the local filesystem (such as <code>/etc/passwd</code> and <code>/etc/shadow</code>). We explored the related user authentication <a id="_idIndexMarker1110"/>internals in <a href="B19682_04.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing </em><em class="italic">Users and Groups</em>. However, as we extend the authentication boundary beyond the local machine – for example, accessing a file or email server – having the user credentials shared between the remote and localhosts would become a serious security issue.</p>
<p>Ideally, we should have a centralized authentication endpoint across the network that’s handled by a secure authentication server. User credentials should be validated using robust encryption mechanisms before users can access remote system resources.</p>
<p>Let’s consider <a id="_idIndexMarker1111"/>the secure access to a network share on an arbitrary file server. Suppose the access requires <strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) user authentication. Creating the related mount (share) locally on a user’s client machine will prompt for <a id="_idIndexMarker1112"/>user credentials. The authentication request is made by the file server (on behalf of the client) to an authentication server. If the authentication succeeds, the server share becomes available to the client. The following diagram represents a simple remote authentication flow between a client and a server, using a <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) authentication endpoint:</p>
<div><div><img alt="Figure 7.33 – Authentication workflow with LDAP" src="img/B19682_07_33.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.33 – Authentication workflow with LDAP</p>
<p>Here are some examples <a id="_idIndexMarker1113"/>of standard secure authentication <a id="_idIndexMarker1114"/>platforms (available for Linux):</p>
<ul>
<li><strong class="bold">Kerberos</strong> (<a href="https://web.mit.edu/kerberos/">https://web.mit.edu/kerberos/</a>)</li>
<li><strong class="bold">LDAP</strong> (<a href="https://www.redhat.com/en/topics/security/what-is-ldap-authentication">https://www.redhat.com/en/topics/security/what-is-ldap-authentication</a>)</li>
<li><strong class="bold">Remote Authentication Dial-In User Service</strong> (<strong class="bold">RADIUS</strong>) (<a href="https://freeradius.org/documentation/">https://freeradius.org/documentation/</a>)</li>
<li><strong class="bold">Diameter</strong> (<a href="https://www.f5.com/glossary/diameter-protocol">https://www.f5.com/glossary/diameter-protocol</a>)</li>
<li><strong class="bold">Terminal Access Controller Access-Control System</strong> (<strong class="bold">TACACS+</strong>) (<a href="https://datatracker.ietf.org/doc/rfc8907/">https://datatracker.ietf.org/doc/rfc8907/</a>)</li>
</ul>
<p><a id="_idIndexMarker1115"/>A Linux LDAP authentication server can be <a id="_idIndexMarker1116"/>configured using OpenLDAP, which was covered in the first edition of this book.</p>
<p>In this section, we illustrated the authentication workflow with an example of using a file server. To remain on topic, we’ll look at network file-sharing services next.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor154"/>File sharing</h2>
<p>In common networking terms, <strong class="bold">file sharing</strong> represents a client machine’s ability to <em class="italic">mount</em> and access <a id="_idIndexMarker1117"/>a remote filesystem belonging to a server, as if it were local. Applications running on the client machine would access the shared files <a id="_idIndexMarker1118"/>directly on the server. For example, a text editor can load and modify a remote file, and then save it back to the same remote location, all in a seamless and transparent operation. The underlying remoting process – the appearance of a remote filesystem acting as local – is made possible by file-sharing services and protocols.</p>
<p>For every file-sharing network protocol, there is a corresponding client-server file-sharing platform. Although most network file servers (and clients) have cross-platform implementations, some operating system platforms are better suited for specific file-sharing protocols, as we’ll see in the following subsections. Choosing between different file-server implementations and protocols is ultimately a matter of compatibility, security, and performance.</p>
<p>Here are some of the most common file-sharing protocols, with some brief descriptions for each:</p>
<ul>
<li><strong class="bold">Server Message Block</strong> (<strong class="bold">SMB</strong>): The SMB protocol provides network discovery and file- and printer-sharing <a id="_idIndexMarker1119"/>services. SMB also supports <a id="_idIndexMarker1120"/>interprocess communication over a network. SMB <a id="_idIndexMarker1121"/>is a relatively old protocol, developed by <strong class="bold">International Business Machines Corporation</strong> (<strong class="bold">IBM</strong>) in the 1980s. Eventually, Microsoft took over and made some considerable alterations to what became the current version through multiple revisions (SMB 1.0, 2.0, 2.1, 3.0, 3.0.2, and 3.1.1).</li>
<li><strong class="bold">Common Internet File System</strong> (<strong class="bold">CIFS</strong>): This protocol is a particular implementation of the SMB protocol. Due to the underlying protocol similarity, SMB clients can <a id="_idIndexMarker1122"/>communicate with CIFS servers and vice versa. Though <a id="_idIndexMarker1123"/>SMB and CIFS are idiomatically the same, their internal implementation of file locking, batch processing, and – ultimately – performance is quite different. Apart from legacy systems, CIFS is rarely used these days. SMB should always be preferred over CIFS, especially with the more recent revisions of SMB 2 or SMB 3.</li>
<li><strong class="bold">Samba</strong>: As with CIFS, Samba is another <a id="_idIndexMarker1124"/>implementation of the SMB protocol. Samba provides file- and print-sharing services for Windows clients on a variety of server <a id="_idIndexMarker1125"/>platforms. In other words, Windows clients can seamlessly access directories, files, and printers on a Linux Samba server, just as if they were communicating with a Windows server.<p class="list-inset">As of version 4, Samba natively supports Microsoft AD and Windows NT domains. Essentially, a Linux Samba server can act as a domain controller on a Windows AD network. Consequently, user credentials on the Windows domain can transparently be used on the Linux server without being recreated, and then manually kept in sync with the AD users.</p></li>
<li><strong class="bold">Network File System</strong> (<strong class="bold">NFS</strong>): This protocol was developed by Sun Microsystems and essentially <a id="_idIndexMarker1126"/>operates on the same premise as SMB – accessing <a id="_idIndexMarker1127"/>files over a network as if they were local. NFS is not compatible with CIFS or SMB, meaning that NFS clients cannot communicate directly with SMB servers or vice versa.</li>
<li><strong class="bold">Apple Filing Protocol</strong> (<strong class="bold">AFP</strong>): The AFP is <a id="_idIndexMarker1128"/>a proprietary <a id="_idIndexMarker1129"/>file-sharing protocol designed by Apple and exclusively operates in macOS network environments. We should note that besides AFP, macOS systems also support standard file-sharing protocols, such as SMB and NFS.</li>
</ul>
<p>Most of the time, NFS is the file-sharing protocol of choice within Linux networks. For mixed networking environments – such as Windows, Linux, and macOS interoperability – Samba and SMB are best suited for file sharing.</p>
<p>Some file-sharing protocols (such as SMB) also support print sharing and are used by print servers. We’ll take a closer look at print sharing next.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor155"/>Printer servers</h2>
<p>A <strong class="bold">printer server</strong> (or <strong class="bold">print server</strong>) connects a printer to client machines (computers or mobile devices) on <a id="_idIndexMarker1130"/>a network using a printing protocol. Printing <a id="_idIndexMarker1131"/>protocols are responsible for the following remote printing tasks over a network:</p>
<ul>
<li>Discovering printers or print servers</li>
<li>Querying printer status</li>
<li>Sending, receiving, queueing, or canceling print jobs</li>
<li>Querying print job status</li>
</ul>
<p>Common <a id="_idIndexMarker1132"/>printing protocols include the following:</p>
<ul>
<li><strong class="bold">Line Printer Daemon</strong> (<strong class="bold">LPD</strong>) protocol</li>
<li><strong class="bold">Generic protocols</strong>, such as SMB and TELNET</li>
<li><strong class="bold">Wireless printing</strong>, such as AirPrint by Apple</li>
<li><strong class="bold">Internet printing protocols</strong>, such as Google Cloud Print</li>
</ul>
<p>Among the generic printing protocols, SMB (also a file-sharing protocol) was previously described in the <em class="italic">File sharing</em> section. The TELNET communication protocol was described in the <em class="italic">Remote </em><em class="italic">access</em> section.</p>
<p>File- and printer-sharing services are mostly about <em class="italic">sharing</em> documents, digital or printed, between computers on a network. When it comes to <em class="italic">exchanging</em> documents, additional network services come into play, such as <em class="italic">file transfer</em> and <em class="italic">email</em> services. We’ll look at file transfer next.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor156"/>File transfer</h2>
<p>FTP is a standard network protocol for transferring files between computers on a network. FTP operates in a client-server environment, where an FTP client initiates a remote <a id="_idIndexMarker1133"/>connection to an FTP server, and files are <a id="_idIndexMarker1134"/>transferred in either direction. FTP maintains a <code>21</code>, and it’s used for exchanging commands between the client and the server. Data connections are exclusively used for data transfer and are negotiated between the client and the server (through the control connection). Data connections usually involve ephemeral ports for inbound traffic, and they only stay open during the actual data transfer, closing immediately after the transfer completes.</p>
<p>FTP negotiates data connections in one of the following two modes:</p>
<ul>
<li><code>PORT</code> command to the<a id="_idIndexMarker1136"/> FTP server, signaling that the client <em class="italic">actively</em> provides the inbound port number for data connections</li>
<li><code>PASV</code> command to the FTP server, indicating that the client <em class="italic">passively</em> awaits the server to supply the port <a id="_idIndexMarker1138"/>number for inbound data connections</li>
</ul>
<p>FTP is a relatively <em class="italic">messy</em> protocol when it comes to firewall configurations due to the dynamic nature of the data connections involved. The control connection port is usually well known (such as port <code>21</code> for insecure FTP) but data connections originate on a different port (usually <code>20</code>) on either side, while on the receiving end, the inbound sockets are opened within a preconfigured ephemeral range (<code>1024</code> to <code>65535</code>).</p>
<p>FTP is most often implemented securely through either of the following approaches:</p>
<ul>
<li><code>990</code>.</li>
<li><code>22</code>. For more information on the SSH protocol and client-server connectivity, refer to <em class="italic">SSH</em> in the <em class="italic">Remote access</em> section, later in this chapter.</li>
</ul>
<p>Next, we’ll <a id="_idIndexMarker1141"/>look at <a id="_idIndexMarker1142"/>mail servers and the underlying email exchange protocols.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor157"/>Mail servers</h2>
<p>A <strong class="bold">mail server</strong> (or <strong class="bold">email server</strong>) is responsible for email delivery over a network. A mail server can <a id="_idIndexMarker1143"/>either exchange emails between clients (users) on the <a id="_idIndexMarker1144"/>same network (domain) – within a company or organization – or deliver emails to other mail servers, possibly beyond the local network, such as the internet.</p>
<p>An email exchange usually involves the following actors:</p>
<ul>
<li>An <strong class="bold">email client</strong> application (such as Outlook or Gmail)</li>
<li>One or more <strong class="bold">mail servers</strong> (Exchange or Gmail server)</li>
<li>The <strong class="bold">recipients</strong> involved in the email exchange – a <em class="italic">sender</em> and one or more <em class="italic">receivers</em></li>
<li>An <strong class="bold">email protocol</strong> that controls the communication between the email client and the mail servers</li>
</ul>
<p>The most used email protocols are <strong class="bold">POP3</strong>, <strong class="bold">IMAP</strong>, and <strong class="bold">SMTP</strong>. Let’s take a closer look at each of these protocols.</p>
<h3>POP3</h3>
<p><strong class="bold">POP version 3</strong> (<strong class="bold">POP3</strong>) is a standard email protocol for receiving and downloading emails from <a id="_idIndexMarker1145"/>a remote mail server to a local email client. With POP3, emails are available for reading offline. After being downloaded, emails are usually <a id="_idIndexMarker1146"/>removed from the POP3 server, thus saving up space. Modern-day POP3 mail client-server implementations (Gmail, Outlook, and others) also have the option of keeping email copies on the server. Persisting emails on the POP3 server becomes very important when users access emails from multiple locations (client applications).</p>
<p>The default POP3 ports are outlined here:</p>
<ul>
<li><code>110</code>: For insecure (non-encrypted) POP3 connections</li>
<li><code>995</code>: For secure POP3 using SSL/TLS encryption</li>
</ul>
<p>POP3 is a relatively old email protocol that’s not always suitable for modern-day email communications. When users access their emails from multiple devices, IMAP is a better choice. We’ll look at the IMAP email protocol next.</p>
<h3>IMAP</h3>
<p>IMAP is a <a id="_idIndexMarker1147"/>standard email protocol for accessing emails on a remote <a id="_idIndexMarker1148"/>IMAP mail server. With IMAP, emails are always retained on the mail server, while a copy of the emails is available for IMAP clients. A user can access emails on multiple devices, each with their IMAP client application.</p>
<p>The default IMAP ports are outlined here:</p>
<ul>
<li><code>143</code>: For insecure (non-encrypted) IMAP connections</li>
<li><code>993</code>: For secure IMAP using SSL/TLS encryption</li>
</ul>
<p>Both POP3 and IMAP are standard protocols for receiving emails. To send emails, SMTP comes into play. We’ll take a look at the SMTP email protocol next.</p>
<h3>SMTP</h3>
<p>SMTP is a <a id="_idIndexMarker1149"/>standard email protocol for sending <a id="_idIndexMarker1150"/>emails over a network or the internet.</p>
<p>The default SMTP ports are outlined here:</p>
<ul>
<li><code>25</code>: For insecure (non-encrypted) SMTP connections</li>
<li><code>465</code> or <code>587</code>: For secure SMTP using SSL/TLS encryption</li>
</ul>
<p>When using or implementing any of the standard email protocols described in this section, it is always recommended to use the corresponding secure implementation with the most up-to-date TLS encryption, if possible. POP3, IMAP, and SMTP also support user authentication, an added layer of security – this is also recommended in commercial or enterprise-grade environments.</p>
<p>To get an idea of how the SMTP protocol operates, let’s go through some of the initial steps for initiating an SMTP handshake with Google’s Gmail SMTP server.</p>
<p>We will start by <a id="_idIndexMarker1151"/>connecting to the Gmail SMTP server, using a secure (TLS) connection via the <code>openssl</code> command, as follows:</p>
<pre class="source-code">
openssl s_client -starttls smtp -connect smtp.gmail.com:587</pre> <p>Here, we invoked <a id="_idIndexMarker1152"/>the <code>openssl</code> command, simulated a client (<code>s_client</code>), started a TLS SMTP connection (<code>-starttls smtp</code>), and connected to the remote Gmail SMTP server on port <code>587</code> <code>(-</code><code>connect smtp.gmail.com:587</code>).</p>
<p>The Gmail SMTP server responds with a relatively long TLS handshake block that ends with the following code:</p>
<div><div><img alt="Figure 7.34 – Initial TLS handshake with a Gmail SMTP server" src="img/B19682_07_34.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.34 – Initial TLS handshake with a Gmail SMTP server</p>
<p>While still inside the <code>openssl</code> command’s interactive prompt, we initiate the SMTP communication with a <code>HELO</code> command (spelled precisely as such). The <code>HELO</code> command <em class="italic">greets</em> the server. It is a specific SMTP command that starts the SMTP connection between a client and a server. There is also an <code>EHLO</code> variant, which is used for ESMTP service extensions. Google expects the following <code>HELO</code> greeting:</p>
<pre class="console">
HELO hellogoogle</pre> <p>Another handshake follows, ending with <code>250 smtp.gmail.com at your service</code>, as illustrated here:</p>
<div><div><img alt="Figure 7.35 – The Gmail SMTP server is ready for communication" src="img/B19682_07_35.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.35 – The Gmail SMTP server is ready for communication</p>
<p>Next, the Gmail SMTP server requires authentication via the <code>AUTH LOGIN</code> SMTP command. We won’t go into further details, but the key point to be made here is that the SMTP protocol follows a plaintext command sequence between the client and the server. It’s very <a id="_idIndexMarker1153"/>important to adopt a secure (encrypted) SMTP communication channel using TLS. The same applies to any of the other email protocols (POP3 and IMAP).</p>
<p>So far, we’ve <a id="_idIndexMarker1154"/>covered several network services, some of them spanning multiple networks or even the internet. Network packets carry data and destination addresses within the payload, but there are also synchronization signals between the communication endpoints, mostly to discern between sending and receiving workflows. The synchronization of network packets is based on timestamps. Reliable network communications would not be possible without a highly accurate time-synchronization between network nodes. We’ll look at network timekeepers next.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor158"/>NTP servers</h2>
<p>NTP is a <a id="_idIndexMarker1155"/>standard networking protocol for clock synchronization <a id="_idIndexMarker1156"/>between computers on a network. NTP attempts to synchronize <a id="_idIndexMarker1157"/>the system clock on participating computers within a few milliseconds of <strong class="bold">Coordinated Universal Time</strong> (<strong class="bold">UTC</strong>) – the world’s time reference.</p>
<p>The NTP protocol’s implementation usually assumes a client-server model. An NTP server acts as a time source on the network by either broadcasting or sending updated <strong class="bold">timestamp datagrams</strong> to clients. An <a id="_idIndexMarker1158"/>NTP server continually adjusts its system clock according to well-known accurate time servers worldwide, using specialized algorithms to mitigate network latency.</p>
<p>A relatively easy way to check the NTP synchronization status on our Linux platform of choice is <a id="_idIndexMarker1159"/>by using the <code>ntpstat</code> utility. <code>ntpstat</code> may not be <a id="_idIndexMarker1160"/>installed by default on our system. On Ubuntu, we can install it with the following command:</p>
<pre class="console">
sudo apt install ntpstat</pre> <p>On Fedora, we can install <code>ntpstat</code> with the following command:</p>
<pre class="console">
sudo dnf install ntpstat</pre> <p><code>ntpstat</code> requires an NTP server to be running locally. To set up a local NTP server, you will need to do the following (all examples shown here are for Ubuntu 22.04.2 LTS):</p>
<ul>
<li>Install the <code>ntp</code> package with the following command:<pre class="source-code">
<code>ntp</code> service’s status:<pre class="source-code">
<code>ntp</code> service:<pre class="source-code">
<strong class="bold">sudo systemctl enable ntp</strong></pre></li> <li>Modify the firewall settings:<pre class="source-code">
<code>ntpdate</code> package:<pre class="source-code">
<code>ntp</code> service:<pre class="source-code">
<strong class="bold">sudo systemctl restart ntp</strong></pre></li> </ul>
<p>Before installing the <code>ntp</code> utility, take into account that Ubuntu is using another tool instead of <code>ntpd</code> by default, named <code>timesyncd</code>. When installing <code>ntpd</code>, the default utility will be disabled.</p>
<p>To query the NTP <a id="_idIndexMarker1161"/>synchronization status, we can run the following <a id="_idIndexMarker1162"/>command:</p>
<pre class="console">
ntpstat</pre> <p>This is the output:</p>
<div><div><img alt="Figure 7.36 – Querying the NTP synchronization status with ntpstat" src="img/B19682_07_36.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.36 – Querying the NTP synchronization status with ntpstat</p>
<p><code>ntpstat</code> provides the IP address of the NTP server the system is synchronized with (<code>31.209.85.242</code>), the synchronization margin (<code>29</code> milliseconds), and the time-update polling interval (<code>64</code> seconds). To find out more about the NTP server, we can <code>dig</code> its IP address with the following command:</p>
<pre class="console">
dig -x 31.209.85.242</pre> <p>It looks like it’s one of the <code>lwlcom</code> time servers (<code>ntp1.lwlcom.net</code>), as shown here:</p>
<div><div><img alt="Figure 7.37 – Querying the NTP synchronization status with ntpstat" src="img/B19682_07_37.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.37 – Querying the NTP synchr<a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">onization status with ntpstat</a></p>
<p><a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">The NTP client-server</a> communication uses UDP as the transport protocol on port <code>123</code>. <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing</em><em class="italic"> Linux</em>, has a section dedicated to installing and configuring <a id="_idIndexMarker1163"/>an NTP server. For more information on NTP, you can refer to <a href="https://en.wikipedia.org/wiki/Network_Time_Protocol">https://en.wikipedia.org/wiki/Network_Time_Protocol</a>.</p>
<p>With that, our brief <a id="_idIndexMarker1164"/>journey into networking servers and protocols <a id="_idIndexMarker1165"/>has come to an end. Everyday Linux administration tasks often require some sort of remote access to a system. There are many ways to access and manage computers remotely. The next section describes some of the most common remote-access facilities and related network protocols.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor159"/>Remote access</h2>
<p>Most Linux <a id="_idIndexMarker1166"/>network services provide a relatively <a id="_idIndexMarker1167"/>limited <strong class="bold">remote management</strong> interface, with their management <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) utilities predominantly operating locally on the <a id="_idIndexMarker1168"/>same system where the service runs. Consequently, the related administrative tasks assume local Terminal access. Direct console access to the system is sometimes not possible. This is when remote-access servers come into play to enable a virtual Terminal login session with the remote machine.</p>
<p>Let’s look at some of the most common remote-access services and applications.</p>
<h3>SSH</h3>
<p>SSH is perhaps the most popular secure login protocol for remote access. SSH uses strong <a id="_idIndexMarker1169"/>encryption, combined with user authentication <a id="_idIndexMarker1170"/>mechanisms, for secure communication between a client and a server machine. SSH servers are relatively easy to install and configure, and the <em class="italic">Setting up an SSH server</em> section in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring Linux Servers</em>, is dedicated to describing the related steps. The default network port for SSH is <code>22</code>.</p>
<p>SSH supports the following authentication types:</p>
<ul>
<li>Public-key authentication</li>
<li>Password authentication</li>
<li>Keyboard-interactive authentication</li>
</ul>
<p>The following sections provide brief descriptions of these forms of SSH authentication.</p>
<h4>Public-key authentication</h4>
<p><strong class="bold">Public-key authentication</strong> (or <strong class="bold">SSH-key authentication</strong>) <a id="_idIndexMarker1171"/>is arguably <a id="_idIndexMarker1172"/>the most common type of SSH authentication.</p>
<p class="callout-heading">Important note</p>
<p class="callout">This section will use the terms <em class="italic">public-key</em> and <em class="italic">SSH-key</em> interchangeably, mostly to reflect the related SSH authentication nomenclature in the Linux community.</p>
<p>The SSH-key authentication mechanism uses a <em class="italic">certificate/key</em> pair – a <code>ssh-keygen</code> tool, using <a id="_idIndexMarker1173"/>standard encryption algorithms such as the <strong class="bold">Rivest–Shamir–Adleman</strong> algorithm (<strong class="bold">RSA</strong>) or the <strong class="bold">Digital Signature </strong><strong class="bold">Algorithm</strong> (<strong class="bold">DSA</strong>).</p>
<p>The SSH <a id="_idIndexMarker1174"/>public-key authentication supports either <strong class="bold">user-based authentication</strong> or <strong class="bold">host-based authentication</strong> models. The two models differ in the ownership of the certificate/key pairs involved. With client authentication, each user has a certificate/key pair for SSH access. On the other hand, host authentication involves a single certificate/key pair per system (host).</p>
<p>Both SSH-key authentication models are illustrated and explained in the following sections. The basic SSH handshake and authentication workflows are the same for both models:</p>
<ul>
<li>First, the SSH client generates a secure certificate/key pair and shares its public key with the SSH server. This is a one-time operation for enabling public-key authentication.</li>
<li>When a <a id="_idIndexMarker1175"/>client initiates the SSH handshake, the server asks for <a id="_idIndexMarker1176"/>the client’s public key and verifies it against its allowed public keys. If there’s a match, the SSH handshake succeeds, the server shares its public key with the client, and the SSH session is established.</li>
<li>Further client-server communication follows standard encryption/decryption workflows. The client encrypts the data with its private key, while the server decrypts the data with the client’s public key. When responding to the client, the server encrypts the data with its own private key, and the client decrypts the data with the server’s public key.</li>
</ul>
<p>SSH public-key <a id="_idIndexMarker1177"/>authentication is also known as <strong class="bold">passwordless authentication</strong>, and it’s frequently used in automation scripts where commands are executed over multiple remote SSH connections without prompting for a password.</p>
<p>Let’s take a closer look at the user-based and host-based public-key authentication mechanisms:</p>
<ul>
<li><strong class="bold">User-based authentication</strong>: This is the most common SSH public-key authentication mechanism. According<a id="_idIndexMarker1178"/> to this model, every user connecting <a id="_idIndexMarker1179"/>to a remote SSH server has its own SSH key. Multiple user accounts on the same host (or domain) would have different SSH keys, each with its own access to the remote SSH server, as suggested in the following figure:</li>
</ul>
<div><div><img alt="Figure 7.38 – User-based key authentication" src="img/B19682_07_38.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.38 – User-based key authentication</p>
<ul>
<li><strong class="bold">Host-based authentication</strong>: This is another form of <a id="_idIndexMarker1180"/>SSH public-key authentication and involves a single SSH key per system (host) to connect to a remote SSH server, as illustrated in the following figure:</li>
</ul>
<div><div><img alt="Figure 7.39 – Host-based key authentication" src="img/B19682_07_39.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.39 – Host-based key authentication</p>
<p class="list-inset">With host-based authentication, the underlying SSH key can only authenticate SSH sessions that originated from a single client host. Host-based authentication allows multiple <a id="_idIndexMarker1181"/>users to connect from the same host to a remote SSH server. If a user attempts to use a host-based SSH key from a different machine <a id="_idIndexMarker1182"/>than the one allowed by the SSH server, access will be denied.</p>
<p>Sometimes, a mix of the two public-key authentications is used – user- and host-based authentication –an approach that provides an increased level of security to SSH access.</p>
<p>When security is not critical, simpler SSH authentication mechanisms could be more suitable. Password authentication is one such mechanism.</p>
<h4>Password authentication</h4>
<p><code>/etc/passwd</code>) or select user accounts defined in the SSH server configuration (<code>/etc/ssh/sshd_config</code>). The SSH server configuration described in <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing</em><em class="italic"> Linux</em>, further elaborates on this subject.</p>
<p>Besides local authentication, SSH can also leverage remote authentication methods such as Kerberos, LDAP, RADIUS, and others. In such cases, the SSH server delegates the user authentication to a remote authentication server, as described in the <em class="italic">Authentication servers</em> section earlier in this chapter.</p>
<p>Password authentication requires either user interaction or some automated way to provide the required credentials. Another similar authentication mechanism is keyboard-interactive authentication, described next.</p>
<h4>Keyboard-interactive authentication</h4>
<p><strong class="bold">Keyboard-interactive authentication</strong> is based on a dialogue of multiple challenge-response sequences between the SSH client (user) and the SSH server. This dialogue is a plaintext exchange of questions and answers, where the server may prompt the user for any number of challenges. In some respect, password authentication is a <strong class="bold">single-challenge interactive </strong><strong class="bold">authentication</strong> mechanism.</p>
<p>The <em class="italic">interactive</em> connotation of this authentication method could lead us to think that <a id="_idIndexMarker1185"/>user interaction <a id="_idIndexMarker1186"/>would be mandatory for the related implementation. Not really. Keyboard-interactive authentication could also serve implementations of authentication mechanisms based on custom protocols, where the underlying message exchange would be modeled as an authentication protocol.</p>
<p>Before moving on to other remote access protocols, we should call out the wide use of SSH due to its security, versatility, and performance. However, SSH connectivity may not always be possible or adequate in specific scenarios. In such cases, <em class="italic">TELNET</em> may come to the rescue. We’ll take a look at it next.</p>
<h3>TELNET</h3>
<p><strong class="bold">TELNET</strong> is an <a id="_idIndexMarker1187"/>application-layer protocol for <a id="_idIndexMarker1188"/>bidirectional network communication that uses a plaintext CLI with a remote host. Historically, TELNET was among the first remote-connection protocols, but it always lacked secure implementation. SSH eventually became the standard way to log in from one computer to another, yet TELNET has its advantages over SSH when it comes to troubleshooting various application-layer protocols, such as web- or email-server communication. You will learn more about how to use TELNET in <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing</em><em class="italic"> Linux</em>.</p>
<p>TELNET <a id="_idIndexMarker1189"/>and SSH are command-line-driven remote-access <a id="_idIndexMarker1190"/>interfaces. There are cases <a id="_idIndexMarker1191"/>when a direct desktop connection is needed to a remote machine through a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>). We’ll look at desktop sharing next.</p>
<h3>VNC</h3>
<p><strong class="bold">Virtual Network Computing</strong> (<strong class="bold">VNC</strong>) is a desktop-sharing platform that allows users to access <a id="_idIndexMarker1192"/>and control a remote computer’s GUI. VNC is <a id="_idIndexMarker1193"/>a cross-platform client-server application. A VNC server running on a Linux machine, for example, allows desktop <a id="_idIndexMarker1194"/>access to multiple VNC clients running on Windows or macOS systems. The VNC network communication uses the <strong class="bold">Remote Framebuffer</strong> (<strong class="bold">RFB</strong>) protocol, defined by <em class="italic">RFC 6143</em>. Setting up a VNC server is relatively simple. VNC assumes the presence of a graphical desktop system. More details on this will be provided in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring </em><em class="italic">Linux Servers</em>.</p>
<p>This <a id="_idIndexMarker1195"/>concludes our section about network services and protocols. We tried to cover the most common concepts about general-purpose network servers and applications, mostly operating in a client-server or distributed fashion. With each network server, we described the related network protocols and some of the internal aspects involved. <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing Linux</em>, and <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring Linux Servers</em>, will showcase practical implementations for some of these network servers.</p>
<p>In the next section, our focus will turn to network security internals.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor160"/>Understanding network security</h1>
<p><strong class="bold">Network security</strong> represents the processes, actions, and policies to prevent, monitor, and protect unauthorized <a id="_idIndexMarker1196"/>access to computer networks. Network security paradigms span a vast array of technologies, tools, and practices. Here are a few important ones:</p>
<ul>
<li><strong class="bold">Access control</strong>: Selectively restricting access based on user authentication and <a id="_idIndexMarker1197"/>authorization mechanisms. Examples of access control include users, groups, and permissions. Some of the related concepts were covered in <a href="B19682_04.xhtml#_idTextAnchor090"><em class="italic">Chapter 4</em></a>, <em class="italic">Managing </em><em class="italic">Users </em><em class="italic">and Groups</em>.</li>
<li><strong class="bold">Application security</strong>: Securing <a id="_idIndexMarker1198"/>and protecting server and end user applications (email, web, and mobile apps). Examples <a id="_idIndexMarker1199"/>of application security include <strong class="bold">Security-Enhanced Linux</strong> (<strong class="bold">SELinux</strong>), strongly encrypted connections, antivirus, and anti-malware programs. We’ll cover <strong class="bold">SELinux</strong> in <a href="B19682_10.xhtml#_idTextAnchor212"><em class="italic">Chapter 10</em></a>, <em class="italic">Disaster Recovery, Diagnostics, </em><em class="italic">and Troubleshooting</em>.</li>
<li><strong class="bold">Endpoint security</strong>: Securing <a id="_idIndexMarker1200"/>and protecting servers and end user devices (smartphones, laptops, and desktop PCs) on the network. Examples of endpoint security include <em class="italic">firewalls</em> and various intrusion-detection mechanisms. We’ll look at firewalls in <a href="B19682_10.xhtml#_idTextAnchor212"><em class="italic">Chapter 10</em></a>, <em class="italic">Disaster Recovery, Diagnostics, </em><em class="italic">and Troubleshooting</em>.</li>
<li><strong class="bold">Network segmentation</strong>: Partitioning <a id="_idIndexMarker1201"/>computer networks into smaller segments or <strong class="bold">virtual LANs</strong> (<strong class="bold">VLANs</strong>). This is <a id="_idIndexMarker1202"/>not to be confused with subnetting, which is a logical division of networks through addressing.</li>
<li><strong class="bold">VPNs</strong>: Accessing <a id="_idIndexMarker1203"/>corporate networks using a secure encrypted tunnel from public networks or the internet. We’ll look at VPNs in more detail in <a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic">Chapter 9</em></a>, <em class="italic">Securing Linux</em>, and <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring </em><em class="italic">Linux Servers</em>.</li>
</ul>
<p>In everyday Linux administration, setting up a network security perimeter should always follow the paradigms enumerated previously, roughly in the order listed. Starting with access-control mechanisms and ending with VPNs, securing a network takes an <em class="italic">inside-out</em> approach, from local systems and networks to firewalls, VLANs, and VPNs.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor161"/>Summary</h1>
<p>This chapter provided a relatively condensed view of basic Linux networking principles. We learned about network communication layers and protocols, IP addressing schemes, TCP/IP configurations, well-known network application servers, and VPN. A good grasp of networking paradigms will give Linux administrators a more comprehensive view of the distributed systems and underlying communication between the application endpoints involved.</p>
<p>Some of the theoretical aspects covered in this chapter will be taken for a practical spin in <a href="B19682_13.xhtml#_idTextAnchor276"><em class="italic">Chapter 13</em></a>, <em class="italic">Configuring Linux Servers</em>, where we’ll focus on real-world implementations of network servers. <a href="B19682_10.xhtml#_idTextAnchor212"><em class="italic">Chapter 10</em></a>, <em class="italic">Disaster Recovery, Diagnostics, and Troubleshooting</em>, will further explore network security internals and practical Linux firewalls. Everything we have learned so far will serve as a good foundation for the assimilation of these upcoming chapters.</p>
<p>The following chapter will introduce you to Linux shell scripting, where you will learn about the most common shell features and how to use decisions, loops, variables, arrays, and functions.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor162"/>Questions</h1>
<p>Here’s a quick quiz to outline and test some of the essential concepts covered in this chapter:</p>
<ol>
<li>How does the OSI model compare to the TCP/IP model?<p class="list-inset"><strong class="bold">Hint</strong>: <em class="italic">Figure 7</em><em class="italic">.2</em> could be of help.</p></li>
<li>Think of a couple of TCP/IP protocols and try to see where and how they operate in some of the network administration tasks or applications you are familiar with.</li>
<li>At what networking layer does the HTTP protocol operate? How about DNS?<p class="list-inset"><strong class="bold">Hint</strong>: Both operate on the same layer.</p></li>
<li>What is the network class for IP address <code>192.168.0.1</code>?<p class="list-inset"><strong class="bold">Hint</strong>: Refer to <em class="italic">Figure 7</em><em class="italic">.5</em>.</p></li>
<li>What is the network prefix that corresponds to network mask <code>255.255.0.0</code>?<p class="list-inset"><strong class="bold">Hint</strong>: Check out <em class="italic">Figure </em><em class="italic">7</em><em class="italic">.5</em> again.</p></li>
<li>How do you configure a static IP address using the <code>nmcli</code> utility?<p class="list-inset"><code>connection modify</code>.</p></li>
<li>How do you change the hostname of a Linux machine?<p class="list-inset"><code>hostnamectl</code> utility.</p></li>
<li>What is the difference between the POP3 and IMAP email protocols?</li>
<li>How does SSH host-based authentication differ from user-based SSH key authentication?</li>
<li> What is the difference between SSH and TELNET?</li>
</ol>
<h1 id="_idParaDest-147"><a id="_idTextAnchor163"/>Further reading</h1>
<p>For more information about what was covered in this chapter, please refer to the following Packt titles:</p>
<ul>
<li><em class="italic">Linux Administration Best Practices</em>, by Scott Alan Miller</li>
<li><em class="italic">Linux for Networking Professionals</em>, by Rob VandenBrink</li>
</ul>
</div>
</body></html>