<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Deployment Setup</h1></div></div></div><p>In the previous chapter, you learned how to set up a local CoreOS environment for development on a personal computer and a Test and Staging environment cluster on Google Cloud's Compute Engine VM instances.</p><p>In this chapter, we will cover how to deploy code from the GitHub repository to our Test and Staging servers, and how to set up the Docker builder and Docker private registry worker for Docker image building and distribution.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Code deployment on Test and Staging servers</li><li class="listitem">Setting up the Docker builder and private Docker registry machine</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Code deployment on Test and Staging servers</h1></div></div></div><p>In the previous chapter, you learned how to set up your Test and Staging environment on Google Cloud and deploy your web servers there. In this section, we will see how to deploy code to our web servers on Test and Staging environments.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>Deploying code on servers</h2></div></div></div><p>To deploy code on our <code class="literal">Test1</code> and <code class="literal">Staging1</code> servers, we run the following commands:</p><div><pre class="programlisting">
<strong>$ cd coreos-essentials-book/chapter6/Test_Staging_Cluster/webserver</strong>
<strong>$ ./deploy_2_test1.sh</strong>
</pre></div><p>You will get this output:</p><div><img src="img/image00146.jpeg" alt="Deploying code on servers"/></div><p style="clear:both; height: 1em;"> </p><p>Then, run this command:</p><div><pre class="programlisting">
<strong>$ ./deploy_2_staging1.sh</strong>
</pre></div><p>You should see the following result:</p><div><img src="img/image00147.jpeg" alt="Deploying code on servers"/></div><p style="clear:both; height: 1em;"> </p><p>Now open the <code class="literal">tsc-test1</code> and <code class="literal">tsc-staging1</code> VM instance external IPs, copying them to your browser (you can check out the IPs at GC Console, Compute Engine, VM Instance).</p><p>The output you see depends on the server.</p><p>For the Test server, you should see something like this:</p><div><img src="img/image00148.jpeg" alt="Deploying code on servers"/></div><p style="clear:both; height: 1em;"> </p><p>This is what you will see for the Staging server:</p><div><img src="img/image00149.jpeg" alt="Deploying code on servers"/></div><p style="clear:both; height: 1em;"> </p><p>Let's see what has happened here:</p><div><pre class="programlisting">$ cat deploy_2_test1.sh
#!/bin/bash

function pause(){
read -p "$*"
}

## Fetch GC settings
# project and zone
project=$(cat ~/coreos-tsc-gce/settings | grep project= | head -1 | cut -f2 -d"=")
zone=$(cat ~/coreos-tsc-gce/settings | grep zone= | head -1 | cut -f2 -d"=")

# change folder permissions
gcloud compute --project=$project ssh  --zone=$zone "core@tsc-test1" --command "sudo chmod -R 755 /home/core/share/"

echo "Deploying code to tsc-test1 server !!!"
gcloud compute copy-files test1/index.html tsc-test1:/home/core/share/nginx/html --zone $zone --project $project

echo " "
echo "Finished !!!"
pause 'Press [Enter] key to continue...'</pre></div><p>As you can see, we used <code class="literal">gcloud compute</code> to change the permissions for our <code class="literal">home/core/share/nginx/html</code> folder, as we need to be able to copy files there. We copied a single <code class="literal">index.html</code> file there. </p><p>In real-life scenarios, <code class="literal">git pull</code> should be used there to pull from the Test and Staging branches.</p><p>To automate releases to the <code class="literal">Test1/Staging1</code> servers, for example, Strider-CD can be used, but this is beyond the scope of this book. You can read about Strider-CD at <a class="ulink" href="https://github.com/Strider-CD/strider">https://github.com/Strider-CD/strider</a> and practice implementing it.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Setting up the Docker builder and private Docker registry worker</h1></div></div></div><p>We have successfully deployed code (<code class="literal">index.html</code> in our case) in our Test/Staging environment on the cloud with the help of <code class="literal">gcloud compute</code>, by running it in a simple shell script.</p><p>Let's set up a new server in our Test/Staging environment on the cloud. It will build Docker images for us and store them in our private Docker Registry so that they can be used on our production cluster (you will learn how to set this up in the next chapter).</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>Server setup</h2></div></div></div><p>As both Docker builder and Private Docker Registry fleet units will run on the same server, we are going to deploy one more server on the Test/Staging environment.</p><p>To install a new server, run the following commands:</p><div><pre class="programlisting">
<strong>$ cd coreos-essentials-book/chapter6/Test_Staging_Cluster</strong>
<strong>$ ls</strong>
<strong>cloud-config</strong>
<strong>create_registry-cbuilder1.sh </strong>
<strong>dockerfiles</strong>
<strong>files</strong>
<strong>fleet</strong>
<strong>webserver</strong>
</pre></div><p>Next, let's install our new server:</p><div><pre class="programlisting">
<strong>$ ./create_ registry-cbuilder1.sh</strong>
</pre></div><p>You should see output similar to this:</p><div><img src="img/image00150.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Let's see what happened during the process of script installation:</p><div><ul class="itemizedlist"><li class="listitem">A new <code class="literal">server tsc-registry-cbuilder1</code> was created</li><li class="listitem">The static IP's <code class="literal">10.200.4.1</code> forward route for the <code class="literal">tsc-registry-cbuilder1</code> instance was created</li><li class="listitem">The external port <code class="literal">5000</code> was opened for the new server</li><li class="listitem">File <code class="literal">reg-dbuilder1.sh</code> from the <code class="literal">files</code> folder got copied to <code class="literal">~/coreos-tsc-gce/bin</code></li><li class="listitem">The <code class="literal">dbuilder.service</code> and <code class="literal">registry.service</code> fleet units from the <code class="literal">fleet</code> folder got copied to <code class="literal">~/coreos-tsc-gce/fleet</code></li></ul></div><p>If we check out the GCE VM Instances at the GC console, we should see our new instance there:</p><div><img src="img/image00151.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>We now need to verify that our new server is working fine, so we perform <code class="literal">ssh</code> on it:</p><div><pre class="programlisting">
<strong>$ cd ~/coreos-tsc-gce/bin</strong>
<strong>$ ./reg-dbuider1.sh</strong>
</pre></div><div><img src="img/image00152.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Very good! Our new server is up-and-running. Press <em>Ctrl</em> + <em>D</em> to exit.</p><p>Now we need to verify that our server is connected to our cluster. So, run the following command:</p><div><pre class="programlisting">
<strong>$ ./set_cluster_access.sh</strong>
</pre></div><p>The script's output should look like this:</p><div><img src="img/image00153.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Perfect! We can see that our new server has successfully connected to our cluster:</p><div><img src="img/image00154.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Okay, now let's install those two new fleet units:</p><div><pre class="programlisting">
<strong>$ cd ~/coreos-tsc-gce/fleet</strong>
<strong>$ fleetctl start dbuilder.service registry.service</strong>
</pre></div><div><img src="img/image00155.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Next, let's list the fleet units:</p><div><pre class="programlisting">
<strong>$ fleetctl list-units</strong>
</pre></div><div><img src="img/image00156.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>If you see <code class="literal">activating start-pre</code>, give the <code class="literal">fleet</code> units a few minutes to pull the remote Docker images.</p><p>You can check the status of the <code class="literal">fleet</code> units using the following command:</p><div><pre class="programlisting">
<strong>$ fleetctl status dbuilder.service</strong>
</pre></div><div><img src="img/image00157.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Suppose we try again in a couple of minutes:</p><div><pre class="programlisting">
<strong>$ fleetctl list-units</strong>
</pre></div><div><img src="img/image00158.jpeg" alt="Server setup"/></div><p style="clear:both; height: 1em;"> </p><p>Then we can see that we've successfully got two new <code class="literal">fleet</code> units on our new <code class="literal">tsc-registry-cbuilder1</code> server.</p><p>You might remember from the previous chapter that the <code class="literal">set_cluster_access.sh</code> script does the following:</p><div><ul class="itemizedlist"><li class="listitem">It sets <code class="literal">PATH</code> to the <code class="literal">~/coreos-tsc-gce/bin</code> folder so that we can access executable files and scripts stored there from any folder</li><li class="listitem">It sets <code class="literal">FLEETCTL_TUNNEL</code> to our <code class="literal">control/etcd</code> machine's external IP</li><li class="listitem">It prints machines at the cluster with <code class="literal">fleetctl list-machines</code></li><li class="listitem">It prints units at the cluster with <code class="literal">fleetctl list-units</code></li><li class="listitem">It allows us to work with a remote <code class="literal">etcd</code> cluster via a local <code class="literal">fleetctl</code> client</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Summary</h1></div></div></div><p>In this chapter, you learned how to deploy code on a remote Test/Staging cluster on GCE, and set up the Docker builder and private Docker registry machine.</p><p>In the following chapter, we will cover these topics: using our Staging and Docker builder and private registry servers to deploy code from Staging to production, building Docker images, and deploying them on production servers.</p></div></body></html>