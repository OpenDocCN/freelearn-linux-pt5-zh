["```\nsestatus\n```", "```\ngetenforce\n```", "```\nsudo setenforce 0\n```", "```\nsudo setenforce 1\n```", "```\nSELINUX=disabled\n```", "```\nsudo sed -i 's/SELINUX=enforcing/SELINUX=disabled/g' /etc/selinux/config\n```", "```\ncat /etc/selinux/config\n```", "```\nsudo systemctl reboot\n```", "```\ntouch afile\nls -Z afile\n```", "```\nUSER:ROLE:TYPE:LEVEL\n```", "```\n    sudo semanage login -l\n    ```", "```\nid -Z\n```", "```\nps -eZ | grep sshd\n```", "```\nls -Z /usr/bin/passwd\nls -Z /etc/shadow\n```", "```\nsudo dnf install setools-console -y\n```", "```\nsudo sesearch -s passwd_t -t shadow_t -p write --allow\n```", "```\nsudo dnf install gcc\n```", "```\ngcc -o packtd packtd.c\n```", "```\nsudo cp packtd /usr/local/bin/\nsudo cp packtd.service /usr/lib/systemd/system/\n```", "```\nsudo systemctl start packtd\nsudo systemctl status packtd\n```", "```\nps -efZ | grep packtd | grep -v grep\n```", "```\nsudo dnf install -y policycoreutils-devel rpm-build\n```", "```\nsepolicy generate --init /usr/local/bin/packtd\n```", "```\nsudo ./packtd.sh\n```", "```\nsudo systemctl restart packtd\n```", "```\nps -efZ | grep packtd | grep -v grep\n```", "```\nsudo ausearch -m AVC -ts recent\n```", "```\nsudo ausearch -m AVC -ts recent | audit2allow -R\n```", "```\nsudo ./packtd.sh\nsudo systemctl restart packtd\nsudo ausearch -m AVC -ts recent | audit2allow -R\n```", "```\nsudo ausearch --start 04/19/2023 '17:30:00' | audit2allow -R\n```", "```\nsemanage TARGET [OPTIONS]\n```", "```\nsudo semanage port -l | grep ssh\n```", "```\nsudo semanage port -a -t ssh_port_t -p tcp 2222\n```", "```\nsudo semanage port -d -p tcp 22\n```", "```\nsudo semanage port -l -C\n```", "```\nsudo semanage boolean -l | grep httpd | grep ftp\n```", "```\nsudo semanage boolean -m --on httpd_enable_ftp_server\n```", "```\nsudo semanage boolean -l -C\n```", "```\nsudo semanage fcontext -l | grep sshd\n```", "```\nsudo semanage fcontext -a -t sshd_key_t '/etc/ssh/keys(/.*)?'\n```", "```\nsudo semanage fcontext -l -CWe should see our new security context:\n```", "```\nsudo restorecon -r /etc/ssh/keys\n```", "```\ncat packt.te\n```", "```\nsudo semanage permissive -l\n```", "```\nsudo semanage permissive -a httpd_t\n```", "```\nsudo semanage permissive -d httpd_t\n```", "```\nsudo dnf install -y selinux-policy-doc.noarch\n```", "```\nman -k selinux | grep httpd\n```", "```\nsudo aa-status\n```", "```\nmkdir ./log\n```", "```\nchmod a+x appackt\n./appackt\n```", "```\nsudo apt install -y apparmor-utils\n```", "```\nsudo aa-genprof ./appackt\n```", "```\n./appackt\n```", "```\nsudo aa-logprof\n```", "```\nsudo aa-remove-unknown\n```", "```\nsudo aa-status\n```", "```\nLOG_FILE=\"./log to logs. Let’s create a logs directory and run our app:\n\n```", "```\n\n The preceding output suggests that `appackt` is attempting to access a path outside the permitted boundaries by AppArmor, thus validating our profile:\n![Figure 9.36 – appackt acting outside security boundaries](img/B19682_09_36.jpg)\n\nFigure 9.36 – appackt acting outside security boundaries\nLet’s revert the preceding changes and have the `appackt` script act normally. Let’s assume that our app is not yet running in `enforce` mode (but ours is already). We can change it to `enforce` profile mode with the following command:\n\n```", "```\n\n We can verify that our application is indeed running in `enforce` mode with the following command:\n\n```", "```\n\n If we wanted to make further adjustments to our application and then test it with the related changes, we would have to change the profile mode to `complain` and then reiterate the steps described earlier in this section. The following command sets the application profile to `complain` mode:\n\n```", "```\n\n AppArmor profiles are plain text files stored in the `/etc/apparmor.d/` directory. Creating or modifying AppArmor profiles usually involves manually editing the corresponding files or the procedure described in this section using the `aa-genprof` and `aa-logprof` tools.\nNext, let’s look at how to disable or enable AppArmor application profiles.\nDisabling and enabling profiles\nSometimes, we may want to disable a problematic application profile while working on a better version. Here’s how we do this.\nFirst, we need to locate the application profile we want to disable (for example, `appackt`). The related file is in the `/etc/apparmor.d/` directory and it’s named according to its full path, with dots (`.`) instead of slashes (`/`). In our case, the file is `/etc/apparmor.d/home.packt.appackt`, as seen in the following screenshot:\n![Figure 9.37 – Location of the AppArmor profile for appackt](img/B19682_09_37.jpg)\n\nFigure 9.37 – Location of the AppArmor profile for appackt\nTo disable the profile, we must run the following commands:\n\n```", "```\n\n If we run the `aa-status` command, we won’t see our `appackt` profile anymore. The related profile is still present in the filesystem, at `/etc/apparmor.d/disable/home.packt.appackt`.\nIn this situation, the `appackt` script is not enforced by any restrictions. To re-enable the related security profile, we can run the following commands:\n\n```", "```\n\n The `appackt` profile should now show up in the `aa-status` output as running in `enforce` mode. All the previous commands and their output are shown in the following screenshot:\n![Figure 9.38 – Disabling and enabling an AppArmor profile](img/B19682_09_38.jpg)\n\nFigure 9.38 – Disabling and enabling an AppArmor profile\nTo disable or enable the profile, we used the `apparmor_parser` command, besides the related filesystem operations. This utility assists with loading (`-r`, `--replace`) or unloading (`-R`, `--remove`) security profiles to and from the kernel.\nDeleting AppArmor security profiles is functionally equivalent to disabling them. We can also choose to remove the related file from the filesystem altogether. If we delete a profile without removing it from the kernel first (with `apparmor_parser -R`), we can use the `aa-remove-unknown` command to clean up orphaned entries.\nLet’s conclude our relatively brief study of AppArmor internals with some final thoughts.\nFinal considerations\nWorking with AppArmor is relatively easier than SELinux, especially when it comes to generating security policies or switching back and forth between permissive and non-permissive mode. SELinux can only toggle the permissive context for the entire system, while AppArmor does it at the application level. On the other hand, there might be no choice between the two, as some major Linux distributions either support one or the other. AppArmor is used on Debian, Ubuntu, and openSUSE, while SELinux runs on RHEL/Fedora and SLE. Theoretically, you can always try to port the related kernel modules across distros, but that’s not a trivial task.\nAs a final note, we should reiterate that in the big picture of Linux security, SELinux and AppArmor are ACMs that act locally on a system, at the application level. When it comes to securing applications and computer systems from the outside world, firewalls come into play. We’ll look at firewalls next.\nWorking with firewalls\nTraditionally, a **firewall** is a network security device that’s placed between two networks. It monitors the network traffic and controls access to these networks. Generally speaking, a firewall protects a local network from unwanted intrusion or attacks from the outside. But a firewall can also block unsolicited locally originated traffic targeting the public internet. Technically, a firewall allows or blocks incoming and outgoing network traffic based on specific security rules.\nFor example, a firewall can block all but a select set of inbound networking protocols (such as SSH and HTTP/HTTPS). It may also block all but approved hosts within the local network from establishing specific outbound connections, such as allowing outbound **Simple Mail Transfer Protocol** (**SMTP**) connections that originated exclusively from the local email servers.\nThe following diagram shows a simple firewall deployment regulating traffic between a local network and the internet:\n![Figure 9.39 – A simple firewall diagram](img/B19682_09_39.jpg)\n\nFigure 9.39 – A simple firewall diagram\nThe outgoing security rules prevent bad actors, such as compromised computers and untrustworthy individuals, from directing attacks on the public internet. The resulting protection benefits external networks, but it’s ultimately essential for the organization as well. Thwarting hostile actions from the local network avoids them being flagged by **internet service providers** (**ISPs**) for unruly internet traffic.\nConfiguring a firewall usually requires a default security policy acting at a global scope, and then configuring specific exceptions to this general rule, based on port numbers (protocols), IP addresses, and other criteria.\nIn the following sections, we’ll explore various firewall implementations and firewall managers. First, let’s take a brief look under the hood at how a firewall monitors and controls network traffic by introducing the Linux firewall chain.\nUnderstanding the firewall chain\nAt a high level, the TCP/IP stack in the Linux kernel usually performs the following workflows:\n\n*   Receives data from an application (process), serializes the data into network packets, and transmits the packets to a network destination, based on the respective IP address and port\n*   Receives data from the network, deserializes the network packets into application data, and delivers the application data to a process\n\nIdeally, in these workflows, the Linux kernel shouldn’t alter the network data in any specific way apart from shaping it due to TCP/IP protocols. However, with distributed and possibly insecure network environments, the data may need further scrutiny. The kernel should provide the necessary hooks to filter and alter the data packets further based on various criteria. This is where firewalls and other network security and intrusion detection tools come into play. They adapt to the kernel’s TCP/IP packet filtering interface and perform the required monitoring and control of network packets. The blueprint of the Linux kernel’s network packet filtering procedure is also known as the **firewall chain** or **firewalling chain**:\n![Figure 9.40 – The Linux firewall chain](img/B19682_09_40.jpg)\n\nFigure 9.40 – The Linux firewall chain\nWhen the incoming data enters the firewall packet filtering chain, a routing decision is made, depending on the packet’s destination. Based on that routing decision, the packet can follow either the **INPUT** chain (for localhost) or the **FORWARD** chain (for a remote host). These chains may alter the incoming data in various ways via hooks that are implemented by network security tools or firewalls. By default, the kernel won’t change the packets traversing the chains.\nThe **INPUT** chain ultimately feeds the packets into the **local application process** consuming the data. These local applications are usually user-space processes, such as network clients (for example, web browsers, SSH, and email clients) or network servers (for example, web and email servers). They may also include kernel space processes, such as the kernel’s **Network File** **System** (**NFS**).\nBoth the **FORWARD** chain and the **local processes** route the data packets into the **OUTPUT** chain before placing them on the network.\nAny of the chains can filter packets based on specific criteria, such as the following:\n\n*   The source or destination IP address\n*   The source or destination port\n*   The network interface involved in the data transaction\n\nEach chain has a set of security rules that are matched against the input packet. If a rule matches, the kernel routes the data packet to the **target** specified by the rule. Some predefined targets include the following:\n\n*   `ACCEPT`: Accepts the data packet for further processing\n*   `REJECT`: Rejects the data packet\n*   `DROP`: Ignores the data packet\n*   `QUEUE`: Passes the data packet to a user-space process\n*   `RETURN`: Stops processing the data packet and passes the data back to the previous chain\n\nFor a full list of predefined targets, please refer to the `iptables-extensions` system reference (`man iptables-extensions`).\nIn the following sections, we’ll explore some of the most common network security frameworks and tools based on the kernel’s networking stack and firewall chain. We’ll start with Netfilter—the Linux kernel’s packet filtering system. Next, we’ll look at `iptables`—the traditional interface for configuring Netfilter. `iptables` is a highly configurable and flexible firewall solution. Then, we’ll briefly cover `nftables`, a tool that implements most of the complex functionality of `iptables` and wraps it into a relatively easy-to-use command-line interface. Finally, we’ll take a step away from the kernel’s immediate proximity of packet filtering frameworks and look at `firewalld` (RHEL/Fedora) and `ufw` (Debian/Ubuntu), two user-friendly frontends for configuring Linux firewalls on major Linux distros.\nLet’s start our journey with Netfilter.\nIntroducing Netfilter\n**Netfilter** is a packet filtering framework in the Linux kernel that provides highly customizable handlers (or hooks) to control networking-related operations. These operations include the following:\n\n*   Accepting or rejecting packets\n*   Packet routing and forwarding\n*   **Network address translation** and **network address port** **translation** (**NAT**/**NAPT**)\n\nApplications that implement the Netfilter framework use a set of callback functions built around hooks registered with kernel modules that manipulate the networking stack. These callback functions are further mapped to security rules and profiles, which control the behavior of every packet traversing the networking chain.\nFirewall applications are first-class citizens of Netfilter framework implementations. Consequently, a good understanding of Netfilter hooks will help Linux power users and administrators create reliable firewall rules and policies.\nWe’ll have a brief look at these Netfilter hooks next.\nNetfilter hooks\nAs packets traverse the various chains in the networking stack, Netfilter triggers events for the kernel modules that are registered with the corresponding **hooks**. These events result in notifications in the module or packet filtering application (for example, the firewall) implementing the hooks. Next, the application takes control of the packet based on specific rules.\nThere are five Netfilter hooks available for packet filtering applications. Each corresponds to a networking chain, as illustrated in *Figure 9**.40*:\n\n*   `NF_IP_PRE_ROUTING`: Triggered by incoming traffic upon entering the network stack and before any routing decisions are made about where to send the packet\n*   `NF_IP_LOCAL_IN`: Triggered after routing an incoming packet when the packet has a `localhost` destination\n*   `NF_IP_FORWARD`: Triggered after routing an incoming packet when the packet has a remote host destination\n*   `NF_IP_LOCAL_OUT`: Triggered by locally initiated outbound traffic entering the network stack\n*   `NF_IP_POST_ROUTING`: Triggered by outgoing or forwarded traffic, immediately after routing it and just before it exits the network stack\n\nKernel modules or applications registered with Netfilter hooks must provide a priority number to determine the order the modules are called in when the hook is triggered. This mechanism allows us to deterministically order multiple modules (or multiple instances of the same module) that have been registered with a specific hook. When a registered module is done processing a packet, it provides a decision to the Netfilter framework about what should be done with the packet.\nThe Netfilter framework’s design and implementation is a community-driven collaborative project part of the **Free and Open Source Software** (**FOSS**) movement. As a good starting point for the Netfilter project, you may refer to [http://www.netfilter.org/](http://www.netfilter.org/).\nOne of the most well-known implementations of Netfilter is `iptables`—a widely used firewall management tool that shares a direct interface with the Netfilter packet filtering framework. A practical examination of `iptables` would further reveal the functional aspects of Netfilter. Let’s explore `iptables` next.\nWorking with iptables\n`iptables` is a relatively low-level Linux firewall solution and command-line utility that uses Netfilter chains to control network traffic. `iptables` operates with `iptables` also uses `iptables` defines the following tables:\n\n*   `filter`: The default table, which is used when we’re deciding if packets should be allowed to traverse specific chains (`INPUT`, `FORWARD,` `OUTPUT`).\n*   `nat`: Used with packets that require a source or destination address/port translation. The table operates on the following chains: `PREROUTING`, `INPUT`, `OUTPUT`, and `POSTROUTING`.\n*   `mangle`: Used with specialized packet alterations involving IP headers, such as `PREROUTING`, `INPUT`, `FORWARD`, `OUTPUT`, and `POSTROUTING`.\n*   `raw`: Used when we’re disabling connection tracking (`NOTRACK`) on specific packets, mainly for stateless processing and performance optimization purposes. The table relates to the `PREROUTING` and `OUTPUT` chains.\n*   `security`: Used for MAC when packets are subject to SELinux policy constraints. The table interacts with the `INPUT`, `FORWARD`, and `OUTPUT` chains.\n\nThe following diagram summarizes the tables with the corresponding chains supported in `iptables`:\n![Figure 9.41 – Tables and chains in iptables](img/B19682_09_41.jpg)\n\nFigure 9.41 – Tables and chains in iptables\nThe chain traversal order of the packets in the kernel’s networking stack is as follows:\n\n*   Incoming packets with localhost destination: `PREROUTING` | `INPUT`\n*   Incoming packets with remote host destination: `PREROUTING` | `FORWARD` | `POSTROUTING`\n*   Locally generated packets (by application processes): `OUTPUT` | `POSTROUTING`\n\nNow that we’re familiar with some introductory concepts, we can tackle a few practical examples to understand how `iptables` works.\nThe following examples use a Fedora 37 system, but they should work on every major Linux distribution. Please note that starting with RHEL 7, the default firewall management application is `firewalld` (discussed in the *Using firewall managers* section later in this chapter). If you want to use `iptables`, first, you need to disable `firewalld`:\n\n```", "```\n\n Next, install the `iptables-services` package (on Fedora):\n\n```", "```\n\n The output of the preceding commands is shown here:\n![Figure 9.42 – Disabling firewalld and installing iptables on Fedora](img/B19682_09_42.jpg)\n\nFigure 9.42 – Disabling firewalld and installing iptables on Fedora\nImportant note\nOn Ubuntu, you must install `iptables` using `sudo apt` `install iptables`.\nNow, let’s start configuring `iptables`.\nConfiguring iptables\nThe `iptables` command requires superuser privileges. First, let’s check the current `iptables` configuration. The general syntax for retrieving the rules in a chain for a specific table is as follows:\n\n```", "```\n\n The `-L` (`--list`) option lists the rules in a *chain*. The `-t` (`--table`) option specifies a table. The `CHAIN` and `TABLE` parameters are optional. If the `CHAIN` option is omitted, *all* chains and their related rules are considered within a table. When no `TABLE` option is specified, the `filter` table is assumed. Thus, the following command lists all the chains and rules for the `filter` table:\n\n```", "```\n\n On a system with a default firewall configuration, the output is as follows:\n![Figure 9.43 – Listing the current configuration in iptables](img/B19682_09_43.jpg)\n\nFigure 9.43 – Listing the current configuration in iptables\nWe can be more specific—for example, by listing all the `INPUT` chain rules for the `nat` table with the following command:\n\n```", "```\n\n The `-t` (`--table`) option parameter is only required when `iptables` operations target something other than the default `filter` table.\nImportant note\nUnless the `-t` (`--table`) option parameter is specified, `iptables` assumes the `filter` table by default.\nWhen you’re designing firewall rules from a clean slate, the following steps are generally recommended:\n\n1.  Flush any remnants in the current firewall configuration.\n2.  Set up a default firewall policy.\n3.  Create firewall rules, making sure the more specific (or restrictive) rules are placed first.\n4.  Save the configuration.\n\nLet’s briefly look at each of the preceding steps by creating a sample firewall configuration using the `filter` table:\n\n1.  `filter` table’s chains (`INPUT`, `FORWARD`, and `OUTPUT`):\n\n    ```", "```\n\n![Figure 9.44 – Flushing existing configuration in iptables](img/B19682_09_44.jpg)\n\nFigure 9.44 – Flushing existing configuration in iptables\nImportant note\nThe flushing operation will delete all the rules in a specific chain. Please take into consideration that this kind of operation will disable your firewall. This can also lock you out of an SSH connection if you are using one, thus be careful when using the flushing operation.\n\n1.  `iptables` allows all packets to pass through the networking (firewall) chain. A secure firewall configuration should use `DROP` as the default target for the relevant chains:\n\n    ```", "```\n\n     2.  `192.168.0.0/24`):\n\n    ```", "```\n\n    3.  `-p tcp`: The networking protocol (for example, TCP or UDP) transporting the packets4.  `--dport 22`: The destination port of the packets5.  `--sport 22`: The source port of the packets6.  `-m state`: The packet property we want to match (for example, `state`)7.  `--state NEW,ESTABLISHED`: The state(s) of the packet to match8.  `-s 192.168.0.0/24`: The source IP address/mask originating the packets9.  `-j ACCEPT`: The target or what to do with the packets (such as `ACCEPT`, `DROP`, `REJECT`, and so on)\n\nWe used two commands to enable SSH access. The first allows incoming SSH traffic (`--dport 22`) for new and existing connections (`-m state --state NEW,ESTABLISHED`). The second command enables SSH response traffic (`--sport 22`) for existing connections (`-m state –``state ESTABLISHED`).\n\nSimilarly, the following commands enable HTTPS traffic:\n\n```", "```\n\nTo enable DNS traffic, we need to use the following commands:\n\n```", "```\nsudo service iptables save\n```", "```\n\n![Figure 9.45 – Saving the iptables configuration](img/B19682_09_45.jpg)\n\nFigure 9.45 – Saving the iptables configuration\nWe can also dump the current configuration to a file (such as `iptables.config`) for later use with the following command:\n\n```", "```\niptables backup configuration file.\nExploring more complex rules and topics with `iptables` is beyond the scope of this chapter. The examples we’ve presented so far, accompanied by the theoretical introduction of `iptables`, should be a good start for everyone to explore more advanced configurations. Also, tools such as newly emerging `nftables` are getting a lot of traction in some of the more recent versions of Linux distributions, and firewall management tools such as `ufw` and `firewalld` are used out of the box in distros such as Fedora, RHEL, openSUSE or Ubuntu.\nNext, we’ll look at `nftables`, a relatively new framework that was designed and developed by the *Netfilter project*, built to eventually replace `iptables`.\nIntroducing nftables\n`nftables` is a successor of `iptables`. `nftables` is a firewall management framework that supports packet filtering, NAT, and various packet shaping operations. `nftables` offers notable improvements in terms of features, convenience, and performance over previous packet filtering tools, such as the following:\n\n*   Lookup tables instead of linear processing of rules\n*   Rules are applied individually instead of processing a complete ruleset\n*   A unified framework for IPv4 and IPv6 protocols\n*   No protocol-specific extensions\n\nThe functional principles behind `nftables` generally follow the design patterns presented in earlier sections about firewall networking chains—that is, Netfilter and `iptables`. Just as with `iptables`, `nftables` uses tables to store chains. Each chain contains a set of rules for packet filtering actions.\n`nftables` is the default packet filtering framework in Debian and RHEL/Fedora Linux distributions, replacing the old `iptables` (and related) tools. The command-line interface for manipulating the `nftables` configuration is `nft`. Yet some users prefer to use a more user-friendly frontend instead, such as `firewalld` (which recently added backend support for `nftables`). RHEL/Fedora, for example, uses `firewalld` as its default firewall management solution.\nIn this section, we’ll show a few examples of how to use `nftables` and the related command-line utilities to perform simple firewall configuration tasks. For this purpose, we’ll take an RHEL/Fedora distribution where we’ll disable `firewalld`. Let’s have a quick look at the preparatory steps required to run the examples in this section.\nPrerequisites for our examples\nIf you have an RHEL 7 system, `nftables` is not installed by default. You can install it with the following command:\n\n```", "```\n\n The examples in this section use a Fedora 37 distribution. To directly configure `nftables`, we need to disable `firewalld` and potentially `iptables` (if you ran the examples in the *Working with iptables* section). The steps for disabling `firewalld` were shown at the beginning of the *Configuring* *iptables* section.\nAlso, if you have `iptables` enabled, you need to stop and disable the related service with the following commands:\n\n```", "```\n\n Next, we need to enable and start `nftables`:\n\n```", "```\n\n We can check the status of `nftables` with the following command:\n\n```", "```\n\n The running status of `nftables` should be `active`, as seen here:\n![Figure 9.46 – Checking the status of nftables](img/B19682_09_46.jpg)\n\nFigure 9.46 – Checking the status of nftables\nAt this point, we are ready to configure `nftables`. Let’s work with a few examples in the next section.\nWorking with nftables\n`ntftables` loads its configuration from `/etc/sysconfig/nftables.conf`. We can display the content of the configuration file with the following command:\n\n```", "```\n\n A default `nftables` configuration has no active entries in `nftables.conf`, except for a few comments:\n![Figure 9.47 – The default nftables configuration file](img/B19682_09_47.jpg)\n\nFigure 9.47 – The default nftables configuration file\nAs the comments suggest, we have a few options for changing the `nftables` configuration:\n\n*   Directly edit the `nftables.conf` file\n*   Manually edit the `/etc/nftables/main.nft` configuration file, then uncomment the related line in `nftables.conf`\n*   Use the `nft` command-line utility to edit the rules and then dump the current configuration into `nftables.conf`\n\nRegardless of the approach taken, we need to reload the updated configuration by restarting the `nftables` service. In this section, we’ll use `nft` command-line examples to change the `nftables` configuration. Power users usually write `nft` configuration scripts, but it’s best to learn the basic steps first.\nThe following command displays all the rules in the current configuration:\n\n```", "```\n\n Your system may already have some default rules set up. You may choose to do a backup of the related configuration (for example, `/etc/sysconfig/nftables.conf` and `/etc/nftables/main.nft`) before proceeding with the next steps.\nThe following command will flush any preexisting rules:\n\n```", "```\n\n At this point, we have an empty configuration. Let’s design a simple firewall that accepts SSH, HTTP, and HTTPS traffic, blocking anything else.\nAccepting SSH, HTTP, and HTTPS traffic\nFirst, we need to create a table and a chain. The following command creates a table named `packt_table`:\n\n```", "```\nsudo nft add chain inet packt_table packt_chain. Allow SSH, HTTP, and HTTPS access with the following rule:\n\n```", "```\nsudo nft add rule inet packt_table packt_chain ip protocol icmp accept\n```", "```\nsudo nft add rule inet packt_table packt_chain reject with icmp type port-unreachable\n```", "```\nsudo nft list ruleset\n```", "```\nsudo nft list ruleset | sudo tee /etc/nftables/packt.nft\n```", "```\ninclude \"/etc/nftables/packt.nft\"\n```", "```\nsudo vim /etc/sysconfig/nftables.conf\n```", "```\nsudo systemctl restart nftables\n```", "```\nsudo yum install -y firewalld\n```", "```\nsudo systemctl enable firewalld\n```", "```\nsudo firewall-cmd --get-zones\n```", "```\nsudo firewall-cmd --list-all-zones\n```", "```\nsudo firewall-cmd --get-active-zones\n```", "```\nsudo firewall-cmd --get-default-zone\n```", "```\nsudo firewall-cmd --zone=FedoraServer --add-rich-rule='rule protocol value=\"icmp\" reject'\n```", "```\nsudo firewall-cmd --info-zone=public\n```", "```\nsudo firewall-cmd --zone=FedoraServer --remove-rich-rule='rule protocol value=\"icmp\" reject'\n```", "```\nsudo firewall-cmd --zone=FedoraServer --add-rich-rule='rule protocol value=\"icmp\" accept'\n```", "```\nsudo firewall-cmd --list-services\n```", "```\nsudo firewall-cmd --zone=FedoraServer --add-service=https\n```", "```\nsudo firewall-cmd --zone=FedoraServer --add-port=8443/tcp\n```", "```\nsudo firewall-cmd --list-ports\n```", "```\nsudo firewall-cmd --reload\n```", "```\nsudo ufw status\n```", "```\nsudo ufw enable\n```", "```\nsudo ufw allow ssh\n```", "```\nsudo ufw status verbose\n```", "```\nsudo ufw app list\n```", "```\nsudo ufw deny http\n```", "```\nsudo ufw status numbered\n```", "```\nsudo ufw insert 2 deny http\n```", "```\nsudo ufw allow from 192.168.0.0/24 to any port 22\n```", "```\nsudo ufw logging on\n```", "```\ngrep -i ufw /var/log/syslog\n```", "```\nsudo ufw logging off\n```", "```\nsudo ufw reset\n```", "```\n\n```", "```\n\n```", "```\n\n```"]