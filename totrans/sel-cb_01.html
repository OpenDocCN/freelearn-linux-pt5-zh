<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;The SELinux Development Environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. The SELinux Development Environment</h1></div></div></div><p>This chapter covers the setup of the SELinux policy development environment. We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating the development environment</li><li class="listitem" style="list-style-type: disc">Building a simple SELinux module</li><li class="listitem" style="list-style-type: disc">Calling refpolicy interfaces</li><li class="listitem" style="list-style-type: disc">Creating our own interface</li><li class="listitem" style="list-style-type: disc">Using the refpolicy naming convention</li><li class="listitem" style="list-style-type: disc">Distributing SELinux policy modules</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introduction</h1></div></div></div><p>Similar to <a id="id0" class="indexterm"/>any other software development, having a well-functioning development environment is essential to successfully create and manage SELinux policies. Such an environment should not only support version control, but also be able to quickly search through the sources or show definitions.</p><p>With SELinux, this means that the policy module sources (which are all readable text files) should be stored in a structured manner, the upstream project that provides SELinux policies should be readily accessible, and the necessary functions or scripts to query and search through the policies should be available.</p><p>Adventurous<a id="id1" class="indexterm"/> users might want to take a look at<a id="id2" class="indexterm"/> the <span class="strong"><strong>SELinux Policy IDE</strong></span> (<span class="strong"><strong>SLIDE</strong></span>) as offered by Tresys Technology (<a class="ulink" href="http://oss.tresys.com/projects/slide">http://oss.tresys.com/projects/slide</a>). In this book, we do not focus on this IDE; instead, we use whatever file editor the user wants (such as VIM, Emacs, or Kate) and enhance the environment through the necessary shell functions and commands.</p><p>Before we cover the setup of the development environment, let's do a quick recapitulation of what SELinux is.</p><div class="section" title="About SELinux"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>About SELinux</h2></div></div></div><p>The <span class="strong"><strong>Security Enhanced Linux</strong></span> (<span class="strong"><strong>SELinux</strong></span>) project is the result of projects initiated and supported by the US <span class="strong"><strong>National Security Agency</strong></span> (<span class="strong"><strong>NSA</strong></span>) and came to life in December 2000. It is the implementation of a security <a id="id3" class="indexterm"/>system architecture with a flexible, policy-driven configuration approach. This architecture is called the <span class="strong"><strong>Flux Advanced Security Kernel</strong></span> (<span class="strong"><strong>Flask</strong></span>), and its related resources are still an important read for everyone involved with SELinux.</p><p>Most papers <a id="id4" class="indexterm"/>are linked through the Flask website at <a class="ulink" href="http://www.cs.utah.edu/flux/fluke/html/flask.html">http://www.cs.utah.edu/flux/fluke/html/flask.html</a>. The following are some examples of these papers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The paper called <span class="emphasis"><em>The Inevitability of Failure: The Flawed Assumption of Security in Modern Computing Environments</em></span> is still a very topical paper on why mandatory access controls are needed in operating systems</li><li class="listitem" style="list-style-type: disc">The NSA publication, <span class="emphasis"><em>Implementing SELinux as a Linux Security Module</em></span>, available at <a class="ulink" href="http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf">http://www.nsa.gov/research/_files/publications/implementing_selinux.pdf</a>, goes deeper into how SELinux is implemented</li></ul></div><p>Nowadays, SELinux can be best seen as an additional layer of security services on top of the existing Linux operating system. It is part of the mainstream Linux kernel and uses the <span class="strong"><strong>Linux Security Modules</strong></span> (<span class="strong"><strong>LSM</strong></span>) interfaces to hook into the interaction between processes (user space) and resources. It manages various access services (such as the reading of<a id="id5" class="indexterm"/> files, getting directory attributes, binding to domain sockets, connecting to TCP sockets, and gaining additional capabilities) through <a id="id6" class="indexterm"/>a powerful approach called <span class="strong"><strong>type enforcement</strong></span>.</p><p>The following diagram displays the high-level functional position of the SELinux subsystem. Whenever a subject (in the drawing, this is the <span class="strong"><strong>Application</strong></span>) wants to perform an action against<a id="id7" class="indexterm"/> a resource, this action is first checked by the Discretionary Access Control mechanism that the Linux kernel provides. After the action is checked and allowed by the DAC mechanism, the LSM implementation (against which SELinux is registered) calls the hooks that the SELinux subsystem has provided. SELinux then checks the policy (through the cache, and if the access is not registered in the cache yet, it checks in the entire policy) and returns whether the access should be allowed or not.</p><div class="mediaobject"><img src="graphics/9669OS_01_01.jpg" alt="About SELinux"/></div><p>SELinux is <a id="id8" class="indexterm"/>a Mandatory Access Control system in which the governed activities on the system are defined in rules that are documented through a policy. This policy is applicable to all processes of the system and enforced through the SELinux subsystem, which is part of the Linux kernel. Anything that is not allowed by the policy will not be allowed at all—security is not left at the discretion of the user or correctness of the application. Unlike Linux DAC restrictions, enforcement itself (the SELinux code) is separate from the rules (the SELinux policy). The rules document what should be considered as acceptable behavior on the system. Actions that do not fit the policy will be denied by the SELinux subsystem.</p><p>In SELinux, a set of access control mechanisms are supported. The most visible one is its type enforcement in which privileges of a subject (be it the kernel or a Linux process) towards an object (such as a file, device, system capability, or security control) are granted based on the current security context of that subject. This security context is most often represented through a readable string such as <code class="literal">staff_u:staff_r:staff_t:s0:c0,c3</code>. This string represents the SELinux user (<code class="literal">staff_u</code>), SELinux role (<code class="literal">staff_r</code>), SELinux type/domain (<code class="literal">staff_t</code>), and optionally, the SELinux sensitivity level or security clearance, which provides both the sensitivity (<code class="literal">s0</code>) as well as assigned categories (<code class="literal">c0,c3</code>).</p><p>Alongside type enforcement, SELinux has several other features as well. For instance, it provides <a id="id9" class="indexterm"/>a <span class="strong"><strong>role-based access control</strong></span> system by assigning valid domains (which are SELinux types assigned to running processes) to roles. If a role is not granted a particular domain, then that role cannot execute tasks or applications associated with that domain. SELinux also supports user-based access controls, thus limiting information flow and governing data sharing between SELinux users.</p><p>Another <a id="id10" class="indexterm"/>stronghold within SELinux is its support for sensitivities (which SELinux displays as integers, but these integers can very well be interpreted as public, internal, confidential, and so on) as well as access categories. Through the constraints that SELinux can impose in its policy, systems can be made to largely abide by <a id="id11" class="indexterm"/>the Bell-LaPadula model (<a class="ulink" href="https://en.wikipedia.org/wiki/Bell-LaPadula_model">https://en.wikipedia.org/wiki/Bell-LaPadula_model</a>). This model supports information flow restrictions such as no read up (lower sensitivities cannot read information from higher sensitivities) and no write down (higher sensitivities cannot leak information to lower sensitivities).</p></div><div class="section" title="The role of the SELinux policy"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>The role of the SELinux policy</h2></div></div></div><p>The SELinux <a id="id12" class="indexterm"/>policy itself is a representation of what the security administrator (the role that is usually mentioned as being the owner of what is and isn't allowed on a system) finds acceptable, expected, and normalized behavior:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Acceptable</strong></span>: Application<a id="id13" class="indexterm"/> and user<a id="id14" class="indexterm"/> behavior will be acceptable because it will be allowed on the system by the policy</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Expected</strong></span>: Application and user behavior will be expected as the policy usually<a id="id15" class="indexterm"/> doesn't (or shouldn't) contain <a id="id16" class="indexterm"/>access vectors (a permission assigned to a subject towards a particular object) that are not applicable to the system, even if it would be acceptable on other systems in the environment</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Normalized</strong></span>: Application and user behavior will be normalized not in the sense of <a id="id17" class="indexterm"/>database normalization, but <a id="id18" class="indexterm"/>as in normality—something that is consistent with the most common behavior of the process</li></ul></div><p>As a policy represents these behaviors, correct tuning and development of the policy is extremely important. This is why the <span class="emphasis"><em>SELinux Cookbook</em></span> will focus on policy development and policy principles.</p><p>A policy that is too restrictive will cause applications to malfunction, often in ways that its users will find unexpected. It will not be surprising to the security administrator of course, as he knows that the policy dictates what is allowed, and he is (or at least should be) perfectly aware of what the policy says.</p><p>However, a policy that is too broad will not result in such behavior. On the contrary, everything will work as expected. Sadly, when nonstandard or abnormal behavior is triggered, the (too) broadly defined policy might still allow this nonstandard or abnormal behavior to happen. When this abnormal behavior is an exploited vulnerability, then SELinux—as powerful as it can be—has nothing to deter the exploit, as the policy itself has granted the access. Another example of this principle would be a network firewall, whose policy can be too open as well.</p><p>Through the packaged approach that policies provide (SELinux policies are like loadable kernel modules, but then for the SELinux subsystem), administrators can push the policies to<a id="id19" class="indexterm"/> one or more systems, usually through the package management system or centralized configuration management system of choice. Unlike Linux DAC controls, which need to be applied on the files themselves, SELinux policies are much easier to handle and are even versionable—a trait much appreciated by administrators in larger environments.</p></div><div class="section" title="The example"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>The example</h2></div></div></div><p>Throughout this book, we<a id="id20" class="indexterm"/> will often come across settings that are optional or whose value is heavily dependent on the choices made by the system administrator. In order to not repeat documenting and explaining when a setting or value is configurable, we will use the following configuration settings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The SELinux type (which is configured in <code class="literal">/etc/selinux/config</code>) will be MCS in this book. It uses an MLS-enabled, single-sensitivity policy definition. This means that contexts will always have a sensitivity level or security clearance assigned when displayed, and the location of the SELinux policy configuration will always be shown in <code class="literal">/etc/selinux/mcs/</code>. Make sure to substitute this path with your own if the policy store on your environment is named differently. For instance, a Red Hat or Fedora installation defaults to <code class="literal">/etc/selinux/targeted/</code>.</li><li class="listitem" style="list-style-type: disc">Operations will be documented as they run through restricted users, which are aptly named <code class="literal">user</code> (for an unprivileged end user assigned the <code class="literal">user_r</code> role), <code class="literal">staff</code> (for a user that might perform administrative tasks and is assigned the <code class="literal">staff_r</code> and <code class="literal">sysadm_r</code> roles), and <code class="literal">root</code> (which is mapped to the <code class="literal">sysadm_r</code> role). Distributions might have users associated with the <code class="literal">unconfined_r</code> role. Whenever a step can be skipped for unconfined users, it will be explicitly mentioned.</li></ul></div></div></div></div>
<div class="section" title="Creating the development environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Creating the development environment</h1></div></div></div><p>We will <a id="id21" class="indexterm"/>now create a development environment in which the SELinux policies and upstream project code as well as the functions we use to easily query the SELinux policies will be stored. This environment will have the following three top-level locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">local/</code>: This<a id="id22" class="indexterm"/> location contains the SELinux rules that are local to the system and not part of a cooperatively developed repository (that is, where other developers work)</li><li class="listitem" style="list-style-type: disc"><code class="literal">centralized/</code>: This<a id="id23" class="indexterm"/> location contains checkouts of the various repositories used in the development environment</li><li class="listitem" style="list-style-type: disc"><code class="literal">bin/</code>: This<a id="id24" class="indexterm"/> location contains the supporting script(s) we will use to query the policy sources as well as troubleshoot the SELinux issues</li></ul></div><p>In this <a id="id25" class="indexterm"/>exercise, we will also populate the <code class="literal">centralized/</code> location with a checkout: the SELinux policy tree that is used by the current system.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Getting ready</h2></div></div></div><p>Look for a good location where the development environment should be stored. This usually is a location in the user's home directory, such as <code class="literal">/home/staff/dev/selinux/</code>. Whenever this book references a location with respect to the development environment, it will use the <code class="literal">${DEVROOT}</code> variable to refer to this location.</p><p>Another piece of information that we need is the location of the repository that hosts the SELinux policies of the current system. This location is distribution specific, so consult the distribution site for more information. At the time of writing this book, the policies for Gentoo<a id="id26" class="indexterm"/> Linux <a id="id27" class="indexterm"/>and Fedora can be found at the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/sjvermeu/hardened-refpolicy">https://github.com/sjvermeu/hardened-refpolicy</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://git.fedorahosted.org/git/selinux-policy.git">https://git.fedorahosted.org/git/selinux-policy.git</a></li></ul></div><p>Whenever version control is used, we will use <code class="literal">git</code> in this book. Other version control systems exist as well, but this too is outside the scope of this book.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How to do it…</h2></div></div></div><p>To create the development environment used in this book, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create the necessary directories:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ cd ${DEVROOT}</strong></span>
<span class="strong"><strong>~$ mkdir local centralized bin</strong></span>
</pre></div></li><li class="listitem">Create a checkout of the distributions' SELinux policy tree (which, in this example, is based on the Gentoo Linux repository):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ cd ${DEVROOT}/centralized</strong></span>
<span class="strong"><strong>~$ git clone git://git.overlays.gentoo.org/proj/hardened-refpolicy.git</strong></span>
</pre></div></li><li class="listitem">Create a <code class="literal">git</code> repository for the policies that we will develop throughout this book:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ cd ${DEVROOT}/local</strong></span>
<span class="strong"><strong>~$ git init</strong></span>
</pre></div></li><li class="listitem">Add the <code class="literal">functions.sh</code> script, which is available through the download pack of this book, to the <code class="literal">${DEVROOT}/bin/</code> location.</li><li class="listitem">Edit the <code class="literal">.profile</code>, <code class="literal">.bashrc</code>, or other shell configuration files that are sourced<a id="id28" class="indexterm"/> when our Linux user logs on to the system, and add in the following code:<div class="informalexample"><pre class="programlisting"># Substitute /home/staff/dev/selinux with your DEVROOT
DEVROOT=/home/staff/dev/selinux
# Substitute the next location with your distributions' policy checkout
POLICY_LOCATION=${DEVROOT}/centralized/hardened-refpolicy/
source ${DEVROOT}/bin/functions.sh</pre></div></li><li class="listitem">Log out and log in again, and verify that the environment is working by requesting the definition of the <code class="literal">files_read_etc_files</code> interface:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seshowif files_read_etc_files</strong></span>
<span class="strong"><strong>interface(`files_read_etc_files',`</strong></span>
<span class="strong"><strong>  gen_require(`</strong></span>
<span class="strong"><strong>    type etc_t;</strong></span>
<span class="strong"><strong>  ')</strong></span>

<span class="strong"><strong>  allow $1 etc_t:dir list_dir_perms;</strong></span>
<span class="strong"><strong>  read_files_pattern($1, etc_t, etc_t)</strong></span>
<span class="strong"><strong>  read_lnk_files_pattern($1, etc_t, etc_t)</strong></span>
<span class="strong"><strong>')</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How it works…</h2></div></div></div><p>The setup of the development environment helps us deal with policy development for further recipes. The checkout of the distributions' SELinux policy tree is to query the existing policy rules while developing new policies. SELinux does not require to have the policy sources available on a system (only the compiled binary SELinux policy modules and parts of the SELinux policy rules, which can be used by other policy modules). As a result, default installations usually do not have the policy rules available on the system.</p><p>By having the checkout at our disposal, we can review the existing SELinux policy files and happily use examples from it for our own use. A major user of this checkout is the <code class="literal">functions.sh</code> script, which uses the <code class="literal">${POLICY_LOCATION}</code> variable to know where the checkout is<a id="id29" class="indexterm"/> hosted. This script provides several functions that we'll use<a id="id30" class="indexterm"/> throughout this book; they will also help in querying the sources.</p><p>By sourcing this <code class="literal">functions.sh</code> script during log on, these functions are readily available<a id="id31" class="indexterm"/> in the user's shell. One of these functions is the <code class="literal">seshowif</code> function, which displays the rules of a particular interface. The example given shows the definition of the <code class="literal">files_read_etc_files</code> interface, which we used to validate that our setup is working correctly.</p><p>The <code class="literal">functions.sh</code> script can also work with the interface files that are available through <code class="literal">/usr/share/selinux/devel/</code> (on Fedora/Red Hat systems), making the checkout of the policy repository optional if the user does not need access to the complete policy rules. The policy location defined then is as follows:</p><div class="informalexample"><pre class="programlisting">export POLICY_LOCATION=/usr/share/selinux/devel/</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>There's more...</h2></div></div></div><p>Next to the distributions' SELinux policy tree, one can also use the reference policy SELinux tree. This is the upstream project that most, if not all, Linux distributions use as the source of their policies. It has to be said though that the reference policy often lags behind on the policy repositories of the individual distributions, as it has stricter acceptance criteria for policy enhancements.</p><p>It also doesn't hurt to check out the SELinux policy repositories of other distributions. Often, Linux distributions first do SELinux policy updates on their own repository before pushing their changes to the reference policy (which is called upstreaming in the free software development community). By looking at other distributions' repositories, developers can easily see if the necessary changes have been made in the past already (and are thus more likely to be correct).</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>See also</h2></div></div></div><p>For more information about the topics covered in this recipe, refer to the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id32" class="indexterm"/>reference policy project (<a class="ulink" href="http://oss.tresys.com/projects/refpolicy/">http://oss.tresys.com/projects/refpolicy/</a>)</li><li class="listitem" style="list-style-type: disc">The <a id="id33" class="indexterm"/>Git tutorial (<a class="ulink" href="http://git-scm.com/docs/gittutorial">http://git-scm.com/docs/gittutorial</a>)</li></ul></div></div></div>
<div class="section" title="Building a simple SELinux module"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Building a simple SELinux module</h1></div></div></div><p>Now that <a id="id34" class="indexterm"/>we have a development environment, it is time to create our first SELinux policy module. As its purpose does not matter at this point, we will focus on a privilege that is by default not allowed (and rightfully so) yet easy to verify, as we want to make sure that our policy development approach works. The privilege we are going to grant is to allow the system logger to write to a logfile labeled <code class="literal">named_conf_t</code> (the type used for the configuration of the BIND DNS server—known as <code class="literal">named</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Building SELinux policy modules is to extend the existing policy with more rules that allow certain accesses. It is not possible to create a policy module that reduces the allowed privileges for a domain. If this is needed, the policy module needs to recreate and substitute the existing policy (and thus, a distribution-provided policy will need to be removed from the system).</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Getting ready</h2></div></div></div><p>Before we <a id="id35" class="indexterm"/>get started, we first need to make sure that we can test the outcome of the change. A simple method would be to change the context of the <code class="literal">/var/log/messages</code> file (or another general logfile that the system logger is configured to use) and send messages through the system logger using the <code class="literal">logger</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ logger "Just a simple log event"</strong></span>
<span class="strong"><strong>~$ tail /var/log/messages</strong></span>
</pre></div><p>Verify that the message has indeed been delivered by looking at the last lines shown through<a id="id36" class="indexterm"/> the <code class="literal">tail</code> command. Then, change the context and try again. The event should not be shown, and a denial should be logged by the audit daemon:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# chcon -t named_conf_t /var/log/messages</strong></span>
<span class="strong"><strong>~$ logger "Another simple log event"</strong></span>
<span class="strong"><strong>~$ tail /var/log/messages</strong></span>
<span class="strong"><strong>~# ausearch -m avc -ts recent</strong></span>
</pre></div><p>With this in place, we can now create our first simple SELinux module.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>How to do it…</h2></div></div></div><p>Building a new SELinux policy is a matter of going through the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file called <code class="literal">mylogging.te</code> inside <code class="literal">${DEVROOT}/local</code> with the following content:<div class="informalexample"><pre class="programlisting">policy_module(mylogging, 0.1)
gen_require(`
  type syslogd_t;
  type named_conf_t;
 ')
# Allow writing to named_conf_t files
allow syslogd_t named_conf_t:file { getattr append lock ioctl open write };</pre></div></li><li class="listitem">Copy or link the <code class="literal">Makefile</code> file available in <code class="literal">/usr/share/selinux/devel/</code> or <code class="literal">/usr/share/selinux/mcs/include/</code> (the exact location is distribution specific) to the current directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ ln –s /usr/share/selinux/devel/Makefile</strong></span>
</pre></div></li><li class="listitem">Build the <a id="id37" class="indexterm"/>SELinux policy module through this <code class="literal">Makefile</code>. The target is to name the (target) policy module with the <code class="literal">.pp</code> suffix:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ make mylogging.pp</strong></span>
</pre></div></li><li class="listitem">Switch to the root user, and if we are logged on through an unprivileged SELinux domain/role, switch to the <code class="literal">sysadm_r</code> or <code class="literal">secadm_r</code> role (this is not needed if the current user domain is already <code class="literal">sysadm_t</code> or <code class="literal">unconfined_t</code>):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sudo –r sysadm_r –t sysadm_t -s</strong></span>
</pre></div></li><li class="listitem">Now, load the SELinux policy module (which will immediately activate the newly defined SELinux policy):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# semodule –i mylogging.pp</strong></span>
</pre></div></li><li class="listitem">Verify that the newly defined SELinux policy is active by generating a new log event and by looking at the logfile to see if it has indeed been registered.</li><li class="listitem">Commit the newly created files to the repository:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ cd ${DEVROOT}/local</strong></span>
<span class="strong"><strong>~$ git add mylogging.te Makefile</strong></span>
<span class="strong"><strong>~$ git commit –m 'Adding mylogging.te which allows the system logger to write to the named configuration file type named_conf_t'</strong></span>
</pre></div><p>When verified, reset the context of the logfile using <code class="literal">restorecon /var/log/messages</code> and remove the policy module from the subsystem using <code class="literal">semodule -r mylogging</code>. After all, we do not want this rule to stay active.</p></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How it works…</h2></div></div></div><p>There are three important, new aspects of SELinux policy development that we got in touch with in this recipe:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A policy source file called <code class="literal">mylogging.te</code> was created</li><li class="listitem" style="list-style-type: disc">A generated, binary policy module called <code class="literal">mylogging.pp</code> was built</li><li class="listitem" style="list-style-type: disc">The binary policy file, <code class="literal">mylogging.pp</code>, is added to the active policy store on the system</li></ul></div><p>At the end, we committed the file to our local repository. Using version control on policy files is recommended in order to track changes across time. A good hint would be to tag new releases of the policies—if users ever report issues with the policy, you can then ask them for the <a id="id38" class="indexterm"/>SELinux policy module version (through <code class="literal">semodule –l</code>) and use the tags in the repository to easily find rules for that particular policy module.</p><p>In the remainder of this book, we will no longer use <code class="literal">git add</code>/<code class="literal">commit</code> so that we can focus on the SELinux recipes.</p><div class="section" title="The policy source file"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>The policy source file</h3></div></div></div><p>In the <a id="id39" class="indexterm"/>recipe, we created a policy source file <a id="id40" class="indexterm"/>called <code class="literal">mylogging.te</code>, which contains the raw SELinux policy rules. The name, <code class="literal">mylogging</code>, is not chosen at random; it is a common best practice to name custom modules starting with <code class="literal">my</code> and followed by the name of the SELinux policy module whose content we are enhancing (in our case, the logging module that provides the SELinux policy for everything that is system-logging related). The <code class="literal">.te</code> suffix is not just a convention (referring to the type enforcement part of SELinux); the build system requires the <code class="literal">.te</code> suffix.</p><p>The policy module rules start with the <code class="literal">policy_module(…)</code> call, which tells the build system that the file will become a loadable SELinux policy module with the given name and version. This name and version will be displayed by the <code class="literal">semodule</code> command if we ask it to<a id="id41" class="indexterm"/> list all the currently loaded SELinux policy modules:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# semodule –l</strong></span>
<span class="strong"><strong>aide  1.8.0</strong></span>
<span class="strong"><strong>alsa  1.13.0</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>mylogging  0.1</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div><p>The best practice is to keep all rules for a single domain within a policy module. If rules for multiple unrelated domains are needed, it is recommended that you create multiple modules, as this isolates the policy rules and makes modifications more manageable.</p><p>In <a id="id42" class="indexterm"/>this simple example, we did not follow<a id="id43" class="indexterm"/> this best practice (yet). Instead, we told the SELinux subsystem that the policy is going to be enhanced with an access vector for <code class="literal">syslogd_t</code>. The access vector here is to allow this domain a set of permissions against files that are labeled as <code class="literal">named_conf_t</code>.</p></div><div class="section" title="The binary policy module"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>The binary policy module</h3></div></div></div><p>When <a id="id44" class="indexterm"/>we called the <code class="literal">Makefile</code> file, the underlying scripts built a loadable binary SELinux policy module. Such files have the <code class="literal">.pp</code> suffix and are ready to be loaded into the policy store. The <code class="literal">Makefile</code> file called might <a id="id45" class="indexterm"/>not be installed by default; some distributions<a id="id46" class="indexterm"/> require specific development packages to be installed (such as <code class="literal">selinux-policy-devel</code> in Fedora).</p><p>There is no nice way of retrieving the sources of a policy if we are only given the <code class="literal">.pp</code> file. Sure, there are commands such as <code class="literal">semodule_unpackage</code> and <code class="literal">sedismod</code> available, but these will only give a low-level view of the rules, not the original <code class="literal">.te</code> code. So, make sure to have backups, and as we saw in the example, use a versioning system to control changes across time.</p></div><div class="section" title="Loading a policy into the policy store"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Loading a policy into the policy store</h3></div></div></div><p>To load <a id="id47" class="indexterm"/>the newly created policy into<a id="id48" class="indexterm"/> the policy store, we called the <code class="literal">semodule</code> command. This <a id="id49" class="indexterm"/>application is responsible for managing the policy store (which is the set of all SELinux policy modules together with the base policy module) and linking or unlinking the modules together into a final policy.</p><p>This final policy (which can be found at <code class="literal">/etc/selinux/mcs/policy</code>) is then loaded into the SELinux subsystem itself and enforced.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>There's more...</h2></div></div></div><p>Throughout this book, the build system used is based on the reference policy build system. This is a collection of M4 macros and affiliated scripts that make the development of SELinux policies easier. This is, however, not the only way of creating SELinux policies.</p><p>When visiting online resources, you might come across SELinux policy modules whose structure looks like the following:</p><div class="informalexample"><pre class="programlisting">module somename 1.0;
require {
  type some_type_t;
  type another_type_t;
}
allow some_type_t another_type_t:dir { read search };</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>These are <a id="id50" class="indexterm"/>policy files that do not use the reference<a id="id51" class="indexterm"/> policy build system. To build such files, we first create an intermediate module file with <code class="literal">checkmodule</code>, after which we package the module file towards a loadable binary SELinux policy with <code class="literal">semodule_package</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ checkmodule -M –m –o somename.mod somename.te</strong></span>
<span class="strong"><strong>~$ semodule_package –m somename.mod –o somename.pp</strong></span>
</pre></div><p>To keep <a id="id52" class="indexterm"/>things simple, we will stick to the reference policy build system.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>See also</h2></div></div></div><p>Many topics and areas have been touched upon in this recipe. More information can be found at the following resources:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Most Linux distributions have distribution-specific information on how SELinux is <a id="id53" class="indexterm"/>integrated in the distribution. For Red Hat, these resources <a id="id54" class="indexterm"/>can be reached through <a class="ulink" href="https://access.redhat.com">https://access.redhat.com</a>. For Fedora, use <a class="ulink" href="https://docs.fedoraproject.org">https://docs.fedoraproject.org</a>. Gentoo has its documentation at <a class="ulink" href="https://wiki.gentoo.org">https://wiki.gentoo.org</a>.</li><li class="listitem" style="list-style-type: disc">For more information on how to administer SELinux on a system, consult the documentation provided by the distribution or read the <span class="emphasis"><em>SELinux System Administration</em></span> book published by Packt Publishing at <a class="ulink" href="http://www.packtpub.com/selinux-system-administration/book">http://www.packtpub.com/selinux-system-administration/book</a>.</li><li class="listitem" style="list-style-type: disc">Extensive coverage of the SELinux language itself is provided by the SELinux Notebook, which is available online at <a class="ulink" href="http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html">http://www.freetechbooks.com/the-selinux-notebook-the-foundations-t785.html</a>.</li></ul></div></div></div>
<div class="section" title="Calling refpolicy interfaces"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Calling refpolicy interfaces</h1></div></div></div><p>Writing up<a id="id55" class="indexterm"/> SELinux policies entirely using the standard language constructs offered by SELinux is doable, but it is prone to error and not manageable in the long term. To support a more simple language construct, the reference policy project uses a set of M4 macros that are expanded with the underlying SELinux policy statements when the policy is built.</p><p>The API that policy developers can use can be consulted online, but most systems also have this information available onsite at <code class="literal">/usr/share/doc/selinux-*/</code>. Finding proper interfaces requires some practice though, which is why one of the functions that we installed earlier (as part of the development environment) simplifies this for us.</p><p>In this recipe, we are going to edit the <code class="literal">mylogging.te</code> file we generated earlier with the right reference policy macro.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>How to do it…</h2></div></div></div><p>To use reference policy interfaces in an SELinux policy module, the following approach can be taken:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Use the<a id="id56" class="indexterm"/> <code class="literal">sefinddef</code> function to find permission groups or patterns to write to files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sefinddef 'file.*write'</strong></span>
<span class="strong"><strong>define(`write_files_pattern',`</strong></span>
<span class="strong"><strong>  allow $1 $3:file write_file_perms;</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>define(`write_file_perms',`{ getattr write append lock ioctl open }')</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div></li><li class="listitem">Use the <code class="literal">seshowdef</code> function to <a id="id57" class="indexterm"/>show the full nature of the <code class="literal">write_files_pattern</code> definition:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seshowdef write_files_pattern</strong></span>
<span class="strong"><strong>define(`write_files_pattern',`</strong></span>
<span class="strong"><strong>  allow $1 $2:dir search_dir_perms;</strong></span>
<span class="strong"><strong>  allow $1 $3:file write_file_perms;</strong></span>
<span class="strong"><strong>')</strong></span>
</pre></div></li><li class="listitem">Use the <code class="literal">sefindif</code> function to<a id="id58" class="indexterm"/> find the interface that will allow writing to <code class="literal">named_conf_t</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sefindif 'write_files_pattern.*named_conf_t'</strong></span>
<span class="strong"><strong>contrib/bind.if: interface(`bind_write_config',`</strong></span>
<span class="strong"><strong>contrib/bind.if:   write_files_pattern($1, named_conf_t, named_conf_t)</strong></span>
</pre></div></li><li class="listitem">Now, update the <code class="literal">mylogging.te</code> file to use this function. The file should now look like the following:<div class="informalexample"><pre class="programlisting">policy_module(mylogging, 0.2)
gen_require(`
  type syslogd_t;
')
bind_write_config(syslogd_t)</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Note the use of the backtick (<code class="literal">`</code>) and single quote (<code class="literal">'</code>). Whenever definitions are used, they need to start with a backtick and end with a single quote.</p></div></div></li><li class="listitem">Rebuild and reload the policy module, and then rerun the tests we did earlier to verify that this still allows us to write to the <code class="literal">named_conf_t labeled</code> file.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>How it works…</h2></div></div></div><p>One of the<a id="id59" class="indexterm"/> principles behind the build system of the reference policy is that an SELinux policy module should not directly mention SELinux types that are not related to that module. Whenever a policy module needs to define rules against a type that is defined by a different module, interfaces defined by that different module should be used instead.</p><p>In our example, we need the interface used by the BIND SELinux policy (which handles the BIND-named daemon policy rules); this interface allows us to write to the BIND DNS server configuration file type (<code class="literal">named_conf_t</code>). We can check the online API, the API documentation in <code class="literal">/usr/share/doc/selinux-*</code>, or just guess the interface name. However, in order to be certain that the interface does what we need, we need to query the interface definitions themselves.</p><p>That is where the <code class="literal">sefinddef</code>, <code class="literal">seshowdef</code>, <code class="literal">sefindif</code>, and <code class="literal">seshowif</code> functions come into play. These functions are not part of any SELinux user space—they are provided through the <code class="literal">functions.sh</code> file we installed earlier and are simple <code class="literal">awk</code>/<code class="literal">grep</code>/<code class="literal">sed</code> combinations against the SELinux policy files.</p><p>With <code class="literal">sefinddef</code> (the SELinux find definition), we <a id="id60" class="indexterm"/>can search through the support macros (not related to a particular SELinux policy module) for any definition that matches the expression given to it. In this recipe, we gave <code class="literal">file.*write</code> as the expression to look for. The <code class="literal">seshowdef</code> (SELinux show definition) function shows us the entire definition of the given<a id="id61" class="indexterm"/> pattern.</p><p>The <code class="literal">sefindif</code> (SELinux find interface) function then allows us to find an interface that the SELinux <a id="id62" class="indexterm"/>policy provides. In this recipe, we used it to search for the interface that allows a domain to write to the BIND DNS server configuration files. There is <a id="id63" class="indexterm"/>also a <code class="literal">seshowif</code> (SELinux show interface) function that shows us the entire interface definition like the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seshowif bind_write_config</strong></span>
<span class="strong"><strong>interface(`bind_write_config',`</strong></span>
<span class="strong"><strong>  gen_require(`</strong></span>
<span class="strong"><strong>    type named_conf_t;</strong></span>
<span class="strong"><strong>  ')</strong></span>
<span class="strong"><strong>  write_files_pattern($1, named_conf_t, named_conf_t)</strong></span>
<span class="strong"><strong>  allow $1 named_conf_t:file setattr_file_perms;</strong></span>
<span class="strong"><strong>')</strong></span>
</pre></div><p>This <a id="id64" class="indexterm"/>example interface nicely shows how interfaces are handled by the SELinux reference policy build system. Whenever such an interface is called, one or more arguments are given to the interface. In our case, we passed on <code class="literal">syslogd_t</code> as the first (and only) argument.</p><p>The build system then substitutes every <code class="literal">$1</code> occurrence in the interface with the first argument, effectively expanding the call to the following code:</p><div class="informalexample"><pre class="programlisting">write_files_pattern(<span class="strong"><strong>syslogd_t</strong></span>, named_conf_t, named_conf_t)
allow <span class="strong"><strong>syslogd_t</strong></span> named_conf_t:file setattr_file_perms;</pre></div><p>The call to <code class="literal">write_files_pattern</code> is then expanded with the definition we saw earlier.</p><p>For the policy developer, this is all handled transparently. The sources of the SELinux policy file stay well-formatted and only call the interfaces. It is at build time that the expansion of the various interfaces is done. This allows developers to have nicely segregated, compartmentalized policy definitions.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The<a id="id65" class="indexterm"/> reference policy project can be found online at <a class="ulink" href="http://oss.tresys.com/projects/refpolicy/">http://oss.tresys.com/projects/refpolicy/</a></li></ul></div></div></div>
<div class="section" title="Creating our own interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Creating our own interface</h1></div></div></div><p>Being able<a id="id66" class="indexterm"/> to call interfaces is nice, but when we develop SELinux policies, we will run into situations where we need to create our own interface for the SELinux module we are developing. This is done through a file with an <code class="literal">.if</code> extension.</p><p>In this recipe, we are going to extend the <code class="literal">mylogging</code> policy with an interface that allows other domains to execute the system log daemon binary (but without running this binary with the privileges of the system logger itself; this would be called a domain transition in SELinux).</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">If our current context is an unprivileged user domain (as unconfined domains are highly privileged and can do almost everything), we can try executing the system logger daemon (<code class="literal">syslog-ng</code> or <code class="literal">rsyslog</code>) directly and have it fail as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ /usr/sbin/syslog-ng --help</strong></span>
<span class="strong"><strong>bash: /usr/sbin/syslog-ng: Permission denied</strong></span>
</pre></div></li><li class="listitem">Now, create<a id="id67" class="indexterm"/> the <code class="literal">mylogging.if</code> file (in the same location where <code class="literal">mylogging.te</code> is) with the following content, granting all permissions needed to execute the binary:<div class="informalexample"><pre class="programlisting">## &lt;summary&gt;Local adaptation to the system logging SELinux policy&lt;/summary&gt;
 
##########################################
## &lt;summary&gt;
##    Execute the system logging daemon in the caller domain
## &lt;/summary&gt;
## &lt;desc&gt;
##   &lt;p&gt;
##     This does not include a transition.
##   &lt;/p&gt;
## &lt;/desc&gt;
## &lt;param name="domain"&gt;
##    &lt;summary&gt;
##      Domain allowed access.
##    &lt;/summary&gt;
## &lt;/param&gt;
#
interface(`logging_exec_syslog',`
  gen_require(`
    type syslogd_exec_t;
  ')
  can_exec($1, syslogd_exec_t)
')</pre></div></li><li class="listitem">Create a new SELinux policy module for the user domain; this policy should be able to execute the system logger directly. For instance, for the <code class="literal">sysadm_t</code> domain, we would create a <code class="literal">mysysadm.te</code> file with the following content:<div class="informalexample"><pre class="programlisting">policy_module(mysysadm, 0.1)
gen_require(`
  type sysadm_t;
')
logging_exec_syslog(sysadm_t)</pre></div></li><li class="listitem">Build the <code class="literal">mysysadm</code> policy module and load it. Then, test to see if the daemon binary can now be executed directly:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ /usr/sbin/syslog-ng --help</strong></span>
</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>How it works…</h2></div></div></div><p>Let's first look at how the build system knows where the interface definitions are. Then, we'll cover <a id="id68" class="indexterm"/>the in-line comment system used in the example.</p><div class="section" title="The location of the interface definitions"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>The location of the interface definitions</h3></div></div></div><p>Whenever <a id="id69" class="indexterm"/>an SELinux policy module is built, the<a id="id70" class="indexterm"/> build system sources all interface files it finds at the following locations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/usr/share/selinux/mcs/include/*</code> or <code class="literal">/usr/share/selinux/devel/include/*</code> (depending on the Linux distribution)</li><li class="listitem" style="list-style-type: disc">The current working directory</li></ul></div><p>The first location is where the interface files of all the SELinux modules provided by the Linux distribution are stored. The files are inside subdirectories named after particular categories (the reference policy calls these layers, but this is only used to make some structure amongst the definitions, nothing else) such as <code class="literal">contrib/</code>, <code class="literal">system/</code>, and <code class="literal">roles/</code>.</p><p>For local development of SELinux policies, this location is usually not writable. If we develop our own policy modules, then this would mean that none of the locally managed SELinux policy files can use interfaces of the other local interface files. The <code class="literal">Makefile</code> file, therefore, also sources all interface files it finds in the current working directory.</p></div><div class="section" title="The in-line documentation"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>The in-line documentation</h3></div></div></div><p>Inside<a id="id71" class="indexterm"/> the interface file created, we notice a few XML-like <a id="id72" class="indexterm"/>structures as comments. These comments are prefixed by a double hash sign (<code class="literal">##</code>) and are used by the reference policy build system to generate the API documentation (which can be found at <code class="literal">/usr/share/doc/selinux-*</code>).</p><p>For local policies, this in-line documentation is not used and, thus, not mandatory. However, writing the documentation even for local policies helps us in documenting the rules better. Also, if we ever want to push our changes upstream, this in-line documentation will be requested anyway.</p><p>The comment <a id="id73" class="indexterm"/>system uses the following constructs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Right before an interface definition, we encounter a <code class="literal">&lt;summary&gt;</code> element, which provides a one-sentence description of the interface</li><li class="listitem" style="list-style-type: disc">Additional information can then be provided through a <code class="literal">&lt;desc&gt;</code> element under which the HTML code can be placed for documenting the interface further</li><li class="listitem" style="list-style-type: disc">Every<a id="id74" class="indexterm"/> parameter to an interface is <a id="id75" class="indexterm"/>documented through a <code class="literal">&lt;param&gt;</code> entity, which again contains a <code class="literal">&lt;summary&gt;</code> line</li></ul></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec25"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id76" class="indexterm"/>reference policy API documentation can be found online at <a class="ulink" href="http://oss.tresys.com/docs/refpolicy/api/">http://oss.tresys.com/docs/refpolicy/api/</a></li></ul></div></div></div>
<div class="section" title="Using the refpolicy naming convention"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Using the refpolicy naming convention</h1></div></div></div><p>The interface<a id="id77" class="indexterm"/> names used to simplify policy development can be freely chosen. However, the reference policy itself uses a naming convention to try and structure the names used so that the SELinux policy developers can easily find the interfaces they need—if they exist—and give an unambiguous name to an interface they want to create.</p><p>The naming <a id="id78" class="indexterm"/>convention for the reference policy is available online at <a class="ulink" href="http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming">http://oss.tresys.com/projects/refpolicy/wiki/InterfaceNaming</a>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec26"/>Getting ready</h2></div></div></div><p>In this recipe, we'll do a pen-and-paper exercise to see how the naming convention works. In the example, we will create interface names for three situations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To read all logfiles</li><li class="listitem" style="list-style-type: disc">To connect to the HTTP port over TCP</li><li class="listitem" style="list-style-type: disc">To not audit getting the attributes of user home directories</li></ul></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec27"/>How to do it…</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First we need to figure out the file types that are involved in the situations:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Generic logfiles are <code class="literal">var_log_t</code> (as can be seen by querying the label of <code class="literal">/var/log/</code>itself):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ ls -dZ /var/log</strong></span>
<span class="strong"><strong>drwxr-xr-x. root root system_u:object_r:var_log_t:s0 /var/log</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">When we deal with all logfiles, we can safely assume this is handled by an SELinux attribute. Let's look at the attributes for the generic <code class="literal">var_log_t</code> type:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ seinfo –tvar_log_t –x</strong></span>
<span class="strong"><strong>  var_log_t</strong></span>
<span class="strong"><strong>    file_type</strong></span>
<span class="strong"><strong>    non_security_file_type</strong></span>
<span class="strong"><strong>    mountpoint</strong></span>
<span class="strong"><strong>    non_auth_file_type</strong></span>
<span class="strong"><strong>    logfile</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">logfile</code> attribute looks like an interesting hit. We can now grep<a id="id79" class="indexterm"/> through the policy sources to figure out which SELinux policy modules handle the <code class="literal">logfile</code> attribute, or use <code class="literal">sefindif</code> (assuming that there are interfaces defined that handle this attribute):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sefindif 'attribute logfile'</strong></span>
<span class="strong"><strong>system/logging.if: interface(`logging_log_file',`</strong></span>
<span class="strong"><strong>…</strong></span>
</pre></div></li><li class="listitem" style="list-style-type: disc">For the logfiles example, the module we need is called <code class="literal">logging</code> as can be seen from the <code class="literal">sefindif</code> output. Similarly, we will find that for the HTTP port, the module is <code class="literal">corenet</code>, and home directories are <code class="literal">userdom</code>.</li></ul></div></li><li class="listitem">Next, we check whether there is a modifier. The first two situations have no specific modifier (all the actions are regular verbs). The last example has one: do not audit. In the SELinux policy language, this is known as a <code class="literal">dontaudit</code> statement.</li><li class="listitem">Now, let's look at the verbs involved. This is mostly based on experience, but the situations show that there is a huge correlation between the verbs and the eventually chosen <code class="literal">refpolicy</code> name (which usually uses SELinux permission names):<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first situation, this is <code class="literal">read</code></li><li class="listitem" style="list-style-type: disc">The second one has <code class="literal">connect over TCP</code>, which is translated into <code class="literal">tcp_connect</code></li><li class="listitem" style="list-style-type: disc">The last situation has <code class="literal">getting the attributes</code>, so it is translated as <code class="literal">getattr</code></li></ul></div></li><li class="listitem">Finally, let's look at the object that is being referenced:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first situation, this is <code class="literal">all logfiles</code>, which we will name <code class="literal">all_logs</code></li><li class="listitem" style="list-style-type: disc">In the second situation, this is <code class="literal">HTTP port</code>, so we will name <code class="literal">http_port</code></li><li class="listitem" style="list-style-type: disc">The third situation has <code class="literal">user home directories</code>, so we will name <code class="literal">user_home_dirs</code></li></ul></div></li><li class="listitem">Combining <a id="id80" class="indexterm"/>this gives us the following <a id="id81" class="indexterm"/>interface names:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Read all logfiles</strong></span>: <code class="literal">logging_read_all_logs</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connect to the HTTP port over TCP</strong></span>: <code class="literal">corenet_tcp_connect_http_port</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Do not audit getting the attributes of user home directories</strong></span>: <code class="literal">userdom_dontaudit_getattr_user_home_dirs</code></li></ul></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec28"/>How it works…</h2></div></div></div><p>The naming convention that the reference policy uses is not mandated in a technical manner. Just like with coding styles, naming conventions are made so that collaboration is easier (everyone uses the same naming convention) and searching through the large set of interfaces can be directed more efficiently.</p><p>Using the proper naming convention is a matter of exercise. If uncertain, ask around in <code class="literal">#selinux</code> on <code class="literal">irc://irc.freenode.net</code> or on the reference policy mailing list.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec29"/>There's more...</h2></div></div></div><p>Take some time to look through the interface files available at <code class="literal">/usr/share/selinux/devel/include/</code>. Next, for the more standard permission-based interface names, there are also interface names used for templates and type assignation.</p><p>For instance, there is a template called <code class="literal">apache_content_template</code>. Through it, additional SELinux types and permissions (used for web applications) are created in one go. Similarly, there is an interface called <code class="literal">apache_cgi_domain</code> that marks a particular type as being a domain that can be invoked through a web servers' CGI support.</p><p>Besides <a id="id82" class="indexterm"/>the naming convention, the reference policy also<a id="id83" class="indexterm"/> has a style guide available at <a class="ulink" href="http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide">http://oss.tresys.com/projects/refpolicy/wiki/StyleGuide</a>. Like the naming convention, this is purely a human aspect for improved collaboration—there is no consequence of violating the coding style beyond the changes that might not be accepted in the upstream repositories.</p></div></div>
<div class="section" title="Distributing SELinux policy modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Distributing SELinux policy modules</h1></div></div></div><p>We <a id="id84" class="indexterm"/>finish this chapter by explaining how SELinux policy modules can be distributed across multiple systems.</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec30"/>How to do it…</h2></div></div></div><p>To distribute SELinux policies, complete the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Take into account the different system configurations to which the SELinux policies need to be distributed:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If multiple systems have different SELinux policy releases to be active, then build the SELinux policy module against each of these implementations. This is heavily distribution specific. For instance, on Gentoo, this is the version of the <code class="literal">sec-policy/selinux-base</code> package. On Red Hat and derived distributions, this is the version of the <code class="literal">selinux-policy</code> package.</li><li class="listitem" style="list-style-type: disc">If multiple SELinux policy types are active (such as <code class="literal">mcs</code>, <code class="literal">targeted</code>, and <code class="literal">strict</code>) and there are both MLS-enabled as well as MLS-disabled policies, then the SELinux policy module will need to be built against both an MLS-enabled policy as well as an MLS-disabled policy. The output of <code class="literal">sestatus</code> will tell us whether MLS is enabled on an active policy or not:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~$ sestatus | grep MLS</strong></span>
<span class="strong"><strong>Policy MLS status:    enabled</strong></span>
</pre></div></li></ul></div></li><li class="listitem">Package the resulting <code class="literal">.pp</code> files and distribute them to the various systems. It is a common best practice to place the <code class="literal">.pp</code> files inside <code class="literal">/usr/share/selinux/mcs/</code> (this is for an SELinux policy store named <code class="literal">mcs</code>, you can adjust it where needed).</li><li class="listitem">On each system, make sure that the <code class="literal">.pp</code> file is loaded through <code class="literal">semodule –I policyfile.pp</code>.</li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec31"/>How it works…</h2></div></div></div><p>SELinux policy modules (the files ending with <code class="literal">.pp</code>) contain everything SELinux needs to activate the policy. By distributing these files across many systems (and loading it through the <code class="literal">semodule</code> command), these systems receive the wanted updates against their current SELinux policy.</p><p>Once loaded (and this only needs to happen once, as a loaded module is retained even after the system reboots), one does not really need the <code class="literal">.pp</code> files anymore (loaded modules are copied inside <code class="literal">/etc/selinux</code>). However, it is recommended that you keep the policies there so that administrators can reload policies as needed; this might help in troubleshooting the SELinux policy and system permission issues.</p><p>There <a id="id85" class="indexterm"/>are a few caveats to take into account though:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Changes in interfaces</li><li class="listitem" style="list-style-type: disc">Kernel version changes</li><li class="listitem" style="list-style-type: disc">MLS-enabled or MLS-disabled policies</li></ul></div><div class="section" title="Changes in interfaces"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec06"/>Changes in interfaces</h3></div></div></div><p>The <code class="literal">.pp</code> files <a id="id86" class="indexterm"/>contain all rules that SELinux needs to enforce the additional policy rules. This includes the (expanded) rules that were <a id="id87" class="indexterm"/>part of the interface definition <a id="id88" class="indexterm"/>files (the <code class="literal">.if</code> files) of the module itself as well as the interfaces referred to by the policy module.</p><p>When an update against an interface occurs, then all SELinux policy modules that might be affected by the change need to be rebuilt. As there is no simple way to know if a module needs to be rebuilt or not, it is recommended that you rebuild all policy modules every time a change has occurred to at least one interface.</p><p>Distributions will handle the rebuilding of the policies and the distribution of the rebuilt policies themselves, but for custom policy modules, we need to do this ourselves.</p></div><div class="section" title="Kernel version changes"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec07"/>Kernel version changes</h3></div></div></div><p>New <a id="id89" class="indexterm"/>kernel releases might include <a id="id90" class="indexterm"/>updates against the SELinux subsystem. When these updates provide additional features, the binary representation of a policy might be updated. This is then reflected in the binary version of the policy that the kernel supports.</p><p>Binary versions are backward compatible, so a system that supports a maximum version of <code class="literal">28</code> (SELinux's binary versions are integers that are incremented with every change) will also support loading policy modules of a lower binary version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>~# sestatus</strong></span>
<span class="strong"><strong>SELinux status:      enabled</strong></span>
<span class="strong"><strong>SELinuxfs mount:      /sys/fs/selinux</strong></span>
<span class="strong"><strong>SELinux root directory:    /etc/selinux</strong></span>
<span class="strong"><strong>Loaded policy name:    mcs</strong></span>
<span class="strong"><strong>Current mode:      enforcing</strong></span>
<span class="strong"><strong>Mode from config file:    enforcing</strong></span>
<span class="strong"><strong>Policy MLS status:      enabled</strong></span>
<span class="strong"><strong>Policy deny_unknown status:  denied</strong></span>
<span class="strong"><strong>Max kernel policy version:  28</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>When the binary version of an SELinux policy module is higher than the maximum kernel policy version, this SELinux policy module will not load on the <a id="id91" class="indexterm"/>target system. A higher <a id="id92" class="indexterm"/>version means that the policy uses features that are only available in kernels that support this version, so the administrator will need to update the kernels on those systems to support the higher version or update the SELinux policy module to not use these features so that a rebuild creates a lower-versioned binary SELinux policy module.</p></div></div></div><div class="section" title="MLS or not"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec08"/>MLS or not</h3></div></div></div><p>SELinux <a id="id93" class="indexterm"/>policy modules might contain <a id="id94" class="indexterm"/>sensitivity-related information. When a policy module is <a id="id95" class="indexterm"/>built, information is added to <a id="id96" class="indexterm"/>reflect whether it is built against an MLS-enabled system<a id="id97" class="indexterm"/> or not.</p><p>Therefore, if we have hosts that have diverse policy usages (some policy stores are MLS-enabled and some are MLS-disabled), then the SELinux policy module will need to be built against both and distributed separately.</p><p>Usually, this is done by providing SELinux policy modules for each particular SELinux policy type (be it <code class="literal">mcs</code>, <code class="literal">strict</code>, or <code class="literal">targeted</code>).</p></div></div></div></body></html>