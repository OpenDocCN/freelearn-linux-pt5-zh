<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Nginx – Deploying a Performance-centric Web Server</h1></div></div></div><p>When it comes to web servers, it seems that Apache gets all the attention, and you may be led to believe that there is little competition; so let me introduce Nginx to you. We have seen many<a class="indexterm" id="id369"/> articles implementing the <strong>Linux Apache MySQL and PHP</strong> (<strong>LAMP</strong>) technology. We shall play this a little left field and look at <strong>Linux Nginx MySQL and PHP</strong> (<strong>LEMP</strong>); the E in LEMP<a class="indexterm" id="id370"/> comes from the phonetic version of the web server that is pronounced <em>engine-x</em>, allowing us to place a well needed vowel to create the acronym LEMP. The web server was first introduced in 2004, and Nginx is beginning to make inroads into the enterprise web space, being faster to deliver web content than equivalent Apache servers.</p><p>The following topics are going to be covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Installing and configuring Nginx</strong>: We will install and configure the Nginx web server</li><li class="listitem" style="list-style-type: disc"><strong>Installing PHP</strong>: We will install PHP5 to integrate with Nginx</li><li class="listitem" style="list-style-type: disc"><strong>Installing MySQL</strong>: We will install and configure the MySQL database server</li><li class="listitem" style="list-style-type: disc"><strong>Creating dynamic web content</strong>: Using the LEMP stack, we will learn to create simple dynamic web pages</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec45"/>Installing and configuring Nginx</h1></div></div></div><p>To begin <a class="indexterm" id="id371"/>this chapter, we will need to install the web server Nginx on <a class="indexterm" id="id372"/>our <a class="indexterm" id="id373"/>CentOS system. Nginx is the<a class="indexterm" id="id374"/> new <a class="indexterm" id="id375"/>kid on the block in terms of web servers, but in recent surveys from NetCraft, <a class="ulink" href="http://www.netcraft.com">http://www.netcraft.com</a>, we <a class="indexterm" id="id376"/>have seen that the Internet has fallen a little out of love with Apache,<a class="indexterm" id="id377"/> with Nginx making steady rises since its introduction in<a class="indexterm" id="id378"/> 2004. That said, in May 2014, Apache still had 37 percent <a class="indexterm" id="id379"/>of the web server share with Microsoft at 33 percent <a class="indexterm" id="id380"/>and Nginx at 14 percent.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec50"/>Installing Nginx</h2></div></div></div><p>Nginx is<a class="indexterm" id="id381"/> not part of the standard repositories, but we can use the EPEL repository that we used to install the 389-ds we looked at in <a class="link" href="ch07.html" title="Chapter 7. LDAP – A Better Type of User">Chapter 7</a>, <em>LDAP – A Better Type of User</em>. With the <strong>Extra Packages for Enterprise Linux</strong> (<strong>EPEL</strong>) repository in <a class="indexterm" id="id382"/>place, we can install using yum, and then<a class="indexterm" id="id383"/> once we have Nginx installed, we can start the service and configure it with <code class="literal">chkconfig</code> to start on the system boot:</p><div><pre class="programlisting">
<strong># yum install nginx</strong>
<strong># service nginx start</strong>
<strong># chkconfig nginx on</strong>
</pre></div><p>There is a welcome page configured in the default site's configuration that points to <code class="literal">/usr/share/nginx/html/</code>. We will leave this in place, but will create our own document root soon. We can test the functionality of the web server by browsing to the site <code class="literal">http://localhost</code> as seen in the following screenshot:</p><div><img alt="Installing Nginx" src="img/5920OS_08_01.jpg"/></div><p>That was really quite easy, wasn't it! We probably need to replace this web page with one of our <a class="indexterm" id="id384"/>own and tidy up some other configurations; but<a class="indexterm" id="id385"/> this simple test is good enough to prove the site is up and running.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Configuring Nginx</h2></div></div></div><p>The <a class="indexterm" id="id386"/>configuration directory for Nginx, or what is referred to as <code class="literal">ServerRoot</code>, is <code class="literal">/etc/nginx</code>. The main configuration file is <code class="literal">/etc/nginx/nginx.conf</code>; however, the web server takes a very modular approach to its configuration,<a class="indexterm" id="id387"/> and there is an include statement within the main configuration file that will reference all <code class="literal">.conf</code> files in <code class="literal">conf.d</code>. The statement from the <code class="literal">nginx.conf</code> reads as follows:</p><div><pre class="programlisting">include /etc/nginx/conf.d/*.conf</pre></div><p>In this way, it is easy to add in additional configurations without having to edit existing files and risking costly errors. The default configuration that defines the initial server is <code class="literal">/etc/nginx/conf.d/default.conf</code>. To help understand a little of the anatomy of the Nginx configurations files, let's take a look at the following diagram:</p><div><img alt="Configuring Nginx" src="img/5920OS_08_02.jpg"/></div><p>To gain the best understanding of the configuration of Nginx, it is often better to start with your own configuration. Start with something simple and add to it. To this end, we will rename <code class="literal">default.conf</code> to something else and create our own configuration. For a simple server configuration, we need little more than five lines of code:</p><div><pre class="programlisting">server {
    listen 80;
    root /var/www/html;
    index index.html;
}</pre></div><p>The previous lines can save this configuration to the new file, <code class="literal">/etc/nginx/conf.d/main.conf</code>. We will then rename the original configuration <code class="literal">/etc/nginx/conf.d/default.conf</code> to <code class="literal">/etc/nginx/conf.d/default.conf.old</code>. It is only <code class="literal">.conf</code> files that are included so in this way, we can maintain the original configuration without effecting the operation of the web server.</p><p>The new <a class="indexterm" id="id388"/>configuration<a class="indexterm" id="id389"/> that we have is very simple and sparse, and we can explain the limited directives:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">listen</code>: We will listen on all interfaces to TCP port 80.</li><li class="listitem" style="list-style-type: disc"><code class="literal">root</code>: Here we set the document root to <code class="literal">/var/www/html</code>. It is better to have variable content like this in the <code class="literal">/var</code> structure rather than the default location of <code class="literal">/usr</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">index</code>: We set the default page, often known as the welcome page, to <code class="literal">index.html</code>. If the URL from the client is entered using the server name only or server name with a directory path without specifying a web page, then the server will look for a page named <code class="literal">index.html</code>.</li></ul></div><p>We will need to create the directory structure for the document root and fashion a simple web page:</p><div><pre class="programlisting">
<strong># mkdir /var/www/html </strong>
<strong>#echo '&lt;h1&gt;Welcome to NGINX&lt;/h1&gt;' &gt; /var/www/html/index.html</strong>
</pre></div><p>In an ideal world, before restarting the Nginx server, we should endeavor to test any configuration changes. In this way, we can avoid the embarrassing issue where the restart of the server is interrupted by configuration anomalies. When we issue a restart to the service, we will need to first stop and then start Nginx. Stopping the service will not be a problem, but the start might be if we have omitted a semi-colon or other little typo. Consequently, it may be few minutes before we can identify the problem and resume normal service. Having made any changes to the Nginx configuration, we should always test the integrity of these edits before restarting. Using the <code class="literal">/usr/sbin/nginx -t</code> command, we can perform this check and ensure that if we stop the server, we will be able to start it again. If you prefer, the same test is available by the use of the <code class="literal">service nginx configtest</code> command.</p><p>Other options to the <code class="literal">nginx</code> command include <code class="literal">-v</code> for the version of Nginx and <code class="literal">-V</code> to show the version and configuration options. If we do come across errors, we can check the logfile <code class="literal">/var/log/nginx/error.log</code>. The <code class="literal">tail</code> command is often good for this since only the last 10 lines will be shown. The path to the error log is configured in the <code class="literal">/etc/nginx/nginx.conf</code> with the following line:</p><div><pre class="programlisting">error_log /var/log/nginx/error.log</pre></div><p>If required, you could change this to a different logfile; but the default seems reasonable. For now, we can satisfy ourselves that the configuration is OK and restart the service as follows:</p><div><pre class="programlisting">
<strong># nginx -t &amp;&amp; service nginx restart</strong>
</pre></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>In this command sequence, the <code class="literal">&amp;&amp;</code> operator ensures that the restart will only occur if the first command succeeds and the configuration check gave no errors.</p></div></div><p>We<a class="indexterm" id="id390"/> can revisit our site now. It may appear a little less glamorous,<a class="indexterm" id="id391"/> but it is all our own work as we can see in the following screenshot:</p><div><img alt="Configuring Nginx" src="img/5920OS_08_03.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Configuring a 404 Document Not Found Error page</h2></div></div></div><p>Another<a class="indexterm" id="id392"/> small change we will <a class="indexterm" id="id393"/>implement is to control the page not found or HTTP 404 errors. If a user types a page that does not exist, then they will be displayed a very simple error page. We can customize this a little and, at least, give the user a link back to the main index page. If we reedit the configuration file, <code class="literal">/etc/nginx/conf.d/main.conf</code> it will now read:</p><div><pre class="programlisting">server {
    listen 80;
    root /var/www/html;
    index index.html;
    error_page 404 not_found.html;
}</pre></div><p>The extra line <code class="literal">error_page</code> looks for HTTP 404 errors and returns the page <code class="literal">not_found.html</code>. We, of course, need to create the page, and it could look similar to this, as a very simple example providing the error and a link to return to the index page:</p><div><pre class="programlisting">&lt;h2&gt;We could not locate the document&lt;/h2&gt;
&lt;a href='/index.html'&gt;Home&lt;/a&gt;</pre></div><p>Remember to test the configuration; we can restart the web server as follows:</p><div><pre class="programlisting">
<strong># nginx -t &amp;&amp; service nginx restart</strong>
</pre></div><p>Then, access a page that we know does not exist, such as <code class="literal">http://localhost/page1.html</code>. We should see the new error page, which may look like this if you used my example:</p><div><img alt="Configuring a 404 Document Not Found Error page" src="img/5920OS_08_04.jpg"/></div><p>Although the design of the web page is simple and bare, we are not trying to teach HTML or CSS <a class="indexterm" id="id394"/>tricks here, but more about <a class="indexterm" id="id395"/>gaining the idea of how we can use directives in Nginx to issue our own custom error pages.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec46"/>Installing PHP</h1></div></div></div><p>Now that we have the web server up and running, we can add the PHP processor that we need to be <a class="indexterm" id="id396"/>able to add PHP elements to our page and subsequently<a class="indexterm" id="id397"/> create dynamic web content. Nginx uses the PHP FastCGI Process Manager, which is again available from the EPEL repository. We have that set up already from the Nginx install and the earlier install of 389-ds. To install PHP and the PHP-FPM, we can use <code class="literal">yum</code>:</p><div><pre class="programlisting">
<strong># yum install php-fpm</strong>
</pre></div><p>Once installed, we need to edit the FPM so that it uses the correct accounts for Nginx. To do this, we can edit <code class="literal">/etc/php-fpm.d/www.conf</code>. We will need to edit the user and group lines from <code class="literal">apache</code> to <code class="literal">nginx</code>:</p><div><pre class="programlisting">user = nginx
group = nginx</pre></div><p>We also need to make sure that the Nginx web server knows to forward PHP files to the FPM service on port 9000. We can re-edit <code class="literal">/etc/nginx/conf.d/main.conf</code> and add it to the server section:</p><div><pre class="programlisting">server {
 listen 80;
 root /var/www/html;
 index index.html;
 error_page 404 not_found.html;
 location ~ \.php$  {
  fastcgi_pass 127.0.0.1:9000;
  fastcgi_index index.php;
  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name
  include fastcgi_params;
 }

}</pre></div><p>The code <a class="indexterm" id="id398"/>we add is all within the original server block. The file will end <a class="indexterm" id="id399"/>correctly with two right braces. We are closing the new location block and the original server code block. Taking stock of the edit, we can see that we have defined a <code class="literal">location</code> block. This is used when we access a web page that ends with <code class="literal">.php</code> or, more simply, a PHP page. The definition for the location block looks a little akin to comic book profanities, and that should identify for you that it is in fact a regular expression; the tilde (<code class="literal">~</code>) denotes that we look for a regular expression match. The expression we search for is URLs that end in <code class="literal">.php</code>. The <code class="literal">$ </code>symbol denotes the end of the string. The complete expression starts with the escape character <code class="literal">\</code>; this is needed as the period (dot) has special meaning in regular expressions. To protect this, we use <code class="literal">\</code> to inform Nginx to read it as literal dot rather than as a regular expression language element. The rest of the code block then denotes that we should pass the PHP code through to the PHP interpreter by means of port 9000 on the local host. The <code class="literal">include</code> statement reads in a preconfigured file for PHP to set various parameter values.</p><p>We can now test and restart the Nginx web server and start the FPM service, configuring it for autostart:</p><div><pre class="programlisting">
<strong># nginx -t &amp;&amp; service nginx restart</strong>
<strong># service php-fpm start</strong>
<strong># chkconfig php-fpm on</strong>
</pre></div><p>With a little luck and a following wind, all has been successful, but of course, we do need to test a PHP page now; this can be easily achieved by calling a simple <code class="literal">phpinfo()</code> function. This is a really simple test that will prove PHP is up and running on your CentOS system. We will return to the Nginx document root directory, <code class="literal">/var/www/html</code> and create a new page, <code class="literal">info.php</code>. The PHP extension is important as this is what we look for in the location block: to direct through to the PHP interpreter. The page that we will create could not be any more simple; however, the power behind the function will display a lot in your web browser for very little typing. We can mix HTML code and PHP code in the single file, but we will just use only PHP here. The PHP block starts with <code class="literal">&lt;?php</code> and ends with the closing tag, <code class="literal">?&gt;</code>. Each line of PHP code ends with a semi-colon. The <code class="literal">/var/www/html/info.php</code> file will look like this when edited:</p><div><pre class="programlisting">&lt;?php
    phpinfo();
?&gt;</pre></div><p>When we direct the browser to the page with <code class="literal">http://127.0.0.1/info.php</code>, we should be encouraged <a class="indexterm" id="id400"/>with a comprehensive page detailing the configuration <a class="indexterm" id="id401"/>of PHP on our CentOS host. See the output from my system in the following screenshot:</p><div><img alt="Installing PHP" src="img/5920OS_08_05.jpg"/></div><p>Very quickly we have been able to demonstrate the power that lies behind PHP with this simple test. We also can be confident that we have configured PHP correctly with Nginx on our system. We will now add the MySQL database.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec47"/>Installing MySQL</h1></div></div></div><p>MySQL is the <a class="indexterm" id="id402"/>open source database solution now managed by<a class="indexterm" id="id403"/> Oracle, and of course this is a pivotal component of the LEMP <a class="indexterm" id="id404"/>stack that we are implementing. The MySQL server can store data to be displayed later on our web pages. We will communicate from Nginx using PHP with the database server. We can use <code class="literal">yum</code> to install MySQL and the PHP modules:</p><div><pre class="programlisting">
<strong># yum install php-mysql mysql-server</strong>
<strong># service mysqld start</strong>
<strong># chkconfig mysqld on</strong>
</pre></div><p>Once MySQL is installed, we need to secure the installation a little further; even if it is only to set the MySQL root password. Out of the box security in many systems tends to be a little light. Using the <code class="literal">mysql_secure_installation</code> command, we can add a little extra security. Running the program will lead you into a simple interactive prompted session:</p><div><pre class="programlisting">
<strong># mysql_secure_installation</strong>
</pre></div><p>The resulting wizard will prompt you through the process described in the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Enter current password for root</strong>: This is currently blank, so just use the <em>Enter</em> key.</li><li class="listitem" style="list-style-type: disc"><strong>Set root password</strong>: We will choose <code class="literal">Y</code>.</li><li class="listitem" style="list-style-type: disc"><strong>New Password</strong>: Enter the new password twice.</li><li class="listitem" style="list-style-type: disc"><strong>Remove anonymous users</strong>: Choose <code class="literal">Y</code> for this. In this way, only configured accounts have access.</li><li class="listitem" style="list-style-type: disc"><strong>Disallow root login remotely</strong>: This is usually a good idea, preventing remote MySQL root access. We only need access from this host, so we will answer <code class="literal">Y</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Remove test database and access to it</strong>: There is a database test that is empty. If we do not need it, we should delete it.</li><li class="listitem" style="list-style-type: disc"><strong>Reload privilege table now</strong>: We will answer <code class="literal">Y</code> to make these settings effective.</li></ul></div><p>If for <a class="indexterm" id="id405"/>nothing else, this is one of the simplest ways to set the<a class="indexterm" id="id406"/> MySQL root account password and remind us to verify other settings as we run through the simple script. When we are ready, we can test the operation of the database server from the Linux command line:</p><div><pre class="programlisting">
<strong>$ mysql -u root -p -e 'show databases;'</strong>
</pre></div><p>We are authenticating as root and will be prompted for the password we set earlier. The <code class="literal">-e</code> option allows us to execute a MySQL query directly from the command line, and the subsequent query we issue will list all databases. Of course, these will be system databases, as we have not created our own. We can use this same query within a web page to show that we have connectivity to the database from Nginx later. From the query results, we should see two databases listed: <code class="literal">information_schema</code> and <code class="literal">mysql</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec48"/>Create dynamic web content</h1></div></div></div><p>To demonstrate<a class="indexterm" id="id407"/> how easily we can create dynamic web pages that will connect to the database using PHP from the Nginx server, we will create a new PHP page in <code class="literal">/var/www/html</code>. So fire up your favorite editor, and we will create the page within the document root, <code class="literal">/var/www/html/db.php</code>:</p><div><pre class="programlisting">&lt;h2&gt;Databases&lt;/h2&gt;
&lt;?php
      $dbh=mysqli_connect("localhost","root","Password1");
      $result=mysqli_query($dbh, "SHOW DATABASES");
      while ($row = mysqli_fetch_assoc($result)) {
        echo $row['Database'] . "&lt;BR&gt;";
      }
?&gt;</pre></div><p>The code<a class="indexterm" id="id408"/> again is kept as simple as possible, and ideally we would include the connection credentials stored within another file that was not accessible to the web server, allowing access only from the PHP process; however, keeping the code to a minimum does aide the learning process at this early stage.</p><p>In this PHP file, you can see that we mix a little HTML code with the PHP code, starting with heading tags before entering into the PHP block. The PHP code first connects to the MySQL server, and then we execute the same query we demonstrated before, from the command line. Before we test this, we will need to restart Nginx and the <code class="literal">php-fpm</code> service:</p><div><pre class="programlisting">
<strong># service nginx restart</strong>
<strong># service php-fpm restart</strong>
</pre></div><p>This time, the results will show in the web browser and illustrating that we have a simple dynamic page created from database content. At this stage, we can be happy that we have a LEMP server up and running. With this proof of concept in place, we can now consider building further projects on the LEMP stack, and I certainly hope that you can take a little enthusiasm away with you to read a little more on what you can achieve with PHP and MySQL.</p><p>This is the home page that you'll be seeing:</p><div><img alt="Create dynamic web content" src="img/5920OS_08_06.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we have seen how we can build upon the CentOS host and the LEMP stack and implementing Nginx, MySQL, and PHP. Nginx is quite simple to configure but provides faster access to web content than Apache, but can equally be configured to communicate with PHP and MySQL in the backend. Gaining the basic knowledge of configuring PHP and MySQL to operate with the web server can build the grounding you need to develop your web application further.</p><p>In the following chapter, we will see how to implement Puppet on CentOS as a central configuration server to allow configuration changes to be made on one server to replicate to other configured clients.</p></div></body></html>