- en: Chapter 3. Using OpenLDAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a basic OpenLDAP server installed, configured, and running,
    it is time to turn our attention to using OpenLDAP. In this chapter we will be
    looking at what the various applications in the **OpenLDAP suite** do. In the
    process, we will discuss LDAP operations, create our initial directory tree, and
    use the OpenLDAP clients and utilities to interact with the directory server.
    As we do this we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic functional division of the OpenLDAP tools: daemons, clients, and
    utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic directory server operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an initial directory tree in an LDIF file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading the data into the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the directory records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting passwords and authenticating against the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we will also see many new LDAP terms and concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A Brief Survey of the LDAP Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we saw that the OpenLDAP suite was composed of daemons,
    libraries, clients, and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In UNIX parlance, a daemon is a process that runs for long periods of time
    without user interaction. It is a process that runs in the background. A server
    is a type of daemon that answers requests from other applications (clients). There
    are two daemons in the OpenLDAP suite: the SLAPD daemon (server) and the SLURPD
    daemon. In the next section we will look at these two.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a host of utilities included with OpenLDAP too. Utilities are programs
    that assist in managing the directory but do not use the LDAP protocol. They do
    things like maintain indexes, dump the contents of the database, and assist with
    migrating records from one directory to another.
  prefs: []
  type: TYPE_NORMAL
- en: Clients, in contrast to utilities, are programs that connect to the directory
    server using the LDAP protocol and perform directory operations, such as searching
    for, adding, modifying, and deleting records from the directory.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at all of the utilities and clients. But before we dive into that
    we will look at the daemons and some of the concepts involved in communication
    between LDAP clients and servers. This will give us the foundational knowledge
    for our work with the LDAP utilities and clients.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP from the Server Side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenLDAP includes two daemons: **SLAPD** and **SLURPD**. SLAPD is the main
    server, and we will examine its operation throughout this book. SLURPD is a special-purpose
    daemon used for replicating directories. While it is still in use, it is now deprecated
    in favor of a more robust replication mechanism. We will cover it only briefly
    in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: SLAPD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first, SLAPD, is the stand-alone LDAP daemon. It is the LDAP server. It
    listens for client requests and, when it receives a request, performs the requested
    operation and returns any necessary data. In the most common case a client will
    send a query message to the server. The SLAPD server will then look up the information
    and return the results. Let''s consider an example (in conversational English):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client: Log in as user Bob with the password Password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server: Bob is now logged in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client: Bob wants all of the usernames of users whose email addresses start
    with ''m'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server: There are four users with email addresses that start with ''m''. The
    user IDs are: mattb, markd, melaniek, melindaq'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client: Log Bob off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server: OK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This example is very simplistic (and omits lots of the details of an LDAP transaction),
    but it should give you the main idea of what SLAPD does.
  prefs: []
  type: TYPE_NORMAL
- en: The SLAPD program is called, appropriately enough, `slapd`. It is located at
    `/usr/sbin` (if you compiled from source, it is in `/usr/local/libexec`). In the
    previous chapter we configured SLAPD using the `/etc/ldap/slapd.conf` configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The SLAPD server handles all client interactions, including authentication,
    processing ACLs, performing searches, and handling changes, additions, and deletions
    of the data. It also manages the databases that store LDAP content. All of the
    clients that we look at in this chapter interact directly with SLAPD. The utilities
    provide maintenance services for SLAPD, though they rarely directly interact with
    the SLAPD server (they tend to operate on files that the directory uses).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a slightly more technical look at the simple LDAP exchange that
    we outlined here. We can break the exchange into two major parts: the authentication
    process (called **binding** in LDAP parlance) and the search process.'
  prefs: []
  type: TYPE_NORMAL
- en: The Binding Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing that must happen is the client must authenticate to the server.
    Keep in mind that in order to interact with an LDAP server the client must provide
    two pieces of information: a DN and a password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, there are two different ways by which a client can authenticate
    to a server: through a Simple Bind, and through an SASL Bind. It is possible to
    write custom methods of binding, too, but that''s a significant undertaking. Let''s
    look at the way clients connect to LDAP using the **Simple Bind** method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, to authenticate a user, SLAPD looks up the DN (and the DN''s `userPassword`
    attribute) in the directory and verifies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The supplied DN exists in the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The DN is allowed to connect under the present conditions (such as from the
    originating IP address, or with the currently-implemented security features).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The password supplied matches the value of the DN's `userPassword` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example scenario the user Bob wants to bind to the directory. For Bob
    to bind according to the outlined steps, the client would have to provide Bob's
    full DN, which might be something like `cn=Bob,dc=example,dc=net`. But, not all
    clients know the full DN of the user. Most applications require only a username
    and password, not a full DN. To solve this problem, LDAP servers support the idea
    of the **Anonymous** user.
  prefs: []
  type: TYPE_NORMAL
- en: When the LDAP server receives a bind request with an empty DN and an empty password
    field, the server treats the user as Anonymous. The Anonymous user can be granted
    or denied access to information in the directory based on the ACLs specified for
    SLAPD. Generally, the task of the Anonymous user is to get Bob's DN out of the
    directory and request that Bob be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this happen? The client first connects to the server as Anonymous,
    then searches the directory for Bob''s entry with a filter of something like this:
    *entries* *whose* *CN* *is* *"Bob"* *and* *who* *have* *the* *objectclass* *"organizationalPerson"*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The actual LDAP filter for this request would look like this: `(&(cn=Bob)(objectClass=oraganizationalPerson))`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the filter is specific enough, and the directory actually has
    an entry for Bob, then the server would then send the client one DN: `cn=Bob,dc=example,dc=net`.
    The client would then re-bind, this time as `cn=Bob,dc=example,dc=net` (and with
    Bob''s password), rather than as Anonymous.'
  prefs: []
  type: TYPE_NORMAL
- en: In order for anonymous authentication to work, the ACLs will need to allow the
    Anonymous user to bind and attempt to perform authentication. The ACLs we added
    to `slapd.conf` in the previous chapter allowed the Anonymous user to request
    authentication services with the `userPassword` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use Simple Binding, though we will specify a full DN,
    rather than bind as Anonymous and search, and then rebind. Simple Bind sends the
    password from the client to the server. Without additional security (like SSL
    or TLS encryption), this makes the authentication process vulnerable to attacks.
    **SASL (Simple Authentication and Security Layer) Binding** provides another method
    of authenticating that relies on external security measures for added security.
    In Chapter 4, we will look at the authentication process in more detail, with
    particular emphasis on security.
  prefs: []
  type: TYPE_NORMAL
- en: The Search Operation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our example scenario, after Bob authenticates to the server he searches for
    all the email addresses that begin with the letter *m*. Let's examine that process
    in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to search the directory we need to know the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base DN**: Where in the directory to start from'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: How deep in the tree to look'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: What information we want retrieved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter**: What to look for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at what Bob wants to get out of the directory. Bob wants to get a
    list of all of the people in his organization, Example.Com, who have email addresses
    that begin with the letter *m*. From this information, we can construct a search.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, Bob wants to know about everyone in the Example.Com organization. In
    the directory, this is everything under the Example.Com entry: `dc=example,dc=com`.
    Also, since we know that Bob wants all of the email addresses that begin with
    *m*, not just one layer down; we know that Bob wants to search the entire subtree
    under `dc=example,dc=com`. So we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base DN**: `dc=example,dc=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: Entire subtree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we want to know what attributes Bob wants the server to return. The DN
    will be automatically returned. Other than that, Bob is concerned only with the
    attribute that stores the email address. Email addresses are stored in the `mail`
    attribute. We could also grab any number of attributes, such as the user''s name
    (`cn`) and telephone number (`telephoneNumber`). So we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**: `mail`, `cn`, `telephoneNumber`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Attribute Descriptions**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The attribute referred to by `mail` also has a second name: `rfc822Mailbox`.
    These two names are called **attribute descriptions** because they both describe
    a common attribute. Each attribute has at least one attribute description, but
    it is legal to have multiple descriptions (such as `cn` and `commonName`, or `dc`
    and `domainComponent`). When you have an attribute with more than one description
    it doesn''t matter which description you use. All should return the same results.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we need to create a filter from Bob's criteria. Bob wants all of the
    entries where the email address starts with the letter *m*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the search filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple filter is composed of four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the filter is enclosed in parentheses. Parentheses are used for grouping
    elements within the filter. For any filter, the entire filter should always be
    enclosed in parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, the filter begins with an attribute description: `mail`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third is the matching rule. There are four matching rules: equality (`=`),
    approximate match (`~=`), greater than or equal to (`>=`), and less than or equal
    to (`<=`). How these are used (and whether they can be used) is determined to
    a large degree by the directory schema, which we will discuss at length in Chapter
    6\. In this case the filter performs string matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have the assertion value—the string or pattern that we want results
    to match. In this case it is composed of the character `m` and the wildcard character
    (`*`). This indicates that the string must start with `m`, and can then have zero
    or more characters following it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type of search is called a **substring search**, because the filter provides
    only part of the string, and requests that the server respond with any entries
    that match the substring (according to the pattern supplied).
  prefs: []
  type: TYPE_NORMAL
- en: 'What if Bob also needed all of the users with email addresses that started
    with `n`? We could run two separate searches, or we could create a more elaborate
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter is composed of two subfilters: `(mail=m*)` and `(mail=n*)`. The
    first matches only mail addresses that start with *m*, while the second matches
    only addresses that start with *n*. These two subfilters are disjoined using the
    pipe (`|`) symbol. That means that an OR operation will be performed, and the
    filter will match a record if the record matches either `(mail=m*)` or `(mail=n*)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax may seem a little unusual at first, as the operator (the OR) comes
    before the two filters are listed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three logical operators that can be used in filters: AND (`&`), OR
    (`|`), and NOT (`!`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make things more interesting, let''s say that Bob wants to restrict
    the list to only people whose offices have room numbers of 300 or above. We can
    simply add one more sub-filter to our list, and we will have the results that
    Bob is looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To visualize this a little better let''s add some line breaks and spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now it should be a little easier to see how this filter is interpreted. In the
    innermost level, mail addresses are considered matches if they start with *m*
    OR *n*. Now, these matches are only returned if they also have a room number greater
    than or equal to 300\. They must match either `(mail=m*)` OR `(mail=n*)`, AND,
    in addition, must also have `(roomNumber >= 300)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Bob performs the search, with the base DN, scope, attributes, and filter,
    he will receive a response from the server that will contain a list of records
    that look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The search returns everything in appearing in the subtree below the DN `dc=example,dc=com`
    that matches our filter. The returned records only have the DN and the attributes
    that we specified: `mail`, `cn`, and `telephoneNumber`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our most complex filter, we used the `roomNumber` attribute. Why isn't it
    present in the records above? Even though it was used in the filter the attribute
    value would not be returned in the response unless we requested it.
  prefs: []
  type: TYPE_NORMAL
- en: Before going on, there is one last thing to mention about searching. During
    a search the entire request is checked against the list of access controls.
  prefs: []
  type: TYPE_NORMAL
- en: If an ACL specifies that Bob does not have access to the `telephoneNumber` attribute,
    then the search will return the same DNs but without the `telephoneNumber` attribute.
    Similarly, if an ACL denied Bob access to the records of certain people in the
    directory, then the server would send back the results for only those that Bob
    does have permission to see.
  prefs: []
  type: TYPE_NORMAL
- en: The server will not give Bob any indication that some information has been withheld
    because of an ACL.
  prefs: []
  type: TYPE_NORMAL
- en: 'More Operations: Additions, Modifications, and Deletions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our illustration of Bob's search for email addresses we covered only binding
    and searching. Of course, LDAP supports adding, modifying, and deleting, as well.
    All three of these also require that the user first bind. And all three of these
    are also subject to ACL restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: The Addition Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In an addition operation a new record is added to the server. In this case the
    client will have to provide a new (and unique) DN, and set of attribute/value
    pairs. The attribute/value pairs must include a list of object classes to which
    the entry belongs. For example, if the entry is going to be a new user with a
    user ID and an email account, then the modification would have to include at least
    three object class attribute/value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'An entire record for a user to be added might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Modification Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modification acts on a particular record, specified by DN. Any number of changes
    can be done on a single record in one modification request.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a particular record, a modification operation can add, replace, or remove
    attributes. And it can combine operations in the same request. That is, it can
    remove one attribute and replace another attribute in one request. Let''s see
    these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An **add** request takes an attribute name and one or more values. It will
    add those values to the existing set of values for that attribute. For example,
    consider a record like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we want to modify this record by adding `cn: Matthew`, the result will look
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Modification operations are processed in an "all or nothing" fashion. When multiple
    modifications are sent in one request, either they all succeed, or they all fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A **replace** request also takes an attribute and one or more values. But the
    list of values replaces the existing values. For example, if Matt relocated and
    his telephone number changed, then replacing with the new attribute `telephoneNumber`:
    `1 555 555 6543` would result in a record that looked like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new number is added and the old numbers are removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A **delete** request also takes an attribute and a list of values. It deletes
    only the values for an attribute that are specified in the list of values. For
    example, deletion of `cn: Matthew` would give us the following record:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Only the matching CN was removed. If, however, a delete request only specifies
    the attribute (with no values), then all instances of that attribute will be removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Delete Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, an entire LDAP record can be deleted. Like modifications, deletion
    operates on a particular record, the record's DN. During a delete operation, the
    entire record is removed from the directory—the DN and all attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Only records that do not have children can be deleted from the directory. If
    an entry has children, the children must be removed from the directory (or relocated
    to another part of the tree) before the parent entry can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Infrequent Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few operations that clients can call, but that tend to be used less
    than binding, searching, adding, modifying, and deleting. Three that we will look
    at just briefly are **ModifyDN**, **Compare**, and **Extended Operation**.
  prefs: []
  type: TYPE_NORMAL
- en: The ModifyDN Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'ModifyDN is used in cases where the DN for a record must be changed. Generally,
    DNs should not be changed frequently as they are intended to be used as unique
    and stable locators within a directory tree. However, it is not difficult to envision
    cases where a DN needs to be changed. The following figure displays a (full) DN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ModifyDN Operation](img/1021_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A (full) DN is composed of two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the part specific to the immediate record, called the **Relative
    DN** or the **RDN**. For example, in the DN `cn=Matt,dc=example,dc=com`, the RDN
    is the `cn=Matt` part.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, there is the part that refers to the parent record of the DN. It is
    specific to this record. The `dc=example,dc=com` part in the same example points
    to the parent of this record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the DN, we know how far down the directory tree this record is. It is
    one layer below the root of the tree—the base DN (`dc=example,dc=com`).
  prefs: []
  type: TYPE_NORMAL
- en: The ModifyDN operation provides a way to change just the RDN or the entire DN.
    Changing the latter equates to moving the record to another part of the directory
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: The Compare Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Compare operation takes a DN and an attribute value assertion (attribute =
    value), and checks to see if that attribute assertion is true or false. For example,
    if the client supplies the DN `cn=Matt,dc=example,dc=com` and the attribute value
    assertion `cn=Matthew`, then the server will return *true* if the record has an
    attribute `cn` with the value `Matthew`, or *false* otherwise. This operation
    can be faster (and also more secure) than fetching a record and doing the comparison
    on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In OpenLDAP ACLs, the `auth` permission setting (as well as the `=x` permission
    setting that we will look at in the next chapter) allows the Compare operation
    to be used, but does not allow the attribute value to be returned in a search.
    The `read` permission (`=xw`) allows both the Compare operation and the return
    of the attribute value in search results.
  prefs: []
  type: TYPE_NORMAL
- en: The Extended Operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, OpenLDAP implements the LDAP v.3 Extended Operation, which makes it
    possible for a server to implement custom operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact syntax of an Extended Operation will depend on the implementation
    of the extension. The supported Extended Operations are listed in the root DSE
    under the `supportedExtension` attribute. Take a look at the root DSE at the end
    of Chapter 2\. In that record there are two extended operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '1.3.6.1.4.1.4203.1.11.1: This **Modify Password extension** is defined in RFC
    3062 ([http://www.rfc-editor.org/rfc/rfc3062.txt](http://www.rfc-editor.org/rfc/rfc3062.txt)).
    This extension provides an operation for updating a password in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1.3.6.1.4.1.4203.1.11.3: This **Who Am I? extension** is defined in RFC 4532
    ([http://www.rfc-editor.org/rfc/rfc4532.txt](http://www.rfc-editor.org/rfc/rfc4532.txt)).
    This extension makes it possible for the currently active DN to find out about
    itself from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter we will look at tools that use the Modify Password and
    the Who Am I? extensions.
  prefs: []
  type: TYPE_NORMAL
- en: SLAPD Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section we have looked at some of the operations that the SLAPD server
    makes available to the clients. We've looked at the most common operations (binding,
    searching, modifying, adding, and deleting). We've also looked at a few of the
    less-known operations like modifyDN, Compare, and Extended Operations as well.
  prefs: []
  type: TYPE_NORMAL
- en: By now you should have a good idea of what services the SLAPD server provides
    to clients. Clients can bind (or authenticate) to a SLAPD server and perform powerful
    searches of the directory. And through SLAPD the information in the directory
    tree can be maintained.
  prefs: []
  type: TYPE_NORMAL
- en: These concepts will be central to the rest of this chapter, and the rest of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at the SLURPD daemon, though we will not go into much detail.
  prefs: []
  type: TYPE_NORMAL
- en: SLURPD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SLAPD and SLURPD are the two daemons included in the OpenLDAP suite. Above,
    we looked at the SLAPD server. Now we will turn to the second daemon.
  prefs: []
  type: TYPE_NORMAL
- en: SLURPD, the Stand-alone LDAP Update Replication Daemon, is used less frequently
    than SLAPD, and is on its way to obsolescence. SLURPD provides one way of keeping
    multiple copies of an LDAP directory synchronized (see the discussion in Chapter
    1). Basically it works by tracking the changes (additions, deletions, modifications)
    to a *master* SLAPD directory server. When a change is made to the master directory,
    SLURPD sends updates to all of the subordinate *slave* servers.
  prefs: []
  type: TYPE_NORMAL
- en: The SLURPD program, `slurpd`, is located at `/usr/sbin` (or `/usr/local/libexec`,
    if you compiled from source). In configurations where SLURPD is used, `slurpd`
    is typically started immediately after `slapd`. SLURPD does not have its own configuration
    file. It searches the `slapd.conf` file for configuration information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 7 we will look at the technology that will likely replace SLURPD:
    the LDAP Sync Replication capability that is built into recent (OpenLDAP 2.2 and
    later) versions of SLAPD.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Directory Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we looked at the two LDAP daemons, SLAPD and SLURPD.
    But though we have a directory running already, we do not have any entries in
    our directory (other than the ones that are created by SLAPD, such as schema records
    and the root DSE).
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will create a file for holding our LDAP data, and we will
    devise some directory entries to go in this file. In the next section we will
    load the data into the directory.
  prefs: []
  type: TYPE_NORMAL
- en: The LDIF File Format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book we look at examples of LDAP records presented in plain
    text, with each line having an attribute description, followed by a colon and
    a value. The first line of the record is the DN, and usually the last lines of
    the record are the object class attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This format is the standard way of representing LDAP directory entries in a
    text file. It is an example of a record written in the **LDAP Data Interchange
    Format (LDIF)**, version 1.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LDIF file format was developed as part of the University of Michigan LDAP
    server project. In 2000, LDIF version 1 was standardized in RFC 2849\. The standard
    is available online at [http://www.rfc-editor.org/rfc/rfc2849.txt](http://www.rfc-editor.org/rfc/rfc2849.txt).
  prefs: []
  type: TYPE_NORMAL
- en: The LDIF standard defines a file format not only for representing the contents
    of a directory, but for representing certain LDAP operations, such as additions,
    changes, and deletions. In the section on the `ldapmodify` client, we will use
    LDIF to specify changes to records in the directory server, but right now we are
    interested in creating a file that represents the contents of our directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LDIF is not the only directory file format. There is an XML-based directory
    markup language called **DSML** (**Directory Services Markup Language**). While
    there is a standardized DSML version 1, the project seems to have lost momentum
    to the extent that the official website, [dsml.org](http://dsml.org), is now gone.
    However, one Open Source DSML tools website hosts a mirror of the old [dsml.org](http://dsml.org)
    site: [http://www.dsmltools.org/dsml.org/](http://www.dsmltools.org/dsml.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: The OpenLDAP suite does not directly support DSML.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an LDIF File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An LDIF file consists of a list of records, each of which represents an entry
    in the directory. Each entry must have a DN (since any LDAP entry requires a DN),
    and then one or more attributes or change records (`add`, `modify`, `delete`,
    `modrdn`, `moddn`). For now we will confine ourselves to attributes, and put off
    discussion of change records until we discuss `ldapmodify`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Records are separated by empty lines, and each record must begin with a DN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Lines that begin with a pound or number sign (`#`) are treated as comments,
    and ignored. Note that the pound sign must be the first character on the line,
    not preceded by any whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: While it is customary for records to end with the `objectClass` attributes,
    this is done because it is considered easier to read. There is no requirement
    to do so. The order of attributes in an LDIF record is inconsequential.
  prefs: []
  type: TYPE_NORMAL
- en: An object class (which is defined in a schema definition) indicates what type
    or types of object the record represents. In the precvious example, the two records
    are both `documents`. The object class definition determines which attributes
    are required, and which are merely allowed. When authoring an LDIF file you will
    need to know which fields are required. The DN of any entry is, of course, required,
    as is the `objectclass` attribute. In the `top` object class, which represents
    the root of the schema hierarchy, there are no required fields other than `objectclass`.
    The `document` object class definition requires `documentIdentifier`, and allows
    eleven additional fields, including `documentTitle` (which takes a string value)
    and `documentAuthor` (which takes a DN value, pointing to another record in the
    directory).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Document Object Class**'
  prefs: []
  type: TYPE_NORMAL
- en: LDAP directories can model a variety of different types of objects. The `document`
    object class, used in the previous example, represents documents (such as books,
    papers, and manuals) in the directory. The schema for the `document` object class
    and the related `documentSeries` object class is contained in `cosine.schema`
    and defined in section 3.2 of RFC 4524 ([ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt](ftp://ftp.rfc-editor.org/in-notes/rfc4524.txt)).
    Schemas will be discussed at length in Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the list of attributes for the document and documentSeries object
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Anatomy of an LDIF File](img/1021_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Any attributes that are used in the DN but are not part of the directory's base
    DN must be present in the record. For example, consider the case where the base
    DN is `dc=example,dc=com`. An entry with the DN `cn=Matt,dc=example,dc=com` would
    have to have a `cn` attribute with the value `Matt`. In the previous examples,
    since `documentIdentifier` is used in the DN, there must be a matching `documentIdentifier`
    attribute in the record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, the `document` object class requires the `documentIdentifier` attribute
    so, in this case, even if the attribute was not used in the DN, any document record
    would still need a `documentIdentifier`.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, an entry with the DN `cn=Matt,ou=Users,dc=example,dc=com` would have
    to have the attributes `cn:Matt` and `ou:Users`.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Attribute Values in LDIF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all attribute values are simple and short ASCII strings. LDIF provides facilities
    for encoding more complex types of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes attribute values won''t fit on one line. If an attribute value is
    too long to fit on one line it can be continued on the next line, provided that
    the first character on the continued line is a whitespace character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'According to the RFC, an LDIF file can only contain characters in the ASCII
    character set. However, characters that are not in ASCII can be represented in
    LDIF using a base-64 encoded value. Entries whose value is base-64 encoded differ
    slightly. The attribute description is followed by two colons, instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should consider base-64 encoding under the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When the attribute value contains binary data (such as a JPEG photo).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the character set is not ASCII. Generally, the directory data should be
    stored in UTF-8, but that means that in order to remain compliant to the LDIF
    standard, values should be base-64 encoded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are line breaks or other non-printing characters within the value.
    (Note that for such values to be accepted the schema must allow these characters
    or the directory server will not allow them to be uploaded even if they are encoded.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the value begins with or ends with whitespace characters (that you want
    preserved), or begins with a colon (`:`) or a less-than sign (`<`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even DNs can be base-64 encoded, and you can use UTF-8 characters in a DN as
    long as the DN is base-64 encoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several UNIX/Linux utilities which can be used to base-64 encoded
    values. The most popular is the `uuencode` program that comes in the `sharutils`
    package. However, this program is not installed by default in Ubuntu. You can
    install it quickly from the command line with `apt-get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `sharutils` is installed you can encode a value with `uuencode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example we are converting the string `" test"` (note the leading white
    space) into a base-64 encoded string. This is done with a couple of commands on
    the command line (using the Bash shell in this example).
  prefs: []
  type: TYPE_NORMAL
- en: The `uuencode` command is typically used to encode files for attachment to an
    email message, so we have to do a little work to get it to operate the way we
    want. First, we `echo` the string that we want to encode. The `echo` program,
    by default, adds a newline character onto the end of the string that it echoes.
    We use the `-n` flag to prevent it from adding the newline character.
  prefs: []
  type: TYPE_NORMAL
- en: The string `" test"` is echoed to the standard output (`/dev/stdout`), and then
    piped (`|`) into the `uuencode` command. The `-m` flag instructs `uuencode` to
    use base-64 encoding, and the `name` string is used by `uuencode` to generate
    a name for the attachment. While this is useful when using `uuencode` to generate
    email attachements, it serves no purpose for us. Since we are not attaching this
    file to anything it doesn't really matter what you put there; `foo` would work
    equally as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `uuencode` program then prints three lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Only the second line of the code (highlighted one), the actual base-64 encoded
    value, matters to us. We can copy `IHRlc3Q=` and paste it into our LDIF file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another popular tool for base-64 encoding is `mimencode`, provided by the `metamail`
    package. Both the Perl and Python scripting languages have base-64 encoding tools
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, inserting a lengthy attribute value (such as the entire base-64
    encoded image file, or even a lengthy bit of text) into the LDIF file would make
    the file too large to efficiently edit with a text editor. Even a small image
    file would be hundreds of characters long when base-64 encoded. Instead of inserting
    the base-64 encoded string directly into the file you can use a special file reference,
    and the contents of the file will be retrieved and loaded into the directory when
    the LDIF file is imported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line of code shows an example of inserting a reference to an
    external file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two important features to note in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The left angle bracket (`<`) character is used to indicate that the file should
    be imported. This character evokes the UNIX/Linux shell, which uses the left angle
    bracket for the same purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The path to the file follows the standard `file://` URL scheme to represent
    the file path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in the file scheme, you will usually need three slashes at the beginning
    (`file:///path/to/file`) to indicate that there is no host field. RFC 3986 ([ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt](ftp://ftp.rfc-editor.org/in-notes/rfc3986.txt))
    defines the general structures of URIs and URLs. `file://` is one particular URL
    scheme, and is roughly defined in section 3.1 of RFC 1738 ([ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt](ftp://ftp.rfc-editor.org/in-notes/rfc1738.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where you have attribute values in multiple languages you can store
    language information along with the attribute description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The language information is stored in the directory, and clients will be able
    to use it to display the language appropriate to the locale.
  prefs: []
  type: TYPE_NORMAL
- en: This covers the basics of the LDIF file format, now we will move on and create
    an LDIF file to load into the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Example.Com in LDIF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are ready to model our directory tree in an LDIF file. The first thing
    to do is to decide on a directory structure. We are going to represent an organization
    in our directory tree. Of course the possibilities for the types of trees you
    can model are boundless, but we will stick to those most commonly used for LDAP
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two popular ways of defining the roots of an organizational directory
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is to create a root entry that indicates the official name of the
    organization and the geographic location (usually just the country) of the organization.
    Here are a few examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In each of these three examples, `o` represents the organization name, and `c`
    is the two-character country code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second popular model is to use the organization''s domain name. For example,
    if the company Airius has registered the `airus.co.uk` domain name, then the root
    DN would be composed of three **domain component** (`dc`) attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Likewise, the other two records could be re-written using their respective
    domain components:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the organization/country configuration has its advantages. Corporations
    with multiple domains may find this form more appealing. But the second form,
    relying upon domain components instead, has become much more prevalent. In most
    circumstances, I prefer the domain component form because it is more closely related
    to the way much information is referenced on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is no hard and fast rule about how exactly the DN must be structured,
    and you may find other base DN structures more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Base DN Record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have chosen a base DN style, let's begin building a directory for
    Example.Com. LDIF files are read sequentially, record by record. So, the base
    DN must come first, since all other records will refer to it in their DNs. Likewise,
    as we build the directory information tree, we will need to make sure that the
    parent entries always appear in the file before their children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our base DN looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start from the bottom and work backwards through the example. The record
    has three object classes: `top`, `dcObject`, and `organization`. As we have seen
    already, the `top` object class is the root of the hierarchy of object classes,
    and all records within the directory are in the `top` object class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the figure displaying the object classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the Base DN Record](img/1021_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `dcObject` object class simply describes domain components—pieces of a
    domain name. The domain [www.packtpub.com](http://www.packtpub.com), for example,
    has three domain components: `www`, `packtpub`, and `com`. Since we are using
    domain components in the DN, we need the `dcObject` class, which requires one
    attribute: `dc`.'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that while in the DN there are two `dc` attributes (`dc=example`
    and `dc=com`), there is only one (`dc:example`) listed in the record. While it
    seems counter-intuitive at first glance, the reason is actually straightforward.
    The record is not describing the entire domain—just a single domain component
    (`example`). Like a DNS record, the parent component (`com`) refers to another
    entity somewhere else in a great big hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: So, each record that uses the `dcObject` object class can describe only one
    domain component, and hence have only one `dc` attribute in the record (though
    the DN may have multiple `dc` attributes, specifying in which part of the domain
    hierarchy this record resides).
  prefs: []
  type: TYPE_NORMAL
- en: But is the `dc=com` record supposed to be in our directory? Since the root of
    this directory (as specified in the `slapd.conf` file) is `dc=example,dc=com`,
    we would not expect to find the `dc=com` record within the database, as it is
    not under the `dc=example,dc=com` part of the tree (rather, `dc=com` is above,
    or superior to, this part of the tree).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Handling Requests for Records Outside the Directory Tree**'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if a search request comes into our `Example.Com` directory for `dc=com`?
    Or what if we get a request for `dc=otherExample,dc=com`? These are records not
    expected to be in our directory. Using the referral directive in the `slapd.conf`
    file, you can direct requests of this sort to another server that might prove
    more authoritative on the matter. The syntax for the directive is `referral <ldap
    URL>`, for example: `referral ldap://root.openldap.org`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have specified what domain component our record describes. But we still
    need a little more. We can't just have a record with `top` and `dcObject` object
    classes for two reasons—one practical and the other technical.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, the record would not be particularly useful with just
    this sparse information, as it wouldn't really tell us about the base of the directory
    tree (other than that, it has a domain name).
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, neither of the two object classes, `top` and `dcObject`,
    are sufficient for a complete record. The reason for this is that neither of these
    object classes are **structural object classes**, (`top` is abstract, and `dcObject`
    is auxiliary) and every record in the directory must have one object class that
    is considered the structural object class for that record. For a detailed explanation,
    as well as some useful information about structuring records, see Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: What would make our base record more useful (and fulfill the record's requirement
    to have a structural object class)? The `organization` object class describes
    an organization, as the name suggests. It requires one field, `o` (or its synonym,
    `organizationName`), which is used to specify the (legal) name of the organization.
    Additionally the organization object class allows twenty-one optional fields that
    provide more detailed information about the organization, such as `postalAddress`,
    `telephoneNumber`, and `location`. In the previous example we used the `description`
    field, which is also among the twenty-one attributes allowed by the `organization`
    object class.
  prefs: []
  type: TYPE_NORMAL
- en: That is our base entry for our directory. It describes the record at the root
    of our directory information tree. Next we want to add some structure to our directory.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Directory with Organizational Units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the strengths of LDAP's directory server model is its ability to represent
    data organized into hierarchies. In this section, we will use **Organizational
    Units (OUs)** to create a several subtrees beneath our `dc=example,dc=com` root.
  prefs: []
  type: TYPE_NORMAL
- en: Our Example.Com directory is intended primarily for holding user and account
    information. For that reason, we will want to use Organizational Units to create
    subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we were, for example, creating a directory of `document` records (as we did
    in the section entitled *The* *LDIF* *File* *Format*), instead of using OUs, we
    might instead use `documentSeries` records.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLDAP does not provide a default OU subtree structure, so you will need to
    create your own. This can be done in many ways, but here we will see the two prominent
    theories of how OUs should be structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Theory 1: Directory as Organizational Chart'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first theory is that the directory should be structured to represent the
    organizational chart of the organization you are modeling. For example, if the
    organization has three main units—Accounting, Human Resources (HR), and Information
    Technology (IT)—then you should have three OUs. Here is a figure for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theory 1: Directory as Organizational Chart](img/1021_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the given screenshot, each OU represents a unit in the organizational chart.
    Employees who work in Accounting will have their user accounts in the directory
    subtree `ou=Accounting,dc=example,dc=com`, while employees in IT will have accounts
    in `ou=IT,dc=example,dc=com`.
  prefs: []
  type: TYPE_NORMAL
- en: This method has some obvious advantages. Knowledge of how the organization works
    will help you locate information in the directory. Conversely, the directory will
    serve as a tool for understanding how the organization is structured. Organizational
    relationships between people or records in the directory will be more easily ascertained.
    For example, a glance at the record (or just the DN) of `uid=Marvin,ou=Accounting,dc=example,dc=com`,
    and you will know that Marvin works in the same department as Barbara.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to consider before structuring your directory this way
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: First, while organizational structures change—sometimes too frequently—relocating
    DNs within the directory is not an easy task (and in some cases requires deleting
    a record from one part of the tree and creating a similar version in another part
    of the tree).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Barbara, the manager of Accounting, is transferred to Human Resources, her
    DN must change (to reflect the new OU). Some (older) backends do not allow DN
    changes, and so Barbara's Accounting record would need to be deleted, and then
    a new one created for her in the HR OU. Also, applications that stored the DN
    of the user would have to be reconfigured. Similarly, some employees may split
    their time between two departments. How would this case be handled?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A second consideration, and one that is not at all obvious, has to do with the
    technical use of the LDAP directory. If user records are spread throughout the
    directory tree, then applications will need to be smart enough to search all over
    the tree for user records.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This problem is usually solved by pre-authentication search techniques, such
    as binding as Anonymous or as a special authentication user, searching the directory
    for the account that will be used for authentication, and then binding as the
    correct account (if found). But not all clients (and not all directories, for
    that matter) allow pre-authentication searching. And pre-authentication searching
    can impose a bigger load on the server, whereas other techniques may be easier
    on the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A third consideration has to do with what other sorts of information you want
    to store in your directory. If you are using the directory primarily as a tool
    for modeling the organizational chart, then this particular method of structuring
    the directory will be ideal for you. You can track employees, assets (fleet vehicles,
    computers, and so on), and other resources within the directory, and locate their
    position in the organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But if the main purpose of the directory is to create a directory of users of
    IT services, then this structure will be less than ideal, requiring applications
    to do much more work to locate users (and in some cases, requiring users to know
    more about their LDAP accounts).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Theory 2: Directory as IT Service'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second theory is that the directory should be structured to represent the
    way your system (networks, servers, user applications) will need to access the
    records. In this case the structure of the LDAP directory should be optimized
    for use by such IT services. While the organizational chart technique groups records
    by their relation to the organization, this method groups records into functional
    units, where a position in the directory is determined primarily by the tasks
    that applications and services will require the directory to perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common way to structure the directory is to split it into a unit for users,
    a unit for groups, and a unit for system-level records that applications need,
    but users will not require access to. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Theory 2: Directory as IT Service](img/1021_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, all of the user accounts are under a particular subtree of the
    directory: `ou=Users,dc=example,dc=com`. Applications need only search in one
    part of the directory to find user accounts, and when the organization changes,
    the structure of the directory need not also change.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is nothing magical about using organizational units (OUs) for partitioning
    the directory information tree. You can use other record types, and other attributes
    (such as `cn`—common name) to divide a directory into multiple branches. Using
    OUs is traditional, though perhaps not the most appropriate in cases where the
    directory information tree does not model the organizational chart.
  prefs: []
  type: TYPE_NORMAL
- en: This method, Also has some drawbacks. First, the directory structure does not,
    by design, provide any overt clues to the structure of the organization. Of course
    organizational information, such as department IDs, can be stored in individual
    records, and so can be retrieved that way.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly though, if the directory supports a large number of users,
    the `ou=Users` branch is going to have a lot of records. This is not necessarily
    a performance problem, but it can make browsing the directory (as opposed to searching
    the directory) a tedious process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, this problem is mitigated by adding additional subtrees under
    the user''s branch. Sometimes this is done by creating a hybrid configuration
    where `ou=User` has subtrees that represent departments in the organization, such
    as `ou=Accounting,ou=Users,dc=example,dc=com`. Sometimes other classification
    systems, such as alphabetical schemes, are used to handle this situation: `uid=matt,ou=m-p,ou=Users,dc=example,dc=com`.'
  prefs: []
  type: TYPE_NORMAL
- en: But for small and medium-sized ones, a user's branch typically does not have
    any additional subtrees, which eases the process of integrating with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP also has object classes designed to describe groups of records in the directory.
    Usually, it does not make sense to store these in with the user accounts, so they
    can be moved to a separate branch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the System branch is used to store records for things like system accounts,
    mail servers, web servers, and other miscellaneous applications often need (or
    perform best with) their own LDAP accounts. But if it can be helped, they shouldn't
    be grouped in with user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: I've outlined two different ways of structuring the directory information tree—one
    mirroring the organization, and the other facilitating IT services. But these
    are only two ways of structuring the directory. You may find that other structures
    meet your needs better. However, for our purposes, we will use the IT services
    structure as we continue to build our LDIF file.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing the OUs in LDIF
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we are ready to write out our chosen OUs in LDIF. We will create three
    OUs—Users, Groups, and System—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The three OUs have the same structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each OU must have the `organizationalUnit` object class. This object class
    has one required attribute: `ou`. Here is a figure displaying the **organizationalUnit**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressingdirectory treedirectory, structuring the OUs in LDIF](img/1021_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the `objectClass: top` has been omitted from these records, as well
    as all of the following records in this chapter. All records are automatically
    assumed to be instances of the `top` object class, so it is not necessary to explicitly
    include the `objectClass: top` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The `description` attribute is optional and there are more than twenty additional
    (optional) attributes that can be added—most of which provide contact information
    of the organization unit, such as `telephoneNumber`, `postOfficeBox`, and `postalAddress`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our OUs in place we are ready to add a third tier to our directory tree.
    Before we start creating individual records let''s get an overview of what this
    next tier will look like. Here is the directory tree structure with a group, a
    system account, and a pair of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expressingdirectory treedirectory, structuring the OUs in LDIF](img/1021_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the directory information tree that we will create in the remainder
    of this section. Next, we will continue building an LDIF file first by adding
    the users, followed by a system record, and then a group.
  prefs: []
  type: TYPE_NORMAL
- en: Adding User Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will reserve the `Users` OU for records that describe people in the organization.
    In these accounts we want to store information about the user—things like first
    and last name, title, and department. Since the directory will also be a central
    resource for application information, we also want to store user ID, email address,
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic user record looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The user record for Barbara belongs to three object classes: `person`, `organizationalPerson`,
    and `inetOrgPerson`. All three of these are structural object classes, where `inetOrgPerson`
    is a child of the `organizationalPerson` class, which, in turn, is a child of
    the `person` object class. The attributes in Barbara''s record are a mixture of
    the required and allowed attributes from the three object classes. The following
    figure displays the attributes in Barbara''s record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Addingdirectory treedirectory, structuring User Records](img/1021_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since `inetOrgPerson` inherits from `organizationalPerson`, a record that has
    the `inetOrgPerson` object class also must have the `organizationalPerson` object
    class. And `organizationalPerson` inherits from the `person` object class, so
    `person`, is also required.
  prefs: []
  type: TYPE_NORMAL
- en: This means that all of the `inetOrgPerson` records will require `cn` (the user's
    full name) and `sn` (the user's surname) attributes, as all `inetOrgPerson` records
    are also person records. It also means that the record can have any combination
    of the forty-nine optional attributes defined between the three object classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `uid` and `ou` attributes were used in the DN, they are effectively required
    attributes as well. Furthermore, OpenLDAP will require that the record have a
    `uid` attribute and an `ou` attribute that have values that match the values in
    the DN—in other words, since the `ou` in the DN is `Users`, the `ou` attribute
    in the record must have the value `Users`. This behavior is dictated by the LDAP
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Different object classes, different schemas**'
  prefs: []
  type: TYPE_NORMAL
- en: 'While `person` and `organizationalPerson` are defined in the core schema (`core.schema`),
    `inetOrgPerson` is defined in its own schema (`inetOrgPerson.schema`), and is
    standardized on its own in RFC 2798 ([http://rfc-editor.org/rfc/rfc2798.txt](http://rfc-editor.org/rfc/rfc2798.txt)).
    The reason for this is largely historical: `person` and `organizationalPerson`
    were defined well before `inetOrgPerson` (and by different parties).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `inetOrgPerson` record that utilizes more of the available attributes might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we are still using the same three object classes, but have
    selected many more of the optional attributes. One thing that may stand out in
    both Barbara''s and Matt''s records, is that there are an awful lot of attributes
    used simply for specifying the name of the person; `cn`, `sn`, `givenName`, and
    `displayName` are all fields related to the person''s name. What''s the point
    in having so many? There are two benefits achieved by providing diverse name fields:'
  prefs: []
  type: TYPE_NORMAL
- en: This reduces the amount of guess work that an application has to do when parsing
    names. Names can be ambiguous—for instance, John Stuart Mill's surname is Mill,
    while Mary Stuart Masterson's surname is Stuart Masterson. Explicitly specifying
    such things can reduce ambiguity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different attributes allow additional information to be specified. Multiple
    `cn` and `givenName` values can specify different forms of a person's name, while
    `displayName` (which can only have one value, and cannot be used multiple times
    in the same record) ensures that the applications will consistently display the
    same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Common Names**'
  prefs: []
  type: TYPE_NORMAL
- en: The `cn` field is used by many different object classes in the directory, many
    of which do not describe persons. For this reason, a `cn` does not always contain
    the full name of a person. Groups, devices, and documents are amongst the things
    that may use the `cn` (or `commonName`) attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples the `userPassword` field, which contains the person's
    password, is in plain text. When this file is loaded into the directory, the value
    will be base-64 encoded, but it will not be *encrypted*. It is not at all secure
    to store clear-text passwords in the directory (and base-64 encoding does not
    improve the security of the password). Later in this section we will look at the
    `ldappasswd` tool, which encrypts passwords before storing them in the directory.
    Production directories should always store the `userPassword` value in encrypted
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may notice that in the `homePostalAddress` field, dollar signs (`$`) are
    used where one would normally expect to see line breaks. OpenLDAP does not automatically
    convert these to line breaks. But use of the dollar sign is an older way of representing
    line breaks without using base-64 encoding. Typically, it is only used in postal
    address related fields—and it is up to implementing applications to correctly
    interpret the dollar signs.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these examples use the `inetOrgPerson` object class as their primary
    structural object class. This is because these records describe a person and use
    the `uid` attribute (and use it as part of the DN). Additionally, `inetOrgPerson`
    provides a number of attributes that are useful for modern information infrastructures;
    `jpegPhoto`, `preferredLanguage`, and `displayName` (amongst others) are all intended
    to be used primarily by modern computer agents rather than humans. As it is standardized
    and widely deployed (LDAP servers from Sun to Microsoft use it), it is the preferred
    object class for describing people within an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far we have created a base DN entry, some organizational units, and a few
    users. Now we will add a record describing a system account.
  prefs: []
  type: TYPE_NORMAL
- en: Adding System Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the entries in our tree—entries that we will need—do not describe users,
    and so do not belong in the Users organizational unit (OU). Instead, we will put
    such special records in the `System` OU. Likewise, the entities we are describing
    are not people, and so using the `person`, `organizationalPerson`, and `inetOrgPerson`
    object classes is not appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we will create a new record for an account that will assist
    users in logging in. The function of the account will be described in detail in
    Chapter 4, but this account will need to be able to authenticate to the directory
    server and perform operations. But, again, this account is not for a specific
    person, and so it will not have personal data (like a surname or a given name).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our new system account, called `authenticate`, looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This record has two object classes: `account` and `simpleSecurityObject`. The
    first one, `account`, is the structural object class. An `account` object, which
    is defined in the Cosine schema (`cosine.schema`), describes an account used to
    access computers or networks. Let''s have a look at the two object classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding System Records](img/1021_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our account, whose DN is `uid=authenticate,ou=System,dc=example,dc=com`, uses
    the `uid` attribute required by the `account` object class, as well as the `ou`
    and `description` fields from account. But the account object class does not have
    a field for storing a password. For that reason we need to add to the record the
    auxiliary object class `simpleSecurityObject`, which has one attribute: the required
    attribute `userPassword`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Auxiliary object classes can be combined with any other structural or auxiliary
    object classes. While using multiple structural object classes in one record requires
    that the object classes be related (for example as `organizationalPerson` is a
    child of `person`), auxiliary object classes do not need to be related to the
    object classes with which they are used. In this case `simpleSecurityObject` has
    no direct relation to `account`. See Chapter 6 for a more detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding the `simpleSecurityObject` auxiliary object class, we have now made
    it possible for our `account` record to have a password. Again, in our example,
    we have specified the password (`userPassword: secret`) in clear text. It is not
    safe to store unencrypted passwords in the directory. For information on encrypting
    LDAP passwords, see the section on `ldappasswd` later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have created some records under two of our three organizational units:
    Users and System. Next, we will add a group under the Groups OU.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Group Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last record we will add to our LDIF file is a record that describes a group
    of DNs. Groups provide a flexible method for collecting similar DNs by whatever
    criterion is needed. The DNs in a group do not have to be structurally similar—they
    can have completely different attributes and object classes, and can describe
    completely different things (such as a document and a person). Thus, it is up
    to the directory administrators and directory applications as to what sorts of
    DNs will be grouped into any particular group.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to create a group to represent our directory administrators,
    and all of the DNs that belong to this group are DNs for users (in the `Users`
    OU, and with the `inetOrgPerson` structural object class).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our group has the DN `cn=LDAP Admins,ou=Groups,dc=example,dc=com`. Note that
    we use the `cn` attribute, rather than `uid`, to identify the group. That is because
    the `groupOfUniqueNames` object class does not allow a `uid` attribute (and `cn`
    is required).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, you should use the `groupOfNames` object class rather than `groupOfUniqueNames`,
    because `groupOfNames` is the default grouping object class in OpenLDAP. We use
    a `groupOfUniqueNames` here to exhibit some of the features of LDAP group management
    in thelater chapters.
  prefs: []
  type: TYPE_NORMAL
- en: A `groupOfUniqueNames` class is one of three grouping object classes defined
    in the core LDAP version 3 schema (`core.schema`). The other two are `groupOfNames`
    and `organizationalRole`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These have been diplayed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Group Records](img/1021_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All three of these object classes are designed for collecting DNs. Each has
    an attribute that specifies the DN of a member of the group. In `groupOfNames`,
    the attribute is called, simply enough, `member`. The `groupOfUniqueNames` class,
    which does not differ in function from `groupOfNames`, uses `uniqueMember` as
    its membership attribute. The `organizationalRole` grouping class, which is intended
    to represent the group responsible for performing a particular role in the context
    of the organization, uses the `roleOccupant` attribute for membership.
  prefs: []
  type: TYPE_NORMAL
- en: In all three grouping object classes, the membership attribute (`member`, `uniqueMember`,
    or `roleOccupant`) can be specified multiple times, as we saw in the LDIF snippet
    for the `LDAP Admins` group.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What Kind of Group Should I Use?**'
  prefs: []
  type: TYPE_NORMAL
- en: How do you decide whether to use a `groupOfNames`, `groupOfUniqueNames`, or
    `organizationalRole`? By default, it is best to use `groupOfNames`, as it is treated
    as the default grouping object class by OpenLDAP. The `organizationalRole` object
    class is intended to be used as a way of defining what a person does within an
    organization. The `groupOfUniqueNames` object class was intended for a different
    use from `groupOfNames`, but implementation-wise, they function identically on
    OpenLDAP.
  prefs: []
  type: TYPE_NORMAL
- en: The `groupOfUniqueNames` and `groupOfNames` object classes both allow the `owner`
    attribute, which can also be used more than once (to, for example, model cases
    where a group has two owners). An `owner` attribute holds the DN of the record
    that is considered the owner of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a fourth (but experimental) general purpose method for grouping in
    OpenLDAP, called **dynlist**/**dyngroup**. This uses a specific object class,
    the dynamic **groupOfURLs** grouping class, in conjunction with a special directory
    overlay. This method of grouping is expected to reach maturity in OpenLDAP 2.4.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example group, which is `groupOfUniqueNames`, we specified two `uniqueMember`
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Both of these DNs are members of the group. Note that SLAPD does not actively
    check to make sure that these DNs exist, nor does it automatically remove a DN
    from groups when the DN is removed from the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Integrity Checking**'
  prefs: []
  type: TYPE_NORMAL
- en: SLAPD can be configured to do integrity checking on records using the RefInt
    (Referential Integrity) overlay discussed in Chapter 5\. This overlay can be used
    to make sure that group member DNs stay synchronized with the entries in the directory
    information tree.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, directory administrators and directory applications must be careful to
    perform additional verification and cleanup when working with groups. When a DN
    is deleted from the directory, a directory-wide search for attributes that take
    DN values should be performed to make sure that attributes such as `member` and
    `roleOccupant` (and, for that matter, `seeAlso`) do not point to the newly-deleted
    DN.
  prefs: []
  type: TYPE_NORMAL
- en: The Complete LDIF File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally , we have finished building our LDIF file. We will save it in a file
    named `basics.ldif`, since it contains the basic elements of our directory. Here
    is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the OpenLDAP utilities, and we will use
    these utilities to load our LDIF file into the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Utilities to Prepare the Directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter we have looked at the server operations, and created
    an LDIF file representing our initial directory information tree. In the remainder
    of this chapter we are going to look at two groups of tools. In this part we are
    going to look at the OpenLDAP utilities. In the next part we will look at the
    OpenLDAP clients.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the OpenLDAP clients, the utilities do not use the LDAP protocol to connect
    to a server and perform directory operations. Instead they work on a lower level,
    interacting directly with OpenLDAP directories and data files. The OpenLDAP suite
    includes eight utilities that perform administrative tasks. We will look at these
    tools as we go through the process of creating, loading, and verifying directory
    data.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this section is to explain the basic use of these utilities. Each
    utility has a handful of command-line flags that can be used to further modify
    the behavior of the utility. We will see some of the more useful flags, but if
    you want detailed information, you should consult the excellent OpenLDAP man pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent versions of OpenLDAP the utilities do not actually exist as stand-alone
    programs. Instead, they are all compiled into the `slapd` program, and symbolic
    links are created to point from the utility name to the `slapd` program. Using
    the `ls` command, we can look at the utilities to see how this is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All eight of the utilities are just symbolic links to the `slapd` program. When
    `slapd` gets executed, it checks to see what program name was used when it was
    executed, and then it acts like that program. For example, when `slapd` is called
    as `slapadd`, it acts as a program for loading data into the directory. If it
    is called as `slaptest`, it acts as a program for verifying the format of and
    directives in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: As we proceed through the description of the utilities we will cover them as
    if they were separate programs because that is how they are treated.
  prefs: []
  type: TYPE_NORMAL
- en: Since we created an LDIF file in the last part, we will begin this section by
    looking at the tool that loads the LDIF file into the directory backend.
  prefs: []
  type: TYPE_NORMAL
- en: slapadd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slapadd` program is used to load directory data, formated as LDIF files,
    directly into OpenLDAP. It is executed from within an operating system shell (for
    example a command prompt or shell script).
  prefs: []
  type: TYPE_NORMAL
- en: The `slapadd` program does not use the LDAP protocol to connect to a running
    server. Instead, it works directly with the OpenLDAP backend. For that reason,
    when you run `slapadd` you must first shut down the directory server. Otherwise,
    you may end up with conflicts between the `slapd` server process and the `slapadd`
    process as they both try to exclusively manage the same databases.
  prefs: []
  type: TYPE_NORMAL
- en: When Should slapadd be Used?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many tools for loading records into the directory, including the OpenLDAP
    client `ldapadd` (which connects to the server over the LDAP protocol and performs
    one or more add operations). So, how do we figure out which program to use under
    any particular set of circumstances?
  prefs: []
  type: TYPE_NORMAL
- en: Well, `slapadd` is intended to be used to load large amounts of directory data,
    generally for the purpose of creating a new directory, or restoring a directory
    from a backup. Because it requires that the directory be taken offline, this utility
    is not generally a good candidate for performing routine updates. The `ldapadd`
    program (discussed in the *Clients* section later in this chapter) is a much better
    candidate for that sort of operation.
  prefs: []
  type: TYPE_NORMAL
- en: What Does slapadd Do?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `slapadd` utility reads the `slapd.conf` file (and any included files),
    loads the appropriate backend databases, and then reads LDIF data (usually from
    a file). As it reads the data, it verifies that all of the records are correctly
    constructed (that the DNs are in a tree that the server manages, that the records
    use the right attributes for their object classes, that all required fields are
    there, that the record is formatted correctly, and so on), and then it loads the
    records into the appropriate backend.
  prefs: []
  type: TYPE_NORMAL
- en: Since `slapadd` does not connect over the LDAP protocol, it does not require
    any authentication to the directory. It does, however, require write access to
    the directory database files. So `slapadd` is usually run from the shell of either
    the user that runs the directory (often `ldap` or `slapd`) or from the root account.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the LDIF File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous part of this chapter we created an LDIF file containing a handful
    of records for our directory tree. Now we will load this LDIF file into our directory.
    This will take four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the `slapd` server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the LDIF file with `slapadd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the directory with `slapadd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart the `slapd` server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stopping the Server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We covered the process of starting and stopping the server at the end of Chapter
    2\. To summarize, though, we can stop a version installed from the Ubuntu package
    using the `invoke-rc.d` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With the version compiled from source (see [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source")), this can be done by finding the `slapd` process ID and
    killing the process (or using the `killall` program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to make sure that the LDIF file we created in the last part is
    correctly formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Running ldapadd in Test Mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Running in test mode before doing the actual load can greatly reduce the amount
    of time it takes to load a new LDIF file because it will help you catch LDIF errors
    before things get written to the directory. Normally `slapadd` adds records one
    at a time as it reads them. So if there are three records in a file, the first
    record will be added to the directory before the second or third records are read.
    If there is an error in a record later in the file, then the directory will be
    partially loaded, and you will either have to creatively alter the LDIF file or
    destroy the database and start again.
  prefs: []
  type: TYPE_NORMAL
- en: Using test mode, we can make sure that the LDIF file does not have any errors
    before we start loading records into the directory. This should just eliminate
    cases where an LDIF file is only partially imported because of bad records.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `slapadd` program to do this before we try to load the data
    into the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command uses five flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` flag: This puts the program into "verbose" mode, where it will print out
    extra information about what is happening (and, if the process fails, what led
    to the failure). Usually it is a good idea to run `slapadd` in verbose mode, especially
    when loading an untested LDIF file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u` flag: This tells `slapadd` to run in test (or *dry-run*) mode. When this
    is enabled, `slapadd` will evaluate the file as if it were going to load the file
    into the directory, but it won''t actually put any records in the directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` flag: This tells `slapadd` to keep processing the file even if it hits
    a bad record. Using this flag, we can run through the file once and get a list
    of all of the records that are not correctly formatted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f` flag: This flag, which takes as an argument the path to the server''s
    configuration file, specifies which configuration file should be used. In most
    cases you can omit this, and `slapadd` will just look in the default place (usually
    `/etc/ldap/slapd.conf`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-l` flag: This points to the LDIF file we want to load. In this case we are
    loading the `basics.ldif` file, which is located in the system''s `/tmp` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In cases where there is an error in the LDIF file, `slapadd` will print out
    some helpful information. For example, if we try to load an obviously broken file
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file the broken lines are highlighted. When we run `slapadd`, we will
    get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `slapadd` tested our first record, `dc=example,dc=com`, without problems,
    but then encountered a line that did not begin with a DN (on line 11). It skipped
    that record. On line 18 it encountered another error: the `ferble` attribute is
    not defined by any of the object classes in the record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When run successfully against the LDIF file we created earlier in this chapter,
    the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'No errors. We are ready to proceed to the third step: importing the records
    into the directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Records Using slapadd
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To do the actual import of the records into the directory, we use the `slapadd`
    command with a subset of the flags used in the previous section. We omit the `-u`
    flag (for testing) and the `-c` flag (so that it doesn't continue if it encounters
    a bad record).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using the -q flag**'
  prefs: []
  type: TYPE_NORMAL
- en: To load the directory faster, you can add the `-q` flag, which turns off some
    of the time-consuming checks `slapadd` performs on the data. But before using
    this flag, make sure you test the LDIF data first (using the method just described).
    Otherwise you might end up with an unusable directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And, this is what we get as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output is just slightly different this time; at the end of each
    line, there is an ID number enclosed in parentheses. This ID number makes up part
    of the record's `entryCSN` attribute, which is used internally to monitor the
    record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with many LDAP servers, OpenLDAP attaches special **operational attributes**
    to records. In these attributes, OpenLDAP stores directory-centric information
    about the record. We will talk about these more when we discuss the `slapcat`
    utility.
  prefs: []
  type: TYPE_NORMAL
- en: We have just populated our directory with the eight records we created earlier
    in the chapter. We are now ready to start the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the Directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Chapter 2 we discussed starting and stopping the directory. This can be
    done with the init script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you installed according to [Appendix A](apa.html "Appendix A. Building
    OpenLDAP from Source"), `slapd` can be run directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If Something Went Wrong...
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It sometimes happens that midway through a `slapadd`, the program encounters
    an error—either in the LDIF file itself, or from some external consideration—and
    aborts the directory import part way through. In these cases you may need to start
    over. But merely re-running the `slapadd` operation will give errors like this
    (the error may vary depending on the backend you are using):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here?
  prefs: []
  type: TYPE_NORMAL
- en: What has happened is that some of the entries from the `basics.ldif` file have
    already been imported into the directory, but perhaps not all of them. There are
    various ways to attempt to work around this. You can try to prune the LDIF file
    down to just the records that haven't been added already. You can try to run the
    `slapadd` program in continuation mode (with the `-c` flag) and hope that all
    of the remaining records are added correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you may find that the best way of dealing with these cases is to simply
    destroy and rebuild the directory. While this sounds like a rather extreme measure,
    it has one distinct advantage over other methods: it avoids the problem of inconsistent
    records that can be caused with failed `slapadd` commands. Thus, it is often the
    best way of recovering from failed directory imports.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Errors in the index files can also be induced by `slapadd` failures. If you
    decide not to destroy and recreate your directory after a failed `slapadd`, make
    sure you run the `slapindex` utility (covered later in this chapter) after loading
    new records to the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying and Recreating the Directory Files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In most of the OpenLDAP backends that can be loaded with `slapadd`, the backend
    stores data somewhere on the file system or in a relational database. After a
    failed `slapadd` you may find that the best way to recover is to destroy all of
    the data in the underlying backend, and then start over.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we are using the `hdb` backend (see Chapter 2). The method used here
    will apply equally well to other BerkeleyDB backends (`bdb` and `ldbm` in `bdb`
    mode), and can be easily adapted to cover the (deprecated) `ldbm` with `gdbm`
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: For other sorts of backends, such as those that use relational databases like
    PostgreSQL, or custom backends like `back-perl`, you will need to examine the
    documentation on those backends to determine the best way of clearing the records
    from the directory.
  prefs: []
  type: TYPE_NORMAL
- en: For the `hdb` and `bdb` backends, the directory data files are stored on the
    file system. In Ubuntu, these are located at `/var/lib/ldap`. If you followed
    the directions in [Appendix A](apa.html "Appendix A. Building OpenLDAP from Source"),
    the database files are located at `/usr/local/var/openldap-data/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the contents of the `/var/lib/ldap` directory look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you can see all of the directory database files (which start with `__db.`),
    the directory index files (which end with `.bdb`), and the BerkeleyDB transaction
    logs (which begin with `log.`). There are a few other files in this directory,
    such as `alock` and `DB_CONFIG`, that we don''t need to delete. To delete the
    files, we use `rm` with a list of expressions that match only the files we want
    to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes just the files we don''t want. Now the directory should contain
    only a couple of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all it takes to destroy the database. Now we can re-create the directory
    by loading the (corrected, if necessary) LDIF file with the `slapadd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And this message is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That is all there is to destroying and recreating a directory.
  prefs: []
  type: TYPE_NORMAL
- en: slapindex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next utility that we will examine is `slapindex`. This utility manages the
    index files for OpenLDAP backends that use indexes (such as `hdb`, `bdb`, and
    the deprecated `ldbm`).
  prefs: []
  type: TYPE_NORMAL
- en: OpenLDAP maintains a set of index files to expedite searching for records. These
    are stored outside of the main directory database, and as records are added, modified,
    and removed from the directory, the `slapd` server modifies the index files accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: But in certain circumstances, the `slapd` server may not have sufficient information
    to know about changes it needs to make to the index files and, in those cases,
    the indexes will need to be rebuilt manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `slapadd`, `slapindex` should not be run while the server is running. Before
    running `slapindex`, you should stop `slapd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three common cases that require use of the `slapindex` command:'
  prefs: []
  type: TYPE_NORMAL
- en: When a utility, usually `slapadd`, is used to add records to an *existing* database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the indexing directives in `slapd.conf` are changed, or new indexes are
    added (see Chapter 2 and the *Performance* *Tuning* section of Chapter 5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On other (rare) occasions, external conditions or failed `slapadd` commands
    may get the directory database and the directory indexes out of sync. The main
    symptom of this synchronization error is that searches using `ldapsearch` will
    fail to return records that are known to be in the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In these three cases, `slapindex` should be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This will rebuild all of the indexes for the first database defined in `slapd.conf`
    (we only have one database defined).
  prefs: []
  type: TYPE_NORMAL
- en: The `-q` flag instructs slapindex to perform some additional checking operations,
    which will greatly expedite the process of re-indexing. Skipping such checks is
    generally safe with the `slapindex` utility, though it should only be done with
    great care when using `slapadd`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-f` flag, which takes the path to a configuration file, specifies the `slapd`
    configuration file. If this flag is omitted (as we have done), `slapindex` will
    look in the default location for the `slapd.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to monitor the progress of `slapindex`, you can use the `-v` flag
    to turn on verbose output.
  prefs: []
  type: TYPE_NORMAL
- en: slapcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slapcat` program dumps the entire contents of a directory into an LDIF
    file. It is a convenient tool for creating a backup of the directory, and can
    also be useful for examining the data is in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is a similar client application, `ldapsearch`, which can also
    dump the entire contents of the directory. How do you know when to use each? Since
    `ldapsearch` uses the LDAP protocol to contact the server, bind, and then run
    LDAP search operations, it incurs more overhead. `slapcat`, on the other hand,
    works directly with the backend. `ldapsearch` is limited by time and size limits,
    set both in the client configuration file, `ldap.conf`, and in the server's configuration
    in `slapd.conf` (see Chapter 2). The `ldapsearch` command is also limited by ACLs,
    while no ACLs are applied to `slapcat`.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly then, for operations such as backing up the directory, `slapcat` ought
    to be used rather than `ldapsearch`.
  prefs: []
  type: TYPE_NORMAL
- en: As of version 2.3 of OpenLDAP, if you are using the `hdb` or `bdb` backends,
    you can safely run `slapcat` while `slapd` is running; there is no need to shutdown
    the directory server in order to make a backup copy.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The man page for `slapcat` in OpenLDAP incorrectly indicates that it is unsafe
    to run `slapcat` while the directory server is running. This is simply an artifact
    of the earlier versions of OpenLDAP (2.2 and earlier), in which `slapcat` could
    not be run while `slapd` was running. Note that it is still unsafe to run `slapcat`
    against an `ldbm` backend while `slapd` is running.
  prefs: []
  type: TYPE_NORMAL
- en: When we covered `slapadd` earlier in this chapter, we used that utility to load
    records in `basics.ldif` into the directory. Now we can use `slapcat` to view
    those records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `-l` flag, which takes a path for an argument, indicates what file the output
    should be written to. In this case it is writing to the file `basics-out.ldif`.
    If `-l` is omitted, then the LDIF data will be sent to standard output, which
    will usually be printed straight to your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other utilities, the `-f` flag can be used to specify the path
    to the SLAPD configuration file. The `-a` flag, which takes an LDAP filter, can
    be used to specify a pattern that records must match before they are dumped to
    output. You can use this flag to dump just a subtree. For example, we could dump
    only records in the `Users` OU with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return complete records for only the following three DNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ou=Users,dc=example,dc=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid=matt,ou=Users,dc=example,dc=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid=barbara,ou=Users,dc=example,dc=com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operational Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the output for just the record of the base DN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted attributes should look unfamiliar, as they did not exist in
    the original LDIF file that we created. These are internal **operational attributes**
    that OpenLDAP automatically maintains.
  prefs: []
  type: TYPE_NORMAL
- en: Different operational attributes play different roles in OpenLDAP, and these
    attributes may be useful for directory managers and LDAP-aware applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `creatorsName`, `modifiersName`, `createTimestamp`, and `modifyTimestamp`
    fields often come in useful. OpenLDAP automatically retains the following record-level
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: When and by whom each record was created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and by whom each record was last modified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `entryUUID` attribute provides a **Universally Unique Identifier (UUID)**
    for a record, which serves as an identifier that is more stable than DN (which
    can change), and is supposed to be, according to the specification in RFC 4122
    ([http://rfc-editor.org/rfc/rfc4122.txt](http://rfc-editor.org/rfc/rfc4122.txt)),
    "an identifier unique across both space and time, with respect to the space of
    all UUIDs." See the `entryUUID` RFC at [http://rfc-editor.org/rfc/rfc4530.txt](http://rfc-editor.org/rfc/rfc4530.txt).
  prefs: []
  type: TYPE_NORMAL
- en: The `entryCSN` (**Change Sequence Number**) attribute is used by the SyncRepl
    replication provider to determine what records need to be synchronized between
    LDAP servers. We will see this in more detail in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the attribute `structuralObjectClass` is added. This attribute specifies
    which of the object classes is to be treated as the structural object class. Recall
    that when we created our records for Matt and Barbara, each record had three object
    classes: `person`, `organizationalPerson`, and `inetOrgPerson`. All three are
    structural object classes, and all three are related (`inetOrgPerson` is a child
    of `organizationalPerson`, which in turn is a child of `person`). But each record
    can have only one structural object class. As I noted above, the one farthest
    down the tree becomes the structural object class, and the others are treated,
    essentially, as abstract object classes. We can see this if we use `slapcat` to
    dump Barbara''s record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `structuralObjectClass` attribute has the value `inetOrgPerson`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we've examined the `slapcat` tool, as well as the `slapindex`
    and `slapadd` tools. These three are the most often used utilities. But there
    are a few others that can come in handy in certain circumstances. So next, we
    will look at `slapacl`.
  prefs: []
  type: TYPE_NORMAL
- en: slapacl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing ACLs can be frustrating and difficult to test. In order to ease the
    process of testing the efficacy of ACLs in the `slapd.conf` file, the OpenLDAP
    suite includes a tool for testing ACLs directly. We will make greater use of this
    tool when we test ACLs in Chapter 4, but we will see an introduction to the utility
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 2, we added the following ACL to `slapd.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This ACL specifies that for any given record in the directory, if it has `userPassword`,
    the following rules should be applied to requests for access to that attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: The `anonymou s` user should be able to authenticate using `userPassword`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should allow a DN the permissions to modify (and read) its own password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should deny all other DNs all access to this record's `userPassword`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That means that `uid=matt,ou=Users,dc=example,dc=com` should not be able to
    write a new `userPassword` value for `uid=barbara,ou=Users,dc=example,dc=com`.
    We can use the `slapacl` utility to test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This command might look daunting at first, but it is actually very simple.
    Let''s look at the arguments in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: The `-v` flag tuns on verbose output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-D` flag is used to tell `slapacl` which DN is trying to access the directory.
    In this case, we said: `-D "uid=matt,ou=Users,dc=example,dc=com"`. That is, `slapacl`
    is testing to see if the DN for Matt can get access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-b` flag indicates which record we want the given DN to try to access.
    In this case it is Barbara''s DN, since we want to test if Matt can write Barbara''s
    password: `-b "uid=barbara,ou=Users,dc=example,dc=com"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last argument specifies what attribute we want to access, and what
    sort of privilege we are requesting. In this case, we want the `userPassword`
    attribute, and we want to see if Matt has `write` access to it (`"userPassword/write"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in the end, we are testing to see if Matt''s DN can write a new `userPassword`
    for Barbara''s record. Here is the result of the `slapacl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That's the result we would expect. Because of this ACL, Matt cannot write to
    Barbara's `userPassword` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: slapauth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `slapauth` tool is used to test SASL authentication to the directory. When
    an application attempts to bind using SASL, instead of specifying a complete DN
    (like `uid=matt,ou=Users,dc=example,dc=com`), the application passes in a user
    ID (`u: matt`) along with a few other bits of information, such as a realm identifier
    and an authentication mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover SASL authentication in Chapter 4\. If you do not already have
    experience with SASL you may want to read on, and come back to this section after
    reading Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: OpenLDAP can then take that information and use a regular expression to guess
    what DN that user belongs to. But it can be difficult to figure out what the regular
    expressions will look like. The slapauth tool is useful in testing what one particular
    SASL request will look like when OpenLDAP receives it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could add the following SASL configuration directives to our
    `slapd.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The regular expression in `authz-regexp` should convert from a SASL authzID
    format to an LDAP DN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter, `-U matt`, sends a test request with the SASL authcID
    of `matt`. The `-X "u: matt"` parameter sends a test request with the authzID
    `u: matt`. These should then output a correctly formatted DN, according the the
    regular expression in `authz-regexp`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use `slapauth` more in Chapter 4 when we set up SASL authentication.
  prefs: []
  type: TYPE_NORMAL
- en: slapdn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **`slapdn`** tool is used to test whether a given DN is valid for this directory
    server. Specifically, it tests a DN against the defined schemas to make sure that
    the DN is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of `slapdn` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In these two examples, the DNs checked out. `slapdn` tested the DNs, and then
    printed out the normalized version (all lowercase, extra spaces removed) and the
    pretty (originally formated) version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case no schema was found that had the attribute `fakeAttr`. Here''s
    another failed case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: While `documentSeries` is defined in a schema it is an object class, not an
    attribute, and object class names cannot be used in constructing DNs.
  prefs: []
  type: TYPE_NORMAL
- en: The usefulness of the `slapdn` program is limited to only rare cases where you
    need to test a DN against a directory without being able to look at the `slapd.conf`
    file to find out what schemas are loaded (or, alternately, search the schemas
    using the `ldapsearch` program).
  prefs: []
  type: TYPE_NORMAL
- en: slappasswd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slappasswd` utility is a tool for encrypting passwords according to schemes
    supported by OpenLDAP, such as the one described in RFC 2307 ([http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: Storing and Using Passwords in OpenLDAP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we created our basic LDIF file, we used the `userPassword` attribute for
    storing passwords. For example, our authentication account record looked like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `userPassword` field has the password in plain text. When the value is
    loaded into the directory `userPassword` is encoded with base-64, and looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: But this is not encrypted—just encoded in an easily reversible way. While it
    might prevent the directory administrator from accidentally seeing the user's
    password, base-64 encoding will do nothing to prevent an attacker from figuring
    out the password.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the Python scripting language, you can easily encode and decode strings
    with the built-in `base64.b64encode()` and `base64.b64decode()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: But OpenLDAP does not require you to store passwords in unencrypted text. In
    fact, it is best if you do not. OpenLDAP supports a number of one-way hashing
    algorithms that can be used to store the passwords in a way in which they cannot
    be decrypted.
  prefs: []
  type: TYPE_NORMAL
- en: The `slappasswd` program provides the tools to create a hashed value of a password.
    That hashed value can then be used in the `userPassword` field of an LDIF file.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenLDAP supports five different password hashing schemes: Crypt (`CRYPT`),
    Message Digest 5 (`MD5`), salted MD5 (`SMD5`), Secure Hashing Algorithm, the SHA-1
    version (`SHA`), and Salted SHA (`SSHA`). By default, OpenLDAP uses the most secure
    of the available hashing algorithms: `SSHA`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Passwords are stored in the `userPassword` field in a format according to section
    5.3 of RFC 2307 ([http://rfc-editor.org/rfc/rfc2307.txt](http://rfc-editor.org/rfc/rfc2307.txt)).
    An encrypted password looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the password, the section in curly braces (`{}`) indicates
    which of the five password schemes was used. In this case it is the default SSHA
    algorithm. The remainder of the field is the digested hash of the password.
  prefs: []
  type: TYPE_NORMAL
- en: While the hashed password cannot be decrypted, when a user tries to bind to
    the server, OpenLDAP takes the password the user supplies and encrypts it using
    the same algorithm as the value (and same salt) of the value of `userPassword`.
    If the two hashed passwords match, then OpenLDAP logs the user on. If the two
    do not match, OpenLDAP responds with an error message indicating that authentication
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a Password with slappasswd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Armed with this basic understanding of how passwords are used and stored, we
    can now look at the `slappasswd` program. This program can be used to encrypt
    a password and format it for insertion into an LDIF file. The command can be called
    with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, since no parameters were specified on the command line, `slappasswd`
    prompts for a password, and then prompts for verification of the password. Then,
    it prints out the encrypted value of the password. We can use this value in an
    LDIF record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, typing and retyping passwords may be too tedious, and a faster
    method of encrypting a number of passwords is preferred. You can either use the
    `-T` flag to point to a file containing a list of clear-text passwords to be hashed,
    or you can specify the password on the command line with the `-s` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this shell command, each of the three clear-text passwords, `foo`, `bar`,
    and `baz`, are encrypted by `slappasswd`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On a multi-user system, other users may have access to your command history,
    and thus would be able to see these passwords in cleartext. Caution should be
    used when specifying passwords (or other sensitive information) on the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `-h` flag, you can specify which hashing algorithm `slappasswd`
    should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the above commands, the same password, `test`, is encrypted using three different
    hashing schemes.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will turn to the last OpenLDAP utility—`slaptest`.
  prefs: []
  type: TYPE_NORMAL
- en: slaptest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slaptest` utility is used for checking the format and directives used in
    the `slapd.conf` file (and any files included by `slapd.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `slaptest` is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `-v` flag turns on verbose output, and the `-f` flag, which takes one argument,
    specifies which configuration file to check. If `-f` is omitted, then the default
    `slapd.conf` file (usually `/etc/ldap/slapd.conf`) is checked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in the previous chapter, the version of `slaptest` provided by Ubuntu
    Linux does not print warnings if a directive in `slapd` is unknown. This is non-standard
    behavior. Most of the time OpenLDAP is compiled with such warnings enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the configuration file is correctly formatted and the directives are all
    valid and operational, then `slaptest` will print out a basic success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If anything goes wrong however, `slaptest` will print out diagnostic information.
    For example, if I add an include directive to `slapd.conf` that points to a file
    that does not exist, `slaptest` will print an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This output should be helpful for tracking down the problem in the configuration
    files. In this case it was caused by a line that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is the last of the OpenLDAP utilities. Now we will turn to the client applications
    that are included with the OpenLDAP suite.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Directory Operations Using the Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a host of OpenLDAP clients, all stored at `/usr/bin` (or `/usr/local/bin`
    if you compiled according to [Appendix A](apa.html "Appendix A. Building OpenLDAP
    from Source")). The OpenLDAP clients communicate over the LDAP protocol. They
    are all standards-compliant, and follow the LDAPv3 protocol (which was last updated
    in June 2006).
  prefs: []
  type: TYPE_NORMAL
- en: While some of the clients provide the basic standardized LDAP operations, such
    as search, add, and delete, others implement one or more of the LDAP extensions.
    But since the suite of tools does follow the standards, these tools should work
    against any standards-compliant LDAP directory server.
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the chapter we will take a brief look at each of the OpenLDAP
    clients and see how they can be used to interact with an LDAP server. We do not
    have the space to cover all of the details of each client, so we will focus on
    the most useful and common features of each client. The OpenLDAP man pages (which
    are installed with OpenLDAP) are detailed and informative, and they provide a
    good source of further information for these clients.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the utilities in the last part required that the SLAPD server must not
    not be running. All of the tools in this section, however, connect to a SLAPD
    server. So make sure your server is running before trying the examples in this
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Common Command-Line Flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the OpenLDAP clients are command-line applications that use UNIX-style
    flags to pass parameters to the program. For the sake of continuity common flags
    (like `-D`, `-b`, and `-H`) are used consistently across all of the clients.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2 we configured our directory server to handle basic directory operations.
    However, we did not configure it to use SASL authentication (which is covered
    in Chapter 4). To authenticate to the server we will be using what is called **simple
    binding**. In simple binding the client authenticates by sending a full DN and
    password to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The clients require different command-line flags depending on whether they do
    a simple bind or a **SASL bind**. Now we will see those necessary for simple binding.
    Those flags needed for SASL binding are covered in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Common Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are command-line flags for the simple binding process. Some of the common
    flags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-D`: The `-D` flag is used to specify the full DN of the user who will bind
    to the directory server (this is used for simple binding).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-W`, `-w`, `-y`: Each of these flags indicates a different source for the
    password. Let''s see them one by one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-W` flag indicates that the user should be interactively prompted to enter
    a password.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-w` flag takes the password string for a value. We can use it to specify
    the password on the command line.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-y` flag takes a file name as an argument. It will use the contents of
    the file as a password. These flags are mutually exclusive—you can only use one
    of these per command.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `-y` flag uses the entire contents of a file for the password. This means
    that if there is a line break in the file, it will be treated like part of the
    password. To create a password file, you can use the `echo` command with the `-n`
    flag: `$ echo -n "secret" > my_pw`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`-x`: The `-x` flag specifies that the client will use a simple bind. If this
    is not specified, the client will try a SASL bind.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-H`, `-h`: These two flags provide different ways of specifying which host
    to connect to. `-H` takes an LDAP URL (`-H ''ldap://example.com:389''`). `-h`
    simply takes the host name (`-h example.com`), and can be used with `-p` to specify
    a port. Unless you do not have a choice, use `-H`. The `-h` flag is provided only
    for backward compatibility, and may disappear in future versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-Z`: This flag is used to indicate that the client should issue a **Start
    TLS** command to the server, so that traffic is encrypted according to the TLS
    standard. But if TLS negotiation fails, the client will still continue to operate.
    Using two Z''s (`-ZZ`) will make it mandatory that the traffic be encrypted. If
    negotiation fails, then the client will disconnect. TLS is covered in more detail
    in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This is used to specify a base DN (`-b ''dc=example,dc=com''`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: The `-f` flag takes a filename as a parameter. The client will then read
    the contents of the file and build requests based on the contents of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v`: This flag will turn on verbose output. It is useful when troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the common flags used by the clients in the OpenLDAP suite. But these
    represent only a subset of the flags used by each client, as each client implements
    the flags needed to accomplish its task.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Defaults in ldap.conf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Chapter 2, in the section entitled *Configuring the LDAP Clients*, we looked
    at the `ldap.conf` file. In that file, we set some useful defaults. In particular
    we set these three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: If you omit host settings (`-H`, `-h`), then the value of `URI` will be used.
    If the client needs a base DN, and none is set with the `-b` flag, then the value
    of `BASE` is used. Likewise, if the client uses simple binding (with `-x`), and
    doesn't specify a DN with `-D`, then the value of `BINDDN` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have an `ldap.conf` file created already, many of the examples will
    omit the `-H` and `-b` flags.
  prefs: []
  type: TYPE_NORMAL
- en: While `ldap.conf` is shared by all clients, you can create a user-specific LDAP
    configuration file in your home directory. The LDAP clients will look for user-specific
    configuration files named `ldaprc` and `.ldaprc` in your home directory (`$HOME`).
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to look at the client commands.
  prefs: []
  type: TYPE_NORMAL
- en: ldapsearch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first client we will look at is also the most often used tool: `ldapsearch`.
    As the name suggests, this is a tool for searching the directory information tree.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ldapsearch` client connects to the server, authenticates a user, and then
    (as that user) runs one or more **search operations**, returning the results in
    LDIF format. When it is done performing searches, it closes the connection and
    exits. Since `ldapsearch` is a network client it can be used to search both local
    directories or a remote directory server.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple search command. In this command we will log
    in as the directory manager and request the record for the entry with the user
    ID *barbara*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we ran the `ldapsearch` command with four flags: `-x`, `-W`,
    `-D`, and `-b`. For a description of these flags see the *Common Command-Line
    Flags* section. In a nutshell though, `-x`, `-W`, and `-D` are all parameters
    used for authenticating to the directory. They instruct the client to bind to
    the directory with simple authentication (`-x`) as the DN specified by `-D` (the
    directory manager in this case), then prompt the user to enter a password interactively
    (`-W`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `-b` flag sets the base DN for the search. This is set to `ou=Users,dc=example,dc=com`.
    Given this, `ldapsearch` will start searching in the `Users` OU.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we had omitted the `-b` flag, the value of BASE in `ldap.conf` would have
    been used, which would have set the base DN to `dc=example,dc=com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of the command-line flags and their arguments, we specified an LDAP
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the filter that the server will use for searching. We covered search
    filters in more detail earlier in this chapter, in the section entitled *The*
    *Search* *Operation*. In this case though, the search filter is straightforward:
    it matches only records that have the attribute named `uid` with the attribute
    value of `barbara`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many attributes have more than one name (these are properly called **attribute
    descriptions**). For example, the attribute that labels user IDs has the attribute
    descriptions `uid` and `userID`. In the case above, a search for `(uid=barbara)`
    will also match directory entries with and attribute of the form `userID: barbara`.'
  prefs: []
  type: TYPE_NORMAL
- en: When this command is run, it will first prompt the user to enter a password
    (because of the `-W` flag), and then connect to the server and attempt to bind
    as the specified DN (`cn=Manager,dc=example,dc=com`). Then, if the bind is successful,
    it will request all records that match the filter, `(uid=barbara)`. As the example
    illustrates, the server will return the entire record of the user, or as much
    of it as the ACLs allow, in the case of a non-manager user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are returned in LDIF format, with comments sprinkled throughout.
    The first set of comments provides basic information about the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line indicates that this record is in extended LDIF format. This
    is LDIF version 1.0, plus some comments. Beneath that, we get a summary of the
    search, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Version of LDAP used (v3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the base DN is (`ou=Users,dc=example,dc=com`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of search will be performed. In this case, it is a **subtree search**,
    which means the server will look in all records beneath the base DN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the operating search filter is (`(userid=barbara)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What attributes the client wants returned. `ALL` indicates that the client wants
    all available attributes returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The central part of the file contains the full record for Barbara. Beneath
    the record is a brief summary of the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `search`, indicates that we performed two search operations
    (one for binding and one to execute the filtered search).
  prefs: []
  type: TYPE_NORMAL
- en: The second, `result`, inidcates the result code that the server sent back. `0
    Success` indicates that our search ran without encountering any errors.
  prefs: []
  type: TYPE_NORMAL
- en: The extended (and thus commented) results add some additional information. `numResponses`
    indicates that the server sent two responses back to the client (one for the bind,
    one for the search). And `numEntries` indicates how many entries were returned
    by the search. In this case there was only one—Barbara's record.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting Returned Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we don''t want to get a DN''s entire record back. Instead, we just
    want a couple of attributes. This can be accomplished by specifying a list of
    attributes at the end of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example we used the `-w secret` flag to specify the password
    on the command line. We also used the `-LLL` flag to suppress all of the extraneous
    comments printed in the LDIF output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Specifying the password on the command line can be a security risk. Other users
    on the system may be able to access this information through command-line histories
    (like the Bash shell's history feature) and operating system constructs (like
    the `/proc` file system in Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the filter, `(userID=matt)`, I also added a list of attributes
    that I wanted returned: `cn` and `mail`. The returned record contained four lines:
    the `dn`, the two `mail` attributes, and the `cn` attribute. The DN is always
    returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Operational Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the record returned for Barbara by `ldapsearch` is
    quite a bit different than the record returned by `slapcat`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered `slapcat` in the part of this chapter entitled *Using the Utilities
    to Prepare the Directory*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the two. First, here''s the `ldapsearch` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, here''s the `slapcat` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of `slapcat` has a host of additional attributes—namely the special
    operational attributes that the directory maintains internally. We can retrieve
    the operational attributes with `ldapsearch` either by specifying them by name
    along with the list of desired attributes, or by using the special plus sign (`+`)
    attribute list specifier at the end of the `ldapsearch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'And, this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying the `+` list does not return all attributes—only the operational
    attributes. To get all of the regular attributes and all of the operational attributes,
    you will need both the `+` specifier and the `*` (asterisk) specifier. The `*`
    specifier indicates that we want all of the standard attributes. This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the complete list of attributes. Using this combination of arguments,
    we can generate LDIF files suitable for making backups (assuming the ACLs are
    not preventing access to something). While `slapcat` will outperform `ldapsearch`
    for this task, the fact that `ldapsearch` can run remotely over the network is
    attractive in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that in the given record, `ldapsearch` has returned three operational
    attributes that do not show up with `slapcat`: `entryDN`, `subschemaSubentry`,
    and `hasSubordinates`. These values are generated dynamically at runtime and do
    not exist in the LDAP backend. For that reason they are not exported with `slapcat`.
    Since they are generated dynamically, they are not useful values to back up.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to run multiple queries in sequence using `ldapsearch`.
    This is done by using an external file to store filter information for multiple
    searches.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Using a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ldapsearch` client can use a file to build and execute multiple queries.
    Let''s say we have a plain text list of user IDs, and we want to get the last
    name for each user ID. The file, `userIDs.txt`, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `ldapsearch` to dynamically build a filter and run a search for
    each user''s surname. To do this, we use the `-f` flag, and point to the `userIDs.txt`
    file, and then we build a special filter. Here is the command line to be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this should look familiar, by now. But notice the filter: `''(uid=%s)''`.
    This filter uses the special `%s` placeholder to indicate where the values from
    the file ought to be placed. As `ldapsearch` runs, it will read through the `userIDs.txt`
    file line by line, and with each line, it will execute a search, substituting
    the value of the line for `%s` in the filter. The results look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this example the `ldapsearch` client actually ran two different search operations.
    It first expanded `(uid=%s)` to `(uid=matt)` and ran a search; then, it expanded
    `(uid=%s)` to `(uid=barbara)`, and ran another search. In each case, it returned
    only the `dn` (which is always returned for a match) and the requested `sn` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create filters in a file, and have multiple search filters run.
    For example, we could create a file named `filters.txt` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Since each line will be inserted into a filter, we do not need the outer set
    of parentheses. Now we can use these lines to dynamically build filters with `ldapsearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this case the filter `(%s)` was expanded in the first case to `(&(ou=System)(objectClass=account))`,
    and in the second case to `(&(uid=b*)(ou=Users))`.
  prefs: []
  type: TYPE_NORMAL
- en: Using techniques like this it becomes possible to execute a number of complex
    searches with one command.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue using the `ldapsearch` client throughout this book. Now that
    we have a basic idea as to how it works, we will move on to the next client in
    the OpenLDAP suite.
  prefs: []
  type: TYPE_NORMAL
- en: ldapadd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a command-line program used for adding new entries to an LDAP directory.
    The `ldapadd` command is not actually a stand-alone client. It is just a link
    to the `ldapmodify` program. When `ldapmodify` sees that it has been called as
    `ldapadd`, it will assume that it should request that the server perform an **add
    operation**, instead of requesting a modify operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the most simple case, `ldapadd` can be used to enter a new record from the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have been successfully authenticated, the cursor will move to the next
    line and wait for the input. We can directly enter a record. As soon as we hit
    *Enter* twice (creating a blank line, which indicates the end of a record), `ldapadd`
    will send the record to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted portion is the text that we entered. It specifies one entire
    record (a record for a user named Adam Smith).
  prefs: []
  type: TYPE_NORMAL
- en: 'After we pressed the return key twice, inserting a blank line, the record was
    sent to the server. The client indicated that it was adding the record: `adding
    new entry "uid=adam,ou=Users,dc=example,dc=com"`. No error message followed. This
    means that the add was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: Once a record is added the cursor will move to a blank line, waiting for the
    `dn` attribute of the next record.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In this example the record that we entered (again, highlighted) contained an
    undefined attribute, and the server balked with the same error message. In cases
    where the server sends an error message, the `ldapadd` client prints the error
    message and exits. To re-enter the record you will have to re-run `ldapadd`.
  prefs: []
  type: TYPE_NORMAL
- en: But as long as new records are valid and the server does not report an error,
    `ldapadd` will continue prompting (or rather listening) for new records. When
    finished, use the *CTRL*-*C* key combination to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Records from a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While typing a record directly into the client may be useful on occasion, in
    most cases it is far more convenient (and less error prone) to create the records
    in a plain text file, and then load them all at once with the `ldapadd` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, the records in the text file should be formated in LDIF. Here, for
    example, are the contents of the file `user_records.ldif`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add all of the records in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Just as when we added records interactively, here the absence of an error message
    indicates that the record was successfully added.
  prefs: []
  type: TYPE_NORMAL
- en: Next we will look at modifying records that already exist in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: ldapmodify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ldapmodify` program is used to modify an existing entry. It can add, change,
    and delete the attributes of a entries in the directory. It can also be used to
    add new entries (together with attributes for the entry).
  prefs: []
  type: TYPE_NORMAL
- en: Like `ldapadd`, `ldapmodify` can be run interactively. It can be used to add,
    modify, and remove records.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Record with ldapmodify
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax for adding a record is almost identical in `ldapmodify` to that
    of `ldapadd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is the addition of the `changetype` instruction after the
    `dn`. This tells `ldapmodify` what sort of LDAP operation should be performed
    on this record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `changetype` instruction is not an attribute, though it looks like one.
    It is not part of the record, but rather an instruction (in LDIF format) to tell
    the server what operation it should use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four possible values for `changetype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modrdn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these corresponds to an LDAP operation. The `add` change-type is used
    to add a new record (essentially performing the same add operation as `ldapadd`).
    The `modify` change-type takes an existing record and modifies it in some way
    (for example, by adding, replacing, or removing attributes). The `modrdn` change-type
    changes the relative DN (or RDN) of a record. The `delete` change-type deletes
    the entire record from the directory server.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Existing Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually it is easier to add records with `ldapadd`. Where the `ldapmodify` client
    really shines is in its ability to modify existing records, adding, removing,
    or replacing attributes within a record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `givenName` field to one of the records we added in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Just as with `ldapadd`, once the authentication phase has been done, `ldapmodify`
    waits for a DN to be given. After the `dn` attribute is specified, the `changetype`
    should follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a `modify` change-type, as we do here, we must also specify exactly
    what attributes we are going to change, and how we will change them. The modify
    change-type is the only type that requires this further specification. Here is
    the figure displaying the several change-types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying Existing Records](img/1021_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we want to add a new attribute to the the `uid=david`, `ou=Users`,
    `dc=example`, `dc=com` record. And the attribute we want to add is `givenName`.
    So, the line that specifies that we will add a `givenName` attribute reads `add:
    givenName`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to specify the attribute and attribute value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Then, by hitting *Enter* twice, we indicate that the record is complete. Just
    as with `ldapadd`, `ldapmodify` indicates which record it is modifying. If the
    server does not return an error, `ldapmodify` will wait for another modify record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` modification type is one of three that `ldapmodify` supports. Operations
    can only be specified if the change-type is set to modify. The three modification
    types are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: Adds new attributes to an existing record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace`: Replaces existing attribute values with new attribute values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: Removes attributes from the record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More than one of these operations can be done in a single transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example we first add `givenName`, and then replace the existing `cn`
    value with a new one. Between the two modification requests we use a dash (`-`)
    to indicate that we are still working on the same record. Remember, a blank line
    indicates that we are done with the record. Now, if we look up the record with
    `ldapsearch`, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `cn` has been replaced, and the `givenName` attribute has been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the modification is adding several attributes, rather than splitting the
    additions up using dashes, you can group them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in this case, the `add` line has two attribute names (`description`
    and `title`), followed by both attributes. And just as with `ldapadd`, we can
    put these change records into a plain text file, and then use the `-f` flag, which
    takes the path to a file, to have `ldapmodify` read the commands from the file
    instead of from the interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `modify` change-type we can delete an attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an attribute from the record has the result of deleting all of the
    attribute values from the record. For example, if Nicholas had two titles specified,
    the above would remove them both.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete just one specific attribute, the request must also name the attribute
    value to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: That will delete any `title` attribute values that contain the exact string
    "Cartesian philosopher", leaving any other attribute values intact.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Relative DN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third change type is for modifying relative DNs—the portion of the DN that
    identifies the current record (see the discussion at the beginning of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can change the RDN portion of the DN for our user `uid=immanuel,ou=Users,dc=example,dc=com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `modrdn` change-type to instruct SLAPD to change
    the RDN portion of the user's DN. The `newrdn` instruction supplies the new RDN
    portion, and the `deleteoldrdn` instruction determines whether the old attribute
    value (`uid=immanuel`) will be deleted or retained. Setting `0` indicates that
    the old attribute value should not be deleted, while `1` will result in the old
    attribute value's removal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we search for that user, we can observe the modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases we don''t want the old RDN attribute value to be kept. In such
    cases, setting the `deleteoldrdn` value to `1` will remove the old RDN attribute
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This changes the RDN back to `uid=immanuel`, and since `deleteoldrdn` is set
    to `1`, the old UID value (`manny`) should be deleted. We can verify this with
    `ldapsearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in addition to the changed DN, the old `uid` attribute value (`manny`)
    is no longer present in the record. It has been replaced.
  prefs: []
  type: TYPE_NORMAL
- en: We will take another look at modifying relative DNs when we examine the `ldapmodrdn`
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Moving a Record with modrdn
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `modrdn` change-type can be used for more than just changing the RDN. It
    can be used for changing a record's superior entry, essentially relocating a record
    within the directory information tree.
  prefs: []
  type: TYPE_NORMAL
- en: For this operation to work however, the backend database type must support this
    sort of modification. Currently, the only storage database that supports this
    is HDB. In Chapter 2, we set up `slapd.conf` to store the `dc=example,dc=com`
    tree in an HDB backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can issue a compound ModRDN operation, in which we change the record''s
    RDN, and move the record to a different OU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we change the user's UID from `manny` back to `immanuel`. Since
    `deleteoldrdn` is `1`, the old RDN (`uid=manny`) will be removed from the record.
  prefs: []
  type: TYPE_NORMAL
- en: The `newsuperior` instruction tells SLAPD what the new base portion of the DN
    ought to be. This will effectively move the record from the `ou=users` branch
    to the `ou=system` branch of our directory information tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike modifying a user's RDN, changing a record's superior will not modify
    any of the fields in the record. Thus, our record above would still have the `ou=Users`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we can use `ldapsearch` to see the newly modified record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Notice that not only has the `uid` changed, but also the `ou` in the DN.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the `newsuperior` instruction, you must first specify a `modrdn`.
    Thus, if we wanted to move the record for this user back to the users OU, we would
    still have to specify the user's new RDN.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you move a record without changing the RDN?
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `modrdn` change-type does not require that the new RDN be different
    from the old one, a record can be moved with `modrdn` simply by setting the `newrdn`
    to be the same as the old RDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, `newrdn: uid=immanuel` does not actually change the RDN of the
    user. But this is necessary in order to change the superior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `newsuperior` instruction indicates that the record should be moved (back)
    to the `ou=users,dc=example,dc=com` tree. One last `ldapsearch` of this record
    shows us the results of that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the record is back in the `Users` OU.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Entire Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, using the `delete` change-type, we can delete an entire record with
    `ldapmodify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: When deleting a record all we need to specify are the DN and the change-type.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, using the delete change-type performs the same task as is done
    using the `ldapdelete` client.
  prefs: []
  type: TYPE_NORMAL
- en: ldapdelete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ldapdelete` tool is used to delete one or more records from the directory.
    It performs the same operation as the `delete` change-type used in `ldapmodify`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to delete a record with `ldapdelete`, you must know its DN. This
    tool will not search for, say, all records that have a specified address, and
    then delete them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the `ldapdelete` command is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: After the usual flags (`-x`, `-w`, `-D`), `ldapdelete` takes the DN that is
    to be deleted (this is the DN for `uid=nicholas` on the second line of the command).
    Upon execution it will request that the server delete the record. Assuming that
    the record exists and the user is allowed (by the server's ACLs) to delete the
    record, then the record will be removed from the directory.
  prefs: []
  type: TYPE_NORMAL
- en: ldapcompare
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This tool is used to ask the server whether a particular entry (identified by
    a DN) has a particular attribute that matches the attribute specified. If the
    entry does have a matching attribute, then `ldapcompare` returns `TRUE`. Otherwise,
    it returns `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a pair of examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first example `ldapcompare` requested that the server examine the record
    for `uid=david,ou=Users,dc=example,dc=com` to see if it had the attribute `givenName`
    with the value `David`. The record did have an attribute `givenName: David`, and
    so the return value is `TRUE`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second example performed a similar compare on the same record; it looked
    for the attribute `cn` with the value `Dave Hume`. While the record does have
    a `cn` attribute, the value of that attribute is `David Hume`, not `Dave Hume`.
    So the server returned `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Base-64 Encoding with ldapcompare**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where the value to compare is not an ASCII string, you should base-64
    encode the value and use the double colon syntax (`::`) that we used in our LDIF
    files. Example: `givenName::RGF2aWQ=`'
  prefs: []
  type: TYPE_NORMAL
- en: An LDAP compare operation is often much faster than a search operation. In cases
    where the same task can be accomplished with `ldapsearch` and `ldapcompare`, it
    is often more efficient to use `ldapcompare`.
  prefs: []
  type: TYPE_NORMAL
- en: ldapmodrdn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ldapmodrdn` client is used to change the Relative DN (RDN) portion of
    a DN. This client requests a ModifyDN operation. `ldapmodrdn` takes the full DN
    of an existing record, and the relative DN that should replace the existing RDN
    for the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: This example requests that the RDN for `uid=immanual,ou=Users,dc=example,dc=com`
    be changed from `uid=immanuel` to `uid=manny`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the record after the change. We will search by the
    `sn` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the filter is looking for records with the surname `Kant` and requesting
    that only the `uid` attribute be returned. Recall that we did not ever add a `uid`
    attribute with the value `manny`—we only had `uid: immanuel`.'
  prefs: []
  type: TYPE_NORMAL
- en: But looking at the results, we can see that not only has the DN been modified,
    but a new user ID attribute has been added for us. In some cases it is fine that
    the modification of the RDN results in adding (rather than replacing) an attribute
    value. But in other cases this is inconvenient or even illegal (because of the
    schema).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might have a record in the directory that describes a subtree
    of records that have to do with the company website. Such a record might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, say we wanted to change the RDN to point not to `www`, but to `web`. Using
    `ldapmodrdn` the way we did earlier would generate an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this error is that the schema definition for `dc` specifies that
    there can be only one `dc` attribute value per record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dc` (or `domainComponent`) attribute is defined in `core.schema`.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to use the `-r` flag for `ldapmodrdn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-r` flag causes `ldapmodrdn` to replace, rather than add, the existing
    attribute value. Now the resulting record looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There is only one `dc` attribute listed, and it has the newly set value, `web`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the Superior DN with ldapmodrdn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as we saw earlier with the `modrdn` change-type for ldapmodify, we can
    change the superior DN (the base portion of a record's DN) with `ldapmodrdn`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The Right Backend**'
  prefs: []
  type: TYPE_NORMAL
- en: Not all backends support this type of renaming. Currently, the HDB backend is
    the only storage backend to support changing the superior reference in a DN. Other
    non-storage backends (like `ldap`) may pass on these operations to the underlying
    storage mechanism, which in turn may or may not support this degree of renaming.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as with the `modrdn` change type, `ldapmodrdn` must specify a replacement
    RDN even if that RDN is the same as the current one. In other words, an RDN is
    required, even if the RDN is not a new RDN. We will see an example of this below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-s` flag for `ldapmodrdn` specifies the new superior DN. Thus, to move
    the entry `uid=barbara,ou=users,dc=example,dc=com` to the `ou=system` branch of
    the directory, we can use a command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a long command, and it is thus broken up into three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains the flags that handle binding to the directory, and
    these should be familiar by now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line begins with the `-s` flag, which takes a DN for a parameter.
    This is the flag that specifies what the new superior DN will be. In this case,
    it is `ou=system,dc=example,dc=com`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-r` flag, as we have seen before, instructs SLAPD to replace the old RDN
    with the new one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the third line is the DN for the entry we want to modify, `uid=barbar,ou=users,dc=example,dc=com`,
    and the new RDN. Since we want to keep the same RDN (but move the record to a
    new subtree), we set this last value to `uid=barbara`, which is the RDN that the
    existing record has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After we run this command we can see the results with `ldapsearch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The base portion of Barbara's new record is now `ou=system,dc=example,dc=com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the `modrdn` changetype for `ldapmodify`, changing a superior
    entry will not change any attributes in the record. Thus, even though this record
    is now in the sytem OU, it still has the attribute `ou: Users`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to construct Relative DNs that have more than one attribute
    value. For example, I can use a combination of `uid` and `l` (for location) in
    the RDN portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: In such cases, the plus sign (`+`) is used to indicate that both the attribute
    are to be considered part of the RDN.
  prefs: []
  type: TYPE_NORMAL
- en: '`ldapmodrdn` is smart enough to handle these cases. It will add (or replace)
    all of the attributes used in the RDN.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where the `-r` flag is specified, there are some things to be aware
    of. First, `ldapmodrdn` will replace all of the fields used in the new RDN. Second,
    if there is a value in the initial RDN that is removed from the RDN, then the
    attribute value will be removed from the record as well. For example, here is
    our starting record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the DN uses both the `cn` and the `l` attributes, both of which
    are present in the body of the record. Now, if we use `ldapmodrdn` with the `-r`
    flag and replace `cn=Matt Butcher+l=Chicago` with `cn=Matt Butcher`, the `l: Chicago`
    attribute will be removed from the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: So, when using `ldapmodrdn` with multi-attribute RDNs, be judicious when using
    the `-r` flag.
  prefs: []
  type: TYPE_NORMAL
- en: ldappasswd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the utilities section we looked at encrypting passwords with `slappasswd`.
    That tool was used to generate encrypted values for inclusion in LDIF files. The
    `ldappasswd` client, in contrast, connects to the server and changes a password
    value in the directory. If needed it can be used to automatically generate a password,
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `ldapadd` and `ldapmodify`, which use the LDAP v.3 standard Add and Modify
    operations, the `ldappasswd` client uses an extension operation—the **LDAP Password
    Modify Extended Operation** as defined in RFC 3062 ([http://rfc-editor.org/rfc/rfc3062.txt](http://rfc-editor.org/rfc/rfc3062.txt)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When loading passwords from an LDIF file, or from `ldapadd` or `ldapmodify`,
    if you send the server a cleartext password, the password will be stored in the
    directory in an unencrypted string. This is not safe. You should either use `slappasswd`
    to generate an encrypted password for inclusion in an LDIF, or you should use
    `ldappasswd` to set the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as the ACLs permit, a user can change her or his password with the
    `ldappasswd` client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The `-S` flag is the only new flag used here. It indicates that `ldappasswd`
    should prompt the user to enter (and re-enter) a new password. The `-W` flag,
    as you may recall, prompts the user to enter a current password interactively.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which the user enters the passwords differs from the norm. The
    user is prompted to first enter and re-enter a new password, and then to enter
    the current password.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible for an administrator (or one with write permissions to
    the `userPassword` attribute of a given record) to change a password for another
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the directory manager is changing the value of the `userPassword`
    attribute for `uid=barbara,ou=Users,dc=example,dc=com`. Rather than using `-S`
    and entering the password at an interactive prompt, the password has been specified
    on the command line: `-s secret`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The password, when changed through `ldappasswd`, is automatically encrypted
    by the server before it is stored in the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decode the `userPassword` value, it reads: `{SSHA}S1SRt5nI/pvF8kwRIUSrwNDGdqRKxNCV`.
    The password is stored in an irreversible SSHA hash.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Setting the Default Encryption Scheme**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify which encryption scheme the server should choose when encrypting
    passwords. To specify the algorithm, use the `password-hash` directive in `slapd.conf`.
    Example: `password-hash {SMD5}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `ldappasswd` can request that the server generate a strong password
    for that DN. If no flag is set that indicates, the source of the password (for
    example `-s`, `-S`, or `-T`), then `ldappasswd` requests that one be generated.
    Here is the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The server responded to this request with a generated password, `New password:
    dS9R4Kvc`, which has already been encrypted and stored in the `userPassword` attribute
    on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: ldapwhoami
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last client in the OpenLDAP suite is `ldapwhoami`. This client provides
    a client implementation of the **"Who am I?" Extended Operation**. This operation
    provides information about the DN who is currently bound to the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ldapwhoami` command simply requires enough information to authenticate
    to the directory server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this example, all this client does is reply with the DN
    of the user we connected with. This tool comes in useful when debugging SASL authentication,
    which does not require a DN to connect. We will look at SASL configuration in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have taken a closer look at the tools in the OpenLDAP suite.
    We began by looking at the SLAPD and SLURPD servers. In particular, we looked
    at the major LDAP operations, such as bind, search, add, modify, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: Next we created a basic directory information tree in an LDIF file. In doing
    this, we familiarized ourselves with LDIF—the text format for representing LDAP
    directory data.
  prefs: []
  type: TYPE_NORMAL
- en: From there we looked at the utilities and clients in the OpenLDAP suite. Along
    the way, we loaded our directory information tree from LDIF into the directory,
    and then added to and modified that data.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you should be comfortable working with the tools included in OpenLDAP.
    In the next chapter we are going to return to the SLAPD server and take a close
    look at LDAP security.
  prefs: []
  type: TYPE_NORMAL
