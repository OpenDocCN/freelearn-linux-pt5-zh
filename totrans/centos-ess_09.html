<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Introduction to CoreOS rkt"><div class="titlepage" id="aid-1GKCM2"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Introduction to CoreOS rkt</h1></div></div></div><p>In the previous chapter, we overviewed CoreUpdate, free and paid container repositories, and the hosting and enterprise registry provided by CoreOS.</p><p>In this chapter, you will learn about CoreOS's <code class="literal">rkt</code>, a container runtime for applications. We will cover the following topics in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Introduction to <code class="literal">rkt</code></li><li class="listitem">Running streamlined Docker images with <code class="literal">rkt</code></li><li class="listitem">Converting Docker images to ACI</li></ul></div><div class="section" title="An introduction to rkt"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec45"/>An introduction to rkt</h1></div></div></div><p>rkt (pronounced "rock it") is a container runtime<a id="id180" class="indexterm"/> for applications made by CoreOS and is designed for composability, speed, and security. It is an alternative to Docker and is designed to be run on servers with the most rigorous security and production environments.</p><p>rkt is a standalone tool, compared to Docker's client and central daemon version, which makes it a better alternative to Docker, as it has fewer constraints and dependencies. For example, if the <code class="literal">docker</code> central daemon crashes, all running <code class="literal">docker</code> containers will be stopped; in the case of <code class="literal">rkt</code>, however, this can affect only the particular rkt process responsible for running <code class="literal">rkt</code> containers in its pod. As each <code class="literal">rkt</code> process gets its <span class="strong"><strong>process identification number</strong></span> (<span class="strong"><strong>PID</strong></span>), if one <code class="literal">rkt</code> process dies, it will not affect any other <code class="literal">rkt</code> process.</p><div class="section" title="Features of rkt"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec33"/>Features of rkt</h2></div></div></div><p>We will overview the main <code class="literal">rkt</code> features, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It can be integrated <a id="id181" class="indexterm"/>with <code class="literal">init</code> systems, as <code class="literal">systemd</code> and <code class="literal">upstart</code></li><li class="listitem">It can be integrated with cluster orchestration tools, such as <code class="literal">fleet</code> and <code class="literal">Kubernetes</code> (which we will cover in the next chapter)</li><li class="listitem">It is compatible with other container solutions as Docker</li><li class="listitem">It has an extensible and modular<a id="id182" class="indexterm"/> architecture</li></ul></div></div><div class="section" title="The basics of App container"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec34"/>The basics of App container</h2></div></div></div><p>
<code class="literal">rkt</code> is an implementation <a id="id183" class="indexterm"/>of <span class="strong"><strong>App Container</strong></span> (<span class="strong"><strong>appc</strong></span>: <a class="ulink" href="https://github.com/appc/spec/">https://github.com/appc/spec/</a>), which is open source and defines an image format, the runtime environment, and<a id="id184" class="indexterm"/> the discovery mechanism of application containers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">rkt</code> uses images of the <span class="strong"><strong>Application Container Image</strong></span> (<span class="strong"><strong>ACI</strong></span>) format as defined by the App Container (appc) specifications (<a class="ulink" href="https://github.com/appc/spec">https://github.com/appc/spec</a>). An ACI is just a simple<a id="id185" class="indexterm"/> <code class="literal">tarball</code> bundle of different <code class="literal">rootfs</code> files and an image manifest.</li><li class="listitem">A pod (the basic unit of execution in <code class="literal">rkt</code>) is a grouping of one or more app images (ACIs), with some optionally applied additional metadata on the pod level—for example, applying some resource constraints, such as CPU usage.</li></ul></div></div><div class="section" title="Using rkt"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec35"/>Using rkt</h2></div></div></div><p>As rkt comes preinstalled with CoreOS, running ACI images with rkt is easy and it is very similar to <code class="literal">docker</code> commands. (I would love to write more on this, but rkt does not provide many options yet, as it is <a id="id186" class="indexterm"/>constantly changing and innovating, which was also the case at the time of writing this book).</p><p>As <code class="literal">rkt</code> has no running OS X client, you need to log in to your CoreOS VM host directly to run the following example commands:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to trust the remote site before we download any ACI file from there, as <code class="literal">rkt</code> verifies signatures by default:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt trust –prefix example.com/nginx</strong></span>
</pre></div></li><li class="listitem">Then we can fetch (download) an image from there:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt fetch example.com/nginx:latest</strong></span>
</pre></div></li><li class="listitem">Then running the container with <code class="literal">rkt</code> is simple:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt run example.com/nginx:v1.8.0</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>As you see, <code class="literal">rkt</code> appropriates ETags—as in our case v1.8.0 will be run.</p></div><div class="section" title="rkt networking"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec36"/>rkt networking</h2></div></div></div><p>By default <code class="literal">rkt</code> run uses the host mode for<a id="id187" class="indexterm"/> port assignments. For example, if you have <code class="literal">EXPOSE 80</code> in your Dockerfile, run this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt run example.com/nginx:v1.8.0</strong></span>
</pre></div><p>The <code class="literal">rkt</code> pod will share the network stack and interfaces with the host machine.</p><p>If you want to assign a different port/private IP address, then use <code class="literal">run</code> with these parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo rkt run --private-net --port=http:8000 example.com/nginx:v1.8.0</strong></span>
</pre></div></div><div class="section" title="rkt environment variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec37"/>rkt environment variables</h2></div></div></div><p>Environment variables can be inherited from the host using the <code class="literal">--inherit-env</code> flag. Using <code class="literal">flag --set-env</code>, we<a id="id188" class="indexterm"/> can set individual environment variables.</p><p>Okay, let's prepare a few environment variables to be inherited using these two commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export ENV_ONE=hi_from_host</strong></span>
<span class="strong"><strong>$ export ENV_TWO=CoreOS</strong></span>
</pre></div><p>Now let's use them together with <code class="literal">--set-env</code> in the command, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt run --inherit-env --set-env ENV_THREE=hi_nginx example.com/nginx:v1.8.0</strong></span>
</pre></div></div><div class="section" title="rkt volumes"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec38"/>rkt volumes</h2></div></div></div><p>For host volumes, the <code class="literal">-volume</code> flag needs to<a id="id189" class="indexterm"/> be used. Volumes need to be defined in the ACI manifest when creating the new ACI image and converting Docker images. You will get an output like this:</p><div class="mediaobject"><img src="../Images/image00176.jpeg" alt="rkt volumes"/></div><p style="clear:both; height: 1em;"> </p><p>The following command will mount the <code class="literal">host</code> directory on the <code class="literal">rkt</code> Pod:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt run –volume volume-/var/cache/nginx,kind=host,source=/some_folder/nginx_cache example.com/nginx:v1.8.0</strong></span>
</pre></div><p>Note that the <code class="literal">rkt</code> volume standard was not completed at the time of writing this book, so the previous example might not work when <code class="literal">rkt</code> reaches its final version.</p><p>Next let's see how <code class="literal">rkt</code> plays nicely with docker images.</p></div></div></div>
<div class="section" title="Running streamlined Docker images with rkt" id="aid-1HIT81"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec46"/>Running streamlined Docker images with rkt</h1></div></div></div><p>As there are thousands of docker images on the public Docker hub, <code class="literal">rkt</code> allows you to use them very easily. Alternatively, you might <a id="id190" class="indexterm"/>have some docker images and would like to run them with <code class="literal">rkt</code> too, without building new <code class="literal">rkt</code> ACI images, to see how they work with <code class="literal">rkt</code>.</p><p>Running Docker images is very<a id="id191" class="indexterm"/> much the same as it was in previous examples:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As Docker images do not support signature verification yet, we just skip the verification step and fetch one with the <code class="literal">--insecure-skip-verify</code> flag:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt --insecure-skip-verify fetch docker://nginx</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00177.jpeg" alt="Running streamlined Docker images with rkt"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">The last line shown in the preceding screenshot represents the <code class="literal">rkt</code> image ID of the converted ACI, and this can be used to <code class="literal">run</code> with <code class="literal">rkt</code> :<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt --insecure-skip-verify run sha512-13a9c5295d8c13b9ad94e37b25b2feb2</strong></span>
</pre></div></li><li class="listitem">Also we can run in this way, where the image will be downloaded and then run:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt --insecure-skip-verify run docker://nginx</strong></span>
</pre></div></li><li class="listitem">If we want to use volumes with Docker images, we run this line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo rkt --insecure-skip-verify run \</strong></span>
<span class="strong"><strong>--volume /home/core/share/nginx/html:/usr/share/nginx/html \</strong></span>
<span class="strong"><strong>docker://nginx</strong></span>
</pre></div><p>This is very similar to the <code class="literal">docker</code> command, isn't it?</p></li><li class="listitem">Okay, let's update our local development <code class="literal">nginx.service</code> to use <code class="literal">rkt</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Unit]</strong></span>
<span class="strong"><strong>Description=nginx</strong></span>
<span class="strong"><strong>[Service]</strong></span>
<span class="strong"><strong>User=root</strong></span>
<span class="strong"><strong>TimeoutStartSec=0</strong></span>
<span class="strong"><strong>EnvironmentFile=/etc/environment</strong></span>
<span class="strong"><strong>ExecStart=/usr/bin/ rkt --insecure-skip-verify run \</strong></span>
<span class="strong"><strong> -volume /home/core/share/nginx/html:/usr/share/nginx/html \</strong></span>
<span class="strong"><strong>docker://nginx</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>Restart=always</strong></span>
<span class="strong"><strong>RestartSec=10s</strong></span>
<span class="strong"><strong>[X-Fleet]</strong></span>
</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>As you see, there is no<a id="id192" class="indexterm"/> <code class="literal">ExecStop=/usr/bin/docker stop nginx</code>. It is not needed because <code class="literal">systemd</code> takes care of stopping the <code class="literal">rkt</code> instance when the <code class="literal">systemctl</code>/<code class="literal">fleetctl</code> stop is used by sending the running <code class="literal">nginx</code> process a <code class="literal">SIGTERM</code>.</p><p>Much simpler than<a id="id193" class="indexterm"/> docker, right?</p><p>In the next section, we will see how to convert a docker image into an ACI image.</p></div>
<div class="section" title="Converting Docker images into ACI" id="aid-1IHDQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec47"/>Converting Docker images into ACI</h1></div></div></div><p>With CoreOS comes another file<a id="id194" class="indexterm"/> related to <code class="literal">rkt</code>—<code class="literal">docker2aci</code>. It converts a docker image to an ACI<a id="id195" class="indexterm"/> image (an application container image used by <code class="literal">rkt</code>).</p><p>Let's convert our <code class="literal">nginx</code> image. Run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker2aci docker://nginx</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00178.jpeg" alt="Converting Docker images into ACI"/></div><p style="clear:both; height: 1em;"> </p><p>We can also save <a id="id196" class="indexterm"/>a docker image in a file and the convert it. Run the following<a id="id197" class="indexterm"/> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ docker save -o nginx.docker nginx</strong></span>
<span class="strong"><strong>$ docker2aci nginx.docker</strong></span>
</pre></div><div class="mediaobject"><img src="../Images/image00179.jpeg" alt="Converting Docker images into ACI"/></div><p style="clear:both; height: 1em;"> </p><p>Finally, you can try to use the generated<a id="id198" class="indexterm"/> ACI files by updating<a id="id199" class="indexterm"/> the preceding <code class="literal">nginx.service fleet</code> unit:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[Unit]</strong></span>
<span class="strong"><strong>Description=nginx</strong></span>
<span class="strong"><strong>[Service]</strong></span>
<span class="strong"><strong>User=root</strong></span>
<span class="strong"><strong>TimeoutStartSec=0</strong></span>
<span class="strong"><strong>EnvironmentFile=/etc/environment</strong></span>
<span class="strong"><strong>ExecStart=/usr/bin/ rkt --insecure-skip-verify run \</strong></span>
<span class="strong"><strong> --volume volume-/usr/share/nginx/html,kind=host,source=/usr/share/nginx/html \</strong></span>
<span class="strong"><strong> full_path_to/nginx-latest.aci</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>Restart=always</strong></span>
<span class="strong"><strong>RestartSec=10s</strong></span>

<span class="strong"><strong>[X-Fleet]</strong></span>
</pre></div></div>
<div class="section" title="Summary" id="aid-1JFUC1"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we overviewed the main features of CoreOS rkt, the <code class="literal">rkt</code> application container, and the image format. You also learned how to run images based on <code class="literal">aci</code> and <code class="literal">docker</code> as containers with <code class="literal">rkt</code>.</p><p>In the next chapter, you will get an introduction to Google Kubernetes, an open source orchestration system for application containers.</p></div></body></html>