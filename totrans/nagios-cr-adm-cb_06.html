<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Enabling Remote Execution</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monitoring local services on a remote machine with NRPE</li><li class="listitem" style="list-style-type: disc">Setting the listening address for NRPE</li><li class="listitem" style="list-style-type: disc">Setting allowed client hosts for NRPE</li><li class="listitem" style="list-style-type: disc">Creating new NRPE command definitions securely</li><li class="listitem" style="list-style-type: disc">Giving limited sudo privileges to NRPE</li><li class="listitem" style="list-style-type: disc">Using check_by_ssh with key authentication instead of NRPE</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Introduction</h1></div></div></div><p>For a dedicated Nagios Core server with access to all the relevant parts of the network, making checks is relatively simple using commands and plugins that make ICMP, TCP, and UDP connections to network hosts and services, in order to determine their operating state. These can be used to check any sort of network service, without requiring anything to be installed on the target machine. As an example, when the <code class="literal">check_http</code> plugin is used to check a web server, it works in the same way as if a browser was making the request.</p><p>However, monitoring a network thoroughly usually has more to it than simply checking network connectivity and availability. It's also a good idea to check properties of the network that don't directly correspond to a network service, and hence can't be directly checked over a network connection.</p><p>These are often properties of hardware or the underlying system, such as disk space or system load average, or processes that are configured only to listen locally, commonly done for database servers.</p><p>We could install Nagios Core on all of the systems, perhaps, but this would make maintenance difficult. It would be much better to have some means of remote execution of diagnostic programs, so that they are run directly on the target host to retrieve the information they need, and the results are returned to a single Nagios Core server via a dedicated network service.</p><p>There are three general approaches to managing this problem:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use <code class="literal">check_nrpe</code><a id="id314" class="indexterm"/> to run a standard Nagios Core plugin on the target machine and return its results transparently to the monitoring server.</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">check_by_ssh</code><a id="id315" class="indexterm"/> to run an arbitrary command on the target machine from the monitoring server by first connecting to it with SSH.</li><li class="listitem" style="list-style-type: disc">Use <code class="literal">check_snmp</code><a id="id316" class="indexterm"/> to check an SNMP OID that's configured to provide the return value and output of some command on the target host.</li></ul></div><p>This chapter covers the first two solutions, focusing on the more commonly used <strong>Nagios Remote Plugin Executor</strong> (<strong>NRPE</strong>), and explaining how it differs from the <code class="literal">check_by_ssh</code> solution. For some information on configuring SNMP, see the <em>Monitoring the output of an SNMP query</em> and <em>Creating an SNMP OID to monitor</em> recipes in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Monitoring local services on a remote machine with NRPE</h1></div></div></div><p>In this recipe, we'll learn how to install and run an NRPE server on a target host, <code class="literal">roma.naginet</code>. We'll use this to check the load average on that host with the <code class="literal">check_load</code> plugin.</p><p>The plugins for these checks will be executed on the <a id="id317" class="indexterm"/>
<a id="id318" class="indexterm"/>target server by the NRPE daemon, but the results will be returned to our Nagios Core monitoring server <code class="literal">olympus.naginet</code>. This requires installing the <code class="literal">check_nrpe</code> plugin on the monitoring server, and the full Nagios Plugins set (but not Nagios Core itself) on the target server.</p><p>This is a reasonably long and in-depth recipe as it involves installing a total of three software packages on two servers.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec201"/>Getting ready</h2></div></div></div><p>You will need a monitoring server with Nagios Core 3.0 or newer installed. You should also have a UNIX-like target host that you intend to monitor that can run the NRPE daemon. Most modern UNIX-like systems including Linux and BSD should be able to do this. Both the monitoring server and the target host will need internet connectivity, and you should already be monitoring the target host itself with a host definition, to which we'll be adding service checks.</p><p>If your servers don't have a direct gateway to the Internet, then you can work around this by uploading the relevant files after downloading them onto a workstation, or another machine with Internet access.</p><p>You should understand the basics of configuring, compiling, and installing software from source. In most cases, the usual <code class="literal">./configure</code>, <code class="literal">make</code>, and <code class="literal">make install</code> process will be all that's necessary, and the recipe will walk you through this. You will need to have <code class="literal">make</code> installed, along with any other tools needed for the configure and build processes, including a C compiler such as <code class="literal">gcc</code>.</p><p>You should also have a good grasp of how hosts and services interrelate in Nagios Core, which is discussed in the recipes of <a class="link" href="ch01.html" title="Chapter 1. Understanding Hosts, Services, and Contacts">Chapter 1</a>, and how Nagios Core uses commands and plugins, discussed in <a class="link" href="ch02.html" title="Chapter 2. Working with Commands and Plugins">Chapter 2</a>. You should not need an in-depth understanding of the use of any particular plugin; the recipe will demonstrate the usage of the plugins to which it refers.</p><p>Finally, you should be able to configure any firewalls to allow connectivity from the Nagios Core server to the server being monitored with TCP <a id="id319" class="indexterm"/>destination port <code class="literal">5666</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec202"/>How to do it...</h2></div></div></div><p>This first part of the recipe is done on the target server:</p><div><ol class="orderedlist arabic"><li class="listitem">Download and install the latest Nagios Plugins package. At the time of writing, the link is available at <a class="ulink" href="http://nagiosplugins.org/download/">http://nagiosplugins.org/download/</a>.<div><pre class="programlisting">
<strong>$ wget http://downloads.sourceforge.net/project/nagiosplug/nagiosplug/1.4.16/nagios-plugins-1.4.16.tar.gz</strong>
<strong>$ tar -xzf nagios-plugins-1.4.16.tar.gz</strong>
</pre></div></li><li class="listitem">Configure, compile, and install the plugins, the same way you would on a new monitoring server. You will need to have <code class="literal">root</code> privileges for the <code class="literal">make install</code> call.<div><pre class="programlisting">
<strong>$ cd nagios-plugins-1.4.16</strong>
<strong>$ ./configure</strong>
<strong>$ make</strong>
<strong># make install</strong>
</pre></div><p>You may need to install some shared libraries and headers on the system to do this for certain plugins, such as a <code class="literal">libssl</code> implementation. The output of the <code class="literal">./configure</code> script should alert you to any such problems.</p></li><li class="listitem">Download and install the latest version of NRPE from the Nagios Exchange website. At the time of writing, the link is available at <a class="ulink" href="http://exchange.nagios.org/directory/Addons/Monitoring-Agents/NRPE--2D-Nagios-Remote-Plugin-Executor/details">http://exchange.nagios.org/directory/Addons/Monitoring-Agents/NRPE--2D-Nagios-Remote-Plugin-Executor/details</a>.<div><pre class="programlisting">
<strong>$ wget http://prdownloads.sourceforge.net/sourceforge/nagios/nrpe-2.13.tar.gz</strong>
<strong>$ tar -xzf nrpe-2.13.tar.gz</strong>
</pre></div></li><li class="listitem">Enter the <code class="literal">nrpe-2.13</code> source directory, and configure, compile, and install the daemon and a stock configuration for it. <a id="id320" class="indexterm"/>You will need to have <code class="literal">root</code> privileges for both the <code class="literal">make install-daemon</code> and the <code class="literal">make install-daemon-config</code> calls:<div><pre class="programlisting">
<strong>$ cd nrpe-2.13</strong>
<strong>$ ./configure</strong>
<strong>$ make all</strong>
<strong># make install-daemon</strong>
<strong># make install-daemon-config</strong>
</pre></div><p>If you do not already have a <code class="literal">nagios</code> user on the target host, you may need to create one before the daemon will install properly:</p><div><pre class="programlisting">
<strong># groupadd nagios</strong>
<strong># useradd -r -g nagios nagios</strong>
</pre></div></li><li class="listitem">Edit the newly installed file at <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code> and find the line beginning with <code class="literal">allowed_hosts</code>. Add a comma and the IP address of your monitoring server to this line. In this case, we've added the IP address <code class="literal">10.128.0.11</code>:<div><pre class="programlisting">
<strong>allowed_hosts=127.0.0.1,10.128.0.11</strong>
</pre></div></li><li class="listitem">Start the <code class="literal">nrpe</code> daemon, and check that it is running by searching the process table with <code class="literal">pgrep</code> or <code class="literal">ps</code>:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nrpe -c /usr/local/nagios/etc/nrpe.cfg -d</strong>
<strong># pgrep nrpe</strong>
<strong>18593</strong>
<strong># ps -e | grep [n]rpe</strong>
<strong>nagios 18593 1 0 21:55 ? 00:00:01 nrpe</strong>
</pre></div></li><li class="listitem">If you would like the <code class="literal">nrpe</code> daemon to start on boot, add an <code class="literal">init</code> script appropriate to your system. An example <code class="literal">init-script</code> is generated at <code class="literal">./configure</code> time in the source directory. Versions are also generated for Debian-derived systems and SUSE systems in <code class="literal">init-script.debian</code> and <code class="literal">init-script.suse</code>. Exactly how this should be done will depend on your particular system, for which you may need to consult its documentation.</li></ol></div><p>This next part of the recipe is done on the monitoring server.</p><div><ol class="orderedlist arabic"><li class="listitem">Again, download the latest version of NRPE, <a id="id321" class="indexterm"/>the same way as done for the target server:<div><pre class="programlisting">
<strong>$ wget http://prdownloads.sourceforge.net/sourceforge/nagios/nrpe-2.13.tar.gz</strong>
<strong>$ tar -xzf nrpe-2.13.tar.gz</strong>
</pre></div></li><li class="listitem">Again, configure and build the software. However, note that this time the install line is different, as we're installing the <code class="literal">check_nrpe</code> plugin rather than the <code class="literal">nrpe</code> daemon:<div><pre class="programlisting">
<strong>$ cd nrpe-2.13.tar.gz</strong>
<strong>$ ./configure</strong>
<strong>$ make all</strong>
<strong># make install-plugin</strong>
</pre></div></li><li class="listitem">Check that the plugin is installed correctly. It should be saved at <code class="literal">/usr/local/nagios/libexec/check_nrpe</code>:<div><pre class="programlisting">
<strong>$ ls /usr/local/nagios/libexec/check_nrpe</strong>
<strong>/usr/local/nagios/libexec/check_nrpe</strong>
</pre></div></li><li class="listitem">Move to the directory containing the Nagios Core object configuration. By default, this is <code class="literal">/usr/local/nagios/etc/objects</code>:<div><pre class="programlisting">
<strong>$ cd /usr/local/nagios/etc/objects</strong>
</pre></div></li><li class="listitem">Edit an appropriate file for defining new commands. For the default installation, <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code> is a good choice. Add the following definition to the end of this file:<div><pre class="programlisting">define command {
    command_name  check_nrpe
    command_line  $USER1$/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
}</pre></div></li><li class="listitem">Edit the file defining the target host as an object. The definition might look something similar to the following code snippet:<div><pre class="programlisting">define host {
    use        linux-server
    host_name  roma.naginet
    alias      roma
    address    10.128.0.61
}</pre></div></li><li class="listitem">Beneath the definition for the host, after any other <a id="id322" class="indexterm"/>services defined for it, add the following service definition:<div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  LOAD
    check_command        check_nrpe!check_load
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, a new service with the description <code class="literal">LOAD</code> will appear in the web interface ready to be checked, and will come up with an appropriate status, including the load average as read from the <code class="literal">nrpe</code> daemon on the target host:</p><div><img src="img/5566_06_01.jpg" alt="How to do it..."/></div><p>We can see more detail about how the check was performed and its results in the details page for the service:</p><div><img src="img/5566_06_02.jpg" alt="How to do it..."/></div><p>If the load average on <code class="literal">roma.naginet</code> exceeds the limits defined <a id="id323" class="indexterm"/>for the <code class="literal">check_load</code> command in <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code> on the target host, the service will enter <code class="literal">WARNING</code> or <code class="literal">CRITICAL</code> states, and will send notifications if configured to do so, all in the same manner as a non-NRPE service.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec203"/>How it works...</h2></div></div></div><p>The NRPE plugin and daemon are used to run Nagios Core plugins on the target host, rather than on the monitoring server itself. The results of the check are then passed back to the monitoring server, and recorded and analyzed by Nagios Core the same way as if the service was running a plugin on the monitoring server, for example <code class="literal">check_http</code> or <code class="literal">check_ssh</code>.</p><p>The recipe we followed does four main things:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We installed the latest Nagios Plugins package to the target host, including the <code class="literal">check_load</code> plugin. This is necessary because the plugin is actually run on the target host and not on the monitoring server, as is the case with the plugins that check network services.</li><li class="listitem" style="list-style-type: disc">We installed the <code class="literal">nrpe</code> daemon to the target host, along with a stock configuration file <code class="literal">nrpe.cfg</code>. This is the network service through which the <code class="literal">check_nrpe</code> plugin will request commands to be run on the target host. The plugins will be run by this process, typically as the <code class="literal">nagios</code> user.</li><li class="listitem" style="list-style-type: disc">We installed the <code class="literal">check_nrpe</code> plugin<a id="id324" class="indexterm"/> to the monitoring host, and defined a command of the same name to use it. The command accepts one argument in the <code class="literal">$ARG1$</code> macro; its value is the command that should be run on the target host. In this case, we supplied <code class="literal">check_load</code> for this argument.</li><li class="listitem" style="list-style-type: disc">We set up a service to monitor the output of the standard <code class="literal">check_load</code> plugin, via <code class="literal">check_nrpe</code>.</li></ul></div><p>Like other Nagios Core plugins, the <code class="literal">check_nrpe</code> program can be run directly from the command line. If we wanted to test the response of the configuration that we arranged in the previous section, then we might run the following command:</p><div><pre class="programlisting">
<strong>$ /usr/local/nagios/libexec/check_nrpe -H roma.naginet -c check_load</strong>
<strong>OK - load average: 0.00, 0.00, 0.00|load1=0.000;15.000;30.000;0;</strong>
<strong>load5=0.000;10.000;25.000;0; load15=0.000;5.000;20.000;0;</strong>
</pre></div><p>In this case, the state of <code class="literal">OK</code> and the load average values, as retrieved by <code class="literal">check_load</code>, were returned by the <code class="literal">nrpe</code> daemon as the result of the <code class="literal">check_nrpe</code> call.</p><div><img src="img/5566OS_06_03.jpg" alt="How it works..."/></div><p>It's very important to note that this simple configuration of NRPE is not completely secure by default. The recipes listed under the <em>See also</em> <a id="id325" class="indexterm"/>section for this recipe provide some basic means to secure NRPE instances from abuse. These should be used in concert with a sensible firewall policy.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec204"/>There's more...</h2></div></div></div><p>Of course, <code class="literal">check_load</code> is not the only plugin that can be run on the target server this way. If we inspect the <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code> file <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code> on the target host, near the end of the file, we find some other example definitions of commands that <code class="literal">check_nrpe</code> will run upon requests issued from the monitoring server:</p><div><pre class="programlisting">
<strong>command[check_users]=/usr/local/nagios/libexec/check_users -w 5 -c 10</strong>
<strong>command[check_load]=/usr/local/nagios/libexec/check_load -w 15,10,5 -c 30,25,20</strong>
<strong>command[check_hda1]=/usr/local/nagios/libexec/check_disk -w 20% -c 10% -p /dev/hda1</strong>
<strong>command[check_zombie_procs]=/usr/local/nagios/libexec/check_procs -w 5 -c 10 -s Z</strong>
<strong>command[check_total_procs]=/usr/local/nagios/libexec/check_procs -w 150 -c 200</strong>
</pre></div><p>We recognize <code class="literal">check_load</code> as the second of these. Note that it already includes some thresholds for <code class="literal">WARNING</code> and <code class="literal">CRITICAL</code> alerts in its <code class="literal">-w</code> and <code class="literal">-c</code> parameters.</p><p>If we also wanted to check the number of processes on this server, we could add a service check for <code class="literal">roma.naginet</code>, defined as follows:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  PROCS
    check_command        check_nrpe!check_total_procs
}</pre></div><p>This service will generate a <code class="literal">WARNING</code> alert if the number of processes exceeds 150, and a <code class="literal">CRITICAL</code> alert if it exceeds 200. Again, the plugin is run on the target server, and not on the monitoring server.</p><p>Another useful and common application of <code class="literal">check_nrpe</code> is to make remote checks on database servers, with plugins such as <code class="literal">check_mysql</code> and <code class="literal">check_pgsql</code>, in the case where servers do not listen on network interfaces for security reasons. Instead, they listen only on <code class="literal">localhost</code> or UNIX sockets, and are hence inaccessible to the monitoring server. To work around this problem, we could add a new command definition to the end of <code class="literal">nrpe.cfg</code> on the target server as follows:</p><div><pre class="programlisting">
<strong>command[check_mysql]=/usr/local/nagios/libexec/check_mysql -u nagios -d nagios -p wGG7H233bq</strong>
</pre></div><p>A corresponding check that uses the <code class="literal">check_mysql</code> command can then be made on the monitoring server:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  MYSQL
    check_command        check_nrpe!check_mysql
}</pre></div><p>See the <em>Monitoring database services</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em>, for some detail on how to use the <code class="literal">check_mysql</code> and <code class="literal">check_pgsql</code> plugins.</p><p>NRPE is thus useful not only for making checks of system properties or hardware, but also for any plugin that needs to be run on the target host rather than the monitoring host.</p><p>Finally, it's important to note that the command <a id="id326" class="indexterm"/>definitions included in the default <code class="literal">nrpe.cfg</code> file are intended as examples; you will probably want to fine-tune the parameters for some of them, and remove the ones you don't use, along with adding your own.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec205"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Setting the listening address for NRPE</em>, <em>Setting allowed client hosts for NRPE</em>, <em>Creating new NRPE command definitions securely</em>, and <em>Giving limited sudo privileges to NRPE</em> recipes in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Monitoring database services</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Setting the listening address for NRPE</h1></div></div></div><p>In this recipe, we'll learn how to make NRPE listen on a specific IP address on a target host. This might be done on hosts with multiple interfaces in order to prevent spurious requests made to the <code class="literal">nrpe</code> daemon from untrusted interfaces, <a id="id327" class="indexterm"/>perhaps the public Internet. It could also be appropriate for configuring the daemon only to listen on a trusted VPN interface.</p><p>This setup can be particularly useful when the server has an interface into a dedicated management network to which the monitoring server also has access, preventing the <code class="literal">nrpe</code> daemon from responding to requests on other interfaces unnecessarily, and thereby closing a possible security hole.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec206"/>Getting ready</h2></div></div></div><p>You should have a target host configured for checking in a Nagios Core 3.0 or later monitoring server. The target host should be running the <code class="literal">nrpe</code> <a id="id328" class="indexterm"/>daemon, and listening on all interfaces (which we'll fix). You can verify that <code class="literal">nrpe</code> is running with <code class="literal">pgrep</code> or <code class="literal">ps</code>:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># ps -e | grep [n]rpe</strong>
<strong>nagios 29964 1 0 21:55 ? 00:00:01 nrpe</strong>
</pre></div><p>You can check whether the <code class="literal">nrpe</code> daemon is listening on all interfaces by checking the output of <code class="literal">netstat</code>:</p><div><pre class="programlisting">
<strong># netstat -plnt | grep nrpe</strong>
<strong>tcp 0 0 0.0.0.0:5666 0.0.0.0:* LISTEN 29964/nrpe</strong>
</pre></div><p>The address of <code class="literal">0.0.0.0</code> shows that <code class="literal">nrpe</code> is listening on all interfaces, which is what we'd like to correct.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec207"/>How to do it...</h2></div></div></div><p>We can configure the <code class="literal">nrpe</code> daemon only to listen on one address as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">nrpe</code> daemon's configuration file. The default location is <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>. Look for the line beginning with <code class="literal">server_address</code>, which is normally commented out by default:<div><pre class="programlisting">
<strong>#server_address=127.0.0.1</strong>
</pre></div><p>If you don't have such a line, then you can add it at the end of the file.</p></li><li class="listitem">Uncomment the line if it's commented by removing the leading <code class="literal">#</code> character, and change the <code class="literal">127.0.0.1</code> address to the address to which you want to restrict the <code class="literal">nrpe</code> process listening:<div><pre class="programlisting">
<strong>server_address=10.128.0.61</strong>
</pre></div></li><li class="listitem">Restart the <code class="literal">nrpe</code> daemon<a id="id329" class="indexterm"/>. If you have installed an <code class="literal">init</code> script for it, you may be able to do this with the following:<div><pre class="programlisting">
<strong># /etc/init.d/nrpe restart</strong>
</pre></div><p>If not, you can restart the process by sending it a <code class="literal">HUP</code> signal with the <code class="literal">kill</code> command<a id="id330" class="indexterm"/>, which will prompt it to re-read its configuration file and resume running:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># kill -HUP 29964</strong>
</pre></div></li></ol></div><p>With this done, the <code class="literal">nrpe</code> daemon should now only be listening on the specified address. We can verify this using <code class="literal">netstat</code>:</p><div><pre class="programlisting">
<strong># netstat -plnt | grep nrpe</strong>
<strong>tcp 0 0 10.128.0.61:5666 0.0.0.0:* LISTEN 29964/nrpe</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec208"/>How it works...</h2></div></div></div><p>The configuration we adjusted in the preceding section <a id="id331" class="indexterm"/>defines an address on which the <code class="literal">nrpe</code> daemon should listen, and implies that it should not respond to requests on any others.</p><p>Because the <code class="literal">nrpe</code> server is explicitly designed to run commands at the request of remote servers, it's very important to take steps like these wherever appropriate to prevent attackers from exploiting the service.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec209"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring local services on a remote machine with NRPE</em> recipe in this chapter.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Setting allowed client hosts for NRPE</h1></div></div></div><p>In this recipe, we'll learn how to configure the NRPE daemon to answer requests from a particular IP address, typically the designated Nagios Core server or servers monitoring your network. This means that <code class="literal">nrpe</code> will not run plugins or <a id="id332" class="indexterm"/>return results for any <code class="literal">check_nrpe</code> request made from IP addresses not in this list.</p><p>This is an elementary security step in running an NRPE server. This should be done in concert with a hardware or software firewall and security policy. If your target host has interfaces or routes into untrusted networks, there is a risk of attackers making spurious requests for information about the system, clogging up your disk with logs from excessive check requests, or even possibly exploiting the <code class="literal">nrpe</code> daemon or the Nagios Plugins.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec210"/>Getting ready</h2></div></div></div><p>You should have a target host configured for checking in a Nagios Core 3.0 or later monitoring server. The target host should be running the <code class="literal">nrpe</code> daemon. You can verify that <code class="literal">nrpe</code> is running with <code class="literal">pgrep</code> or <code class="literal">ps</code>:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># ps -e | grep [n]rpe</strong>
<strong>nagios 29964 1 0 21:55 ? 00:00:01 nrpe</strong>
</pre></div><p>We can verify that the target host is not configured to respond to a particular IP address by attempting to open a <code class="literal">telnet</code> or <code class="literal">netcat</code> connection to it. If we are not one of the allowed hosts, <code class="literal">nrpe</code> will close the session immediately without waiting for any input:</p><div><pre class="programlisting">
<strong>$ telnet roma.naginet 5666</strong>
<strong>Trying 10.128.0.61...</strong>
<strong>Connected to 10.128.0.61.</strong>
<strong>Escape character is '^]'.</strong>
<strong>Connection closed by foreign host.</strong>
</pre></div><p>This assumes that NRPE is listening on its default port number <code class="literal">5666</code>. In this example, we'll add the IP address <code class="literal">10.128.0.12</code> to the list of hosts allowed to request information from NRPE.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec211"/>How to do it...</h2></div></div></div><p>We can configure the <code class="literal">nrpe</code> daemon to respond to a new <a id="id333" class="indexterm"/>address as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">nrpe</code> daemon's configuration file. The default location is <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>. Look for the line beginning with <code class="literal">allowed_hosts</code>. It may look similar to the following code snippet:<div><pre class="programlisting">
<strong>allowed_hosts=127.0.0.1,10.128.0.11</strong>
</pre></div></li><li class="listitem">Add or remove IP addresses from the line, separating them with commas. For this example, we're adding one more address:<div><pre class="programlisting">
<strong>allowed_hosts=127.0.0.1,10.128.0.11,10.128.0.12</strong>
</pre></div></li><li class="listitem">Restart the <code class="literal">nrpe</code> daemon. If you have installed an <code class="literal">init</code> script for it, you may be able to this with something similar to the following:<div><pre class="programlisting">
<strong># /etc/init.d/nrpe restart</strong>
</pre></div><p>If not, you can restart the process by sending it a <code class="literal">HUP</code> signal with the <code class="literal">kill</code> command, which will prompt it to re-read its configuration file and resume running:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># kill -HUP 29964</strong>
</pre></div></li></ol></div><p>With this done, the <code class="literal">nrpe</code> daemon should now respond only to the nominated hosts making <code class="literal">check_nrpe</code> requests<a id="id334" class="indexterm"/>, immediately closing the connection otherwise. We can verify whether our new host is allowed to talk to the <code class="literal">nrpe</code> service on <code class="literal">roma.naginet</code> with another <code class="literal">telnet</code> test:</p><div><pre class="programlisting">
<strong>$ telnet roma.naginet 5666</strong>
</pre></div><p>Note that the <code class="literal">nrpe</code> daemon is now waiting for input, rather than closing the connection immediately as it was doing before. This implies that we can now run <code class="literal">check_nrpe</code> checks from <code class="literal">10.128.0.12</code>, if we need to.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec212"/>How it works...</h2></div></div></div><p>The configuration we adjusted above defines a set of <a id="id335" class="indexterm"/>addresses to which the <code class="literal">nrpe</code> daemon should respond if a request is made, and implies that it should refuse to answer requests made by any other address.</p><p>The <code class="literal">nrpe</code> daemon inspects the IP address of incoming connections, and if the <code class="literal">allowed_hosts</code> directive is defined, checks that the address features in that list. If it does not, it closes the connection and refuses to run any plugins, much less return any output from them.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec213"/>There's more...</h2></div></div></div><p>The <code class="literal">allowed_hosts</code> directive<a id="id336" class="indexterm"/> is actually optional; if we wished, we could set the <code class="literal">nrpe</code> server up to respond to requests from any IP address. The default installation and example configuration, however, enables it by default, allowing both requests from the localhost IP <code class="literal">127.0.0.1</code>, and any network addresses the host had at the time <code class="literal">./configure</code> was run.</p><p>This is a sensible policy because Nagios Core plugins are designed by third parties in an open source community, for monitoring purposes in trusted networks, and may not necessarily be very secure. A plugin doesn't actually have to have a security hole to cause such problems; if the check it makes is very resource-intensive, for example opening a lot of TCP connections or querying a large database, an attacker could cause problems on the target host, if allowed, simply by making a large number of <a id="id337" class="indexterm"/>such <code class="literal">check_nrpe</code> request<a id="id338" class="indexterm"/>s in a short period of time.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec214"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring local services on a remote machine with NRPE</em> recipe in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Creating new NRPE command definitions securely</h1></div></div></div><p>In this recipe, we'll learn how to securely create new command definitions for <code class="literal">nrpe</code> to run upon request by a monitoring server. We need to do this because even if we have a huge set of plugins installed on our target host <a id="id339" class="indexterm"/>running <code class="literal">nrpe</code>, the daemon will only run commands defined in its configuration file.</p><p>We'll also learn how arguments can be passed to these commands if strictly necessary, and about the potentially negative security consequences of this.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec215"/>Getting ready</h2></div></div></div><p>You should have a target host configured for checking in a Nagios Core 3.0 or later monitoring server. The target host should be running the <code class="literal">nrpe</code> daemon. You can verify that <code class="literal">nrpe</code> is running with <code class="literal">pgrep</code> or <code class="literal">ps</code>:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># ps -e | grep [n]rpe</strong>
<strong>nagios 29964 1 0 21:55 ? 00:00:01 nrpe</strong>
</pre></div><p>We can inspect the list of commands that <code class="literal">nrpe</code> is already configured to run by looking for <code class="literal">command</code> directives in its configuration file. By default, this file is <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>, and the default command definitions are near the end of the file:</p><div><pre class="programlisting">
<strong>command[check_users]=/usr/local/nagios/libexec/check_users -w 5 -c 10</strong>
<strong>command[check_load]=/usr/local/nagios/libexec/check_load -w 15,10,5 -c 30,25,20</strong>
<strong>command[check_hda1]=/usr/local/nagios/libexec/check_disk -w 20% -c 10% -p /dev/hda1</strong>
<strong>command[check_zombie_procs]=/usr/local/nagios/libexec/check_procs -w 5 -c 10 -s Z</strong>
<strong>command[check_total_procs]=/usr/local/nagios/libexec/check_procs -w 150 -c 200</strong>
</pre></div><p>We'll add another command to this set to check whether the swap space available is above a specific threshold, using the standard Nagios Core plugin <code class="literal">check_swap</code>. We can test whether it is working first by running it on the target host:</p><div><pre class="programlisting">
<strong>$ /usr/local/nagios/libexec/check_swap -w 10% -c 5%</strong>
<strong>SWAP OK - 100% free (216 MB out of 217 MB) |swap=216MB;21;10;0;217</strong>
</pre></div><p>For completeness, we'll also show how to define a service check using this new plugin on the Nagios Core monitoring server.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec216"/>How to do it...</h2></div></div></div><p>We can add a new command definition to an <code class="literal">nrpe</code> <a id="id340" class="indexterm"/>configuration as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">nrpe</code> daemon's configuration file. The default location is <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>. Look for lines beginning with <code class="literal">command</code>, which are near the end of the file by default.</li><li class="listitem">Add the following line to the end of the file:<div><pre class="programlisting">
<strong>command[check_swap]=/usr/local/nagios/libexec/check_swap -w 10% -c 5%</strong>
</pre></div></li><li class="listitem">Restart the <code class="literal">nrpe</code> daemon. If you have installed an <code class="literal">init</code> script for it, you may be able to do this with something similar to the following command:<div><pre class="programlisting">
<strong># /etc/init.d/nrpe restart</strong>
</pre></div><p>If not, you can restart the process by sending it a <code class="literal">HUP</code> signal with the <code class="literal">kill</code> command, which will prompt it to re-read its configuration file and resume running:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># kill -HUP 29964</strong>
</pre></div></li></ol></div><p>With this done, assuming that our monitoring server is part of the <code class="literal">allowed_hosts</code> directive and can contact the target host, a call to <code class="literal">check_nrpe</code> on the monitoring host should return the status and output of the <code class="literal">check_swap</code> plugin<a id="id341" class="indexterm"/> on the target host:</p><div><pre class="programlisting">
<strong>$ /usr/local/nagios/libexec/check_nrpe -H roma.naginet -c check_swap</strong>
<strong>SWAP OK - 100% free (216 MB out of 217 MB) |swap=216MB;21;10;0;217</strong>
</pre></div><p>In turn, this allows us to use the check in a service definition on the monitoring server, with a <code class="literal">check_nrpe</code> command<a id="id342" class="indexterm"/>:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  SWAP
    check_command        check_nrpe!check_swap
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec217"/>How it works...</h2></div></div></div><p>The configuration added in the preceding section defines a new command in <code class="literal">nrpe.cfg</code> called <code class="literal">check_swap</code>. The definition of new <a id="id343" class="indexterm"/>commands in <code class="literal">nrpe.cfg</code> takes the following general form:</p><div><pre class="programlisting">
<strong>command[command_name] = command_line</strong>
</pre></div><p>We defined a command <code class="literal">check_swap</code> for NRPE. It doesn't accept any arguments, where the actual <code class="literal">check_swap</code> plugin requires them; instead, the arguments are hard-coded into the command definition, with the two options <code class="literal">-w 10%</code> and <code class="literal">-c 5%</code> setting the thresholds for free swap space.</p><p>Besides checking system properties, such as the load average or the swap space, which might not otherwise be directly retrievable except via systems such as SNMP, another common use for NRPE is to report on the state of network services that only listen locally, or are otherwise unreachable by the monitoring host. Database server monitoring is a good example. We could define the following command in <code class="literal">nrpe.cfg</code>:</p><div><pre class="programlisting">
<strong>command[check_mysql] = /usr/local/nagios/libexec/check_mysql -u nagios -d nagios -p NFmxenQ5</strong>
</pre></div><p>Assuming that the <code class="literal">check_mysql</code> plugin is installed on this target host, which it ought to be if the MySQL client library and headers were available at compile time, this command would then enable this check to be run from the monitoring host:</p><div><pre class="programlisting">
<strong>$ /usr/local/nagios/libexec/check_nrpe -H roma.naginet -c check_mysql</strong>
<strong>Uptime: 420865  Threads: 1  Questions: 172  Slow queries: 0  Opens: 99</strong>
<strong>Flush tables: 1  Open tables: 23  Queries per second avg: 0.0</strong>
</pre></div><p>This can be configured as a service check using an appropriate command definition for <code class="literal">check_nrpe</code> as follows:</p><div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  MYSQL
    check_command        check_nrpe!check_mysql
}</pre></div><p>Thus we're able to get the status of the MySQL server on the remote host <code class="literal">roma.naginet</code> without actually connecting directly to the MySQL server itself; we arrange for the NRPE service on the target host to do it on the monitoring server's behalf.</p><p>This is not just useful for network services running on the target host. It can be used to delegate any kind of check that a remote host can perform where the monitoring server cannot. Using NRPE is thus also a way to work around <a id="id344" class="indexterm"/>the addressability problems of NAT, because a service running on an address such as <code class="literal">192.168.1.1</code> would not be addressable from outside the network. If NRPE were running on the NAT gateway, we could use that to address the appropriate systems by their local addresses.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec218"/>There's more...</h2></div></div></div><p>Also, near the bottom of <code class="literal">nrpe.cfg</code>, you'll find some information on providing arguments to NRPE commands as part of the <code class="literal">check_nrpe</code> request, as opposed to hard-coding them. The comment included in the file makes it quite clear that this carries some risks:</p><div><blockquote class="blockquote"><p>The following examples allow user-supplied arguments and can only be used if the NRPE daemon was compiled with support for command arguments AND the dont_blame_nrpe directive in this config file is set to '1'. This poses a potential security risk, so make sure you read the SECURITY file before doing this.</p></blockquote></div><p>It's important to understand that, when running NRPE on a target host, you are running a service that is designed to allow network machines to run commands on the target machine with no strong authentication, which is why keeping NRPE secure is so important. If you allow passing arguments to commands, you need to be aware of the full ramifications and risks of doing so, and the recommended <code class="literal">SECURITY</code> file explains these well.</p><p>If you really want to use it, it requires reconfiguring and recompiling the <code class="literal">nrpe</code> daemon with the <code class="literal">--enable-command-args</code> switch:</p><div><pre class="programlisting">
<strong>$ ./configure --enable-command-args</strong>
<strong>$ make all</strong>
<strong># make install-daemon</strong>
</pre></div><p>Then set the <code class="literal">dont_blame_nrpe</code> in <code class="literal">nrpe.cfg</code> parameter<a id="id345" class="indexterm"/> to <code class="literal">1</code>, where it otherwise defaults to <code class="literal">0</code>:</p><div><pre class="programlisting">dont_blame_nrpe=1</pre></div><p>After restarting <code class="literal">nrpe</code> (if you have rebuilt it, you will need to restart it completely this time, and not simply send the process a <code class="literal">HUP</code> signal), this allows us to use command definitions similar to the following:</p><div><pre class="programlisting">
<strong>command[check_mysql_args]=/usr/local/nagios/libexec/check_mysql -H localhost -u $ARG1$ -d $ARG2$ -p $ARG3$</strong>
</pre></div><p>This command in turn allows checks from the monitoring servers like this, using the <code class="literal">-a</code> option of <code class="literal">check_nrpe</code>:</p><div><pre class="programlisting">
<strong># /usr/local/nagios/libexec/check_nrpe -H roma.naginet -c check_mysql_args -a nagios nagios NFmxenQ5</strong>
</pre></div><p>Because of the security concerns, I would <a id="id346" class="indexterm"/>recommend you avoid using command arguments if at all possible. If you do absolutely need to use them, it's also important to make sure that the traffic is encrypted, especially if it contains usernames and passwords. Advice on how to manage this is included in the <code class="literal">SECURITY</code> document for the <code class="literal">nrpe</code> daemon.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec219"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring local services on a remote machine with NRPE</em> and <em>Giving limited sudo privileges to NRPE</em> recipes in this chapter </li><li class="listitem" style="list-style-type: disc">The <em>Monitoring database services</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Giving limited sudo privileges to NRPE</h1></div></div></div><p>In this recipe, we'll learn how to deal with the difficulty of <a id="id347" class="indexterm"/>execution permissions for NRPE. The majority of the standard Nagios plugins don't require special privileges to run, although this depends on how stringent your system's <a id="id348" class="indexterm"/>security restrictions are. However, some of the plugins require being run as <code class="literal">root</code>, or perhaps as a user other than <code class="literal">nrpe</code>. This is sometimes the case with plugins that need to make requests of system-level resources, such as checking the integrity of <code class="literal">RAID</code> arrays.</p><p>There are four general approaches to fixing this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Bad</strong>: One method is to change the plugins to <code class="literal">setuid</code>, meaning that they will always be run as the user who owns them, no matter who executes them. The problem with this is that setting this bit allows anyone to run the program as <code class="literal">root</code>, not just <code class="literal">nrpe</code>, a very common vector for exploits.</li><li class="listitem" style="list-style-type: disc"><strong>Worse</strong>: Another method is to run <code class="literal">nrpe</code> as <code class="literal">root</code>, or as the appropriate user. This is done by changing the <code class="literal">nrpe_user</code> and <code class="literal">nrpe_group</code> properties in <code class="literal">nrpe.cfg</code>. This is even more dangerous, and completely inconsistent with the principle of least privilege; we should confer a user as little permission as possible to allow it to do its job. Never do this!</li><li class="listitem" style="list-style-type: disc"><strong>Better</strong>: A third method is to use <code class="literal">command_prefix</code> in <code class="literal">nrpe.cfg</code> to prepend <code class="literal">/usr/bin/sudo</code> to all commands, and gives <code class="literal">nrpe</code> full <code class="literal">sudo</code> privileges to run only the plugins in <code class="literal">/usr/local/nagios/libexec</code>. This is a bit better, but still quite risky as we probably don't need every single command to be run as <code class="literal">root</code>, only one or two.</li><li class="listitem" style="list-style-type: disc"><strong>Best</strong>: The best method is to use <code class="literal">sudo</code> to <a id="id349" class="indexterm"/>assign the <code class="literal">nrpe</code> user limited privileges for a subset of commands, only the ones it needs to run, and only as the user by which it needs to be run.</li></ul></div><p>The last solution is the most likely to be secure, so we'll <a id="id350" class="indexterm"/>examine an example here. We'll run the <code class="literal">check_procs</code> plugin as <code class="literal">root</code>, to get a process count. In most cases, you wouldn't need <code class="literal">root</code> privileges to get a complete count of all processes, but it might be needed on a system with a very locked-down <code class="literal">grsecurity</code> patch installed.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec220"/>Getting ready</h2></div></div></div><p>You should have a target host configured for checking in a Nagios Core 3.0 or later monitoring server. The target host should be running the <code class="literal">nrpe</code> daemon, and listening on all interfaces. You can verify that <code class="literal">nrpe</code> is running with <code class="literal">pgrep</code> or <code class="literal">ps</code>:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># ps -e | grep [n]rpe</strong>
<strong>nagios 29964 1 0 21:55 ? 00:00:01 nrpe</strong>
</pre></div><p>You should also have <code class="literal">sudo</code> installed and working on the target system, and understand what it does. We'll be editing the <code class="literal">/etc/sudoers</code> file to confer <code class="literal">root</code> privileges to our <code class="literal">nrpe</code> user, for one program only. This recipe will assume that the <code class="literal">nrpe</code> daemon is running as the <code class="literal">nagios</code> user in the <code class="literal">nagios</code> group.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec221"/>How to do it...</h2></div></div></div><p>We can confer limited <code class="literal">root</code> privileges for one <a id="id351" class="indexterm"/>command to our <code class="literal">nrpe</code> user as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">/etc/sudoers</code> file. The safest way to do this is generally with a call to <code class="literal">visudo</code>, which will make a temporary copy of the file and verify its syntax is correct before installing it:<div><pre class="programlisting">
<strong># visudo</strong>
</pre></div></li><li class="listitem">Add the following line to the file, and save it:<div><pre class="programlisting">nagios ALL=(ALL) NOPASSWD: /usr/local/nagios/libexec/check_procs</pre></div><p>Note that if the <code class="literal">requiretty</code> directive appears anywhere in your <code class="literal">/etc/sudoers</code> file, you may need to remove it to make this work.</p></li><li class="listitem">Become the <code class="literal">nagios</code> user with <code class="literal">sudo</code>, and test whether running the command runs as <code class="literal">root</code>, with no password prompt:<div><pre class="programlisting">
<strong># sudo -s -u nagios</strong>
<strong>$ sudo /usr/local/nagios/libexec/check_procs</strong>
<strong>PROCS OK: 89 processes</strong>
</pre></div></li><li class="listitem">Edit the <code class="literal">nrpe</code> daemon's configuration file. <a id="id352" class="indexterm"/>The default location is <code class="literal">/usr/local/nagios/etc/nrpe.cfg</code>. Look for the command definition for <code class="literal">check_total_procs</code>, and if there isn't one, create it. Note that <code class="literal">/usr/bin/sudo</code> has been added to the start of the command:<div><pre class="programlisting">
<strong>command[check_total_procs]=/usr/bin/sudo /usr/local/nagios/libexec/check_procs -w 150 -c 200</strong>
</pre></div></li><li class="listitem">Restart the <code class="literal">nrpe</code> daemon. If you have installed an <code class="literal">init</code> script for it, you may be able to do this with something similar to the following:<div><pre class="programlisting">
<strong># /etc/init.d/nrpe restart</strong>
</pre></div><p>If not, you can restart the process by sending it a <code class="literal">HUP</code> signal with the <code class="literal">kill</code> command, which will prompt it to re-read its configuration file and resume running:</p><div><pre class="programlisting">
<strong># pgrep nrpe</strong>
<strong>29964</strong>
<strong># kill -HUP 29964</strong>
</pre></div></li></ol></div><p>With this done, we should now be able to run a <code class="literal">check_nrpe</code> call from the monitoring server, and get a successful response:</p><div><pre class="programlisting">
<strong>$ /usr/local/nagios/libexec/check_nrpe -H roma.naginet -c check_total_procs</strong>
<strong>PROCS OK: 89 processes</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec222"/>How it works...</h2></div></div></div><p>The preceding configuration does not change the behavior of <code class="literal">nrpe</code> very much; most of the configuration is actually done on its host system. All we changed was the command definition for <code class="literal">check_total_procs</code> to run it from within <code class="literal">sudo</code>.</p><p>To make this work without a password, we defined it in the <code class="literal">/etc/sudoers</code> file so that no password was required to execute this particular program as <code class="literal">root</code> for the <code class="literal">nagios</code> user. Because <code class="literal">nrpe</code> runs as the <code class="literal">nagios</code> user, it is therefore able to use <code class="literal">sudo</code> with no password for this command only.</p><p>This means that when we call the <code class="literal">check_total_procs</code> command<a id="id353" class="indexterm"/> from the monitoring server, it returns us the full output of the plugin as it was run with <code class="literal">root</code> privileges, but the <code class="literal">nagios</code> user doesn't have <code class="literal">root</code> privileges to run anything <a id="id354" class="indexterm"/>else potentially dangerous, such as <code class="literal">rm</code> or <code class="literal">halt</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec223"/>There's more...</h2></div></div></div><p>While this is a much more secure way of allowing privileges as another user for <code class="literal">nrpe</code>, it still requires trusting that the plugin that is being run with <code class="literal">root</code> privileges is secure and can't easily be exploited. Be very careful before running this with custom code or with stray plugins you find on the Web!</p><p>If you intend to allow the <code class="literal">nagios</code> user to run more than a couple of distinct programs, it may look a little tidier to define them in<code class="literal"> /etc/sudoers</code> with <code class="literal">Cmnd_Alias</code>:</p><div><pre class="programlisting">Cmnd_Alias NAGIOS = /usr/local/nagios/libexec/check_procs, /usr/local/nagios/libexec/check_load
nagios ALL=(ALL) NOPASSWD: NAGIOS</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec224"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring local services on a remote machine with NRPE</em> and <em>Using check_by_ssh with key authentication instead of NRPE</em> recipes in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Using check_by_ssh with key authentication instead of NRPE</h1></div></div></div><p>While all of the previous recipes in this chapter show that NRPE can be very effectively tied down and secured, it may be that we require some means of authentication to a target host in order to run the appropriate Nagios plugins on it. The <code class="literal">nrpe</code> daemon does not require any authentication to return information about the host's state; as long as the IP addresses all match, and the command is defined for running, it will return information.</p><p>If you already use SSH keys for a public key infrastructure in your network, then you may find it preferable to use the <a id="id355" class="indexterm"/>
<code class="literal">check_by_ssh</code> plugin instead, which allows you to use public keys to authenticate with a target host before running any commands. This is only suitable if the target host runs an <code class="literal">ssh</code> daemon.</p><p>In this recipe, we'll repeat the setup for the <code class="literal">check_load</code> plugin<a id="id356" class="indexterm"/> as done in the first recipe in this chapter, <em>Monitoring local services on a remote machine with NRPE</em>, but we'll use the <code class="literal">check_by_ssh</code> plugin instead.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec225"/>Getting ready</h2></div></div></div><p>You should have a Nagios Core 3.0 or newer server ready, with the <code class="literal">ssh</code> client software installed, and a target host running <code class="literal">sshd</code>. The OpenSSH implementations should work fine.</p><p>The target host should have all of the Nagios Plugins installed; in this case, we're using <code class="literal">check_load</code>.</p><p>You should be familiar with public key authentication and its advantages and disadvantages. Wikipedia has an excellent article about public key cryptography and authentication at <a class="ulink" href="http://en.wikipedia.org/wiki/Public-key_cryptography">http://en.wikipedia.org/wiki/Public-key_cryptography</a>.</p><p>There is a popular introduction to SSH authentication with a key infrastructure at <a class="ulink" href="http://support.suso.com/supki/SSH_Tutorial_for_Linux">http://support.suso.com/supki/SSH_Tutorial_for_Linux</a>.</p><p>We will be running through a sensible key infrastructure setup, but it would pay to have an understanding of how it works in case this setup does not suit your configuration.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec226"/>How to do it...</h2></div></div></div><p>We can arrange to get the output of <code class="literal">check_load</code> from our remote host by way of <code class="literal">check_by_ssh</code> as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">On the monitoring server, decide on a location for the private and public keys for the <code class="literal">nagios</code> user. I recommend placing them in <code class="literal">/usr/local/nagios/keys</code>. Create this directory and make it owned by the <code class="literal">nagios</code> user, and only readable by that user:<div><pre class="programlisting">
<strong># KEYSDIR=/usr/local/nagios/keys</strong>
<strong># mkdir -p $KEYSDIR</strong>
<strong># chown nagios.nagios $KEYSDIR</strong>
<strong># chmod 0700 $KEYSDIR</strong>
</pre></div></li><li class="listitem">Become the <code class="literal">nagios</code> user using <code class="literal">su</code> or <code class="literal">sudo</code>:<div><pre class="programlisting">
<strong># su nagios</strong>
<strong># sudo -s -u nagios</strong>
</pre></div></li><li class="listitem">Generate a pair of private and public SSH keys using <code class="literal">ssh-keygen</code>. Here we've used 2048-bit RSA; use whichever key length and cipher is appropriate for your network setup.<div><pre class="programlisting">
<strong>$ ssh-keygen -b 2048 -t rsa -f /usr/local/nagios/keys/id_rsa</strong>
</pre></div><p>When prompted for a passphrase, simply press <em>Enter</em> to signal that you don't want one.</p><p>This should create two files in <code class="literal">/usr/local/nagios/keys</code>, called <code class="literal">id_rsa</code> and <code class="literal">id_rsa.pub</code>. The first one is the <strong>private key</strong>, and should be kept secret at all times. The second, the <strong>public key</strong>, is safe to distribute and to install on other machines.</p></li><li class="listitem">Decide on a location for the <code class="literal">authorized_keys</code> file on the target host. The easiest way to do this is probably to specify a <code class="literal">$HOME</code> directory for the <code class="literal">nagios</code> user, and to create it if appropriate:<div><pre class="programlisting">
<strong># NAGIOSHOME=/home/nagios</strong>
<strong># usermod -d $NAGIOSHOME nagios</strong>
<strong># mkdir -p $NAGIOSHOME/.ssh</strong>
<strong># chown -R nagios.nagios $NAGIOSHOME</strong>
<strong># chmod 0700 $NAGIOSHOME/.ssh</strong>
</pre></div></li><li class="listitem">Copy the <code class="literal">/usr/local/nagios/keys/id_rsa.pub</code> file from the monitoring server to <code class="literal">/home/nagios/.ssh/authorized_keys</code> on the target machine. The best way to do this varies. One possible method is to use <code class="literal">scp</code>:<div><pre class="programlisting">
<strong>$ whoami</strong>
<strong>nagios</strong>
<strong>$ scp /usr/local/nagios/keys/id_rsa.pub roma.naginet:.ssh/authorized_keys</strong>
</pre></div><p>You may have to set a password temporarily for the <code class="literal">nagios</code> user on the target host to do this:</p><div><pre class="programlisting">
<strong># passwd nagios</strong>
<strong>Enter new UNIX password:</strong>
<strong>Retype new UNIX password:</strong>
<strong>passwd: password updated successfully.</strong>
</pre></div></li><li class="listitem">Check that you can now log in from the monitoring server to the target server as the <code class="literal">nagios</code> user with no password:<div><pre class="programlisting">
<strong>$ whoami</strong>
<strong>nagios</strong>
<strong>$ ssh -i /usr/local/nagios/keys/id_rsa roma.naginet</strong>
<strong>Linux roma 2.6.32-5-686 #1 SMP Mon Oct 3 04:15:24 UTC 2011 i686</strong>
<strong>Lost login: Sun Jul 29 18:23:14 2012 from olympus.naginet</strong>
</pre></div></li><li class="listitem">Back on the monitoring server, check that you're able to run the <code class="literal">check_by_ssh</code> plugin to call one of the installed plugins on the remote server; in this example, we're calling <code class="literal">check_load</code>:<div><pre class="programlisting">
<strong>$ whoami</strong>
<strong>nagios</strong>
<strong>$ /usr/local/nagios/libexec/check_by_ssh \</strong>
<strong>    -H roma.naginet \</strong>
<strong>    -i /usr/local/nagios/keys/id_rsa \</strong>
<strong>    -C '/usr/local/nagios/libexec/check_load -w 15,10,5 -c 30,24,20'</strong>
<strong>OK - load average: 0.00, 0.00, 0.00|load1=0.000;15.000;30.000;0;</strong>
<strong>load5=0.000;10.000;24.000;0; load15=0.000;5.000;20.000;0;</strong>
</pre></div><p>Note that the value for the <code class="literal">-C</code> option needs to be surrounded with quotes.</p></li><li class="listitem">Now that we've verified that <code class="literal">check_by_ssh</code> works with our infrastructure, we can define a command to use it in <code class="literal">/usr/local/nagios/etc/objects/commands.cfg</code>:<div><pre class="programlisting">define command {
    command_name  check_by_ssh
    command_line  $USER1$/check_by_ssh -H $HOSTADDRESS$ -i /usr/local/nagios/keys/id_rsa -C '$ARG1$'
}</pre></div></li><li class="listitem">We can apply that command to a new service check for <code class="literal">roma.naginet</code> as follows, preferably placed beneath the host definition:<div><pre class="programlisting">define service {
    use                  generic-service
    host_name            roma.naginet
    service_description  LOAD_BY_SSH
    check_command        check_by_ssh!/usr/local/nagios/libexec/check_load -w 15,10,5 -c 30,25,20
}</pre></div></li><li class="listitem">Validate the configuration and restart the Nagios Core server:<div><pre class="programlisting">
<strong># /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg</strong>
<strong># /etc/init.d/nagios restart</strong>
</pre></div></li></ol></div><p>With this done, a new service with the description <code class="literal">LOAD_BY_SSH</code> should appear in the web interface ready to be checked, and will come up with an appropriate status, including the load average as read via <code class="literal">SSH</code> to the target host. To Nagios Core, the results of the check are just the same as if they'd come via NRPE.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec227"/>How it works...</h2></div></div></div><p>Checking services via NRPE and SSH is actually a reasonably similar process; the central idea is that we're using another network service shared by the monitoring server and the target host to instruct the target host to run a plugin, and return the results to the monitoring server.</p><p>In the case of <code class="literal">check_by_ssh</code>, this is done over an SSH connection. It's quite typical for administrators to run commands on remote hosts using the <code class="literal">ssh</code> client, simply by adding the command to be run to the command line:</p><div><pre class="programlisting">
<strong>$ hostname</strong>
<strong>olympus.naginet</strong>
<strong>$ ssh roma.naginet hostname</strong>
<strong>roma.naginet</strong>
</pre></div><p>All that the <code class="literal">check_by_ssh</code> plugi<a id="id357" class="indexterm"/>n does is formalizes this process into a Nagios plugin context. The value for the <code class="literal">command_line</code> directive<a id="id358" class="indexterm"/> for the command we defined can be broken down as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$USER1$/check_by_ssh</code>: This is the path to the plugin, as is typical in command definitions, using the <code class="literal">$USER1$</code> macro to expand to <code class="literal">/usr/local/nagios/libexec</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-H $HOSTADDRESS$</code>: This specifies that the plugin should connect to the applicable host for any host or service that uses this command.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-i /usr/local/nagios/keys/id_rsa</code>: This specifies the location of the private key to be used for identification with the remote host.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-C '$ARG1$'</code>: This specifies that the command run by <code class="literal">check_by_ssh</code> on the target host is given in the first argument the service defines in its <code class="literal">check_command</code>; in this case, our command is:<div><pre class="programlisting">
<strong>/usr/local/nagios/libexec/check_load -w 15,10,5 -c 30,25,20</strong>
</pre></div></li></ul></div><p>Note that it's important that <code class="literal">$ARG1$</code> is in quotes, because we want to pass the whole command as one argument to <code class="literal">check_by_ssh</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec228"/>There's more...</h2></div></div></div><p>Using <code class="literal">check_by_ssh</code> instead of <code class="literal">check_nrpe</code> allows full authentication via public key, rather than merely by having the right IP address. It also encrypts all traffic implicitly, minimizing the risk of sensitive data, such as usernames or passwords, from being intercepted. Which of the two plugins you should use will depend very much on the nature of your network and your security policy. There is no reason you can't use both of them if you wish.</p><p>Be careful not to confuse this plugin with <code class="literal">check_ssh</code>, which checks that the SSH service itself is running, and is discussed in the <em>Monitoring SSH for any host</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec229"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Monitoring local services on a remote machine with NRPE</em> recipe in this chapter</li><li class="listitem" style="list-style-type: disc">The <em>Monitoring SSH for any host</em> recipe in <a class="link" href="ch05.html" title="Chapter 5. Monitoring Methods">Chapter 5</a>, <em>Monitoring Methods</em></li></ul></div></div></div></body></html>