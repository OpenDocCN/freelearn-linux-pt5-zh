<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Graduation Day</h1></div></div></div><p>We have reached the last chapter of <em>CentOS System Administration Essentials</em>, and you are nearly a Linux Ninja; however, before you can pass with flying colors, you will learn some best practices in the deployment of CentOS Linux. This chapter will cover the subjects that we have specifically looked at and some other more generic CentOS best practices to consider when administering your systems. Additionally, we will take a quick peek at the new features that you will find in Enterprise Linux 7 from Red Hat and CentOS.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Securing remote access to your system</strong>: Here, we take a look at OpenSSH and some considerations that you may want to review</li><li class="listitem" style="list-style-type: disc"><strong>OpenLDAP best practices</strong>: Here, we ensure that your directory service is kept running the way that you want</li><li class="listitem" style="list-style-type: disc"><strong>Nginx best practices</strong>: A quick guide to some dos and don'ts when configuring the web server</li><li class="listitem" style="list-style-type: disc"><strong>Mastering Puppet</strong>: A checklist on what and how to secure on your Linux server.</li><li class="listitem" style="list-style-type: disc"><strong>What's new in CentOS 7</strong>: This guide is predominately aimed at CentOS 6.5, but Enterprise Linux 7 is now available for both Red Hat and CentOS, and we will take a quick look at the highlights</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec59"/>Securing remote access to your system</h1></div></div></div><p>Using <strong>Secure Shell</strong> (<strong>SSH</strong>) is a command method to gain remote access to your server. The<a class="indexterm" id="id532"/> security is implemented at one level using data <a class="indexterm" id="id533"/>encryption, but is augmented by server authentication, by default. Clients can compare the public key presented by the server against a list of trusted hosts, or as SSH names them, <code class="literal">known_hosts</code>. This is a little like using your web browser to visit HTTPS sites; occasionally, we may get warnings saying that the remote host is not trusted or cannot be identified. With SSH, instead of the browser holding the public key of the server, we have the <code class="literal">~/.ssh/known_hosts</code> file to store <a class="indexterm" id="id534"/>the<a class="indexterm" id="id535"/> SSH public key of hosts we connect to.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec80"/>The SSH public key</h2></div></div></div><p>The<a class="indexterm" id="id536"/> default behavior of the SSH client on CentOS and most Linux distributions is to prompt the user to accept the remote host's public SSH key when they first connect to that host. Unless the key is already present and perhaps preshared, on acceptance, the public key from the remote SSH host will be stored in the SSH client store for that user. Any subsequent times that the same user connects to the same remote host, the client will connect without the prompt as the host is already trusted.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec81"/>Analyzing the risks of default settings</h2></div></div></div><p>The default settings provide for a convenient, and mostly secure, mechanism in which we can obtain the public keys of remote hosts. Potentially, we have an issue where the remote<a class="indexterm" id="id537"/> host we connect to in the first instance is not the trusted host that we wish to connect to. As there is no authentication mechanism in place, we have to rely on trust and probability that in the first instance, the connection will be made to the correct host and not an imposter.</p><p>To work more securely, we can adjust the client settings so that it may only connect to hosts that are already trusted or, in other words, have their public key stored in the local keystore. To make this adjustment, we will need to edit the <code class="literal">/etc/ssh/ssh_config</code> file. The <code class="literal">StrictHostKeyChecking</code> directive is set to <code class="literal">ask</code> by default and should be edited to read <code class="literal">yes</code> to ensure we only connect when we have a preshared key.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec82"/>Populating the keystore</h2></div></div></div><p>If we choose the latter method where we wish the key to be already preshared, we need to address<a class="indexterm" id="id538"/> the method of populating the keystore. We can copy the server's public key to the client store manually or more easily, using the <code class="literal">ssh-keyscan</code> command. The <a class="indexterm" id="id539"/>command, although convenient, carries the same risks that are inherent to the client prompting to accept the key. If there is a malicious server during the scan, we will store the incorrect key. The reality is that the only secure method is sending a physical copy of the key to the client. Being able to centralize the client keystore would certainly make life much easier, and this can be achieved using the <code class="literal">/etc/ssh/ssh_known_hosts</code> file. This then does allow much easier manual population, as we only need the one client file rather than one per user on the client machine.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec83"/>Public key authentication</h2></div></div></div><p>Potentially, user passwords pose another security risk to your SSH servers. Although the password is<a class="indexterm" id="id540"/> encrypted over the wire, users, yes, we all know and love them, do share passwords, and perhaps use simple passwords when they should not. The settings for this are which authentication types are allowed are controlled on the server using the /<code class="literal">etc/ssh/sshd.conf</code> file. We can disable password-based authentication so that users have to use client keys. To disable passwords being used by our users for authentication, you will need to edit this file on the remote host; look for the <code class="literal">PasswordAuthentication</code> directive and ensure that it is set to <code class="literal">no</code>; the setting for <code class="literal">PubKeyAuthentication</code> should be set to <code class="literal">yes</code>.</p><p>With this in place, users will need to generate their own public and private key pairs on their client<a class="indexterm" id="id541"/> devices, using the <code class="literal">ssh-keygen</code> command. Their public keys should be copied to the <code class="literal">~/.ssh/authorized_keys</code> file on the server; this can<a class="indexterm" id="id542"/> be achieved using the <code class="literal">ssh-copy-id</code> command:</p><div><pre class="programlisting">
<strong>ssh-copy-i &lt;idfile&gt;  user@server</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec84"/>Root logins</h2></div></div></div><p>Root logins to<a class="indexterm" id="id543"/> an SSH server should never be allowed; I do not feel this is debatable at all on a production server. Users who need to administer the device can log in as a standard user and use <code class="literal">sudo</code> or <code class="literal">su</code> to gain privileges. This again is a controller in the <code class="literal">/etc/ssh/sshd.conf</code> file and the <code class="literal">PermitRootLogin</code> directive.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec85"/>Conclusion</h2></div></div></div><p>SSH provides <a class="indexterm" id="id544"/>a secure encryption mechanism to maintain data security across the network. Implementing <code class="literal">StrictHostKeyChecking</code> on the client will also allow for host authentication so we can be sure that we are sending our secure information to the correct server. To enhance client authentication, disable root logins to the server and allow only authentication from clients with preshared user keys.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec60"/>Best practices of OpenLDAP</h1></div></div></div><p>We have seen<a class="indexterm" id="id545"/> during the course of this book that we can centralize user accounts on an OpenLDAP server or, if we want to ease some administration features on CentOS, we can use the 389-ds. Either way, the underlying directory is OpenLDAP. Now, of course, if the user accounts exits from the directory, then so do our authentication tokens (passwords). We need to ensure that this is secure and effective. OpenLDAP supports different mechanisms for authentication; each, of course, has advantages and disadvantages as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Simple bind</strong>: Using the simple bind authentication mechanism, clients pass a clear text <a class="indexterm" id="id546"/>password to authenticate themselves to the server. This carries three potential threats: the password can be collected from a network capture, the password can be collected by a host spoofing the server's address, and the password can be obtained through a malicious attack on the server. Using LDAPS will protect against the first two threats, but not the third. It is best to avoid simple bind authentication, if possible.</li><li class="listitem" style="list-style-type: disc"><strong>Simple Authentication and Security Layer</strong> (<strong>SASL</strong>)<strong> external</strong>: This allows the use<a class="indexterm" id="id547"/> of external authentication <a class="indexterm" id="id548"/>such as client X.509 certificates (TLS public keys) to authenticate users, and can overcome inherent password issues. If the LDAP client and LDAP server are on the same machine, it is also possible to use the <strong>LDAP over IPC</strong> (<strong>LDAPI</strong>) method of the SASL authentication, where the Linux <a class="indexterm" id="id549"/>credentials of the user are used to access the directory.</li><li class="listitem" style="list-style-type: disc"><strong>SASL passwords</strong>: It is<a class="indexterm" id="id550"/> possible to use password-based authentication with SASL, but the threats then are similar to simple bind.</li></ul></div><p>If you use<a class="indexterm" id="id551"/> password-based authentication, it is often thought prudent to implement a lockout of accounts after so many failed attempts. Although this is possible in an OpenLDAP password policy, the reality is that password attacks are often more subtle than this in today's environment, and all this provides a mechanism for attackers to lock accounts.</p><p>It is also becoming more common to allow users to reset their own password if they do not remember it. Although this does alleviate a load from the help desk, it is often a weak leak in your security chain as the challenge response questions often proffered are too easily known or guessed by potential attackers.</p><p>In any directory system, there is a schema that describes each object that can be created, such as a user or group, and the attributes are properties that can exist for that object. Although it is possible to edit the schema for any given object or attribute, it is best to create your own definitions if additional attributes are required for an object rather than add them directory to the existing schema. In the long run, altering existing objects can cause issues with replication to other servers if the schema is not identical on all servers.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec61"/>Best practices of Nginx</h1></div></div></div><p>If you<a class="indexterm" id="id552"/> choose to implement the Nginx web server, there are few things that we should take a look at to endure the longevity of your web service.</p><p>From a security perspective, your web server could be accessible to the whole world, everyone. For this reason, we should ensure that some basic security threats are protected:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>SELinux</strong>: Ensure<a class="indexterm" id="id553"/> that we have set SELinux to <code class="literal">Enforcing</code> on our CentOS system that hosts Nginx.</li><li class="listitem" style="list-style-type: disc"><strong>DocumentRoot</strong>: Mount the DocumentRoot structure independently as its own <a class="indexterm" id="id554"/>filesystem, ensuring that malicious writes will not crash the Linux host if the disk fills, and secondly the partition or disk can be mounted with minimal rights, for example, <code class="literal">LABEL=web /var/www ext4 ro,nosuid,noexec,nodev,noatime 0 2</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Use a host-based firewall</strong>: Allow only incoming TCP ports <code class="literal">80</code> and <code class="literal">443</code>. Often, only <a class="indexterm" id="id555"/>outgoing UDP port <code class="literal">123</code> along with outgoing dynamic TCP ports need to be open, with port <code class="literal">123</code> being for time synchronization.</li><li class="listitem" style="list-style-type: disc"><strong>Restrict HTTP methods available to Nginx</strong>. The RFC 2616 allows many HTTP access methods; most will not be needed on your server. We can add code <a class="indexterm" id="id556"/>similar to the following to check for matches that are not equal to GET, HEAD, and POST. The code will then disallow other access methods that we do not require, such as DELETE, SEARCH, and others:<div><pre class="programlisting">if ( $request_method !~ ^(GET|POST|HEAD)$ ) {
    return 403;
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>User Agents</strong>: We may also choose to block certain user agents, browsers that are often <a class="indexterm" id="id557"/>associated with scanners, bots, or spammers. The <code class="literal">$httpd_user_agent</code> variable in an HTTP header will show what the<a class="indexterm" id="id558"/> browser is, for example Internet Explorer, Mozilla, and so on. Other than these normal browsers, there are also automated browsers that can access your site through scripts such as <code class="literal">wget</code> and <code class="literal">BBBike</code>. Try adding this to your <code class="literal">nginx.conf</code> file to prevent these agents:<div><pre class="programlisting">if ($http_user_agent ~* wget|BBBike|LWP::Simple ) {
    return 403;
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Limit access by IP</strong>: If a particular directory should only be accessible to the internal <a class="indexterm" id="id559"/>network, then you can use code similar to this in your host configuration:<div><pre class="programlisting">location /var/www/docs {
    allow 192.168.0.0/24
    deny all
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Limit file ownership</strong>: The Nginx web server will run as a named user, <code class="literal">nginx</code>. The<a class="indexterm" id="id560"/> temptation is to add the Nginx user as the owner of the DocumentRoot directory and all web content therein. This is ill advised as the document owner, user, or group can gain <a class="indexterm" id="id561"/>additional privileges such as deleting a document that you cannot write to. Typically, the <code class="literal">nginx</code> user should gain access via <code class="literal">others</code>, and we limited <code class="literal">others</code> to <code class="literal">r-x</code> on directories and <code class="literal">r--</code> on files. Typical file permissions should be similar to the following:<div><pre class="programlisting">-rw-r--r-- 1 root root 1000 Feb 1 10:00 index.html</pre></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec62"/>Mastering Puppet</h1></div></div></div><p>When <a class="indexterm" id="id562"/>using the Puppet server to manage your configuration centrally, it is worth remembering a few pertinent facts in the setup of the Puppet master.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Use modules</strong>: The <code class="literal">/etc/puppet/modules</code> directory allows the creation of modules. Modules are subdirectories created within the Puppet <code class="literal">ModulePath</code> directive, and <a class="indexterm" id="id563"/>contains files and configurations that need to be distributed to the client as part of its desired state. This simplifies the Puppet configuration, as related files are all within the module directory.</li><li class="listitem" style="list-style-type: disc"><strong>Use version control</strong>: Puppet itself does not have version control, but we can use <a class="indexterm" id="id564"/>something like GIT or <strong>subversion</strong> (<strong>svn</strong>) to <a class="indexterm" id="id565"/>maintain the previous copies of configurations.</li><li class="listitem" style="list-style-type: disc"><strong>Style</strong>: When writing Puppet configuration, standardizing the syntax style helps in <a class="indexterm" id="id566"/>maintenance and readability. The<a class="indexterm" id="id567"/> Puppet Labs style guide can be found at <a class="ulink" href="http://docs.puppetlabs.com/guides/style_guide.html">http://docs.puppetlabs.com/guides/style_guide.html</a>.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec63"/>What's new in CentOS 7</h1></div></div></div><p>CentOS 7 was<a class="indexterm" id="id568"/> released in June 2014, along with the earlier release of Red Hat Enterprise Linux 7. Along with the introduction of the Linux kernel 3.10 in this release, there are other significant updates to the distribution.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec86"/>Locale</h2></div></div></div><p>The system locale<a class="indexterm" id="id569"/> information can be conveniently set and displayed<a class="indexterm" id="id570"/> using the <code class="literal">localectl</code> command:</p><div><pre class="programlisting">
<strong>$ localectl status</strong>
</pre></div><p>The output can be seen in the following screenshot:</p><div><img alt="Locale" src="img/5920OS_11_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec87"/>Time and date information</h2></div></div></div><p>Similar to the locale information, CentOS 7 includes a simple command to display and manage<a class="indexterm" id="id571"/> time and date settings on the host system: <code class="literal">/usr/bin/timedatectl</code>. This really is a godsend to us as administrators; even if we only use the command to display the output, this one command will display the time, timezone, and NTP settings. Take a look at the output of the <code class="literal">timedatectl</code> command without options in the following <a class="indexterm" id="id572"/>screenshot:</p><div><img alt="Time and date information" src="img/5920OS_11_02.jpg"/></div><p>Staying with the <code class="literal">timedatectl</code> command, we can change the date using the following command:</p><div><pre class="programlisting">
<strong># timedatectl set-time 2014-07-19</strong>
</pre></div><p>The time <a class="indexterm" id="id573"/>can be set using the same option with time as the argument, shown as follows:</p><div><pre class="programlisting">
<strong># timedatectl set-time 23:02:23</strong>
</pre></div><p>NTP time synchronization can be enabled and disabled with the following command; though, it uses the news system service manager to enable and disable the time service:</p><div><pre class="programlisting">
<strong># timedatectl set-ntp yes</strong>
</pre></div><p>This is really a Swiss Army knife of a command; you will get to learn very quickly.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec88"/>Managing services</h2></div></div></div><p>
<code class="literal">Systemd</code> is <a class="indexterm" id="id574"/>now the system and service manager in CentOS 7 and replaces Upstart as the default init system. This not only replaces Upstart, but is backwards compatible with the traditional System V init scripts. For us as administrators, the main command to become familiar with is <code class="literal">/usr/bin/systemctl</code>.</p><p>Starting <a class="indexterm" id="id575"/>with the <code class="literal">status</code> subcommand, we can immediately see how <code class="literal">systemctl</code> works well for us. Here, we look at the status of the SSH service:</p><div><pre class="programlisting">
<strong># systemctl status sshd</strong>
</pre></div><p>The output is<a class="indexterm" id="id576"/> quite extensive and includes the <strong>Process ID</strong> (<strong>PID</strong>) and recent logfile activity. You can view this in the following screenshot.</p><div><img alt="Managing services" src="img/5920OS_11_03.jpg"/></div><p>We can stop the service using the following command:</p><div><pre class="programlisting">
<strong># systemctl stop sshd</strong>
</pre></div><p>To disable the<a class="indexterm" id="id577"/> autostart of the service, we will use the <code class="literal">disable</code> subcommand:</p><div><pre class="programlisting">
<strong># systemctl disable sshd</strong>
</pre></div><p>A<a class="indexterm" id="id578"/> service that is disabled can still be started by the administrator; the term disabled just means that the autostart of the service is disabled. A new feature that <code class="literal">systemd</code> brings is the ability to prevent a service from being started manually:</p><div><pre class="programlisting">
<strong># systemctl mask sshd</strong>
</pre></div><p>Even if an administrator tried to start the service while it is masked, the service will not start. If it is <a class="indexterm" id="id579"/>required to re-enable the service, then an administrator would need to use the <code class="literal">unmask</code> subcommand:</p><div><pre class="programlisting">
<strong># systemctl unmask sshd</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec89"/>Additional ways to repair your machine than just using the single user mode</h2></div></div></div><p>In traditional environments, we are perhaps used to using run level 1, or the single mode, as the<a class="indexterm" id="id580"/> mechanism to place the system into the maintenance mode. The concept of run levels has changed with system, and we now have targets rather than run levels. To place a running system in maintenance, we can use the following command:</p><div><pre class="programlisting">
<strong># systemctl rescue</strong>
</pre></div><p>You will be prompted for the root user password to complete the operation. If this still does not allow you to repair your system, then there is an emergency target that starts even fewer services, again allowing only root access:</p><div><pre class="programlisting">
<strong># systemctl emergency</strong>
</pre></div><p>The emergency target is much more similar to starting a CentOS 6.5 machine with the kernel argument <code class="literal">init=/bin/bash</code>. You may also have guessed from some of these commands that we can also power off and reboot systems with <code class="literal">systemctl</code>:</p><div><pre class="programlisting">
<strong># systemctl reboot</strong>
<strong># systemctl halt</strong>
</pre></div><p>Of course, the <code class="literal">shutdown</code> command<a class="indexterm" id="id581"/> is still here and can be used for this purpose too.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec90"/>Remote management</h2></div></div></div><p>The <a class="indexterm" id="id582"/>management of remote systems is possible with system too, which<a class="indexterm" id="id583"/> also uses the same <code class="literal">systemctl</code> command. If we need to see the status of the <code class="literal">atd</code> service on the host <code class="literal">s1.tup.com</code>, we can issue the following command:</p><div><pre class="programlisting">
<strong>$ systemctl -H root@s1.tup.com status atd</strong>
</pre></div><p>This simply makes use of an SSH connection to the remote host, so port <code class="literal">22</code> and SSHD must be accessible on the remote host that we monitor.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec91"/>Systemd and nonstandard subcommands</h2></div></div></div><p>The <a class="indexterm" id="id584"/>subcommands that are available from <code class="literal">systemctl</code> through <code class="literal">systemd</code> are now standardized, whereas with System V init scripts, it was possible<a class="indexterm" id="id585"/> to have any argument or subcommands <a class="indexterm" id="id586"/>added to the script. For example, with the Apache HTTPD service in CentOS 6.5, we could issue the <code class="literal">service httpd graceful</code> command. The <code class="literal">graceful</code> argument is unique to the web server, so it is not built as a subcommand within <code class="literal">systemctl</code>; however, the same result can be achieved through the use of the <code class="literal">apachectl graceful</code> command. While on the subject of the Apache web server, the default DocumentRoot has changed from <code class="literal">/var/www</code> to <code class="literal">/usr/share/httpd</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec92"/>The Samba 4.1 package</h2></div></div></div><p>For the <a class="indexterm" id="id587"/>Windows domain, file, and print services, Samba 4.1 replaces the aged Samba 3, which was supplied with CentOS 6.5 and earlier systems.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec93"/>Filesystem changes</h2></div></div></div><p>The <a class="indexterm" id="id588"/>default filesystem is now XFS, replacing ext4. XFS has been around for a long time, but is obviously catching the attention of the Enterprise Linux community now.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec94"/>Password policies</h2></div></div></div><p>The PAM module that enforces password quality now defaults to <code class="literal">pam_pwquality</code>, replacing <a class="indexterm" id="id589"/>the older <code class="literal">pam_cracklib</code>. Editing the <code class="literal">/etc/security/pwquality.conf</code> file will allow you to specify the minimum password length and password complexity. The password complexity consists of:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>minclass</strong>: This<a class="indexterm" id="id590"/> is the minimum number of character class types, uppercase, lowercase, numeric, and non-alphanumeric</li><li class="listitem" style="list-style-type: disc"><strong>maxsequence</strong>: This<a class="indexterm" id="id591"/> limits the number of consecutive characters of the same class, such as <code class="literal">12345</code> or <code class="literal">bcfag</code>; both have a sequence of five characters, whereas <code class="literal">bcafG</code> only has a sequence of four characters from the same class (lowercase)</li><li class="listitem" style="list-style-type: disc"><strong>maxrepeat</strong>: This <a class="indexterm" id="id592"/>limits the number of repeating characters</li></ul></div><p>The <a class="indexterm" id="id593"/>existing file can act as an example, or we can use the manual using the <code class="literal">man 5 pwqulality.conf</code> command for more detailed information.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec64"/>Summary</h1></div></div></div><p>You are now ready to walk out into the world and declare your new-found knowledge of CentOS. I have been able to help you through some simple best practice goals to manage the services we looked at throughout this book as well as introduce some new elements of CentOS 7. Of course, for a long time, you will still come across plenty of CentOS 6 systems to keep you busy, and most elements are consistent from Version 6 to Version 7, but keeping up to date with the latest enhancements is always useful.</p></div></body></html>