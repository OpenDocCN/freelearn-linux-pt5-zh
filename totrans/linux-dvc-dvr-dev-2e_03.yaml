- en: '*Chapter 2*: Understanding Linux Kernel Module Basic Concepts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：理解Linux内核模块的基本概念'
- en: A kernel module is a piece of software whose aim is to extend the Linux kernel
    with a new feature. A kernel module can be a device driver, in which case it would
    control and manage a particular hardware device, hence the name **device driver**.
    A module can also add a framework support (for example **IIO**, the **Industrial
    Input Output** framework), extend an existing framework, or even a new filesystem
    or an extension of it. The thing to keep in mind is that kernel modules are not
    always device drivers, whereas device drivers are always kernel modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块是一种软件，旨在通过新增功能扩展Linux内核。内核模块可以是设备驱动程序，在这种情况下，它将控制和管理特定的硬件设备，因此被称为**设备驱动程序**。模块也可以添加框架支持（例如**IIO**，即**工业输入输出**框架）、扩展现有框架，甚至是新的文件系统或其扩展。需要记住的是，内核模块不一定是设备驱动程序，而设备驱动程序始终是内核模块。
- en: In opposition to kernel modules, there might be simple modules or user space
    modules, running in user space, with low privileges. This book, however, exclusively
    deals with kernel space modules, particularly Linux kernel modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核模块相对的是，可能存在简单模块或用户空间模块，它们运行在用户空间，权限较低。然而，本书仅处理内核空间模块，特别是Linux内核模块。
- en: 'That being said, this chapter will discuss the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，本章将讨论以下主题：
- en: An introduction to the concept of modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块概念简介
- en: Building a Linux kernel module
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Linux内核模块
- en: Dealing with symbol exports and module dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理符号导出和模块依赖
- en: Learning some Linux kernel programming tips
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些Linux内核编程技巧
- en: An introduction to the concept of modules
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块概念简介
- en: When building the Linux kernel, the resulting image is a single file made by
    the linking of all object files that correspond to features enabled in the configuration.
    As a result, all included features are therefore available as soon as the kernel
    starts, even if the filesystem is not yet ready or does not exist. These features
    are built-in, and the corresponding modules are called static modules. Such a
    module is available at any time in the kernel image and thus can't be unloaded,
    at the cost of extra size to the final kernel image. A static module is also known
    as a built-in module, since it is part of the final kernel image output. Any change
    in its code will require the whole kernel to be rebuilt.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Linux内核时，最终生成的映像是由所有与配置中启用的功能相对应的目标文件链接而成的单一文件。因此，所有包含的功能在内核启动时就能立即可用，即使文件系统尚未准备好或不存在。这些功能是内建的，相应的模块称为静态模块。这样的模块在内核映像中始终可用，因此无法卸载，但代价是最终内核映像的体积增加。静态模块也被称为内建模块，因为它是最终内核映像输出的一部分。任何代码的更改都需要重新构建整个内核。
- en: Some features (such as device drivers, filesystems, and frameworks) can, however,
    be compiled as loadable modules. Such modules are separated from the final kernel
    image and are loaded on demand. These can be considered as plugins that can be
    loaded/unloaded dynamically to add or remove features (at runtime) to the kernel.
    Because each module is stored as a separate file on the filesystem, using loadable
    modules requires access to a filesystem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些功能（如设备驱动程序、文件系统和框架）可以编译为可加载模块。这些模块与最终的内核映像分离，按需加载。它们可以被视为插件，能够动态加载/卸载，以便在运行时向内核添加或删除功能。由于每个模块作为单独的文件存储在文件系统中，因此使用可加载模块需要访问文件系统。
- en: To summarize, a module is to the Linux kernel what a plugin (add-on) is to user
    software (for example, Firefox). When it is statically linked to the resulting
    kernel image, it is said to be built in. When it is built as a separate file (which
    can be loaded/unloaded), it is loadable. It dynamically extends the kernel features
    without even the need to restart the machine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，模块对于Linux内核就像插件（附加组件）对于用户软件（例如Firefox）。当它与生成的内核映像静态链接时，称为内建。它如果被构建为一个单独的文件（可以加载/卸载），则称为可加载模块。它在不需要重启机器的情况下动态扩展内核功能。
- en: 'To support module loading, the kernel must have been built with the following
    option enabled:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持模块加载，内核必须启用以下选项进行构建：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unloading modules is a kernel feature that can be enabled or disabled according
    to the `CONFIG_MODULE_UNLOAD` kernel configuration option. Without this option,
    we won''t be able to unload any module. Thus, to be able to unload modules, the
    following feature must be enabled:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载模块是内核的一项特性，可以根据`CONFIG_MODULE_UNLOAD`内核配置选项启用或禁用。没有这个选项，我们将无法卸载任何模块。因此，为了能够卸载模块，必须启用以下功能：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That said, the kernel is smart enough to prevent unloading modules that may
    probably break things (for example, because these are in use), even if it is asked
    to do so. This is because the kernel keeps a reference count of module usage so
    that it knows whether a module is currently in use or not. If the kernel believes
    it is unsafe to remove a module, it will not. We can, however, change this behavior
    with the following configuration feature:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，内核足够智能，可以防止卸载可能会破坏系统的模块（例如，因为这些模块正在使用中），即使被要求卸载。这是因为内核会保持模块使用的引用计数，从而知道模块当前是否正在使用。如果内核认为卸载模块不安全，它将不会卸载。但是，我们可以通过以下配置功能来改变这种行为：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding option allows us to force module unload.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的选项允许我们强制卸载模块。
- en: Now that we are done with the main concepts behind modules, let's start practicing,
    first by introducing a module skeleton that will serve as a basis for this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了模块背后的主要概念，让我们开始实践，首先介绍一个模块框架，它将作为本章的基础。
- en: Case study – module skeleton
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究——模块框架
- en: 'Let''s consider the following `hello-world` module. It will be the basis for
    our work throughout this chapter. Let''s call its compilation unit `helloworld.c`,
    with the following content:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下`hello-world`模块。它将是我们在本章中工作的基础。我们将其编译单元命名为`helloworld.c`，其内容如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding skeleton, headers are specific to the Linux kernel, hence the
    use of `linux/xxx.h`. The `module.h` header file is mandatory for all kernel modules,
    and `init.h` is needed for the `__init` and `__exit` macros. Other elements are
    described in the next sections. To build this skeleton module, we need to write
    a *special* makefile, which will be covered a little bit later in this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的框架中，头文件是特定于Linux内核的，因此使用了`linux/xxx.h`。`module.h`头文件是所有内核模块的必需文件，`init.h`是为了使用`__init`和`__exit`宏而需要的。其他内容将在接下来的部分中描述。为了构建这个框架模块，我们需要编写一个*特殊*的makefile，稍后在本章中会涉及到。
- en: Module entry and exit points
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块的入口和退出点
- en: The minimal requirement of a kernel module is an initialization method. This
    is a must. If the module can be built as a loadable module, then the `exit` method
    must be provided as well. The first method is the entry point and corresponds
    to the function called when the module is loaded (`modprobe` or `insmod`), and
    the latter is the cleanup and exit point and corresponds to the function executed
    at module unloading (at `rmmod` or `modprobe -r`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块的最小要求是一个初始化方法。这是必须的。如果模块可以构建为可加载模块，则还必须提供`exit`方法。第一个方法是入口点，对应于模块加载时调用的函数（`modprobe`或`insmod`），而后者是清理和退出点，对应于模块卸载时执行的函数（`rmmod`或`modprobe
    -r`）。
- en: All you need to do is to inform the kernel about which functions should be executed
    as an entry or exit point. The `helloworld_init` and `helloworld_exit` functions
    can be given any name. The only thing that is actually mandatory is to identify
    them as the corresponding initialization and exit functions, passing them as parameters
    to the `module_init()` and `module_exit()` macros.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的就是通知内核哪些函数应该作为入口或出口点执行。`helloworld_init`和`helloworld_exit`函数可以使用任何名称。实际上唯一强制要求的是将它们标识为相应的初始化和退出函数，并将它们作为参数传递给`module_init()`和`module_exit()`宏。
- en: To sum up, `module_init()` is used to declare the function that should be called
    when the module is loaded (with `insmod` or `modprobe` when the module is built
    as a loadable kernel module) or when the kernel reaches the run level corresponding
    to this module (when built-in). What is done in the initialization function will
    define the behavior of the module. `module_exit()` is used only when the module
    can be built as a loadable kernel module. It declares the function that should
    be called when the module is unloaded (with `rmmod`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`module_init()`用于声明在模块加载时应该调用的函数（当模块构建为可加载内核模块时，通过`insmod`或`modprobe`），或者当内核达到与此模块对应的运行级别时（当它是内置的）。初始化函数中执行的内容将定义模块的行为。`module_exit()`仅在模块可以构建为可加载内核模块时使用。它声明了模块卸载时应该调用的函数（通过`rmmod`）。
- en: '`init` or `exit` methods are invoked only once, whatever the number of devices
    currently handled by the module, provided the module is a device driver. It is
    common for modules that are platform (or alike) device drivers to register a platform
    driver and the associated `probe`/`remove` callback in their `init` functions,
    which this time will be invoked each time a device handled by the module is added
    or removed on the system. In such a case, they just unregister the platform driver
    from within their `exit` method.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`或`exit`方法只会被调用一次，无论模块当前处理多少设备，只要该模块是设备驱动程序。对于平台（或类似的）设备驱动程序的模块来说，通常会在其`init`函数中注册一个平台驱动程序，并关联`probe`/`remove`回调，这样每次模块处理的设备添加或从系统中移除时，`init`函数就会被调用。在这种情况下，它们只需在`exit`方法中注销平台驱动程序。'
- en: __init and __exit attributes
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: __init和__exit属性
- en: '`__init` and `__exit` are kernel macros, defined in `include/linux/init.h`,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init`和`__exit`是内核宏，在`include/linux/init.h`中定义，如下所示：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `__init` keyword tells the linker to place the symbols (variables or functions)
    they prefix in a dedicated section in the resulting kernel object file. This section
    is known in advance to the kernel and freed when the module is loaded and the
    initialization function has finished. This applies only to built-in modules, not
    to loadable ones. The kernel will run the initialization function of the driver
    for the first time during its boot sequence. Since the driver cannot be unloaded,
    its initialization function will never be called again until the next reboot.
    There is no need to keep references on this initialization function anymore. It
    is the same for the `__exit` keyword and the `exit` method, whose corresponding
    code is omitted when the module is compiled statically into the kernel or when
    module unloading support is not enabled because, in both cases, the exit function
    is never called. `__exit` has no effect on loadable modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init`关键字告诉链接器将它们前缀的符号（变量或函数）放置在结果内核目标文件中的专用段中。内核事先已知该段，并在模块加载且初始化函数完成后释放。此功能仅适用于内建模块，而不适用于可加载模块。内核会在启动过程中首次运行驱动程序的初始化函数。由于驱动程序不能卸载，因此初始化函数在下次重启之前永远不会再次被调用。因此，之后无需再保留对该初始化函数的引用。`__exit`关键字及`exit`方法也遵循相同的规则，编译时将会忽略对应的代码，如果模块被静态编译到内核中，或者未启用模块卸载支持，因为在这两种情况下，退出函数从未被调用。`__exit`对可加载模块没有影响。'
- en: In conclusion, `__init` and `__exit` are Linux directives (macros) that wrap
    GNU C compiler attributes used for symbol placement. They instruct the compiler
    to put the code they prefix in the `.init.text` and `.exit.text` sections, respectively,
    even though the kernel can access different object sections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`__init`和`__exit`是Linux指令（宏），用于包装GNU C编译器属性，这些属性用于符号位置的设置。它们指示编译器将它们前缀的代码分别放置在`.init.text`和`.exit.text`段中，尽管内核可以访问不同的对象段。
- en: Module information and metadata
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块信息和元数据
- en: 'Without having to read its code, it should be possible to gather some information
    (such as the author(s), module parameter descriptions, and the license) about
    a given module. A kernel module uses its `.modinfo` section to store information
    about the module. Any `MODULE_*` macro will update the content of this section
    with the values passed as parameters. Some of these macros are `MODULE_DESCRIPTION()`,
    `MODULE_AUTHOR()`, and `MODULE_LICENSE()`. That said, the real underlying macro
    provided by the kernel to add an entry to the module information section is `MODULE_INFO(tag,
    info)`, which adds generic information of the `tag = "info"` form. This means
    a driver author can add any freeform information they want, such as the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无需读取其代码，应该可以收集一些关于给定模块的信息（例如，作者、模块参数描述和许可证）。内核模块使用其`.modinfo`段来存储模块信息。任何`MODULE_*`宏都将更新该段的内容，并传入作为参数的值。部分宏如`MODULE_DESCRIPTION()`、`MODULE_AUTHOR()`和`MODULE_LICENSE()`。也就是说，内核提供的真实底层宏来添加条目到模块信息段是`MODULE_INFO(tag,
    info)`，它以`tag = "info"`的形式添加通用信息。这意味着驱动程序作者可以添加任何自由格式的信息，举例如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As well as the custom information we define, there is standard information
    we should provide, which the kernel provides macros for:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们定义的自定义信息外，还有一些标准信息我们应该提供，内核为此提供了宏：
- en: '`MODULE_LICENSE`: The license will define how your source code should be shared
    (or not) with other developers. `MODULE_LICENSE()` tells the kernel what license
    our module is under. It has an effect on your module behavior, since a license
    that is not compatible with GPL (General Public License) will result in your module
    not being able to see/use symbols exported by the kernel through the `EXPORT_SYMBOL_GPL()`
    macro, which shows the symbols for GPL-compatible modules only. This is the opposite
    of `EXPORT_SYMBOL()`, which exports functions for modules with any license. Loading
    a non-GPL-compatible module will also result in a tainted kernel; that means non-open
    source or untrusted code has been loaded, and you will likely have no support
    from the community. Remember that the module without `MODULE_LICENSE()` is not
    considered open source and will taint the kernel too. Available licenses can be
    found in `include/linux/module.h`, describing the license supported by the kernel.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_LICENSE`：许可证将定义如何与你的源代码共享（或不共享）给其他开发者。`MODULE_LICENSE()` 告诉内核我们的模块采用何种许可证。它会影响模块的行为，因为与
    GPL（通用公共许可证）不兼容的许可证会导致模块无法看到/使用内核通过 `EXPORT_SYMBOL_GPL()` 宏导出的符号，这些符号仅供与 GPL 兼容的模块使用。这与
    `EXPORT_SYMBOL()` 相反，后者导出任何许可证模块的函数。加载一个与 GPL 不兼容的模块也会导致内核被污染；这意味着加载了非开源或不受信任的代码，并且你可能无法获得社区的支持。记住，没有
    `MODULE_LICENSE()` 的模块也不被视为开源，并且会污染内核。可以在 `include/linux/module.h` 中找到可用的许可证，描述内核支持的许可证类型。'
- en: '`MODULE_AUTHOR()` declares the module''s author(s): `MODULE_AUTHOR("John Madieu
    <john.madieu@foobar.com>");`. It is possible to have more than one author. In
    this case, each author must be declared with `MODULE_AUTHOR()`:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_AUTHOR()` 声明模块的作者：`MODULE_AUTHOR("John Madieu <john.madieu@foobar.com>");`。一个模块可以有多个作者。在这种情况下，每个作者必须使用
    `MODULE_AUTHOR()` 声明：'
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`MODULE_DESCRIPTION()` briefly describes what the module does: `MODULE_DESCRIPTION("Hello,
    world! Module")`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODULE_DESCRIPTION()` 简要描述模块的功能：`MODULE_DESCRIPTION("Hello, world! Module")`。'
- en: You can dump the content of the `.modeinfo` section of a kernel module using
    the `objdump -d -j .modinfo` command on the given module. For a cross-compiled
    module, you should use `$(CORSS_COMPILE)objdump` instead.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `objdump -d -j .modinfo` 命令查看内核模块的 `.modeinfo` 部分内容。对于交叉编译的模块，你应该使用 `$(CORSS_COMPILE)objdump`
    来代替。
- en: Now that we are done with providing module information and metadata, which are
    the last requirements when writing Linux kernel modules, let's learn how to build
    these modules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成提供模块信息和元数据的步骤后，这些是编写 Linux 内核模块时的最后要求，让我们学习如何构建这些模块。
- en: Building a Linux kernel module
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Linux 内核模块
- en: 'Two solutions exist for compiling a kernel module:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编译内核模块有两种解决方案：
- en: The first solution is when code is outside of the kernel source tree, which
    is also known as out-of-tree building. The module source code is in a different
    directory. Building a module this way does not allow integration into the kernel
    configuration/compilation process, and the module needs to be built separately.
    It must be noted that with this solution, the module cannot be statically linked
    in the final kernel image – that is, it cannot be built in. Out-of-tree compilation
    only allows loadable kernel modules to be produced.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个解决方案是当代码位于内核源树之外时，也称为外部构建。模块源代码位于不同的目录。以这种方式构建模块不能与内核配置/编译过程集成，模块需要单独构建。需要注意的是，使用这种解决方案时，模块不能在最终的内核镜像中静态链接——也就是说，它不能被内建。外部构建只允许生成可加载的内核模块。
- en: The second solution is inside the kernel tree, which allows you to upstream
    your code, since it is well integrated into the kernel configuration/compilation
    process. This solution allows you to produce either a statically linked module
    (also known as built-in) or a loadable kernel module.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种解决方案是在内核树中，它允许你将代码上游化，因为它与内核配置/编译过程紧密集成。这个解决方案允许你生成静态链接模块（也叫内建模块）或可加载的内核模块。
- en: Now that we have enumerated and given the characteristics of the two possible
    solutions for building kernel modules, before studying each of them, let's first
    dig into the Linux kernel build process. This will help us to understand compilation
    prerequisites for each solution.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经列举并给出了构建内核模块的两种可能解决方案的特点，在研究它们之前，让我们先深入了解一下 Linux 内核的构建过程。这将帮助我们理解每种解决方案的编译前提条件。
- en: Understanding the Linux kernel build system
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Linux 内核构建系统
- en: The Linux kernel maintains its own build system. It is called `Kconfig`, for
    feature selections, mainly used with in-kernel tree building, and `Kbuild` (note
    that the K is uppercase this time) or `Makefile`, for compilation rules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核维护其自己的构建系统。它称为 `Kconfig`，用于功能选择，主要与内核树构建一起使用，以及 `Kbuild`（注意这次 K 是大写）或
    `Makefile`，用于编译规则。
- en: The Kbuild or Makefile files
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kbuild 或 Makefile 文件
- en: 'From within this build system, the makefile can be called either `Makefile`
    or `Kbuild`. If both files exist, only `Kbuild` will be used. That said, a makefile
    is a special file used to execute a set of actions, among which the most common
    is the compilation of programs. There is a dedicated tool to parse makefiles,
    called `make`. Using this tool, a kernel module build command pattern resembles
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从此构建系统内部，makefile 可以称为`Makefile`或`Kbuild`。如果两个文件都存在，则仅使用`Kbuild`。也就是说，makefile
    是用于执行一组操作的特殊文件，其中最常见的是程序的编译。有一个专用工具来解析 makefile，称为`make`。使用此工具，内核模块构建命令模式如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding pattern, `$KERNEL_SRC` refers to the path of the prebuilt
    kernel directory, `-C $KERNEL_SRC` instructs `make` to change into the specified
    directory when executing and change back when finished, and `M=$(shell pwd)` instructs
    the kernel build system to move back into this directory to find the module that
    is being built. The value given to `M` is the absolute path of the directory where
    the module sources (or the associated `Kbuild` file) are located. `[target]` corresponds
    to the subset of the `make` targets available when building an external module.
    These are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述模式中，`$KERNEL_SRC` 指的是预构建内核目录的路径，`-C $KERNEL_SRC` 指示 `make` 在执行时转到指定目录并在完成后返回，`M=$(shell
    pwd)` 指示内核构建系统回到此目录以找到正在构建的模块。给定给 `M` 的值是模块源代码所在目录（或相关的 `Kbuild` 文件）的绝对路径。`[target]`
    对应于构建外部模块时可用的 `make` 目标的子集。这些如下：
- en: '`modules`: This is the default target for external modules. It has the same
    functionality as if no target was specified.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules`：这是外部模块的默认目标。它的功能与未指定目标时相同。'
- en: '`modules_install`: This installs the external module(s). The default location
    is `/lib/modules/<kernel_release>/extra/`. This path can be overridden.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules_install`：这会安装外部模块(s)。默认位置是`/lib/modules/<kernel_release>/extra/`。此路径可以被覆盖。'
- en: '`clean`: This removes all generated files (in the module directory only).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clean`：这将删除所有生成的文件（仅在模块目录中）。'
- en: 'However, we have not told the build system what object files to build or to
    link together. We must specify the name of the module(s) to be built, along with
    the list of requisite source files. It can be as simple as the following single
    line:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有告诉构建系统要构建或链接哪些对象文件。我们必须指定要构建的模块名称，以及必需的源文件列表。可以简单地如下一行：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding, the kernel build system will build `<module_name>.o` from
    `<module_name>.c` or `<module_name>.S`, and after linking, it will result in the
    `<module_name>.ko` kernel loadable module or will be part of the single-file kernel
    image. `<X>` can be either `y`, `m`, or left blank.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述中，内核构建系统将从 `<module_name>.c` 或 `<module_name>.S` 构建 `<module_name>.o`，并在链接后将其结果为
    `<module_name>.ko` 内核可加载模块或将其作为单文件内核映像的一部分。`<X>` 可以是 `y`、`m` 或留空。
- en: 'How and if `mymodule.o` will be built or linked depends on the value of `<X>`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以及是否构建或链接 `mymodule.o` 取决于 `<X>` 的值：
- en: If `<X>` is set to `m`, the `obj-m` variable is used, and `mymodule.o` will
    be built as a loadable kernel module.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `<X>` 设置为 `m`，则使用 `obj-m` 变量，并且 `mymodule.o` 将作为可加载的内核模块构建。
- en: If `<X>` is set to `y`, the `obj-y` variable is used, and `mymodule.o` will
    be built as part of the kernel. You then say "`foo` is a built-in kernel module".
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `<X>` 设置为 `y`，则使用 `obj-y` 变量，并且 `mymodule.o` 将作为内核的一部分构建。然后你会说"`foo` 是一个内置的内核模块"。
- en: If `<X>` is not set, the `obj-` variable is used, and `mymodule.o` will not
    be built at all.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未设置 `<X>`，则使用 `obj-` 变量，并且 `mymodule.o` 将根本不会构建。
- en: 'However, the `obj-$(CONFIG_XXX)` pattern is often used, where `CONFIG_XXX`
    is a kernel configuration option, set or not, during the kernel configuration
    process. An example is the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常使用 `obj-$(CONFIG_XXX)` 模式，其中 `CONFIG_XXX` 是内核配置选项，在内核配置过程中设置或不设置。例如以下是一个示例：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`$(CONFIG_MYMODULE)` evaluates to either `y`, `m`, or nothing (blank), according
    to its value during the kernel configuration (displayed with `menuconfig`). If
    `CONFIG_MYMODULE` is neither `y` nor `m`, then the file will not be compiled nor
    linked. `y` means built-in (it stands for `yes` in the kernel configuration process),
    and `m` stands for a loadable module. `$(CONFIG_MYMODULE)` pulls the right answer
    from the normal config process.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(CONFIG_MYMODULE)`的值根据内核配置时的值（通过`menuconfig`显示）会被评估为`y`、`m`或空（无）。如果`CONFIG_MYMODULE`既不是`y`也不是`m`，则该文件既不会被编译也不会被链接。`y`表示内建（在内核配置过程中表示`yes`），而`m`表示可加载模块。`$(CONFIG_MYMODULE)`从正常的配置过程中提取正确的答案。'
- en: 'So far, we have assumed the module is built from a single `.c` source file.
    When the module is built from multiple source files, an additional line is needed
    for listing these source files, as shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设模块是由一个单独的`.c`源文件构建的。当模块是由多个源文件构建时，需要添加一行来列出这些源文件，如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding says that `<module_name>.ko` will be built from two files, `file1.c`
    and `file2.c`. However, if you wanted to build two modules, let''s say `foo.ko`
    and `bar.ko`, the `Makefile` line would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的说明表示`<module_name>.ko`将由两个文件`file1.c`和`file2.c`构建。然而，如果你想构建两个模块，例如`foo.ko`和`bar.ko`，`Makefile`的行应如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If `foo.o` and `bar.o` are made of source files other than `foo.c` and `bar.c`,
    you can specify the appropriate source files of each object file, as shown here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`foo.o`和`bar.o`是由不同于`foo.c`和`bar.c`的源文件生成的，你可以指定每个目标文件的适当源文件，如下所示：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is another example of listing the requisite source files to build
    a given module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列出构建给定模块所需源文件的另一个示例：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding example says that `8123` should be built as a loadable kernel
    module by building and linking `8123_if.c`, `8123_pci.c`, and `8123_bin.c` together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，`8123`应该通过构建和链接`8123_if.c`、`8123_pci.c`和`8123_bin.c`文件来构建为一个可加载的内核模块。
- en: 'Apart from the files being part of the resulting build artifact, the `Makefile`
    file can also contain compiler and linker flags, such as the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了文件作为生成的构建产物的一部分，`Makefile`文件还可以包含编译器和链接器标志，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What is important here is the fact that such flags can be specified as well,
    not the values we have set in the example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，除了我们在示例中设置的值外，也可以指定类似的标志。
- en: 'There is another use case of `obj-<X>`, described in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`obj-<X>`的使用案例如下所述：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means that the kernel build system should go into the directory named `somedir`
    and look for any `Makefile` or `Kbuild` files inside, processing it in order to
    decide what objects should be built.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着内核构建系统应该进入名为`somedir`的目录，并查找其中的任何`Makefile`或`Kbuild`文件，处理它们以决定应该构建哪些目标。
- en: 'We can summarize what we just said with the following Makefile:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下`Makefile`总结刚才所说的内容：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following describes this minimalist `Makefile` skeleton:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了这个简化的`Makefile`框架：
- en: '`obj-m := helloworld.o`: `obj-m` lists modules we want to build. For each `<filename>.o`,
    the build system will look for `<filename>.c` or `<filename>.S` to build. `obj-m`
    is used to build a loadable kernel module, whereas `obj-y` will result in a built-in
    kernel module.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`obj-m := helloworld.o`：`obj-m`列出了我们希望构建的模块。对于每个`<filename>.o`，构建系统将查找`<filename>.c`或`<filename>.S`来进行构建。`obj-m`用于构建可加载的内核模块，而`obj-y`将导致内建的内核模块。'
- en: '`KERNEL_SRC= /lib/modules/$(shell uname -r)/build`: `KERNEL_SRC` is the location
    of the prebuilt kernel source. As we said earlier, we need a prebuilt kernel in
    order to build any module. If you have built your kernel from the source, you
    should set this variable with the absolute path of the built source directory.
    `–C` instructs the `make` utility to change into the specified directory reading
    the makefiles.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KERNEL_SRC= /lib/modules/$(shell uname -r)/build`：`KERNEL_SRC`是预构建内核源代码的位置。正如我们之前所说，我们需要一个预构建的内核来构建任何模块。如果你是从源代码构建内核的，你应该用已构建的源目录的绝对路径来设置此变量。`–C`指示`make`工具切换到指定的目录并读取`Makefile`。'
- en: '`M=$(shell pwd)`: This is relevant to the kernel build system. The `Makefile`
    kernel uses this variable to locate the directory of an external module to build.
    Your `.c` files should be placed in that directory.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M=$(shell pwd)`：这与内核构建系统有关。内核的`Makefile`使用此变量来定位外部模块的目录进行构建。你的`.c`文件应该放在该目录中。'
- en: '`all default`: `modules`: This line instructs the `make` utility to execute
    the `modules` target as a dependency of `all` or `default` targets. In other words,
    `make default`, `make all`, or simple `make` commands will result in `make modules`
    being executed prior to execute any subsequent command if any.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all default`: `modules`：这一行指示`make`工具将`modules`目标作为`all`或`default`目标的依赖项执行。换句话说，`make
    default`、`make all`或简单的`make`命令将在执行任何后续命令之前执行`make modules`。'
- en: '`modules modules_install help clean`: This line represents the list target
    that is valid in this makefile.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules modules_install help clean`：这一行表示在该makefile中有效的目标列表。'
- en: '`$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@`: This is the rule to be executed
    for each of the targets enumerated previously. `$@` will be replaced with the
    parameters given to `make`, which includes the target. Using this kind of magic
    word prevents us from writing as many (identical) lines as there are targets.
    In other words, if you run `make modules`, `$@` will be replaced with `modules`,
    and the rule will become `$(MAKE) -C $(KERNELDIR) M=$(shell pwd) modules`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@`：这是为先前列举的每个目标执行的规则。`$@`将被替换为传递给`make`的参数，其中包括目标。使用这种魔术词可以防止我们编写与目标数目相同（相同）的行。换句话说，如果你运行`make
    modules`，`$@`将被替换为`modules`，规则将变为`$(MAKE) -C $(KERNELDIR) M=$(shell pwd) modules`。'
- en: Now that we are familiar with the kernel build system requirements, let's see
    how modules are actually built.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了内核构建系统的要求，让我们看看模块是如何实际构建的。
- en: Out-of-tree building
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树外构建
- en: 'Before you can build an external module, you need to have a complete and precompiled
    kernel source tree. The prebuilt kernel version must be the same as the kernel
    you''ll load and use your module with. There are two ways to obtain a prebuilt
    kernel version:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建外部模块之前，你需要拥有一个完整的、预编译的内核源代码树。预构建的内核版本必须与你将加载并使用模块的内核版本相同。有两种方式可以获得预构建的内核版本：
- en: 'Building it by yourself (which we discussed earlier): This can be used for
    both native and cross-compilation. Using a build system such as Yocto or Buildroot
    may help.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自行构建（我们之前讨论过的）：这可以用于本地编译和交叉编译。使用像Yocto或Buildroot这样的构建系统可能会有所帮助。
- en: 'Installing the `linux-headers-*` package from the distribution package feed:
    This applies only for x86 native compilations unless your embedded target runs
    a Linux distribution that maintains a package feed (such as Raspbian).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从发行版软件包源安装`linux-headers-*`包：这仅适用于x86本地编译，除非你的嵌入式目标运行的是维护软件包源的Linux发行版（例如Raspbian）。
- en: It must be noted that is it not possible to build a built-in kernel module with
    out-of-tree building. The reason is that building a Linux kernel module out of
    tree requires a prebuilt or prepared kernel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，无法通过树外构建来构建内建的内核模块。原因是，树外构建Linux内核模块需要一个预构建或准备好的内核。
- en: Native and out-of-tree module compiling
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地和树外模块编译
- en: 'With a native kernel module build, the easiest way is to install the prebuilt
    kernel headers and to use their directory path as the kernel directory in the
    makefile. Before we start doing so, headers can be installed with the following
    command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地内核模块构建时，最简单的方法是安装预构建的内核头文件，并在makefile中将其目录路径作为内核目录。在我们开始这样做之前，可以使用以下命令安装头文件：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will install preconfigured and prebuilt kernel headers (not the whole source
    tree) in `/usr/src/linux-headers-$(uname -r)`. There will be a symbolic link,
    `/lib/modules/$(uname -r)/build`, pointing to the previously installed headers.
    It is the path you should specify as the kernel directory in `Makefile`. You should
    remember that `$(uname -r)` corresponds to the kernel version in use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装预配置和预构建的内核头文件（不是整个源代码树）到`/usr/src/linux-headers-$(uname -r)`。将会有一个符号链接`/lib/modules/$(uname
    -r)/build`，指向之前安装的头文件。这个路径应该在`Makefile`中作为内核目录进行指定。你应该记住，`$(uname -r)`对应的是正在使用的内核版本。
- en: 'Now, when you are done with the makefile, still in your module source directory,
    run the `make` command or `make modules`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你完成makefile后，仍然在模块源代码目录中，运行`make`命令或`make modules`：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the end of the build, you''ll have the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建结束时，你将获得以下内容：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To test, you can do the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时，你可以执行以下操作：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example only deals with a native build, compiling on a machine
    running a standard distribution, allowing us to leverage its package repository
    to install prebuilt kernel headers. In the next section, we will discuss out-of-tree
    module cross-compilation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例仅处理本地构建，即在运行标准发行版的机器上编译，允许我们利用其包存储库安装预构建的内核头文件。在接下来的章节中，我们将讨论树外模块的交叉编译。
- en: Out-of-tree module cross-compiling
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树外模块交叉编译
- en: When it comes to cross-compiling an out-of-tree kernel module, there are essentially
    two variables that the kernel `make` command needs to be aware of. These are `ARCH`
    and `CROSS_COMPILE`, which respectively represent the target architecture and
    the cross-compiler prefix. Moreover, the location of a prebuilt kernel for the
    target architecture must be specified in the makefile. In our skeleton, we called
    it `KERNEL_SRC`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到交叉编译树外内核模块时，内核的`make`命令需要知道两个变量。这些是`ARCH`和`CROSS_COMPILE`，分别代表目标架构和交叉编译器前缀。此外，必须在makefile中指定目标架构的预构建内核的位置。在我们的框架中，我们称其为`KERNEL_SRC`。
- en: When using a build system such as Yocto, the Linux kernel is first cross-compiled
    as a dependency before it starts cross-compiling the module. That said, I voluntarily
    used the `KERNEL_SRC` variable name for the prebuilt kernel directory, since this
    variable is automatically exported by Yocto for kernel module recipes. It is set
    to the value of `STAGING_KERNEL_DIR` within the `module.bbclass` class, inherited
    by all kernel module recipes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用像Yocto这样的构建系统时，Linux内核首先作为依赖项进行交叉编译，然后才开始交叉编译模块。也就是说，我自愿使用了`KERNEL_SRC`变量名来表示预构建内核目录，因为Yocto会自动为内核模块食谱导出这个变量。它在`module.bbclass`类中被设置为`STAGING_KERNEL_DIR`的值，该类被所有内核模块食谱继承。
- en: 'That said, what changes between native compilation and cross-compilation of
    an out-of-tree kernel module is the final `make` command, which looks like the
    following for a 32-bit Arm architecture:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，本地编译和树外内核模块交叉编译之间的区别在于最终的`make`命令，对于32位Arm架构，命令如下：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the 64-bit variant, it would look like the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于64位变种，它看起来如下：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous commands assume the cross-compiled kernel source path has been
    specified in the makefile.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令假设已经在makefile中指定了交叉编译的内核源路径。
- en: In-tree building
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 树内构建
- en: In-tree module building requires dealing with an additional file, `Kconfig`,
    which allows us to expose the module features in the configuration menu. That
    said, before you can build a module in the kernel tree, you should first identify
    which directory should host your source files. Given your filename, `mychardev.c`,
    which contains the source code of your special character driver, it should be
    changed to the `drivers/char` directory in the kernel source. Every subdirectory
    in the drivers has both `Makefile` and `Kconfig` files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 树内模块构建需要处理一个额外的文件`Kconfig`，该文件允许我们在配置菜单中公开模块特性。也就是说，在你能够在内核树中构建模块之前，你应该先确定应该在哪个目录中托管源文件。考虑到你的文件名是`mychardev.c`，它包含了你特定字符设备驱动程序的源代码，它应该被更改到内核源代码中的`drivers/char`目录。驱动程序中的每个子目录都有`Makefile`和`Kconfig`文件。
- en: 'Add the following content to the `Kconfig` file of that directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到该目录的`Kconfig`文件中：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `Makefile` in that same directory, add the following line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录的`Makefile`中，添加以下行：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Be careful when updating `Makefile` – the `.o` file name must match the exact
    name of the `.c` file. If the source file is `foobar.c`, you must use `foobar.o`
    in `Makefile`. In order to have your module built as a loadable kernel module,
    add the following line to your `defconfig` board in the `arch/arm/configs` directory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Makefile`时要小心——`.o`文件名必须与`.c`文件的确切名称匹配。如果源文件是`foobar.c`，则必须在`Makefile`中使用`foobar.o`。为了将你的模块构建为可加载的内核模块，请在`arch/arm/configs`目录中的`defconfig`板文件中添加以下行：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also run `menuconfig` to select it from the UI, run `make` to build
    the kernel, and then `make modules` to build modules (including yours). To make
    the driver built-in, just replace `m` with `y`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以运行`menuconfig`从UI中选择它，运行`make`来构建内核，然后运行`make modules`来构建模块（包括你的模块）。要将驱动程序构建为内核模块，只需将`m`替换为`y`：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Everything described here is what embedded board manufacturers do in order
    to provide a **Board Support Package** (**BSP**) with their board, with a kernel
    that already contains their custom drivers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的内容是嵌入式板制造商为其板提供**板级支持包**（**BSP**）时所做的工作，内核中已经包含了他们自定义的驱动程序：
- en: '![Figure 2.1 – The Packt_dev module in the kernel tree'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 2.1 – 内核树中的Packt_dev模块](#)'
- en: '](img/B17934_02_001.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_02_001.jpg)'
- en: Figure 2.1 – The Packt_dev module in the kernel tree
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 内核树中的Packt_dev模块
- en: Once configured, you can build the kernel with `make`, and build modules with
    `make modules`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，你可以使用`make`构建内核，并使用`make modules`构建模块。
- en: Modules included in the kernel source tree are installed in `/lib/modules/$(unale
    -r)/kernel/`. On your Linux system, it is `/lib/modules/$(uname -r)/kernel/`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在内核源代码树中的模块安装在`/lib/modules/$(uname -r)/kernel/`目录下。在你的Linux系统中，它的路径是`/lib/modules/$(uname
    -r)/kernel/`。
- en: Now that we are familiar with out-of-tree or in-tree kernel module compilation,
    let's see how to handle module behavior adaptation by allowing parameters to be
    passed to this module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了树外或树内内核模块的编译，接下来让我们看看如何通过允许传递参数来调整模块的行为。
- en: Handling module parameters
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理模块参数
- en: 'Similar to a user program, a kernel module can accept arguments from the command
    line. This allows us to dynamically change the behavior of the module according
    to the given parameters, which can help a developer not have to indefinitely change/compile
    the module during a test/debug session. In order to set this up, we should first
    declare the variables that will hold the values of command-line arguments and
    use the `module_param()` macro on each of these. The macro is defined in `include/linux/moduleparam.h`
    (this should be included in the code too – `#include <linux/moduleparam.h>`) as
    follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户程序类似，内核模块可以从命令行接收参数。这使得我们可以根据给定的参数动态地改变模块的行为，这可以帮助开发者在测试/调试会话中不必反复修改和编译模块。为了设置这一点，我们应该首先声明将保存命令行参数值的变量，并对每个变量使用`module_param()`宏。该宏定义在`include/linux/moduleparam.h`中（代码中也应该包含此文件
    – `#include <linux/moduleparam.h>`），如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This macro contains the following elements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏包含以下元素：
- en: '`name`: The name of the variable used as the parameter.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：作为参数使用的变量名称。'
- en: '`type`: The parameter''s type (`bool`, `charp`, `byte`, `short`, `ushort`,
    `int`, `uint`, `long`, and `ulong`), where `charp` stands for *character pointer*.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：参数的类型（`bool`、`charp`、`byte`、`short`、`ushort`、`int`、`uint`、`long`和`ulong`），其中`charp`表示*字符指针*。'
- en: '`perm`: This represents the `/sys/module/<module>/parameters/<param>` file
    permissions. Some of them are `S_IWUSR`, `S_IRUSR`, `S_IXUSR`, `S_IRGRP`, `S_WGRP`,
    and `S_IRUGO`, where the following applies:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perm`：表示`/sys/module/<module>/parameters/<param>`文件的权限。一些常见权限有`S_IWUSR`、`S_IRUSR`、`S_IXUSR`、`S_IRGRP`、`S_WGRP`和`S_IRUGO`，其中适用如下：'
- en: '`S_I` is just a prefix.'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S_I`只是一个前缀。'
- en: '`R` = read, `W` = write, and `X` = execute.'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R` = 读取，`W` = 写入，`X` = 执行。'
- en: '`USR` = user, `GRP` = group, and `UGO` = user, group, and others.'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USR` = 用户，`GRP` = 组，`UGO` = 用户、组和其他人。'
- en: You can eventually use `|` (the `OR` operation) to set multiple permissions.
    If `perm` is `0`, the file parameter in Sysfs will not be created. You should
    use only `S_IRUGO` read-only parameters, which I highly recommend; by OR'ing with
    other properties, you can obtain fine-grained properties.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终可以使用`|`（即`OR`操作）来设置多个权限。如果`perm`为`0`，则不会创建Sysfs中的文件参数。你应该只使用`S_IRUGO`只读参数，我强烈推荐这样做；通过与其他属性进行`OR`操作，你可以获得更细粒度的属性。
- en: 'When using module parameters, `MODULE_PARM_DESC` can be used on a per-parameter
    basis to describe each of them. This macro will populate the module information
    section of each parameter''s description. The following is a sample, from the
    `helloworld-params.c` source file provided with the code repository of this book:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模块参数时，`MODULE_PARM_DESC`可以逐个参数进行使用，用于描述每个参数。此宏会填充每个参数描述的模块信息部分。以下是一个示例，来自本书代码仓库中提供的`helloworld-params.c`源文件：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To load the module and feed our parameter, we do the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载模块并传递我们的参数，我们执行以下操作：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That said, we could have used `modinfo` prior to loading the module in order
    to display a description of parameters supported by the module:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们可以在加载模块之前使用`modinfo`来显示该模块支持的参数描述：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It is also possible to find and edit the current values for the parameters of
    a loaded module from Sysfs in `/sys/module/<name>/parameters`. In that directory,
    there is one file per parameter, containing the parameter value. These parameter
    values can be changed if the associated files have write permissions (which depends
    on the module code).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在`/sys/module/<name>/parameters`中的Sysfs中找到并编辑已加载模块的当前参数值。在该目录中，每个参数都有一个文件，文件中包含参数值。如果相关文件具有写权限，则可以更改这些参数值（这取决于模块代码）。
- en: 'The following is an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Not just loadable kernel modules can accept parameters. Provided that a module
    is built in the kernel, you can specify parameters for this module from the Linux
    kernel command line (the one passed by the bootloader or the one that is provided
    by the `CONFIG_CMDLINE` configuration option).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅是可加载的内核模块可以接受参数。只要模块是内核构建的一部分，你可以通过Linux内核命令行（由引导加载程序传递或由`CONFIG_CMDLINE`配置选项提供）为该模块指定参数。
- en: 'This has the following form:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其形式如下：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, `my_module` corresponds to the module name and `value` is the
    value assigned to this parameter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`my_module`对应于模块名称，`value`是分配给此参数的值。
- en: Now that we are able to deal with module parameters, let's dive a bit deeper
    into a not-so-obvious scenario, where we will learn how the Linux kernel itself
    and its build system handles module dependencies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们能够处理模块参数，让我们深入探讨一个不太明显的场景，在这个场景中，我们将学习Linux内核本身及其构建系统如何处理模块依赖关系。
- en: Dealing with symbol exports and module dependencies
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理符号导出和模块依赖关系
- en: 'Only a limited number of kernel functions can be called from a kernel module.
    To be visible to a kernel module, functions and variables must be explicitly exported
    by the kernel. Thus, the Linux kernel exposes two macros that can be used to export
    functions and variables. These are the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只有有限数量的内核函数可以从内核模块中调用。为了让内核模块能够访问，函数和变量必须由内核显式导出。因此，Linux内核提供了两个宏，用于导出函数和变量。它们分别是：
- en: '`EXPORT_SYMBOL(symbolname)`: This macro exports a function or variable to all
    modules.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_SYMBOL(symbolname)`：此宏将函数或变量导出给所有模块。'
- en: '`EXPORT_SYMBOL_GPL(symbolname)`: This macro exports a function or variable
    only to GPL modules.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_SYMBOL_GPL(symbolname)`：此宏仅将函数或变量导出给GPL模块。'
- en: '`EXPORT_SYMBOL()` or its GPL counterpart are Linux kernel macros that make
    a symbol available to loadable kernel modules or dynamically loaded modules (provided
    that said modules add an `extern` declaration – that is, include the headers corresponding
    to the compilation units that exported the symbols). `EXPORT_SYMBOL()` instructs
    the Kbuild mechanism to include the symbol passed as an argument in the global
    list of kernel symbols. As a result, kernel modules can access them. Code that
    is built into the kernel itself (as opposed to loadable kernel modules) can, of
    course, access any non-static symbol via an extern declaration, as with conventional
    C code.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPORT_SYMBOL()`或其GPL版本是Linux内核宏，使符号对可加载内核模块或动态加载模块可用（前提是这些模块添加了`extern`声明——也就是说，包含了导出符号的编译单元的头文件）。`EXPORT_SYMBOL()`指示Kbuild机制将作为参数传递的符号包含在全局内核符号列表中。结果，内核模块可以访问这些符号。内核本身构建的代码（与可加载的内核模块相对）当然可以通过`extern`声明访问任何非静态符号，就像传统的C代码一样。'
- en: These macros also allow us to export, from loadable kernel modules, symbols
    that can be accessed from other loadable kernel modules. An interesting thing
    is that a symbol thus exported by one module becomes accessible to another module
    that may depend on it! A normal driver should not need any non-exported function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏还允许我们从可加载的内核模块中导出符号，这些符号可以从其他可加载的内核模块访问。有趣的是，一个模块导出的符号会变得对另一个可能依赖于它的模块可访问！正常的驱动程序不应该需要任何未导出的函数。
- en: An introduction to the concept of module dependencies
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块依赖关系概述
- en: A dependency of module B on module A is that module B is using one or more of
    the symbols exported by module A. Let's see in the next section how such dependencies
    are handled in the Linux kernel infrastructure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 模块B对模块A的依赖关系是，模块B使用了模块A导出的一个或多个符号。接下来我们将在下一节中查看Linux内核基础设施如何处理此类依赖关系。
- en: The depmod utility
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: depmod工具
- en: '`depmod` is a tool that you run during the kernel build process to generate
    module dependency files. It does that by reading each module in `/lib/modules/<kernel_release>/`
    to determine what symbols it should export and what symbols it needs. The result
    of that process is written to a `modules.dep` file, and its binary version, `modules.dep.bin`.
    It is a kind of module indexing.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`depmod`是一个工具，你可以在内核构建过程中运行它来生成模块依赖文件。它通过读取`/lib/modules/<kernel_release>/`中的每个模块，确定应该导出哪些符号，以及需要哪些符号。该过程的结果会写入`modules.dep`文件及其二进制版本`modules.dep.bin`。这是一种模块索引。'
- en: Module loading and unloading
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块加载和卸载
- en: For a module to be operational, you should load it into the Linux kernel, either
    by using `insmod` and passing the module path as an argument, which is the preferred
    method during development, or by using `modprobe`, a clever command but which
    is preferable for use in production systems.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个模块能够正常运行，您应该将其加载到Linux内核中，您可以使用`insmod`并将模块路径作为参数传递，这是开发过程中首选的方法，或者使用`modprobe`，这是一个巧妙的命令，但在生产系统中更为推荐使用。
- en: Manual loading
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动加载
- en: Manual loading needs the intervention of a user, which should have `root` access.
    The two classical methods to achieve this are `modprobe` and `insmod`, which are
    described as follows.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 手动加载需要用户干预，该用户应具有`root`权限。实现此目的的两种经典方法是`modprobe`和`insmod`，其具体描述如下。
- en: 'During development, you usually use `insmod` in order to load a module. `insmod`
    should be given the path of the module to load, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，通常使用`insmod`来加载模块。`insmod`应该接收要加载的模块的路径，如下所示：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the low-level form of module loading, which forms the basis of the
    other module-loading method and the one we will use in this book. On the other
    hand, there is `modprobe`, mostly used by system admins or in a production system.
    `modprobe` is a clever command that parses the `modules.dep` file (discussed previously)
    in order to load dependencies first, prior to loading the given module. It automatically
    handles module dependencies, as a package manager does. It is invoked as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块加载的低级形式，它构成了其他模块加载方法的基础，也是本书中将要使用的方法。另一方面，`modprobe`主要由系统管理员或生产系统中使用。`modprobe`是一个巧妙的命令，它解析`modules.dep`文件（前面已经讨论过），以便先加载依赖项，然后再加载给定的模块。它像包管理器一样自动处理模块依赖关系。其调用方式如下：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Whether we can use `modprobe` depends on `depmod` being aware of module installation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是否能够使用`modprobe`取决于`depmod`是否能识别模块的安装。
- en: Auto-loading
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动加载
- en: 'The `depmod` utility doesn''t only build `modules.dep` and `modules.dep.bin`
    files; it does more than that. When kernel developers write drivers, they know
    exactly what hardware the drivers will support. They are then responsible for
    feeding the drivers with the product and vendor IDs of all devices supported by
    the driver. `depmod` also processes module files in order to extract and gather
    that information and generates a `modules.alias` file, located in `/lib/modules/<kernel_release>/modules.alias`,
    which maps devices to their drivers:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`depmod`工具不仅仅构建`modules.dep`和`modules.dep.bin`文件；它的功能远不止此。当内核开发人员编写驱动程序时，他们清楚地知道驱动程序将支持哪些硬件。接着，他们负责为驱动程序提供所有受支持设备的产品ID和供应商ID。`depmod`还处理模块文件，以提取和收集这些信息，并生成`modules.alias`文件，该文件位于`/lib/modules/<kernel_release>/modules.alias`，它将设备与其驱动程序进行映射：'
- en: 'An excerpt of `modules.alias` is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules.alias`的摘录如下：'
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this step, you'll need a user space hotplug agent (or device manager), usually
    `udev` (or `mdev`), that will register with the kernel to get notified when a
    new device appears.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，您需要一个用户空间的热插拔代理（或设备管理器），通常是`udev`（或`mdev`），它将注册到内核以在新设备出现时接收通知。
- en: The notification is done by the kernel, sending the device's description (the
    product ID, the vendor ID, the class, the device class, the device subclass, the
    interface, and any other information that can identify a device) to the hotplug
    daemon, which in turn calls `modprobe` with this information. `modprobe` then
    parses the `modules.alias` file in order to match the driver associated with the
    device. Before loading the module, `modprobe` will look for its dependencies in
    `module.dep`. If it finds any, they will be loaded prior to the associated module
    loading; otherwise, the module is loaded directly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是由内核完成的，它将设备的描述（产品ID、供应商ID、类别、设备类别、设备子类别、接口以及任何其他可以识别设备的信息）发送给热插拔守护进程，该进程根据这些信息调用`modprobe`。然后，`modprobe`解析`modules.alias`文件，以匹配与设备相关的驱动程序。在加载模块之前，`modprobe`会查找`module.dep`中的依赖项。如果发现任何依赖项，它们将在关联模块加载之前加载；否则，模块将直接加载。
- en: 'There is another method for automatically loading a module, at boot time this
    time. This is achieved in `/etc/modules-load.d/<filename>.conf`. If you want some
    modules to be loaded at boot time, just create a `/etc/modules-load.d/<filename>.conf`
    file and add the module names that should be loaded, one per line. `<filename>`
    will be meaningful to you, and people usually use `module`: `/etc/modules-load.d/modules.conf`.
    You can create as many `.conf` files as you need.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以在启动时自动加载模块。这可以通过`/etc/modules-load.d/<filename>.conf`来实现。如果你希望在启动时加载某些模块，只需创建一个`/etc/modules-load.d/<filename>.conf`文件，并按行添加应该加载的模块名称。`<filename>`对你来说是有意义的，通常人们使用`module`：`/etc/modules-load.d/modules.conf`。你可以根据需要创建任意数量的`.conf`文件。
- en: 'An example of `/etc/modules-load.d/mymodules.conf` is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/modules-load.d/mymodules.conf`的示例如下：'
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These configuration files are processed by `systemd-modules-load.service`, provided
    that `systemd` is the initialization manager on your machine. On `SysVinit` systems,
    these files are processed by the `/etc/init.d/kmod` script.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置文件由`systemd-modules-load.service`处理，前提是`systemd`是你机器上的初始化管理器。在`SysVinit`系统中，这些文件由`/etc/init.d/kmod`脚本处理。
- en: Module unloading
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块卸载
- en: 'The usual command to unload a module is `rmmod`. This is preferable to unloading
    a module loaded with the `insmod` command. The command should be given the module
    name to unload as a parameter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载模块的常用命令是`rmmod`。这比卸载使用`insmod`命令加载的模块更为合适。该命令应该传入要卸载的模块名称作为参数：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the other hand, a higher-level command to unload a module in a smart manner
    is `modeprobe –r`, which automatically unloads unused dependencies:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，用于智能卸载模块的更高层命令是`modeprobe –r`，它会自动卸载未使用的依赖：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may have guessed, it is a helpful option for developers. Finally, we
    can check whether a module is loaded with the `lsmod` command, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的，这对开发人员来说是一个有用的选项。最后，我们可以通过`lsmod`命令检查模块是否已加载，命令如下：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output includes the name of the module, the amount of memory it uses, the
    number of other modules that use it, and finally, the name of these. The output
    of `lsmod` is actually a nice formatting view of what you can see under `/proc
    /modules`, which is the file listing loaded modules:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括模块的名称、使用的内存量、其他依赖于它的模块数量，最后是这些模块的名称。`lsmod`的输出实际上是对`/proc /modules`下可见文件的一种良好格式化视图，这是列出已加载模块的文件：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding output is raw and poorly formatted. Therefore, it is preferable
    to use `lsmod`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出是原始且格式较差的，因此更建议使用`lsmod`。
- en: Now that we are familiar with kernel module management, let's extend our kernel
    development skills by learning some tips that kernel developers have adopted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了内核模块管理，让我们通过学习内核开发人员采用的一些技巧，进一步提升我们的内核开发技能。
- en: Learning some Linux kernel programming tips
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习一些Linux内核编程技巧
- en: 'Linux kernel development is about learning from others and not reinventing
    the wheel. There is a set of rules to follow when doing kernel development. A
    whole chapter won''t be enough to cover these rules. Thus, I picked two of the
    most relevant to me, those that are likely to change when programming for user
    space: error handling and message printing.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核开发是从别人那里学习，而不是重新发明轮子。当进行内核开发时，有一套规则需要遵循。单独一章内容不足以涵盖这些规则。因此，我挑选了两条对我来说最为相关的规则，它们在进行用户空间编程时可能会发生变化：错误处理和消息打印。
- en: In user space, exiting from the `main()` method is enough to recover from all
    the errors that may have occurred. In the kernel, this is not the case, especially
    since it directly deals with the hardware. Things are different for message printing
    as well, and we will see that in this section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户空间，退出`main()`方法足以恢复所有可能发生的错误。而在内核中，情况并非如此，尤其是它直接处理硬件。消息打印方面也有所不同，我们将在本节中详细探讨。
- en: Error handling
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Returning the wrong error code for a given error can result in either the kernel
    or user space application misinterpreting and taking the wrong decision, producing
    unneeded behavior. To keep things clear, there are predefined errors in the kernel
    tree that cover almost every case you may face. Some of the errors (with their
    meaning) are defined in `include/uapi/asm-generic/errno-base.h`, and the rest
    of the list can be found in `include/uapi/asm-generic/errno.h`. The following
    is an excerpt of this list of errors, from `include/uapi/asm-generic/errno-base.h`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定错误返回错误代码不正确可能导致内核或用户空间应用程序误解并做出错误决策，从而产生不必要的行为。为了保持清晰，内核树中预定义了几乎涵盖你可能遇到的每种情况的错误。一些错误（及其含义）定义在`include/uapi/asm-generic/errno-base.h`中，其他的列表可以在`include/uapi/asm-generic/errno.h`中找到。以下是该错误列表的摘录，来自`include/uapi/asm-generic/errno-base.h`：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Most of the time, the standard way to return an error is to do so in the form
    of `return –ERROR`, especially when it comes to answering system calls. For example,
    for an I/O error, the error code is `EIO`, and you should return `-EIO`, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，返回错误的标准方式是以`return –ERROR`的形式，特别是在回答系统调用时。例如，对于I/O错误，错误代码是`EIO`，你应该返回`-EIO`，如下所示：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Errors sometimes cross the kernel space and propagate themselves to the user
    space. If the returned error is an answer to a system call (`open`, `read`, `ioctl`,
    or `mmap`), the value will be automatically assigned to the user space `errno`
    global variable, on which you can use `strerror(errno)` to translate the error
    into a readable string:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 错误有时会跨越内核空间并传播到用户空间。如果返回的错误是对系统调用（`open`、`read`、`ioctl`或`mmap`）的响应，值将自动赋给用户空间的`errno`全局变量，之后你可以使用`strerror(errno)`将错误翻译为可读的字符串：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you face an error, you must undo everything that has been set until the
    error occurred. The usual way to do that is to use the `goto` statement:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到错误时，你必须撤销在错误发生之前设置的所有内容。通常的做法是使用`goto`语句：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The reason to use the `goto` statement is simple. When it comes to handling
    errors, let''s say that at *step 5*, you have to clean up the previous operations
    (*steps 4*, *3*, *2*, and *1*), instead of doing lots of nested checking operations,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`goto`语句的原因很简单。当处理错误时，假设在*步骤 5*，你需要清理之前的操作（*步骤 4*、*3*、*2*和*1*），而不是做大量的嵌套检查操作，如下所示：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is less readable, error-prone, and confusing (readability also depends
    on indentation). By using the `goto` statement, we have straight control flow,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可读性差，容易出错且让人困惑（可读性还依赖于缩进）。通过使用`goto`语句，我们可以获得直接的控制流，如下所示：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That said, you should only use `goto` to move forward in a function, not backward,
    nor to implement loops (as is the case in an assembler).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你应该只在函数中向前使用`goto`，而不是向后使用，也不要用它来实现循环（就像在汇编语言中那样）。
- en: Handling null pointer errors
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理空指针错误
- en: 'When it comes to returning an error from functions that are supposed to return
    a pointer, functions often return the `NULL` pointer. It is functional but it
    is a quite meaningless approach, since we do not exactly know why this `NULL`
    pointer is returned. For that purpose, the kernel provides three functions, `ERR_PTR`,
    `IS_ERR`, and `PTR_ERR`, defined as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到从应返回指针的函数中返回错误时，函数通常返回`NULL`指针。这是有效的，但这种方法相当没有意义，因为我们并不完全知道为何返回这个`NULL`指针。为此，内核提供了三个函数，`ERR_PTR`、`IS_ERR`和`PTR_ERR`，其定义如下：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first macro returns the error value as a pointer. It can be seen as an *error
    value to pointer* macro. Given a function that is likely to return `-ENOMEM` after
    a failed memory allocation, we have to do something such as `return ERR_PTR(-ENOMEM);`.
    The second macro is used to check whether the returned value is a pointer error
    using `if(IS_ERR(foo))`. The last one returns the actual error code, `return PTR_ERR(foo)`.
    It can be seen as a *pointer to error value* macro.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个宏将错误值作为指针返回。可以将其视为*错误值到指针*的宏。给定一个在内存分配失败后可能返回`-ENOMEM`的函数，我们必须做类似`return
    ERR_PTR(-ENOMEM);`的操作。第二个宏用于检查返回值是否是指针错误，通过`if(IS_ERR(foo))`进行判断。最后一个宏返回实际的错误代码，`return
    PTR_ERR(foo)`。可以将其视为*指针到错误值*的宏。
- en: 'The following is an example of how to use `ERR_PTR`, `IS_ERR`, and `PTR_ERR`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`ERR_PTR`、`IS_ERR`和`PTR_ERR`的示例：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a plus with error handling, which is also an excerpt of the kernel coding
    style that states that if a function's name is an action or an imperative command,
    the function should return an integer error code. If, however, the function's
    name is a predicate, this function should return a Boolean to indicate the succeeded
    status of the operation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`Add work`, for example, is a command, thus the `add_work()` function returns
    `0` for success or `-EBUSY` for failure. `PCI device present` is a predicate,
    and in the same way, this is why the `pci_dev_present()` function returns `1`
    if it succeeds in finding a matching device or `0` if it doesn''t.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Message printing – goodbye printk, long life dev_*, pr_*, and net_* APIs
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from informing users of what is going on, printing is the first debugging
    technique. `printk()` is to the kernel what `printf()` is to the user space. `printk()`
    has, for a long time, ruled kernel message printing in a leveled manner. Written
    messages can be displayed using the `dmesg` command. Depending on how important
    the message to print was, `printk()` allowed you to choose between eight log-level
    messages, defined in `include/linux/kern_levels.h`, along with their meaning.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, while `printk()` remains the low-level message printing API, the
    printk/log-level pair has been encoded into clearly named helpers, which are recommended
    for use in new drivers. These are as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '`pr_<level>(...)`: This is used in regular modules that are not device drivers.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev_<level>(struct device *dev, ...)`: This is to be used in device drivers
    that are not network devices (also known as `netdev` drivers).'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netdev_<level>(struct net_device *dev, ...)`: This is used in `netdev` drivers
    exclusively.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In all these helpers, `<level>` represents the log level encoded into a quite
    meaningful name, as described in the following table:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – The Linux kernel printing API'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17934_02_Table_1.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – The Linux kernel printing API
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Log levels work in a way that, whenever a message is printed, the kernel compares
    the message log level with the current console log level; if the former is higher
    (lower value) than the last, the message will be immediately printed to the console.
    You can check your log-level parameters with the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding output, the first value is the current log level (`4`). According
    to that, any message printed with higher importance (a lower log level) will be
    displayed in the console as well. The second value is the default log level, according
    to the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL` option. Other values are not relevant
    for the purpose of this chapter, so let's ignore them.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The current log level can be changed with the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In addition, you can prefix the module output messages with a custom string.
    To achieve this, you should define the `pr_fmt` macro. It is common to define
    this message prefix with the module name, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For more concise log output, some overrides use the current function name as
    a prefix, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更简洁的日志输出，一些重写函数使用当前函数名称作为前缀，如下所示：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we consider the `net/bluetooth/lib.c` file in the kernel source tree, we
    can see the following in the first line:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑内核源代码树中的`net/bluetooth/lib.c`文件，可以看到第一行有以下内容：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With that line, any `pr_<level>` (we are in a regular module, not a device
    driver) logging call will produce a log prefixed with `Bluetooth:`, similar to
    the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一行，任何`pr_<level>`（我们在一个常规模块中，而不是设备驱动程序）日志调用都会生成一个以`Bluetooth:`为前缀的日志，类似于以下内容：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is all about message printing. We have learned how to choose and use the
    appropriate printing APIs according to the situation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是关于消息打印的。我们已经学习了如何根据情况选择和使用合适的打印 API。
- en: We are now done with our kernel module introduction series. At this stage, you
    should be able to download, configure, and (cross-)compile the Linux kernel, as
    well as write and build kernel modules against this kernel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了内核模块介绍系列。在这个阶段，你应该能够下载、配置并（交叉）编译 Linux 内核，以及编写和构建针对该内核的内核模块。
- en: Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`printk()` (or its encoded helpers) never blocks and is safe enough to be called
    even from atomic contexts. It tries to lock the console and print the message.
    If locking fails, the output will be written into a buffer and the function will
    return, never blocking. The current console holder will then be notified about
    new messages and will print them before releasing the console.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`printk()`（或其编码的辅助函数）永远不会阻塞，并且足够安全，即使在原子上下文中也可以调用。它尝试锁定控制台并打印消息。如果锁定失败，输出将被写入缓冲区，函数将返回，永不阻塞。当前控制台持有者随后会被通知到有新消息，并在释放控制台之前打印这些消息。'
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter showed the basics of driver development and explained the concept
    of built-in and loadable kernel modules, as well as their loading and unloading.
    Even if you are not able to interact with the user space, you are ready to write
    a working module, print formatted messages, and understand the concept of `init`/`exit`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了驱动开发的基础知识，并解释了内置内核模块和可加载内核模块的概念，以及它们的加载与卸载。即使你不能与用户空间进行交互，你也已经准备好编写一个工作模块，打印格式化的消息，并理解`init`/`exit`的概念。
- en: The next chapter will deal with Linux kernel core functions, which, along with
    this chapter, form the Swiss army knife of Linux kernel development. In the next
    chapter, you will be able to target enhanced features, perform fancy operations
    that can impact the system, and interact with the core of the Linux kernel.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论 Linux 内核核心功能，它与本章一起构成了 Linux 内核开发的瑞士军刀。在下一章中，你将能够针对增强功能，执行可能影响系统的复杂操作，并与
    Linux 内核的核心进行交互。
