<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Installing an Operating System</h1></div></div></div><p>Having a Cubieboard is only useful if you can actually use it and eventually develop and/or play with it. The preinstalled OS might or might not be adequate for this. Very often, Android is preinstalled on these devices, as the SoC used is usually found in Android devices, and the manufacturer mostly or only supports it. While BSD or Minix are also operating systems that are being developed by various developers, this book will limit itself to Linux as an operating system. The first few sections of this chapter will dig a little deeper into the concepts for educational purposes.</p><p>This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Finding out where the SoC chip decides to boot from</li><li class="listitem" style="list-style-type: disc">The difference between an OS image and a clean install</li><li class="listitem" style="list-style-type: disc">Downloading and installing Fedora</li><li class="listitem" style="list-style-type: disc">Booting the freshly installed OS from an SD card</li><li class="listitem" style="list-style-type: disc">The basic concepts on using Fedora and connecting to a wired network</li><li class="listitem" style="list-style-type: disc">Maintaining Fedora via the Package Manager</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec14"/>Booting the Cubieboard</h1></div></div></div><p>While it <a id="id71" class="indexterm"/>might <a id="id72" class="indexterm"/>seem natural that the system simply boots, there is a lot more to it. The Allwinner series of SoCs has something called a <strong>Boot Read Only Memory</strong> (<strong>BROM</strong>). The BROM<a id="id73" class="indexterm"/> is really a small program embedded into the chip itself that always gets executed first. This program has a few drivers for a minimal set of hardware to ensure that it is small and simple.</p><p>First, the BROM will try to find a valid bootloader on the first SD card, also called the MMC slot. If nothing is found there, the NAND is checked for a valid bootloader. Again, if nothing is found there, the second MMC slot is checked. If nothing is found there either, the first SPI bus is probed for an SPI memory flash chip and checked for a valid bootloader. Finally, if all of the preceding methods fail, the FEL mode is entered. The FEL mode is a recovery mode where it is possible to upload a piece of code over a USB connection and <a id="id74" class="indexterm"/>execute it. This can be useful to recover a board when it fails to boot and the first MMC slot is not available to boot from. The FEL mode does not have to be initiated. One might wonder why two MMC slots are being probed. Sometimes, manufacturers include <a id="id75" class="indexterm"/>an embedded MMC chip, or eMMC, in their design, which unlike an SD or MMC card looks like a regular chip, similar to a NAND flash chip, but behaves and looks like an MMC card. By probing the two MMC slots, you can have a board that uses an eMMC chip on the board while still having the first MMC slot available for use cases such as boot recovery. The Cubietruck is available with various combinations of these storage options.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec15"/>OS image installation background</h1></div></div></div><p>Many sites <a id="id76" class="indexterm"/>and forums on the Internet speak of firmware or ROMs when talking about an installation for an embedded device. It all sounds very mysterious initially, but this is far from the truth. A ROM is nothing more than a full disk image, which, in turn, can be written to storage, which the board can boot from. The name <em>ROM</em> is derived from the fact that the data used to be stored in a ROM chip. Many of the OS images that can be found for Allwinner development boards are tailored to a very specific board. This is not surprising, as the chip used might be the same on a range of boards, but certain attached peripherals might be completely different; one board may have different memory chips for example. Another board might not have an onboard flash and rely completely on the secondary MMC slot for its OS. It is almost impossible to have a single disk image that works on all these different combinations of hardware, and thus a clean installation sounds like quite a sensible approach. While distributions are slowly starting to support the ARM-based systems, it is still not easy to have a common installer that can install the distribution to any ARM-based board. To bridge these worlds, a few linux-sunxi community members and Red Hat employees have developed a hybrid installation of Fedora, where a generic image is downloaded, configured, and finally launched in the installer.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Getting and preparing Fedora</h1></div></div></div><p>There have been several releases of Fedora for the A10, A10S, A13, and A20 series of SoCs. As this book focuses on the most recent version, Fedora 20-r1, the latest version is recommended. Additionally, if fails, Fedora 20-r1 can be written to an SD card, which can be used as a<a id="id77" class="indexterm"/> recovery boot disk. The first step in this endeavor is to download this disk image. About 2 GB of free disk space is required.</p><p>Fedora for this chapter can be downloaded from the Packt Publishing website in the <strong>Help &amp; Support</strong> section of the book's <strong>Support</strong> page.</p><p>The next few steps assume that there is a Linux computer available. If this is not the case, the preinstalled OS on the Cubieboard can also be used; while a little bit trickier, it should be quite <a id="id78" class="indexterm"/>possible. If the preinstalled OS is Android, then a terminal application will be required that might not be installed. Do note that on Mac OSX, the device path names will be different. Finally, a virtual machine can also be used, but a detailed explanation of that is out of the scope of this book.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Mac OSX uses device nodes that are similar to Linux but slightly different. For example, the second partition on an inserted USB stick can be called at <code class="literal">/dev/sdb2</code> on Linux, where on OSX however, this would translate to <code class="literal">/dev/disk2s2</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Writing the OS image to the SD card</h1></div></div></div><p>First, the<a id="id79" class="indexterm"/> image <a id="id80" class="indexterm"/>needs to be written to a microSD card that is at least 4 GiB in size.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The next few steps will delete all the content on the SD card.</p></div></div><p>The microSD card should be connected to the PC. If there is no card reader available, a USB to microSD card reader can be used instead. The <code class="literal">xzcat</code> command<a id="id81" class="indexterm"/> is used to decompress the downloaded <code class="literal">xz-compressed</code> archive onto the SD card.</p><p>In the following example, it is assumed that the microSD card is inserted into a USB card reader and has been assigned the device node, <code class="literal">/dev/sdd</code>. It is up to the reader to determine the proper device node on the system, but <code class="literal">dmesg</code> or one of the installed graphical disk utilities can provide an answer here. An example output with the SD card found on the device node <code class="literal">/dev/sdd</code> is as follows:</p><div><pre class="programlisting">
<strong>usb 2-5: new high-speed USB device number 14 using ehci-pci</strong>
<strong>usb 2-5: New USB device found, idVendor=14cd, idProduct=8123</strong>
<strong>usb 2-5: New USB device strings: Mfr=1, Product=3, SerialNumber=2</strong>
<strong>usb 2-5: Product: USB 2.0  SD MMC READER</strong>
<strong>usb 2-5: Manufacturer: SDMMC MA8123</strong>
<strong>usb 2-5: SerialNumber: 312811122181</strong>
<strong>usb-storage 2-5:1.0: USB Mass Storage device detected</strong>
<strong>scsi14 : usb-storage 2-5:1.0</strong>
<strong>scsi 14:0:0:0: Direct-Access     USB 2.0  SD MMC Reader         PQ: 0 ANSI: 0 CCS</strong>
<strong>sd 14:0:0:0: [sdd] 248320 512-byte logical blocks: (127 MB/121 MiB)</strong>
<strong>sd 14:0:0:0: [sdd] Write Protect is off</strong>
<strong>sd 14:0:0:0: [sdd] Mode Sense: 03 00 00 00</strong>
<strong>sd 14:0:0:0: [sdd] No Caching mode page found</strong>
<strong>sd 14:0:0:0: [sdd] Assuming drive cache: write through</strong>
<strong>sd 14:0:0:0: [sdd] No Caching mode page found</strong>
<strong>sd 14:0:0:0: [sdd] Assuming drive cache: write through</strong>
<strong> sdd: sdd1</strong>
<strong>sd 14:0:0:0: [sdd] No Caching mode page found</strong>
<strong>sd 14:0:0:0: [sdd] Assuming drive cache: write through</strong>
<strong>sd 14:0:0:0: [sdd] Attached SCSI removable disk</strong>
</pre></div><p>This <a id="id82" class="indexterm"/>command might require root privileges; to do so, prefix <code class="literal">dmesg</code> with <code class="literal">sudo</code>. The filename used here should match the file downloaded. A cache-flush via the <code class="literal">sync</code> command is forced upon successful completion. Flushing the cache is important so that we <a id="id83" class="indexterm"/>know all the data that has actually been written to the SD card and it is not held up in the cache. This process might take quite a while—10 minutes is commonly reported commonly reported. The following command is an example of writing the image to an SD card and flushing the cache:</p><div><pre class="programlisting">
<strong>root@packt:~# xzcat Fedora-Xfce-armhfp-20-a10-1-sda.img.xz &gt; /dev/sdd &amp;&amp; sync</strong>
</pre></div><p>Writing the OS image should be possible on Linux, OSX, the BSDs, Solaris, and many modern POSIX-based systems. On Windows, a little more care is required. A program such as 7-Zip can be used to decompress the image, and an image writer such as WinDD can be used instead.</p><p>When done, remove the USB device and reinsert it to force re-reading of the SD card's partition table. Opening a file manager will, in most cases, show the newly created partitions on the SD card, one named <code class="literal">u-boot</code> and the other <code class="literal">rootfs</code>.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec11"/>Writing the bootloader</h2></div></div></div><p>The bootloader <a id="id84" class="indexterm"/>is very device-specific and can even vary between production runs of the same board. This is because the memory initialization is performed by the bootloader and thus can be different. To do this, a setup script is preinstalled in addition to several bootloaders and several kernels for the various generations of SoCs. This <a id="id85" class="indexterm"/>script needs to be executed from the partition labeled <code class="literal">u-boot</code> on the microSD card. If the currently running OS mounts the partitions automatically, the <code class="literal">mount</code> command can be used to find the mount point, as follows:</p><div><pre class="programlisting">
<strong>[root@packt:~]# mount</strong>
<strong>/dev/sdd1 on /media/u-boot type ext2 (rw,errors=remount-ro)</strong>
</pre></div><p>In the preceding example, the microSD card is mounted on <code class="literal">/media/u-boot</code>, and the setup script should be run from there. This path should be adjusted as needed. The following is an example showing a sample output of the available boards. The bootloader is being installed using the Cubietruck. It may be required to prefix the command with <code class="literal">bash</code> to force <code class="literal">bash</code> to execute the script.</p><div><pre class="programlisting">
<strong>[root@packt:~]# bash /media/u-boot/select-board.sh</strong>
</pre></div><p>If no Linux system is available, the setup script should be able to run from within the native Android. However, an ADB or a terminal application will be required.</p><p>This will now provide a list of supported boards. Find the exact board being used, and run the command again with the selected board as the parameter. Note that only a small selection will be displayed, as shown in the following screenshot:</p><div><img src="img/1572OS_03_01.jpg" alt="Writing the bootloader"/></div><p>After setting up the board, unmount the microSD card <a id="id86" class="indexterm"/>followed by a sync to ensure all the data is written properly. Let us take a look at the following command:</p><div><pre class="programlisting">
<strong>[root@packt:~]# umount /dev/sdd1 &amp;&amp; eject /dev/sdd1 &amp;&amp; sync</strong>
</pre></div><p>Depending on the environment that this script is being run on, a graphical version can be launched instead; the idea, however, is identical: choose the correct board and the script will write the image to the correct place.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Finishing the operating system installation</h1></div></div></div><p>Connect a monitor, USB keyboard, and <a id="id87" class="indexterm"/>USB mouse, and insert the microSD card into the Cubieboard. Each board has a default output configured upon the first boot. For many headless boards, this will be the HDMI port. For tablets or systems with LCD screens, it will be the LCD screen. While not strictly required, connecting the UART, as mentioned in the previous chapter, can be helpful in case things go wrong, as shown in the following screenshot:</p><div><img src="img/1572OS_03_02.jpg" alt="Finishing the operating system installation"/></div><p>Applying power will boot the device, and after a few minutes and a few intentional reboots to resize <a id="id88" class="indexterm"/>the partition on the SD card, the Fedora installer should pop up. If there is no output on the monitor, refer to <a class="link" href="apd.html" title="Appendix D. Troubleshooting the Common Pitfalls">Appendix D</a>, <em>Troubleshooting the Common Pitfalls</em>. Also, refer to the following screenshot to see Fedora's first graphical installer screen:</p><div><img src="img/1572OS_03_03.jpg" alt="Finishing the operating system installation"/></div><p>If a mouse or, at least, a keyboard is connected, various parameters for the system can be set up. Verify <a id="id89" class="indexterm"/>that at least the time zone is correct, and set up a password for the root user. Also, a new user should be created for regular use of the system, as shown in the following screenshot:</p><div><img src="img/1572OS_03_04.jpg" alt="Finishing the operating system installation"/></div><p>After creating a user and finishing the installation and a short reboot, a login screen should appear, allowing <a id="id90" class="indexterm"/>the newly created user to log in. It is now possible to log in to the desktop, as you can see in the following screenshot:</p><div><img src="img/1572OS_03_05.jpg" alt="Finishing the operating system installation"/></div><p>The desktop environment that will be encountered is called <a id="id91" class="indexterm"/>
<strong>Xfce4</strong>, where the letters only have a historic meaning, and the number indicates the version. Version 4 has been in active development <a id="id92" class="indexterm"/>since 2003. Xfce4 is a very lightweight desktop environment and is the default for Fedora on ARM to keep the strain light on the available system resources. Xfce4 might ask the new user a question or two on how the desktop should appear, but the default settings should work fine and were used in this example as well. Feel free to explore this new desktop, launch some applications, or just browse the Internet. Refer to the following screenshot to see the default desktop:</p><div><img src="img/1572OS_03_06.jpg" alt="Finishing the operating system installation"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Precautionary measures for installing updates</h1></div></div></div><p>While<a id="id93" class="indexterm"/> there is a perfectly usable desktop environment now, one of the very common tasks is to keep the OS up-to-date and thus secure. Fedora comes with a graphical frontend to the Yum command-line tool called <a id="id94" class="indexterm"/>
<strong>Yum Extender</strong>. Before going there, however, a warning needs to be issued. At this point, Fedora, like all other distributions, does not officially support the Allwinner range of SoCs. This has one major drawback when updating the OS. The updater, be it Yum or Yum Extender, will also try to update the kernel and bootloader configuration.</p><p>At the time of writing this book, the Fedora 20-r1 release will try to update the kernel and bootloader configuration, causing an unbootable device. However, it can easily be fixed by inserting the SD card into a working system and running the <code class="literal">select-device.sh</code> script as before. To prevent this corruption, edit the file at the <code class="literal">/etc/yum.conf</code> location, and add the following line to that file, which will force Yum to ignore any kernel updates:</p><div><pre class="programlisting">
<strong>exclude kernel*</strong>
</pre></div><p>The kernel exclusion should be added to any recent release of Fedora because it might not be applicable to the later versions.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Since the kernel and bootloader live in their own partition, not having the <code class="literal">u-boot</code> partition mounted can avoid the need to update the bootloader and kernel. In the next chapter, the reader will be able to edit his/her <code class="literal">fstab</code> file without any difficulty.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Maintaining the OS and installing updates</h1></div></div></div><p>As mentioned <a id="id95" class="indexterm"/>before, the Yum Extender <a id="id96" class="indexterm"/>can be used conveniently from the GUI to update the system or install new packages. The Yum Extender can be found under the <strong>Administration</strong> tab in <strong>Applications Menu</strong>, as shown in the following screenshot:</p><div><img src="img/1572OS_03_07.jpg" alt="Maintaining the OS and installing updates"/></div><p>As the Yum Extender is an administrator's application, the current user will have to authorize its use. Assuming this, the user will be granted administrative privileges. The first user of the system will have these privileges. Refer to the following screenshot for a view of <strong>Yum Extender</strong>:</p><div><img src="img/1572OS_03_08.jpg" alt="Maintaining the OS and installing updates"/></div><p>Clicking on the <strong>Select All</strong> button followed by <strong>Apply</strong> will start installing all the new updates to the <a id="id97" class="indexterm"/>system. Depending on the <code class="literal">speed</code> class of the SD card, this can take a long time. While preparing the illustrations for this chapter on an 8 GB class 4 SD card, the process took 5 minutes short of 6 hours. Thus, it is recommended to use at least a class 10 or a better SD card. While using the OS, a class 4 card, even though slow, is usable however.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>It might be wise to hold out updating the SD card for a Friday evening, for example, where the process can take all weekend without bothering anybody.</p></div></div><p>If a warning, as illustrated in the following screenshot, appears during the update process, it is safe to accept it. It is a notification to import a missing GPG key. In this case, it was sanctioned by the Fedora project as can be seen in the e-mail address used. This message may come up early in the update process, in the first 10 minutes or so.</p><div><img src="img/1572OS_03_09.jpg" alt="Maintaining the OS and installing updates"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Adding more software to the OS</h1></div></div></div><p>Installing additional<a id="id98" class="indexterm"/> software is very easy thanks to Package Managers that have been present in Linux distributions for years. The Yum Extender can not only be used to update the OS, but also to add new software to the system, as seen in the following screenshot, which demonstrates Firefox being installed. Optionally, the command-line version, yum, can be used instead.</p><div><img src="img/1572OS_03_10.jpg" alt="Adding more software to the OS"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>Having gone through this chapter, you should have no problem creating a fresh SD card with a full Xfce4-based Fedora operating system. Also, keeping it up-to-date and adding new software should not be a problem at all. All thanks to a hybrid-disk image of Fedora!</p><p>The next chapter will do an installation in a more in-depth fashion manually and focus more on a command line-based interface, as this is often used on server setups, embedded systems, and so on. An entire installation will be performed manually from scratch to learn how to create a customized system.</p></div></body></html>