- en: Have a Good Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating with `cat`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing back terminal sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files and file listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with `xargs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translating with `tr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checksum and verification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptographic tools and hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting unique and duplicate lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary file naming and random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting files and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slicing filenames based on extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming and moving files in bulk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spell–checking and dictionary manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating interactive input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making commands quicker by running parallel processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining a directory, files and subdirectories in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix-like systems have the best command-line tools. Each command performs a
    simple function to make our work easier. These simple functions can be combined
    with other commands to solve complex problems. Combining simple commands is an
    art; you will get better at it as you practice and gain experience. This chapter
    introduces some of the most interesting and useful commands, including `grep`,
    `awk`, `sed`, and `find`.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating with cat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cat` command displays or concatenates the contents of a file, but `cat`
    is capable of more. For example, `cat` can combine standard input data with data
    from a file. One way of combining the `stdin` data with file data is to redirect
    `stdin` to a file and then append two files. The `cat` command can do this in
    a single invocation. The next recipes show basic and advanced usages of `cat`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cat` command is a simple and frequently used command and it stands for
    **conCATenate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of `cat` for reading contents is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command concatenates data from the files specified as command-line arguments
    and sends that data to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print contents of a single file, execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To print contents of more than one file, execute the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command not only reads from files and concatenates the data but also
    reads from the standard input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipe operator redirects data to the cat command''s standard input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command can also concatenate content from files with input from a
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine `stdin` and data from another file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `-` acts as the filename for the `stdin` text.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cat` command has many other options for viewing files. You can view the
    complete list by typing `man cat` in a terminal session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting rid of extra blank lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some text files contain two or more blank lines together. If you need to remove
    the extra blank lines, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can remove all blank lines with `tr`, as discussed in the *Translating with
    tr* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying tabs as ^I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is hard to distinguish tabs and repeated space characters. Languages such
    as Python may treat tabs and spaces differently. Mixtures of tabs and spaces may
    look similar in an editor, but appear as different indentations to the interpreter.
    It is difficult to identify the difference between tabs and spaces when viewing
    a file in a text editor. `cat` can also identify tabs. This helps you to debug
    indentation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cat` command''s `-T` option displays tab characters as `^I`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Line numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The cat command''s `-n` flag prefixes a line number to each line. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command never changes a file. It sends output to `stdout` after modifying
    the input according to the options. Do not attempt to use redirection to overwrite
    your input file. The shell creates the new output file before it opens the input
    file. The `cat` command will not let you use the same file as input and redirected
    output. Trying to trick `cat` with a pipe and redirecting the output will empty
    the input file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` option generates line numbers for all lines, including blank lines.
    If you want to skip numbering blank lines, use the `-b` option.
  prefs: []
  type: TYPE_NORMAL
- en: Recording and playing back terminal sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recording a screen session as a video is useful, but a video is an overkill
    for debugging terminal sessions or providing a shell tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: The shell provides another option. The `script` command records your keystrokes
    and the timing of keystrokes as you type, and saves your input and the resulting
    output in a pair of files. The `scriptreplay` command will replay the session.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `script` and `scriptreplay` commands are available in most GNU/Linux distributions.
    You can create tutorials of command-line hacks and tricks by recording the terminal
    sessions. You can also share the recorded files for others to playback and see
    how to perform a particular task with the command line. You can even invoke other
    interpreters and record the keystrokes sent to that interpreter. You cannot record
    vi, emacs, or other applications that map characters to particular locations on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start recording the terminal session with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A full example looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that this recipe will not work with shells that do not support redirecting
    only `stderr` to a file, such as the `csh` shell.
  prefs: []
  type: TYPE_NORMAL
- en: The `script` command accepts a filename as an argument. This file will hold
    the keystrokes and the command results. When you use the `-t` option, the script
    command sends timing data to `stdout`. The timing data can be redirected to a
    file (`timing.log`), which records the timing info for each keystroke and output.
    The previous example used `2>` to redirect `stderr` to `timing.log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the two files, `timing.log` and `output.session`, we can replay the sequence
    of command execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often record desktop videos to prepare tutorials. However, videos require
    a considerable amount of storage, while a terminal script file is just a text
    file, usually only in the order of kilobytes.
  prefs: []
  type: TYPE_NORMAL
- en: You can share the `timing.log` and `output.session` files to anyone who wants
    to replay a terminal session in their terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Finding files and file listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` command is one of the great utilities in the Unix/Linux command-line
    toolbox. It is useful both at the command line and in shell scripts. Like `cat`
    and `ls`, `find` has many features, and most people do not use it to its fullest.
    This recipe deals with some common ways to utilize `find` to locate files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find` command uses the following strategy:  `find` descends through a
    hierarchy of files, matches files that meet the specified criteria, and performs
    some actions. The default action is to print the names of files and folders, which
    can be specified with the `-print` option.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To list all the files and folders descending from a given directory, use this
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `base_path` can be any location from which `find` should start descending
    (for example, `/home/slynux/`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `.` specifies the current directory and `..` specifies the parent directory.
    This convention is followed throughout the Unix filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The print option separates each file or folder name with a `\n` (newline).
    The `-print0` option separates each name with a null character `''\0''`. The main
    use for `-print0` is to pass filenames containing newlines or whitespace characters
    to the `xargs` command. The `xargs` command will be discussed in more detail later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples demonstrated using `find` to list all the files and folders
    in a filesystem hierarchy. The `find` command can select files based on glob or
    regular expression rules, depth in the filesystem tree, date, type of file, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Search based on name or regular expression match
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `-name` argument specifies a selection pattern for the name. The `-name`
    argument accepts both glob-style wildcards and regular expressions. In the following
    example, `'*.txt'` matches all the file or folder names ending with `.txt` and
    prints them.
  prefs: []
  type: TYPE_NORMAL
- en: Note the single quotes around `*.txt`. The shell will expand glob wildcards
    with no quotes or using double-quotes (`"`). The single quotes prevent the shell
    from expanding the `*.txt` and passes that string to the `find` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command has an option `-iname` (ignore case), which is similar to
    `-name`, but it matches filenames regardless of case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command supports logical operations with the selection options. The
      `-a`  and     `-and` options perform a logical **AND**, while the `-o` and `-or`
    option perform a logical **OR**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will print all the `.txt` and `.pdf` files, since the `find`
    command matches both `.txt` and `.pdf` files. `\(` and `\)` are used to treat
    `-name "*.txt" -o -name "*.pdf"` as a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: The following command demonstrates using the `-and` operator to select only
    the file that starts with an `s` and has an `e` in the name somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `-path` argument restricts the match to files that match a path as well
    as a name. For example, `$ find /home/users -path '*/slynux/*' -name '*.txt' -print`
    will find `/home/users/slynux/readme.txt`, but not `/home/users/slynux.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The `-regex` argument is similar to `-path`, but `-regex` matches the file paths
    based on regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are more complex than glob wildcards and support more precise
    pattern matching. A typical example of text matching with regular expressions
    is to recognize all e-mail addresses. An e-mail address takes the `name@host.root`
    form. It can be generalized as `[a-z0-9]+@[a-z0-9]+\.[a-z0-9]+`. The characters
    inside the square brackets represent a set of characters. In this case, `a-z`
    and `0-9` The `+` sign signifies that the previous class of characters can occur
    one or more times. A period is a single character wildcard (like a `?` in glob
    wildcards), so it must be escaped with a backslash to match an actual dot in the
    e-mail address. So, this regular expression translates to 'a sequence of letters
    or numbers, followed by an `@`, followed by a sequence of letters or numbers,
    followed by a period, and ending with a sequence of letters or numbers'. See the
    *Using regular expressions * recipe in [Chapter 4](22424a9e-fea7-49de-9589-ea32aeb0b829.xhtml),
    *Texting and Driving  *for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command matches the `.py` or `.sh` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `-iregex` option ignores the case for regular expression matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Negating arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find` command can also exclude things that match a pattern using `!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will match all the files whose names do not end in `.txt`. The following
    example shows the result of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Searching based on the directory depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` command walks through all the subdirectories until it reaches the
    bottom of each subdirectory tree. By default, the `find` command will not follow
    symbolic links. The `-L` option will force it to follow symbolic links. If a link
    references a link that points to the original, `find` will be stuck in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `-maxdepth` and `-mindepth` parameters restrict how far the `find` command
    will traverse. This will break the `find` command from an otherwise infinite search.
  prefs: []
  type: TYPE_NORMAL
- en: The `/proc` filesystem contains information about your system and running tasks.
    The folder hierarchy for a task is quite deep and includes symbolic links that
    loop back on themselves. Each process running your system has an entry in `proc`,
    named for the process ID. Under each process ID is a folder called `cwd`, which
    is a link to that task's current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to list all the tasks that are running in a
    folder with a file named `bundlemaker.def`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `-L` option tells the `find` command to follow symbolic links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/proc` is a folder to start searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-maxdepth 3` option limits the search to only the current folder, not subfolders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-name 'bundlemaker.def'` option is the file to search for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `2>/dev/null` redirects error messages about recursive loops to the null
    device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-mindepth` option is similar to `-maxdepth`, but it sets the minimum depth
    for which `find` will report matches. It can be used to find and print files that
    are located with a minimum level of depth from the base path. For example, to
    print all files whose names begin with `f` and that are at least two subdirectories
    distant from the current directory, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Files with names starting with `f` in the current directory or in `dir1` and
    `dir3` will not be printed.
  prefs: []
  type: TYPE_NORMAL
- en: The `-maxdepth` and `-mindepth` option should be early in the `find` command.
    If they are specified as later arguments, it may affect the efficiency of `find`
    as it has to do unnecessary checks. For example, if `-maxdepth` is specified after
    a `-type` argument, the `find` command will first find the files having the specified
    `-type` and then filter out the files that don't match the proper depth. However,
    if the depth was specified before the `-type`, `find` will collect the files having
    the specified depth and then check for the file type, which is the most efficient
    way to search.
  prefs: []
  type: TYPE_NORMAL
- en: Searching based on file type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix-like operating systems treat every object as a file. There are different
    kinds of file, such as regular files, directory, character devices, block devices,
    symlinks, hardlinks, sockets, FIFO, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The `find` command filters the file search with the `-type` option. Using `-type`,
    we can tell the `find` command to match only files of a specified type.
  prefs: []
  type: TYPE_NORMAL
- en: 'List only directories including descendants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It is hard to list directories and files separately. But `find` helps to do
    it. List only regular files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'List only symbolic links as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the types and arguments `find` recognizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **File type** | **Type argument** |'
  prefs: []
  type: TYPE_TB
- en: '| Regular file | `f` |'
  prefs: []
  type: TYPE_TB
- en: '| Symbolic link | `l` |'
  prefs: []
  type: TYPE_TB
- en: '| Directory | `d` |'
  prefs: []
  type: TYPE_TB
- en: '| Character special device | `c` |'
  prefs: []
  type: TYPE_TB
- en: '| Block device | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| Socket | `s` |'
  prefs: []
  type: TYPE_TB
- en: '| FIFO | `p` |'
  prefs: []
  type: TYPE_TB
- en: Searching by file timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unix/Linux filesystems have three types of timestamp on each file. They are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access time** (`-atime`): The timestamp when the file was last accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modification time** (`-mtime`): The timestamp when the file was last modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change time** (`-ctime`): The timestamp when the metadata for a file (such
    as permissions or ownership) was last modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix does not store file creation time by default; however, some filesystems
    (`ufs2`, `ext4`, `zfs`, `btrfs`, `jfs`) save the creation time. The creation time
    can be accessed with the stat command.
  prefs: []
  type: TYPE_NORMAL
- en: Given that some applications modify a file by creating a new file and then deleting
    the original, the creation date may not be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: The `-atime`, `-mtime`, and `-ctime` option are the time parameter options available
    with `find`. They can be specified with integer values in *number of days*. The
    number may be prefixed with `-` or `+` signs. The `-` sign implies less than,
    whereas the `+` sign implies greater than.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print files that were accessed within the last seven days:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Print files that have an access time exactly seven days old:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Print files that have an access time older than seven days:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `-mtime` parameter will search for files based on the modification time;
    `-ctime` searches based on the change time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-atime`, `-mtime`, and `-ctime` use time measured in days. The `find`
    command also supports options that measure in minutes. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-amin` (access time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-mmin` (modification time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-cmin` (change time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To print all the files that have an access time older than seven minutes, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `-newer` option specifies a reference file with a modification time that
    will be used to select files modified more recently than the reference file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find all the files that were modified more recently than `file.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command's timestamp flags are useful for writing backup and maintenance
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Searching based on file size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the file sizes of the files, a search can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of `k`, we can use these different size units:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b`: 512 byte blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: Bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Two-byte words'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k`: Kilobytes (1,024 bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M`: Megabytes (1,024 kilobytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`G`: Gigabytes (1,024 megabytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching based on file permissions and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to match files based on the file permissions. We can list out
    the files with specified file permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `-perm` option specifies that `find` should only match files with their
    permission set to a particular value. Permissions are explained in more detail
    in the *Working with file permissions, ownership, **and the sticky bit * recipe
    in Chapter 3, *File In, File Out*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example usage case, we can consider the case of the Apache web server.
    The PHP files in the web server require proper permissions to execute. We can
    find PHP files that don''t have proper executing permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can also search files based on ownership. The files owned by a specific user
    can be found with the `-user USER` option.
  prefs: []
  type: TYPE_NORMAL
- en: The `USER` argument can be a username or UID.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print a list of all files owned by the `slynux` user, you can
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Performing actions on files with find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The find command can perform actions on the files it identifies. You can delete
    files, or execute an arbitrary Linux command on the files.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting based on file matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `find` command''s `-delete` flag removes files that are matched instead
    of displaying them. Remove the `.swp` files from the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Executing a command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` command can be coupled with many of the other commands using the
    `-exec` option.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the previous example. We used `-perm` to find files that do not have
    proper permissions. Similarly, in the case where we need to change the ownership
    of all files owned by a certain user (for example, `root`) to another user (for
    example, `www-data`, the default Apache user in the web server), we can find all
    the files owned by `root` using the `-user` option and use `-exec` to perform
    the ownership change operation.
  prefs: []
  type: TYPE_NORMAL
- en: You must run the `find` command as root if you want to change the ownership
    of files or directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find` command uses an open/close curly brace pair `{}` to represent the
    filename. In the next example, each time `find` identifies a file it will replace
    the `{}` with the filename and change the ownership of the file. For example,
    if the `find` command finds two files with the `root` owner it will change both
    so they''re owned by `slynux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the command is terminated with `\;`. The semicolon must be escaped
    or it will be grabbed by your command shell as the end of the `find` command instead
    of the end of the `chown` command.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a command for each file is a lot of overhead. If the command accepts
    multiple arguments (as `chown` does) you can terminate the command with a plus
    (`+`) instead of a semicolon. The plus causes `find` to make a list of all the
    files that match the search parameter and execute the application once with all
    the files on a single command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another usage example is to concatenate all the C program files in a given
    directory and write them to a single file, say, `all_c_files.txt`. Each of these
    examples will perform this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To redirect the data from `find` to the `all_c_files.txt` file, we used the
    `>` operator instead of `>>` (append) because the entire output from the `find`
    command is a single data stream (`stdin`); `>>` is necessary when multiple data
    streams are to be appended to a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will copy all the `.txt` files that are older than 10
    days to a directory `OLD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command can be coupled with many other commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot use multiple commands along with the `-exec` parameter. It accepts
    only a single command, but we can use a trick. Write multiple commands in a shell
    script (for example, `commands.sh`) and use it with `-exec` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-exec` parameter can be coupled with `printf` to produce `joutput`. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Skipping specified directories when using the find command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skipping certain subdirectories may improve performance during the operation
    of `find`. For example, when searching for files in a development source tree
    under a version control system such as `Git`, the filesystem contains a directory
    in each of the subdirectories where version-control-related information is stored.
    These directories may not contain useful files and should be excluded from the
    search.
  prefs: []
  type: TYPE_NORMAL
- en: The technique of excluding files and directories is known as **pruning**. The
    following example shows how to use the `-prune` option to exclude files that match
    a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `-name ".git" -prune` is the pruning section, which specifies that `.git`
    directories should be excluded. The `-type f -print` section describes the action
    to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with xargs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix commands accept data either from the standard input (`stdin`) or as command
    line arguments. Previous examples have shown how to pass data from one application's
    standard output to another's standard input with a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke applications that accept command-line arguments in other ways.
    The simplest is to use the back-tic symbol to run a command and use its output
    as a command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This solution works fine in many situations, but if there are a lot of files
    to be processed, you'll see the dreaded `Argument list too long` error message.
    The `xargs` program solves this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The `xargs` command reads a list of arguments from `stdin` and executes a command
    using these arguments in the command line. The `xargs` command can also convert
    any one-line or multiple-line text inputs into other formats, such as multiple
    lines (specified number of columns) or a single line, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xargs` command should be the first command to appear after a pipe operator.
    It uses standard input as the primary data source and executes another command
    using the values it reads from `stdin` as command-line arguments for the new command.
    This example will search for the main string in a collection of C files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xargs` command supplies arguments to a target command by reformatting
    the data received through `stdin`. By default, `xargs` will execute the `echo`
    command. In many respects, the `xargs` command is similar to the actions performed
    by the `find` command''s `-exec` option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting multiple lines of input to a single-line output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xarg''s default `echo` command can be used to convert multiple-line input to
    single-line text, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting single-line into multiple-line output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `-n` argument to `xargs` limits the number of elements placed on each command
    line invocation. This recipe splits the input into multiple lines of *N* items
    each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `xargs` command works by accepting input from `stdin`, parsing the data
    into individual elements, and invoking a program with these elements as the final
    command line arguments. By default, `xargs` will split the input based on whitespace
    and execute `/bin/echo`.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting the input into elements based on whitespace becomes an issue when
    file and folder names have spaces (or even newlines) in them. The `My Documents`
    folder would be parsed into two elements `My` and `Documents`, neither of which
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: Most problems have solutions and this is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the delimiter used to separate arguments. To specify a custom
    delimiter for input, use the `-d` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `stdin` contains a string consisting of multiple `X`
    characters. We define `X` to be the input delimiter with the `-d option`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `-n` along with the previous command, we can split the input into multiple
    lines of two words each as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xargs` command integrates well with the find command. The output from
    find can be piped to `xargs` to perform more complex actions than the `-exec`
    option can handle. If the filesystem has files with spaces in the name, the find
    command''s `-print0` option will use a `0` (NULL) to delimit the elements, which
    works with the `xargs -0` option to parse these. The following example searches
    for `.docx` files on a Samba mounted filesystem, where names with capital letters
    and spaces are common. It uses `grep` to report files with images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples showed how to use `xargs` to organize a set of data. The
    next examples show how to format sets of data on a command line.
  prefs: []
  type: TYPE_NORMAL
- en: Passing formatted arguments to a command by reading stdin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a small `echo` script to make it obvious as to how `xargs` provides
    command arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'When arguments are passed to the `cecho.sh` shell, it will print the arguments
    terminated by the `#` character. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a common problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have a list of elements in a file (one per line) to be provided to a command
    (say, `cecho.sh`). I need to apply the arguments in several styles. In the first
    method, I need one argument for each invocation, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I need to provide one or two arguments each for each execution of the
    command, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I need to provide all arguments at once to the command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `cecho.sh` script and note the output before going through the following
    section. The `xargs` command can format the arguments for each of these requirements.
    The list of arguments is in a file called `args.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first form, we execute the command multiple times with one argument
    per execution. The `xargs -n` option can limit the number of command line arguments
    to one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To limit the number of arguments to two or fewer, execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to execute the command at once with all the arguments, do not use
    any `-n` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, the arguments added by `xargs` were placed at the
    end of the command. However, we may need to have a constant phrase at the end
    of the command and want `xargs` to substitute its argument in the middle, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command execution, `arg1` is the only variable text. All others
    should remain constant. The arguments from `args.txt` should be applied like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `xargs-I` option specifies a replacement string to be replaced with the
    arguments xargs parses from the input. When `-I` is used with `xargs`, it will
    execute as one command execution per argument. This example solves the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `-I {}` specifies the replacement string. For each of the arguments supplied
    for the command, the `{}` string will be replaced with arguments read through
    `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: When used with `-I`, the command is executed in a loop. When there are three
    arguments, the command is executed three times along with the `{}` command. Each
    time, `{}` is replaced with arguments one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Using xargs with find
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xargs` and `find` command can be combined to perform tasks. However, take
    care to combine them carefully. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is dangerous. It may cause removal of unexpected files. We cannot predict
    the delimiting character (whether it is `'\n'` or `' '`) for the output of the
    `find` command. If any filenames contain a space character (`' '`) `xargs` may
    misinterpret it as a delimiter. For example, `bashrc text.txt` would be misinterpreted
    by `xargs` as `bashrc` and `text.txt`. The previous command would not delete `bashrc
    text.txt`, but would delete `bashrc`.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `-print0` option of `find` to produce an output delimited by the null
    character (`'\0'`); you use `find` output as `xargs` input.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will `find` and remove all `.txt` files and nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Counting the number of lines of C code in a source code directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At some point, most programmers need to count the **Lines of Code** (**LOC**)
    in their C program files The code for this task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If you want more statistics about your source code, a utility called `SLOCCount`,
    is very useful. Modern GNU/Linux distributions usually have packages or you can
    get it from [http://www.dwheeler.com/sloccount/](http://www.dwheeler.com/sloccount/).
  prefs: []
  type: TYPE_NORMAL
- en: While and subshell trick with stdin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `xargs` command places arguments at the end of a command; thus, `xargs`
    cannot supply arguments to multiple sets of commands. We can create a subshell
    to handle complex situations. The subshell can use a `while` loop to read arguments
    and execute commands in a trickier way, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, by replacing `cat $arg` with any number of commands using a `while` loop,
    we can perform many command actions with the same arguments. We can pass the output
    to other commands without using pipes. Subshell `( )` tricks can be used in a
    variety of problematic environments. When enclosed within subshell operators,
    it acts as a single unit with multiple commands inside, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If `cmd1` is `cd /` within the subshell, the path of the working directory changes.
    However, this change resides inside the subshell only. The `cmd4` command will
    not see the directory change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell accepts a `-c` option to invoke a subshell with a command-line script.
    This can be combined with `xargs` to solve the problem of needing multiple substitutions.
    The following example finds all `C` files and echoes the name of each file, preceded
    by a newline (the `-e` option enables backslash substitutions). Immediately after
    the filename is a list of all the times `main` appears in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Translating with tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tr` command is a versatile tool in the Unix command–warrior's kit. It is
    used to craft elegant one-liner commands. It performs substitution of characters,
    deletes selected characters, and can squeeze repeated characters from the standard
    input. Tr is short for **translate**, since it translates a set of characters
    to another set. In this recipe, we will see how to use `tr` to perform basic translation
    between sets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tr` command accepts input through **stdin** (**standard input**) and cannot
    accept input through command-line arguments. It has this invocation format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Input characters from `stdin` are mapped from the first character in `set1`
    to the first character in `set2`, and so on and the output is written to `stdout`
    (standard output). `set1` and `set2` are character classes or a set of characters.
    If the length of sets is unequal, `set2` is extended to the length of `set1` by
    repeating the last character; otherwise if the length of `set2` is greater than
    that of `set1`, all the characters exceeding the length of `set1` are ignored
    from `set2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform translation of characters in the input from uppercase to lowercase,
    use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `'A-Z'` and `'a-z'` are the sets. We can specify custom sets as needed by
    appending characters or character classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `'ABD-}'`, `'aA.,'`, `'a-ce-x'`, `'a-c0-9'`, and so on are valid sets. We
    can define sets easily. Instead of writing continuous character sequences, we
    can use the `'startchar-endchar'` format. It can also be combined with any other
    characters or character classes. If `startchar-endchar` is not a valid continuous
    character sequence, they are then taken as a set of three characters (for example,
    `startchar`, `-`, and `endchar`). You can also use special characters such as
    `'\t'`, `'\n'`, or any ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `tr` with the concept of sets, we can map characters from one set to
    another set easily. Let''s go through an example on using `tr` to encrypt and
    decrypt numeric characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tr` command can be used to encrypt text. **ROT13** is a well-known encryption
    algorithm. In the ROT13 scheme, characters are shifted by 13 positions, thus the
    same function can encrypt and decrypt text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'By sending the encrypted text again to the same ROT13 function, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tr` can convert each tab character to a single space, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw some basic translations using the `tr` command. Let's see what else can
    `tr` help us achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting characters using tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tr` command has an option `-d` to delete a set of characters that appear
    on `stdin` using the specified set of characters to be deleted, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Complementing character sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a set to complement `set1` using the `-c` flag. `set2` is optional
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If only `set1` is present, `tr` will delete all characters that are not in `set1`.
    If `set2` is also present, `tr` will translate characters that aren't in `set1`
    into values from `set2`. If you use the `-c` option by itself, you must use `set1`
    and `set2`. If you combine the `-c` and `-d` options, you only use `set1` and
    all other characters will be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example deletes all the characters from the input text, except
    the ones specified in the complement set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This example replaces all characters that aren''t in `set1` with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Squeezing characters with tr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tr` command can perform many text-processing tasks. For example, it can
    remove multiple occurrences of a character in a string. The basic form for this
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'If you commonly put two spaces after a period, you''ll need to remove extra
    spaces without removing duplicated letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tr` command can also be used to get rid of extra newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding usage of `tr`, it removes the extra `''\n''` characters. Let''s
    use `tr` in a tricky way to add a given list of numbers from a file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How does this hack work?
  prefs: []
  type: TYPE_NORMAL
- en: Here, the `tr` command replaces `'\n'` with the `'+'` character, hence, we form
    the string `1+2+3+..5+``,` but at the end of the string we have an extra `+` operator.
    In order to nullify the effect of the `+` operator, `0` is appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$[ operation ]` performs a numeric operation. Hence, it forms this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: If we used a loop to perform the addition by reading numbers from a file, it
    would take a few lines of code. With `tr`, a one–liner does the trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even trickier is when we have a file with letters and numbers and we want to
    sum the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `tr` to strip out the letters with the `-d` option, then replace
    the spaces with `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Character classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `tr` command can use different character classes as sets. Here are the
    supported character classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`alnum`: Alphanumeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alpha`: Alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cntrl`: Control (nonprinting) characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digit`: Numeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graph`: Graphic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower`: Lowercase alphabetic characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: Printable characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`punct`: Punctuation characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space`: Whitespace characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper`: Uppercase characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xdigit`: Hexadecimal characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can select the required classes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Checksum and verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checksum programs are used to generate a relatively small unique key from files.
    We can recalculate the key to confirm that a file has not changed. Files may be
    modified deliberately (adding a new user changes the password file), accidentally
    (a data read error from a CD-ROM drive), or maliciously (a virus is inserted).
    Checksums let us verify that a file contains the data we expect it to.
  prefs: []
  type: TYPE_NORMAL
- en: Checksums are used by backup applications to check whether a file has been modified
    and needs to be backed up.
  prefs: []
  type: TYPE_NORMAL
- en: Most software distributions also have a checksum file available. Even robust
    protocols such as TCP can allow a file to be modified in transit. Hence, we need
    to know whether the received file is the original one or not by applying some
    kind of test.
  prefs: []
  type: TYPE_NORMAL
- en: By comparing the checksum of the file we downloaded with the checksum calculated
    by the distributer, we can verify that the received file is correct. If the checksum
    calculated from the original file at the source location matches the one calculated
    at the destination, the file has been received successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Some system validation suites maintain a checksum of the critical files. If
    malware modifies a file, we can detect this from the changed checksum.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to compute checksums to verify the integrity
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix and Linux support several checksum programs, but the most robust and widely
    used algorithms are **MD5** and **SHA-1**. The **ms5sum** and **sha1sum** programs
    generate checksum strings by applying the corresponding algorithm to the data.
    Let's see how to generate a checksum from a file and verify the integrity of that
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compute the md5sum, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `md5sum` is a 32-character hexadecimal string as given.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can redirect the checksum output to a file for later use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax for the `md5sum` checksum calculation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'When multiple files are used, the output will contain a checksum for each of
    the files, one checksum report per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The integrity of a file can be verified with the generated file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to check all the files using all `.md5` information available, use
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: SHA-1 is another commonly used checksum algorithm. It generates a 40-character
    hex code from the input. The `sha1sum` command calculates an SHA-1 `checksum`.
    Its usage is similar to `md5sum`. Simply replace `md5sum` with `sha1sum` in all
    the commands previously mentioned. Instead of `file_sum.md5`, change the output
    filename to `file_sum.sha1`.
  prefs: []
  type: TYPE_NORMAL
- en: Checksums are useful to verify the integrity of files downloaded from the Internet.
    ISO images are susceptible to erroneous bits. A few wrong bits and the ISO may
    be unreadable, or, worse, it might install applications that fail in strange ways.
    Most file repositories include an `md5` or `sha1` file you can use to verify that
    files were downloaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05265_02_01_New.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the MD5 sum checksum that is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checksums are also useful when used with a number of files. Let's see how to
    apply checksums to a collection of files and verify the accuracy.
  prefs: []
  type: TYPE_NORMAL
- en: Checksum for directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checksums are calculated for files. Calculating the checksum for a directory
    requires recursively calculating the checksums for all the files in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `md5deep` or `sha1deep` commands traverse a file tree and calculate checksums
    for all files. These programs may not be installed on your system. Use `apt-get`
    or `yum` to install the `md5deep` package. An example of this command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `-r` option allows md5deep to recurse into sub-directories. The `-l` option
    enables displaying the relative path, instead of the default absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` and `md5sum` commands can be used to calculate checksums recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The **md5** and **SHA-1 checksums** are unidirectional hash algorithms, which
    cannot be reversed to form the original data. These are also used to generate
    a unique key from a given data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: These hashes are commonly used to store passwords. Only the hash for a    password
    is stored. When a user needs to be authenticated, the password is read  and converted
    to the hash and that hash is compared to the stored hash. If they  are the same,
    the password is authenticated and access is provided. Storing  plain–text password
    strings is risky and poses a security risk.
  prefs: []
  type: TYPE_NORMAL
- en: Although commonly used, md5sum and SHA-1 are no longer considered secure. This
    is because the rise in computing power in recent times that makes it easier to
    crack them. It is recommended that you use tools such as `bcrypt` or **sha512sum**
    instead. Read more about this at [http://codahale.com/how-to-safely-store-a-password/](http://codahale.com/how-to-safely-store-a-password/).
  prefs: []
  type: TYPE_NORMAL
- en: Shadow-like hash (salted hash)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next recipe shows how to generate a shadow-like salted hash for passwords.
      The hash for user passwords in Linux is stored in the `/etc/shadow` file. A
               typical line in `/etc/shadow` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '`$6$fG4eWdUi$ohTKOlEUzNk77.4S8MrYe07NTRV4M3LrJnZP9p.qc1bR5c.EcOruzPXfEu1uloBFUa18ENRH7F70zhodas3cR`
    is the hash corresponding to its password.'
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, we need to write scripts to edit passwords or add users.
    In that case, we must generate a shadow password string and write a similar line
    to the preceding one to the shadow file. We can generate a shadow password using
    `openssl`.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow passwords are usually salted passwords. `SALT` is an extra string used
    to obfuscate and make the encryption stronger. Salt consists of random bits that
    are used as one of the inputs to a key derivation function that generates the
    salted hash for the password.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on salt, refer to this Wikipedia page at [h t t p ://e n .
    w i k i p e d i a . o r g /w i k i /S a l t _ (c r y p t o g r a p h y )](http://en.wikipedia.org/wiki/Salt_(cryptography)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Replace `SALT_STRING` with a random string and `PASSWORD` with the password
    you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographic tools and hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption techniques are used to protect data from unauthorized access. Unlike
    the checksum algorithms we just discussed, encryption programs can reconstruct
    the original data with no loss. There are many algorithms available and we will
    discuss those most commonly used in the Linux/Unix world.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to use tools such as `crypt`, `gpg`, and `base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `crypt` command is not commonly installed on Linux systems. It''s a simple
    and relatively insecure cryptographic utility that accepts input from `stdin`,
    requests a `passphrase`, and sends encrypted output to `stdout`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can provide a passphrase on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to decrypt the file, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '`gpg` (GNU privacy guard) is a widely used tool for protecting files to ensure
    that data is not read until it reaches its intended destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gpg` signatures are also widely used in e-mail communications to "sign" e-mail
    messages, proving the authenticity of the sender.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to encrypt a file with `gpg`, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This command reads the passphrase interactively and generates `filename.gpg`.
    In order to decrypt a `gpg` file, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: This command reads a passphrase and decrypts the file.
  prefs: []
  type: TYPE_NORMAL
- en: We are not covering `gpg` in much detail in this book. For more information,
    refer to [http://en.wikipedia.org/wiki/GNU_Privacy_Guard](http://en.wikipedia.org/wiki/GNU_Privacy_Guard).
  prefs: []
  type: TYPE_NORMAL
- en: '**Base64** is a group of similar encoding schemes that represent binary data
    in an ASCII string format by translating it into a **radix-64** representation.
    These programs are used to transmit binary data via e-mail. The `base64` command
    encodes and decodes the Base64 string. To encode a binary file into the Base64
    format, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: It can read from `stdin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decode Base64 data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Sorting unique and duplicate lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting text files is a common task. The `sort` command sorts text files and
    `stdin`. It can be coupled with other commands to produce the required output.
    `uniq` is often used with `sort` to extract unique (or duplicate) lines. The following
    recipes illustrate some sort and `uniq` use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sort` and `uniq` commands accept input as filenames or from `stdin` (standard
    input) and output the result by writing to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can sort a set of files (for example, `file1.txt` and `file2.txt`), like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'For a numerical sort, we use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort in the reverse order, we use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort by months (in the order Jan, Feb, March,...), use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To merge two already sorted files, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the unique lines from a sorted file, use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a file has already been sorted, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Replace `filename` with the file you want to check and run the script.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the examples, `sort` accepts numerous parameters to define how the
    data is to be sorted. The sort command is useful with the `uniq` command, which
    expects sorted input.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous scenarios where the `sort` and `uniq` commands can be used.
    Let's go through the various options and usage techniques.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether a file is already sorted, we exploit the fact that `sort` returns
    an exit code (`$?`) of 0 if the file is sorted and nonzero otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These were some basic usages of the `sort` command. Here are sections for using
    it to accomplish complex tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting according to keys or columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a column with sort if the input data is formatted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We can sort this in many ways; currently it is sorted numerically, by the serial
    number (the first column). We can also sort by the second or third column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-k` option specifies the characters to sort by. A single digit specifies
    the column. The `-r` option specifies sorting in reverse order. Consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Always be careful about the -n option for numeric sort. The sort command treats
    alphabetical sort and numeric sort differently. Hence, in order to specify numeric
    sort, the `-n` option should be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `-k` is followed by a single integer, it specifies a column in the text
    file. Columns are separated by space characters. If we need to specify keys as
    a group of characters (for example, characters 4-5 of column 2), we define the
    range as two integers separated by a period to define a character position, and
    join the first and last character positions with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted characters are to be used as numeric keys. To extract them,
    use their positions in the lines as the key format (in the previous example, they
    are `2` and `3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the first character as the key, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the sort''s output `xargs` compatible with the `\0` terminator, use
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the text may contain unnecessary extraneous characters such as spaces.
    To sort them in dictionary order, ignoring punctuations and folds, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The `-b` option is used to ignore leading blank lines from the file and the
    `-d` option specifies sorting in dictionary order.
  prefs: []
  type: TYPE_NORMAL
- en: uniq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `uniq` command finds the unique lines in a given input (`stdin` or a filename
    command line argument) and either reports or removes the duplicated lines.
  prefs: []
  type: TYPE_NORMAL
- en: This command only works with sorted data. Hence, `uniq` is often used with the
    `sort` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce the unique lines (all lines in the input are printed and duplicate
    lines are printed once), use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Display only unique lines (the lines that are not repeated or duplicated in
    the input file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'To count how many times each of the lines appears in the file, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'To find duplicate lines in the file, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify keys, we can use a combination of the `-s` and `-w` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s`: This specifies the number for the first *N* characters to be skipped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`: This specifies the maximum number of characters to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example describes using the comparison key as the index for the
    `uniq` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'To test only the bold characters (skip the first two characters and use the
    next two) we use `-s 2` to skip the first characters and `-w 2` to use the next
    two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: When the output from one command is passed as input to the `xargs` command,
    it's best to use a zero-byte terminator for each element of data. Passing output
    from `uniq` to `xargs` is no exception to this rule. If a zero-byte terminator
    is not used, the default space characters are used to split the arguments in the
    `xargs` command. For example, a line with the text `this is a line` from `stdin`
    will be taken as four separate arguments by the `xargs` command instead of a single
    line. When a zero-byte terminator, `\0`, is used as the delimiter character, the
    full line including spaces is interpreted as a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-z` option generates zero-byte-terminated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This command removes all the files, with filenames read from `files.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'If a filename appears multiple time, the `uniq` command writes the filename
    only once to `stdout`, thus avoiding a `rm: cannot remove FILENAME: No such file
    or directory` error.'
  prefs: []
  type: TYPE_NORMAL
- en: Temporary file naming and random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shell scripts often need to store temporary data. The most suitable location
    to do this is `/tmp` (which will be cleaned out by the system on reboot). There
    are two methods to generate standard filenames for temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `mktemp` command will create a unique temporary file or folder name:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a temporary file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: This creates a temporary file, stores the name in filename, and then displays
    the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a temporary directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This creates a temporary directory, stores the name in filename, and displays
    the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a filename without creating a file or directory, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Here, the filename is stored in `$tmpfile`, but the file won't be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the temporary filename based on a template, use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mktemp` command is straightforward. It generates a file with a unique name
    and returns its filename (or directory name, in the case of directories).
  prefs: []
  type: TYPE_NORMAL
- en: When providing custom templates, `X` will be replaced by a random alphanumeric
    character. Also note that there must be at least three `X` characters in the template
    for `mktemp` to work.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting files and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Splitting a large file into smaller pieces is sometimes necessary. Long ago,
    we had to split files to transport large datasets on floppy disks. Today, we split
    files for readability, for generating logs, or for working around size-restrictions
    on e-mail attachments. These recipes will demonstrate ways of splitting files
    in different chunks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The split command was created to split files. It accepts a filename as an argument
    and creates a set of smaller files in which the first part of the original file
    is in the alphabetically first new file, the next set in the alphabetically next
    file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a 100 KB file can be divided into smaller files of 10k each by
    specifying the split size. The split command supports `M` for MB, `G` for GB,
    `c` for byte, and `w` for word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will split `data.file` into ten files of `10k` each. The
    new files are named `xab`, `xac`, `xad`, and so on. By default, split uses alphabetic
    suffixes. To use numeric suffixes, use the `-d` argument. It is also possible
    to specify a suffix length using `-a` length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `split` command has more options. Let's go through them.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a filename prefix for the split files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the previous split filenames start with x. If we are splitting more than
    one file, we'll want to name the pieces, so it's obvious which goes with which.
    We can use our own filename prefix by providing a prefix as the last argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the previous command with the `split_file` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'To split files based on the number of lines in each split rather than chunk
    size, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The `csplit` utility splits files based on context instead of size. It can split
    based on line count or regular expression pattern. It's particularly useful for
    splitting log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'We may need to split the files into `server1.log`, `server2.log`, and `server3.log`
    from the contents for each `SERVER` in each file. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/SERVER/`: This is the line used to match a line by which a split is to be
    carried out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/[REGEX]/`: This is the format. It copies from the current line (first line)
    up to the matching line that contains `SERVER` excluding the match line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{*}`: This specifies repeating a split based on the match up to the end of
    the file. We can specify the number of times it is to be continued by placing
    a number between the curly braces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: This is the flag to make the command silent rather than printing other
    messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`: This specifies the number of digits to be used as suffix. `01`, `02`,
    `03`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f`: This specifies the filename prefix for split files (`server` is the prefix
    in the previous example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b`: This specifies the suffix format. `"%02d.log"` is similar to the `printf`
    argument format in C, Here, the *filename = prefix + suffix*, that is, `"server"
    + "%02d.log"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We remove `server00.log` since the first split file is an empty file (the match
    word is the first line of the file).
  prefs: []
  type: TYPE_NORMAL
- en: Slicing filenames based on extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many shell scripts perform actions that involve modifying filenames. They may
    need to rename the files and preserve the extension, or convert files from one
    format to another and change the extension, while preserving the name, extracting
    a portion of the filename, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The shell has built-in features for manipulating filenames.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `%` operator will extract the name from `name.extension`. This example
    extracts `sample` from `sample.jpg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#` operator will extract the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract `.jpg` from the filename stored in the `file_jpg` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To extract the name from the filename formatted as `name.extension`, we use
    the `%` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '`${VAR%.*}` is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the string match from `$VAR` for the wildcard pattern that appears to
    the right of `%` (`.*` in the previous example). Evaluating from right to left
    finds the wildcard match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the filename as `VAR=sample.jpg`. Therefore, the wildcard match for`.*`
    from right to left is `.jpg`. Thus, it is removed from the `$VAR` string and the
    output is `sample`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%` is a nongreedy operation. It finds the minimal match for the wildcard from
    right to left. The `%%` operator is similar to `%`, but it is greedy. This means
    that it finds the maximal match of the string for the wildcard. Consider this
    example, where we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `%` operator for a nongreedy match from right to left and match `.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `hack.fun.book`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `%%` operator for a greedy match, and match `.fun.book.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `hack`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `#` operator extracts the extension from the filename. It is similar to
    `%`, but it evaluates from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: '`${VAR#*.}` is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the string match from `$VARIABLE` for the wildcard pattern match that
    appears to the right of `#` (`*.` in the previous example). Evaluating from the
    left to right should make the wildcard match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, as in the case of `%%`, the operator ## is a greedy equivalent to
    #.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes greedy matches by evaluating from left to right and removes the match
    string from the specified variable. Let''s use this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#` operator performs a nongreedy match from left to right and matches
    `hack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `fun.book.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `##` operator performs a greedy match from left to right and matches `hack.fun.book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be: `txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `##` operator is preferred over the `#` operator to extract the extension
    from a filename, since the filename may contain multiple `.` characters. Since
    `##` makes a greedy match, it always extracts extensions only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a practical example to extract different portions of a domain name
    such as URL=`www.google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Renaming and moving files in bulk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We frequently need to move and perhaps rename a set of files. System housekeeping
    often requires moving files with a common prefix or file type to a new folder.
    Images downloaded from a camera may need to be renamed and sorted. Music, video,
    and e-mail files all need to be reorganized eventually.
  prefs: []
  type: TYPE_NORMAL
- en: There are custom applications for many of these operations, but we can write
    our own custom scripts to do it **our** way.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to write scripts to perform these kinds of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rename` command changes filenames using Perl regular expressions. By combining
    the `find`, `rename`, and `mv` commands, we can perform a lot of things.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following script uses find to locate PNG and JPEG files, then uses the
    `##` operator and `mv` to rename them as `image-1.EXT`, `image-2.EXT`, and so
    on. This changes the file''s name, but not its extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script renames all the `.jpg` and `.png` files in the current
    directory to new filenames in the format `image-1.jpg`, `image-2.jpg`, `image-3.png`,
    `image-4.png`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous script uses a `for` loop to iterate through the names of all files
    ending with a `.jpg` or `.png` extension. The `find` command performs this search,
    using the `-o` option to specify multiple `-iname` options for case-insensitive
    matches. The `-maxdepth 1` option restricts the search to the current directory,
    not any subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: The `count` variable is initialized to `1` to track the image number. Then the
    script renames the file using the `mv` command. The new name of the file is constructed
    using `${img##*.}`, which parses the extension of the filename currently being
    processed (refer to the *Slicing filenames based on extensions* recipe in this
    chapter for an interpretation of `${img##*.}`).
  prefs: []
  type: TYPE_NORMAL
- en: '`let count++` is used to increment the file number for each execution of the
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other ways to perform rename operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename `*.JPG` to `*.jpg` like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this to replace spaces in the filenames with the `"_"` character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '`# ''s/ /_/g''` is the replacement part in the filename and `*` is the wildcard
    for the target files. It can be `*.txt` or any other wildcard pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these to convert any filenames from uppercase to lowercase and vice versa:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this to recursively move all the `.mp3` files to a given directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this to recursively rename all the files by replacing spaces with the `_`
    character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Spell–checking and dictionary manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Linux distributions include a dictionary file. However, very few people
    are aware of this, thus spelling errors abound. The `aspell` command-line utility
    is a spell checker. Let's go through a few scripts that make use of the dictionary
    file and the spell checker.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/usr/share/dict/` directory contains one or perhaps more dictionary files,
    which are text files with a list of words. We can use this list to check whether
    a word is a dictionary word or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the given word is a dictionary word, use the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `grep`, `^` is the word-start marker character and the `$` character is the
    word-end marker. The `-q` option suppresses any output, making the `grep` command
    quiet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the spell–check, `aspell`, to check whether a word
    is in a dictionary or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The `aspell list` command returns output text when the given input is not a
    dictionary word, and does not output anything when the input is a dictionary word.
    A `-z` command checks whether `$output` is an empty string or not.
  prefs: []
  type: TYPE_NORMAL
- en: The `look` command will display lines that begin with a given string. You might
    use it to find the lines in a log file that start with a given date, or to find
    words in the dictionary that start with a given string. By default, `look` searches
    `/usr/share/dict/words`, or you can provide a file to search.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this to find lines with a given date in `/var/log/syslog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Automating interactive input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at commands that accept arguments on the command line. Linux also
    supports many interactive applications ranging from `passwd` to `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create our own interactive shell scripts. It''s easier for casual users
    to interact with a set of prompts rather than remember command line flags and
    the proper order. For instance, a script to back up a user''s work, but not to
    back up and lock files, might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: What folder should be backed up? `notes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What type of files should be backed up? `.docx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating interactive applications can save you time when you need to rerun
    the same application and frustration while you're developing one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to automating a task is to run it and note what you do. The script
    command discussed earlier may be of use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examine the sequence of interactive inputs. From the previous code, we can
    formulate the steps of the sequence like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the preceding steps, type `notes`, press `Return`, type `docx`,
    and finally press `Return` to convert into a single string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: The `\n` character is sent when we press Return. By appending the return (`\n`)
    characters, we get the string that is passed to `stdin` (standard input).
  prefs: []
  type: TYPE_NORMAL
- en: By sending the equivalent string for the characters typed by the user, we can
    automate passing input to the interactive processes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a script that reads input interactively for an automation example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s automate the sending of input to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: This style of automating an interactive script can save you a lot of typing
    during developing and debugging. It also insures that you perform the same test
    each time and don't end up chasing a phantom bug because you mis-typed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `echo -e` to produce the input sequence. The `-e` option signals to
    `echo` to interpret escape sequences. If the input is large we can use an input
    file and the redirection operator to supply input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'You can manually craft the input file without the `echo` commands by hand–typing.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: This redirects interactive input data from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a reverse engineer, you may have played with buffer overflow exploits.
    To exploit them we need to redirect a shell code such as `\xeb\x1a\x5e\x31\xc0\x88\x46`,
    which is written in hex. These characters cannot be typed directly on the keyboard
    as keys for these characters are not present. Therefore, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: This will redirect the byte sequence to a vulnerable executable.
  prefs: []
  type: TYPE_NORMAL
- en: These echo and redirection techniques automate interactive input programs. However,
    these techniques are fragile, in that there is no validity checking and it's assumed
    that the target application will always accept data in the same order. If the
    program asks for input in a changing order, or some inputs are not always required,
    these methods fail.
  prefs: []
  type: TYPE_NORMAL
- en: The expect program can perform complex interactions and adapt to changes in
    the target application. This program is in worldwide use to control hardware tests,
    validate software builds, query router statistics, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The expect application is an interpreter similar to the shell. It's based on
    the TCL language. We'll discuss the spawn, expect, and send commands for simple
    automation. With the power of the TCL language behind it, expect can do much more
    complex tasks. You can learn more about the TCL language at the [www.tcl.tk](http://www.tcl.tk)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Automating with expect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`expect` does not come by default on all Linux distributions. You may have
    to install the expect package with your package manager (`apt-get` or `yum`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expect has three main commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Commands** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spawn` | Runs the new target application. |'
  prefs: []
  type: TYPE_TB
- en: '| `expect` | Watches for a pattern to be sent by the target application. |'
  prefs: []
  type: TYPE_TB
- en: '| `send` | Sends a string to the target application. |'
  prefs: []
  type: TYPE_TB
- en: The following example spawns the backup script and then looks for the patterns
    `*folder*` and `*file*` to determine if the backup script is asking for a folder
    name or a filename. It will then send the appropriate reply. If the backup script
    is rewritten to request files first and then folders, this automation script still
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The `spawn` command's parameters are the target application and arguments to
    be automated.
  prefs: []
  type: TYPE_NORMAL
- en: The `expect` command accepts a set of patterns to look for and an action to
    perform when that pattern is matched. The action is enclosed in curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: The `send` command is the message to be sent. This is similar to echo `-n -e`
    in that it does not automatically include the newline and does understand backslash
    symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Making commands quicker by running parallel processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computing power constantly increases not only because processors have higher
    clock cycles but also because they have multiple cores. This means that in a single
    hardware processor there are multiple logical processors. It's like having several
    computers, instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: However, multiple cores are useless unless the software makes use of them. For
    example, a program that does huge calculations may only run on one core while
    the others will sit idle. The software has to be aware and take advantage of the
    multiple cores if we want it to be faster.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can make our commands run faster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an example of the `md5sum` command we discussed in the previous
    recipes. This command performs complex computations, making it CPU-intensive.
    If we have more than one file that we want to generate a checksum for, we can
    run multiple instances of `md5sum` using a script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be the same as running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: However, if the `md5sum` commands run simultaneously, you'll get the results
    quicker if you have a multi–core processor (you can verify this using the `time`
    command).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We exploit the Bash operand `&`, which instructs the shell to send the command
    to the background and continue with the script. However, this means our script
    will exit as soon as the loop completes, while the `md5sum` processes are still
    running in the background. To prevent this, we get the PIDs of the processes using
    `$!`, which in Bash holds the PID of the last background process. We append these
    PIDs to an array and then use the `wait` command to wait for these processes to
    finish.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bash `&` operand works well for a small number of tasks. If you had a hundred
    files to checksum, the script would try to start a hundred processes and might
    force your system into swapping, which would make the tasks run slower.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU parallel command is not part of all installations, but again it can
    be loaded with your package manager. The parallel command optimizes the use of
    your resources without overloading any of them.
  prefs: []
  type: TYPE_NORMAL
- en: The parallel command reads a list of files on `stdin` and uses options similar
    to the find command's `-exec` argument to process these files. The `{}` symbol
    represents the file to be processed, and the `{.}` symbol represents the filename
    without a suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command uses **Imagemagick''s **`convert` command to make new,
    resized images of all the images in a folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Examining a directory, files and subdirectories in it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the commonest problems we deal with is finding misplaced files and sorting
    out mangled file hierarchies. This section will discuss tricks for examining a
    portion of the filesystem and presenting the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` command and loops we discussed give us tools to examine and report
    details in a directory and its contents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipes show two ways to examine a directory. First we'll display the
    hierarchy as a tree, then we'll see how to generate a summary of files and folders
    under a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a tree view of a directory.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it's easier to visualize a file system if it's presented graphically.
  prefs: []
  type: TYPE_NORMAL
- en: The next recipe pulls together several of the tools we discussed. It uses the
    find command to generate a list of all the files and sub-folders under the current
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `-exec` option creates a subshell which uses echo to send the filenames
    to the `tr` command's `stdin`. There are two `tr` commands. The first deletes
    all alphanumeric characters, and any dash (`-`), underbar (`_`), or period (`.`).
    This passes only the slashes (`/`) in the path to the second `tr` command, which translates
    those slashes to spaces. Finally, the `basename` command strips the leading path
    from the filename and displays it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these to view a tree of the folders in `/var/log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'This output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Generating a summary of files and sub-directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can generate a list of subdirectories, and the number of files in them, with
    a combination of the `find` command, `echo`, and `wc` commands, which will be
    discussed in greater detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following to get a summary of files in the current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'If this script is run in `/var/log`, it will generate output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
