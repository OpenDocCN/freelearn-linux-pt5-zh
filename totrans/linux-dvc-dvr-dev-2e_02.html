<html><head></head><body>
		<div id="_idContainer008">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introduction to Kernel Development</h1>
			<p><strong class="bold">Linux</strong> started as a hobby project in 1991 by a Finnish student, Linus Torvalds. The project has gradually grown and continues to do so, with roughly a thousand contributors around the world. Nowadays, Linux is a must, in embedded systems as well as on servers. A <strong class="bold">kernel</strong> is a central <a id="_idIndexMarker000"/>part of an operating system, and its development is not straightforward. Linux offers many advantages over other operating systems; it is free of charge, well documented with a large community, is portable across different platforms, provides access to the source code, and has a lot of free open source software.</p>
			<p>This book will try to be as generic as possible. There is a special topic, known as the device tree, that is not a full <strong class="bold">x86</strong> feature yet. This topic will be dedicated to ARM processors, especially those that fully support the device tree. Why those architectures? Because they are mostly used on desktops and servers (for x86), as well as embedded systems (ARM).</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Setting up the development environment</li>
				<li>Understanding the kernel configuration process </li>
				<li>Building your kernel </li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Setting up the development environment</h1>
			<p>When you're working<a id="_idIndexMarker001"/> in embedded system fields, there are terms you must be familiar with, before even setting up your environment. They are as follows:</p>
			<ul>
				<li><strong class="bold">Target</strong>: This is the <a id="_idIndexMarker002"/>machine that the binaries resulting from the build process are produced for. This is the machine that is going to run the binary.</li>
				<li><strong class="bold">Host</strong>: This is the<a id="_idIndexMarker003"/> machine where the build process takes place.</li>
				<li><strong class="bold">Compilation</strong>: This is also called native compilation<a id="_idIndexMarker004"/> or a <strong class="bold">native build</strong>. This happens <a id="_idIndexMarker005"/>when the target and the host are the same; that is, when you're building on machine A (the host) a binary that is going to be executed on the same machine (A, the target) or a machine of the same kind. Native compilation<a id="_idIndexMarker006"/> requires a native compiler. Therefore, a native compiler is one where the target and the host are the same.</li>
				<li><strong class="bold">Cross-compilation</strong>: Here, the target and the host are different. It is where you build a binary from <a id="_idIndexMarker007"/>machine A (the host) that is going to be executed on machine B (the target). In this case, the host (machine A) must have installed the cross-compiler that supports the target architecture. Thus, a cross-compiler is a compiler where the target is different from the host.</li>
			</ul>
			<p>Because <a id="_idIndexMarker008"/>embedded computers have limited or reduced resources (CPU, RAM, disk, and so on), it is common for the hosts to be x86 machines, which are much more powerful and have far more resources to speed up the development process. However, over the past few years, embedded computers have become more powerful, and they tend to be used for native compilation (thus used as the host). A typical example is the Raspberry Pi 4, which has a powerful quad-core CPU and up to 8 GB of RAM.</p>
			<p>In this chapter, we will be using an x86 machine as the host, either to create a native build or for cross-compilation. So, any "native build" term will refer to an "x86 native build." Due to this, I'm running <strong class="bold">Ubuntu 18.04</strong>.</p>
			<p>To quickly check this information, you can use the following command:</p>
			<p class="source-code">lsb_release -a</p>
			<p class="source-code">Distributor ID: Ubuntu</p>
			<p class="source-code">Description:    Ubuntu 18.04.5 LTS</p>
			<p class="source-code">Release:    18.04</p>
			<p class="source-code">Codename:   bionic</p>
			<p>My computer is an <strong class="bold">ASUS RoG</strong>, with a 16 core AMD Ryzen CPU (you can use the <strong class="source-inline">lscpu</strong> command to pull this information out), 16 GB of RAM, 256 GB of SSD, and a 1 TB magnetic hard drive (information that you can obtain using the <strong class="source-inline">df -h</strong> command). That said, a quad-core CPU and 4 or 8 GB of RAM could be enough, but at the cost of an increased build <a id="_idIndexMarker009"/>duration. My favorite editor is <strong class="bold">Vim</strong>, but you are free to use the one you are most comfortable with. If <a id="_idIndexMarker010"/>you are using a desktop machine, you could use <strong class="bold">Visual Studio Code </strong>(<strong class="bold">VS Code</strong>), which is<a id="_idIndexMarker011"/> becoming widely used.</p>
			<p>Now that we are familiar with the compilation-related keywords we will be using, we can start preparing the host machine.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Setting up the host machine</h2>
			<p>Before you can start the <a id="_idIndexMarker012"/>development process, you need to set up an <strong class="bold">environment</strong>. The environment that's dedicated to Linux development is quite simple – on <strong class="bold">Debian</strong>-based systems, at least (which is our case).</p>
			<p>On the host machine, you need to install a few packages, as follows:</p>
			<p class="source-code">$ sudo apt update</p>
			<p class="source-code">$ sudo apt install gawk wget git diffstat unzip \</p>
			<p class="source-code">       texinfo gcc-multilib build-essential chrpath socat \</p>
			<p class="source-code">       libsdl1.2-dev xterm ncurses-dev lzop libelf-dev make</p>
			<p>In the preceding code, we installed a few development tools and some mandatory libraries so that we have a nice user interface when we're configuring the Linux kernel.</p>
			<p>Now, we need to install the compiler and the tools (linker, assembler, and so on) for the build process to <a id="_idIndexMarker013"/>work properly and produce the executable for the target. This set of tools is called <strong class="bold">Binutils</strong>, and the compiler + Binutils (+ other build-time dependency libraries if any) combo is <a id="_idIndexMarker014"/>called <strong class="bold">toolchain</strong>. So, you need to understand what is meant by <em class="italic">"I need a toolchain for &lt;this&gt; architecture"</em> or similar sentences.</p>
			<h3>Understanding and installing toolchains</h3>
			<p>Before we can start compiling, we need to install the necessary packages and tools for native or ARM cross-compiling; that is, the <a id="_idIndexMarker015"/>toolchains. GCC is the compiler that's supported by the Linux kernel. A lot of macros that are defined in the kernel are GCC-related. Due to this, we will use GCC as our (cross-)compiler.</p>
			<p>For a native compilation, you can use the following toolchain installation command:</p>
			<p class="source-code">sudo apt install gcc binutils</p>
			<p>When you need to cross-compile, you must identify and install the right toolchain. Compared to a native compiler, cross-compiler executables are prefixed by the name of the target operating system, architecture, and (sometimes) library. Thus, to identify architecture-specific toolchains, a naming convention has been defined: <strong class="source-inline">arch[-vendor][-os]-abi</strong>. Let's look at what<a id="_idIndexMarker016"/> the fields in the pattern mean:</p>
			<ul>
				<li><strong class="source-inline">arch</strong> identifies the architecture; that is, <strong class="source-inline">arm</strong>, <strong class="source-inline">mips</strong>, <strong class="source-inline">x86</strong>, <strong class="source-inline">i686</strong>, and so on.</li>
				<li><strong class="source-inline">vendor</strong> is the toolchain supplier (company); that is, <strong class="source-inline">Bootlin</strong>, <strong class="source-inline">Linaro</strong>, <strong class="source-inline">none</strong> (if there is no provider) or simply omitting the field, and so on.</li>
				<li><strong class="source-inline">os</strong> is for the target operating system; that is, <strong class="source-inline">linux</strong> or <strong class="source-inline">none</strong> (bare metal). If omitted, bare metal is assumed. </li>
				<li><strong class="source-inline">abi</strong> stands for application binary interface. It refers to what the underlying binary is going to look like, the function call convention, how parameters are passed, and more. Possible conventions include <strong class="source-inline">eabi</strong>, <strong class="source-inline">gnueabi</strong>, and <strong class="source-inline">gnueabihf</strong>. Let's look at these in more detail:<ul><li><strong class="source-inline">eabi</strong> means that the code that will be compiled will run on a bare metal ARM core.</li><li><strong class="source-inline">gnueabi</strong> means that the code for Linux will be compiled.</li><li><strong class="source-inline">gnueabihf</strong> is the same as <strong class="source-inline">gnueabi</strong>, but <strong class="source-inline">hf</strong> at the end means <strong class="source-inline">hard float</strong>, which indicates that the compiler and its underlying libraries are using hardware floating-point instructions rather than a software implementation of floating-point instructions, such as fixed-point software implementations. If no floating-point hardware is available, the instructions will be trapped and performed by a floating-point emulation module instead. When you're using software emulation, the only actual difference in functionality is slower execution.</li></ul></li>
			</ul>
			<p>The following are some toolchain names to illustrate the use of the pattern:</p>
			<ul>
				<li><strong class="source-inline">arm-none-eabi</strong>: This is a <a id="_idIndexMarker017"/>toolchain that targets the ARM architecture. It has no vendor, targets a bare-metal system (does not target an operating system), and complies with the ARM EABI.</li>
				<li><strong class="source-inline">arm-none-linux-gnueabi</strong> or <strong class="source-inline">arm-linux-gnueabi</strong>: This is a toolchain that produces objects for the ARM architecture to be run on Linux with the default configuration (ABI) provided by the toolchain. Note that <strong class="source-inline">arm-none-linux-gnueabi</strong> is the same as <strong class="source-inline">arm-linux-gnueabi</strong> because, as we have seen, when no vendor is specified, we assume there isn't one. The variant of this toolchain supporting hardware floating point would be <strong class="source-inline">arm-linux-gnueabihf</strong> or <strong class="source-inline">arm-none-linux-gnueabihf</strong>.</li>
			</ul>
			<p>Now that we are familiar with toolchain naming conventions, we can determine which toolchain can be used to cross-compile for our target architecture.</p>
			<p>To cross-compile for a 32-bit ARM machine, we would install the toolchain using the following command:</p>
			<p class="source-code">$ sudo apt install gcc-arm-linux-gnueabihf binutils-arm-linux-gnueabihf</p>
			<p>Note that the 64-bit ARM backend/support in the Linux tree and GCC is <a id="_idIndexMarker018"/>called <strong class="bold">aarch64</strong>. So, the cross-compiler must be called something like <strong class="source-inline">gcc-aarch64-linux-gnu*</strong>, while Binutils must be called something like <strong class="source-inline">binutils-aarch64-linux-gnu*</strong>. Thus, for a 64-bit ARM toolchain, we would use the following command:</p>
			<p class="source-code">$ sudo apt install make gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that aarch64 only supports/provides hardware float aarch64 toolchains. Thus, there is no need to specify <strong class="source-inline">hf</strong> at the end.</p>
			<p>Note that not all versions of the compiler can compile a given Linux kernel version. Thus, it is important to take care of both the Linux kernel version and the compiler (GCC) version. While the previous commands installed the latest version that's supported by your distribution, it is possible to target a particular version. To achieve this, you can use <strong class="source-inline">gcc-&lt;version&gt;-&lt;arch&gt;-linux-gnu*</strong>.</p>
			<p>For example, to install version 8 of GCC for aarch64, you can use the following command:</p>
			<p class="source-code">sudo apt install gcc-8-aarch64-linux-gnu</p>
			<p>Now that our toolchain <a id="_idIndexMarker019"/>has been installed, we can look at the version that was picked by our distribution package manager. For example, to check which version of the aarch64 cross-compiler was installed, we can use the following command: </p>
			<p class="source-code">$ aarch64-linu<a id="_idTextAnchor017"/>x-gnu-gcc --version</p>
			<p class="source-code">aarch64-linux-gnu-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0</p>
			<p class="source-code">Copyright (C) 2017 Free Software Foundation, Inc.</p>
			<p class="source-code">[...]</p>
			<p>For the 32-bit ARM variant, we can use the following command:</p>
			<p class="source-code">$ arm-linux-gnueabihf-gcc --version</p>
			<p class="source-code">arm-linux-gnueabihf-gcc (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0</p>
			<p class="source-code">Copyright (C) 2017 Free Software Foundation, Inc.</p>
			<p class="source-code">[...]</p>
			<p>Finally, for the native version, we can use the following command:</p>
			<p class="source-code">$ gcc --version</p>
			<p class="source-code">gcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0</p>
			<p class="source-code">Copyright (C) 2017 Free Software Foundation, Inc.</p>
			<p>Now that we have set up our environment and made sure we are using the right tool versions, we can start downloading the Linux kernel sources and dig into them.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>Getting the sources</h2>
			<p>In the early <a id="_idIndexMarker020"/>kernel days (until 2003), odd-even versioning styles were used, where odd numbers were stable and even numbers were unstable. When the 2.6 version was released, the versioning scheme switched to <strong class="bold">X.Y.Z</strong>. Let's look at this in more detail:</p>
			<ul>
				<li><strong class="bold">X</strong>: This was the actual kernel's version, also called major. It was incremented when there were backward-incompatible API changes.</li>
				<li><strong class="bold">Y</strong>: This was the minor revision. It was incremented after functionality was added in a backward-compatible manner.</li>
				<li><strong class="bold">Z</strong>: This is also called PATCH and represented versions related to bug fixes.</li>
			</ul>
			<p>This is called <em class="italic">semantic versioning</em> and <a id="_idIndexMarker021"/>was used until version <em class="italic">2.6.39</em>, when Linus Torvalds decided to bump the version to 3.0, which also meant the end of semantic versioning in 2011. At that point, an X.Y scheme was adopted.</p>
			<p>When it came to version 3.20, Linus argued that he could no longer increase Y. Therefore, he decided to switch to an arbitrary versioning scheme, incrementing X whenever Y got so big that he ran out of fingers and toes to count it. This is the reason why the version has moved from 3.20 to 4.0 directly. </p>
			<p>Now, the kernel uses an arbitrary <strong class="bold">X.Y</strong> versioning scheme, which has nothing to do with semantic versioning.</p>
			<p>According to the Linux kernel release model, there are always two latest releases of the kernel out there: the stable release and <a id="_idIndexMarker022"/>the <strong class="bold">long-term support</strong> (<strong class="bold">LTS</strong>) release. All bug fixes and new features are collected and prepared by subsystem maintainers and then submitted to Linus Torvalds for inclusion into his Linux tree, which is called the mainline Linux tree, also known as the <em class="italic">master</em> Git repository. This is where every stable release originates from.</p>
			<p>Before each new kernel version is released, it is submitted to the community through <em class="italic">release candidate</em> tags so that developers can test and polish all the new features. Based on the feedback he receives during this cycle, Linus decides whether the final version is ready to go. When Linus is convinced that the new kernel is ready to go, he makes the final release. We call this release "stable" to indicate that it's not a "release candidate:" those releases are <em class="italic">vX.Y</em> versions.</p>
			<p>There is no strict timeline for making releases, but new mainline kernels are generally released every 2-3 months. Stable kernel releases are based on Linus releases; that is, the mainline tree releases.</p>
			<p>Once a stable <a id="_idIndexMarker023"/>kernel is released by Linus, it also appears in the <em class="italic">linux-stable</em> tree (available at <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/</a>), where it becomes a branch. Here, it can receive bug fixes. This tree is called a stable tree because it is used to track previously released stable kernels. It is maintained and curated by <em class="italic">Greg Kroah-Hartman</em>. However, all fixes must go into Linus's tree first, which is the mainline repository. Once the bug has been fixed in the mainline repository, it can be applied to previously released kernels that are still maintained by the kernel development community. All the fixes that have been backported to stable releases must meet a set of important criteria before they are considered – one of them is that they "must already exist in Linus's tree."</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Bugfix kernel releases</strong> are considered stable.</p>
			<p>For example, when the 4.9 kernel is released by Linus, the stable kernel is released based on the kernel's numbering scheme; that is, 4.9.1, 4.9.2, 4.9.3, and so on. Such releases are called <strong class="bold">bugfix kernel releases</strong>, and the<a id="_idIndexMarker024"/> sequence is usually shortened with the number "4.9.y" when referring to their branch in the stable kernel release tree. Each stable kernel release tree is maintained by a single kernel developer, who is responsible for picking the necessary patches for the release and going through the review/release process. Usually, there are only a few bugfix kernel releases until the next mainline kernel becomes available – unless it is designated as a <em class="italic">long-term maintenance kernel</em>.</p>
			<p>Every subsystem and kernel maintainer repository is hosted here: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/">https://git.kernel.org/pub/scm/linux/kernel/git/</a>. Here, we can also find either a Linus or a stable tree. In the Linus tree (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/</a>), there is only one branch; that is, the <strong class="bold">master branch</strong>. Its tags are either stable releases or release candidates. In the stable tree (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/</a>), there is one branch per stable kernel release (named <em class="italic">&lt;A.B&gt;.y</em>, where <em class="italic">&lt;A.B&gt;</em> is the release version in the Linus tree) and each branch contains its bugfix kernel releases.</p>
			<h3>Downloading the source and organizing it</h3>
			<p>In this book, we will be using Linus's tree, which can be downloaded using the following commands:</p>
			<p class="source-code">git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth 1 </p>
			<p class="source-code">git checkout v5.10</p>
			<p class="source-code">ls</p>
			<p>In the preceding<a id="_idIndexMarker025"/> commands we used <strong class="source-inline">--depth 1</strong> to avoid downloading the<a id="_idIndexMarker026"/> history (or rather, picking only the last commit history), which may considerably reduce the download size and save time. Since Git supports branching and tagging, the <strong class="source-inline">checkout</strong> command allows you to switch to a specific tag or branch. In this example, we are switching to the <strong class="source-inline">v5.10</strong> tag. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this book, we will be dealing with Linux kernel v5.10.</p>
			<p>Let's look at the content of the main source directory:</p>
			<ul>
				<li><strong class="source-inline">arch/</strong>: To be as generic as possible, architecture-specific code is separated from the rest. This directory contains processor-specific code that's organized in a subdirectory per architecture, such as <strong class="source-inline">alpha/</strong>, <strong class="source-inline">arm/</strong>, <strong class="source-inline">mips/</strong>, <strong class="source-inline">arm64/</strong>, and so on.</li>
				<li><strong class="source-inline">block/</strong>: This directory contains codes for block storage devices.</li>
				<li><strong class="source-inline">crypto/</strong>: This directory contains the cryptographic API and the encryption algorithm's code.</li>
				<li><strong class="source-inline">certs/</strong>: This directory contains certificates and sign files to enable a module signature to make the kernel load signed modules.</li>
				<li><strong class="source-inline">documentation/</strong>: This directory contains the descriptions of the APIs that are used for different kernel frameworks and subsystems. You should look here before asking any questions on the public forums.</li>
				<li><strong class="source-inline">drivers/</strong>: This is the heaviest directory since it is continuously growing as device drivers get merged. It contains every device driver, organized into various subdirectories.</li>
				<li><strong class="source-inline">fs/</strong>: This directory contains the implementations of different filesystems that the kernel supports, such as NTFS, FAT, ETX{2,3,4}, sysfs, procfs, NFS, and so on.</li>
				<li><strong class="source-inline">include/</strong>: This <a id="_idIndexMarker027"/>directory contains kernel header files.</li>
				<li><strong class="source-inline">init/</strong>: This directory <a id="_idIndexMarker028"/>contains the initialization and startup code.</li>
				<li><strong class="source-inline">ipc/</strong>: This directory <a id="_idIndexMarker029"/>contains the implementation of the <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) mechanisms, such as message queues, semaphores, and shared memory.</li>
				<li><strong class="source-inline">kernel/</strong>: This directory contains architecture-independent portions of the base kernel.</li>
				<li><strong class="source-inline">lib/</strong>: Library routines and <a id="_idIndexMarker030"/>some helper functions live here. This includes generic <strong class="bold">kernel object</strong> (<strong class="bold">kobject</strong>) handlers and <strong class="bold">cyclic redundancy code</strong> (<strong class="bold">CRC</strong>) computation<a id="_idIndexMarker031"/> functions.</li>
				<li><strong class="source-inline">mm/</strong>: This directory contains memory management code.</li>
				<li><strong class="source-inline">net/</strong>: This directory contains networking (whatever network type it is) protocol code.</li>
				<li><strong class="source-inline">samples/</strong>: This directory contains device driver samples for various subsystems.</li>
				<li><strong class="source-inline">scripts/</strong>: This directory contains scripts and tools that are used alongside the kernel. There are other useful tools here.</li>
				<li><strong class="source-inline">security/</strong>: This directory contains the security framework code.</li>
				<li><strong class="source-inline">sound/</strong>: Guess what falls here: audio subsystem code.</li>
				<li><strong class="source-inline">tools/</strong>: This directory contains Linux kernel development and testing tools for various subsystems, such as USB, vhost test modules, GPIO, IIO, and SPI, among others.</li>
				<li><strong class="source-inline">usr/</strong>: This directory currently contains the initramfs implementation.</li>
				<li><strong class="source-inline">virt/</strong>: This is the <a id="_idIndexMarker032"/>virtualization directory, which contains the <strong class="bold">kernel virtual machine </strong>(<strong class="bold">KVM</strong>) module for a hypervisor.</li>
			</ul>
			<p>To enforce portability, any <a id="_idIndexMarker033"/>architecture-specific code should be in the <strong class="source-inline">arch</strong> directory. Moreover, the kernel code that's related to the user space API does not<a id="_idIndexMarker034"/> change (system calls, <strong class="source-inline">/proc</strong>, <strong class="source-inline">/sys</strong>, and so on) as it would break the existing programs.</p>
			<p>In this section, we have familiarized ourselves with the Linux kernel's source content. After going through all the sources, it seems quite natural to configure them to be able to compile a kernel. In the next section, we will learn how kernel configuration works.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Configuring and building the Linux kernel</h1>
			<p>There are<a id="_idIndexMarker035"/> numerous drivers/features and build options available in the Linux kernel sources. The configuration process consists of choosing what features/drivers are<a id="_idIndexMarker036"/> going to be part of the compilation process. Depending on whether we are going to perform native compilation or cross-compilation, there are environment variables that must be defined, even before the configuration process takes place.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Specifying compilation options</h2>
			<p>The compiler that's <a id="_idIndexMarker037"/>invoked by the kernel's <strong class="source-inline">Makefile</strong> is <strong class="source-inline">$(CROSS_COMPILE)gcc</strong>. That said, <strong class="source-inline">CROSS_COMPILE</strong> is the prefix of the cross-compiling tools (<strong class="source-inline">gcc</strong>, <strong class="source-inline">as</strong>, <strong class="source-inline">ld</strong>, <strong class="source-inline">objcopy</strong>, and so on) and must be specified when you're invoking <strong class="source-inline">make</strong> or must have been exported before any <strong class="source-inline">make</strong> command is executed. Only <strong class="source-inline">gcc</strong> and its related Binutils executables will be prefixed with <strong class="source-inline">$(CROSS_COMPILE)</strong>.</p>
			<p>Note that various assumptions are made and options/features/flags are enabled by the Linux kernel build infrastructure based on the target architecture. To achieve that, in addition to the cross-compiler prefix, the architecture of the target must be specified as well. This can be done through the <strong class="source-inline">ARCH</strong> environment variable.</p>
			<p>Thus, a typical Linux <a id="_idIndexMarker038"/>configuration or build command would look as follows:</p>
			<p class="source-code">ARCH=&lt;XXXX&gt; CROSS_COMPILE=&lt;YYYY&gt; make menuconfig</p>
			<p>It can also look as follows:</p>
			<p class="source-code">ARCH=&lt;XXXX&gt; CROSS_COMPILE=&lt;YYYY&gt; make &lt;make-target&gt;</p>
			<p>If you don't wish to specify these environment variables when you launch a command, you can export them into your current shell. The following is an example:</p>
			<p class="source-code">export CROSS_COMPILE=aarch64-linux-gnu-</p>
			<p class="source-code">export ARCH=aarch64</p>
			<p>Remember that if these variables are not specified, the native host machine is going to be targeted; that is, if <strong class="source-inline">CROSS_COMPILE</strong> is omitted or not set, <strong class="source-inline">$(CROSS_COMPILE)gcc</strong> will result in <strong class="source-inline">gcc</strong>, and it will be the same for other tools that will be invoked (for example, <strong class="source-inline">$(CROSS_COMPILE)ld</strong> will result in <strong class="source-inline">ld</strong>).</p>
			<p>In the same manner, if <strong class="source-inline">ARCH</strong> (the target architecture) is omitted or not set, it will default to the host where <strong class="source-inline">make</strong> is executed. It will default to <strong class="source-inline">$(uname -m)</strong>.</p>
			<p>As a result, you should leave <strong class="source-inline">CROSS_COMPILE</strong> and <strong class="source-inline">ARCH</strong> undefined to have the kernel natively compiled for the host architecture using <strong class="source-inline">gcc</strong>.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Understanding the kernel configuration process</h2>
			<p>The Linux kernel is a <em class="italic">Makefile-based</em> project that contains thousands of options and drivers. Each option that's enabled can make another one available or can pull specific code into the build. To <a id="_idIndexMarker039"/>configure the kernel, you can use <strong class="source-inline">make menuconfig</strong> for a ncurses-based interface or <strong class="source-inline">make xconfig</strong> for an X-based interface. The ncurses-based interface looks as follows:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B17934_Fig_1.1.jpg" alt="Figure 1.1 – Kernel configuration screen &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Kernel configuration screen </p>
			<p>For most options, you have three choices. However, we can enumerate five types of options while configuring the Linux kernel:</p>
			<ul>
				<li>Boolean options, for which<a id="_idIndexMarker040"/> you have two choices:<ul><li><strong class="source-inline">(blank)</strong>, which leaves this feature out. Once this option is highlighted in the configuration menu, you can press the <strong class="source-inline">&lt;n&gt;</strong> key to leave the feature out. It is equivalent to false. When it's disabled, the resulting configuration option is commented out in the configuration file.</li><li><strong class="source-inline">(*)</strong>, which compiles it statically in the kernel. This means it will always be there when the kernel first loads. It is equivalent to true. You can enable a feature in the configuration menu by selecting it and pressing the <strong class="source-inline">&lt;y&gt;</strong> key. The resulting option will appear as <strong class="source-inline">CONFIG_&lt;OPTION&gt;=y</strong> in the configuration file; for example, <strong class="source-inline">CONFIG_INPUT_EVDEV=y</strong>. </li></ul></li>
				<li>Tristate <a id="_idIndexMarker041"/>options, which, in addition to being able to take Boolean states, can take a third state, marked as <strong class="source-inline">(M)</strong> in the configuration windows. This results in <strong class="source-inline">CONFIG_&lt;OPTION&gt;=m</strong> in the configuration file; for example, <strong class="source-inline">CONFIG_INPUT_EVDEV=m</strong>. To produce a loadable module (provided that this option allows it), you can select the feature and press the <strong class="source-inline">M</strong> key.</li>
				<li>String options, which expect string values; for example, <strong class="source-inline">CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"</strong>.</li>
				<li>Hex options, which expect hexadecimal values; for example, <strong class="source-inline">CONFIG_PAGE_OFFSET=0x80000000</strong>.</li>
				<li>Int options, which expect integer values; for example, <strong class="source-inline">CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7</strong>.</li>
			</ul>
			<p>The selected options will be stored in a <strong class="source-inline">.config</strong> file, at the root of the source tree.</p>
			<p>It is very difficult to know which configuration is going to work on your platform. In most cases, there will be no need to start a configuration from scratch. There are default and functional configuration files available in each arch directory that you can use as a starting point (it is important to start with a configuration that already works):</p>
			<p class="source-code">ls arch/&lt;your_arch&gt;/configs/</p>
			<p>For 32-bit ARM-based CPUs, these config files can be found in <strong class="source-inline">arch/arm/configs/</strong>. In this architecture, there is usually one default configuration per CPU family. For instance, for i.MX6-7 processors, the default config file is <strong class="source-inline">arch/arm/configs/imx_v6_v7_defconfig</strong>. However, on ARM 64-bit CPUs, there is only one big default configuration to customize; it is located in <strong class="source-inline">arch/arm64/configs/</strong> and is called <strong class="source-inline">defconfig</strong>. Similarly, for x86 processors, we can find the files in <strong class="source-inline">arch/x86/configs/</strong>. There will be two default configuration files here – <strong class="source-inline">i386_defconfig</strong> and <strong class="source-inline">x86_64_defconfig</strong>, for 32- and 64-bit x86 architectures, respectively. </p>
			<p>The kernel configuration command, given a default configuration file, is as follows:</p>
			<p class="source-code">make &lt;foo_defconfig&gt;</p>
			<p>This will generate a new <strong class="source-inline">.config</strong> file in the main (root) directory, while the old <strong class="source-inline">.config</strong> will be renamed <strong class="source-inline">.config.old</strong>. This can be useful to revert the previous configuration changes. Then, to customize the configuration, you can use the following command:</p>
			<p class="source-code">make menuconfig</p>
			<p>Saving your <a id="_idIndexMarker042"/>changes will update your <strong class="source-inline">.config</strong> file. While you could share this config with your teammates, you are better off creating a default configuration file in the same minimal format as those shipped with the Linux kernel sources. To do that, you can use the following command:</p>
			<p class="source-code">make savedefconfig</p>
			<p>This command will create a minimal (since it won't store non-default settings) configuration file. The generated default configuration file will be called <strong class="source-inline">defconfig</strong> and stored at the root of the source tree. You can store it in another location using the following command:</p>
			<p class="source-code">mv defconfig arch/&lt;arch&gt;/configs/myown_defconfig</p>
			<p>This way, you can share a reference configuration inside the kernel sources and other developers can now get the same <strong class="source-inline">.config</strong> file as you by running the following command:</p>
			<p class="source-code">make myown_defconfig</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that, for cross-compilation, <strong class="source-inline">ARCH</strong> and <strong class="source-inline">CROSS_COMPILE</strong> must be set before you execute any <strong class="source-inline">make</strong> command, even for kernel configuration. Otherwise, you'll have unexpected changes in your configuration.</p>
			<p>The followings are the various configuration commands you can use, depending on the target system:</p>
			<ul>
				<li>For a 64-bit x86 native compilation, it is quite straightforward (the compilation options can be omitted):<p class="source-code"><strong class="bold">make x86_64_defconfig</strong></p><p class="source-code"><strong class="bold">make menuconfig</strong></p></li>
				<li>Given a 32-bit ARM i.MX6-based board, you can execute the following command:<p class="source-code"><strong class="bold">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make imx_v6_v7_defconfig</strong></p><p class="source-code"><strong class="bold">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make menuconfig</strong></p></li>
			</ul>
			<p>With the first command, you store the default options in the <strong class="source-inline">.config</strong> file, while with the latter, you can update (add/remove) various options, depending on your needs.</p>
			<ul>
				<li>For 64-bit<a id="_idIndexMarker043"/> ARM boards, you can execute the following commands:<p class="source-code"><strong class="bold">ARCH=aarch64 CROSS_COMPILE=aarch64-linux-gnu- make defconfig</strong></p><p class="source-code"><strong class="bold">ARCH=aarch64 CROSS_COMPILE=aarch64-linux-gnu- make menuconfig</strong></p></li>
			</ul>
			<p>You may run into a Qt4 error with <strong class="source-inline">xconfig</strong>. In such a case, you should just use the following command to install the missing packages:</p>
			<p class="source-code">sudo apt install qt4-dev-tools qt4-qmake</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may be switching from an old kernel to a new one. Given the old <strong class="source-inline">.config</strong> file, you can copy it into the new kernel source tree and run <strong class="source-inline">make oldconfig</strong>. If there are new options in the new kernel, you'll be prompted to include them or not. However, you may want to use the default values for those options. In this case, you should run <strong class="source-inline">make olddefconfig</strong>. Finally, to say no to every new option, you should run <strong class="source-inline">make oldnoconfig</strong>.</p>
			<p>There may be a <a id="_idIndexMarker044"/>better option to find an initial configuration file, especially if your machine is already running. Debian and Ubuntu Linux distributions save the <strong class="source-inline">.config</strong> file in the <strong class="source-inline">/boot</strong> directory, so you can use the following command to copy this configuration file:</p>
			<p class="source-code">cp /boot/config-`uname -r` .config</p>
			<p>The other distributions may not do this. So, I can recommend that you always enable the <strong class="source-inline">IKCONFIG</strong> and <strong class="source-inline">IKCONFIG_PROC</strong> kernel configuration options, which will enable access to <strong class="source-inline">.config</strong> through <strong class="source-inline">/proc/configs.gz</strong>. This is a standard method that also works with embedded distributions.</p>
			<h3>Some useful kernel configuration features</h3>
			<p>Now that we can <a id="_idIndexMarker045"/>configure the kernel, let's enumerate some useful configuration features that may be worth enabling in your kernel:</p>
			<ul>
				<li><strong class="source-inline">IKCONFIG</strong> and <strong class="source-inline">IKCONFIG_PROC</strong>: These are the most important to me. It makes your kernel configuration available at runtime, in <strong class="source-inline">/proc/config.gz</strong>. It can be useful either to reuse this config on another system or simply look for the enabled state of a particular feature; for example:<p class="source-code"><strong class="bold"># zcat /proc/config.gz | grep CONFIG_SOUND</strong></p><p class="source-code"><strong class="bold">CONFIG_SOUND=y</strong></p><p class="source-code"><strong class="bold">CONFIG_SOUND_OSS_CORE=y</strong></p><p class="source-code"><strong class="bold">CONFIG_SOUND_OSS_CORE_PRECLAIM=y</strong></p><p class="source-code"><strong class="bold"># CONFIG_SOUNDWIRE is not set</strong></p><p class="source-code"><strong class="bold">#  </strong></p></li>
				<li><strong class="source-inline">CMDLINE_EXTEND</strong> and <strong class="source-inline">CMDLINE</strong>: The first option is a Boolean that allows you to extend the kernel command line from within the configuration, while the second option is a string containing the actual command-line extension value; for example, <strong class="source-inline">CMDLINE="noinitrd usbcore.authorized_default=0"</strong>.</li>
				<li><strong class="source-inline">CONFIG_KALLSYMS</strong>: This is a Boolean option that makes the kernel symbol table (the mapping between symbols and their addresses) available in <strong class="source-inline">/proc/kallsyms</strong>. This is very useful for tracers and other tools that need to map kernel symbols to addresses. It is used while you're printing oops messages. Without this, oops listings would produce hexadecimal output, which is difficult to interpret.</li>
				<li><strong class="source-inline">CONFIG_PRINTK_TIME</strong>: This <a id="_idIndexMarker046"/>option shows timing information while printing messages from the kernel. It may be helpful to timestamp events that occurred at runtime.</li>
				<li><strong class="source-inline">CONFIG_INPUT_EVBUG</strong>: This allows you to debug input devices.</li>
				<li><strong class="source-inline">CONFIG_MAGIC_SYSRQ</strong>: This allows you to have some control (such as rebooting, dumping some status information, and so on) over the system, even after a crash, by simply using some combination keys. </li>
				<li><strong class="source-inline">DEBUG_FS</strong>: This enables support for debug filesystems, where <strong class="source-inline">GPIO</strong>, <strong class="source-inline">CLOCK</strong>, <strong class="source-inline">DMA</strong>, <strong class="source-inline">REGMAP</strong>, <strong class="source-inline">IRQs</strong>, and many other subsystems can be debugged from.</li>
			</ul>
			<ul>
				<li><strong class="source-inline">FTRACE</strong> and <strong class="source-inline">DYNAMIC_FTRACE</strong>: These options enable the powerful <strong class="source-inline">ftrace</strong> tracer, which can trace the whole system. Once <strong class="source-inline">ftrace</strong> has been enabled, some of its enumeration options can be enabled as well:<ul><li><strong class="source-inline">FUNCTION_TRACER</strong>: This allows you to trace any non-inline function in the kernel.</li><li><strong class="source-inline">FUNCTION_GRAPH_TRACER</strong>: This does the same thing as the previous command, but it shows a call graph (the caller and the callee functions).</li><li><strong class="source-inline">IRQSOFF_TRACER</strong>: This allows you to track off periods of IRQs in the kernel.</li><li><strong class="source-inline">PREEMPT_TRACER</strong>: This allows you to measure preemption off latency.</li><li><strong class="source-inline">SCHED_TRACER</strong>: This <a id="_idIndexMarker047"/>allows you to schedule latency tracing.</li></ul></li>
			</ul>
			<p>Now that the kernel has been configured, it must be built to generate a runnable kernel. In the next section, we will describe the kernel building process, as well as the expected build artifacts.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Building the Linux kernel</h2>
			<p>This step requires you<a id="_idIndexMarker048"/> to be in the same shell where you were during the configuration step; otherwise, you'll have to redefine the <strong class="source-inline">ARCH</strong> and <strong class="source-inline">CROSS_COMPILE</strong> environment variables.</p>
			<p>Linux is a Makefile-based project. Building such a project requires using the <strong class="source-inline">make</strong> tool and executing the <strong class="source-inline">make</strong> command. Regarding the Linux kernel, this command must be executed from the main kernel source directory, as a normal user.</p>
			<p>By default, if not specified, the make target is <strong class="source-inline">all</strong>. In the Linux kernel sources, for x86 architectures, this target points to (or depends on) <strong class="source-inline">vmlinux bzImage modules</strong> targets; for ARM or aarch64 architectures, it corresponds to <strong class="source-inline">vmlinux zImage modules dtbs</strong> targets.</p>
			<p>In these targets, <strong class="source-inline">bzImage</strong> is an x86-specific make target that produces a binary with the same name, <strong class="source-inline">bzImage</strong>. <strong class="source-inline">vmlinux</strong> is a make target that produces a Linux image called <strong class="source-inline">vmlinux</strong>. <strong class="source-inline">zImage</strong> and <strong class="source-inline">dtbs</strong> are both ARM- and aarch64-specific make targets. The first produces a Linux image with the same name, while the second builds the device tree sources for the target CPU variant. <strong class="source-inline">modules</strong> is a make target that will build all the selected modules (marked with <strong class="source-inline">m</strong> in the configuration).</p>
			<p>While building, you can leverage the host's CPU performance by running multiple jobs in parallel thanks to the <strong class="source-inline">-j</strong> make options. The following is an example: </p>
			<p class="source-code">make -j16</p>
			<p>Most people define their <strong class="source-inline">-j</strong> number as 1.5x the number of cores. In my case, I always use <strong class="source-inline">ncpus * 2</strong>. </p>
			<p>You can build the Linux kernel like so:</p>
			<ul>
				<li>For a native compilation, use the following command:<p class="source-code"><strong class="bold">make -j16</strong></p></li>
				<li>For a 32-bit ARM cross-compilation, use the following command:<p class="source-code"><strong class="bold">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make -j16</strong></p></li>
			</ul>
			<p>Each make target can be invoked separately, like so:</p>
			<p class="source-code">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs</p>
			<p>You can also do the<a id="_idIndexMarker049"/> following:</p>
			<p class="source-code">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make zImage -j16</p>
			<p>Finally, you can also do the following:</p>
			<p class="source-code">make bzImage -j16</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I have used <strong class="source-inline">-j16</strong> in my commands because my host has an 8-core CPU. This number of jobs must be adapted according to your host configuration.</p>
			<p>At the end of your 32-bit ARM cross-compilation jobs, you will see something like the following:</p>
			<p class="source-code">[…]</p>
			<p class="source-code">  LZO     arch/arm/boot/compressed/piggy_data</p>
			<p class="source-code">  CC      arch/arm/boot/compressed/misc.o</p>
			<p class="source-code">  CC      arch/arm/boot/compressed/decompress.o</p>
			<p class="source-code">  CC      arch/arm/boot/compressed/string.o</p>
			<p class="source-code">  SHIPPED arch/arm/boot/compressed/hyp-stub.S</p>
			<p class="source-code">  SHIPPED arch/arm/boot/compressed/lib1funcs.S</p>
			<p class="source-code">  SHIPPED arch/arm/boot/compressed/ashldi3.S</p>
			<p class="source-code">  SHIPPED arch/arm/boot/compressed/bswapsdi2.S</p>
			<p class="source-code">  AS      arch/arm/boot/compressed/hyp-stub.o</p>
			<p class="source-code">  AS      arch/arm/boot/compressed/lib1funcs.o</p>
			<p class="source-code">  AS      arch/arm/boot/compressed/ashldi3.o</p>
			<p class="source-code">  AS      arch/arm/boot/compressed/bswapsdi2.o</p>
			<p class="source-code">  AS      arch/arm/boot/compressed/piggy.o</p>
			<p class="source-code">  LD      arch/arm/boot/compressed/vmlinux</p>
			<p class="source-code">  OBJCOPY arch/arm/boot/zImage</p>
			<p class="source-code">  Kernel: arch/arm/boot/zImage is ready</p>
			<p>By using the default <a id="_idIndexMarker050"/>targets, various binaries will result from the build process, depending on the architecture. These are as follows:</p>
			<ul>
				<li><strong class="source-inline">arch/&lt;arch&gt;/boot/Image</strong>: An uncompressed kernel image that can be booted</li>
				<li> <strong class="source-inline">arch/&lt;arch&gt;/boot/*Image*</strong>: A compressed kernel image that can also be booted:</li>
			</ul>
			<p>This is <strong class="source-inline">bzImage</strong> (which means "big zImage") for x86, <strong class="source-inline">zImage</strong> for ARM or aarch64, and <strong class="source-inline">vary</strong> for other architectures.</p>
			<ul>
				<li><strong class="source-inline">arch/&lt;arch&gt;/boot/dts/*.dtb</strong>: This provides compiled device tree blobs for the selected CPU variant.</li>
				<li><strong class="source-inline">vmlinux</strong>: This is a raw, uncompressed, and unstripped kernel image in ELF format. It's useful for debugging purposes but generally not used for booting purposes.</li>
			</ul>
			<p>Now that we know how to (cross-)compile the Linux kernel, let's learn how to install it.</p>
			<h3>Installing the Linux kernel</h3>
			<p>The Linux kernel<a id="_idIndexMarker051"/> installation process differs in terms of native compilation or cross-compilation:</p>
			<ul>
				<li>In native installation (that is, you're installing host), you can simply run <strong class="source-inline">sudo make install</strong>. You must use <strong class="source-inline">sudo</strong> because the installation will take place in the <strong class="source-inline">/boot</strong> directory. If you're doing an x86 native installation, the following files are shipped:<ul><li><strong class="source-inline">/boot/vmlinuz-&lt;version&gt;</strong>: This is the compressed and stripped variant of <strong class="source-inline">vmlinux</strong>. It is the same kernel image as the one in <strong class="source-inline">arch/&lt;arch&gt;/boot</strong>.</li><li><strong class="source-inline">/boot/System.map-&lt;version&gt;</strong>: This stores the kernel symbol table (the mapping between the kernel symbols and their addresses), not just for debugging, but also to allow some kernel modules to resolve their symbols and load properly. This file only contains a static kernel symbol table, while <strong class="source-inline">/proc/kallsyms</strong> (provided that <strong class="source-inline">CONFIG_KALLSYMS</strong> is enabled in the config) on the running kernel contains <strong class="source-inline">System.map</strong> and the loaded kernel module symbols.</li><li><strong class="source-inline">/boot/config-&lt;version&gt;</strong>: This corresponds to the kernel configuration for the version that's been built.</li></ul></li>
				<li>An embedded<a id="_idIndexMarker052"/> installation usually uses a single file kernel. Moreover, the target is not accessible, which makes manual installation preferred. Thus, embedded Linux build systems (such as Yocto or Buildroot) use internal scripts to make the kernel image available in the target root filesystem. While embedded installation may be straightforward thanks to the use of build systems, native installation (especially x86 native installation) can require running additional bootloader-related commands (such as <strong class="source-inline">update-grub2</strong>) to make the new kernel visible to the system.</li>
			</ul>
			<p>Now that we are familiar with the kernel configuration, including the build and installation processes, let's look at kernel modules, which allow you to extend the kernel at runtime.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>Building and installing modules</h1>
			<p>Modules can <a id="_idIndexMarker053"/>be built separately using the <strong class="source-inline">modules</strong> target. You can install them using the <strong class="source-inline">modules_install</strong> target. Modules are built in the same directory as their corresponding source. Thus, the resulting kernel objects are spread over the kernel source tree:</p>
			<ul>
				<li>For a native build and <a id="_idIndexMarker054"/>installation, you can use the following commands:<p class="source-code"><strong class="bold">make modules</strong></p><p class="source-code"><strong class="bold">sudo make modules_install</strong></p></li>
			</ul>
			<p>The resulting modules will be installed in <strong class="source-inline">/lib/modules/$(uname -r)/kernel/</strong>, in the same directory structure as their corresponding source. A custom install path can be specified using the <strong class="source-inline">INSTALL_MOD_PATH</strong> environment variable.</p>
			<ul>
				<li>When you're cross-compiling for embedded systems, as with all <strong class="source-inline">make</strong> commands, <strong class="source-inline">ARCH</strong> and <strong class="source-inline">CROSS_COMPILE</strong> must be specified. As it is not possible to install a directory in the target device filesystem, embedded Linux build systems (such as Yocto or Buildroot) set <strong class="source-inline">INSTALL_MOD_PATH</strong> to a path that corresponds to the target root filesystem so that the final root filesystem image contains the modules that have been built; otherwise, the modules will be installed on the host. The following is an example of a 32-bit ARM architecture:<p class="source-code"><strong class="bold">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make modules</strong></p><p class="source-code"><strong class="bold">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=&lt;dir&gt; make modules_install</strong></p></li>
			</ul>
			<p>In addition to the <strong class="source-inline">kernel</strong> directory that is shipped with modules, the following files are installed in <strong class="source-inline">/lib/modules/&lt;version&gt;</strong> as well:</p>
			<ul>
				<li><strong class="source-inline">modules.builtin</strong>: This lists all the kernel objects (<strong class="source-inline">.ko</strong>) that are built into the kernel. It is used by the module loading utility (<strong class="source-inline">modprobe</strong>, for example) so that it does not fail when it's trying to load something that's already built in. <strong class="source-inline">modules.builtin.bin</strong> is its binary counterpart.</li>
				<li><strong class="source-inline">modules.alias</strong>: This contains the aliases for module loading utilities, which are used to match drivers and devices. This concept of module aliases will be explained in <a href="B17934_06_Epub.xhtml#_idTextAnchor095"><em class="italic">Chapter 6</em></a>, <em class="italic">Introduction to Devices, Drivers, and Platform Abstraction</em>. <strong class="source-inline">modules.alias.bin</strong> is its binary equivalent. </li>
				<li><strong class="source-inline">modules.dep</strong>: This <a id="_idIndexMarker055"/>lists modules, along with their dependencies. <strong class="source-inline">modules.dep.bin</strong> is its binary counterpart.</li>
				<li><strong class="source-inline">modules.symbols</strong>: This<a id="_idIndexMarker056"/> tells us which module a given symbol belongs to. They are in the form of <strong class="source-inline">alias symbol:&lt;symbol&gt; &lt;modulename&gt;</strong>. An example is <strong class="source-inline">alias symbol:v4l2_async_notifier_register videodev</strong>. <strong class="source-inline">modules.symbols.bin</strong> is the binary counterpart of this file.</li>
			</ul>
			<p>With that, we have installed the necessary modules. We've finished learning how to build and install Linux kernels and modules. We've also finished learning how to configure the Linux kernel and add the features we need.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Summary</h1>
			<p>In this chapter, you learned how to download the Linux source and process your first build. We also covered some common operations, such as configuring or selecting the appropriate toolchain. That said, this chapter was quite brief; it was just an introduction. This is why, in the next chapter, we will cover the kernel building process, how to compile a driver (either externally or as part of the kernel), and some basics that you should learn before you start the long journey that kernel development represents. Let's take a look!  </p>
		</div>
	</body></html>