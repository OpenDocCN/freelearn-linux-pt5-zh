<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-25"><em class="italic"><a id="_idTextAnchor025"/>Chapter 2</em>: Understanding Linux Kernel Module Basic Concepts</h1>
			<p>A kernel module is a piece of software whose aim is to extend the Linux kernel with a new feature. A kernel module can be a device driver, in which case it would control and manage a particular hardware device, hence the name <strong class="bold">device driver</strong>. A module can also add a framework support (for example <strong class="bold">IIO</strong>, the <strong class="bold">Industrial Input Output</strong> framework), extend an existing framework, or even a new filesystem or an extension of it. The thing to keep in mind is that kernel modules are not always device drivers, whereas device drivers are always kernel modules.</p>
			<p>In opposition to kernel modules, there might be simple modules or user space modules, running in user space, with low privileges. This book, however, exclusively deals with kernel space modules, particularly Linux kernel modules.</p>
			<p>That being said, this chapter will discuss the following topics:</p>
			<ul>
				<li>An introduction to the concept of modules</li>
				<li>Building a Linux kernel module</li>
				<li>Dealing with symbol exports and module dependencies</li>
				<li>Learning some Linux kernel programming tips</li>
			</ul>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>An introduction to the concept of modules</h1>
			<p>When building the Linux kernel, the resulting image is a single file made by the linking of all object files that correspond to features enabled in the configuration. As a result, all included features are <a id="_idIndexMarker057"/>therefore available as soon as the kernel starts, even if the filesystem is not yet ready or does not exist. These features are built-in, and the corresponding modules are called static modules. Such a module is available at any time in the kernel image and thus can't be unloaded, at the cost of extra size to the final <a id="_idIndexMarker058"/>kernel image. A static module is also known as a built-in module, since it is part of the final kernel image output. Any change in its code will require the whole kernel to be rebuilt.</p>
			<p>Some features (such as device drivers, filesystems, and frameworks) can, however, be compiled as loadable modules. Such modules are separated from the final kernel image and are loaded on demand. These can be considered as plugins that can be loaded/unloaded dynamically to <a id="_idIndexMarker059"/>add or remove features (at runtime) to the kernel. Because each module is stored as a separate file on the filesystem, using loadable modules requires access to a filesystem.</p>
			<p>To summarize, a module is to the Linux kernel what a plugin (add-on) is to user software (for example, Firefox). When it is statically linked to the resulting kernel image, it is said to be built in. When it is built as a separate file (which can be loaded/unloaded), it is loadable. It dynamically extends the kernel features without even the need to restart the machine.</p>
			<p>To support module loading, the kernel must have been built with the following option enabled:</p>
			<p class="source-code">CONFIG_MODULES=y</p>
			<p>Unloading modules is a kernel feature that can be enabled or disabled according to the <strong class="source-inline">CONFIG_MODULE_UNLOAD</strong> kernel configuration option. Without this option, we won't be able to unload any module. Thus, to be able to unload modules, the following feature must be enabled:</p>
			<p class="source-code">CONFIG_MODULE_UNLOAD=y</p>
			<p>That said, the kernel is smart enough to prevent unloading modules that may probably break things (for example, because these are in use), even if it is asked to do so. This is because the kernel keeps a reference count of module usage so that it knows whether a module is currently in use or not. If the kernel believes it is unsafe to remove a module, it will not. We can, however, change this behavior with the following configuration feature: </p>
			<p class="source-code">MODULE_FORCE_UNLOAD=y</p>
			<p>The preceding option allows us to force module unload.</p>
			<p>Now that we are done with the main concepts behind modules, let's start practicing, first by introducing a module skeleton that will serve as a basis for this chapter.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Case study – module skeleton</h2>
			<p>Let's consider the following <strong class="source-inline">hello-world</strong> module. It will be the basis for our work throughout this <a id="_idIndexMarker060"/>chapter. Let's call its compilation unit <strong class="source-inline">helloworld.c</strong>, with <a id="_idIndexMarker061"/>the following content:</p>
			<p class="source-code">#include &lt;linux/module.h&gt;</p>
			<p class="source-code">#include &lt;linux/init.h&gt;</p>
			<p class="source-code">static int __init helloworld_init(void) {</p>
			<p class="source-code">    pr_info("Hello world initialization!\n");</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p class="source-code">static void __exit helloworld_exit(void) {</p>
			<p class="source-code">    pr_info("Hello world exit\n");</p>
			<p class="source-code">}</p>
			<p class="source-code">module_init(helloworld_init);</p>
			<p class="source-code">module_exit(helloworld_exit);</p>
			<p class="source-code">MODULE_LICENSE("GPL");</p>
			<p class="source-code">MODULE_AUTHOR("John Madieu &lt;john.madieu@gmail.com&gt;");</p>
			<p class="source-code">MODULE_DESCRIPTION("Linux kernel module skeleton");</p>
			<p>In the preceding skeleton, headers are specific to the Linux kernel, hence the use of <strong class="source-inline">linux/xxx.h</strong>. The <strong class="source-inline">module.h</strong> header file is mandatory for all kernel modules, and <strong class="source-inline">init.h</strong> is needed for the <strong class="source-inline">__init</strong> and <strong class="source-inline">__exit</strong> macros. Other elements are described in the next sections. To build this skeleton module, we need to write a <em class="italic">special</em> makefile, which will be covered a little bit later in this chapter.</p>
			<h3>Module entry and exit points</h3>
			<p>The minimal requirement of a kernel module is an initialization method. This is a must. If the module can be <a id="_idIndexMarker062"/>built as a loadable module, then the <strong class="source-inline">exit</strong> method must be <a id="_idIndexMarker063"/>provided as well. The first method is the entry point and corresponds to the function called when the module is loaded (<strong class="source-inline">modprobe</strong> or <strong class="source-inline">insmod</strong>), and the latter is the cleanup and exit point and corresponds to the function executed at module unloading (at <strong class="source-inline">rmmod</strong> or <strong class="source-inline">modprobe -r</strong>).</p>
			<p>All you need to do is to inform the kernel about which functions should be executed as an entry or exit point. The <strong class="source-inline">helloworld_init</strong> and <strong class="source-inline">helloworld_exit</strong> functions can be given <a id="_idIndexMarker064"/>any name. The only thing that is actually mandatory is to identify them as the corresponding <a id="_idIndexMarker065"/>initialization and exit functions, passing them as parameters to the <strong class="source-inline">module_init()</strong> and <strong class="source-inline">module_exit()</strong> macros.</p>
			<p>To sum up, <strong class="source-inline">module_init()</strong> is used to declare the function that should be called when the module is loaded (with <strong class="source-inline">insmod</strong> or <strong class="source-inline">modprobe</strong> when the module is built as a loadable kernel module) or when the kernel reaches the run level corresponding to this module (when built-in). What is done in the initialization function will define the behavior of the module. <strong class="source-inline">module_exit()</strong> is used only when the module can be built as a loadable kernel module. It declares the function that should be called when the module is unloaded (with <strong class="source-inline">rmmod</strong>).</p>
			<p><strong class="source-inline">init</strong> or <strong class="source-inline">exit</strong> methods are invoked only once, whatever the number of devices currently handled by the module, provided the module is a device driver. It is common for modules that are platform (or alike) device drivers to register a platform driver and the associated <strong class="source-inline">probe</strong>/<strong class="source-inline">remove</strong> callback in their <strong class="source-inline">init</strong> functions, which this time will be invoked each time a device handled by the module is added or removed on the system. In such a case, they just unregister the platform driver from within their <strong class="source-inline">exit</strong> method.</p>
			<h4>__init and __exit attributes</h4>
			<p><strong class="source-inline">__init</strong> and <strong class="source-inline">__exit</strong> are kernel <a id="_idIndexMarker066"/>macros, defined in <strong class="source-inline">include/linux/init.h</strong>, as <a id="_idIndexMarker067"/>shown here:</p>
			<p class="source-code">#define __init      __section(.init.text)</p>
			<p class="source-code">#define __exit      __section(.exit.text)</p>
			<p>The <strong class="source-inline">__init</strong> keyword tells the linker to place the symbols (variables or functions) they prefix in a dedicated section in the resulting kernel object file. This section is known in advance to the kernel <a id="_idIndexMarker068"/>and freed when the module is loaded and the initialization function has finished. This applies only to built-in modules, not to loadable ones. The kernel will run the initialization function of the driver for the first time during its boot sequence. Since the driver cannot be unloaded, its initialization function will never be called again until the next reboot. There is no need to keep references on this initialization function anymore. It is the same for the <strong class="source-inline">__exit</strong> keyword and the <strong class="source-inline">exit</strong> method, whose <a id="_idIndexMarker069"/>corresponding code is omitted when the module is compiled statically into the kernel or when module unloading support is not enabled because, in both cases, the exit function is never called. <strong class="source-inline">__exit</strong> has no effect on loadable modules.</p>
			<p>In conclusion, <strong class="source-inline">__init</strong> and <strong class="source-inline">__exit</strong> are Linux directives (macros) that wrap GNU C compiler attributes used for symbol placement. They instruct the compiler to put the code they prefix in the <strong class="source-inline">.init.text</strong> and <strong class="source-inline">.exit.text</strong> sections, respectively, even though the kernel can access different object sections.</p>
			<h3>Module information and metadata</h3>
			<p>Without having to read its code, it should be possible to gather some information (such as the author(s), module parameter <a id="_idIndexMarker070"/>descriptions, and the license) about a given <a id="_idIndexMarker071"/>module. A kernel module uses its <strong class="source-inline">.modinfo</strong> section to store information about the module. Any <strong class="source-inline">MODULE_*</strong> macro will update the content of this section with the values passed as parameters. Some of these macros are <strong class="source-inline">MODULE_DESCRIPTION()</strong>, <strong class="source-inline">MODULE_AUTHOR()</strong>, and <strong class="source-inline">MODULE_LICENSE()</strong>. That said, the real underlying macro provided by the kernel to add an entry to the module information section is <strong class="source-inline">MODULE_INFO(tag, info)</strong>, which adds generic information of the <strong class="source-inline">tag = "info"</strong> form. This means a driver author can add any freeform information they want, such as the following:</p>
			<p class="source-code">MODULE_INFO(my_field_name, "What easy value");</p>
			<p>As well as the custom information we define, there is standard information we should provide, which the kernel provides macros for: </p>
			<ul>
				<li><strong class="source-inline">MODULE_LICENSE</strong>: The license will define how your source code should be shared (or not) with other developers. <strong class="source-inline">MODULE_LICENSE()</strong> tells the kernel what license our module is under. It has an effect on your module behavior, since a license that is not compatible with GPL (General Public License) will result in your module not being able to see/use symbols exported by the kernel through the <strong class="source-inline">EXPORT_SYMBOL_GPL()</strong> macro, which shows the symbols for GPL-compatible modules only. This is the opposite of <strong class="source-inline">EXPORT_SYMBOL()</strong>, which exports functions for modules with any license. Loading a non-GPL-compatible module will <a id="_idIndexMarker072"/>also result in a tainted kernel; that means non-open <a id="_idIndexMarker073"/>source or untrusted code has been loaded, and you will likely have no support from the community. Remember that the module without <strong class="source-inline">MODULE_LICENSE()</strong> is not considered open source and will taint the kernel too. Available licenses can be found in <strong class="source-inline">include/linux/module.h</strong>, describing the license supported by the kernel. </li>
				<li><strong class="source-inline">MODULE_AUTHOR()</strong> declares the module's author(s): <strong class="source-inline">MODULE_AUTHOR("John Madieu &lt;john.madieu@foobar.com&gt;");</strong>. It is possible to have more than one author. In this case, each author must be declared with <strong class="source-inline">MODULE_AUTHOR()</strong>: <p class="source-code">MODULE_AUTHOR("John Madieu &lt;john.madieu@foobar.com&gt;");</p><p class="source-code">MODULE_AUTHOR("Lorem Ipsum &lt;l.ipsum@foobar.com&gt;");</p></li>
				<li><strong class="source-inline">MODULE_DESCRIPTION()</strong> briefly describes what the module does: <strong class="source-inline">MODULE_DESCRIPTION("Hello, world! Module")</strong>.</li>
			</ul>
			<p>You can dump the content of the <strong class="source-inline">.modeinfo</strong> section of a kernel module using the <strong class="source-inline">objdump  -d -j .modinfo</strong> command on the given module. For a cross-compiled module, you should use <strong class="source-inline">$(CORSS_COMPILE)objdump</strong> instead.</p>
			<p>Now that we are done with providing module information and metadata, which are the last requirements when writing Linux kernel modules, let's learn how to build these modules.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Building a Linux kernel module</h1>
			<p>Two solutions <a id="_idIndexMarker074"/>exist for compiling a kernel module:</p>
			<ul>
				<li>The first solution is when code is outside of the kernel source tree, which is also known as out-of-tree building. The module source code is in a different directory. Building a module this way does not allow integration into the kernel configuration/compilation process, and the module needs to be built separately. It must be noted that with this solution, the module cannot be statically linked in the final kernel image – that is, it cannot be built in. Out-of-tree compilation only allows loadable kernel modules to be produced.</li>
				<li>The second solution is inside the kernel tree, which allows you to upstream your code, since it is well <a id="_idIndexMarker075"/>integrated into the kernel configuration/compilation process. This solution allows you to produce either a statically linked module (also known as built-in) or a loadable kernel module.</li>
			</ul>
			<p>Now that we have enumerated and given the characteristics of the two possible solutions for building kernel modules, before studying each of them, let's first dig into the Linux kernel build process. This will help us to understand compilation prerequisites for each solution.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Understanding the Linux kernel build system</h2>
			<p>The Linux kernel maintains its own build system. It is called <strong class="bold">kbuild</strong> (note that the k is lower case). It allows <a id="_idIndexMarker076"/>you to configure the Linux kernel and compile it based on <a id="_idIndexMarker077"/>the configuration that has been done. It relies essentially on three files to achieve that. These are <strong class="source-inline">Kconfig</strong>, for feature selections, mainly used with in-kernel tree building, and <strong class="source-inline">Kbuild</strong> (note that the K is uppercase this time) or <strong class="source-inline">Makefile</strong>, for compilation rules.</p>
			<h3>The Kbuild or Makefile files</h3>
			<p>From within this <a id="_idIndexMarker078"/>build system, the makefile can be called either <strong class="source-inline">Makefile</strong> or <strong class="source-inline">Kbuild</strong>. If both <a id="_idIndexMarker079"/>files exist, only <strong class="source-inline">Kbuild</strong> will be used. That said, a makefile is a special file used to execute a set of actions, among which the most common is the compilation of programs. There is a dedicated tool to parse makefiles, called <strong class="source-inline">make</strong>. Using this tool, a kernel module build command pattern resembles the following:</p>
			<p class="source-code">make -C $KERNEL_SRC M=$(shell pwd) [target]</p>
			<p>In the preceding pattern, <strong class="source-inline">$KERNEL_SRC</strong> refers to the path of the prebuilt kernel directory, <strong class="source-inline">-C $KERNEL_SRC</strong> instructs <strong class="source-inline">make</strong> to change into the specified directory when executing and change <a id="_idIndexMarker080"/>back when finished, and <strong class="source-inline">M=$(shell pwd)</strong> instructs the kernel <a id="_idIndexMarker081"/>build system to move back into this directory to find the module that is being built. The value given to <strong class="source-inline">M</strong> is the absolute path of the directory where the module sources (or the associated <strong class="source-inline">Kbuild</strong> file) are located. <strong class="source-inline">[target]</strong> corresponds to the subset of the <strong class="source-inline">make</strong> targets available when building an external module. These are as follows:</p>
			<ul>
				<li><strong class="source-inline">modules</strong>: This is the default target for external modules. It has the same functionality as if no target was specified.</li>
				<li><strong class="source-inline">modules_install</strong>: This installs the external module(s). The default location is <strong class="source-inline">/lib/modules/&lt;kernel_release&gt;/extra/</strong>. This path can be overridden.</li>
				<li><strong class="source-inline">clean</strong>: This removes all generated files (in the module directory only).</li>
			</ul>
			<p>However, we have not told the build system what object files to build or to link together. We must specify the name of the module(s) to be built, along with the list of requisite source files. It can be as simple as the following single line: </p>
			<p class="source-code">obj-&lt;X&gt; := &lt;module_name&gt;.o</p>
			<p>In the preceding, the kernel build system will build <strong class="source-inline">&lt;module_name&gt;.o</strong> from <strong class="source-inline">&lt;module_name&gt;.c</strong> or <strong class="source-inline">&lt;module_name&gt;.S</strong>, and after linking, it will result in the <strong class="source-inline">&lt;module_name&gt;.ko</strong> kernel loadable module or will be part of the single-file kernel image. <strong class="source-inline">&lt;X&gt;</strong> can be either <strong class="source-inline">y</strong>, <strong class="source-inline">m</strong>, or left blank. </p>
			<p>How and if <strong class="source-inline">mymodule.o</strong> will be built or linked depends on the value of <strong class="source-inline">&lt;X&gt;</strong>:</p>
			<ul>
				<li>If <strong class="source-inline">&lt;X&gt;</strong> is set to <strong class="source-inline">m</strong>, the <strong class="source-inline">obj-m</strong> variable is used, and <strong class="source-inline">mymodule.o</strong> will be built as a loadable kernel module.</li>
				<li>If <strong class="source-inline">&lt;X&gt;</strong> is set to <strong class="source-inline">y</strong>, the <strong class="source-inline">obj-y</strong> variable is used, and <strong class="source-inline">mymodule.o</strong> will be built as part of the kernel. You then say "<strong class="source-inline">foo</strong> is a built-in kernel module".</li>
				<li>If <strong class="source-inline">&lt;X&gt;</strong> is not set, the <strong class="source-inline">obj-</strong> variable is used, and <strong class="source-inline">mymodule.o</strong> will not be built at all.</li>
			</ul>
			<p>However, the <strong class="source-inline">obj-$(CONFIG_XXX)</strong> pattern is often used, where <strong class="source-inline">CONFIG_XXX</strong> is a kernel configuration option, set or not, during the kernel configuration process. An example is the following:</p>
			<p class="source-code">obj-$(CONFIG_MYMODULE) += mymodule.o</p>
			<p><strong class="source-inline">$(CONFIG_MYMODULE)</strong> evaluates to either <strong class="source-inline">y</strong>, <strong class="source-inline">m</strong>, or nothing (blank), according to its value during the kernel <a id="_idIndexMarker082"/>configuration (displayed with <strong class="source-inline">menuconfig</strong>). If <strong class="source-inline">CONFIG_MYMODULE</strong> is neither <strong class="source-inline">y</strong> nor <strong class="source-inline">m</strong>, then the file will not be compiled nor linked. <strong class="source-inline">y</strong> means <a id="_idIndexMarker083"/>built-in (it stands for <strong class="source-inline">yes</strong> in the kernel configuration process), and <strong class="source-inline">m</strong> stands for a loadable module. <strong class="source-inline">$(CONFIG_MYMODULE)</strong> pulls the right answer from the normal config process. </p>
			<p>So far, we have assumed the module is built from a single <strong class="source-inline">.c</strong> source file. When the module is built from multiple source files, an additional line is needed for listing these source files, as shown here:</p>
			<p class="source-code">&lt;module_name&gt;-y := &lt;file1&gt;.o &lt;file2&gt;.o</p>
			<p>The preceding says that <strong class="source-inline">&lt;module_name&gt;.ko</strong> will be built from two files, <strong class="source-inline">file1.c</strong> and <strong class="source-inline">file2.c</strong>. However, if you wanted to build two modules, let's say <strong class="source-inline">foo.ko</strong> and <strong class="source-inline">bar.ko</strong>, the <strong class="source-inline">Makefile</strong> line would be as follows:</p>
			<p class="source-code">obj-m := foo.o bar.o</p>
			<p>If <strong class="source-inline">foo.o</strong> and <strong class="source-inline">bar.o</strong> are made of source files other than <strong class="source-inline">foo.c</strong> and <strong class="source-inline">bar.c</strong>, you can specify the appropriate source files of each object file, as shown here:</p>
			<p class="source-code">obj-m := foo.o bar.o</p>
			<p class="source-code">foo-y := foo1.o foo2.o . . .</p>
			<p class="source-code">bar-y := bar1.o bar2.o bar3.o . . .</p>
			<p>The following is another example of listing the requisite source files to build a given module:</p>
			<p class="source-code">obj-m := 8123.o</p>
			<p class="source-code">8123-y := 8123_if.o 8123_pci.o 8123_bin.o</p>
			<p>The preceding example says that <strong class="source-inline">8123</strong> should be built as a loadable kernel module by building and linking <strong class="source-inline">8123_if.c</strong>, <strong class="source-inline">8123_pci.c</strong>, and <strong class="source-inline">8123_bin.c</strong> together.</p>
			<p>Apart from the files being part of the resulting build artifact, the <strong class="source-inline">Makefile</strong> file can also contain compiler and linker flags, such as the following:</p>
			<p class="source-code">ccflags-y := -I$(src)/include</p>
			<p class="source-code">ccflags-y += -I$(src)/src/hal/include</p>
			<p class="source-code">ldflags-y := -T$(src)foo_sections.lds</p>
			<p>What is important <a id="_idIndexMarker084"/>here is the fact that such flags can be specified as well, not the values <a id="_idIndexMarker085"/>we have set in the example.</p>
			<p>There is another use case of <strong class="source-inline">obj-&lt;X&gt;</strong>, described in the following:</p>
			<p class="source-code">obj-&lt;X&gt; += somedir/</p>
			<p>This means that the kernel build system should go into the directory named <strong class="source-inline">somedir</strong> and look for any <strong class="source-inline">Makefile</strong> or <strong class="source-inline">Kbuild</strong> files inside, processing it in order to decide what objects should be built.</p>
			<p>We can summarize what we just said with the following Makefile:</p>
			<p class="source-code"># kbuild part of makefile</p>
			<p class="source-code">obj-m := helloworld.o</p>
			<p class="source-code">#the following is just an example</p>
			<p class="source-code">#ldflags-y := -T foo_sections.lds</p>
			<p class="source-code"># normal makefile</p>
			<p class="source-code">KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build</p>
			<p class="source-code">all default: modules</p>
			<p class="source-code">install: modules_install</p>
			<p class="source-code">modules modules_install help clean:</p>
			<p class="source-code">    $(MAKE) -C $(KERNEL_SRC) M=$(shell pwd) $@</p>
			<p>The following describes this minimalist <strong class="source-inline">Makefile</strong> skeleton:</p>
			<ul>
				<li><strong class="source-inline">obj-m := helloworld.o</strong>: <strong class="source-inline">obj-m</strong> lists modules we want to build. For each <strong class="source-inline">&lt;filename&gt;.o</strong>, the build system will look for <strong class="source-inline">&lt;filename&gt;.c</strong> or <strong class="source-inline">&lt;filename&gt;.S</strong> to build. <strong class="source-inline">obj-m</strong> is used to build a loadable kernel module, whereas <strong class="source-inline">obj-y</strong> will result in a built-in kernel module.</li>
				<li><strong class="source-inline">KERNEL_SRC= /lib/modules/$(shell uname -r)/build</strong>: <strong class="source-inline">KERNEL_SRC</strong> is the location of the prebuilt kernel source. As we said earlier, we need a prebuilt kernel in <a id="_idIndexMarker086"/>order to build any module. If you have built your kernel from <a id="_idIndexMarker087"/>the source, you should set this variable with the absolute path of the built source directory. <strong class="source-inline">–C</strong> instructs the <strong class="source-inline">make</strong> utility to change into the specified directory reading the makefiles.</li>
				<li><strong class="source-inline">M=$(shell pwd)</strong>: This is relevant to the kernel build system. The <strong class="source-inline">Makefile</strong> kernel uses this variable to locate the directory of an external module to build. Your <strong class="source-inline">.c</strong> files should be placed in that directory.</li>
				<li><strong class="source-inline">all default</strong>: <strong class="source-inline">modules</strong>: This line instructs the <strong class="source-inline">make</strong> utility to execute the <strong class="source-inline">modules</strong> target as a dependency of <strong class="source-inline">all</strong> or <strong class="source-inline">default</strong> targets. In other words, <strong class="source-inline">make default</strong>, <strong class="source-inline">make all</strong>, or simple <strong class="source-inline">make</strong> commands will result in  <strong class="source-inline">make modules</strong> being executed prior to execute any subsequent command if any. </li>
				<li><strong class="source-inline">modules modules_install help clean</strong>: This line represents the list target that is valid in this makefile.</li>
				<li><strong class="source-inline">$(MAKE) -C $(KERNELDIR) M=$(shell pwd) $@</strong>: This is the rule to be executed for each of the targets enumerated previously. <strong class="source-inline">$@</strong> will be replaced with the parameters given to <strong class="source-inline">make</strong>, which includes the target. Using this kind of magic word prevents us from writing as many (identical) lines as there are targets. In other words, if you run <strong class="source-inline">make modules</strong>, <strong class="source-inline">$@</strong> will be replaced with <strong class="source-inline">modules</strong>, and the rule will become <strong class="source-inline">$(MAKE) -C $(KERNELDIR) M=$(shell pwd) modules</strong>.</li>
			</ul>
			<p>Now that we are familiar <a id="_idIndexMarker088"/>with the kernel build system requirements, let's see how <a id="_idIndexMarker089"/>modules are actually built.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>Out-of-tree building</h2>
			<p>Before you can build an external module, you need to have a complete and precompiled kernel source tree. The prebuilt kernel version must be the same as the kernel you'll load and use <a id="_idIndexMarker090"/>your module with. There are two ways to obtain a prebuilt kernel version:</p>
			<ul>
				<li>Building it by yourself (which we discussed earlier): This can be used for both native and cross-compilation. Using a build system such as Yocto or Buildroot may help.</li>
				<li>Installing the <strong class="source-inline">linux-headers-*</strong> package from the distribution package feed: This applies only for x86 native compilations unless your embedded target runs a Linux distribution that maintains a package feed (such as Raspbian).</li>
			</ul>
			<p>It must be noted that is it not possible to build a built-in kernel module with out-of-tree building. The reason is that building a Linux kernel module out of tree requires a prebuilt or prepared kernel.</p>
			<h3>Native and out-of-tree module compiling</h3>
			<p>With a native kernel module build, the easiest way is to install the prebuilt kernel headers and to use their <a id="_idIndexMarker091"/>directory path as the kernel directory in the <a id="_idIndexMarker092"/>makefile. Before we start doing so, headers can be installed with the following command:</p>
			<p class="source-code">sudo apt update</p>
			<p class="source-code">sudo apt install linux-headers-$(uname -r)</p>
			<p>This will install preconfigured and prebuilt kernel headers (not the whole source tree) in <strong class="source-inline">/usr/src/linux-headers-$(uname -r)</strong>. There will be a symbolic link, <strong class="source-inline">/lib/modules/$(uname -r)/build</strong>, pointing to the previously installed headers. It is the path you should specify as the kernel directory in <strong class="source-inline">Makefile</strong>. You should remember that <strong class="source-inline">$(uname -r)</strong> corresponds to the kernel version in use.</p>
			<p>Now, when you are done with the makefile, still in your module source directory, run the <strong class="source-inline">make</strong> command or <strong class="source-inline">make modules</strong>:</p>
			<p class="source-code">$ make</p>
			<p class="source-code">make -C /lib/modules/ 5.11.0-37-generic/build \</p>
			<p class="source-code">    M=/home/john/driver/helloworld modules</p>
			<p class="source-code">make[1]: Entering directory '/usr/src/linux-headers- 5.11.0-37-generic'</p>
			<p class="source-code">  CC [M]  /media/jma/DATA/work/tutos/sources/helloworld/helloworld.o</p>
			<p class="source-code">  Building modules, stage 2.</p>
			<p class="source-code">  MODPOST 1 modules</p>
			<p class="source-code">  CC      /media/jma/DATA/work/tutos/sources/helloworld/helloworld.mod.o</p>
			<p class="source-code">  LD [M]  /media/jma/DATA/work/tutos/sources/helloworld/helloworld.ko</p>
			<p class="source-code">make[1]: Leaving directory '/usr/src/linux-headers- 5.11.0-37-generic'</p>
			<p>At the end <a id="_idIndexMarker093"/>of the build, you'll have the following:</p>
			<p class="source-code">$ ls</p>
			<p class="source-code">helloworld.c  helloworld.ko  helloworld.mod.c  helloworld.mod.o  helloworld.o  Makefile  modules.order  Module.symvers</p>
			<p>To test, you can do the following:</p>
			<p class="source-code">$ sudo insmod  helloworld.ko</p>
			<p class="source-code">$ sudo rmmod helloworld</p>
			<p class="source-code">$ dmesg</p>
			<p class="source-code">[...]</p>
			<p class="source-code">[308342.285157] Hello world initialization!</p>
			<p class="source-code">[308372.084288] Hello world exit</p>
			<p>The preceding example only deals with a native build, compiling on a machine running a standard <a id="_idIndexMarker094"/>distribution, allowing us to leverage its package repository to install prebuilt kernel headers. In the next section, we will discuss out-of-tree module cross-compilation.</p>
			<h3>Out-of-tree module cross-compiling</h3>
			<p>When it comes to cross-compiling an out-of-tree kernel module, there are essentially two variables that <a id="_idIndexMarker095"/>the kernel <strong class="source-inline">make</strong> command needs to be aware of. These are <strong class="source-inline">ARCH</strong> and <strong class="source-inline">CROSS_COMPILE</strong>, which respectively represent the target architecture and the cross-compiler prefix. Moreover, the location of a prebuilt kernel for the target architecture must be specified in the makefile. In our skeleton, we called it <strong class="source-inline">KERNEL_SRC</strong>.</p>
			<p>When using a build system such as Yocto, the Linux kernel is first cross-compiled as a dependency before it starts cross-compiling the module. That said, I voluntarily used the <strong class="source-inline">KERNEL_SRC</strong> variable name for the prebuilt kernel directory, since this variable is automatically exported by Yocto for kernel module recipes. It is set to the value of <strong class="source-inline">STAGING_KERNEL_DIR</strong> within the <strong class="source-inline">module.bbclass</strong> class, inherited by all kernel module recipes.</p>
			<p>That said, what changes between native compilation and cross-compilation of an out-of-tree kernel module is the final <strong class="source-inline">make</strong> command, which looks like the following for a 32-bit Arm architecture:</p>
			<p class="source-code">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</p>
			<p>For the 64-bit variant, it would look like the following:</p>
			<p class="source-code">make ARCH=aarch64 CROSS_COMPILE=aarch64-linux-gnu-</p>
			<p>The previous commands assume the cross-compiled kernel source path has been specified in the makefile.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>In-tree building</h2>
			<p>In-tree module building <a id="_idIndexMarker096"/>requires dealing with an additional file, <strong class="source-inline">Kconfig</strong>, which allows us to expose the module features in the configuration menu. That said, before you can build a module in the kernel tree, you should first identify which directory should host your source files. Given your filename, <strong class="source-inline">mychardev.c</strong>, which contains the source code of your special character driver, it should be changed to the <strong class="source-inline">drivers/char</strong> directory in the kernel source. Every subdirectory in the drivers has both <strong class="source-inline">Makefile</strong> and <strong class="source-inline">Kconfig</strong> files.</p>
			<p>Add the following content to the <strong class="source-inline">Kconfig</strong> file of that directory:</p>
			<p class="source-code">config PACKT_MYCDEV</p>
			<p class="source-code">    tristate "Our packtpub special Character driver"</p>
			<p class="source-code">    default m</p>
			<p class="source-code">    help</p>
			<p class="source-code">      Say Y here to support /dev/mycdev char device.</p>
			<p class="source-code">      The /dev/mycdev is used to access packtpub.</p>
			<p>In <strong class="source-inline">Makefile</strong> in that <a id="_idIndexMarker097"/>same directory, add the following line:</p>
			<p class="source-code">obj-$(CONFIG_PACKT_MYCDEV)   += mychardev.o</p>
			<p>Be careful when updating <strong class="source-inline">Makefile</strong> – the <strong class="source-inline">.o</strong> file name must match the exact name of the <strong class="source-inline">.c</strong> file. If the source file is <strong class="source-inline">foobar.c</strong>, you must use <strong class="source-inline">foobar.o</strong> in <strong class="source-inline">Makefile</strong>. In order to have your module built as a loadable kernel module, add the following line to your <strong class="source-inline">defconfig</strong> board in the <strong class="source-inline">arch/arm/configs</strong> directory:</p>
			<p class="source-code">CONFIG_PACKT_MYCDEV=m</p>
			<p>You can also run <strong class="source-inline">menuconfig</strong> to select it from the UI, run <strong class="source-inline">make</strong> to build the kernel, and then <strong class="source-inline">make modules</strong> to build modules (including yours). To make the driver built-in, just replace <strong class="source-inline">m</strong> with <strong class="source-inline">y</strong>:</p>
			<p class="source-code">CONFIG_PACKT_MYCDEV=y</p>
			<p>Everything described here is <a id="_idIndexMarker098"/>what embedded board manufacturers do in order to provide a <strong class="bold">Board Support Package</strong> (<strong class="bold">BSP</strong>) with their board, with a kernel that already contains their custom drivers:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B17934_02_001.jpg" alt="Figure 2.1 – The Packt_dev module in the kernel tree&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The Packt_dev module in the kernel tree</p>
			<p>Once configured, you <a id="_idIndexMarker099"/>can build the kernel with <strong class="source-inline">make</strong>, and build modules with <strong class="source-inline">make modules</strong>.</p>
			<p>Modules included in the kernel source tree are installed in <strong class="source-inline">/lib/modules/$(unale -r)/kernel/</strong>. On your Linux system, it is <strong class="source-inline">/lib/modules/$(uname -r)/kernel/</strong>. </p>
			<p>Now that we are familiar <a id="_idIndexMarker100"/>with out-of-tree or in-tree kernel module compilation, let's see how to handle module behavior adaptation by allowing parameters to be passed to this module. </p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor032"/>Handling module parameters</h1>
			<p>Similar to a user program, a kernel module can accept arguments from the command line. This allows us to <a id="_idIndexMarker101"/>dynamically change the behavior of the module according to the given parameters, which can help a developer not have to indefinitely change/compile the module during a test/debug session. In order to set this up, we should first declare the variables that will hold the values of command-line arguments and use the <strong class="source-inline">module_param()</strong> macro on each of these. The macro is defined in <strong class="source-inline">include/linux/moduleparam.h</strong> (this should be included in the code too – <strong class="source-inline">#include &lt;linux/moduleparam.h&gt;</strong>) as follows:</p>
			<p class="source-code">module_param(name, type, perm);</p>
			<p>This macro contains the following elements:</p>
			<ul>
				<li><strong class="source-inline">name</strong>: The name of the variable used as the parameter.</li>
				<li><strong class="source-inline">type</strong>: The parameter's type (<strong class="source-inline">bool</strong>, <strong class="source-inline">charp</strong>, <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">ushort</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">uint</strong>, <strong class="source-inline">long</strong>, and <strong class="source-inline">ulong</strong>), where <strong class="source-inline">charp</strong> stands for <em class="italic">character pointer</em>.</li>
				<li><strong class="source-inline">perm</strong>: This represents the <strong class="source-inline">/sys/module/&lt;module&gt;/parameters/&lt;param&gt;</strong> file permissions. Some of them are <strong class="source-inline">S_IWUSR</strong>, <strong class="source-inline">S_IRUSR</strong>, <strong class="source-inline">S_IXUSR</strong>, <strong class="source-inline">S_IRGRP</strong>, <strong class="source-inline">S_WGRP</strong>, and <strong class="source-inline">S_IRUGO</strong>, where the following applies:<ul><li><strong class="source-inline">S_I</strong> is just a prefix.</li><li><strong class="source-inline">R</strong> = read, <strong class="source-inline">W</strong> = write, and <strong class="source-inline">X</strong> = execute.</li><li><strong class="source-inline">USR</strong> = user, <strong class="source-inline">GRP</strong> = group, and <strong class="source-inline">UGO</strong> = user, group, and others.</li></ul></li>
			</ul>
			<p>You can eventually use <strong class="source-inline">|</strong> (the <strong class="source-inline">OR</strong> operation) to set multiple permissions. If <strong class="source-inline">perm</strong> is <strong class="source-inline">0</strong>, the file parameter in Sysfs will not be created. You should use only <strong class="source-inline">S_IRUGO</strong> read-only parameters, which I highly recommend; by OR'ing with other properties, you can obtain fine-grained properties.</p>
			<p>When using module parameters, <strong class="source-inline">MODULE_PARM_DESC</strong> can be used on a per-parameter basis to describe <a id="_idIndexMarker102"/>each of them. This macro will populate the module information section of each parameter's description. The following is a sample, from the <strong class="source-inline">helloworld-params.c</strong> source file provided with the code repository of this book:</p>
			<p class="source-code">#include &lt;linux/moduleparam.h&gt;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">static char *mystr = "hello";</p>
			<p class="source-code">static int myint = 1;</p>
			<p class="source-code">static int myarr[3] = {0, 1, 2};</p>
			<p class="source-code">module_param(myint, int, S_IRUGO);</p>
			<p class="source-code">module_param(mystr, charp, S_IRUGO);</p>
			<p class="source-code">module_param_array(myarr, int,NULL, S_IWUSR|S_IRUSR);</p>
			<p class="source-code">MODULE_PARM_DESC(myint,"this is my int variable");</p>
			<p class="source-code">MODULE_PARM_DESC(mystr,"this is my char pointer variable");</p>
			<p class="source-code">MODULE_PARM_DESC(myarr,"this is my array of int");</p>
			<p class="source-code">static int foo()</p>
			<p class="source-code">{</p>
			<p class="source-code">    pr_info("mystring is a string: %s\n",</p>
			<p class="source-code">             mystr);</p>
			<p class="source-code">    pr_info("Array elements: %d\t%d\t%d",</p>
			<p class="source-code">             myarr[0], myarr[1], myarr[2]);</p>
			<p class="source-code">    return myint;</p>
			<p class="source-code">}</p>
			<p>To load the module and feed our parameter, we do the following:</p>
			<p class="source-code"># insmod hellomodule-params.ko mystring="packtpub" myint=15 myArray=1,2,3</p>
			<p>That said, we could have used <strong class="source-inline">modinfo</strong> prior to loading the module in order to display a description of <a id="_idIndexMarker103"/>parameters supported by the module:</p>
			<p class="source-code">$ modinfo ./helloworld-params.ko </p>
			<p class="source-code">filename:       /home/jma/work/tutos/sources/helloworld/./helloworld-params.ko</p>
			<p class="source-code">license:      GPL</p>
			<p class="source-code">author:       John Madieu &lt;john.madieu@gmail.com&gt;</p>
			<p class="source-code">srcversion:   BBF43E098EAB5D2E2DD78C0</p>
			<p class="source-code">depends:        </p>
			<p class="source-code">vermagic:     4.4.0-93-generic SMP mod_unload modversions </p>
			<p class="source-code">parm:         myint:this is my int variable (int)</p>
			<p class="source-code">parm:         mystr:this is my char pointer variable (charp)</p>
			<p class="source-code">parm:         myarr:this is my array of int (array of int)</p>
			<p>It is also possible to find and edit the current values for the parameters of a loaded module from Sysfs in <strong class="source-inline">/sys/module/&lt;name&gt;/parameters</strong>. In that directory, there is one file per parameter, containing the parameter value. These parameter values can be changed if the associated files have write permissions (which depends on the module code).</p>
			<p>The following is an example:</p>
			<p class="source-code">echo 0 &gt; /sys/module/usbcore/parameters/authorized_default</p>
			<p>Not just loadable kernel modules can accept parameters. Provided that a module is built in the kernel, you can specify parameters for this module from the Linux kernel command line (the one passed by the bootloader or the one that is provided by the <strong class="source-inline">CONFIG_CMDLINE</strong> configuration option).</p>
			<p>This has the following form:</p>
			<p class="source-code">[initial command line ...] my_module.param=value</p>
			<p>In this <a id="_idIndexMarker104"/>example, <strong class="source-inline">my_module</strong> corresponds to the module name and <strong class="source-inline">value</strong> is the value assigned to this parameter.</p>
			<p>Now that we are able to deal with module parameters, let's dive a bit deeper into a not-so-obvious scenario, where we will learn how the Linux kernel itself and its build system handles module dependencies.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor033"/>Dealing with symbol exports and module dependencies</h1>
			<p>Only a limited number of kernel functions can be called from a kernel module. To be visible to a kernel <a id="_idIndexMarker105"/>module, functions and variables must be explicitly exported <a id="_idIndexMarker106"/>by the kernel. Thus, the Linux kernel exposes two macros that can be used to export functions and variables. These are the following:</p>
			<ul>
				<li><strong class="source-inline">EXPORT_SYMBOL(symbolname)</strong>: This macro exports a function or variable to all modules. </li>
				<li><strong class="source-inline">EXPORT_SYMBOL_GPL(symbolname)</strong>: This macro exports a function or variable only to GPL modules.</li>
			</ul>
			<p><strong class="source-inline">EXPORT_SYMBOL()</strong> or its GPL counterpart are Linux kernel macros that make a symbol available to loadable kernel <a id="_idIndexMarker107"/>modules or dynamically loaded modules (provided that said modules add an <strong class="source-inline">extern</strong> declaration – that is, include the headers corresponding to the compilation units that exported the symbols). <strong class="source-inline">EXPORT_SYMBOL()</strong> instructs the Kbuild mechanism to include the symbol passed as an argument in the global list of kernel symbols. As a result, kernel modules can access them. Code that is built into the kernel itself (as opposed to loadable kernel modules) can, of course, access any non-static symbol via an extern declaration, as with conventional C code.</p>
			<p>These macros also allow us to export, from loadable kernel modules, symbols that can be accessed from <a id="_idIndexMarker108"/>other loadable kernel modules. An interesting thing is that <a id="_idIndexMarker109"/>a symbol thus exported by one module becomes accessible to another module that may depend on it! A normal driver should not need any non-exported function.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>An introduction to the concept of module dependencies</h2>
			<p>A dependency of module B on module A is that module B is using one or more of the symbols exported by <a id="_idIndexMarker110"/>module A. Let's see in the next section how such dependencies are handled in the Linux kernel infrastructure.</p>
			<h3>The depmod utility</h3>
			<p><strong class="source-inline">depmod</strong> is a tool that you run during the kernel build process to generate module dependency files. It does that by reading <a id="_idIndexMarker111"/>each module in <strong class="source-inline">/lib/modules/&lt;kernel_release&gt;/</strong> to determine what symbols it should export and what symbols it needs. The result of that process is written to a <strong class="source-inline">modules.dep</strong> file, and its binary version, <strong class="source-inline">modules.dep.bin</strong>. It is a kind of module indexing.</p>
			<h3>Module loading and unloading</h3>
			<p>For a module to be operational, you should load it into the Linux kernel, either by using <strong class="source-inline">insmod</strong> and passing the <a id="_idIndexMarker112"/>module path as an argument, which is the preferred method <a id="_idIndexMarker113"/>during development, or by using <strong class="source-inline">modprobe</strong>, a clever command but which is preferable for use in production systems.</p>
			<h4>Manual loading</h4>
			<p>Manual loading needs <a id="_idIndexMarker114"/>the intervention of a user, which should have <strong class="source-inline">root</strong> access. The two classical methods to achieve this are <strong class="source-inline">modprobe</strong> and <strong class="source-inline">insmod</strong>, which are described as follows.</p>
			<p>During development, you usually use <strong class="source-inline">insmod</strong> in order to load a module. <strong class="source-inline">insmod</strong> should be given the path of the module to load, as follows:</p>
			<p class="source-code">insmod /path/to/mydrv.ko</p>
			<p>This is the low-level form of module loading, which forms the basis of the other module-loading method and the one we will use in this book. On the other hand, there is <strong class="source-inline">modprobe</strong>, mostly used by <a id="_idIndexMarker115"/>system admins or in a production system. <strong class="source-inline">modprobe</strong> is a clever command that parses the <strong class="source-inline">modules.dep</strong> file (discussed previously) in order to load dependencies first, prior to loading the given module. It automatically handles module dependencies, as a package manager does. It is invoked as follows:</p>
			<p class="source-code">modprobe mydrv</p>
			<p>Whether we can use <strong class="source-inline">modprobe</strong> depends on <strong class="source-inline">depmod</strong> being aware of module installation.</p>
			<h4>Auto-loading</h4>
			<p>The <strong class="source-inline">depmod</strong> utility doesn't only build <strong class="source-inline">modules.dep</strong> and <strong class="source-inline">modules.dep.bin</strong> files; it does more than that. When kernel developers write drivers, they know exactly what hardware the drivers <a id="_idIndexMarker116"/>will support. They are then responsible for feeding the drivers with the product and vendor IDs of all devices supported by the driver. <strong class="source-inline">depmod</strong> also processes module files in order to extract and gather that information and generates a <strong class="source-inline">modules.alias</strong> file, located in <strong class="source-inline">/lib/modules/&lt;kernel_release&gt;/modules.alias</strong>, which maps devices to their drivers:</p>
			<p>An excerpt of <strong class="source-inline">modules.alias</strong> is as follows:</p>
			<p class="source-code">alias usb:v0403pFF1Cd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">alias usb:v0403pFF18d*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">alias usb:v0403pDAFFd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">alias usb:v0403pDAFEd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">alias usb:v0403pDAFDd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">alias usb:v0403pDAFCd*dc*dsc*dp*ic*isc*ip*in* ftdi_sio</p>
			<p class="source-code">[...]</p>
			<p>At this step, you'll need a user space hotplug agent (or device manager), usually <strong class="source-inline">udev</strong> (or <strong class="source-inline">mdev</strong>), that will register with the kernel to get notified when a new device appears.</p>
			<p>The notification is done by the kernel, sending the device's description (the product ID, the vendor ID, the class, the device class, the device subclass, the interface, and any other information that can identify a device) to the hotplug daemon, which in turn calls <strong class="source-inline">modprobe</strong> with this information. <strong class="source-inline">modprobe</strong> then parses the <strong class="source-inline">modules.alias</strong> file in order to match the <a id="_idIndexMarker117"/>driver associated with the device. Before loading the module, <strong class="source-inline">modprobe</strong> will look for its dependencies in <strong class="source-inline">module.dep</strong>. If it finds any, they will be loaded prior to the associated module loading; otherwise, the module is loaded directly.</p>
			<p>There is another method for automatically loading a module, at boot time this time. This is achieved in <strong class="source-inline">/etc/modules-load.d/&lt;filename&gt;.conf</strong>. If you want some modules to be loaded at boot time, just create a <strong class="source-inline">/etc/modules-load.d/&lt;filename&gt;.conf</strong> file and add the module names that should be loaded, one per line. <strong class="source-inline">&lt;filename&gt;</strong> will be meaningful to you, and people usually use <strong class="source-inline">module</strong>: <strong class="source-inline">/etc/modules-load.d/modules.conf</strong>. You can create as many <strong class="source-inline">.conf</strong> files as you need.</p>
			<p>An example of <strong class="source-inline">/etc/modules-load.d/mymodules.conf</strong> is as follows:</p>
			<p class="source-code">#This line is a comment</p>
			<p class="source-code">uio</p>
			<p class="source-code">iwlwifi</p>
			<p>These configuration files are processed by <strong class="source-inline">systemd-modules-load.service</strong>, provided that <strong class="source-inline">systemd</strong> is the initialization manager on your machine. On <strong class="source-inline">SysVinit</strong> systems, these files are processed by the <strong class="source-inline">/etc/init.d/kmod</strong> script.</p>
			<h4>Module unloading</h4>
			<p>The usual command to unload a module is <strong class="source-inline">rmmod</strong>. This is preferable to unloading a module loaded <a id="_idIndexMarker118"/>with the <strong class="source-inline">insmod</strong> command. The command should be given the module name to unload as a parameter:</p>
			<p class="source-code">rmmod -f mymodule</p>
			<p>On the other hand, a higher-level command to unload a module in a smart manner is <strong class="source-inline">modeprobe –r</strong>, which automatically unloads unused dependencies:</p>
			<p class="source-code">modeprobe -r mymodule</p>
			<p>As you may have guessed, it is a helpful option for developers. Finally, we can check whether a module is loaded with the <strong class="source-inline">lsmod</strong> command, as follows:</p>
			<p class="source-code">$ lsmod</p>
			<p class="source-code">Module                  Size  Used by</p>
			<p class="source-code">btrfs                1327104  0</p>
			<p class="source-code">blake2b_generic        20480  0</p>
			<p class="source-code">xor                    24576  1 btrfs</p>
			<p class="source-code">raid6_pq              114688  1 btrfs</p>
			<p class="source-code">ufs                    81920  0</p>
			<p class="source-code">[...]</p>
			<p>The output includes the name of the module, the amount of memory it uses, the number of other modules <a id="_idIndexMarker119"/>that use it, and finally, the name of these. The output of <strong class="source-inline">lsmod</strong> is actually a nice formatting view of what you can see under <strong class="source-inline">/proc /modules</strong>, which is the file listing loaded modules:</p>
			<p class="source-code">$ cat /proc/modules </p>
			<p class="source-code">btrfs 1327104 0 - Live 0x0000000000000000</p>
			<p class="source-code">blake2b_generic 20480 0 - Live 0x0000000000000000</p>
			<p class="source-code">xor 24576 1 btrfs, Live 0x0000000000000000</p>
			<p class="source-code">raid6_pq 114688 1 btrfs, Live 0x0000000000000000</p>
			<p class="source-code">ufs 81920 0 - Live 0x0000000000000000</p>
			<p class="source-code">qnx4 16384 0 - Live 0x0000000000000000</p>
			<p>The preceding output is raw and poorly formatted. Therefore, it is preferable to use <strong class="source-inline">lsmod</strong>.</p>
			<p>Now that we are familiar with kernel module management, let's extend our kernel development skills by learning some tips that kernel developers have adopted.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Learning some Linux kernel programming tips</h1>
			<p>Linux kernel development is about learning from others and not reinventing the wheel. There is a set of rules to follow when doing kernel development. A whole chapter won't be enough to cover these rules. Thus, I picked two of the most relevant to me, those that are likely to change when programming for user space: error handling and message printing.</p>
			<p>In user space, exiting from the <strong class="source-inline">main()</strong> method is enough to recover from all the errors that may have occurred. In the kernel, this is not the case, especially since it directly deals with the hardware. Things are different for message printing as well, and we will see that in this section.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Error handling</h2>
			<p>Returning the wrong error code for a given error can result in either the kernel or user space application <a id="_idIndexMarker120"/>misinterpreting and taking the wrong decision, producing unneeded behavior. To keep things clear, there are predefined errors in the kernel tree that cover almost every case you may face. Some of the errors (with their meaning) are defined in <strong class="source-inline">include/uapi/asm-generic/errno-base.h</strong>, and the rest of the list can be found in <strong class="source-inline">include/uapi/asm-generic/errno.h</strong>. The following is an excerpt of this list of errors, from <strong class="source-inline">include/uapi/asm-generic/errno-base.h</strong>:</p>
			<p class="source-code">#define  EPERM    1    /* Operation not permitted */</p>
			<p class="source-code">#define  ENOENT   2    /* No such file or directory */</p>
			<p class="source-code">#define  ESRCH    3    /* No such process */</p>
			<p class="source-code">#define  EINTR    4    /* Interrupted system call */</p>
			<p class="source-code">#define  EIO      5    /* I/O error */</p>
			<p class="source-code">#define  ENXIO    6    /* No such device or address */</p>
			<p class="source-code">#define  E2BIG    7    /* Argument list too long */</p>
			<p class="source-code">#define  ENOEXEC  8    /* Exec format error */</p>
			<p class="source-code">#define  EBADF    9    /* Bad file number */</p>
			<p class="source-code">#define  ECHILD   10   /* No child processes */</p>
			<p class="source-code">#define  EAGAIN   11   /* Try again */</p>
			<p class="source-code">#define  ENOMEM   12   /* Out of memory */</p>
			<p class="source-code">#define  EACCES   13   /* Permission denied */</p>
			<p class="source-code">#define  EFAULT   14   /* Bad address */</p>
			<p class="source-code">#define  ENOTBLK  15   /* Block device required */</p>
			<p class="source-code">#define  EBUSY    16   /* Device or resource busy */</p>
			<p class="source-code">#define  EEXIST   17   /* File exists */</p>
			<p class="source-code">#define  EXDEV    18   /* Cross-device link */</p>
			<p class="source-code">#define  ENODEV   19   /* No such device */</p>
			<p class="source-code">[...]</p>
			<p>Most of the time, the standard way to return an error is to do so in the form of <strong class="source-inline">return –ERROR</strong>, especially <a id="_idIndexMarker121"/>when it comes to answering system calls. For example, for an I/O error, the error code is <strong class="source-inline">EIO</strong>, and you should return <strong class="source-inline">-EIO</strong>, as follows:</p>
			<p class="source-code">dev = init(&amp;ptr);</p>
			<p class="source-code">if(!dev)</p>
			<p class="source-code">    return –EIO</p>
			<p>Errors sometimes cross the kernel space and propagate themselves to the user space. If the returned error is an answer to a system call (<strong class="source-inline">open</strong>, <strong class="source-inline">read</strong>, <strong class="source-inline">ioctl</strong>, or <strong class="source-inline">mmap</strong>), the value will be automatically assigned to the user space <strong class="source-inline">errno</strong> global variable, on which you can use <strong class="source-inline">strerror(errno)</strong> to translate the error into a readable string:</p>
			<p class="source-code">#include &lt;errno.h&gt;  /* to access errno global variable */</p>
			<p class="source-code">#include &lt;string.h&gt;</p>
			<p class="source-code">[...]</p>
			<p class="source-code">if(wite(fd, buf, 1) &lt; 0) {</p>
			<p class="source-code">    printf("something gone wrong! %s\n", strerror(errno));</p>
			<p class="source-code">}</p>
			<p class="source-code">[...]</p>
			<p>When you face <a id="_idIndexMarker122"/>an error, you must undo everything that has been set until the error occurred. The usual way to do that is to use the <strong class="source-inline">goto</strong> statement:</p>
			<p class="source-code">ret = 0;</p>
			<p class="source-code">ptr = kmalloc(sizeof (device_t));</p>
			<p class="source-code">if(!ptr) {</p>
			<p class="source-code">        ret = -ENOMEM</p>
			<p class="source-code">        goto err_alloc;</p>
			<p class="source-code">}</p>
			<p class="source-code">dev = init(&amp;ptr);</p>
			<p class="source-code">if(!dev) {</p>
			<p class="source-code">        ret = -EIO</p>
			<p class="source-code">        goto err_init;</p>
			<p class="source-code">}</p>
			<p class="source-code">return 0;</p>
			<p class="source-code">err_init:</p>
			<p class="source-code">        free(ptr);</p>
			<p class="source-code">err_alloc:</p>
			<p class="source-code">        return ret;</p>
			<p>The reason to use the <strong class="source-inline">goto</strong> statement is simple. When it comes to handling errors, let's say that at <em class="italic">step 5</em>, you have to clean up the previous operations (<em class="italic">steps 4</em>, <em class="italic">3</em>, <em class="italic">2</em>, and <em class="italic">1</em>), instead of doing lots of nested checking operations, as follows:</p>
			<p class="source-code">if (ops1() != ERR) {</p>
			<p class="source-code">    if (ops2() != ERR) {</p>
			<p class="source-code">        if (ops3() != ERR) {</p>
			<p class="source-code">            if (ops4() != ERR) {</p>
			<p>This is less <a id="_idIndexMarker123"/>readable, error-prone, and confusing (readability also depends on indentation). By using the <strong class="source-inline">goto</strong> statement, we have straight control flow, as follows:</p>
			<p class="source-code">if (ops1() == ERR) // ||</p>
			<p class="source-code">    goto error1;   // ||</p>
			<p class="source-code">if (ops2() == ERR) // ||</p>
			<p class="source-code">    goto error2;   // ||</p>
			<p class="source-code">if (ops3() == ERR) // ||</p>
			<p class="source-code">    goto error3;   // ||</p>
			<p class="source-code">if (ops4() == ERR) // VV</p>
			<p class="source-code">    goto error4;</p>
			<p class="source-code">error5:</p>
			<p class="source-code">[...]</p>
			<p class="source-code">error4:</p>
			<p class="source-code">[...]</p>
			<p class="source-code">error3:</p>
			<p class="source-code">[...]</p>
			<p class="source-code">error2:</p>
			<p class="source-code">[...]</p>
			<p class="source-code">error1:</p>
			<p class="source-code">[...]</p>
			<p>That said, you should only use <strong class="source-inline">goto</strong> to move forward in a function, not backward, nor to implement loops (as is the case in an assembler).</p>
			<h3>Handling null pointer errors</h3>
			<p>When it comes to returning an error from functions that are supposed to return a pointer, functions <a id="_idIndexMarker124"/>often return the <strong class="source-inline">NULL</strong> pointer. It is functional but it is a quite meaningless approach, since we do not exactly know why this <strong class="source-inline">NULL</strong> pointer is returned. For that purpose, the kernel provides three functions, <strong class="source-inline">ERR_PTR</strong>, <strong class="source-inline">IS_ERR</strong>, and <strong class="source-inline">PTR_ERR</strong>, defined as follows:</p>
			<p class="source-code">void *ERR_PTR(long error);</p>
			<p class="source-code">long IS_ERR(const void *ptr);</p>
			<p class="source-code">long PTR_ERR(const void *ptr);</p>
			<p>The first macro returns the error value as a pointer. It can be seen as an <em class="italic">error value to pointer</em> macro. Given a function that is likely to return <strong class="source-inline">-ENOMEM</strong> after a failed memory allocation, we have to do something such as <strong class="source-inline">return ERR_PTR(-ENOMEM);</strong>. The second macro is used to check whether the returned value is a pointer error using <strong class="source-inline">if(IS_ERR(foo))</strong>. The last one returns the actual error code, <strong class="source-inline">return PTR_ERR(foo)</strong>. It can be seen as a <em class="italic">pointer to error value</em> macro.</p>
			<p>The following is an example of how to use <strong class="source-inline">ERR_PTR</strong>, <strong class="source-inline">IS_ERR</strong>, and <strong class="source-inline">PTR_ERR</strong>:</p>
			<p class="source-code">static struct iio_dev *indiodev_setup(){</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    struct iio_dev *indio_dev;</p>
			<p class="source-code">    indio_dev = devm_iio_device_alloc(&amp;data-&gt;client-&gt;dev,</p>
			<p class="source-code">                                      sizeof(data));</p>
			<p class="source-code">    if (!indio_dev)</p>
			<p class="source-code">        return ERR_PTR(-ENOMEM);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    return indio_dev;</p>
			<p class="source-code">}</p>
			<p class="source-code">static int foo_probe([...]){</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">    struct iio_dev *my_indio_dev = indiodev_setup();</p>
			<p class="source-code">    if (IS_ERR(my_indio_dev))</p>
			<p class="source-code">        return PTR_ERR(data-&gt;acc_indio_dev);</p>
			<p class="source-code">    [...]</p>
			<p class="source-code">}</p>
			<p>This is a plus with error handling, which is also an excerpt of the kernel coding style that states that if a function's name <a id="_idIndexMarker125"/>is an action or an imperative command, the function should return an integer error code. If, however, the function's name is a predicate, this function should return a Boolean to indicate the succeeded status of the operation.</p>
			<p><strong class="source-inline">Add work</strong>, for example, is a command, thus the <strong class="source-inline">add_work()</strong> function returns <strong class="source-inline">0</strong> for success or <strong class="source-inline">-EBUSY</strong> for failure. <strong class="source-inline">PCI device present</strong> is a predicate, and in the same way, this is why the <strong class="source-inline">pci_dev_present()</strong> function returns <strong class="source-inline">1</strong> if it succeeds in finding a matching device or <strong class="source-inline">0</strong> if it doesn't.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Message printing – goodbye printk, long life dev_*, pr_*, and net_* APIs</h2>
			<p>Apart from informing <a id="_idIndexMarker126"/>users of what is going on, printing is the first debugging technique. <strong class="source-inline">printk()</strong> is to the kernel what <strong class="source-inline">printf()</strong> is to the user space. <strong class="source-inline">printk()</strong> has, for a long time, ruled kernel message printing in a <a id="_idIndexMarker127"/>leveled manner. Written messages can be displayed using the <strong class="source-inline">dmesg</strong> command. Depending on how important the message to print was, <strong class="source-inline">printk()</strong> allowed you to choose between eight log-level messages, defined in <strong class="source-inline">include/linux/kern_levels.h</strong>, along with their meaning.</p>
			<p>Nowadays, while <strong class="source-inline">printk()</strong> remains the low-level message printing API, the printk/log-level pair has been encoded into clearly named helpers, which are recommended for use in new drivers. These are as follows:</p>
			<ul>
				<li><strong class="source-inline">pr_&lt;level&gt;(...)</strong>: This is used in regular modules that are not device drivers.</li>
				<li><strong class="source-inline">dev_&lt;level&gt;(struct device *dev, ...)</strong>: This is to be used in device drivers that are not network devices (also known as <strong class="source-inline">netdev</strong> drivers).</li>
				<li><strong class="source-inline">netdev_&lt;level&gt;(struct net_device *dev, ...)</strong>: This is used in <strong class="source-inline">netdev</strong> drivers exclusively.</li>
			</ul>
			<p>In all these <a id="_idIndexMarker128"/>helpers, <strong class="source-inline">&lt;level&gt;</strong> represents the log level encoded into a quite meaningful name, as described in the following table:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B17934_02_Table_1.jpg" alt="Table 2.1 – The Linux kernel printing API&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 2.1 – The Linux kernel printing API</p>
			<p>Log levels work in a way that, whenever a message is printed, the kernel compares the message log level <a id="_idIndexMarker129"/>with the current console log level; if the former is higher (lower value) than the last, the message will be immediately printed to the console. You can check your log-level parameters with the following: </p>
			<p class="source-code">cat /proc/sys/kernel/printk</p>
			<p class="source-code">4        4         1        7</p>
			<p>In the preceding output, the first value is the current log level (<strong class="source-inline">4</strong>). According to that, any message printed <a id="_idIndexMarker130"/>with higher importance (a lower log level) will be displayed in the console as well. The second value is the default log level, according to the <strong class="source-inline">CONFIG_DEFAULT_MESSAGE_LOGLEVEL</strong> option. Other values are not relevant for the purpose of this chapter, so let's ignore them.</p>
			<p>The current log level can be changed with the following: </p>
			<p class="source-code">echo &lt;level&gt; &gt; /proc/sys/kernel/printk</p>
			<p>In addition, you can prefix the module output messages with a custom string. To achieve this, you should define the <strong class="source-inline">pr_fmt</strong> macro. It is common to define this message prefix with the module name, as follows:</p>
			<p class="source-code">#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt</p>
			<p>For more concise log output, some overrides use the current function name as a prefix, as follows:</p>
			<p class="source-code">#define pr_fmt(fmt) "%s: " fmt, __func__</p>
			<p>If we consider the <strong class="source-inline">net/bluetooth/lib.c</strong> file in the kernel source tree, we can see the following in the first line:</p>
			<p class="source-code">#define pr_fmt(fmt) "Bluetooth: " fmt</p>
			<p>With that line, any <strong class="source-inline">pr_&lt;level&gt;</strong>  (we are in a regular module, not a device driver) logging call will produce a log prefixed with <strong class="source-inline">Bluetooth:</strong>, similar to the following:</p>
			<p class="source-code">$ dmesg | grep Bluetooth</p>
			<p class="source-code">[ 3.294445] Bluetooth: Core ver 2.22</p>
			<p class="source-code">[ 3.294458] Bluetooth: HCI device and connection manager initialized</p>
			<p class="source-code">[ 3.294460] Bluetooth: HCI socket layer initialized</p>
			<p class="source-code">[ 3.294462] Bluetooth: L2CAP socket layer initialized</p>
			<p class="source-code">[ 3.294465] Bluetooth: SCO socket layer initialized</p>
			<p class="source-code">[...]</p>
			<p>This is all about message printing. We have learned how to choose and use the appropriate printing <a id="_idIndexMarker131"/>APIs according to the situation.</p>
			<p>We are now done with our kernel module introduction series. At this stage, you should be able to download, configure, and (cross-)compile the Linux kernel, as well as write and build kernel modules against this kernel.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">printk()</strong> (or its encoded helpers) never blocks and is safe enough to be called even from atomic contexts. It tries to <a id="_idIndexMarker132"/>lock the console and print the message. If locking fails, the output will be written into a buffer and the function will return, never blocking. The current console holder will then be notified about new messages and will print them before releasing the console.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Summary</h1>
			<p>This chapter showed the basics of driver development and explained the concept of built-in and loadable kernel modules, as well as their loading and unloading. Even if you are not able to interact with the user space, you are ready to write a working module, print formatted messages, and understand the concept of <strong class="source-inline">init</strong>/<strong class="source-inline">exit</strong>. </p>
			<p>The next chapter will deal with Linux kernel core functions, which, along with this chapter, form the Swiss army knife of Linux kernel development. In the next chapter, you will be able to target enhanced features, perform fancy operations that can impact the system, and interact with the core of the Linux kernel.</p>
		</div>
	</body></html>