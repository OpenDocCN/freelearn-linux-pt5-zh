<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Installation and Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Installation and Configuration</h1></div></div></div><p>In this chapter we will walk through the process of installing and configuring the OpenLDAP suite of tools. Here we will only cover basic configuration of the SLAPD server. This will serve as a base for subsequent chapters (particularly Chapters 4 to 7), where we will explore advanced configuration options. The specific topics that we will cover include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing binary OpenLDAP packages</li><li class="listitem" style="list-style-type: disc">Configuring the LDAP server with the <code class="literal">slapd.conf</code> file</li><li class="listitem" style="list-style-type: disc">Verifying the <code class="literal">slapd.conf</code> configuration with <code class="literal">slaptest</code></li><li class="listitem" style="list-style-type: disc">Starting and stopping the server</li><li class="listitem" style="list-style-type: disc">Configuring client tools with the <code class="literal">ldap.conf</code> file</li><li class="listitem" style="list-style-type: disc">Fetching the root DSE entry from the directory with <code class="literal">ldapsearch</code></li></ul></div><div class="section" title="Before Getting Started"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec10"/>Before Getting Started</h1></div></div></div><a class="indexterm" id="id38"/><a class="indexterm" id="id39"/><a class="indexterm" id="id40"/><p>OpenLDAP is maintained by the OpenLDAP Foundation. The foundation maintains a suite of tools that we will call as OpenLDAP suite. As we saw in Chapter 1, the OpenLDAP suite includes the following classes of tools:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Daemons (<code class="literal">slapd</code> and <code class="literal">slurpd</code>)</li><li class="listitem" style="list-style-type: disc">Libraries (notably <code class="literal">libldap</code>)</li><li class="listitem" style="list-style-type: disc">Client applications (<code class="literal">ldapsearch</code>, <code class="literal">ldapadd</code>, <code class="literal">ldapmodify</code>, and others)</li><li class="listitem" style="list-style-type: disc">Supporting utilities (<code class="literal">slapcat</code>, <code class="literal">slapauth</code>, and others) </li></ul></div><p>The official OpenLDAP source distribution includes all of these in one download. Various binary versions however, may break these out into sub-packages. Commonly the suite is split into three packages: <span class="emphasis"><em>libraries</em></span>, <span class="emphasis"><em>clients</em></span>, and <span class="emphasis"><em>servers</em></span>.</p><p>OpenLDAP compiles and runs on a wide variety of operating systems. However, the OpenLDAP project itself does not provide binary versions of their software. As a result, different vendors and operating system maintainers compile and provide their own binary versions. There are versions of OpenLDAP compiled for most UNIX variants (including Mac OS X), as well as versions for the Windows operating system. Some binary distributions even come with commercial support.</p><div class="section" title="OpenLDAP Binaries for Operating Systems"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>OpenLDAP Binaries for Operating Systems</h2></div></div></div><p>In this book, we will be using <span class="strong"><strong>Ubuntu Linux</strong></span> as the operating system of choice. Ubuntu is a GNU/Linux distribution based on the venerable <span class="strong"><strong>Debian Project</strong></span>. Like Debian (and the multitude of other Debian-based distributions) Ubuntu uses the Debian package format. Thus, if you are using another Debian-based distribution, the installation process should be largely familiar.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note08a"/>Note</h3><p>Ubuntu is a user-friendly Linux distribution. You can learn more about Ubuntu at <a class="ulink" href="http://www.ubuntu.com/">http://www.ubuntu.com/</a>. To learn more about the Debian Project, on which Ubuntu is based, visit <a class="ulink" href="http://debian.org/">http://debian.org/</a>.</p></div></div><p>Almost every major Linux and BSD distribution includes official support for OpenLDAP. You may want to consult the documentation for your chosen distribution to find out more information on getting and installing OpenLDAP. In some cases, OpenLDAP is installed with the base operating system.</p><p>For Windows, Mac, and other variants of UNIX, the best way to find a list of available binary packages is by perusing the list of distributions maintained in the <span class="strong"><strong>OpenLDAP Faq-O-Matic </strong></span>(<a class="ulink" href="http://www.openldap.org/faq/data/cache/108.html">http://www.openldap.org/faq/data/cache/108.html</a>).</p><div class="section" title="Commercial OpenLDAP Distribution"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Commercial OpenLDAP Distribution</h3></div></div></div><a class="indexterm" id="id41"/><p>If you need a commercially supported OpenLDAP distribution, you may want to consider the offerings from <span class="strong"><strong>Symas</strong></span>. Symas (<a class="ulink" href="http://www.symas.com/">http://www.symas.com/</a>) is owned and operated by many of the same folks who contribute to the OpenLDAP suite. They provide a commercial binary version of the OpenLDAP suite, distributed as <span class="strong"><strong>Connexitor Directory Services (CDS)</strong></span>.</p><p>Several different CDS editions are available, with each edition tuned and optimized for specific organizational needs. Their <span class="emphasis"><em>Platinum Edition</em></span>, for instance, is optimized for directories with more than 150 million records! Symas also provides LDAP training, maintenance and support services, and consulting.</p></div><div class="section" title="Source Code Compilation"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Source Code Compilation</h3></div></div></div><a class="indexterm" id="id42"/><p>Instead of installing a binary file, you may wish to simply compile the OpenLDAP source code yourself. This process is outlined in simple steps in <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a> of this book.</p><p>The primary advantage of building from source code is that you will benefit from many improvements long before these revisions are made available in mainstream packages. The focus of development on the stable branch of OpenLDAP is bug fixes. Thus, building from source generally improves OpenLDAP stability.</p></div></div><div class="section" title="A Quick Note on Versions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>A Quick Note on Versions</h2></div></div></div><a class="indexterm" id="id43"/><p>Currently, the stable branch for OpenLDAP is <span class="emphasis"><em>2.3 branch</em></span> (2.4 is in early beta). However, some Linux distributions still use the aging 2.2 version, originally released in 2003. If the latest package for your chosen operating system is still in the 2.2 branch, you may want to consider looking for <span class="emphasis"><em>unofficial</em></span> versions of 2.3 for your platform, or even compiling a custom binary (see <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>).</p></div></div></div>
<div class="section" title="Installation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>Installation</h1></div></div></div><a class="indexterm" id="id44"/><p>In this section, we will walk through the process of installing on a system running Ubuntu Linux 7.04. Later, Ubuntu distributions will likely follow the same installation pattern.</p><div class="section" title="Dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Dependencies</h2></div></div></div><a class="indexterm" id="id45"/><p>The basic OpenLDAP configuration in Ubuntu requires a few extra libraries and packages. These are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Berkeley Database (<code class="literal">bdb4</code>) version 4.2 (but <span class="emphasis"><em>not</em></span> 4.3, which has stability issues): In the Ubuntu default configuration, OpenLDAP stores the directory inside a BDB database. The Berkeley Database is often simply called BDB.</li><li class="listitem" style="list-style-type: disc">The OpenSSL libraries: These provide SSL and TLS security. SSL and TLS provide encryption for network connections to the directory.</li><li class="listitem" style="list-style-type: disc">The Cyrus SASL library: This provides support for secure SASL authentication.</li><li class="listitem" style="list-style-type: disc">The Perl programming language: This can provide custom back-end scripting.</li><li class="listitem" style="list-style-type: disc">The iODBC database connectivity layer: OpenLDAP can store the directory in a relational database (RDBMS). The iODBC library is used to connect to the RDBMS.</li></ul></div><p>OpenLDAP also relies on some standard system library packages (such as <code class="literal">libc6</code>) that are installed on all UNIX/Linux distributions. In its default installation, Ubuntu includes BDB, OpenSSL, and Perl. Installation of other dependencies is handled automatically by the package manager, so don't worry about manually installing any of these.</p></div><div class="section" title="Installing OpenLDAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Installing OpenLDAP</h2></div></div></div><p>Like many other distributions, Ubuntu breaks OpenLDAP up into small packages. The daemons (<code class="literal">slapd</code> and <code class="literal">slurpd</code>) are packaged in the <code class="literal">slapd</code> package. The clients are packaged in <code class="literal">ldap-utils</code>, and the libraries are packaged in <code class="literal">libldap-2.3-0</code>. When Ubuntu 7.04 was released, OpenLDAP version 2.3.30 was provided. As security fixes are made, Ubuntu may release newer versions via online updates. While legacy 2.2.26 packages are still available, they should be avoided.</p><p>To install Ubuntu we can use the <span class="strong"><strong>Synaptic</strong></span> graphical installer or any of the command-line package management utilities. For the sake of simplicity, we will use <span class="strong"><strong>apt-get</strong></span>. This will download all of the necessary packages (including dependencies) from the official Ubuntu repository and install them for us. Note that installing this way will require access to the Internet (or, alternatively, to some other form of Ubuntu distribution media, such as a CD-ROM). We need to run the following command.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo apt-get install libldap-2.3-0 slapd ldap-utils</strong></span>
</pre></div><p>It may take a little while for the packages to download and install.</p><p>Once <code class="literal">apt-get</code> is done, the LDAP server and all of its clients should be installed. Next, we will begin the process of configuring the SLAPD server.</p></div></div>
<div class="section" title="Configuring the SLAPD Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Configuring the SLAPD Server</h1></div></div></div><a class="indexterm" id="id46"/><a class="indexterm" id="id47"/><a class="indexterm" id="id48"/><a class="indexterm" id="id49"/><p>There are two daemons that come packaged with OpenLDAP: SLAPD server and SLURPD server. <span class="strong"><strong>SLAPD</strong></span>, sometimes called the <span class="strong"><strong>OpenLDAP server</strong></span>, handles client requests and directory management, while <span class="strong"><strong>SLURPD</strong></span> manages replicating changes to other directories. SLURPD is now deprecated in favor of a newer, more robust replication process, and will be removed from future versions of OpenLDAP.</p><p>In the next chapter we will talk more about what these two daemons do. Right now we are only concerned with getting the SLAPD server up and running so we can start connecting to (and using) our directory.</p><p>SLAPD has one main configuration file and any number of auxiliary configuration files. In this section we are going to edit the main configuration file. It is called <code class="literal">slapd.conf</code>, and in Ubuntu's distribution it is located at <code class="literal">/etc/ldap/</code> (if you built from source, the default location is <code class="literal">/usr/local/etc/openldap/</code>).</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip03152"/>Tip</h3><p>Use find . <code class="literal">–type f –name slapd.conf</code> or if the <code class="literal">locate</code> service is enabled, you can use <code class="literal">locate slapd.conf</code>.</p></div></div><p>While Ubuntu provides a good basic <code class="literal">slapd.conf</code> file that you can work with, if you choose, we will not use it. For our purpose, we will start with an empty file and create a <code class="literal">slapd.conf</code> configuration from scratch. You may want to make a backup copy of the original <code class="literal">slapd.conf</code> file before we begin. You can do this from a terminal by running:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo mv /etc/ldap/slapd.conf /etc/ldap/slapd.conf.orig</strong></span>
</pre></div><p>This will rename the file from <code class="literal">slapd.conf</code> to <code class="literal">slapd.conf.orig</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip1000"/>Tip</h3><p>By default, Ubuntu does not activate the <code class="literal">root</code> account. Any time you want to perform a function as the superuser, you should use sudo. However, if you need to become <code class="literal">root</code> (to run, for instance, several commands in sequence), you can type <code class="literal">sudo su</code>.</p></div></div><p>Now we are ready to create our new <code class="literal">slapd.conf</code> file. Open the text editor and create a basic <code class="literal">slapd.conf</code> file:</p><div class="informalexample"><pre class="programlisting"># slapd.conf - Configuration file for LDAP SLAPD
##########
# Basics #
##########
include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema

pidfile /var/run/slapd/slapd.pid
argsfile /var/run/slapd/slapd.args
loglevel none

modulepath /usr/lib/ldap
# modulepath /usr/local/libexec/openldap
moduleload back_hdb

##########################
# Database Configuration #
##########################
database hdb
suffix "dc=example,dc=com"
rootdn "cn=Manager,dc=example,dc=com"
rootpw secret
directory /var/lib/ldap
# directory /usr/local/var/openldap-data
index objectClass,cn eq

########
# ACLs #
########
access to attrs=userPassword
       by anonymous auth
       by self write
       by * none

access to *
       by self write
       by * none</pre></div><p>There are three headings in the file (<span class="strong"><strong>Basics</strong></span>, <span class="strong"><strong>Database Configuration</strong></span>, and <span class="strong"><strong>ACLs</strong></span>), and we will now see each heading in detail.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip4655"/>Tip</h3><p>If you built from source, the paths in the above file need to be adjusted (or, alternately, you can relocate files on your file system). Look in the <code class="literal">/usr/local</code> portion of your file system to locate the correct location (for example, <code class="literal">modulepath</code> is in <code class="literal">/usr/local/libexex/openldap/</code>).</p></div></div><div class="section" title="Basics"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Basics</h2></div></div></div><a class="indexterm" id="id50"/><p>The first section of the configuration file, labeled <span class="emphasis"><em>Basics</em></span>, contains a variety of configuration parameters:</p><div class="informalexample"><pre class="programlisting">##########
# Basics #
##########
include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema
pidfile /var/run/slapd/slapd.pid
argsfile /var/run/slapd/slapd.args
loglevel none

modulepath /usr/lib/ldap
# modulepath /usr/local/libexec/openldap
moduleload back_hdb</pre></div><p>First note that all lines that start with a hash (<code class="literal">#</code>) are treated as comments, and ignored by SLAPD.</p><p>The first three functional (non-comment) lines all begin with the <code class="literal">include</code> directive. The <code class="literal">include</code> directive should always be followed by a full path to a file on the file system. When SLAPD finds the <code class="literal">include</code> directive it will attempt to load the indicated file. Those files will then be treated as part of the current configuration file. So, when SLAPD reads these three lines, it will try to load the three schema files (<code class="literal">core.schema</code>, <code class="literal">cosine.schema</code>, and <code class="literal">inetorgperson.schema</code>).</p><p>The <code class="literal">include</code> directive can be used to load any configuration parameters (in the next chapter, we will use it to include a file that contains ACLs). Traditionally, the schema information is stored separately from other configuration directives, and loaded (using <code class="literal">include</code> directives) at server startup. This improves the readability of the code and helps prevent the accidental modification of the schema information.<a class="indexterm" id="id51"/>
</p><div class="section" title="Schemas"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec05"/>Schemas</h3></div></div></div><a class="indexterm" id="id52"/><p>Schemas provide definitions of (amongst other things) the different object classes and attribute types that OpenLDAP should support. Using these, OpenLDAP can determine what entries it is allowed to store, whether any given entry is valid, and how entries should optimally be stored.</p><p>The three schemas loaded here contain the most frequently used options. <code class="literal">core.schema</code> contains all of the attribute and object class definitions from the LDAP v.3 specification. The <code class="literal">cosine.schema</code> and <code class="literal">inteorgperson.schema</code> files contain schema definitions for commonly used standardized extensions (see RFCs 4524 and 2798). There are a host of other schemas available with OpenLDAP, and we will look at some of those in Chapter 6.</p></div><div class="section" title="More Directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>More Directives</h3></div></div></div><a class="indexterm" id="id53"/><p>After the schemas are included the next two directives, <code class="literal">pidfile</code> and <code class="literal">argsfile</code>, tell SLAPD where to store (and look for) files that contain information on:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The process ID for the SLAPD server process</li><li class="listitem" style="list-style-type: disc">The arguments that were passed into the <code class="literal">slapd</code> command at startup</li></ul></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note164554645"/>Note</h3><p>Since SLAPD needs to write to these files, the user that runs <code class="literal">slapd</code> needs to have permissions to <code class="literal">read from</code> and <code class="literal">write to</code> these files. Since the files are removed when the SLAPD server shuts down, the user that runs <code class="literal">slapd</code> will also need write permissions on the directory where these files are stored (<code class="literal">/var/run/slapd/</code>, in this case).</p></div></div><p>Next, the <code class="literal">loglevel</code> directive is set to <code class="literal">none</code>. The <code class="literal">loglevel</code> directive specifies how much information SLAPD should send to the system log (by way of <code class="literal">syslogd</code>). The loglevel directive accepts keywords (<code class="literal">any</code>, <code class="literal">none</code>, <code class="literal">trace</code>, and so on), integers (<code class="literal">0</code>, <code class="literal">128</code>, <code class="literal">32768</code>), and hexidecimal numbers (<code class="literal">0x2</code>, <code class="literal">0x80</code>, <code class="literal">0x100</code>).</p><p>Setting this to <code class="literal">none</code> will cause SLAPD to only log critical events. In order to turn <span class="emphasis"><em>off</em></span> the logging altogether, use <code class="literal">0</code>. To turn <span class="emphasis"><em>on</em></span> all the logging, which will generate massive amounts of logging for every request, use <code class="literal">any</code>. The SLAPD man page (<code class="literal">man slapd</code>) provides a complete list of all the supported log levels.<a class="indexterm" id="id54"/>
<a class="indexterm" id="id55"/>
</p></div><div class="section" title="Module Directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec07"/>Module Directives</h3></div></div></div><a class="indexterm" id="id56"/><p>The last few directives in the <span class="emphasis"><em>Basics</em></span> section are <code class="literal">modulepath</code> and <code class="literal">moduleload</code>. These are instructions for loading OpenLDAP modules.</p><p>A <span class="strong"><strong>module</strong></span> is a special type of library that can be loaded when SLAPD starts up. Instead of compiling all of SLAPD's code into one large binary, the modules make it possible to create smaller library files for discrete functional units of LDAP code.</p><p>Typically, there are two different kinds of modules:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Backends</strong></span>: The OpenLDAP server can use different storage backends, including BDB, SQL database, flat files (in LDIF format), or even another LDAP directory server. Each of these backends can be compiled into its own module. Then, during configuration, we have the option of only loading the module (or modules) that we need.</li><li class="listitem"><span class="strong"><strong>Overlays</strong></span>: OpenLDAP includes a number of optional extensions, called overlays, which can modify behavior of the server (we will look at several overlays in the course of this book). These, too, are stored in modules.</li></ol></div><p>Let's have a look at the directives we have used in our <code class="literal">slapd.conf</code> file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">modulepath</code> directive provides the full path to the directory where the modules (the compiled libraries) are stored. By default, Ubuntu puts LDAP libraries in <code class="literal">/usr/lib/ldap</code>. If, for some reason, you have modules stored in multiple directories you can specify a list of paths, separated by colons:<div class="informalexample"><pre class="programlisting">  modulepath /usr/lib/ldap:/usr/local/lib/custom-ldap</pre></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">moduleload</code> directive instructs OpenLDAP to load a particular module. The directive takes either the file name of the module to be loaded (such as <code class="literal">back_hdb</code>) or a full path (beginning with <code class="literal">/</code>) to a module file. If just the name is specified, SLAPD will look in the directories specified in <code class="literal">modulepath</code>. If the entire path is specified, it will attempt to load from exactly that path (it will not use <code class="literal">modulepath</code> at all).</li><li class="listitem" style="list-style-type: disc"><code class="literal">moduleload back_hdb</code> instructs SLAPD to load the module that provides services for storing the directory in the <span class="emphasis"><em>Hierarchical</em></span> <span class="emphasis"><em>Database</em></span> (HDB) backend. This is the database that we will configure in the <span class="emphasis"><em>Database</em></span> <span class="emphasis"><em>Configuration</em></span> section.</li></ul></div><p>For now these are the only directives we need in the <span class="emphasis"><em>Basics</em></span> section. There are other <a class="indexterm" id="id57"/>options though, and we will look at many of them <a class="indexterm" id="id58"/>in Chapters 4 and 5.</p></div></div><div class="section" title="Database Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Database Configuration</h2></div></div></div><a class="indexterm" id="id59"/><p>The next section of our <code class="literal">slapd.conf</code> file is the database configuration section. This section handles the configuration of the database storage mechanisms. OpenLDAP is not limited to one database. More than one database can be used per server, where each database stores its own directory tree (or subtree). For example, a single OpenLDAP instance can serve a directory tree whose base is <code class="literal">o=My Company,c=US</code> from one database, and a directory tree whose root is <code class="literal">dc=example,dc=com</code> from a second database.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12345"/>Note</h3><p>As we saw in Chapter 1, the base DN for a directory tree is made up of attribute name/attribute value pairs. For example, the DN <code class="literal">o=My Company, c=US</code> indicates that the organization name <code class="literal">(o)</code> is My Company, and its country of origin <code class="literal">(c)</code> is United States (whose two-letter ISO code is US). Likewise, the second DN is composed of attribute name/value pairs, this time representing domain components <code class="literal">(dc)</code> from the organization's registered domain name, here, the fictitious <code class="literal">Example.Com</code>.</p></div></div><p>We will look at this option in Chapter 5. In our simple <code class="literal">slapd.conf</code> file, we are defining only one database:</p><div class="informalexample"><pre class="programlisting">##########################
# Database Configuration #
##########################
database hdb
suffix "dc=example,dc=com"
rootdn "cn=Manager,dc=example,dc=com"
rootpw secret
directory /var/lib/ldap
# directory /usr/local/var/openldap-data
index objectClass,cn eq</pre></div><p>The first directive in the database configuration section is the <code class="literal">database</code> directive. This specifies which database backend will be used. In this case we will be using the <span class="strong"><strong>Hierarchical Database</strong></span> (<span class="strong"><strong>HDB</strong></span>), so we specify <code class="literal">hdb</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note465654"/>Note</h3><p>HDB is the new generation storage mechanism for OpenLDAP. Like its predecessor, the BDB backend, HDB uses the Oracle Berkeley DB database for storage, but HDB stores entries hierarchically, a perfect fit for LDAP's tree strucutre. The old BDB backend is still supported, and you can use it by specificing <code class="literal">bdb</code> instead of <code class="literal">hdb</code> in the <code class="literal">database</code> directive.</p></div></div><p>The next directive, <code class="literal">suffix</code>, indicates which parts of the directory tree this database will hold. Basically, it indicates that this database's base will be the entry with the <span class="strong"><strong>Distinguished Name</strong></span> (<span class="strong"><strong>DN</strong></span>) specified in the <code class="literal">suffix</code> directive (<code class="literal">dc=example</code>,<code class="literal">dc=com</code>). We have discussed <span class="emphasis"><em>Distinguished</em></span> <span class="emphasis"><em>Names </em></span>in Chapter 1.</p><p>When the server receives a request for something in that tree (for example, <code class="literal">cn=Matt</code>,<code class="literal">dc=example</code>,<code class="literal">dc=com</code>), it will search in this database. The following figure gives a better idea:<a class="indexterm" id="id60"/>
</p><div class="mediaobject"><img alt="Database Configuration" src="graphics/1021_02_01.jpg"/></div><p>Here, the client is searching for a specific DN, <code class="literal">cn=Matt</code>, <code class="literal">dc=example,dc=com</code>. The SLAPD server contains a directory information tree whose base DN is <code class="literal">dc=example</code>, <code class="literal">dc=com</code>.</p><p>The DN <code class="literal">cn=Matt</code>,<code class="literal">dc=example</code>,<code class="literal">dc=com</code> is subordinate to <code class="literal">dc=example</code>,<code class="literal">dc=com</code>. It exists in the <code class="literal">dc=example</code>,<code class="literal">dc=com</code> tree. So, SLAPD searches the <code class="literal">dc=example</code>,<code class="literal">dc=com</code> database for a record whose DN is <code class="literal">cn=Matt</code>,<code class="literal">dc=example</code>,<code class="literal">dc=com</code>. Once the record is found, it is returned to the client.</p><p>What will happen if a client requests the record of <code class="literal">cn=Matt</code>,<code class="literal">dc=test</code>,<code class="literal">dc=net</code>? Since this DN does not contain a base DN handled by this server, the server will not search for the record. Depending on the configuration, it may either send an error back to the client or redirect the client to another server that might be able to handle such a request.</p><p>Likewise, if a client tries to <span class="emphasis"><em>add</em></span> a record with a base DN other than the one specified in the suffix directive, the LDAP server will refuse to add the record to the directory information tree.</p><p>The <code class="literal">suffix</code> directive in <code class="literal">slapd.conf</code> specifies what the base DN will be for information stored or referenced in this database. This will determine, to a large degree, what records this database will contain, search for, or allow to be added.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note156465"/>Note</h3><p>One database can have multiple trees (this is covered in Chapter 5).</p></div></div><p>The next two lines assign a record for the directory manager and give the manager entry a password. The <code class="literal">rootdn</code> directive specifies the DN that will be considered the administrator of this directory. By convention, the <span class="emphasis"><em>root</em></span> DN is created by prepending <code class="literal">cn=Manager</code> to the <span class="emphasis"><em>base</em></span> DN of the directory tree. Thus, our directory manager is <code class="literal">cn=Manager</code>,<code class="literal">dc=example</code>,<code class="literal">dc=com</code>. The next field, <code class="literal">rootpw</code>, is used to assign a password for the directory manager. Note that this is stored outside the directory rather than inside it. For example, the <code class="literal">userPassword</code> attribute of a record in the directory. This is to prevent <a class="indexterm" id="id61"/>the manager from being <span class="emphasis"><em>locked</em></span> <span class="emphasis"><em>out</em></span> of the directory.</p><p>The directory manager is a special user with special privileges. The manager's requests are not filtered through ACLs—the manager's access cannot be restricted. Furthermore, the manager has <span class="emphasis"><em>write</em></span> access to all records in the directory under the specified suffix or suffixes. For that reason, the manager DN should be used for administrative tasks only and not for anything else.</p><p>Further, since the necessary fields for the manager are stored here in the <code class="literal">slapd.conf</code> file, there should <span class="emphasis"><em>not</em></span> be a record in the directory with the manager's DN (this is recommended for best practices, though it is not explicitly prevented by SLAPD).</p><p>Since the manager's DN and password are stored in the <code class="literal">slapd.conf</code> file, and since the manager has access to everything in the directory, we should keep file system permissions on the <code class="literal">slapd.conf</code> file as restrictive as possible.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip1564"/>Tip</h3><p><span class="strong"><strong>Encrypting the Manager's Password</strong></span></p><p>You can also give <code class="literal">rootpw</code> an encrypted password by using the <code class="literal">ldappasswd</code> utility, described in the next chapter.</p></div></div><p>The <code class="literal">directory</code> directive indicates which directory on the file system should hold the database files. In this case the database is stored at <code class="literal">/var/lib/ldap/</code>.</p><p>Finally, the <code class="literal">index</code> directive is composed of a list of attributes that should be indexed, followed by the type of matching that the index will be used for. Our example looked like this:</p><div class="informalexample"><pre class="programlisting">index objectClass,cn eq</pre></div><p>This means that we are creating an index that will support equality (<code class="literal">eq</code>) matching on the attributes <code class="literal">objectClass</code> and <code class="literal">cn</code>. When the server gets a request for all the entries with <code class="literal">cn Rob</code> or <code class="literal">commonName Rob</code>, the server can greatly expedite service by accessing the index instead of searching the entire database. However, if the request was for <code class="literal">Rob*</code> (note the <code class="literal">*</code> wildcard character), then the server would not be looking for a CN that equals "Rob*", but for any CN that starts with "Rob". In this case, the index we created would not be used.</p><p>Multiple index directives can be used, and we could support faster CN searches for queries like <code class="literal">Rob*</code> by splitting the index directive into two different directives:</p><div class="informalexample"><pre class="programlisting">index objectClass eq
index cn eq,sub</pre></div><p>In the given example, an equality (<code class="literal">eq</code>) index is maintained for <code class="literal">objectClass</code> attributes, <a class="indexterm" id="id62"/>while the <code class="literal">cn</code> attribute is indexed for equality matches (<code class="literal">eq</code>) and substring matches (<code class="literal">sub</code>).</p><p>Certain attributes do not support all index types. The <code class="literal">objectClass</code> attribute, for example, does not support substring (<code class="literal">sub</code>) index matching. When we will look at performance tuning in Chapter 5, we will see the indexing directive more carefully.</p><p>Once you have a database created, every time you modify the <code class="literal">index</code> directives in <code class="literal">slapd.conf</code>, you should rebuild the indexes with the <code class="literal">slapindex</code> command-line utility. Since we have not yet put any data in the database though, we don't need to run this command now.</p><p>Now we are ready to move on to the third and final section of our configuration file.</p></div><div class="section" title="ACLs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>ACLs</h2></div></div></div><a class="indexterm" id="id63"/><a class="indexterm" id="id64"/><p>The last section in the <code class="literal">slapd.conf</code> file is the ACL section. ACLs (Access Control Lists) determine which clients can access what data, and under what conditions. In Chapter 4, we will cover ACLs in much more detail. However, it is important to have some basic ACLs configured from the beginning, so we will briefly walk through two simple ACLs:</p><div class="informalexample"><pre class="programlisting">########
# ACLs #
########
access to attrs=userPassword
       by anonymous auth
       by self write
       by * none

access to *
       by self write
       by * none</pre></div><p>ACLs are just fancy directives—directives with a complex syntax. They begin with the access directive, followed by a list of conditions. The conditions can span multiple lines as long as each continuation line begins with one or more white space characters (such as a tab or a space).</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip154d"/>Tip</h3><p><span class="strong"><strong>Line Continuations in slapd.conf file</strong></span></p><p>Any directive, not just ACLs, can span multiple lines, as long as each continued line begins with a white space. For example, <code class="literal">moduleload back_hdb</code> can be written as:</p><p><code class="literal">moduleload</code></p><p><code class="literal">back_hdb</code></p></div></div><p>Let's look at the first access control in detail:</p><div class="informalexample"><pre class="programlisting">access to attrs=userPassword
       by anonymous auth
       by self write
       by * none</pre></div><p>The purpose of this access control is to keep a user's password protected. Specifically, it allows anonymous users to request that the server perform an authentication comparison (during the process of logging on) on a password. Additionally, it grants a user permission to change his or her own password. Finally, it denies everyone else any access to the password. That's what this rule is supposed to do. Now, how do we get that?</p><p>Each line of code having <code class="literal">by</code> should be indented:</p><p>
<code class="literal">access to</code> [<span class="emphasis"><em>resources</em></span>]</p><p>             <code class="literal">by</code> [<span class="emphasis"><em>who</em></span>] [<span class="emphasis"><em>type</em></span> <span class="emphasis"><em>of</em></span> <span class="emphasis"><em>access</em></span> <span class="emphasis"><em>granted</em></span>]</p><p>             <code class="literal">by</code> [<span class="emphasis"><em>who</em></span>] [<span class="emphasis"><em>type</em></span> <span class="emphasis"><em>of</em></span> <span class="emphasis"><em>access</em></span> <span class="emphasis"><em>granted</em></span>]</p><p>             <code class="literal">by</code> [<span class="emphasis"><em>who</em></span>] [<span class="emphasis"><em>type</em></span> <span class="emphasis"><em>of</em></span> <span class="emphasis"><em>access</em></span> <span class="emphasis"><em>granted</em></span>]</p><p>Each <code class="literal">access</code> directive can have one <code class="literal">to</code> phrase, and any number of <code class="literal">by</code> phrases. Our first rule has three <code class="literal">by</code> phrases. Let's see these in more detail:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In <code class="literal">access to attrs=userPassword</code>, <code class="literal">attrs</code> indicates that a list of one or more attributes will follow. In our case there is only one attribute: <code class="literal">userPassword</code>. The <code class="literal">userPassword</code> attribute is used to store the value of a password for an object in the directory.<div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note13213a"/>Note</h3><p>While not just any object in the directory can have a userPassword, there are many objects in the directory that are not users, but can have passwords. The most frequent use of the <code class="literal">userPassword</code> attribute is for records that describe users.</p></div></div><p>In this access control there is no explicit mention of particular parts of the directory to which this rule applies. Given this, the ACL will be enforced for <span class="emphasis"><em>all</em></span> instances of <code class="literal">userPassword</code>. So, the rule specifies access to the <code class="literal">userPassword</code> attribute. The next three phrases will indicate who has access to <code class="literal">userPassword</code> attributes, and what kind of access they have.<a class="indexterm" id="id65"/>
</p></li><li class="listitem" style="list-style-type: disc">Next is <code class="literal">by anonymous auth</code>. This phrase grants an anonymous user (one who has not yet authenticated) permission to authenticate using a password. More accurately, it indicates that when a user submits a request for authentication, the directory server is allowed to perform an authentication operation (which <a class="indexterm" id="id66"/>amounts to comparing the submitted password with the value in the <code class="literal">userPassword</code> attribute for the corresponding user's entry).</li><li class="listitem" style="list-style-type: disc">The last part of the <code class="literal">by</code> phrase specifies what sort of permissions are granted to the record. The permissions level can be granted in a few ways, which is discussed in detail in Chapter 4.</li></ul></div><p>For the time being, though, we will look at four keywords that can be used in ACLs to grant common permission levels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">auth</code>: The server can perform an authentication operation using this resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">read</code>: The client can have <code class="literal">auth</code> access and can also <span class="emphasis"><em>read</em></span> this resource, but cannot make any changes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">write</code>: The client can have <code class="literal">auth</code> and <code class="literal">read</code> access to this resource and can also perform add, modify, and delete operations on whatever is specified by resource.</li><li class="listitem" style="list-style-type: disc"><code class="literal">none</code>: The server should not give the client any access at all to this resource.</li></ul></div><p>In Chapter 4, when we look at ACLs in depth, we will look at other keywords and explore creating finer-grained permissions levels, such as allowing write access without granting read access.</p><p>So, the second <code class="literal">by</code> phrase, <code class="literal">by self write</code>, means that once a DN (usually a user) has successfully connected and authenticated to the LDAP server, it can change the value of <code class="literal">userPassword</code>.</p><p>Finally, the last <code class="literal">by</code> phrase says <code class="literal">by * none</code>. The <code class="literal">*</code> is a wildcard that will apply to everyone. And <code class="literal">none</code>, as we came to know, denies any sort of access to the <code class="literal">userPassword</code> attribute. This rule says that everyone should be denied access to the password attribute.</p><p>This third <code class="literal">by</code> phrase provides a good illustration of how ACLs are applied. The ACL is evaluated in order. In the rules above, as soon as the server finds a rule that applies to the current DN, it will stop processing the ACL. Consider an example. When an anonymous user tries to authenticate (bind) with a DN and password, the server will check the ACLs to see if the DN has the right to request an authentication comparison using the <code class="literal">userPassword</code> attribute.</p><p>As SLAPD evaluates this ACL, it will see that the first <code class="literal">by</code> phrase applies; use that rule and skip the other two. But, on the other hand, if an authenticated user tries to read <code class="literal">userPassword</code> of another DN, the server will search <code class="literal">by</code> phrases until it finds one that matches. It will evaluate and skip the first two before applying the third, which denies <a class="indexterm" id="id67"/>that user the access to another record's <code class="literal">userPassword</code> attribute.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip545454a"/>Tip</h3><p><span class="strong"><strong>The Default by Phrase</strong></span></p><p>When processing an ACL, SLAPD denies access by default. This means that every access directive ends with an implicit <code class="literal">by</code> phrase of <code class="literal">by *</code> none. So, to save space, we could have omitted the last phrase from both of our ACLs.</p></div></div><p>Now that we understand the first ACL, the second should be a breeze. Let's see the second one:</p><div class="informalexample"><pre class="programlisting">access to *
       by self write
       by * none</pre></div><p>This last ACL becomes our default rule for the directory. It can be paraphrased this way: for any object and all its attributes (<code class="literal">to *</code>), if the currently connected DN is the DN of this object, it can write to the object (<code class="literal">by self write</code>). Otherwise, the currently connected DN has no access whatsoever (<code class="literal">by * none</code>). In short, it lets objects write to themselves, but denies everyone else all the permissions to the object.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip132132r"/>Tip</h3><p><span class="strong"><strong>Restricting the Manager</strong></span></p><p>It should be noted that ACLs cannot be used to restrict the special directory manager account named in the <code class="literal">rootdn</code> directive.</p></div></div><p>Keep in mind that ACLs are processed sequentially. So this second rule will only apply if the earlier rule did not apply.</p><p>These access controls are very strict and will prevent directory users from getting much out of the directory. In Chapter 5 we will create some more rules which will make the directory more accessible, but for now these simple rules will suffice.<a class="indexterm" id="id68"/>
</p></div><div class="section" title="Verifying a Configuration File"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Verifying a Configuration File</h2></div></div></div><a class="indexterm" id="id69"/><p>We are now done working through the configuration file. The last thing to do before we start the server is to verify that the configuration file is valid.</p><p>OpenLDAP includes a tool for testing the configuration file to make sure that it is well-formed and that the directives are all used correctly. It also checks elements of the OpenLDAP environment to ensure that the requisite files are in the correct locations. The testing tool is called <code class="literal">slaptest</code> and it appears as:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slaptest -v -f /etc/ldap/slapd.conf</strong></span>
</pre></div><p>Since the file system permissions on <code class="literal">slapd.conf</code> are very restrictive, we used <code class="literal">sudo</code> to execute the test as the root user. The <code class="literal">slaptest</code> command needs to know where the <code class="literal">slapd.conf</code> file is. This is specified with the <code class="literal">-f</code> parameter followed by the path to the configuration file. We also used the <code class="literal">-v</code> flag to require verbose output. Since nothing was wrong with <code class="literal">slapd.conf</code>, only one line was printed:</p><div class="informalexample"><pre class="programlisting">config file testing succeeded</pre></div><p>But if anything is incorrect, <code class="literal">slaptest</code> will provide diagnostic information. Let's look at a misconfigured <code class="literal">slapd.conf</code> file:</p><div class="informalexample"><pre class="programlisting"># slapd.conf - Configuration file for LDAP SLAPD
##########
# Basics #
##########
include /etc/ldap/schema/core.schema
include /etc/ldap/schema/cosine.schema
include /etc/ldap/schema/inetorgperson.schema

pidfile /var/run/slapd/slapd.pid
argsfile /var/run/slapd/slapd.args
loglevel none
modulepath /usr/lib/ldap
# modulepath /usr/local/libexec/openldap
moduleload back_hdb

##########################
# Database Configuration #
##########################
database hdb
suffix "dc=example,dc=com"
rootdn "cn=Manager,dc=example,dc=com"
rootpw secret
directory /var/lib/ldap
# directory /usr/local/var/openldap-data
<span class="strong"><strong>index objectClass sub,eq</strong></span>
index cn sub,eq

########
# ACLs #
########
access to attrs=userPassword
       by anonymous auth
       by self write
       by * none
<a class="indexterm" id="id70"/>
access to *
       by self write
       by * none</pre></div><p>This configuration file is a minor variation of the one we have been examining throughout this section. The problem is that the <code class="literal">objectClass</code> attribute cannot handle substring matches. The reason for this (explained in more detail in Chapter 6) is that the schema does not allow substring matching on the <code class="literal">objectClass</code> attribute.</p><p>Having made the above change, we run the <code class="literal">slaptest</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slaptest -v -f slapd.conf</strong></span>
</pre></div><p>The following messages appear:</p><div class="informalexample"><pre class="programlisting">slapd.conf: line 48: substr index of attribute 
                       "objectClass" disallowed
slaptest: bad configuration file!</pre></div><p>As you can see this information is useful for quickly finding and fixing problems before attempting to start the server.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip1000000"/>Tip</h3><p><span class="strong"><strong>An Ubuntu Oversight</strong></span></p><p>Due to a configuration oversight by Ubuntu packager maintainers, the slaptest program does not issue a warning if an unknown directive is found. As a result, a mistaken directive name may slip through the verification stage unnoticed. For example, misspelling index as idnex will not result in an error.</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip213213213"/>Tip</h3><p><span class="strong"><strong>Testing slapd.conf with slapd</strong></span></p><p>The slaptest command is actually nothing more than a symbolic link to slapd, the command used to start the server. While there are no distinct advantages to doing so, you can use the slapd program to test <code class="literal">slapd.conf</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ slapd -T dest -f /etc/ldap/slapd.conf</strong></span>
</pre></div></div></div><p>Once the configuration file passes muster with the <code class="literal">slaptest</code> program, we are ready to start our server.</p><p>At this point, we have walked through our basic <code class="literal">slapd.conf</code> configuration file. This configuration will get our directory up and running, and in later chapters of this book we will cover some more advanced settings that can be included here in the configuration file.<a class="indexterm" id="id71"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note12313215615"/>Note</h3><p>If you are interested in reading more about configuration options for <code class="literal">slapd.conf</code>, you may want to take a look at the manual (man) pages. The man pages for OpenLDAP provide a thorough (though sometimes tersely worded) reference. In particular, the <code class="literal">slapd.conf</code> page is very useful.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ man slapd.conf</strong></span>
</pre></div></div></div><p>At the bottom of that page there is a list of other related manual pages, such as <code class="literal">slapd-hdb</code>, which lists directives specific to the HDB database.</p></div></div>
<div class="section" title="Starting and Stopping the Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Starting and Stopping the Server</h1></div></div></div><p>At this point, we have configured our <code class="literal">slapd.conf</code> file. We are now ready to start our server. There are two different ways to run the SLAPD server: we can either use the init script provided with the distribution, or we can run the <code class="literal">slapd</code> command directly. Each way has its advantages, and we will look at both here.</p><div class="section" title="Using the Init Script"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Using the Init Script</h2></div></div></div><a class="indexterm" id="id72"/><a class="indexterm" id="id73"/><p>The OpenLDAP packages that are installed with Ubuntu include a startup script that is located, along with other service startup scripts, in the <code class="literal">/etc/init.d/</code> directory. The scripts in <code class="literal">/etc/init.d/</code>, usually referred to as the <span class="strong"><strong>init scripts</strong></span>, are used to automatically <span class="emphasis"><em>start</em></span> and <span class="emphasis"><em>stop</em></span> services when the system run level changes (when the system boots, halts, or reboots), and by default, OpenLDAP should be configured to start when the server boots, and stop during halts and reboots.</p><p>The <code class="literal">ldap</code> init script provides a convenient way to start, stop, and restart the server. You can start it (if it is not already running) with the Ubuntu <code class="literal">invoke-rc.d</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo invoke-rc.d slapd start</strong></span>
</pre></div><p>You can use the same script to stop the server. Just change <code class="literal">start</code> to <code class="literal">stop</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo invoke-rc.d slapd stop</strong></span>
</pre></div><p>Similarly, to restart, use the <code class="literal">restart</code> command instead of <code class="literal">start</code> or <code class="literal">stop</code>.</p><p>The init scripts set up default parameters and pass in many system options. Some of these are stored in a separate configuration file located at <code class="literal">/etc/default/slapd</code>. For example, <a class="indexterm" id="id74"/>by setting the <code class="literal">SLAPD_USER</code> and <code class="literal">SLAPD_GROUP</code> variables to a particular system user ID and group ID, you can run SLAPD as a user other than the default.<a class="indexterm" id="id75"/>
</p><p>The OpenLDAP server must start as root, in order to bind to the correct TCP/IP port (389 or 636 by default). Then it will switch and use the user account and group specified in the file located at <code class="literal">/etc/default/slapd</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note121212121"/>Note</h3><p>Ubuntu creates a special user and group, named <code class="literal">openldap</code>, for running SLAPD. Other distributions run SLAPD as root, which is not a good idea from a security point of view.</p></div></div><p>Other settings, such as logging settings, can also be made in this configuration file.</p></div><div class="section" title="Running SLAPD Directly"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Running SLAPD Directly</h2></div></div></div><a class="indexterm" id="id76"/><a class="indexterm" id="id77"/><p>Sometimes, it is useful to start SLAPD directly from the command line. This may make it easier to see error messages when starting of the server fails, or to test configurations before making any changes to the init script or its configuration files.</p><p>To start the SLAPD server directly, simply run the <code class="literal">slapd</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slapd</strong></span>
</pre></div><p>This will start the SLAPD server in the background.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note14654645"/>Note</h3><p>If you compiled OpenLDAP from source, the <code class="literal">slapd</code> command will be at <code class="literal">/usr/local/libexec/</code>, which is not, by default, in <code class="literal">$PATH</code>. You will have to run the command using the full path: <code class="literal">/usr/local/libexec/slapd</code>.</p></div></div><p>The server will write its process ID to the location specified in the <code class="literal">pidfile</code> directive in <code class="literal">slapd.conf</code>. In our case, this is <code class="literal">/var/run/slapd/slapd.pid</code>. We can stop the server by using the standard <code class="literal">kill</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo kill `cat /var/run/slapd/slapd.pid`</strong></span>
</pre></div><p>This command first uses the <code class="literal">cat</code> program to print the contents of the file (which is simply the process ID of <code class="literal">slapd</code>). Note that the <code class="literal">cat</code> command is surrounded by backticks (<code class="literal">`</code>), not single quotes (<code class="literal">'</code>). The backticks tell the shell to treat the statement as a command to be executed. The process ID is then passed to the <code class="literal">kill</code> command, which instructs the process to shut itself down.</p><p>In cases where the <code class="literal">slapd.pid</code> file is not available you might find it more expedient to kill the server with this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo kill `pgrep slapd`</strong></span>
</pre></div><p>Sometimes though, it is more useful to start the command in the foreground, and set debugging information to print out in the terminal window. This can be done quite easily as well:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo slapd -d config</strong></span><a class="indexterm" id="id78"/> <a class="indexterm" id="id79"/>
</pre></div><p>In the command above we use the <code class="literal">-d</code> flag to print logging information to the shell's standard output. This means that <code class="literal">slapd</code> will print information to the terminal window. The <code class="literal">-d</code> flag takes one parameter—the debugging level. We have specified <code class="literal">config</code>, which instructs the server to print verbose logging information about the processing of the configuration file.</p><p>The output looks something like this:</p><div class="informalexample"><pre class="programlisting">@(#) $OpenLDAP: slapd 2.3.24 (Jun 16 2006 23:35:48) $ 
      mbutcher@bezer:/home/mbutcher/temp/openldap-2.3.24/servers/slapd
reading config file /etc/ldap/slapd.conf
line 6 (include /etc/ldap/schema/core.schema)
reading config file /etc/ldap/schema/core.schema
line 44 (rootdn "cn=Manager,dc=example,dc=com")
line 45 (rootpw ***)
line 47 (directory /var/lib/ldap)
line 48 (index objectClass eq)
index objectClass 0x0004
line 49 (index cn eq,sub,pres,approx)
index cn 0x071e
slapd starting</pre></div><p>This can be one other useful way to ferret out configuration issues. The <code class="literal">-d</code> flag will take any of the debugging levels specified in the <code class="literal">slapd.conf</code> man page. I find <code class="literal">acl</code> useful for debugging access problems, and <code class="literal">filter</code> is often useful in figuring out trouble with searches.</p><p>When <code class="literal">-d</code> is specified the program will run in the foreground. To stop the server simply hit <span class="emphasis"><em>CTRL+C</em></span>. This will stop the server and return you to a shell prompt.</p><p>Other useful command line parameters to use with <code class="literal">slapd</code> are <code class="literal">-u</code> and <code class="literal">-g</code>. Each takes one argument: <code class="literal">-u</code> takes a username and <code class="literal">-g</code> takes a groupname. These control the effective UID and GID (user ID and group ID) that SLAPD runs as. Once SLAPD has started and connected to the appropriate ports (which it must do as root), it will switch its UID and GID to the names specified in these parameters.<a class="indexterm" id="id80"/>
<a class="indexterm" id="id81"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note15515151"/>Note</h3><p>To get a list of other command line flags that we can use with <code class="literal">slapd</code>, refer to the man page for <code class="literal">slapd</code>.</p></div></div><p>In the next section, we will be using some of the OpenLDAP clients to connect to our directory. This will require that the SLAPD server be running. You can verify that <code class="literal">slapd</code> is running by checking if <code class="literal">/var/run/slapd/slapd.pid</code> exists, or by running <code class="literal">pgrep slapd</code>, which will display the process ID of <code class="literal">slapd</code> if it's running. If no process ID number is returned, <code class="literal">slapd</code> is not running.</p></div></div>
<div class="section" title="Configuring the LDAP Clients"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Configuring the LDAP Clients</h1></div></div></div><a class="indexterm" id="id82"/><p>In the last couple of sections we have focused exclusively on the SLAPD server. Now that the server is running we need to get the client configuration so that we can make test connections to the server.</p><p>Fortunately all of the OpenLDAP client programs share one common configuration file, <code class="literal">ldap.conf</code>, which is located in Ubuntu at <code class="literal">/etc/ldap/ldap.conf</code> (if you build from source, according to <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a>, the default location for this file is <code class="literal">/usr/local/etc/openldap/ldap.conf</code>).</p><p>Other programs, such as those that use the OpenLDAP client libraries (like the PHP and Python LDAP APIs, may also use the <code class="literal">ldap.conf</code> file as a default location to retrieve basic configuration information.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip1516564"/>Tip</h3><p><span class="strong"><strong>Too Many ldap.conf Files</strong></span></p><p>Occasionally, some Linux distributions will create two different <code class="literal">ldap.conf</code> files—one for OpenLDAP, and one for the PAM or NSS LDAP tools. This can lead to confusion about which <code class="literal">ldap.conf</code> file is used for which process. Ubuntu, however, gives the other packages distinctly named configuration files, like <code class="literal">/etc/pam_ldap.conf</code>.</p></div></div><div class="section" title="A Basic ldap.conf File"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>A Basic ldap.conf File</h2></div></div></div><p>The purpose of the <code class="literal">ldap.conf</code> file is two-fold:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">It provided a place to define certain aspects of client behavior, such as how they treat SSL/TLS certificates or whether they follow alias entries.</li><li class="listitem">It provides the OpenLDAP clients with useful defaults. By specifying some defaults, we can reduce the number of parameters we have to pass to the OpenLDAP clients when we run them from the command line.</li></ol></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note5555555"/>Note</h3><p>An <span class="strong"><strong>alias</strong></span> is an entry in the directory that points to some other entry. Conceptually, it is similar to a symbolic link in a UNIX/Linux file system, or to a shortcut in Microsoft Windows.</p></div></div><p>The <code class="literal">ldap.conf</code> file has three different kinds of directive:<a class="indexterm" id="id83"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">General settings, which specify things such as the default server and DN to use</li><li class="listitem" style="list-style-type: disc">SASL-specific settings, which determine how the OpenLDAP clients will try to authenticate when using SASL (Simple Authentication and Security Layer) authentication mechanisms</li><li class="listitem" style="list-style-type: disc">TLS-specific settings, which specify how OpenLDAP will handle connections that use SSL (Secure Sockets Layer) and TLS encryption</li></ul></div><p>At this point we are only interested in the general settings. In later chapters, we will return to this file when configuring SSL/TLS and SASL.</p><p>Now, we need to look into a basic <code class="literal">ldap.conf</code> file. The <code class="literal">ldap.conf</code> file is located in the same directory as <code class="literal">slapd.conf</code>—<code class="literal">/etc/ldap/</code> (or <code class="literal">/usr/local/etc/openldap/</code> if you built from source). We will now insert the LDAP client settings into that basic <code class="literal">ldap.conf</code> file:</p><div class="informalexample"><pre class="programlisting"># LDAP Client Settings

URI  ldap://localhost
BASE  dc=example,dc=com
BINDDN  cn=Manager,dc=example,dc=com

SIZELIMIT  0
TIMELIMIT  0</pre></div><p>Again, as with <code class="literal">slapd.conf</code>, lines that begin with a number sign (<code class="literal">#</code>) are treated as comments, and are ignored by the OpenLDAP client tools.</p><p>Next, we have directives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The URI directive indicates which server (or servers, as this directive can take multiple URIs, separated by spaces) is to be contacted if no server is explicitly specified by the client.<p>Since the server is running on the same machine that we are going to be running client commands from, we should set the URI to <code class="literal">ldap://localhost</code>. This URI specifies that the default client connection should be made using the (unencrypted) LDAP protocol over the loopback interface (<code class="literal">127.0.0.1</code> or <code class="literal">localhost</code>). Since no port is specified it will use the default LDAP port, which is 389.<a class="indexterm" id="id84"/>
</p></li><li class="listitem" style="list-style-type: disc">The second directive is <code class="literal">BASE</code>. This tells the client programs where to start their search in the directory. It takes a full DN as a value. In this case we set it to the base DN of the server—to the DN of the root entry in our directory tree, so that all searches will start at the root.<p>You may recall that when we were working on the database configuration section of <code class="literal">slapd.conf</code>, we set this same base DN, <code class="literal">dc=example,dc=com</code>, as the suffix for the database stored there. So, what we have done here is told the client to start at the same directory tree root that the server manages. This is generally the most convenient way to configure <code class="literal">BASE</code> in the <code class="literal">ldap.conf</code> file.</p></li><li class="listitem" style="list-style-type: disc">The third directive, <code class="literal">BINDDN</code>, specifies the default DN that will be used when connecting to the server. In this file I have set it to the manager's DN, <code class="literal">cn=Manager,dc=example,dc=com</code>. While this will be very helpful when it comes to the examples in the next chapter it is not, in general, a good idea, and should never be set this way in a production environment. Usually the <code class="literal">BINDDN</code> default value should be set to a user that has limited privileges, or it should be omitted (in which case no default DN will be used).</li></ul></div><div class="section" title="Size and Time Limits"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec08"/>Size and Time Limits</h3></div></div></div><p>The next two directives, <code class="literal">SIZELIMIT</code> and <code class="literal">TIMELIMIT</code>, indicate the upper limits on the number of records returned (<code class="literal">SIZELIMIT</code>) and the amount of time the client will wait for the server to respond (<code class="literal">TIMELIMIT</code>). Here we have set both to 0, a special value for these directives that indicates that there should be no limit.</p><p>The way that size and time limits are handled can be a little confusing. On the client side there are two ways of specifying these limits: through the <code class="literal">ldap.conf</code> configuration file (as we are doing here) and through command-line parameters (as we will see in the next chapter).</p><p>However, the <code class="literal">SIZELIMIT</code> and <code class="literal">TIMELIMIT</code> directives above are not exactly defaults in the usual sense of the word. They are the absolute upper limit that the client can request. With command-line arguments the client can specify lower time and size limits, and those lower numbers will be used. But if the client attempts to specify larger size or time limits, they will be ignored, and the values of <code class="literal">SIZELIMIT</code> and <code class="literal">TIMELIMIT</code> will be used instead.</p><p>But the story doesn't end here. The SLAPD server can also define size and time limits (with the <code class="literal">limits</code>, <code class="literal">sizelimit</code> and <code class="literal">timelimit</code> directives in <code class="literal">slapd.conf</code>). If a client specifies a limit higher than the server's, the server will ignore the client's limit and use its <a class="indexterm" id="id85"/>own. We will look more at setting server limits in Chapter 5.</p><p>Now we have a functioning <code class="literal">ldap.conf</code> file that will alleviate the need to specify these parameters on the command line.</p><p>The last thing we need to do in this chapter is to use an OpenLDAP client to test out the SLAPD server.</p></div></div></div>
<div class="section" title="Testing the Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Testing the Server</h1></div></div></div><a class="indexterm" id="id86"/><p>At this point, we have a SLAPD server configured and running, and we have an <code class="literal">ldap.conf</code> file that specifies many of the defaults for our tools. Now we are going to query the directory and fetch some information.</p><p>We haven't actually put any entries in our database, though. So what will we query? SLAPD does provide directory-based access to certain information, including currently-loaded schemas and subschemas, configuration information, and a special record called the <span class="strong"><strong>root DSE</strong></span>. The root DSE (<span class="strong"><strong>DSA-Specific Entry</strong></span>, where <span class="strong"><strong>DSA</strong></span> stands for <span class="strong"><strong>Directory Service Agent</strong></span>—the technical term for an LDAP server) is a special entry that provides information about the server itself. Like all other entries in an LDAP, the root DSE has a DN. Unlike all other entries, the root DSE's DN is an empty string.</p><p>Why use an empty string for a DN? The answer is simple: any client can connect to the server and find out about what sorts of operations the server supports, and all of this can be done without requiring the client to know anything about the directory structures hosted on the server. All it must do is perform a search with an empty DN.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note465465e"/>Note</h3><p>The LDAPv3 Directory Information Models specification (RFC 4512) states that a root DSE with an empty DN be provided by any standards-compliant LDAP server.</p></div></div><p>The root DSE contains information about what version of the LDAP protocol the server supports, what extensions to that protocol the server supports, and other useful information that helps clients fruitfully interact with the directory.</p><p>We will search for this entry using the <code class="literal">ldapsearch</code> command-line client.</p><p>Because of the restrictive way in which we set up our ACLs, we will have to authenticate to the directory in order to see the root DSE. And since we have only one defined user, the directory manager, we will log in as that user and perform a search for the root DSE:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ ldapsearch -x -W -D 'cn=Manager,dc=example,dc=com' -b "" -s base</strong></span>
</pre></div><p>All of the above should go on one line at a shell prompt. In order to do the search, we must specify several different parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">-x</code>: This tells the server to use simple authentication (instead of the more complicated, but more secure, SASL authentication).</li><li class="listitem" style="list-style-type: disc"><code class="literal">-W</code>: This tells the client to prompt us for an interactive password. The client will give the following prompt:<div class="informalexample"><pre class="programlisting">   Enter LDAP Password:<a class="indexterm" id="id87"/>
</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">-D 'cn=Manager</code>,<code class="literal">dc=example</code>,<code class="literal">dc=com'</code>: This specifies the DN that we want to use to connect to the directory. In this case, we are using the directory manager account.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-b ""</code>: This sets the base DN for the search. In the <code class="literal">ldap.conf</code> file we set the default base to be <code class="literal">dc=example,dc=com</code>. But to get the root DSE, which is not under <code class="literal">dc=example,dc=com</code>, we need to specify an empty search base.</li><li class="listitem" style="list-style-type: disc"><code class="literal">-s base</code>: This indicates that we want to search for just one (base) entry—the entry with the DN specified in the <code class="literal">-b</code> parameter (the empty DN of the root DSE).</li></ul></div><p>When we run this search, this is the result returned from the server:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  # extended LDIF</strong></span>
<span class="strong"><strong>  #</strong></span>
<span class="strong"><strong>  # LDAPv3</strong></span>
<span class="strong"><strong>  # base &lt;&gt; with scope baseObject</strong></span>
<span class="strong"><strong>  # filter: (objectclass=*)</strong></span>
<span class="strong"><strong>  # requesting: ALL</strong></span>
<span class="strong"><strong>  #</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  #</strong></span>
<span class="strong"><strong>  dn:</strong></span>
<span class="strong"><strong>  objectClass: top</strong></span>
<span class="strong"><strong>  objectClass: OpenLDAProotDSE</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  # search result</strong></span>
<span class="strong"><strong>  search: 2</strong></span>
<span class="strong"><strong>  result: 0 Success</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>  # numResponses: 2</strong></span>
<span class="strong"><strong>  # numEntries: 1</strong></span>
</pre></div><p>At the top of the result is a summary of how the search was processed. The highlighted portion shows the root DSE entry. The server returned three attributes: the <code class="literal">dn</code> (which is empty) and two object class specifications.</p><p>The last section, beneath the highlighted section, displays a summary, including how many records were returned (two: the DSE entry and the summary) and the error code (<code class="literal">0</code> for success).</p><p>This record is sparse, containing only a few attributes. And it doesn't give us much information about the directory's configuration or capabilities. But the root DSE contains much more information than appears here. How to we get at that information?</p><p>To get more extensive information out of the root DSE, we need to query for all of the <span class="strong"><strong>operational attributes</strong></span> for the record.<a class="indexterm" id="id88"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note1131121212121"/>Note</h3><p>Operational attributes, as explained in Chapter 1, are attributes that are intended for internal use. RFC 4512 states that many of the root DSE's attributes be treated as operational attributes.</p></div></div><p>Here's a modified version of the search that adds a filter for any object class <code class="literal">'(objectclass=*)'</code>, and a request for all operational attributes (<code class="literal">+</code>). Since we are using the asterisk character (<code class="literal">*</code>) in the filter, the filter must be enclosed in single quotes to avoid shell expansion:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ ldapsearch -x -W -D 'cn=Manager,dc=example,dc=com' -b "" -s base \</strong></span>
<span class="strong"><strong>      '(objectclass=*)' +</strong></span>
</pre></div><p>The output of this command looks something like this:</p><div class="informalexample"><pre class="programlisting">  Enter LDAP Password: 
  # extended LDIF
  #
  # LDAPv3
  # base &lt;&gt; with scope baseObject
  # filter: (objectclass=*)
  # requesting: + 
  #
  #
  dn:
  structuralObjectClass: OpenLDAProotDSE
  configContext: cn=config
  namingContexts: dc=example,dc=com
  supportedControl: 1.3.6.1.4.1.4203.1.9.1.1
  supportedControl: 2.16.840.1.113730.3.4.18
  supportedControl: 2.16.840.1.113730.3.4.2
  supportedControl: 1.3.6.1.4.1.4203.1.10.1
  supportedControl: 1.2.840.113556.1.4.319
  supportedControl: 1.2.826.0.1.334810.2.3
  supportedControl: 1.2.826.0.1.3344810.2.3
  supportedControl: 1.3.6.1.1.13.2
  supportedControl: 1.3.6.1.1.13.1
  supportedControl: 1.3.6.1.1.12
  supportedExtension: 1.3.6.1.4.1.4203.1.11.1
  supportedExtension: 1.3.6.1.4.1.4203.1.11.3
  supportedFeatures: 1.3.6.1.1.14
  supportedFeatures: 1.3.6.1.4.1.4203.1.5.1
  supportedFeatures: 1.3.6.1.4.1.4203.1.5.2
  supportedFeatures: 1.3.6.1.4.1.4203.1.5.3
  supportedFeatures: 1.3.6.1.4.1.4203.1.5.4
  supportedFeatures: 1.3.6.1.4.1.4203.1.5.5
  supportedLDAPVersion: 3
  supportedSASLMechanisms: NTLM
  supportedSASLMechanisms: DIGEST-MD5
  supportedSASLMechanisms: CRAM-MD5
  entryDN:
  subschemaSubentry: cn=Subschema
  <a class="indexterm" id="id89"/>
  # search result
  search: 2
  result: 0 Success
  <a class="indexterm" id="id90"/>
  # numResponses: 2
  # numEntries: 1</pre></div><p>Again the results above are for the same record—the root DSE record. Only now we get a much bigger record, containing all of the operational attributes for the record.</p><p>The information returned from the server this time includes lists of supported features, extensions, controls, and SASL mechanisms (most of which are not particularly human-friendly).</p><p>While many of the items in this record are not useful to us right now, some can be very useful in practice. For example, the supportedLDAPVersion attribute indicates what version of the LDAP protocol this server uses. The namingContexts attribute gives the base DN for each directory information tree hosted on this server. The supportedSASLMechanisms list tells us what sort of authentication routines can be performed when doing a SASL bind (which we will look at in detail in Chapter 4).</p><p>Some LDAP client programs will even query the root DSE and use this information to determine what kinds of operations the server will support, adjusting the client's own features to the level of service provided by the server.</p><p>What is most important about this exercise though, is that we have verified that we have successfully configured the SLAPD server, as well as the OpenLDAP clients. We have connected, authenticated (using a simple bind), and retrieved a record from the LDAP server.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Summary</h1></div></div></div><p>The focus of this chapter has been on installing and configuring the OpenLDAP suite of tools. We installed OpenLDAP on an Ubuntu system, and then walked through the process of authoring a <code class="literal">slapd.conf</code> file. Once we had created and tested <code class="literal">slapd.conf</code>, we turned to the <code class="literal">ldap.conf</code> file, which contains settings and defaults used by the OpenLDAP clients. Finally, we used <code class="literal">ldapsearch</code> to request the root DSE record from the directory, verifying that we had both the client and the server configured.</p><p>In the next chapter, we will walk through the OpenLDAP utilities and client applications. In the process of doing this we will add some records to our directory.</p></div></body></html>