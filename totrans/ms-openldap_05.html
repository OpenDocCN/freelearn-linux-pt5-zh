<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Advanced Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Advanced Configuration</h1></div></div></div><p>In the last chapter, we looked at securing our OpenLDAP server with SSL/TLS, simple and SASL authentication, and ACL-based authorization rules. All of these measures were implemented through configuration files for SLAPD. In this chapter, we will look at some other advanced features of SLAPD, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring multiple database backends</li><li class="listitem" style="list-style-type: disc">Tuning directory performance</li><li class="listitem" style="list-style-type: disc">Working with directory overlays</li><li class="listitem" style="list-style-type: disc">Adding integrity checks</li><li class="listitem" style="list-style-type: disc">Adding uniqueness constraints</li></ul></div><div class="section" title="Multiple Database Backends"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Multiple Database Backends</h1></div></div></div><a class="indexterm" id="id440"/><p>As we have worked on OpenLDAP so far we have been using only one directory tree (<code class="literal">dc=example,dc=com</code>) and one backend database (an HDB database configured in <code class="literal">slapd.conf</code>). This works well for most of the small directory servers. It is simple to configure and all of the data is stored in the same place.</p><p>But there are a number of more complex-use cases where it makes sense to have one directory server that handles multiple directory trees, where each tree is stored in its own backend database. Here are some situations in which this sort of configuration might make sense:<a class="indexterm" id="id441"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One directory server hosts the directory information trees for multiple organizations </li><li class="listitem" style="list-style-type: disc">One large directory server is broken up into multiple smaller trees and subtrees for performance and replication reasons</li><li class="listitem" style="list-style-type: disc">Two or more previously existing directory information trees are being gradually consolidated (as in the case of a corporate merger)</li></ul></div><p>Of course, there are other scenarios that might require an LDAP server with multiple backends. These are just a few examples of common situations.</p><p>How does a SLAPD with multiple backends works? Let's examine a simple example. Say we have two directory information trees, the <code class="literal">dc=example,dc=com</code> tree that we have used in previous chapters, and <code class="literal">dc=demo,dc=net</code>.</p><p>We want to host both of these on the same SLAPD server. But we don't want the data for <code class="literal">dc=example,dc=com</code> to be stored in the same database files as <code class="literal">dc=demo,dc=net</code> (that could present problems later on if we ever had to split up the databases). And, of course, we don't want searches for records in one directory tree to return entries from the other.</p><p>Configuring a new database is primarily a matter of defining the new database in <code class="literal">slapd.conf</code>. After that is done we just need to create some data and load it into the new database.<a class="indexterm" id="id442"/>
</p><div class="section" title="The slapd.conf File"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>The slapd.conf File</h2></div></div></div><a class="indexterm" id="id443"/><a class="indexterm" id="id444"/><a class="indexterm" id="id445"/><a class="indexterm" id="id446"/><p>We created the <code class="literal">slapd.conf</code> file in Chapter 2. In previous chapters we have modified small sections of <code class="literal">slapd.conf</code>, but now we are going to step back and take a look at the overall structure of the <code class="literal">slapd.conf</code> file.</p><p>As mentioned in Chapter 2, the <code class="literal">slapd.conf</code> file can be broken into component pieces. Initially we created three sections, which we called <span class="emphasis"><em>Basics</em></span>, <span class="emphasis"><em>Database</em></span>, and<span class="emphasis"><em>ACLs</em></span>. In the last chapter we looked extensively at ACLs, as well as the security directives which (for the most part) are defined in the first, <span class="emphasis"><em>Basics</em></span> section. Let's see how the structure of our <code class="literal">slapd.conf</code> file looks:<a class="indexterm" id="id447"/>
</p><div class="mediaobject"><img alt="The slapd.conf File" src="graphics/1021_05_01.jpg"/></div><p>Now it is time to refine the model a little bit. The <span class="emphasis"><em>Basics</em></span> section contains global configuration parameters. That is, the parameters defined there are effective for the entire SLAPD server, regardless of how many database backends it has.</p><a class="indexterm" id="id448"/><p>The<a class="indexterm" id="id449"/> <span class="emphasis"><em>Database</em></span> section contains directives that pertain to a specific database backend, where each backend often hosts only one directory information tree. Parameters in this section define which backend (such as BDB, HDB, LDIF, SQL) is used, what the specific parameters and overlays are for that backend, which DN will be the manager for that database, and so on. There can be multiple <span class="emphasis"><em>Database</em></span> sections in one <code class="literal">slapd.conf</code> file. In fact, configuring multiple database sections is how we accomplish hosting multiple database backends on one SLAPD server.</p><a class="indexterm" id="id450"/><p>Finally, the <span class="emphasis"><em>ACL</em></span> section is really a subsection of the <span class="emphasis"><em>Database</em></span> section (though, as we saw in the last chapter, ACLs can be used at the global level, as well). Each database can have its own set of access controls. So a more accurate picture of the <code class="literal">slapd.conf</code> file would look more like this:</p><div class="mediaobject"><img alt="The slapd.conf File" src="graphics/1021_05_02.jpg"/></div><p>This figure is more representative of how the <code class="literal">slapd.conf</code> file is composed. The previous example shows two separate databases (though the number of databases is certainly not limited to two), each of which has its own directives, and its own ACLs.</p><p>While global ACLs are mentioned in the <span class="emphasis"><em>Basic</em></span> <span class="emphasis"><em>Configuration</em></span> section, they are not visually separated into their own section in part because their role there is not as significant as the use of ACLs in the context of a backend. Global ACLs should be used primarily to protect the root DSE, <code class="literal">cn=Config</code>, and <code class="literal">cn=Subschema</code> portions of the tree (see <a class="link" href="apc.html" title="Appendix C. Useful LDAP Commands">Appendix C</a>), but not much more. Most ACLs should be placed in the appropriate <span class="emphasis"><em>Database</em></span> <span class="emphasis"><em>Configuration</em></span> section.</p><p>Now we are ready to turn to the configuration file itself and see how the previous diagram is put into practice.</p><p>A basic multiple database setup can be done easily by adding just over a dozen lines to our <code class="literal">slapd.conf</code> file. We will begin with the existing backend configuration that we created in Chapter 2 and add a new database backend beneath it:</p><div class="informalexample"><pre class="programlisting">##############################
# BDB Database Configuration #
##############################
# Database 1: Example.Com

database        hdb
suffix          "dc=example,dc=com" "o=My Company,c=US"
rootdn          "cn=Manager,dc=example,dc=com"
rootpw          secret
directory      /var/lib/ldap
#directory       /usr/local/var/openldap-data
index   objectClass     eq
index   cn      eq,sub,pres,approx
index   uid     eq,sub,pres

########
# ACLs #
########
include /etc/ldap/acl.conf

##############################
# Database 2:  Demo.Net

database        hdb
suffix          "dc=demo,dc=net"
rootdn          "cn=Manager,dc=demo,dc=net"
rootpw          secret
directory      /var/lib/ldap/demo.net
#directory       /usr/local/var/openldap-data/demo.net
index   objectClass     eq
index   cn      eq,sub,pres,approx
index   uid     eq,sub,pres

########
# ACLs #
########
access to attrs=userPassword
        by anonymous auth
        by self write

access to dn.sub="dc=demo,dc=net" by users read</pre></div><p>We have just configured two databases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">Example.Com</code> directory is handled by the first database</li><li class="listitem" style="list-style-type: disc">The <code class="literal">Demo.Net</code> directory is handled by the second database</li></ul></div><p>There are a few important things to note about this configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each directory has a separate manager account. This is useful when each directory is managed by a different individual or group.</li><li class="listitem" style="list-style-type: disc">The directory for the second database is different than that of the first. Remember that the directory is the location where the database files are stored. Each backend must have its own storage directory.</li><li class="listitem" style="list-style-type: disc">As we discussed earlier, each database section can (and should) have its own ACLs and a different set of ACLs can be specified for each database defined in <code class="literal">slapd.conf</code>. The ACLs in the previous example are minimal.</li></ul></div></div><div class="section" title="Creating and Importing a Second Directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Creating and Importing a Second Directory</h2></div></div></div><p>Before<a class="indexterm" id="id451"/>
<a class="indexterm" id="id452"/> we can import data, we need to create the location where the data will be stored. In the <code class="literal">slapd.conf</code> file fragment, the <code class="literal">directory</code> directive points to <code class="literal">/var/lib/ldap/demo.net</code>. However, this directory does not yet exist. We need to create it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ sudo mkdir /var/lib/ldap/demo.net</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note73"/>Note</h3><p>If SLAPD is run as a user other than <code class="literal">root</code>, make sure to change the ownership on the <code class="literal">demo.net/</code> directory. The SLAPD user ought to own the directory. For example, if the user <code class="literal">ldap</code> runs <code class="literal">slapd</code>, do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>chown ldap /var/lib/ldap/demo.net</strong></span>
</pre></div></div></div><p>Next, we need to create an LDIF file that contains the basic records for our new directory. In Chapter 3, we created an LDIF file with the main tree structures for the <code class="literal">dc=example,dc=com</code> directory information tree. Here we will create just a minimal directory structure in a file called <code class="literal">demo.net.ldif</code>:</p><div class="informalexample"><pre class="programlisting"># This is the root of the directory tree
dn: dc=demo,dc=net
description: Demo.Net
dc: demo
o: Demo.Net
objectClass: top
objectClass: dcObject
objectClass: organization
# Subtree for users
dn: ou=Users,dc=demo,dc=net
ou: Users
description: Demo.Net Users
objectClass: organizationalUnit

# George Berkeley
dn: uid=george,ou=Users,dc=demo,dc=net
ou: Users
uid: george
sn: Berkeley
cn: George Berkeley
givenName: George
displayName: George Berkeley
mail: george@demo.net
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>This file creates the top-level entry—a single subtree branch (for users) and a single user.</p><p>Now that we have an LDIF file, we can import it with <code class="literal">slapadd</code>. If you have not already done so, stop SLAPD while running <code class="literal">slapadd</code>. We run the following command to import:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>  $ sudo slapadd -b 'dc=demo,dc=net' -l demo.net.ldif</strong></span></pre></div><p>By default, <code class="literal">slapadd</code> tries to import the data into the first directory specified in <code class="literal">slapd.conf</code>. However, in our case we want the data to be stored in the second directory. Thus, in the previous example, we used the <code class="literal">-b</code> flag to specify the base DN of the second directory. Instead of doing <code class="literal">-b</code> <code class="literal">'dc=demo,dc=net'</code>, we could have done <code class="literal">-n</code> <code class="literal">2</code>, which instructs<a class="indexterm" id="id453"/> <code class="literal">slapadd</code> to put the records in database two.</p><p>Now we have a second database with a handful of entries. We can start up the server and test it with <code class="literal">ldapsearch</code>:</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>$ ldapsearch -LLL -x -W -D 'cn=Manager,dc=demo,dc=net' -b \ </strong></span><a class="indexterm" id="id454"/>
               <span class="strong"><strong>'dc=demo,dc=net' '(objectclass=*)' description</strong></span></pre></div><p>This is what we will get:</p><div class="informalexample"><pre class="programlisting">Enter LDAP Password: 
  
dn: dc=demo,dc=net
description: Demo.Net
dn: ou=Users,dc=demo,dc=net
description: Demo.Net Users
  
dn: uid=george,ou=Users,dc=demo,dc=net</pre></div><p>Binding to the <code class="literal">dc=demo,dc=net</code> directory tree as the manager of that directory, we can verify that the three records we added exist. Note that only the description attribute is to be returned. That is why only <code class="literal">dn</code> and <code class="literal">description</code> are displayed.</p><p>No ACLs are in place in the <code class="literal">demo.net</code> portion of <code class="literal">slapd.conf</code> that would prevent users of the <code class="literal">example.com</code> database from seeing information in the <code class="literal">demo.net</code> directory. For example, the user <code class="literal">uid=matt,ou=users,dc=example,dc=com</code> can retrieve information from the <code class="literal">demo.net</code> directory:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>  $ ldapsearch -LLL -U matt -b 'dc=demo,dc=net' '(uid=george)' mail</strong></span></pre></div><p>This is the output:</p><div class="informalexample"><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
  
dn: uid=george,ou=Users,dc=demo,dc=net
mail: george@demo.net</pre></div><p>If we want to prevent this behavior, we can do so with ACLs. For example, we could replace the rule that reads <code class="literal">access</code> <code class="literal">to</code> <code class="literal">dn</code>.<code class="literal">sub="dc=demo,dc=net"</code> <code class="literal">by</code> <code class="literal">users</code> <code class="literal">read</code> to a rule that restricts reading to entries within the <code class="literal">dc=demo,dc=net</code> tree:</p><div class="informalexample"><pre class="programlisting">access to dn.sub="dc=demo,dc=net"
       by dn.sub="dc=demo,dc=net" read</pre></div><p>This<a class="indexterm" id="id455"/> <a class="indexterm" id="id456"/> would deny entries outside of the <code class="literal">dc=demo,dc=net</code> tree from accessing these records. A similar rule would have to be added to the ACLs in the <code class="literal">dc=example,dc=com</code> section to block access from users in the <code class="literal">dc=demo,dc=net</code> tree.</p><p>Now we have a directory with two different databases. In later parts of this book, we will examine other aspects of using multiple databases. For example, later in this chapter we will look at using the <code class="literal">glue</code> overlay to connect two databases together in one search. In Chapter 7 we will look at doing replication with multiple databases. But next we will look at some performance tuning options for SLAPD.</p></div></div></div>
<div class="section" title="Performance Tuning"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Performance Tuning</h1></div></div></div><p>In<a class="indexterm" id="id457"/>
<a class="indexterm" id="id458"/> Chapter 2 we created a basic <code class="literal">slapd.conf</code> file. Our focus there, though, was on getting a basic server running. In the last chapter, we took a close look at the directives that had to do with security. While creating a second database backend just now, we took a higher-level look at the <code class="literal">slapd.conf</code> file.</p><p>In this part, we will continue working on <code class="literal">slapd.conf</code>, but here we will focus on parameters that help you tailor the server to the performance needs of your organization. Later in this part we will look at the <code class="literal">DB_CONFIG</code> file that the Berkeley DB backends (BDB and HDB) use. The optimizations made in that file can lead to significant performance improvements in OpenLDAP.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip32"/>Tip</h3><p>
<span class="strong"><strong>Terminology: Databases and Backends</strong></span>
</p><p>The distinction between databases and backends is a fine-grained one, and often the terms are used interchangeably. Here is the difference.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>database</strong></span> is a location (a file, a relational database, a network resource) where a directory information tree is stored.</li><li class="listitem" style="list-style-type: disc">A <span class="strong"><strong>backend</strong></span> is a particular mechanism that is used to store databases (or, in some cases, to direct SLAPD to a remote database). Backends are coded as modules, which means they can be loaded dynamically at startup.</li></ul></div></div></div><div class="section" title="Performance Directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Performance Directives</h2></div></div></div><p>We<a class="indexterm" id="id459"/>
<a class="indexterm" id="id460"/> have already created a <code class="literal">slapd.conf</code> file that SLAPD uses for managing the directory server. We will continue building on this configuration file as we look at the next batch of directives.</p><p>We will break the directives into two different classes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Those that are global, and should be placed in the basic configuration section at the top of the <code class="literal">slapd.conf</code> file</li><li class="listitem" style="list-style-type: disc">Those that apply only to individual database backends</li></ul></div><p>Of those that apply to database backends, some are available to all backend types (such as BDB, SQL, Shell, LDIF, and so on), and there are some that apply only to a specific backend type. Since we are using an HDB backend (the default), we will focus on directives that can be used by that backend.</p><div class="section" title="Global Directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec62"/>Global Directives</h3></div></div></div><p>The<a class="indexterm" id="id461"/>
<a class="indexterm" id="id462"/> global directives must be placed at the top part of the <code class="literal">slapd.conf</code> file, before any database sections are defined. These directives apply to the entire SLAPD server, not just a particular directory information tree within that server.</p><p>The first three directives we will see are used to optimize the interaction between the client and the LDAP server. These directives are the <code class="literal">timelimit</code>, <code class="literal">sizelimit</code>, and <code class="literal">idletimeout</code> directives. After that, we will look at the <code class="literal">threads</code> directive, which is used to tune SLAPD's threading.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>Fine-grained limits on size and time can be set per-database using the <code class="literal">limit</code> directive, discussed later in this section. For example, this directive can be used to set time and size limits based per user or group.</p></div></div><div class="section" title="Time Limits"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec38"/>Time Limits</h4></div></div></div><p>The<a class="indexterm" id="id463"/> <code class="literal">timelimit</code> directive is used to specify the maximum amount of time SLAPD will work on a particular operation before stopping the operation and returning a message to the client.</p><p>Some operations, like searching a large directory for an attribute that is not indexed, can take a long time. Other times, clients connecting over slow network links and requesting large amounts of data can also take up significant time. Such lengthy searches can slow the entire server down, and on a busy server it can also prevent other clients from connecting and getting timely responses. And, of course, not all client applications deal well with lengthy waiting periods.</p><p>In order to avoid these problems, there is a <code class="literal">timelimit</code> directive, which gives you the ability to set the maximum amount of time the server will wait for an operation to complete before ending the operation and returning a message to the client.</p><p>The default time limit is 3600 seconds. In this example, we will lower it to only five minutes:</p><div class="informalexample"><pre class="programlisting">timelimit 300</pre></div><p>Remember, this directive is a <span class="emphasis"><em>global</em></span> directive, and must be placed in the configuration file before any <code class="literal">database</code> directives.</p><p>Sometimes it is useful to eliminate all time limits. This does have the disadvantage of allowing a connection to occupy resources for an unspecified amount of time and, if too many connections did this, the result would be lengthy delays (and perhaps, in extreme cases, denial of service) for clients. But, in controlled environments, this might be a risk that can be taken. To turn off time limits use the keyword <code class="literal">unlimited</code>:</p><div class="informalexample"><pre class="programlisting">timelimit unlimited</pre></div><p>With this setting the server will not return a message to the client until the operation is complete.</p><p>These examples represent the basic use of time limits, but sometimes a more sophisticated time limit configuration is desirable. The OpenLDAP developers created a more advanced form of the <code class="literal">timelimit</code> directive to handle such complex time limit settings. In this form, the <code class="literal">timelimit</code> directive can set two different sorts of time limits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Soft limit</strong></span>: The<a class="indexterm" id="id464"/> soft limit is the default time limit that the server uses if the client does not include a desired time limit in its request.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hard limit</strong></span>: The<a class="indexterm" id="id465"/> hard limit is the absolute longest time that the server will spend processing a request.</li></ul></div><p>Understanding this difference will help to know how the client and the server handle timing issues.</p><p>When a client connects to the directory and performs a search, it might send its own time limit request, which instructs the server to take no longer than that amount of time to do the search. For example, if a client sends a time limit of 30 seconds, it will expect the server to take no longer than 30 seconds to respond. If the server's hard time limit is higher than the time limit sent by the client, then the server will set the limit for that request to the client's requested time limit. However, if the server's hard limit is lower than the client's then it will use its own hard limit for that request.</p><p>So, if the server's hard time limit is 60 seconds, and the client requests a 30 second time limit, the server will use the 30 second limit. If, however, the server's hard time limit is 10 seconds and the client requests a 30 second limit, the server will use its hard 10-second limit, since it is lower.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>
<span class="strong"><strong>Setting the Client Time Limit</strong></span>
</p><p>For<a class="indexterm" id="id466"/> OpenLDAP clients like <code class="literal">ldapsearch</code>, you can set the client time limit by editing <code class="literal">ldap.conf</code> (or your <code class="literal">.ldaprc</code> file) and adding the <code class="literal">TIMELIMIT</code> directive. In the <code class="literal">ldap.conf</code> file, <code class="literal">TIMELIMIT</code> takes only one parameter: time limit in seconds. For example, to set the time limit to 30 seconds: <code class="literal">TIMELIMIT</code> <code class="literal">30</code>.</p></div></div><p>Where does the soft limit come in? The client does not always supply a time limit and, in these cases, you may want to set a limit that is lower than the hard limit. That is, if the default hard limit is an hour, that may be a perfectly legitimate limit to set as a maximum limit, but a default of a minute or two is a better limit for those clients that don't need the longer limit.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>If you set a soft limit higher than the hard limit, the hard limit will be used.</p></div></div><p>Now we can look at the expanded form of the <code class="literal">timelimit</code> directive to see an example of setting the hard and soft limits. Typically, both are set in the same command (though you can set one without setting the other):</p><div class="informalexample"><pre class="programlisting">timelimit time.soft=30 time.hard=300</pre></div><p>In this example the soft time limit is 30 seconds, while the hard time limit is 300 seconds. This allows clients that request longer limits to get longer processing time, while setting a lower default for clients that do not provide time limits when making requests.</p><p>What does the client get if the time limit is reached? The server will return as much of the processing as it could complete, but it will also include a warning that the time limit was exceeded.</p><p>Note that on a busy server a request may get queued, but not actually be executed until a thread becomes available to do the processing. In such cases, the time that the request waits for a thread is not counted against the time limit. The timer for the time limit begins when the worker thread begins processing the request, not when the server receives the request.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>The backend-specific limits directive discussed later in this chapter provides fine-grained time and size-limit support. For example, you can set time limits on particular users or group members.</p></div></div></div><div class="section" title="Idle Timeouts"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec39"/>Idle Timeouts</h4></div></div></div><a class="indexterm" id="id467"/><p>Along with limiting the amount of time SLAPD spends processing a request you can also limit how long SLAPD should allow a client to remain connected, but idle. A connection is idle if it is connected to SLAPD but is not performing any operations. For example, a client may connect to SLAPD, perform a bind, and then keep the connection open, perhaps waiting for input from a user.</p><p>In many cases, there is no harm in allowing clients to remain connected, but idle. Idle clients do not require attention by one of the server's threads, so they do not use up valuable resources. Because of this, the default behavior of the server is to simply allow idle connections to remain connected indefinitely.</p><p>But on occasion (sometimes because of limitations in another part of the system), it is desirable to prevent clients from connecting and remaining idle. Use the <code class="literal">idletimeout</code> directive to set a timeout. Like the simple form of <code class="literal">timelimit</code>, <code class="literal">idletimeout</code> takes just one argument, the number of seconds a connection can be idle before SLAPD closes the connection:</p><div class="informalexample"><pre class="programlisting">idletimeout 3600</pre></div></div><div class="section" title="Size Limits"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec40"/>Size Limits</h4></div></div></div><a class="indexterm" id="id468"/><p>Along with setting limits on the amount of time that an operation can take, it is also possible to set limits on the number of records a search operation can return. Clients can easily perform broad searches that will return many records. Without a size limit in place a search with the filter <code class="literal">(objectclass=*)</code> would, if not restricted by ACLs, return every record in the search base. And if such a search was performed on a database that held millions of records, SLAPD would send all of those records back to the client.</p><p>In most cases it makes sense to set an upper limit on the number of records that can be returned in any one search. By default, SLAPD will only return the first 500 records. But that number can be changed with the <code class="literal">sizelimit</code> directive.</p><p>In its simple form the <code class="literal">sizelimit</code> directive takes only one parameter, the maximum number of records to return:</p><div class="informalexample"><pre class="programlisting">sizelimit 1000</pre></div><p>As with <code class="literal">timelimit</code> though, there is an expanded form of the <code class="literal">sizelimit</code> directive, and like <code class="literal">timelimit</code>, <code class="literal">sizelimit</code> has both soft and hard limits. The expanded <code class="literal">sizelimit</code> directive also has a third property that can be set, and this property is called <code class="literal">unchecked</code>.</p><p>Hard and soft limits function similarly in <code class="literal">sizelimit</code> as they do in <code class="literal">timelimit</code>. The hard limit determines the maximum number of search results that will be returned in any search. Just as is the case with time limits, clients can also send information telling the server the maximum number of entries the client wants back. If no such information is set the value of the soft limit will be used.</p><a class="indexterm" id="id469"/><p>If the server finds more records than the <code class="literal">sizelimit</code> allows, it will return the maximum number of records as well as an error message: <code class="literal">Size limit exceeded</code>.</p><p>The <code class="literal">unchecked</code> condition is a little bit more complex. In cases where a search requests matches for an attribute that is not indexed, SLAPD may find a large number of records that it needs to test to see if they match the client's filter. Sometimes the number of candidate records is quite large. The <code class="literal">unchecked</code> property can be used to set a limit on the maximum number of records that can be selected as candidates for matching. This can prevent poorly-tuned databases from consuming lots of time and resources searching through huge potential records for those that match.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>Indexing attributes that are commonly searched is the best way to avoid this situation. Indexing is discussed later in this chapter.</p></div></div><p>If a client's request produces more candidates than allowed by the unchecked property, the server will return an error (<code class="literal">Administrative limit exceeded</code>) and will not do the search at all.</p><p>The <code class="literal">unchecked</code> property will keep the server from spending too much time on such tasks, but at the expense of the client's ability to run queries against the database. Perfectly legitimate searches can be blocked this way. For that reason, the <code class="literal">unchecked</code> property should be used with care. The default is to not limit the number of candidates. This is equivalent to specifying <code class="literal">size.unchecked=unlimited</code>.</p><p>Here's an example of setting all three in one directive:</p><div class="informalexample"><pre class="programlisting">sizelimit size.soft=500 size.hard=1000 size.unchecked=2000</pre></div><p>In this example, the soft size limit is set to 500, while the hard limit is set to 1000, and the maximum number of unchecked records to be analyzed is 2000. Note that the unchecked size limit should, as a matter of practice, be set to a value larger than the hard limit.</p></div><div class="section" title="Threads"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec41"/>Threads</h4></div></div></div><a class="indexterm" id="id470"/><p>The last few directives have dealt with setting limits on the server's performing requested operations. These can prove valuable ways of preventing resources from being wasted or misused. Now however, I want to turn to a directive that governs the server's ability to handle requests.</p><p>SLAPD is a multi-threaded application. Unlike other servers, SLAPD does not start subprocesses to handle searching. Instead, the SLAPD server is a single process that has many different threads executing concurrently within that processes.</p><p>Each thread can perform its own task. So, if a server has sixteen threads (the default for OpenLDAP's SLAPD server), then it can perform sixteen different tasks at the same time. Roughly speaking, threads perform operations. A single client can make a single connection, and then request several different operations, each of which may be done by a different thread (although no more than half of the total threads will be dedicated to a single client).</p><p>Sixteen threads, the default, is excessive. Recent performance testing has shown that running a busy server at eight threads performs better than running sixteen, even at high loads. Why? The answer, in a nutshell, is that more threads introduce more competition for the same resources. SLAPD is efficient enough that delegating work to a smaller thread pool is typically faster than using a large thread pool, and incurring thread scheduling overhead.</p><p>Lowering the thread count has additional benefits. It is estimated that each thread costs at least 13MB (and perhaps quite a bit more, depending on the configuration of SLAPD and the hardware on the machine). Enterprise LDAP directories can certainly handle this sort of overhead, but on a host that runs LDAP along with many other services, reducing the number of threads might boost the server's performance in other areas, and still perform at the same speeds (or better) as it would when running sixteen threads.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>In future versions of OpenLDAP, the default thread count will very likely be reduced from sixteen to eight.</p></div></div><p>The <code class="literal">threads</code> directive is used to set the maximum number of threads that SLAPD will create. It takes an integer:</p><div class="informalexample"><pre class="programlisting">threads 8</pre></div><p>In typical OpenLDAP configurations, this setting is optimal, though small servers with little traffic may benefit by dropping the thread pool to as low as four.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>
<span class="strong"><strong>Proxies and Threads</strong></span>
</p><p>If you are running busy SLAPD proxy server (with a <code class="literal">proxy</code> or <code class="literal">ldap</code> backend, covered in Chapter 7) that queries remote directory servers, you may benefit by having much larger thread pools. Since the worker thread is occupied until the remote LDAP server responds, a thread can remain occupied for long periods of time. In order to keep clients from being denied service you may want to add threads.</p></div></div><p>Note that the lowest number of threads allowed is 2. This is the minimum number of threads OpenLDAP needs to provide basic service.</p></div></div><div class="section" title="Directives in the Database Section"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec63"/>Directives in the Database Section</h3></div></div></div><a class="indexterm" id="id471"/><p>Some directives go in the database section instead of the main portion of the configuration file. And of these, some database directives are specific to the particular backend being used. Along with the backend-neutral directives, we will see a few directives that can be used in BDB/HDB backends.</p><div class="section" title="Limits"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec42"/>Limits</h4></div></div></div><p>We looked at the <code class="literal">sizelimit</code> and <code class="literal">timelimit</code> directives, both of which are used in the global section. But in the Database section, there is another directive used for setting limits, and this directive provides finer-grained control over who is limited. You can, for example, set lower or higher limits for individual DNs, subtrees, or for members of a group. The directive for doing these things is the <code class="literal">limit</code> directive.</p><p>A <code class="literal">limit</code> directive is similar to an ACL. It has three parts: the directive itself, the who-phrase, and one or more limit-phrases. Here's an example:</p><div class="informalexample"><pre class="programlisting">limits users size=20</pre></div><p>This directive sets a limit for all authenticated users (using the <code class="literal">users</code> keyword). Only twenty records will be returned before SLAPD will return the message: <code class="literal">Size limit exceeded</code>.</p><p>The <code class="literal">limit</code> directive supports two limit-phrases: <code class="literal">size</code> and <code class="literal">time</code>. As with the <code class="literal">sizelimit</code> directive discussed above, <code class="literal">size</code> can use the <code class="literal">soft</code>, <code class="literal">hard</code>, and <code class="literal">unchecked</code> styles. Similarly, <code class="literal">time</code> can use the <code class="literal">soft</code> and <code class="literal">hard</code> styles. Since more than one limit-phrase can be used, we can create a more robust set of limits. Here's an example limiting the anonymous user to only short result sets, and only if the operation can be done quickly:</p><div class="informalexample"><pre class="programlisting">limits anonymous 
  size.soft=5 size.hard=15 size.unchecked=100 
  time.soft=5 time.hard=30</pre></div><p>This sets all three size limits, as well as both time limits, for the anonymous user. This would keep the anonymous user from running lengthy searches.</p><p>As we have seen, the <code class="literal">anonymous</code> and <code class="literal">users</code> keywords can be used in the who-phrase. But just as in ACLs, the <code class="literal">dn</code> specifier, along with its modifiers (<code class="literal">exact</code>, <code class="literal">base</code>, <code class="literal">onelevel</code>, <code class="literal">subtree</code>, <code class="literal">children</code>, and <code class="literal">regex</code>) can also be used.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>The <code class="literal">dn</code> field and its modifiers were covered in detail in the section on <span class="emphasis"><em>Access Control Lists</em></span> in the previous chapter.<a class="indexterm" id="id472"/>
</p></div></div><p>Using the <code class="literal">dn</code> field we can create limits for particular DNs, DN patterns, or subtrees. For example, we can set a size limit for a particular user:</p><div class="informalexample"><pre class="programlisting">limits dn="uid=matt,ou=Users,dc=example,dc=com" size=50</pre></div><p>This will set the size limit to 50 for this particular user only. If this is the only limits statement, then SLAPD will apply the size limit set in <code class="literal">sizelimit</code> to all other DNs.</p><p>Similarly, we can set a size limit for all DNs in a subtree with a directive like this:</p><div class="informalexample"><pre class="programlisting">limits dn.sub="ou=Users,dc=example,dc=com" size=50</pre></div><p>The above limit will apply to <code class="literal">uid=matt,ou=Users,dc=example,dc=com</code> as well as all other users in that same branch of the directory information tree.</p><p>Finally, limits can also be set by group. In this case the limits will apply to any member of the group. As with ACLs, the limits directive's who-phrase uses the <code class="literal">group</code> field to indicate that SLAPD should base restrictions on group membership:</p><div class="informalexample"><pre class="programlisting">limits group="cn=Admins,ou=Groups,dc=example,dc=com" size=unlimited</pre></div><p>This directive sets the limit for members of the <code class="literal">Admins</code> group to <code class="literal">unlimited</code>, which means that no limiting will be enforced on these group members.</p><p>Just as with ACLs, only records with the object class <code class="literal">groupOfNames</code> are automatically considered to be groups. But other object classes function as groups, as well. For example, in Chapter 3 we created a group with the object class <code class="literal">groupOfUniqueNames</code>. That group's DN was <code class="literal">cn=LDAP</code> <code class="literal">Admins</code>, <code class="literal">ou=Groups,dc=example,dc=com</code>.</p><p>In order to use that record as a group we need to specify more information in the <code class="literal">limits</code> clause:</p><div class="informalexample"><pre class="programlisting">limits group/groupOfUniqueNames/uniqueMember="cn=LDAPAdmins,ou=Groups,dc=example,dc=com" size=unlimited</pre></div><p>When putting a directive, such as the given one into a <code class="literal">slapd.conf</code> file note that the entire group field (from <code class="literal">group</code> to the end of the DN) must be on one line.</p><p>This <code class="literal">limits</code> directive will allow search results of unlimited size for members of the group <code class="literal">cn=LDAP</code> <code class="literal">Admins</code>, <code class="literal">ou=Groups,dc=example,dc=com</code>. The group type explicitly indicates the object class of the record (<code class="literal">groupOfUniqueNames</code>) and the field that is to be treated as the membership field for that group (<code class="literal">uniqueMember</code>). Thus, when </p><p>SLAPD checks limits, it will look at the <code class="literal">LDAP</code> <code class="literal">Admins</code> record, check to see if it has the <code class="literal">groupOfUniqueNames</code> object class, and then evaluate whether the user who connected is listed in one of the <code class="literal">uniqueMember</code> values in the record. If so, then that user's size limit will be set to <code class="literal">unlimited</code>.</p></div><div class="section" title="Read-only and Restrict Directives"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec43"/>Read-only and Restrict Directives</h4></div></div></div><a class="indexterm" id="id473"/><a class="indexterm" id="id474"/><p>One way to improve performance on a busy server is to limit what clients can do on the server. For example, if the information in a directory is static (that is, no users ought to be able to change data), then it may be best to put the directory server into a read-only mode. Or perhaps limiting just specific operations (such as adding new records or deleting records) is sufficient.</p><p>There are two directives that can be placed in the <code class="literal">slapd.conf</code> file for achieving these results: <code class="literal">readonly</code> and <code class="literal">restrict</code>.</p><p>The <code class="literal">readonly</code> directive is simple. It is either <code class="literal">on</code> or <code class="literal">off</code>. By default it is <code class="literal">off</code>, so the directory allows writing operations (add, modify, delete, and so on). Here's how it is used to configure SLAPD as a read-only directory server:</p><div class="informalexample"><pre class="programlisting">readonly on</pre></div><p>When this directive is set, a client that attempts to modify information in the directory information tree will get an error message from the server:</p><div class="informalexample"><pre class="programlisting">  ldap_modify: Server is unwilling to perform (53)
  additional info: operation restricted</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>Not even the manager can perform modifications to the directory when <code class="literal">readonly</code> is turned on.</p></div></div><p>Binding, searching, and other operations that do not involve changing directory information can continue to function as normal though.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>Extended operations, such as the <span class="strong"><strong>Password Modify extended operation</strong></span>, are not affected by the <code class="literal">readonly</code> directive. For that reason the <code class="literal">ldappasswd</code> client, for example, will still change a password in the directory even if <code class="literal">readonly</code> is turned on.</p><p>To prevent this, use the <code class="literal">restrict</code> operation to restrict one or all extensions. The Password Modify extended operation is defined in RFC 3062 (<a class="ulink" href="http://www.ietf.org/rfc/rfc3062.txt">http://www.ietf.org/rfc/rfc3062.txt</a>).</p></div></div><p>Sometimes setting the server to read-only mode is too stringent. It may be desirable to just prevent certain operations. This can be accomplished with the <code class="literal">restrict</code> directive.</p><p>The <code class="literal">restrict</code> directive takes a list of one or more LDAP operations that should be disallowed. These are the operations that <code class="literal">restrict</code> understands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">add</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">bind</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">compare</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">delete</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">modify</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">rename</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">read</code> (a special pseudonym that prevents all reading operations like search, compare, and bind)</li><li class="listitem" style="list-style-type: disc"><code class="literal">search</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">write</code> (a special pseudonym that prevents all writing operations and is equivalent to setting <code class="literal">readonly</code> <code class="literal">on</code>)</li></ul></div><p>In addition to these nine, there is one special type for handling extension: <code class="literal">extended=&lt;OID&gt;</code>. In the extended type, <code class="literal">&lt;OID&gt;</code> should be replaced with the Object <a class="indexterm" id="id475"/>Identifier (OID) for the extended operation that you want to restrict.<a class="indexterm" id="id476"/>
</p><p>For example, we can prevent users from adding, renaming, and deleting entire entries with the following directive:</p><div class="informalexample"><pre class="programlisting">restrict add delete rename</pre></div><p>This will prevent a user from adding new entries, renaming existing entries (that is, changing the DN), or deleting entries. With the above configuration in the database section of <code class="literal">slapd.conf</code>, we cannot add or remove entries with the command-line tools:</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>$ ldapadd -U matt -f john_locke.ldif </strong></span></pre></div><p>Here is what we get:</p><div class="informalexample"><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
adding new entry "cn=John Locke, ou=users,dc=example,dc=com"
ldap_add: Server is unwilling to perform (53)
          additional info: operation restricted
  
$ ldapdelete -U matt "uid=manny,ou=users,dc=example,dc=com"
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
ldap_delete: Server is unwilling to perform (53)
             additional info: operation restricted</pre></div><p>Notice that in both cases the server responded: <code class="literal">Server unwilling to perform</code>. However, modifying an attribute in the record is still allowed, as are searching, comparing, and binding.</p><p>As we noted before, extended operations can be restricted using the <code class="literal">extended</code> type with the <code class="literal">restrict</code> directive. Unlike the other types though, <code class="literal">extended</code> takes a value—we can specify which extended operation we want to restrict. Unfortunately, the value must be in the unfriendly OID format. To find out the correct OID you can either check your server's Root DSE entry (see <a class="link" href="apc.html" title="Appendix C. Useful LDAP Commands">Appendix C</a>), or you can read the RFC for the desired extended operation.<a class="indexterm" id="id477"/>
</p><p>Once you have the OID number it is easy to set a restriction. For example, to prevent clients from performing the <span class="emphasis"><em>Password</em></span> <span class="emphasis"><em>Modify</em></span> extended operation use the following:<a class="indexterm" id="id478"/>
</p><div class="informalexample"><pre class="programlisting">restrict extended=1.3.6.1.4.1.4203.1.11.1</pre></div><p>Attempting to use the <code class="literal">ldappasswd</code> client to modify a password will result in an error:</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>$ ldappasswd -x -W -D 'cn=Manager,dc=example,dc=com' -S 
       'uid=barbara,ou=users,dc=example,dc=com'</strong></span></pre></div><p>Here is the error:</p><div class="informalexample"><pre class="programlisting">New password: 
Re-enter new password: 
Enter LDAP Password: 
Result: Server is unwilling to perform (53)
Additional info: extended operation restricted</pre></div><p>The <code class="literal">restrict</code> directive provides a convenient way of limiting what operations clients can perform.</p></div><div class="section" title="Index (BDB/HDB Backends Only)"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec44"/>Index (BDB/HDB Backends Only)</h4></div></div></div><a class="indexterm" id="id479"/><p>If you are running a SLAPD server with the BDB or HDB backends (the most commonly-used backends), then the <code class="literal">index</code> directive is the single most important performance-related directive.</p><p>The <code class="literal">index</code> directive, which is specified in the database section for each BDB or HDB database, indicates which fields SLAPD should build and maintain an index for. An <a class="indexterm" id="id480"/>index is a separate database file that is optimized for speedy access during LDAP read operations.</p><p>When a client uses a search filter with an attribute that is not indexed, SLAPD searches through every record in the directory for the desired attribute, then checks the value of that attribute against the attribute value or filter supplied by the client.</p><p>If the attribute is indexed on the other hand, the SLAPD server simply searches the appropriate attribute index for the value, and quickly returns a list of matching records.</p><p>An index search is much faster than a full directory search and, the larger the directory, the more noticeable the difference.</p><p>The task of determining which attributes must be indexed is left up to you, and the attributes that you ought to index should be determined by which object classes are used in your directory information tree, and which reading operations (searches, binds, compares) are run against your directory server. Directories primarily oriented around information about people (using <code class="literal">person</code>, <code class="literal">organizationalPerson</code>, and <code class="literal">inetOrgPerson</code> object classes) should probably have indexes for commonly used attributes such as <code class="literal">cn</code>, <code class="literal">sn</code>, and <code class="literal">uid</code>.<a class="indexterm" id="id481"/>
</p><p>When we created our basic <code class="literal">slapd.conf</code> file in Chapter 2, we configured the following indexes:</p><div class="informalexample"><pre class="programlisting">index  objectClass  eq
index  cn  eq,sub,pres,approx
index  uid  eq,sub,pres</pre></div><p>There are three indexes specified above: one for <code class="literal">objectClass</code>, one for <code class="literal">cn</code>, and one for <code class="literal">uid</code>.</p><p>The first line creates an index for the <code class="literal">objectClass</code> attribute. The index is optimized for equality (<code class="literal">eq</code>) matches (that is, searches like <code class="literal">objectclass=person</code>, but not searches such as <code class="literal">objectclass=*son</code>). This index should always be included, as the vast majority of reading operations will use the <code class="literal">objectClass</code> attribute.</p><p>The second line is the index for the <code class="literal">cn</code> attribute. Along with configuring this index to efficiently handle equality (<code class="literal">eq</code>) matches, it is also configured to efficiently perform substring (<code class="literal">sub</code>) and approximation (<code class="literal">approx</code>) matches, as well as doing quick tests to see if the attribute is present (<code class="literal">pres</code>). Here is a brief explanation of each of the index optimization types:<a class="indexterm" id="id482"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">approx</code>: This optimizes searches for approximation matching. If a search operation is made request approximate matches (<code class="literal">cn~=mat</code>), this index may be used to speed up the approximation matching.</li><li class="listitem" style="list-style-type: disc"><code class="literal">eq</code>: This optimizes for equality matching. Filters that request an exact match, such as (<code class="literal">uid=matt</code>) or (<code class="literal">objectclass=person</code>) make use of the <code class="literal">eq</code> optimization. It is very important that the <code class="literal">objectclass</code> attribute have an index optimized for equality. When using directory replication or other overlays, you may also need to index other frequently used attributes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sub</code>: This optimizes substring matching. A substring search occurs when a search request sends a part of a string and asks that attribute value that contains that part be returned. For example, the filter (<code class="literal">uid=*ar*</code>) should match any UIDs that contain the string <code class="literal">ar</code>. Users <code class="literal">mark</code> and <code class="literal">karen</code> would both match this filter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">subinitial</code>: This is a special type of <code class="literal">sub</code> optimization that optimizes matching the first part of the string only. It is good for handling filters like (<code class="literal">uid=mar*</code>), but not filters like (<code class="literal">uid=*ark</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">subfinal</code>: This is also a special type of <code class="literal">sub</code> optimization. This one optimizes matching the last part of the string, and performs well for filters like (<code class="literal">uid=*ark</code>).<a class="indexterm" id="id483"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">pres</code>: The <code class="literal">pres</code> type optimizes the index for cases where a search merely needs to see if an attribute is present.<a class="indexterm" id="id484"/></li></ul></div><p>Not all attributes though, support all of the index options. For example, the <code class="literal">objectclass</code> attribute does not support <code class="literal">approx</code>, <code class="literal">sub</code>, or any of the <code class="literal">sub</code> variants, and does not benefit from having a <code class="literal">pres</code> index.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip35"/>Tip</h3><p>
<span class="strong"><strong>Indexes and Schemas</strong></span>
</p><a class="indexterm" id="id485"/><p>An object class' schema defines what matching rules an attribute supports, and the type of matching rule determines whether or not it can support a particular type of index. See Chapter 6.</p></div></div><p>In general, adding indexes for commonly-used attributes is a good thing. It speeds up searching and other reading operations, and since the majority of LDAP operations are reading operations, this can be a boon to performance.</p><p>But maintaining indexes does slow down writing operations that involve indexed attributes, since those attributes have to be maintained not only in the main database, but also in the index database files. Also, each index requires additional cache space for efficiently searching, which means adding more indexes will consume more memory. For those reasons, it is best to index only the attributes that are frequently used in searching operations, rather than indexing everything.</p><p>When an <code class="literal">index</code> directive is added or modified though, SLAPD does not automatically re-index all of the entries in the directory. You will need to do it by hand. For example, after looking at common searches on our system, we determine that it would be good to add indexes for the <code class="literal">sn</code> and <code class="literal">member</code> attributes. Other applications often run searches to find out what groups particular DNs are members of, and an index of this attribute would expedite those searches.</p><p>To service these needs we will add the following new <code class="literal">index</code> directives:</p><div class="informalexample"><pre class="programlisting">index sn eq,sub,approx
index member eq</pre></div><p>But once we have added these to <code class="literal">slapd.conf</code>, we will need to stop SLAPD and run the <code class="literal">slapindex</code> program to rebuild the index files:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>  $ sudo slapindex -q</strong></span></pre></div><p>This will rebuild all of the indexes. The <code class="literal">-q</code> (quick) flag will greatly speed up the process, as it skips performing consistency checks of the database.<a class="indexterm" id="id486"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip36"/>Tip</h3><p>
<span class="strong"><strong>Avoid Rebuilding Indexes</strong></span>
</p><a class="indexterm" id="id487"/><p>A <code class="literal">slapindex</code> procedure <a class="indexterm" id="id488"/>will rebuild all indexes. When adding an index to a large directory, you may want to avoid rebuilding all of the other indexes. One way to do this is to comment out the existing indexes in <code class="literal">slapd.conf</code> (leaving only the new index lines uncommented), run <code class="literal">slapdindex</code>, and then remove the comments from the existing indexes. The next version of OpenLDAP will support a more convenient way of adding indexes.</p></div></div><p>The <code class="literal">slapindex</code> program will print error messages if any of the optimizing types are not allowed for an attribute (like if one tries to add substring indexing to <code class="literal">objectclass</code>). But when it runs successfully, it will quietly exit without printing any messages.</p><p>Once <code class="literal">slapindex</code> is finished, SLAPD can be restarted.</p></div><div class="section" title="Controlling the Cache (BDB/HDB Only)"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec45"/>Controlling the Cache (BDB/HDB Only)</h4></div></div></div><a class="indexterm" id="id489"/><p>With BDB and HDB backends, SLAPD stores frequently-accessed records in a cache so that it doesn't have to read directory information from disk with every request. By default, SLAPD retains one-thousand records in the cache. But busy directory servers with a few thousand entries or more will benefit from having a larger cache. This can be done with the <code class="literal">cachesize</code> directive:</p><div class="informalexample"><pre class="programlisting">cachesize 2000</pre></div><p>The above directive doubles the default cache size, instructing SLAPD to keep 2000 records in memory.</p><p>What happens when the cache is full? By default, SLAPD simply drops the last item in the cache (leaving a cache of 2000 with 1999 full slots). On a busy server, emptying just one cache entry at a time can have slight negative impacts on performance, since it is possible that if a number of searches are executed in rapid succession, each one missing a cache hit, the last entry of the cache would be freed up and filled with every request. This scenario is more likely to happen with the cache is disproportionately small, when compared to the number of entries in the database.</p><p>The <code class="literal">cachefree</code> directive can be used to instruct SLAPD to drop more than one item from the cache when it fills:</p><div class="informalexample"><pre class="programlisting">cachefree 5</pre></div><p>This example instructs SLAPD to drop the last five entries in the cache.</p><p>Ideally, the cache size should remain as close to the actual number of entries in the database as memory constraints will permit. At least, though, the cache should be large enough that frequently requested records can remain in memory. For example, if your directory server functions as an address book, then the cache should be large enough that the user records, as well as their ancestor records, can all be kept in cache at the same time.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note82"/>Note</h3><p>These caching directives are not the only ones of importance for SLAPD. See also the <code class="literal">set_cachesize</code> directive in the <code class="literal">DB_CONFIG</code> file section.</p></div></div><p>The third cache directive is <code class="literal">idlcachesize</code>. The <code class="literal">idlcachesize</code> directive is used for caching the results of frequently performed searches, and a large cache here will make searches of often used searches much faster. With the HDB database, it is suggested that this be <span class="emphasis"><em>three</em></span> <span class="emphasis"><em>times</em></span> the <code class="literal">cachesize</code> value:<a class="indexterm" id="id490"/>
</p><div class="informalexample"><pre class="programlisting">cachesize 2000
idlcachesize 6000</pre></div><p>We have now finished taking a look at the <code class="literal">slapd.conf</code> configuration options. Now we will turn to another configuration file that can be used to tailor the performance of SLAPD.</p></div><div class="section" title="Reducing Disk I/O Latency (BDB/HDB Only)"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec46"/>Reducing Disk I/O Latency (BDB/HDB Only)</h4></div></div></div><a class="indexterm" id="id491"/><p>When LDAP operations write new data to the directory and SLAPD is using the BDB or HDB backends the data is stored in memory first, and then flushed to the database files stored in the operating system.</p><p>On a very busy directory server (or a server with really slow disk I/O), it is sometimes desirable to trade off data security for speed. There are two directives in particular that instruct SLAPD to make this trade off:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first, and the less risky of the two, is the <code class="literal">dirtyread</code> directive which takes no parameters.<p>Consider the case where one client performs a write operation to modify a record, and then another client performs a read operation on that same record before SLAPD has written the first client's changes to disk. Should the server return the unmodified data stored on disk, or the modified data that has not yet been committed? Usually it does the first, sending the <span class="emphasis"><em>clean</em></span>, but soon-to-be out-of-date record to the client.</p><p>The term "dirty read" describes the second case, where the server sends the client information that has not been committed. While returning this data may be faster, it might possibly be inaccurate; the server may reject or abort the modification request of the first client even after having sent the modified data to the second client.</p><p>The <code class="literal">dirtyread</code> directive only increases the risks that a client may get inaccurate data. <a class="indexterm" id="id492"/>
</p></li><li class="listitem" style="list-style-type: disc">The second directive, <code class="literal">dbnosync</code>, carries a higher risk.<p>Normally, when an operation changes directory information, the changes are written to disk as soon as possible. Data stored in memory is flushed to the files in the Berkeley DB subsystem. But performing disk I/O can slow the server. One way to speed this up is to instruct SLAPD to delay writing the information to the log file on the disk, and this is done with the <code class="literal">dbnosync</code> directive.</p><p>The risk in running with <code class="literal">dbnosync</code> though, is that in the event that the server should die without a clean shutdown, modifications made to the directory, but not yet written to disk, will be lost. However, there is no greater risk of corrupting the database—the database will still be recoverable, though the most recent changes may be lost.</p><p>You can reduce (though not eliminate) the risks of running with <code class="literal">dbnosync</code> by also using the <code class="literal">checkpoint</code> directive. Setting a checkpoint causes SLAPD to periodically write data to the disk. The <code class="literal">checkpoint</code> directive takes two parameters: a maximum size (in kilobytes), and a time limit (in minutes). SLAPD will checkpoint the database anytime the amount of data written is greater than the maximum size or after the specified interval of time has passed. Here is an example of the <code class="literal">checkpoint</code> directive:</p><div class="informalexample"><pre class="programlisting">	  checkpoint 1024 30</pre></div><p>This instructs SLAPD to checkpoint the database (flushing any new data from memory to the file system) whenever more than one megabyte of data has been written to the database and every 30  minutes.</p></li></ul></div><p>Due to the increased risks with these directives, it is generally better to try other means of improving performance (such as altering the cache or tuning the <code class="literal">DB_CONFIG</code> file) before implementing these directives.</p></div></div></div><div class="section" title="The DB_CONFIG File"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>The DB_CONFIG File</h2></div></div></div><a class="indexterm" id="id493"/><p>The <code class="literal">DB_CONFIG</code> file is technically not an OpenLDAP configuration file at all. It is a Berkeley DB configuration file, and is specific to the BDB and HDB backends only. It provides a series of settings for the Berkeley database engine.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note83"/>Note</h3><a class="indexterm" id="id494"/><p>Berkeley DB is an Open Source embedded database, now maintained by Oracle. Because it is robust and reliable, actively maintained, and widely support, it is a popular product in both open source and proprietary applications. For more information about Berkeley DB, see Oracle's website: <a class="ulink" href="http://www.oracle.com/database/berkeley-db/index.html">http://www.oracle.com/database/berkeley-db/index.html</a>
</p></div></div><p>Since the entire directory information tree, as well as the indexes, for a BDB/HDB backend is stored in a Berkeley DB database, a properly configured <code class="literal">DB_CONFIG</code> file is the most important facet of directory performance.</p><p>When experimenting with the <code class="literal">DB_CONFIG</code> file and trying out new configurations, it is best to use a non-production server, and to use <code class="literal">slapcat</code> to make a full backup of the directory data before you make any changes.</p><p>The <code class="literal">DB_CONFIG</code> file is not stored with the OpenLDAP configuration files. Instead, it is stored alongside the database files at <code class="literal">/var/lib/ldap</code> (or <code class="literal">/usr/local/var/openldap-data</code>). Unlike the other configuration files, it is read only when the database is created or recovered. As of OpenLDAP 2.3, if SLAPD detects changes in <code class="literal">DB_CONFIG</code> when it is starting up, it will attempt to perform a database recovery in order to incorporate the changes, and you may see an entry like this in your log file:</p><div class="informalexample"><pre class="programlisting">bdb_db_open: DB_CONFIG for suffix dc=example,dc=com has changed
Performing database recovery to activate new settings</pre></div><p>Likewise, when you create a new directory, the Berkeley DB subsystem will read the <code class="literal">DB_CONFIG</code> file and create the databases according to the directives therein.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip37"/>Tip</h3><p>Make sure your database has a <code class="literal">DB_CONFIG</code> file. If your database directory does not have a <code class="literal">DB_CONFIG</code> file present, you will be using the factory defaults for Berkeley DB, which are very conservative. On anything but a small (&lt;100 entries) directory server, the defaults will be insufficient, and result in poor performance.</p></div></div><p>OpenLDAP distributions include a default <code class="literal">DB_CONFIG</code> file tuned for general use. It should be located at <code class="literal">/var/lib/ldap</code> already (though it is sometimes labeled <code class="literal">DB_CONFIG.example</code>, in which case you will need to rename it to just <code class="literal">DB_CONFIG</code>). In Ubuntu Linux, an Ubuntu-customized <code class="literal">DB_CONFIG</code> file is located at <code class="literal">/usr/share/doc/slapd/examples/DB_CONFIG</code>. We will start by using the version included with the OpenLDAP source distribution (which is configured for enterprise use). The default version looks something like this:</p><div class="informalexample"><pre class="programlisting"># one 0.25 GB cache
set_cachesize 0 268435456 1
# Data Directory
#set_data_dir db

# Transaction Log settings
set_lg_regionmax 262144
set_lg_bsize 2097152
#set_lg_dir logs</pre></div><p>We have removed some of the comments from the header and footer of the file, but preserved all of the settings.</p><p>For standard usage on a medium-sized directory, these settings are good. If your directory is performing sufficiently fast and your system is not strapped for resources, you need not feel compelled to change the default settings.</p><p>The <code class="literal">DB_CONFIG</code> file contains directives that directly pertain to the performance of the underlying Berkeley DB files. We will go through these six settings in order. The most important directive is the first.</p><p>At the end of this section we will also look at three additional directives used for tuning Berkeley DB lock handling.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note84"/>Note</h3><p>Some of the directives we examined earlier are synonyms for <code class="literal">DB_CONFIG</code> directives. For example, <code class="literal">dbnosync</code> does the same thing as the <code class="literal">DB_CONFIG</code> directive <code class="literal">set_flags</code> <code class="literal">DB_TXN_NOSYNC</code>.</p></div></div><div class="section" title="Setting the Cache Size"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec64"/>Setting the Cache Size</h3></div></div></div><a class="indexterm" id="id495"/><p>The BDB/HDB backend attempts to keep as much of the directory as possible in memory in the form of a cache. This keeps directory reading quick since SLAPD does not have to read information from the disk.</p><p>While it might not be possible (on a system with other services, a good economic trade-off) to keep the entire directory in the cache, the server will run faster if at least the most frequently used entries are kept in the cache.</p><p>The <code class="literal">set_cachesize</code> directive determines how much memory SLAPD will allocate for a directory cache. The directive takes three arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The number of gigabytes of space to allocate for the cache</li><li class="listitem" style="list-style-type: disc">The number of bytes of space to allocate for the cache</li><li class="listitem" style="list-style-type: disc">The number of segments to use for the the cache</li></ul></div><p>The first and second are added together and should not, when combined, be larger than 4 GB. The third determines how many data segments the Berkeley DB backend will break the cache into. The values 1 and 0 both result in a single cache segment (which is usually desired).</p><p>In the default OpenLDAP <code class="literal">DB_CONFIG</code> file, the <code class="literal">set_cachesize</code> directive looks like this:</p><div class="informalexample"><pre class="programlisting">set_cachesize 0 268435456 1</pre></div><a class="indexterm" id="id496"/><p>The total size of the cache is 256 megabytes (268435456/1024/1024), and the entire cache is stored in one segment. For our tiny directory, this is far more than we need. It is a safe setting, though the full 256 megabytes will not be allocated.</p><p>A good rule of thumb for estimating the minimum amount of cache you will need in a small or medium-sized directory is to allocate two megabytes of cache for every 100 megabytes of LDIF data, plus one megabyte of cache per index. Larger directories will definitely benefit though, from carefully-tuned caches. For a finer-grained calculation, see the OpenLDAP FAQ-O-Matic entry on setting cache sizes: <a class="ulink" href="http://www.openldap.org/faq/data/cache/1075.html">http://www.openldap.org/faq/data/cache/1075.html</a>.</p></div><div class="section" title="Configuring the Data Directory"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec65"/>Configuring the Data Directory</h3></div></div></div><a class="indexterm" id="id497"/><p>The <code class="literal">set_data_dir</code> directive takes one parameter, which is the path to the directory that contains the database files. In the previous example this directive is commented out. Since the <code class="literal">DB_CONFIG</code> file is stored in the same directory as the BDB files themselves you should not need to set this directive. It only needs to be set when the <code class="literal">DB_CONFIG</code> file is loaded from a location outside of the database directory.</p></div><div class="section" title="Optimizing BDB/HDB Transaction Logging"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec66"/>Optimizing BDB/HDB Transaction Logging</h3></div></div></div><a class="indexterm" id="id498"/><p>The last three directives relate to transaction logging. As modifications are made to the Berkeley DB, the complete details of the transaction are written to log files, named <code class="literal">log.XXXXXXXXXX</code>, where the ten <code class="literal">X</code>'s are replaced by digits from 0-9. The first log file is <code class="literal">log.0000000001</code>, and once it grows too large, a new log file is created by incrementing the number: <code class="literal">log.0000000002</code>.</p><p>The log files comprise a record of all that has happened in a database. In fact, they are so complete that they can be used to rebuild a corrupt database. The log file format is not plain text, and cannot be read using the usual tools (like <code class="literal">cat</code>, <code class="literal">more</code>, or <code class="literal">less</code>). To read it you will need to use the <code class="literal">db_printlog</code> command (or <code class="literal">dbX.Y_printlog</code>, where <code class="literal">X.Y</code> is replaced by the major and minor version numbers of the database, such as <code class="literal">db4.2_printlog</code>). This will display a record for each transaction made to the databases.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>
<span class="strong"><strong>Recovering a Corrupt BDB/HDB Database</strong></span>
</p><a class="indexterm" id="id499"/><p>The log files written by the Berkeley DB subsystem can be used to recover a corrupt database. The Berkeley DB distribution includes a tool called <code class="literal">db_recover</code> (or <code class="literal">dbX.Y_recover</code>, where <code class="literal">X.Y</code> is the major and minor version number, such as <code class="literal">db4.3_recover</code>). The <code class="literal">db_recover</code> tool uses the log files to fix corrupted databases. For more information view the man page for <code class="literal">db_recover</code>.</p></div></div><p>At startup SLAPD automatically performs a recovery on the BDB directory to ensure that the database is in a stable state. It is only in rare cases that a system administrator will have to manually work with the log files.</p><a class="indexterm" id="id500"/><p>Since these transaction log files play such an important role in the safety of SLAPD's data, it is good to ensure that the environment is properly tuned.</p><p>The <code class="literal">set_lg_regionmax</code> directive controls the amount of memory allocated to storing the names of Berkeley DB files. It takes one argument: the amount of space to be allocated (in bytes). The file above allocates 256 KB for storing names, and this should be fine for almost all applications. Only in rare cases where there are many index files would it be necessary to raise this limit (I have never yet encountered such a situation).</p><p>The next directive, <code class="literal">set_lg_bsize</code>, is used to allocate the amount of memory used to buffer data before it is written to the transaction log. It too takes one argument: the amount of space (in bytes) to be used for a buffer. The setting in our file allocates two megabytes of space. When a modification is made to the BDB/HDB database, information about the modification is not written to the log until the transaction is complete. Until it is written it is temporarily stored in an in-memory buffer, whose size is no bigger than the value of <code class="literal">set_lg_bsize</code>.</p><p>Since most LDAP data is relatively short, two megabytes is usually sufficient. But if your particular directory frequently stores large chunks of data (such as image files), you may consider increasing the buffer size for the transaction log to accommodate the largest chunks of data. For example, if the directory stores images as large as ten megabytes, <code class="literal">set_lg_bsize</code> should be set at <code class="literal">10485760</code> (which is 10 * 1024 *1024).</p><p>Howard Chu, one of the OpenLDAP developers, points out that when increasing the <code class="literal">set_lg_bsize</code> flag to a value this large, you will also have to raise the maximum size limit for the log file using the <code class="literal">set_lg_max</code> flag. The maximum size for the log file must be <span class="emphasis"><em>at</em></span> <span class="emphasis"><em>least</em></span> four times the value of <code class="literal">set_lg_bsize</code>.</p><div class="informalexample"><pre class="programlisting">set_lg_max 41943040</pre></div><p>Finally, the last directive, <code class="literal">set_lg_dir</code>, points to the log file for BDB. By default, these log files are stored in the same directory as the rest of the database files (<code class="literal">/var/lib/ldap/</code> or <code class="literal">/usr/local/var/openldap-data/</code> if you compiled from source ). However, since logs are crucial in recovery of the database, it is not a bad idea to store the log files in a different location than the databases. For example, you might want to store the logs on a different hard disk than the database files. To do so, uncomment the <code class="literal">set_lg_dir</code> directive and set it to the absolute path of the desired destination directory:</p><div class="informalexample"><pre class="programlisting">set_lg_dir /usr/local/var/ldap/</pre></div><a class="indexterm" id="id501"/><p>This directive will instruct the Berkeley DB subsystem to write the log files to <code class="literal">/usr/local/var/ldap</code> instead of the same directory that the BDB files are located.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note85"/>Note</h3><p>Regularly backing up the Berkeley DB files (including the log files) is a good idea. A more portable way of backing up the data is to dump a copy of the directory using the <code class="literal">slapcat</code> tool. This will export the database into LDIF format, which can be easily imported into a SLAPD server, regardless of the backend format.</p></div></div></div><div class="section" title="Tuning Lock Files"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec67"/>Tuning Lock Files</h3></div></div></div><a class="indexterm" id="id502"/><p>There are three additional parameters that should be included in the <code class="literal">DB_CONFIG</code> file. These are the three directives that tune the locking mechanisms in Berkeley DB.</p><p>Certain operations on the database will require that the data be locked to prevent the introduction of data inconsistency. For example, it is not good to allow two different threads to modify the same record at the same time. Berkeley DB uses a locking mechanism to prevent this from happening.</p><p>There are three directives that are used to tune the locking subsystem. These are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">set_lk_max_objects</code>: The maximum number of objects that can be locked at a given time</li><li class="listitem" style="list-style-type: disc"><code class="literal">set_lk_max_locks</code>: The maximum number of locks that can be requested at a time</li><li class="listitem" style="list-style-type: disc"><code class="literal">set_lk_max_lockers</code>: The maximum number of simultaneous lock requests</li></ul></div><p>In the default Ubuntu <code class="literal">DB_CONFIG</code> file these are all set to 5000, but lower values (between 1500 and 3000) may be more desirable:</p><div class="informalexample"><pre class="programlisting"># Number of objects that can be locked at the same time.
set_lk_max_objects      5000
# Number of locks (both requested and granted)
set_lk_max_locks        5000
# Number of lockers
set_lk_max_lockers  5000</pre></div><p>Setting these values at a sufficiently high value will prevent the database from running out of locks, and thus denying database access.<a class="indexterm" id="id503"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note86"/>Note</h3><p>To see if your Berkeley DB lock settings are adequate, you can use the following command, which prints detailed information about locks and lockers:</p><p><span class="strong"><strong>  db4.2_stat -c</strong></span></p></div></div></div><div class="section" title="More about Berkeley DB"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec68"/>More about Berkeley DB</h3></div></div></div><a class="indexterm" id="id504"/><p>The directives we have covered in this section are those that get the most attention for OpenLDAP. However, there are other directives, and judicious use of such settings can also improve the performance and reliability of the BDB and HDB backends.</p><p>Some information about these parameters can be found in OpenLDAP's FAQ-O-Matic (<a class="ulink" href="http://www.openldap.org/faq/data/cache/1072.html">http://www.openldap.org/faq/data/cache/1072.html</a>). For a thorough understanding, though the best resource is the <span class="emphasis"><em>Berkeley</em></span> <span class="emphasis"><em>DB</em></span> <span class="emphasis"><em>Reference</em></span> <span class="emphasis"><em>Guide.</em></span> The newest version can be found here: <a class="ulink" href="http://www.oracle.com/technology/documentation/berkeley-db/db/ref/toc.html">http://www.oracle.com/technology/documentation/berkeley-db/db/ref/toc.html</a>
</p><p>At this point we have looked at the <code class="literal">slapd.conf</code> and <code class="literal">DB_CONFIG</code> files, examining some of the ways that these files can be modified to improve the performance of SLAPD. Next, we will turn to a different topic: extending the functionality of SLAPD using directory overlays.</p></div></div></div>
<div class="section" title="Directory Overlays"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Directory Overlays</h1></div></div></div><a class="indexterm" id="id505"/><p>As the OpenLDAP project has grown, more and more features have been added. Initially, these features were added directly to the SLAPD server's code base. But as features were rolled into OpenLDAP, both the code and the configuration became increasingly complex.</p><p>To address this problem, OpenLDAP developers introduced a new concept in OpenLDAP 2.2 that made it easier to introduce new features while reducing the complexity of the underlying code. The developers introduced a modular system called <span class="strong"><strong>overlays</strong></span>. An overlay is a chunk of code that can modify the behavior of the SLAPD.</p><p>When SLAPD receives a request for a database configured to use an overlay, the overlay is given an opportunity to perform processing on the request before any information is retrieved from the underlying database. As a result overlays can be used to perform additional processing of requests.</p><p>How is an overlay added to the directory server? It is through special directives in the <code class="literal">slapd.conf</code> file. The <code class="literal">overlay</code> directive is placed in the database configuration section, <a class="indexterm" id="id506"/>though an overlay sometimes intercepts operations that are not backend-specific.</p><p>More than one overlay can be used in a database. When overlays are used this way, they <a class="indexterm" id="id507"/>are said to be <span class="strong"><strong>stacked</strong></span>. As we will see later in this chapter the order of overlay directives is very important because SLAPD sequentially goes through the overlay stack, calling the overlays one at a time.</p><div class="section" title="A Brief Tour of the Official Overlays"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>A Brief Tour of the Official Overlays</h2></div></div></div><p>In OpenLDAP 2.3 there are sixteen <span class="emphasis"><em>official</em></span> overlays included with the OpenLDAP distribution, and a handful of contributed and unofficial overlays. Almost all of the official overlays are described in the man pages. Here we have a brief description of each of the sixteen; we will also see a few useful overlays in more detail. In the later chapters we will also make use of overlays.</p><p>The <span class="emphasis"><em>official</em></span> overlays are as follows:<a class="indexterm" id="id508"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><code class="literal">accesslog</code>: <a class="indexterm" id="id509"/>The access logging overlay is used to record information about directory access and utilization. Rather than recording the data in the file system, information is stored as records inside a special log directory. Logs can then be retrieved through LDAP clients, or by using a tool such as <code class="literal">slapcat</code> to dump the logs into a flat (LDIF) file. We will implement this overlay in the next chapter, and use it again in Chapter 7 to improve replication.</li><li class="listitem"><code class="literal">auditlog</code>: <a class="indexterm" id="id510"/>The audit logging overlay records information on changes to the directory. Unlike the more powerful access logging overlay, audit log stores information in a file in the file system.</li><li class="listitem"><code class="literal">chain</code>: <a class="indexterm" id="id511"/>In complex directory environments, one directory may have information that another directory does not have. That second directory may be configured to <span class="emphasis"><em>refer</em></span> clients of the first directory. Typically, a referral involves sending the client information about redirecting its query, and then the client is left to chase the referral. The chain overlay handles referral chasing on the server side; the server will follow the referral itself and return the complete information to the client.</li><li class="listitem"><code class="literal">denyop</code>: <a class="indexterm" id="id512"/><a class="indexterm" id="id513"/>The deny operation overlay performs the same sort of function as the restrict directive discussed earlier in this chapter. It disallows clients from performing certain LDAP operations. In the next section we will use this overlay.</li><li class="listitem"><code class="literal">dyngroup</code>: <a class="indexterm" id="id514"/>The <code class="literal">dyngroup</code> overlays provide ways of creating dynamic groups based on specific attributes in an object. This provides a powerful method of grouping records.</li><li class="listitem"><code class="literal">dynlist</code>: <a class="indexterm" id="id515"/>It is similar to the <code class="literal">dyngroup</code> overlay.</li><li class="listitem"><code class="literal">glue</code>: <a class="indexterm" id="id516"/>The glue overlay, which is built-in and loaded by default, makes it possible to link two databases together so they appear as if they were one large directory information tree. For example, if one database contains <code class="literal">dc=example,dc=com</code>, and a second database holds <code class="literal">ou=Users,dc=example,dc=com</code>, the glue overlay makes it possible for searches of <code class="literal">dc=example, dc=com</code> to return entries from the <code class="literal">ou=Users,dc=example,dc=com</code> database. The <code class="literal">subordinate</code> directive must be used in the database section of <code class="literal">slapd.conf</code> to indicate which databases should be glued.</li><li class="listitem"><code class="literal">lastmod</code>: <a class="indexterm" id="id517"/>The last modification overlay creates a special record in the directory information tree that contains information about what the most recently modified record is and when it was modified.</li><li class="listitem"><code class="literal">pcache</code>: <a class="indexterm" id="id518"/>The proxy cache overlay caches the results of an LDAP search. This overlay is mainly used with the <code class="literal">ldap</code> backend. With this combination, SLAPD can be configured to use another LDAP server as its backend, but speed up client requests by keeping a cached copy of the data in a special database.</li><li class="listitem"><code class="literal">ppolicy</code>: <a class="indexterm" id="id519"/>The password policy overlay allows you to enforce certain restrictions, such as password expiration dates and password length. The password policy overlay is described in the next chapter.</li><li class="listitem"><code class="literal">refint</code>: <a class="indexterm" id="id520"/><a class="indexterm" id="id521"/>The referential integrity overlay is used to keep directory entries consistent when records are deleted or DNs are modified. For example, if a DN is deleted from the directory and the <code class="literal">refint</code> overlay is used, SLAPD will search the directory for other references to this DN (such as group memberships) and remove those references as well. We will look at this later in the chapter.</li><li class="listitem"><code class="literal">retcode</code>: <a class="indexterm" id="id522"/>This overlay is designed to help LDAP client implementors test how their code responds to abnormal server responses.</li><li class="listitem"><code class="literal">rwm</code>: <a class="indexterm" id="id523"/>The rewriting and mapping overlay provides a facility for taking a client request and re-writing or mapping parts of the request to other values. This can be used in conjunction with a proxying LDAP server to re-write attribute names and DNs.</li><li class="listitem"><code class="literal">syncprov</code>: <a class="indexterm" id="id524"/>The synchronization provider overlay is used by SLAPD servers that act as providers from which other SLAPD servers replicate data. We will discuss this more in Chapter 7.</li><li class="listitem"><code class="literal">translucent</code>: <a class="indexterm" id="id525"/>The <code class="literal">translucent</code> overlay is similar to the proxy overlay. When a client requests a record, it retrieves the record from a remote server. But, it can do more—it can store a local copy of the record that can override portions of the remote record.</li><li class="listitem"><code class="literal">unique</code>: <a class="indexterm" id="id526"/><a class="indexterm" id="id527"/>The <code class="literal">unique</code> overlay enforces attribute uniqueness. It is used to ensure that, for specified attributes, a given attribute value exists in only one record in the directory. This is useful to keep multiple users from having the same email address (<code class="literal">mail</code>) or user ID (<code class="literal">uid</code>) attribute values.</li></ol></div><p>Each of the overlays documented here (except for <code class="literal">denyop</code>) has a corresponding man page that can be accessed using the command <code class="literal">man</code> <code class="literal">slapo-&lt;name</code> <code class="literal">of</code> <code class="literal">overlay&gt;</code>, where <code class="literal">&lt;name</code> <code class="literal">of</code> <code class="literal">overlay&gt;</code> is replaced with the abbreviated name of the overlay. For example, to get the man page for the <code class="literal">translucent</code> overlay, run the command: <code class="literal">man</code> <code class="literal">slapo-translucent</code>.</p><p>In the remainder of this chapter we will cover a few simple overlays in detail. In the next few chapters we will cover several sophisticated overlays, using them to address common directory server needs.</p></div><div class="section" title="Configuring an Overlay: denyop"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Configuring an Overlay: denyop</h2></div></div></div><a class="indexterm" id="id528"/><a class="indexterm" id="id529"/><p>Since we have covered the basic concepts behind the <code class="literal">denyop</code> overlay when we looked at the <code class="literal">restrict</code> directive, and since <code class="literal">denyop</code> is simple to implement, we will look at it as an example for how to use an overlay.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note87"/>Note</h3><p>The <code class="literal">restrict</code> directive is actually the preferred method of restricting operations. The <code class="literal">denyop</code> overlay was intended primarily as an example for other overlay authors.</p></div></div><p>Overlays are configured in the <code class="literal">slapd.conf</code> file. Typically there are three steps to configuring an overlay:<a class="indexterm" id="id530"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Load the dynamic object with the moduleload directive</li><li class="listitem">Add the overlay to the <span class="emphasis"><em>database</em></span> <span class="emphasis"><em>section</em></span> with the <code class="literal">overlay</code> directive</li><li class="listitem">Add any overlay-specific directives to the database section</li></ol></div><p>Let's look at each step in detail.</p><div class="section" title="Loading the module"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec69"/>Loading the module</h3></div></div></div><a class="indexterm" id="id531"/><p>The first task is to load the module containing the overlay. This part is not always necessary. Some versions of OpenLDAP have all of the modules statically compiled in, which means they are loaded along with the server. More often though, SLAPD is compiled to dynamically load modules that are loaded when SLAPD starts, and almost all overlays are implemented as modules.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note88"/>Note</h3><p>See <a class="link" href="apa.html" title="Appendix A. Building OpenLDAP from Source">Appendix A</a> for a further discussion of the difference between these two ways of building OpenLDAP.</p></div></div><p>The <code class="literal">moduleload</code> directive should go near the top of the configuration file, before the first <code class="literal">database</code> directive. To load the <code class="literal">denyop</code> dynamic object we need to add the following highlighted line:</p><div class="informalexample"><pre class="programlisting">modulepath /usr/lib/ldap
moduleload back_hdb
<span class="strong"><strong>moduleload denyop</strong></span>
</pre></div><p>When SLAPD starts it will search for the <code class="literal">denyop</code> object in its module path, and load it if it finds it.<a class="indexterm" id="id532"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note3465431"/>Note</h3><p>If you need to load a module not in the module path you can specify the full path to the module. For example <code class="literal">/usr/local/libexec/openldap/my_module</code>.</p></div></div><p>If SLAPD fails to find the module on startup it will fail to start, exiting with an error like this:</p><div class="informalexample"><pre class="programlisting">lt_dlopenext failed: (/tmp/lastmod) /tmp/lastmod.so: cannot open 
                   shared object file: No such file or directory</pre></div><p>This indicates that the module, <code class="literal">lastmod</code>, was not found in the given module path, which in this case was erroneously set to <code class="literal">/tmp</code>.</p><p>Make sure that the module is in one of the directories listed in <code class="literal">modulepath</code>, or that the full path to the module is correct.</p></div><div class="section" title="Adding the Overlay"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec70"/>Adding the Overlay</h3></div></div></div><a class="indexterm" id="id533"/><p>The next step is to add the overlay to the overlay stack. Since there are no overlays already specified, this will be the first of three items on the stack. The <code class="literal">glue</code> overlay is automatically applied, though it does nothing unless a <code class="literal">subordinate</code> directive is present. The backend processing of the operation (the actual directory lookup) is always the last item on the stack.</p><p>To add our overlay we need to put the directive in the appropriate database section of the <code class="literal">slapd.conf</code> file. In a situation where there are multiple backends, the same overlay directive can be repeated in each database section to load the overlay for each database. The new directive is highlighted in the following example:</p><div class="informalexample"><pre class="programlisting">database hdb
suffix "dc=example,dc=com" "o=My Company,c=US"
rootdn "cn=Manager,dc=example,dc=com"
rootpw secret
directory /var/lib/ldap
<span class="strong"><strong>overlay denyop</strong></span>
</pre></div><p>Now, we are ready for the third step.<a class="indexterm" id="id534"/>
</p></div><div class="section" title="Adding Overlay-Specific Directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec71"/>Adding Overlay-Specific Directives</h3></div></div></div><a class="indexterm" id="id535"/><p>An overlay may have its own special directives. These directives are usually documented in the man page for that overlay.</p><p>There is only one directive supported by the <code class="literal">denyop</code> overlay, and it is the eponymous <code class="literal">denyop</code> directive. Like the <code class="literal">restrict</code> directive that we looked at earlier, the <code class="literal">denyop</code> directive takes a list of operations. Clients will be disallowed from performing any operation in this list.<a class="indexterm" id="id536"/>
</p><p>Earlier in this chapter we used the <code class="literal">restrict</code> directive to prevent clients from performing <code class="literal">add</code>, <code class="literal">delete</code>, and <code class="literal">rename</code> operations:</p><div class="informalexample"><pre class="programlisting">restrict add delete rename</pre></div><p>We can implement the same thing with the <code class="literal">denyop</code> directive:</p><div class="informalexample"><pre class="programlisting">denyop add,delete,modrdn</pre></div><p>There are a few minor differences between the two directives:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">denyop</code> takes a comma-separated list of operations</li><li class="listitem" style="list-style-type: disc"><code class="literal">denyop</code> uses the <code class="literal">modrdn</code> name instead of using the term <code class="literal">rename</code></li></ul></div><p>If a client attempts to perform one of the disallowed operations <code class="literal">denyop</code> will stop SLAPD from performing the operation, and the client will be returned an <code class="literal">Unwilling</code> <code class="literal">to</code> <code class="literal">perform</code> error.</p><p>The <code class="literal">denyop</code> overlay is simple and, due to the restrict directive, not likely to enjoy much use in a production server. But the next overlay that we will look at provides useful features, though the accompanying directives are slightly more complex.</p></div></div><div class="section" title="Referential Integrity Overlay"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Referential Integrity Overlay</h2></div></div></div><a class="indexterm" id="id537"/><a class="indexterm" id="id538"/><p>The second overlay we will examine is the RefInt (Referential Integrity) overlay. RefInt is designed to handle cases where the modification or deletion of a record may render attribute values in other records inaccurate.</p><p>LDAP groups provide a good context for illustrating the problem that the RefInt overlay is designed to address. In Chapter 3 we created an LDAP group that looked like this:</p><div class="informalexample"><pre class="programlisting">dn: cn=Admins,ou=Groups,dc=example,dc=com
objectClass: groupOfNames
cn: Admins
ou: Groups
member: uid=matt,ou=users,dc=example,dc=com
member: uid=david,ou=users,dc=example,dc=com</pre></div><p>This group has two members, <code class="literal">uid=matt</code>, and <code class="literal">uid=david</code>. These two member attributes refer to other records (identified by their respective DNs) that are also located in the directory. For example, here is the record for <code class="literal">uid=david</code>:</p><div class="informalexample"><pre class="programlisting">dn: uid=david,ou=Users,dc=example,dc=com
cn: David Hume
sn: Hume
uid: david
ou: Users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>What would happen to the <code class="literal">cn=Admins</code> group if we deleted this record for <code class="literal">uid=david</code> from the directory information tree? Nothing! The <code class="literal">cn=Admins</code> group would still contain a member attribute with the DN for <code class="literal">uid=david</code>. By default, SLAPD does not do any searching for references to a modified or removed DN. Why? The assumption has generally been that such tasks are the responsibility of the applications that access and modify the directory.</p><p>But keeping a directory free of invalid references is not a job that everyone wants to leave to external applications. For that reason the OpenLDAP developers created the RefInt overlay, which makes the task of maintaining referential integrity the responsibility of SLAPD.</p><p>There are two cases when the RefInt overlay kicks into action:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When a DN is modified (via a <code class="literal">modrdn</code> operation): The RefInt overlay does a search of the directory (searching only the values of the attributes specified in the configuration), and replacing any occurrences of the old DN with the newly modified DN</li><li class="listitem" style="list-style-type: disc">When a record is removed (with a <code class="literal">delete</code> operation): The RefInt overlay searches the directory (looking for the specified attributes only), and deletes any references to the DN that it finds</li></ul></div><p>We will look at examples of these, but first let's configure the overlay.</p><div class="section" title="Configuring the Overlay"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec72"/>Configuring the Overlay</h3></div></div></div><a class="indexterm" id="id539"/><p>The first step to configuring the overlay is to make sure the module is loaded. This is done (as always) by adding a <code class="literal">moduleload</code> directive in the basic section of the <code class="literal">slapd.conf</code> file, before the first database section:</p><div class="informalexample"><pre class="programlisting">modulepath /usr/lib/ldap
moduleload back_hdb
moduleload denyop
<span class="strong"><strong>moduleload refint</strong></span>
</pre></div><p>This example builds on our earlier <code class="literal">moduleload</code> example. Only the highlighted line has been added.</p><p>Next, we want to add the overlay to the stack, and configure it for operation. These configuration directives go in each database section for which we want to use the overlay:</p><div class="informalexample"><pre class="programlisting">overlay refint
refint_attributes member uniqueMember seeAlso
refint_nothing cn=EMPTY</pre></div><p>The first line, the <code class="literal">overlay</code> directive, adds RefInt to the overlay stack. Remember, it's position relative to other <code class="literal">overlay</code> directives will determine its position on the overlay stack.<a class="indexterm" id="id540"/>
</p><p>On the next line is the <code class="literal">refint_attributes</code> directive. This directive takes a list of attributes (separated by whitespace characters) that will be searched whenever a <code class="literal">modrdn</code> or <code class="literal">delete</code> operation is performed. We want to include all of the attributes that we want SLAPD to maintain referential integrity for.</p><p>Since we have records that are <code class="literal">groupOfNames</code> and <code class="literal">groupOfUniqueNames</code> object classes, we want the RefInt overlay to check the <code class="literal">member</code> and <code class="literal">uniqueMember</code> attributes. The <code class="literal">seeAlso</code> attribute, which is an attribute allowed for <code class="literal">organization</code>, <code class="literal">organizationalUnit</code>, and <code class="literal">person</code> objects (all of which are used in our directory information tree), takes a DN for a value, so we want RefInt to check it as well.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip39"/>Tip</h3><p>
<span class="strong"><strong>The seeAlso Attribute</strong></span>
</p><a class="indexterm" id="id541"/><p>The <code class="literal">seeAlso</code> attribute, which allows only values that are DNs, is used to indicate a connection between the record that contains the <code class="literal">seeAlso</code> attribute, and the record or records that the <code class="literal">seeAlso</code> attribute points to. There are other attributes, such as the <code class="literal">manager</code> attribute for <code class="literal">inetOrgPerson</code> objects, which also take DN values.</p></div></div><p>The last directive, <code class="literal">refint_nothing</code>, is used in special cases when RefInt is responding to a <code class="literal">delete</code> operation.</p><p>Sometimes it is not possible for RefInt to delete an attribute value. This happens when a record must (according to the schema) have at least one such attribute value. For example, any <code class="literal">groupOfNames</code> object must have at least one <code class="literal">member</code> attribute value. The schema does not allow groups with no members.</p><a class="indexterm" id="id542"/><p>But what if deleting an entry would require RefInt to remove the only <code class="literal">member</code> attribute from a group? We wouldn't want RefInt to try to violate the server's schema constraints.</p><p>RefInt avoids the problem this way: RefInt adds the DN in <code class="literal">refint_nothing</code> as a value for that attribute, and then deletes the other attribute. Effectively, it replaces the deleted value with a known placeholder value.</p><p>In the previous example we have set the <code class="literal">refint_nothing</code> DN to be <code class="literal">cn=EMPTY</code>. There is no entry in our directory information tree named <code class="literal">cn=EMPTY</code> (though if there were, it would cause no problems). <a class="indexterm" id="id543"/>
</p></div><div class="section" title="Modifying the Records"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec73"/>Modifying the Records</h3></div></div></div><a class="indexterm" id="id544"/><p>Now, we will add two records to our directory:</p><div class="informalexample"><pre class="programlisting">dn: uid=marcus,ou=users,dc=example,dc=com
uid: marcus
sn: Tullius
cn: Marcus Tullius
givenName: Marcus
ou: users
objectclass: person
objectclass: organizationalperson
objectclass: inetOrgPerson

dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectclass: groupOfNames
cn: Public Relations
ou: Groups
member: uid=marcus,ou=users,dc=example,dc=com</pre></div><p>The first record is for a new <code class="literal">inetOrgPerson</code> with the UID <code class="literal">marcus</code>. The second record defines the <code class="literal">cn=Public</code> <code class="literal">Relations</code> group which currently has one member, <code class="literal">uid=marcus</code>. What happens to the <code class="literal">member</code> attribute of <code class="literal">cn=Public</code> <code class="literal">Relations</code> if we delete the record for <code class="literal">uid=marcus</code> by using the following command?</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>$ ldapdelete -U matt uid=marcus,ou=users,dc=example,dc=com</strong></span></pre></div><p>Now, we search for the <code class="literal">cn=Public</code> <code class="literal">Relations</code> group:</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>$ ldapsearch -U matt -LLL '(cn=Public Relations)'</strong></span></pre></div><p>The record looks like this:</p><div class="informalexample"><pre class="programlisting">SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers
  
dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectClass: groupOfNames
cn: Public Relations
ou: Groups
member: cn=EMPTY</pre></div><a class="indexterm" id="id545"/><p>As the last line of the code illustrates, there is still one member (the <code class="literal">groupOfNames</code> schema requires that there be one) but, thanks to the RefInt overlay, it no longer points to the deleted <code class="literal">uid=marcus</code> record. Instead it points to the DN we specified in <code class="literal">refint_nothing</code>.<a class="indexterm" id="id546"/>
</p><p>Usually, though, the record will have more than one member attribute, like the <code class="literal">cn=Admins</code> example earlier. In such a case when one of those DNs is deleted, the attribute value is completely removed. Consider a modified version of our <code class="literal">cn=Public</code> <code class="literal">Relations</code> group:</p><div class="informalexample"><pre class="programlisting">dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectclass: groupofnames
cn: Public Relations
ou: Groups
<span class="strong"><strong>member: uid=david,ou=users,dc=example,dc=com</strong></span>
<span class="strong"><strong>member: uid=marcus,ou=users,dc=example,dc=com</strong></span>
</pre></div><p>If the record for <code class="literal">uid=marcus</code> was deleted in this case, then the RefInt overlay would simply delete the second member attribute value, leaving the group looking like this:</p><div class="informalexample"><pre class="programlisting">dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectclass: groupofnames
cn: Public Relations
ou: Groups
<span class="strong"><strong>member: uid=david,ou=users,dc=example,dc=com</strong></span>
</pre></div><p>The value of <code class="literal">refint_nothing</code> is used only when required.</p><p>These last two examples have dealt with cases where the <code class="literal">delete</code> operation is used. But the RefInt overlay also handles changes to DNs made with the <code class="literal">modrdn</code> operation. For example, what if instead of deleting the record for <code class="literal">uid=marcus</code> we changed the DN? Using the previous example let's begin with the same two records:</p><div class="informalexample"><pre class="programlisting">dn: uid=marcus,ou=users,dc=example,dc=com
uid: marcus
sn: Tullius
cn: Marcus Tullius
givenName: Marcus
ou: users
objectclass: person
objectclass: organizationalperson
objectclass: inetOrgPerson

dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectclass: groupofnames
cn: Public Relations
ou: Groups
member: uid=marcus,ou=users,dc=example,dc=com<a class="indexterm" id="id547"/>
<a class="indexterm" id="id548"/>
</pre></div><p>Let's change the DN of the first record to use Marcus Tullius's better-known name:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>  $ ldapmodrdn -U matt uid=marcus,ou=users,dc=example,dc=com
      uid=cicero</strong></span></pre></div><p>In the previous example, we are changing the DN <code class="literal">uid=marcus,ou=users,dc=example,dc=com</code>, replacing the relative DN portion (<code class="literal">uid=marcus</code>) with a new relative DN: <code class="literal">uid=cicero</code>. Now the first record looks like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dn: uid=cicero,ou=users,dc=example,dc=com</strong></span>
<span class="strong"><strong>uid: marcus</strong></span>
<span class="strong"><strong>uid: cicero</strong></span>
sn: Tullius
cn: Marcus Tullius
givenName: Marcus
ou: users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>The <code class="literal">ldapmodrdn</code> client added a new <code class="literal">uid</code> attribute value (<code class="literal">cicero</code>), and then changed the DN of the entry from <code class="literal">uid=marcus,ou=users,dc=example,dc=com</code> to <code class="literal">uid=cicero,ou=users,dc=example,dc=com</code>. And what about the <code class="literal">cn=Public</code> <code class="literal">Relations</code> group? It now looks like this:</p><div class="informalexample"><pre class="programlisting">dn: cn=Public Relations,ou=Groups,dc=example,dc=com
objectClass: groupOfNames
cn: Public Relations
ou: Groups
<span class="strong"><strong>member: uid=cicero,ou=users,dc=example,dc=com</strong></span>
</pre></div><p>The RefInt attribute changed the value of the <code class="literal">member</code> attribute to point to the newly modified DN. Remember, without the RefInt overlay, the <code class="literal">cn=Public</code> <code class="literal">Relations</code> group would point to the now non-existent DN <code class="literal">uid=marcus,ou=users,dc=example,dc=com</code>.</p></div><div class="section" title="Drawbacks"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec74"/>Drawbacks</h3></div></div></div><a class="indexterm" id="id549"/><p>Are there any drawbacks of using the RefInt overlay? Performance is one issue. For every deletion or DN modification, the RefInt overlay will check all the values for all of the attributes listed in the <code class="literal">refint_attributes</code> directive. A large number of deletions or DN modifications can have an impact on system performance. But in most situations, large-scale <code class="literal">delete</code> and <code class="literal">modrdn</code> operations are not the norm (and the overlay can always be turned off when doing such operations).</p><a class="indexterm" id="id550"/><p>There is one other drawback worthy of consideration. Some applications do handle their own reference checking. It is possible that a poorly-written client might try to delete attribute values that do not exist, generating spurious error messages in the process. Of course, this would not have any negative effect on the directory information tree, but it might alarm the user. However, the vast majority of clients, including many that perform their own integrity checking, should not be hampered by the RefInt overlay.</p></div><div class="section" title="A Useful Note"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec75"/>A Useful Note</h3></div></div></div><p>When starting up SLAPD after installing a new overlay, it is not uncommon to get the following warning message:</p><div class="informalexample"><pre class="programlisting">WARNING: No dynamic config support for overlay refint.</pre></div><p>What does this message mean? And is the problem serious?</p><p>This warning message can be ignored when configuring OpenLDAP with a <code class="literal">slapd.conf</code> file. It is simply a notice that the configuration options for this overlay cannot be changed once the server starts. But this is, of course, how all directives in the <code class="literal">slapd.conf</code> file work.</p><p>This warning message applies only to installations that load their configuration into the directory as an LDIF file, and then manage their configuration inside of the directory server (using the <code class="literal">cn=Config</code> record). This feature is fairly new, and since it does not support all of the OpenLDAP features (such as many overlays), it is not the recommended configuration for most clients.</p></div></div></div>
<div class="section" title="The Uniqueness Overlay"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>The Uniqueness Overlay</h1></div></div></div><a class="indexterm" id="id551"/><a class="indexterm" id="id552"/><a class="indexterm" id="id553"/><p>The last overlay that we will examine in this section is the uniqueness overlay. The uniqueness overlay enforces uniqueness for a configurable set of attributes in the directory. It prevents attributes in different records from containing the same values. This is desirable, for example, when working with the <code class="literal">uid</code> attribute, where we would clearly not want to have the same UID for multiple users in the system. By default, SLAPD only enforces uniqueness when it comes to DNs—no two DNs may be the same. But other attribute values are unchecked. Using the uniqueness overlay, we can specify which attributes we want SLAPD to ensure uniqueness for.</p><p>The first step in configuring the uniqueness overlay is to load the module:<a class="indexterm" id="id554"/>
</p><div class="informalexample"><pre class="programlisting">modulepath      /usr/local/libexec/openldap
moduleload      back_hdb
moduleload      denyop
moduleload      refint
<span class="strong"><strong>moduleload      unique</strong></span>
</pre></div><p>In the <span class="emphasis"><em>Basics</em></span> section of <code class="literal">slapd.conf</code>, we add one more <code class="literal">moduleload</code> directive. The module we want to load is named <code class="literal">unique</code>.</p><p>Next we want to add this overlay, along with a few specific directives, to the relevant database sections:<a class="indexterm" id="id555"/>
</p><div class="informalexample"><pre class="programlisting">overlay unique
unique_base dc=example,dc=com
unique_attributes uid</pre></div><p>This is a very basic configuration for the uniqueness overlay. The <code class="literal">unique_base</code> directive indicates which parts of the directory information tree we want to enforce uniqueness in. For our exercise we want to enforce uniqueness across our entire directory tree, <code class="literal">dc=example,dc=com</code>.<a class="indexterm" id="id556"/>
</p><p>The <code class="literal">unique_attributes</code> directive takes a whitespace-separated list of attributes that the uniqueness overlay will enforce uniqueness constraints. In this example we just want to enforce uniqueness on the UID attribute.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note89"/>Note</h3><p>The behavior of the uniqueness overlay is expected to change in the next version of OpenLDAP (version 2.4). In particular, it will support multiple bases inside a single database.</p></div></div><p>Thus, according to our configuration, no two UID values for any records in the <code class="literal">dc=example,dc=com</code> directory information tree should be identical.</p><p>Now let's see how this overlay works in practice.</p><p>In the discussion of the RefInt overlay, we created the following record:</p><div class="informalexample"><pre class="programlisting">dn: uid=cicero,ou=users,dc=example,dc=com
uid: <span class="strong"><strong>marcus</strong></span>
uid: cicero
sn: Tullius
cn: Marcus Tullius
givenName: Marcus
ou: users
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson</pre></div><p>Note that this record has the UID <code class="literal">marcus</code>, even though this attribute is not used in the DN. Now let's try to add the following record:</p><div class="informalexample"><pre class="programlisting">dn: uid=marcus,ou=users,dc=example,dc=com
uid: marcus
sn: Aurelius
cn: Marcus Aurelius
givenName: Marcus
ou: users<a class="indexterm" id="id557"/>
objectclass: person
objectclass: organizationalperson
objectclass: inetOrgPerson</pre></div><p>This record also uses the UID <code class="literal">marcus</code>. Without the uniqueness overlay, SLAPD would allow both records to have the same UID. This, of course, will cause problems for applications that assume that a Unique ID is really unique—only zero or one results will be returned for a search on the UID attribute.</p><a class="indexterm" id="id558"/><p>But with the uniqueness overlay, as we have configured it, SLAPD will prevent clients from adding a UID value that matches an existing UID value. The uniqueness overlay does this by checking the attributes in <code class="literal">add</code>, <code class="literal">modify</code>, or <code class="literal">modrdn</code> operations. If we try to add the given record for <code class="literal">uid=marcus</code>, we get an error:</p><div class="informalexample"><pre class="programlisting">
$ ldapadd -U matt -f unique-example.ldif
SASL/DIGEST-MD5 authentication started
Please enter your password: 
SASL username: matt
SASL SSF: 128
SASL installing layers

adding new entry "uid=marcus,ou=users,dc=example,dc=com"
<span class="strong"><strong>ldap_add: Constraint violation (19)</strong></span>
<span class="strong"><strong>          additional info: some attributes not unique</strong></span>
</pre></div><p>SLAPD sends back a <span class="strong"><strong>Constraint violation</strong></span> error because the uniqueness overlay will not allow a duplicate UID attribute value. To work around this, we would have to either delete the extra UID attribute from the <code class="literal">uid=cicero</code> record or use a different UID for Marcus Aurelius's record.</p><p>The example configuration we have just seen represents the most typical use of the uniqueness overlay. There are two additional uniqueness directives that provide more complex configurations:</p><p>The first is the <code class="literal">unique_ignore</code> directive. Typically, this is used <span class="emphasis"><em>instead</em></span> of <code class="literal">unique_attributes</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip40"/>Tip</h3><p>While you can use both <code class="literal">unique_attributes</code> and <code class="literal">unique_ignore</code>, it is not recommended because it can cause unexpected behavior. See the man page for more detail: <code class="literal">man</code> <code class="literal">slapo-unique</code>.</p></div></div><p>The <code class="literal">unique_ignore</code> directive takes a whitespace-separated list of attributes that <span class="emphasis"><em>should</em></span> <span class="emphasis"><em>not</em></span> be tested for uniqueness. There are attributes, such as <code class="literal">ou</code>, <code class="literal">sn</code>, and <code class="literal">objectclass</code>, that are likely to be legitimately used more than once in a directory. For example, it is perfectly possible for multiple people in an organization to have the same surname, and thus have identical <code class="literal">sn</code> attribute values.</p><p>But when <code class="literal">unique_attributes</code> is not specified, then by default all <span class="emphasis"><em>non-operational</em></span> <span class="emphasis"><em>attributes</em></span> are assumed to require uniqueness. Consider this example configuration:<a class="indexterm" id="id559"/>
</p><div class="informalexample"><pre class="programlisting">  overlay unique<a class="indexterm" id="id560"/>
  unique_base dc=example,dc=com
  unique_ignore objectclass sn ou description</pre></div><p>According to this configuration, all of the attribute values in the directory information tree except <code class="literal">objectclass</code>, <code class="literal">sn</code>, <code class="literal">ou</code>, and <code class="literal">description</code> will be required to have unique values. Obviously, this configuration is far more restrictive than our first example and it should be used with care.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note90"/>Note</h3><p>Operational parameters—those intended for internal SLAPD use—are not automatically added to the uniqueness list under any circumstances. Doing so might cause hard-to-debug errors that would prevent SLAPD from functioning properly.</p></div></div><p>Finally, there is one additional directive for the unique overlay. The <code class="literal">unique_strict</code> directive, which takes no parameters, can be used to turn on "strict" uniqueness enforcement.</p><p>By default, the uniqueness overlay allows multiple attributes to have empty (null) values. For example, if we enforce uniqueness on the <code class="literal">uid</code> attribute, SLAPD would still allow multiple records to have a UID attribute with an empty value. But this is not always desirable. Under some circumstances, it might be necessary to ensure that no more than one attribute has an empty value. The <code class="literal">unique_strict</code> directive is used for this purpose.</p><p>When the <code class="literal">unique_strict</code> directive is present, the uniqueness overlay will not allow a client to set an attribute value to empty (null) if another instance of the same attribute already exists and already has an empty value.<a class="indexterm" id="id561"/>
</p><p>At this point, you should have a good idea of how to use overlays. We have looked at three different overlays but in the coming chapters we will look at several more.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Summary</h1></div></div></div><p>The focus of this chapter has been on advanced configuration of the SLAPD server. We began by taking a second look at the <code class="literal">slapd.conf</code> file. Then we added an additional database to our directory server, supporting a second directory information tree. From there we looked at some ways of improving SLAPD's performance using directives in the <code class="literal">slapd.conf</code> file, and also tuning the Berkeley DB's <code class="literal">DB_CONFIG</code> file. In the last section we looked at SLAPD's overlay engine, touring three specific overlays.</p><p>By now you should feel comfortable working with the <code class="literal">slapd.conf</code> file as well as using overlays.</p><p>In the next chapter we will examine LDAP schemas, adding a few schemas for new overlays, and then creating our own schema. Later, in Chapter 7, we will expand upon some of the themes in this chapter when we look at the ways to configure multiple OpenLDAP servers to work together.</p></div></body></html>