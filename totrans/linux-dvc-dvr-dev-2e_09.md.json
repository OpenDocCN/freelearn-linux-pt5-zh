["```\nstruct platform_device {\n     const char       *name;\n     u32              id;\n     struct device    dev;\n     u32              num_resources;\n     struct resource *resource;\n     const struct platform_device_id  *id_entry;\n     struct mfd_cell *mfd_cell;\n};\n```", "```\n    dev_set_name(&pdev->dev, \"%s\", pdev->name);\n    ```", "```\n    dev_set_name(&pdev->dev, \"%s.%d.auto\", pdev->name,\n                 <auto_id>);\n    ```", "```\n    dev_set_name(&pdev->dev, \"%s.%d\", pdev->name,\n                 pdev->id);\n    ```", "```\nstruct platform_driver {\n     int (*probe)(struct platform_device *);\n     int (*remove)(struct platform_device *);\n     void (*shutdown)(struct platform_device *);\n     int (*suspend)(struct platform_device *,\n                         pm_message_t state);\n     int (*resume)(struct platform_device *);\n     struct device_driver driver;\n     const struct platform_device_id *id_table;\n     bool prevent_deferred_probe;\n}; \n```", "```\n    int my_pdrv_probe(struct platform_device *pdev)\n    ```", "```\n    static void my_pdrv_remove(struct platform_device *pdev)\n    ```", "```\nint platform_device_register(struct platform_device *pdev)\n```", "```\nstatic struct platform_device my_pdev = {\n    .name           = \"my_drv_name\",\n    .id             = 0,\n    .ressource         = jz4740_udc_resources,\n    .num_ressources    = ARRY_SIZE(jz4740_udc_resources),\n};\nint foo()\n{\n    [...]\n    return platform_device_register(&my_pdev);\n}\n```", "```\nint platform_add_devices(struct platform_device **devs,\n                          int num);\n```", "```\nstruct platform_device *platform_device_alloc(\n                          const char *name, int id);\n```", "```\nint platform_device_add(struct platform_device *pdev);\n```", "```\nvoid platform_device_put(struct platform_device *pdev);\n```", "```\nstatus = platform_device_add(evm_led_dev);\nif (status < 0) {\n     platform_device_put(evm_led_dev);\n[...]\n}\n```", "```\nvoid platform_device_unregister(struct platform_device *pdev)\n```", "```\nfoo {\n    compatible = \"simple-bus\";\n    bar: bar@0 {\n        compatible = \"labcsmart,something\";\n        [...]\n        baz: baz@0 {\n            compatible = \"labcsmart,anotherthing\";\n            [...]\n        }\n    }\n    foz: foz@1 {\n        compatible = \"company,product\";\n        [...]\n    };\n}\n```", "```\nregulators {\n    compatible = \"simple-bus\";\n    #address-cells = <1>;\n    #size-cells = <0>;\n\n    reg_usb_h1_vbus: regulator@0 {\n        compatible = \"regulator-fixed\";\n        reg = <0>;\n        regulator-name = \"usb_h1_vbus\";\n        regulator-min-microvolt = <5000000>;\n        regulator-max-microvolt = <5000000>;\n        enable-active-high;\n        startup-delay-us = <2>; \n        gpio = <&gpio7 12 0>;\n    };\n    reg_panel: regulator@1 {\n        compatible = \"regulator-fixed\";\n        reg = <1>;\n        regulator-name = \"lcd_panel\";\n        enable-active-high;\n         gpio = <&gpio1 2 0>;\n     };\n};\n```", "```\nstruct resource {\n     resource_size_t start;\n     resource_size_t end;\n     const char *name;\n     unsigned long flags;\n};\n```", "```\nstatic struct resource foo_resources[] = {\n     [0] = { /* The first memory region */\n          .start = 0x10000000,\n          .end   = 0x10001000,\n          .flags = IORESOURCE_MEM,\n          .name  = \"mem1\",\n     },\n     [1] = {\n          .start = JZ4740_UDC_BASE_ADDR2,\n          .end   = JZ4740_UDC_BASE_ADDR2 + 0x10000 -1,\n          .flags = IORESOURCE_MEM,\n          .name  = \"mem2\",\n     },\n     [2] = {\n          .start = 90,\n          .end   = 90,\n          .flags = IORESOURCE_IRQ,\n          .name  = \"mc-irq\",\n     },\n};\n```", "```\nstatic struct platform_device foo_pdev = {\n     .name = \"foo-device\",\n     .resource             = foo_resources,\n     .num_ressources = ARRY_SIZE(foo_resources),\n[...]\n};\n```", "```\nstruct platform_device *foo_pdev;\n[...]\nmy_pdev = platform_device_alloc(\"foo-device\", ...);\nif (!my_pdev)\n           return -ENOMEM;\nmy_pdev->resource = foo_resources;\nmy_pdev->num_ressources = ARRY_SIZE(foo_resources);\n```", "```\nstruct resource *platform_get_resource(\n                       struct platform_device *pdev, \n                       unsigned int type, unsigned int n);\nstruct resource *platform_get_resource_byname(\n                      struct platform_device *pdev,\n                      unsigned int type, const char *name);\nint platform_get_irq(struct platform_device *pdev,\n                     unsigned int n);\n```", "```\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n```", "```\nstatic struct foo_low_level foo_ops = {\n     .owner          = THIS_MODULE,\n     .hw_init         = trizeps_pcmcia_hw_init,\n     .socket_state     = trizeps_pcmcia_socket_state,\n     .configure_socket = trizeps_pcmcia_configure_socket,\n     .socket_init     = trizeps_pcmcia_socket_init,\n     .socket_suspend  = trizeps_pcmcia_socket_suspend,\n[...]\n};\n```", "```\nstatic struct platform_device my_device = {\n     .name = \"foo-pdev\",\n     .dev  = {\n          .platform_data   = (void*)&trizeps_pcmcia_ops,\n     },\n     [...]\n};\n```", "```\nint platform_device_add_data(struct platform_device *pdev,\n                        const void *data, size_t size);\n```", "```\nint ret;\n[…]\nret = platform_device_add_data(foo_pdev,\n                  &foo_ops, sizeof(foo_ops));\nif (ret == 0)\n    ret = platform_device_add(trizeps_pcmcia_device);\nif (ret)\n     platform_device_put(trizeps_pcmcia_device);\n```", "```\nvoid *dev_get_platdata(const struct device *dev)\n```", "```\nstruct foo_low_level *my_ops =\n          dev_get_platdata(&pdev->dev);\n```", "```\nint pdrv_probe(struct platform_device *pdev)\n```", "```\nint pdrv_remove(struct platform_device *dev)\n```", "```\nstruct platform_device_id {\n     char name[PLATFORM_NAME_SIZE];\n     kernel_ulong_t driver_data;\n};\n```", "```\nstatic const struct platform_device_id mxs_ssp_ids[] = {\n     {\n          .name = \"imx23-mmc\",\n          .driver_data = IMX23_SSP,\n     }, {\n          .name = \"imx28-mmc\",\n          .driver_data = IMX28_SSP,\n     }, {\n          /* sentinel */\n     }\n};\nMODULE_DEVICE_TABLE(platform, mxs_ssp_ids);\n```", "```\nstatic const struct of_device_id mxs_mmc_dt_ids[] = {\n    {\n        .compatible = \"fsl,imx23-mmc\",\n        .data = (void *) IMX23_SSP,\n    },{ \n        .compatible = \"fsl,imx28-mmc\",\n        .data = (void *) IMX28_SSP,\n    }, {\n        /* sentinel */ \n    }\n};\nMODULE_DEVICE_TABLE(of, mxs_mmc_dt_ids);\n```", "```\nstatic int mxs_mmc_probe(struct platform_device *pdev)\n{\n    const struct of_device_id *of_id =\n        of_match_device(mxs_mmc_dt_ids, &pdev->dev);\n    struct device_node *np = pdev->dev.of_node;\n[...]\n}\n```", "```\nstatic struct platform_driver imx_uart_platform_driver = {\n    .probe = imx_uart_probe,\n    .remove = imx_uart_remove,\n    .id_table = imx_uart_devtype,\n    .driver = {\n        .name = \"imx-uart\",\n        .of_match_table = imx_uart_dt_ids,\n    },\n};\n```", "```\nint platform_driver_register(struct platform_driver *drv);\nvoid platform_driver_unregister(struct platform_driver *);\nint platform_driver_probe(struct platform_driver *drv,\n                  int (*probe)(struct platform_device *))\n```", "```\n    ret = platform_driver_probe(&mypdrv, my_pdrv_probe);\n    ```", "```\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\nstatic int my_pdrv_probe (struct platform_device *pdev)\n{\n     pr_info(\"Hello! device probed!\\n\");\n     return 0;\n}\nstatic void my_pdrv_remove(struct platform_device *pdev)\n{\n     pr_info(\"good bye reader!\\n\");\n}\nstatic struct platform_driver mypdrv = {\n     .probe     = my_pdrv_probe,\n     .remove     = my_pdrv_remove,\n[...]\n};\nstatic int __init foo_init(void)\n{\n     [...] /* My init code */\n     return platform_driver_register(&mypdrv);\n}\nmodule_init(foo_init);\n\nstatic void __exit foo_cleanup(void)\n{\n     [...] /* My clean up code */\n     platform_driver_unregister(&my_driver);\n}\nmodule_exit(foo_cleanup);\n```", "```\n[...]\nstatic int my_pdrv_probe(struct platform_device *pdev)\n{\n     [...]\n}\nstatic void my_pdrv_remove(struct platform_device *pdev)\n{\n     [...]\n}\nstatic struct platform_driver mypdrv = {\n     [...]\n};\nmodule_platform_driver(mypdrv);\n```", "```\ndemo {\n    compatible = \"simple-bus\";\n    demo_pdev: demo_pdev@0 {\n        compatible = \"labcsmart,demo-pdev\";\n        reg = <0x02008000 0x4000>;\n        interrupts = <0 31 IRQ_TYPE_LEVEL_HIGH>;\n    };\n};\n```", "```\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#define DEV_BASE 0x02008000\n#define PDEV_IRQ 31\nstatic struct resource pdev_resource[] = {\n    [0] = {\n        .start = DEV_BASE,\n        .end   = DEV_BASE + 0x4000,\n        .flags = IORESOURCE_MEM,\n    },\n    [1] = {\n        .start = PDEV_IRQ,\n        .end   = PDEV_IRQ,\n        .flags = IORESOURCE_IRQ,\n    },\n};\n```", "```\nstruct platform_device demo_pdev = {\n    .name        = \"demo_pdev\",\n    .id          = 0,\n    .num_resources = ARRAY_SIZE(pdev_resource),\n    .resource      = pdev_resource,\n    /*.dev  = {\n     *   .platform_data  = (void*)&big_struct_1,\n     *}*/,\n};\n```", "```\nstatic int demo_pdev_init()\n{\n    return platform_device_register(&demo_pdev);\n}\nmodule_init(demo_pdev_init);\nstatic void demo_pdev_exit()\n{\n    platform_device_unregister(&demo_pdev);\n}\nmodule_exit(demo_pdev_exit);\n```", "```\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n```", "```\nstatic const struct of_device_id labcsmart_dt_ids[] = {\n    {\n        .compatible = \" labcsmart,demo-pdev\",\n        /* .data = (void *)&big_struct_1, */\n    },{ \n        .compatible = \" labcsmart,other-pdev \",\n        /* .data = (void *) &big_struct_2, */\n    }, {\n        /* sentinel */ \n    }\n};\nMODULE_DEVICE_TABLE(of, labcsmart_dt_ids);\n```", "```\nstatic const struct platform_device_id labcsmart_ids[] = {\n     {\n          .name = \"demo-pdev\",\n          /*.driver_data = &big_struct_1,*/\n     }, {\n           .name = \"other-pdev\",\n           /*.driver_data = &big_struct_2,*/\n     }, {\n           /* sentinel */\n     }\n};\nMODULE_DEVICE_TABLE(platform, labcsmart_ids);\n```", "```\nstatic u32 *reg_base;\nstatic struct resource *res_irq;\nstatic int demo_pdrv_probe(struct platform_device *pdev)\n{\n    struct resource *regs;\n    regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    if (!regs) {\n        dev_err(&pdev->dev, \"could not get IO memory\\n\");\n        return -ENXIO;\n    }\n    /* map the base register */ \n    reg_base = devm_ioremap(&pdev->dev, regs->start,\n                              resource_size(regs));\n    if (!reg_base) {\n        dev_err(&pdev->dev, \"could not remap memory\\n\");\n        return 0;\n    }\n    res_irq = platform_get_resource(pdev,\n                                   IORESOURCE_IRQ, 0);\n    /* we could have used\n     * irqnum = platform_get_irq(pdev, 0); */\n    devm_request_irq(&pdev->dev, res_irq->start,\n                   top_half, IRQF_TRIGGER_FALLING,\n                   \"demo-pdev\", NULL);\n[...]\n     return 0;\n}\n```", "```\nstruct device_node *np = pdev->dev.of_node;\nconst struct of_device_id *of_id =\n        of_match_device(labcsmart_dt_ids, &pdev->dev);\nstruct big_struct *pdata_struct = (big_struct*)of_id->data;\n```", "```\nstruct big_struct *pdata_struct =\n                 (big_struct*)dev_get_platdata(&pdev->dev);\n```", "```\nint demo_pdrv_remove(struct platform_device *dev)\n{\n    free_irq(res_irq->start, NULL);\n    iounmap(reg_base);\n    return 0;\n}\n```", "```\nstatic struct platform_driver demo_driver = {\n    .probe     = demo_pdrv_probe,\n    /* .remove = demo_pdrv_remove, */\n    .driver    = {\n        .owner    = THIS_MODULE,\n        .name    = \"demo_pdev\",\n    },\n};\nmodule_platform_driver(demo_driver);\n```"]