- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Deploying Applications with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 部署应用程序
- en: Whether you are a seasoned system administrator managing containerized applications
    or a DevOps engineer automating app orchestration workflows, **Kubernetes** could
    be your platform of choice. This chapter will introduce you to Kubernetes and
    will guide you through the basic process of building and configuring a **Kubernetes
    cluster**. We’ll use Kubernetes to run and scale a simple application in a secure
    and highly available environment. You will also learn how to interact with Kubernetes
    using the **command-line** **interface** (**CLI**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是管理容器化应用程序的资深系统管理员，还是自动化应用编排工作流的 DevOps 工程师，**Kubernetes** 都可能是你首选的平台。本章将介绍
    Kubernetes，并指导你完成构建和配置 **Kubernetes 集群** 的基本过程。我们将使用 Kubernetes 在一个安全且高可用的环境中运行和扩展一个简单的应用程序。你还将学会如何通过**命令行界面**（**CLI**）与
    Kubernetes 进行交互。
- en: By the end of this chapter, you’ll learn how to install, configure, and manage
    a Kubernetes cluster on-premises. We’ll also show you how to deploy and scale
    an application using Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会如何在本地环境中安装、配置和管理 Kubernetes 集群。我们还将向你展示如何使用 Kubernetes 部署和扩展应用程序。
- en: 'Here’s a brief outline of the topics we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将要覆盖的主题的简要提纲：
- en: Introducing Kubernetes architecture and the API object model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes 架构和 API 对象模型
- en: Installing and configuring Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Kubernetes
- en: Working with Kubernetes using the `kubectl` command-line tool and deploying
    applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 命令行工具与 Kubernetes 交互并部署应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You should be familiar with Linux and the CLI in general. A good grasp of **TCP/IP
    networking** and **Docker** containers would go a long way in making your journey
    of learning Kubernetes easier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉 Linux 和一般的命令行界面（CLI）。如果你对**TCP/IP 网络**和**Docker** 容器有一定了解，这将大大简化你学习 Kubernetes
    的过程。
- en: 'You will also need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要以下内容：
- en: A local desktop machine with a Linux distribution of your choice to install
    and experiment with the CLI tools used in this chapter. We will use both Debian
    and Ubuntu LTS.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台本地桌面机器，安装你选择的 Linux 发行版，以便安装和实验本章中使用的 CLI 工具。我们将使用 Debian 和 Ubuntu LTS。
- en: A powerful desktop system with at least 8 CPU cores and at least 16 GB of RAM
    will allow you to replicate the necessary environment on your desktop as we’ll
    be devoting a relatively large section to building a Kubernetes cluster using
    VMs.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台性能强大的桌面系统，至少拥有 8 个 CPU 核心和至少 16 GB 内存，将使你能够在桌面上复制所需的环境，因为我们将花费相对较多的篇幅讲解如何使用虚拟机构建
    Kubernetes 集群。
- en: A desktop hypervisor.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个桌面虚拟化管理程序。
- en: Now, let’s start our journey together to discover Kubernetes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一起开始探索 Kubernetes 的旅程。
- en: Introducing Kubernetes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes
- en: 'Kubernetes is an open source **container orchestrator** initially developed
    by Google. A container orchestrator is a piece of software that automatically
    manages (including provisioning, deployment, and scaling) containerized applications.
    Assuming an application uses containerized microservices, a container orchestration
    system provides the following features:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的**容器编排工具**，最初由谷歌开发。容器编排工具是自动管理（包括资源配置、部署和扩展）容器化应用程序的软件。如果一个应用程序使用了容器化的微服务，容器编排系统将提供以下功能：
- en: '**Elastic orchestration (autoscaling)**: This involves automatically starting
    and stopping application services (containers) based on specific requirements
    and conditions – for example, launching multiple web server instances with an
    increasing number of requests and eventually terminating servers when the number
    of requests drops below a certain threshold'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性编排（自动扩展）**：这包括根据特定的需求和条件，自动启动和停止应用程序服务（容器）——例如，当请求数量增加时，启动多个 Web 服务器实例，最终当请求数量降到某个阈值以下时终止服务器。'
- en: '**Workload management**: This involves optimally deploying and distributing
    application services across the underlying cluster to ensure mandatory dependencies
    and redundancy – for example, running a web server endpoint on each cluster node
    for high availability'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作负载管理**：这涉及到将应用服务最佳地部署和分配到底层集群，以确保必要的依赖关系和冗余——例如，在每个集群节点上运行 Web 服务器端点，以保证高可用性。'
- en: '**Infrastructure abstraction**: This involves providing container runtime,
    networking, and load-balancing capabilities – for example, distributing the load
    among multiple web server containers and autoconfiguring the underlying network
    connectivity with a database app container'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施抽象**：这涉及提供容器运行时、网络和负载均衡功能——例如，将负载分配到多个 Web 服务器容器之间，并自动配置与数据库应用容器的底层网络连接。'
- en: '**Declarative configuration**: This involves describing and ensuring the desired
    state of a multi-tiered application – for example, a web server should be ready
    for serving requests only when the database backend is up and running, and the
    underlying storage is available'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式配置**：这涉及描述并确保多层应用的期望状态——例如，只有在数据库后端运行且底层存储可用时，Web 服务器才应准备好处理请求。'
- en: A classic example of workload orchestration is a video-on-demand streaming service.
    With a popular new TV show in high demand, the number of streaming requests would
    significantly exceed the average during a regular season. With **Kubernetes**,
    we could scale out the number of web servers based on the volume of streaming
    sessions. We could also control the possible scale-out of some of the middle-tier
    components, such as database instances (serving the authentication requests) and
    storage cache (serving the streams). When the TV show goes out of fashion, and
    the number of requests drops significantly, Kubernetes terminates the surplus
    instances, automatically reducing the application deployment’s footprint and,
    consequently, the underlying costs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经典的工作负载编排示例是视频点播流媒体服务。在一部受欢迎的新电视节目需求量很大的情况下，流媒体请求的数量将显著超过常规季节的平均水平。使用**Kubernetes**，我们可以根据流媒体会话的数量扩展
    web 服务器的数量。我们还可以控制某些中间层组件的可能扩展，例如数据库实例（处理身份验证请求）和存储缓存（处理视频流）。当该电视节目过时且请求数量显著下降时，Kubernetes
    会终止多余的实例，自动减少应用部署的占用空间，并因此降低底层成本。
- en: 'Here are some key benefits of deploying applications with Kubernetes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Kubernetes 部署应用的一些关键好处：
- en: '**Speedy deployment**: Application containers are created and launched relatively
    fast, using either a **declarative** or **imperative** configuration model (as
    we’ll see in the *Introducing the Kubernetes object model* section later in this
    chapter)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速部署**：应用容器的创建和启动相对较快，使用**声明式**或**命令式**配置模型（我们将在本章后面“介绍 Kubernetes 对象模型”一节中看到）。'
- en: '**Quick iterations**: Application upgrades are relatively straightforward,
    with the underlying infrastructure simply seamlessly replacing the related container'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速迭代**：应用升级相对简单，底层基础设施只需无缝地替换相关容器。'
- en: '**Rapid recovery**: If an application crashes or becomes unavailable, Kubernetes
    automatically restores the application to the desired state by replacing the related
    container'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速恢复**：如果应用崩溃或无法使用，Kubernetes 会通过替换相关容器自动将应用恢复到期望状态。'
- en: '**Reduced operation costs**: The containerized environment and infrastructure
    abstraction of Kubernetes yields minimal administration and maintenance efforts
    with relatively low resources for running applications'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低运营成本**：Kubernetes 的容器化环境和基础设施抽象带来了最小的管理和维护工作，并且运行应用所需的资源相对较低。'
- en: Now that we have introduced Kubernetes, let’s look at its basic operating principles
    next.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了 Kubernetes，让我们接下来看看它的基本操作原理。
- en: Understanding the Kubernetes architecture
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 架构
- en: 'There are three major concepts at the core of the working model of Kubernetes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 工作模型的核心有三个主要概念：
- en: '**Declarative configuration or desired state**: This concept describes the
    overall application state and microservices, deploying the required containers
    and related resources, including network, storage, and load balancers, to achieve
    a running functional state of the application'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明式配置或期望状态**：这个概念描述了整体应用状态和微服务，部署所需的容器和相关资源，包括网络、存储和负载均衡器，以实现应用的运行功能状态。'
- en: '**Controllers or controller loops**: This monitors the desired state of the
    system and takes corrective action when needed, such as replacing a failed application
    container or adding additional resources for scale-out workloads'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器或控制器循环**：这会监控系统的期望状态，并在需要时采取纠正措施，例如替换失败的应用容器或为扩展工作负载添加额外资源。'
- en: '**API object model**: This model represents the actual implementation of the
    desired state, using various configuration objects and the interaction – the **application
    programming interface** (**API**) – between these objects'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API对象模型**：该模型表示期望状态的实际实现，使用各种配置对象以及这些对象之间的交互——即**应用程序编程接口**（**API**）'
- en: For a better grasp of the internals of Kubernetes, we need to take a closer
    look at the Kubernetes object model and related API. Also, you can check out *Figure
    16**.1* for a visual explanation of the Kubernetes (cluster) architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Kubernetes的内部，我们需要更深入地了解Kubernetes对象模型和相关API。此外，您可以查看*图16.1*，以获取Kubernetes（集群）架构的可视化解释。
- en: Introducing the Kubernetes object model
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Kubernetes对象模型
- en: The Kubernetes architecture defines a collection of objects representing the
    desired state of a system. An **object**, in this context, is a programmatic term
    to describe the behavior of a subsystem. Multiple objects interact with one another
    via the API, shaping the desired state over time. In other words, the Kubernetes
    object model is the programmatic representation of the desired state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes架构定义了一组表示系统期望状态的对象。在这个上下文中，**对象**是一个程序化术语，用来描述子系统的行为。多个对象通过API相互交互，随着时间推移塑造期望状态。换句话说，Kubernetes对象模型是期望状态的程序化表示。
- en: 'So, what are these objects in Kubernetes? We’ll briefly enumerate some of the
    more important ones and further elaborate on each in the following sections: API
    server, pods, controllers, services, and storage.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Kubernetes中的这些对象是什么呢？我们将简要列举一些更重要的对象，并在接下来的章节中进一步详细阐述它们：API服务器、Pods、控制器、服务和存储。
- en: 'We use these API objects to configure the system’s state, using either a declarative
    or imperative model:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这些API对象来配置系统的状态，使用声明式或命令式模型：
- en: With a **declarative configuration model**, we describe the state of the system,
    usually with a configuration file or manifest (in YAML or JSON format). Such a
    configuration may include and deploy multiple API objects and regard the system
    as a whole.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**声明式配置模型**，我们描述系统的状态，通常通过配置文件或清单（YAML或JSON格式）。这样的配置可以包含并部署多个API对象，并将系统视为一个整体。
- en: The **imperative configuration model** uses individual commands to configure
    and deploy specific API objects, typically acting on a single target or subsystem.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令式配置模型**使用单独的命令来配置和部署特定的API对象，通常作用于单一目标或子系统。'
- en: Let’s look at the API server first – the central piece in the Kubernetes object
    model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看API服务器——Kubernetes对象模型中的核心部分。
- en: Introducing the API server
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍API服务器
- en: 'The API server is the core hub of the Kubernetes object model, acting as a
    management endpoint for the desired state of the system. The API server exposes
    an HTTP REST interface using JSON payloads. It is accessible in two ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器是Kubernetes对象模型的核心枢纽，作为管理端点，表示系统的期望状态。API服务器通过HTTP REST接口暴露JSON负载。它可以通过两种方式访问：
- en: '**Internally**: It is accessed internally by other API objects'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部**：由其他API对象在内部访问'
- en: '**Externally**: It is accessed externally by configuration and management workflows'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部**：通过配置和管理工作流在外部访问'
- en: The API server is essentially the gateway of interaction with the Kubernetes
    cluster, both from the outside and within. A Kubernetes cluster is a framework
    of different nodes that run containerized applications. The cluster is the basic
    running mode of Kubernetes itself. More on the Kubernetes cluster will be provided
    in the *Anatomy of a Kubernetes cluster* section. A system administrator connects
    to the API server endpoint to configure and manage a Kubernetes cluster, typically
    via a CLI. Internally, Kubernetes API objects connect to the API server to provide
    an update of their state. In return, the API server may further adjust the internal
    configuration of the API objects toward the desired state.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器本质上是与Kubernetes集群交互的网关，既可以从外部也可以从内部访问。Kubernetes集群是由不同节点组成的框架，节点运行容器化的应用程序。集群是Kubernetes自身的基本运行模式。关于Kubernetes集群的更多内容将在*Kubernetes集群解剖*部分中提供。系统管理员通过CLI连接到API服务器端点，配置和管理Kubernetes集群。内部，Kubernetes
    API对象连接到API服务器，以提供其状态的更新。作为回报，API服务器可能会进一步调整API对象的内部配置，以实现期望状态。
- en: The API objects are the building blocks of the internal configuration or desired
    state of a Kubernetes cluster. Let’s look at a few of these API objects next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: API对象是Kubernetes集群内部配置或期望状态的构建模块。接下来，我们将介绍一些这些API对象。
- en: Introducing pods
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍Pods
- en: A **pod** represents the basic working unit in Kubernetes, running as a single-
    or multi-container application. A pod is also known as the **unit of scheduling**
    in Kubernetes. In other words, containers within the same pod are guaranteed to
    be deployed together on the same cluster node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pod** 代表 Kubernetes 中的基本工作单元，作为单容器或多容器应用程序运行。Pod 也被称为 Kubernetes 中的**调度单元**。换句话说，同一
    Pod 内的容器保证会一起部署在同一个集群节点上。'
- en: 'A pod essentially represents a microservice (or a service) within the application’s
    service mesh. Considering the classic example of a web application, we may have
    the following pods running in the cluster:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 本质上代表了应用程序服务网格中的一个微服务（或服务）。以经典的 Web 应用为例，我们可能在集群中运行以下 Pod：
- en: Web server (Nginx)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务器（Nginx）
- en: Authentication (Vault)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份认证（Vault）
- en: Database (PostgreSQL)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库（PostgreSQL）
- en: Storage (NAS)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储（NAS）
- en: Each of these services (or applications) runs within their pod. Multiple pods
    of the same application (for example, a web server) make up a **ReplicaSet**.
    We’ll look at ReplicaSets closer in the *Introducing* *controllers* section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务（或应用程序）都在其 Pod 中运行。相同应用程序的多个 Pod（例如，Web 服务器）组成一个**ReplicaSet**。我们将在*引入*
    *控制器* 部分更详细地了解 ReplicaSets。
- en: 'Some essential features of pods are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 的一些基本特性如下：
- en: They have an **ephemeral nature**. Once a pod is terminated, it is gone for
    good. No pod ever gets redeployed in Kubernetes. Consequently, pods don’t persist
    in any state unless they use persistent storage or a local volume to save their
    data.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有**短暂的特性**。一旦 Pod 被终止，它就永远消失。在 Kubernetes 中，Pod 永远不会被重新部署。因此，除非 Pod 使用持久存储或本地卷来保存数据，否则它们的状态不会持久存在。
- en: Pods are an **atomic unit** – they are either deployed or not. For a single-container
    pod, atomicity is almost a given. For multi-container pods, atomicity means that
    a pod is deployed only when each of the constituent containers is deployed. If
    any of the containers fail to deploy, the pod will not be deployed, and hence
    there’s no pod. If one of the containers within a running multi-container pod
    fails, the whole pod is terminated.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 是一个**最小单位**——它们要么被部署，要么不被部署。对于单容器的 Pod，原子性几乎是理所当然的。对于多容器的 Pod，原子性意味着只有当每个容器都成功部署时，Pod
    才会被部署。如果任何一个容器部署失败，Pod 就不会被部署，因此没有 Pod。如果运行中的多容器 Pod 中的某个容器失败，整个 Pod 将会被终止。
- en: Kubernetes uses **probes** (such as liveliness and readiness) to monitor the
    health of an application inside a pod. This is because a pod could be deployed
    and running, but that doesn’t necessarily mean the application or service within
    the pod is healthy. For example, a web server pod can have a probe that checks
    a specific URL and decides whether it’s healthy based on the response.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 使用**探针**（如存活性探针和就绪探针）来监控 Pod 中应用程序的健康状况。这是因为 Pod 可能已经被部署并运行，但这并不一定意味着
    Pod 内的应用程序或服务是健康的。例如，Web 服务器 Pod 可能有一个探针检查特定的 URL，并根据响应来判断其健康状态。
- en: Kubernetes tracks the state of pods using controllers. Let’s look at controllers
    next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用控制器跟踪 Pod 的状态。接下来我们来看看控制器。
- en: Introducing controllers
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入控制器
- en: '**Controllers** in Kubernetes are control loops responsible for keeping the
    system in the desired state or bringing the system closer to the desired state
    by constantly watching the state of the cluster. For example, a controller may
    detect that a pod is not responding and request the deployment of a new pod while
    terminating the old one. Let’s look at two key types of controllers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的**控制器**是控制循环，负责保持系统处于期望状态，或通过不断监控集群的状态使系统更接近期望状态。例如，控制器可能会检测到一个
    Pod 没有响应，并请求部署一个新的 Pod，同时终止旧的 Pod。我们来看看两种关键的控制器类型：
- en: A controller may also add or remove pods of a specific type to and from a collection
    of pod replicas. Such controllers are called **ReplicaSets**, and their responsibility
    is to accommodate a particular number of pod replicas based on the current state
    of the application. For example, suppose an application requires three web server
    pods, and one of them becomes unavailable (due to a failed probe). In that case,
    the ReplicaSet controller ensures that the failed pod is deleted, and a new one
    takes its place.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器还可以将特定类型的 Pod 添加到或从 Pod 副本集合中移除。这种控制器被称为**ReplicaSets**，它们的责任是根据应用程序当前的状态容纳特定数量的
    Pod 副本。例如，假设一个应用程序需要三个 Web 服务器 Pod，而其中一个由于探针失败变得不可用。在这种情况下，ReplicaSet 控制器确保删除失败的
    Pod，并用一个新的 Pod 替代它。
- en: When deploying applications in Kubernetes, we usually don’t use ReplicaSets
    directly to create pods. We use the `v1`) with several pods, all running version
    1 of our application, and we want to upgrade them to version 2\. Remember, pods
    cannot be regenerated or upgraded. Instead, we’ll define a second ReplicaSet (`v2`),
    creating the version 2 pods. The Deployment controller will tear down the `v1`
    ReplicaSet and bring up `v2`. Kubernetes performs the rollout seamlessly, with
    minimal to no disruption of service. The Deployment controller manages the transition
    between the `v1` and `v2` ReplicaSets and even rolls back the transition if needed.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中部署应用时，我们通常不会直接使用 ReplicaSet 来创建 Pod。我们使用 `v1` 来创建几个运行应用版本 1 的
    Pod，我们希望将它们升级到版本 2。记住，Pod 无法重新生成或升级。相反，我们将定义第二个 ReplicaSet（`v2`），创建版本 2 的 Pod。Deployment
    控制器会拆除 `v1` ReplicaSet 并启动 `v2`。Kubernetes 会无缝地执行发布，几乎没有服务中断。Deployment 控制器管理
    `v1` 和 `v2` ReplicaSet 之间的过渡，并在需要时回滚过渡。
- en: There are many other controller types in Kubernetes, and we encourage you to
    explore them at [https://kubernetes.io/docs/concepts/workloads/controllers/](https://kubernetes.io/docs/concepts/workloads/controllers/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中还有许多其他类型的控制器，我们鼓励你在 [https://kubernetes.io/docs/concepts/workloads/controllers/](https://kubernetes.io/docs/concepts/workloads/controllers/)
    上探索它们。
- en: As applications scale-out or terminate, the related pods are deployed or removed.
    Services provide access to the dynamic and transient world of pods. We’ll look
    at Services next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用的扩展或终止，相关的 Pod 会被部署或移除。服务提供对动态且短暂的 Pod 世界的访问。接下来我们将讨论服务。
- en: Introducing Services
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入服务
- en: '**Services** provide persistent access to the applications running in pods.
    It is the Services’ responsibility to ensure that the pods are accessible by routing
    the traffic to the corresponding application endpoints. In other words, Services
    provide network abstraction for communicating with pods through IP addresses,
    routing, and DNS resolution. As pods are deployed or terminated based on the system’s
    desired state, Kubernetes dynamically updates the Service endpoint of the pods,
    with minimal to no disruption in terms of accessing the related applications.
    As users and applications access the Service endpoint’s persistent IP address,
    the Service will ensure that the routing information is up to date and traffic
    is exclusively routed to the running and healthy pods. Services can also be leveraged
    to load-balance the application traffic between pods and scale pods up or down
    based on demand.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**提供对运行在 Pod 中应用的持久访问。服务的责任是通过将流量路由到相应的应用端点来确保 Pod 可访问。换句话说，服务通过 IP 地址、路由和
    DNS 解析为与 Pod 的通信提供了网络抽象。由于 Pod 会根据系统的期望状态进行部署或终止，Kubernetes 会动态更新 Pod 的服务端点，几乎不会中断访问相关应用。随着用户和应用访问服务端点的持久
    IP 地址，服务将确保路由信息是最新的，并且流量仅会路由到正在运行且健康的 Pod。服务还可以用于在 Pod 之间进行负载均衡，根据需求扩展或缩减 Pod
    数量。'
- en: So far, we have looked at Kubernetes API objects controlling the deployment,
    access, and life cycle of application Services. What about the persistent data
    that applications require? We’ll look at the Kubernetes storage next.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了控制应用服务部署、访问和生命周期的 Kubernetes API 对象。那么，应用所需的持久数据呢？接下来我们将讨论 Kubernetes
    存储。
- en: Introducing storage
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入存储
- en: Kubernetes provides various storage types for applications running within the
    cluster. The most common are **volumes** and **persistent volumes**. Due to the
    ephemeral nature of pods, application data stored within a pod using volumes is
    lost when the pod is terminated. Persistent volumes are defined and managed at
    the Kubernetes cluster level, and they are independent of pods. Applications (pods)
    requiring a persistent state would reserve a persistent volume (of a specific
    size), using a **persistent volume claim**. When a pod using a persistent volume
    terminates, the new pod replacing the old one retrieves the current state from
    the persistent volume and will continue using the underlying storage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 为集群内运行的应用提供了多种存储类型。最常见的存储类型是 **卷** 和 **持久卷**。由于 Pod 的短暂性，通过卷在 Pod
    中存储的应用数据会在 Pod 终止时丢失。持久卷是在 Kubernetes 集群级别定义和管理的，且独立于 Pod。需要持久状态的应用（Pod）会保留一个持久卷（特定大小），通过
    **持久卷声明** 来使用。当使用持久卷的 Pod 终止时，替代旧 Pod 的新 Pod 会从持久卷中检索当前状态，并继续使用底层存储。
- en: For more information on Kubernetes storage types, please refer to [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如需了解更多关于 Kubernetes 存储类型的信息，请参考 [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/)。
- en: Now that we are familiar with the Kubernetes API object model, let’s quickly
    go through the architecture of a Kubernetes cluster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Kubernetes API 对象模型，让我们快速浏览一下 Kubernetes 集群的架构。
- en: The anatomy of a Kubernetes cluster
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 集群的结构
- en: 'A Kubernetes cluster consists of one **Control Plane** (**CP**) **node** and
    one or more **worker nodes**. The following diagram presents a high-level view
    of the Kubernetes architecture:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Kubernetes 集群由一个 **控制平面**（**CP**）**节点**和一个或多个 **工作节点**组成。下图展示了 Kubernetes
    架构的高层次视图：
- en: '![Figure 16.1 – Kubernetes cluster architecture](img/B19682_16_01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – Kubernetes 集群架构](img/B19682_16_01.jpg)'
- en: Figure 16.1 – Kubernetes cluster architecture
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – Kubernetes 集群架构
- en: The components of a Kubernetes cluster that are shown in the preceding figure
    are divided into the worker node and CP node as the two major components. The
    Worker nodes have different components, such as the container runtime, kubelet,
    and kube-proxy, and the CP node has the API server, the controller manager, and
    the scheduler. All of these components will be discussed in detail in the following
    sections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图示中的 Kubernetes 集群组件被划分为工作节点和 CP 节点这两个主要部分。工作节点具有不同的组件，如容器运行时、kubelet 和 kube-proxy，而
    CP 节点则有 API 服务器、控制器管理器和调度器。所有这些组件将在后续部分详细讨论。
- en: First, let’s look at the Kubernetes cluster nodes shown in the preceding image
    in some detail next, starting with the CP node.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们详细看看前面图示中的 Kubernetes 集群节点，从 CP 节点开始。
- en: Introducing the Kubernetes CP
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes CP
- en: 'The **Kubernetes CP** provides essential Services for deploying and orchestrating
    application workloads, and it runs on a dedicated node in the Kubernetes cluster
    – the CP node. This node, also known as the **master node**, implements the core
    components of a Kubernetes cluster, such as resource scheduling and monitoring.
    It’s also the primary access point for cluster administration. Here are the key
    subsystems of a CP node:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes CP** 提供了部署和编排应用工作负载所需的基本服务，并且运行在 Kubernetes 集群中的专用节点——CP 节点上。这个节点，也称为
    **主节点**，实现了 Kubernetes 集群的核心组件，如资源调度和监控。它还是集群管理的主要访问点。以下是 CP 节点的关键子系统：'
- en: '**API server**: The central communication hub between Kubernetes API objects;
    it also provides the cluster’s management endpoint accessible either via CLI or
    the Kubernetes web administration console (dashboard)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器**：Kubernetes API 对象之间的中央通信枢纽；它还提供集群管理端点，可以通过命令行界面（CLI）或 Kubernetes
    Web 管理控制台（仪表板）访问。'
- en: '**Scheduler**: This decides when and which nodes to deploy the pods on, depending
    on resource allocation and administrative policies'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：根据资源分配和管理策略决定何时以及将哪些节点部署到 pod 上。'
- en: '**Controller manager**: This maintains the control loops, monitoring and shaping
    the desired state of the system'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器管理器**：它维护控制循环，监控并塑造系统的期望状态。'
- en: '**etcd**: Also known as the **cluster store**, this is a highly available persisted
    database, maintaining the state of the Kubernetes cluster and related API objects;
    the information in etcd is stored as key-value pairs'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：也称为 **集群存储**，这是一个高度可用的持久化数据库，维护 Kubernetes 集群及相关 API 对象的状态；etcd 中的信息以键值对的形式存储。'
- en: '`kubectl`: The primary administrative CLI for managing and interacting with
    the Kubernetes cluster; `kubectl` communicates directly with the API server, and
    it may connect remotely to a cluster'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`：用于管理和与 Kubernetes 集群交互的主要命令行工具；`kubectl` 直接与 API 服务器通信，并可以远程连接到集群。'
- en: A detailed architectural overview of the Kubernetes CP is beyond the scope of
    this chapter. You may explore the related concepts in more detail at [https://kubernetes.io/docs/concepts/architecture/](https://kubernetes.io/docs/concepts/architecture/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CP 的详细架构概述超出了本章的范围。你可以在 [https://kubernetes.io/docs/concepts/architecture/](https://kubernetes.io/docs/concepts/architecture/)
    上深入探索相关概念。
- en: Next, let’s take a brief look at the Kubernetes node – the workhorse of a Kubernetes
    cluster.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要了解一下 Kubernetes 节点——Kubernetes 集群的“工作马”。
- en: Introducing the Kubernetes nodes
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 Kubernetes 节点
- en: In a Kubernetes cluster, the **nodes** – also referred to as **worker nodes**
    – run the actual application pods and maintain their full life cycle. Nodes provide
    the compute capacity of Kubernetes and ensure that the workloads are uniformly
    distributed across the cluster when deploying and running pods. Nodes can be configured
    either as physical (bare metal) or VMs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中，**节点**——也称为 **工作节点**——运行实际的应用程序 Pods 并维护它们的完整生命周期。节点提供 Kubernetes
    的计算能力，并确保在部署和运行 Pods 时，工作负载均匀地分布在集群中。节点可以配置为物理（裸金属）或虚拟机（VM）。
- en: 'Let’s enumerate the key elements of a Kubernetes node:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举 Kubernetes 节点的关键元素：
- en: '**Kubelet**: This processes CP requests (from the scheduler) to deploy and
    start application pods; the kubelet also monitors the node and pod state, reporting
    the related changes to the API server'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubelet**：处理调度器发送的 CP 请求，用于部署和启动应用程序 Pods；Kubelet 还监视节点和 Pod 的状态，将相关变化报告给
    API 服务器。'
- en: '**Kube-Proxy**: Dynamically configures the virtual networking environment for
    the applications running in the pods; it routes the network traffic, provides
    load balancing, and maintains the IP addresses of Services and pods'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kube-Proxy**：动态配置在 Pods 中运行的应用程序的虚拟网络环境；它负责路由网络流量、提供负载均衡，并维护 Services 和 Pods
    的 IP 地址。'
- en: '`containerd` and Docker)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containerd` 和 Docker)'
- en: All the preceding Services run on *each* node in the Kubernetes cluster, including
    the CP node. These components in the CP are required by special-purpose pods,
    providing specific CP Services, such as DNS, ingress (load balancing), and dashboard
    (web console).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的所有服务都会在 Kubernetes 集群中的 *每个* 节点上运行，包括 CP 节点。这些 CP 中的组件是由专用 Pods 提供的，提供特定的
    CP 服务，例如 DNS、Ingress（负载均衡）和 Dashboard（Web 控制台）。
- en: For more information on Kubernetes nodes and related architectural concepts,
    please visit [https://kubernetes.io/docs/concepts/architecture/nodes/](https://kubernetes.io/docs/concepts/architecture/nodes/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 Kubernetes 节点和相关架构概念的信息，请访问 [https://kubernetes.io/docs/concepts/architecture/nodes/](https://kubernetes.io/docs/concepts/architecture/nodes/)。
- en: Now that we have become familiar with some of the key concepts and cluster components,
    let’s get ready to install and configure Kubernetes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了一些关键概念和集群组件，让我们准备好安装和配置 Kubernetes。
- en: Installing and configuring Kubernetes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Kubernetes
- en: Before installing or using Kubernetes, you have to decide on the infrastructure
    you’ll use, whether that be on-premises or public cloud. Second, you’ll have to
    choose between an **Infrastructure-as-a-Service** (**IaaS**) or a **Platform-as-a-Service**
    (**PaaS**) model. With IaaS, you’ll have to install, configure, manage, and maintain
    the Kubernetes cluster yourself, either on physical (bare metal) or VMs. The related
    operation efforts are not straightforward and should be considered carefully.
    If you choose a PaaS solution, available from all major public cloud providers,
    you’ll be limited to only administrative tasks but saved from the burden of maintaining
    the underlying infrastructure.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装或使用 Kubernetes 之前，你需要决定使用的基础设施，无论是本地还是公有云。其次，你需要在 **基础设施即服务** (**IaaS**)
    或 **平台即服务** (**PaaS**) 模式之间做出选择。选择 IaaS 后，你需要自己安装、配置、管理和维护 Kubernetes 集群，无论是安装在物理机器（裸金属）还是虚拟机上。相关操作工作不简单，需要仔细考虑。如果你选择
    PaaS 解决方案，所有主要公有云提供商都提供该服务，你将仅限于执行管理任务，而无需承担维护底层基础设施的负担。
- en: In this chapter, we’ll cover only IaaS deployments of Kubernetes. For IaaS,
    we’ll use a local desktop environment running Ubuntu VMs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将仅介绍 Kubernetes 的 IaaS 部署。对于 IaaS，我们将使用运行 Ubuntu 虚拟机的本地桌面环境。
- en: For the on-premises installation, we may also choose between a lightweight desktop
    version of Kubernetes or a full-blown cluster with multiple nodes. Let’s look
    at some of the most common desktop versions of Kubernetes next.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地安装，我们还可以选择 Kubernetes 的轻量级桌面版本或具有多个节点的完整集群。接下来让我们看看一些常见的 Kubernetes 桌面版本。
- en: Installing Kubernetes on a desktop
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在桌面上安装 Kubernetes
- en: 'If you’re looking only to experiment with Kubernetes, a desktop version may
    fit the bill. Desktop versions of Kubernetes usually deploy a single-node cluster
    on your local machine. Depending on your platform of choice, whether it be Windows,
    macOS, or Linux, you have plenty of Kubernetes engines to select from. Here are
    just a few:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想尝试 Kubernetes，桌面版可能正合适。Kubernetes 的桌面版本通常在本地机器上部署一个单节点集群。根据你选择的平台，无论是
    Windows、macOS 还是 Linux，你都有很多 Kubernetes 引擎可以选择。以下是其中的一些：
- en: '**Docker Desktop (macOS,** **Windows)**: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Desktop (macOS,** **Windows)**: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)'
- en: '**minikube (Linux, macOS,** **Windows)**: [https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**minikube (Linux, macOS,** **Windows)**: [https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/)'
- en: '**Microk8s (Linux, macOS,** **Windows)**: [https://microk8s.io/](https://microk8s.io/)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microk8s (Linux, macOS,** **Windows)**: [https://microk8s.io/](https://microk8s.io/)'
- en: '**k3s (****Linux)**: [https://k3s.io/](https://k3s.io/)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**k3s (****Linux)**: [https://k3s.io/](https://k3s.io/)'
- en: 'In this section, we’ll show you how to install Microk8s, one of the trending
    Kubernetes desktop engines at the time of writing. Microk8s is available to install
    via the Snap Store. We will use Debian 12 as the base operating system on our
    test computer, so we can install Microk8s from the Snap Store. If you don’t have
    `snapd` installed, you will have to first proceed and install it. You will have
    to use the following command to install the Snap daemon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何安装 Microk8s，这是一款在写作时非常流行的 Kubernetes 桌面引擎。Microk8s 可以通过 Snap Store
    安装。我们将使用 Debian 12 作为测试计算机的基础操作系统，以便从 Snap Store 安装 Microk8s。如果你没有安装`snapd`，你需要先进行安装。你需要使用以下命令来安装
    Snap 守护进程：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you already have `snapd` installed, you can skip this first step. The following
    step will be to run the command to install the `snapd` core runtime environment
    needed to run the Snap Store:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了`snapd`，你可以跳过这第一步。接下来的步骤是运行命令，安装运行 Snap Store 所需的`snapd`核心运行时环境：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Only after `snap` is installed, you can install `microk8s` by using the following
    command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在安装了`snap`之后，你才能使用以下命令安装`microk8s`：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A successful installation of Microk8s should yield the following result:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 Microk8s 后应显示以下结果：
- en: '![Figure 16.2 – Installing Microk8s on Linux](img/B19682_16_02.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – 在 Linux 上安装 Microk8s](img/B19682_16_02.jpg)'
- en: Figure 16.2 – Installing Microk8s on Linux
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 在 Linux 上安装 Microk8s
- en: As we already had `snapd` installed, we did not run the first of the commands
    listed previously.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了`snapd`，因此没有运行之前列出的第一个命令。
- en: 'To access the Microk8s CLI without `sudo` permissions, you’ll have to add the
    local user account to the `microk8s` group and also fix the permissions on the
    `~/.kube` directory with the following commands:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在没有`sudo`权限的情况下访问 Microk8s CLI，你需要将本地用户账户添加到`microk8s`组中，并使用以下命令修复`~/.kube`目录的权限：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The changes will take effect on the next login, and you can use the `microk8s`
    command-line utility with invocations that are not `sudo`. For example, the following
    command displays the help for the tool:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将在下次登录时生效，你可以在不使用`sudo`的情况下调用`microk8s`命令行工具。例如，以下命令显示该工具的帮助信息：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get the status of the local single-node Microk8s Kubernetes cluster, we
    run the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本地单节点 Microk8s Kubernetes 集群的状态，我们运行以下命令：
- en: '[PRE5]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the installation steps of Microk8s on Debian are straightforward
    and similar to the ones used in Ubuntu.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Microk8s 在 Debian 上的安装步骤直接且与 Ubuntu 上使用的步骤类似。
- en: In the next section, we will show you how to install Microk8s on a VM. This
    time, we will use Ubuntu 22.04 LTS as the base operating system for the VM.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将展示如何在虚拟机上安装 Microk8s。这次我们将使用 Ubuntu 22.04 LTS 作为虚拟机的基础操作系统。
- en: Installing Kubernetes on VMs
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在虚拟机上安装 Kubernetes
- en: In this section, we’ll get closer to a real-world Kubernetes environment – though
    at a much smaller scale – by deploying a Kubernetes cluster on Ubuntu VMs. You
    can use any hypervisor, such as KVM, Oracle VirtualBox, or VMware Fusion. We will
    use KVM as our preferred hypervisor.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过在 Ubuntu 虚拟机上部署 Kubernetes 集群，模拟一个更接近真实世界的 Kubernetes 环境——虽然规模要小得多。你可以使用任何虚拟化管理程序，如
    KVM、Oracle VirtualBox 或 VMware Fusion。我们将使用 KVM 作为首选的虚拟化管理程序。
- en: We will create four VMs, and we’ll provision each VM with 2 vCPU cores, 2 GB
    RAM, and 20 GB disk capacity. You may follow the steps described in the *Installing
    Ubuntu* section of [*Chapter 1*](B19682_01.xhtml#_idTextAnchor030), *Installing
    Linux*, using your hypervisor of choice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建四个虚拟机，每个虚拟机配置 2 个 vCPU 核心、2 GB 内存和 20 GB 磁盘容量。你可以按照[*第1章*](B19682_01.xhtml#_idTextAnchor030)中*安装
    Ubuntu*部分的步骤，使用你选择的虚拟化管理程序进行操作。
- en: Before we dive into the Kubernetes cluster installation details, let’s take
    a quick look at our lab environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入 Kubernetes 集群安装细节之前，先快速了解一下我们的实验环境。
- en: Preparing the lab environment
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备实验环境
- en: 'Here are the specs of our VM environment:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们虚拟机环境的规格：
- en: '**Hypervisor**: VMware Fusion'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟化管理程序**: VMware Fusion'
- en: '**Kubernetes cluster**: One CP node and three worker nodes'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 集群**: 一个 CP 节点和三个工作节点'
- en: '`k8s-cp1`: `192.168.122.104`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s-cp1`: `192.168.122.104`'
- en: '`k8s-n1`: `192.168.122.146`*   `k8s-n2`: `192.168.122.233`*   `k8s-n3`: `192.168.122.163`*   **VMs**:
    Ubuntu Server 22.04.3 LTS, 2 vCPUs, 2 GB RAM, 20 GB disk*   `packt` (on all nodes),
    with SSH access enabled'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k8s-n1`: `192.168.122.146`*   `k8s-n2`: `192.168.122.233`*   `k8s-n3`: `192.168.122.163`*   **虚拟机**:
    Ubuntu Server 22.04.3 LTS，2 个 vCPU，2 GB 内存，20 GB 硬盘*   `packt`（所有节点），启用 SSH 访问'
- en: We set the username and hostname settings on each VM node on the Ubuntu Server
    installation wizard. Also, make sure to enable the OpenSSH server when prompted.
    Your VM IP addresses would most probably be different from those in the specs,
    but that shouldn’t matter. You may also choose to use static IP addresses for
    your VMs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个虚拟机节点的 Ubuntu Server 安装向导中设置了用户名和主机名。并且在提示时，确保启用 OpenSSH 服务器。你的虚拟机 IP 地址可能与规格中的不同，但这不应该影响。你也可以选择为虚拟机使用静态
    IP 地址。
- en: 'To make hostname resolution simple within the cluster, edit the `/etc/hosts`
    file on each node and add the related records. For example, we have the following
    `/etc/hosts` file on the CP node (`k8s-cp1`):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化集群内部的主机名解析，编辑每个节点上的 `/etc/hosts` 文件并添加相关记录。例如，我们在 CP 节点（`k8s-cp1`）上有如下的
    `/etc/hosts` 文件：
- en: '![Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)](img/B19682_16_03.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – CP 节点（k8s-cp1）的 /etc/hosts 文件](img/B19682_16_03.jpg)'
- en: Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – CP 节点（k8s-cp1）的 /etc/hosts 文件
- en: In production environments, with the firewall enabled on the cluster nodes,
    we have to make sure that the following rules are configured for accepting network
    traffic within the cluster (according to [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，启用防火墙的集群节点，我们必须确保为接受集群内部的网络流量配置以下规则（参考 [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/)）：
- en: '![Figure 16.4 – The ports used by the Kubernetes cluster nodes](img/B19682_16_04.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – Kubernetes 集群节点使用的端口](img/B19682_16_04.jpg)'
- en: Figure 16.4 – The ports used by the Kubernetes cluster nodes
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – Kubernetes 集群节点使用的端口
- en: The following sections assume that you have the VMs provisioned and running
    according to the preceding specs. You may take some initial snapshots of your
    VMs before proceeding with the next steps. If anything goes wrong with the installation,
    you can revert to the initial state and start again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节假设你已经按照前述规格准备并运行了虚拟机。在继续执行下一步之前，你可以先拍摄一些虚拟机的初始快照。如果安装过程中出现任何问题，你可以恢复到初始状态并重新开始。
- en: 'Here are the steps we’ll follow to install the Kubernetes cluster:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们安装 Kubernetes 集群的步骤：
- en: Disable swapping.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用交换。
- en: Install `containerd.`
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `containerd`。
- en: Install the `kubelet`, `kubeadm`, and Kubernetes packages.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `kubelet`、`kubeadm` 和 Kubernetes 包。
- en: We’ll have to perform these steps on each cluster node. The related commands
    are also captured in the accompanying chapter source code on GitHub.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在每个集群节点上执行这些步骤。相关命令也可以在 GitHub 上附带的章节源代码中找到。
- en: Let’s start with the first step and disable the memory swap on each node.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始，禁用每个节点的内存交换。
- en: Disable swapping
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用交换
- en: '`swap` is a disk space used when the memory is full (refer to [https://github.com/kubernetes/kubernetes/issues/53533](https://github.com/kubernetes/kubernetes/issues/53533)
    for more details). The Kubernetes kubelet package doesn’t work with `swap` enabled
    on Linux platforms. This means that we will have to disable `swap` on all the
    nodes.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap` 是在内存满时使用的磁盘空间（参考 [https://github.com/kubernetes/kubernetes/issues/53533](https://github.com/kubernetes/kubernetes/issues/53533)
    获取更多详细信息）。Kubernetes 的 kubelet 包在 Linux 平台上无法与启用 `swap` 的系统一起使用。这意味着我们需要禁用所有节点上的
    `swap`。'
- en: 'To disable `swap` immediately, we run the following command on each VM:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了立即禁用 `swap`，我们需要在每个虚拟机上运行以下命令：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To persist the disabled `swap` with system reboots, we need to comment out
    the `swap`-related entries in `/etc/fstab`. You can do this either manually, by
    editing `/etc/fstab`, or with the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在系统重启后保持禁用 `swap`，我们需要在 `/etc/fstab` 中注释掉与 `swap` 相关的条目。你可以手动编辑 `/etc/fstab`，或者使用以下命令：
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may want to double-check that all `swap` entries in `/etc/fstab` are disabled:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要再次检查 `/etc/fstab` 中的所有 `swap` 条目是否被禁用：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the `swap` mount point commented out in our `/``etc/fstab` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `/etc/fstab` 文件中看到 `swap` 挂载点已被注释掉：
- en: '![Figure 16.5 – Disabling swap entries in /etc/fstab](img/B19682_16_05.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5 – 在 /etc/fstab 中禁用 swap 条目](img/B19682_16_05.jpg)'
- en: Figure 16.5 – Disabling swap entries in /etc/fstab
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 在 /etc/fstab 中禁用 swap 条目
- en: Remember to run the preceding commands on each node in the cluster. Next, we’ll
    look at installing the Kubernetes container runtime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在集群中的每个节点上运行上述命令。接下来，我们将着手安装 Kubernetes 容器运行时。
- en: Installing containerd
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 containerd
- en: '`containerd` is the default container runtime in recent versions of Kubernetes.
    `containerd` implements the CRI required by the Kubernetes container engine abstraction
    layer. The related installation procedure is not straightforward, and we’ll follow
    the steps described in the official Kubernetes documentation in the following
    link at the time of this writing: [https://kubernetes.io/docs/setup/production-environment/container-runtimes/](https://kubernetes.io/docs/setup/production-environment/container-runtimes/).
    These steps may change at any time, so please make sure to check the latest procedure.
    The container runtime needs to be installed on each node of the cluster. We will
    proceed by installing the needed components on the CP node, the VM called `k8s-cp1`,
    and then on the other nodes as well.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerd` 是 Kubernetes 最近版本中默认的容器运行时。`containerd` 实现了 Kubernetes 容器引擎抽象层所需的
    CRI。相关的安装过程并不简单，我们将在编写本文时，按照官方 Kubernetes 文档中的步骤进行操作，文档链接如下：[https://kubernetes.io/docs/setup/production-environment/container-runtimes/](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)。这些步骤可能会随时更改，因此请确保查看最新的安装流程。容器运行时需要在集群中的每个节点上安装。我们将从安装
    CP 节点（名为 `k8s-cp1`）的所需组件开始，然后在其他节点上继续安装。'
- en: 'We’ll start by installing some `containerd` prerequisites:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先安装一些 `containerd` 的先决条件：
- en: 'First, we enable the `br_netfilter` and `overlay` kernel modules using `modprobe`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用 `modprobe` 启用 `br_netfilter` 和 `overlay` 内核模块：
- en: '[PRE9]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also ensure that these modules are loaded upon system reboots:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还确保在系统重启时加载这些模块：
- en: '[PRE10]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: cat <<EOF | sudo tee /etc/sysctl.d/containerd.conf
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cat <<EOF | sudo tee /etc/sysctl.d/containerd.conf
- en: net.bridge.bridge-nf-call-iptables = 1
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: net.bridge.bridge-nf-call-iptables = 1
- en: net.bridge.bridge-nf-call-ip6tables = 1
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: net.bridge.bridge-nf-call-ip6tables = 1
- en: net.ipv4.ip_forward = 1
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: net.ipv4.ip_forward = 1
- en: EOF
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: EOF
- en: '[PRE11]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We want the preceding changes to take effect immediately, without a system
    reboot:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望上述更改立即生效，而无需重启系统：
- en: '[PRE12]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a screenshot showing the preceding commands:'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是显示前述命令的截图：
- en: '![Figure 16.6 – Setting containerd prerequisites](img/B19682_16_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6 – 设置 containerd 先决条件](img/B19682_16_06.jpg)'
- en: Figure 16.6 – Setting containerd prerequisites
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 设置 containerd 先决条件
- en: 'Next, we will verify if specific system variables are enabled in the `sysctl`
    configuration by running the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过运行以下命令验证 `sysctl` 配置中是否启用了特定的系统变量：
- en: '[PRE13]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of the command should be as follows:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令的输出应如下所示：
- en: '![Figure 16.7 – Verifying system variables in sysctl configuration](img/B19682_16_07.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7 – 验证 sysctl 配置中的系统变量](img/B19682_16_07.jpg)'
- en: Figure 16.7 – Verifying system variables in sysctl configuration
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – 验证 sysctl 配置中的系统变量
- en: Each variable should have a value of `1` in the output, just as shown in the
    previous screenshot.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量的值应为 `1`，正如前面截图所示。
- en: 'Now, let’s make sure the `apt` repository is up to date before installing any
    new packages:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们确保在安装任何新软件包之前，`apt` 仓库是最新的：
- en: '[PRE14]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'containerd configuration:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: containerd 配置：
- en: '[PRE15]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to slightly alter the default `containerd` configuration to use the
    `systemd` `cgroup` driver with the container runtime (`runc`). This change is
    required because the underlying platform (Ubuntu in our case) uses `systemd` as
    the Service manager. Open the `/etc/containerd/config.toml` file with your editor
    of choice, such as the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要稍微修改默认的 `containerd` 配置，以使用 `systemd` 的 `cgroup` 驱动程序和容器运行时（`runc`）。此更改是必需的，因为底层平台（在本例中为
    Ubuntu）使用 `systemd` 作为服务管理器。使用您选择的编辑器打开 `/etc/containerd/config.toml` 文件，如下所示：
- en: '[PRE17]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]'
- en: '[PRE18]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, add the highlighted lines, adjusting the appropriate indentation (this
    is *very* important):'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加突出显示的行，并调整适当的缩进（这*非常*重要）：
- en: '[PRE19]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the resulting configuration stub:'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是配置片段：
- en: '![Figure 16.8 – Modifying the containerd configuration](img/B19682_16_08.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8 – 修改 containerd 配置](img/B19682_16_08.jpg)'
- en: Figure 16.8 – Modifying the containerd configuration
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8 – 修改 containerd 配置
- en: 'Save the `/etc/containerd/config.toml` file and restart `containerd`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `/etc/containerd/config.toml` 文件并重启 `containerd`：
- en: '[PRE20]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: sudo systemctl status containerd
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo systemctl status containerd
- en: '[PRE21]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With `containerd` installed and configured, we can proceed with the installation
    of the Kubernetes packages next.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并配置好 `containerd` 后，我们可以继续进行 Kubernetes 包的安装。
- en: Installing Kubernetes packages
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 包
- en: 'To install the Kubernetes packages, we’ll follow the steps described at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/).
    This procedure may also change over time, so please make sure to check out the
    latest instructions. The steps presented next are applicable to Debian 12 and
    Ubuntu 22.04\. Let’s begin:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Kubernetes 包，我们将按照 [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/)
    上的步骤进行操作。此过程可能随时间变化，因此请确保查看最新的说明。接下来的步骤适用于 Debian 12 和 Ubuntu 22.04。我们开始：
- en: 'We first install the packages required by the Kubernetes `apt` repository:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先安装 Kubernetes `apt` 仓库所需的包：
- en: '[PRE22]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'apt repository to our system:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 向我们的系统添加 apt 仓库：
- en: '[PRE23]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s read the packages available in the new repository we just added:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们查看刚刚添加的新仓库中可用的包：
- en: '[PRE25]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We’re now ready to install the Kubernetes packages:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好安装 Kubernetes 包：
- en: '[PRE26]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'containerd and kubelet Services are enabled upon system startup (reboot):'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: containerd 和 kubelet 服务在系统启动时（重启）启用：
- en: '[PRE27]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'containerd should be active and running. The following is a screenshot showing
    the output of the preceding commands:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: containerd 应该处于活动状态并运行。以下是显示前面命令输出的截图：
- en: '[PRE28]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd](img/B19682_16_09.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.9 – 固定 Kubernetes 包及 containerd 的运行状态](img/B19682_16_09.jpg)'
- en: Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 – 固定 Kubernetes 包及 containerd 的运行状态
- en: 'Next, let’s check the status of the `kubelet` Service:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们检查 `kubelet` 服务的状态：
- en: '[PRE30]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![Figure 16.10 – The kubelet crashing without cluster configuration](img/B19682_16_10.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.10 – kubelet 在没有集群配置时崩溃](img/B19682_16_10.jpg)'
- en: Figure 16.10 – The kubelet crashing without cluster configuration
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.10 – kubelet 在没有集群配置时崩溃
- en: As shown in the preceding screenshot, `kubelet` is looking for the Kubernetes
    cluster, which is not set up yet. We can see that `kubelet` attempts to start
    and activate itself but keeps crashing, as it cannot locate the required configuration.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`kubelet` 正在寻找 Kubernetes 集群，但集群尚未设置。我们可以看到，`kubelet` 尝试启动并激活自身，但由于无法找到所需的配置，它不断崩溃。
- en: Important note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please install the required Kubernetes packages on *all* cluster nodes following
    the previous steps before proceeding with the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行下一部分之前，请按照前面的步骤在*所有*集群节点上安装所需的 Kubernetes 包。
- en: Next, we’ll bootstrap (initialize) the Kubernetes cluster using `kubeadm`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `kubeadm` 引导（初始化）Kubernetes 集群。
- en: Introducing kubeadm
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍 kubeadm
- en: '`kubeadm` is a helper tool for creating a Kubernetes cluster and essentially
    has two invocations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubeadm` 是一个用于创建 Kubernetes 集群的辅助工具，主要有两种调用方式：'
- en: '`kubeadm init`: This bootstraps or initializes a Kubernetes cluster'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubeadm init`：初始化或引导一个 Kubernetes 集群。'
- en: '`kubeadm join`: This adds a node to a Kubernetes cluster'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubeadm join`：将一个节点添加到 Kubernetes 集群中。'
- en: 'The default invocation of `kubadm init [flags]` – with no flags – performs
    the following tasks:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubadm init [flags]` 的默认调用 – 没有标志 – 执行以下任务：'
- en: '`kubeadm init` ensures that we have the minimum system resources in terms of
    CPU and memory, the required user permissions, and a supported CRI-compliant container
    runtime. If any of these checks fail, `kubeadm init` stops the execution of creating
    the cluster. If the checks succeed, `kubeadm` proceeds to the next step.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init` 确保我们在 CPU 和内存等系统资源方面具备最小要求，具有必要的用户权限，并且支持 CRI 合规的容器运行时。如果任何检查失败，`kubeadm
    init` 会停止创建集群的执行。如果检查成功，`kubeadm` 会继续执行下一步。'
- en: '`kubeadm init` creates a self-signed CA used by Kubernetes to generate the
    certificates required to authenticate and run trusted workloads within the cluster.
    The CA files are stored in the `/etc/kubernetes/pki`/ directory and are distributed
    on each node upon joining the cluster.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init` 创建一个 Kubernetes 使用的自签名 CA，用于生成认证和运行集群内可信工作负载所需的证书。CA 文件存储在 `/etc/kubernetes/pki`
    目录中，并在节点加入集群时分发到每个节点。'
- en: '`kubeadm init` creates a default set of kubeconfig files required to bootstrap
    the cluster. The kubeconfig files are stored in the `/``etc/kubernetes/` directory.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init`创建了启动集群所需的默认 kubeconfig 文件集。kubeconfig 文件存储在`/etc/kubernetes/`目录下。'
- en: '`kubelet` daemon. Examples of static pods are the API server, the controller
    manager, scheduler, and etcd. Static pod manifests are configuration files describing
    the CP pods. `kubeadm init` generates the static pod manifests during the cluster
    bootstrapping process. The manifest files are stored in the `/etc/kubernetes/manifests/`
    directory. The `kubelet` Service monitors this location and, when it finds a manifest,
    deploys the corresponding static pod.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubelet`守护进程。静态 pod 的示例包括 API 服务器、控制器管理器、调度器和 etcd。静态 pod 清单是描述 CP pod 的配置文件。`kubeadm
    init`在集群启动过程中生成静态 pod 清单。清单文件存储在`/etc/kubernetes/manifests/`目录下。`kubelet`服务监视此位置，当它找到一个清单文件时，会部署相应的静态
    pod。'
- en: '`kubelet` daemon deploys the static pods, `kubeadm` queries `kubelet` for the
    static pods’ state. When the static pods are up and running, `kubeadm init` proceeds
    with the next stage.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubelet`守护进程部署静态 pod，`kubeadm`查询`kubelet`以获取静态 pod 的状态。当静态 pod 启动并运行后，`kubeadm
    init`将继续进行下一阶段。'
- en: '`kubeadm init` follows the Kubernetes best practice of tainting the CP to avoid
    user pods running on the CP node. The obvious reason is to preserve CP resources
    exclusively for system-specific workloads.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init`遵循 Kubernetes 最佳实践，通过污点处理 CP，避免用户 pod 在 CP 节点上运行。显而易见的原因是为了将
    CP 资源专门保留给系统相关的工作负载。'
- en: '`kubeadm init` generates a bootstrap token that can be shared with a trusted
    node to join the cluster.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init`生成一个启动令牌，可以与受信任的节点共享，以便加入集群。'
- en: '`kubeadm init` creates and deploys the *DNS* and *kube-proxy* add-on pods.'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`kubeadm init`创建并部署*DNS*和*kube-proxy*附加 pod。'
- en: The stages of a Kubernetes cluster’s bootstrapping process are highly customizable.
    `kubeadm init`, when invoked without additional parameters, runs all the tasks
    in the preceding order. Alternatively, a system administrator may invoke the `kubeadm`
    command with different option parameters to control and run any of the stages
    mentioned.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群启动过程的各个阶段具有高度的可定制性。`kubeadm init`在没有额外参数的情况下运行所有前面的任务。或者，系统管理员可以使用不同的选项参数调用`kubeadm`命令，以控制并运行任何一个阶段。
- en: 'For more information about `kubeadm`, please refer to the utility’s help with
    the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`kubeadm`的更多信息，请使用以下命令查阅该工具的帮助文档：
- en: '[PRE31]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For more information about bootstrapping a Kubernetes cluster using `kubeadm`,
    including installing, troubleshooting, and customizing components, you may refer
    to the official Kubernetes documentation at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`kubeadm`启动 Kubernetes 集群的更多信息，包括安装、故障排除和组件定制，您可以参考官方的 Kubernetes 文档：[https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/)。
- en: In the next section, we’ll bootstrap a Kubernetes cluster using `kubeadm` to
    generate a cluster configuration file and then invoke `kubeadm init` to use this
    configuration. We’ll bootstrap our cluster by creating the Kubernetes CP node
    next.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用`kubeadm`启动 Kubernetes 集群，生成集群配置文件，然后调用`kubeadm init`以使用此配置。接下来，我们将通过创建
    Kubernetes CP 节点来启动集群。
- en: Creating a Kubernetes CP node
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Kubernetes CP 节点
- en: 'In order to create the CP node, we will use a networking and security solution
    named `kubeadm`, and afterwards, we will use different tools to apply the configurations.
    The choice of Calico is purely subjective, but it is needed for managing communications
    between workloads and components. For more information about Calico, please visit
    the following link: [https://docs.tigera.io/calico/latest/about/](https://docs.tigera.io/calico/latest/about/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建 CP 节点，我们将使用一个名为`kubeadm`的网络和安全解决方案，之后，我们将使用不同的工具来应用配置。选择 Calico 是完全主观的，但它对于管理工作负载和组件之间的通信是必要的。有关
    Calico 的更多信息，请访问以下链接：[https://docs.tigera.io/calico/latest/about/](https://docs.tigera.io/calico/latest/about/)。
- en: 'The commands are performed on the `k8s-cp1` host in our VM environment. As
    the hostname suggests, we choose `k8s-cp1` as the CP node of our Kubernetes cluster.
    Now, let’s get to work and configure our Kubernetes CP node:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将在我们的虚拟机环境中的`k8s-cp1`主机上执行。如主机名所示，我们选择`k8s-cp1`作为 Kubernetes 集群的 CP 节点。现在，让我们开始工作并配置我们的
    Kubernetes CP 节点：
- en: 'We’ll start by downloading the Calico manifest for **overlay networking**.
    The overlay network – also known as **software-defined network** (**SDN**) – is
    a logical networking layer that accommodates a secure and seamless network communication
    between the pods over a physical network that may not be accessible for configuration.
    Exploring the internals of cluster networking is beyond the scope of this chapter,
    but we encourage you to read more at [https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/).
    You’ll also find references to the Calico networking add-on. To download the related
    manifest, we run the following command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先下载用于**覆盖网络**的 Calico 清单。覆盖网络，也被称为**软件定义网络**（**SDN**），是一个逻辑网络层，它支持通过一个可能无法配置的物理网络，在
    Pod 之间进行安全且无缝的网络通信。探索集群网络的内部结构超出了本章的范围，但我们鼓励你阅读更多内容，访问 [https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/)。你还会找到与
    Calico 网络插件相关的参考资料。要下载相关清单，我们运行以下命令：
- en: '[PRE32]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let’s open the `calico.yaml` file using a text editor and look for the
    following lines (starting with *line 3672*):'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用文本编辑器打开 `calico.yaml` 文件，并查找以下行（从 *第 3672 行* 开始）：
- en: '[PRE33]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we’ll create a default cluster configuration file using `kubeadm`. The
    cluster configuration file describes the settings of the Kubernetes cluster we’re
    building. Let’s name this file `k8s-config.yaml`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 `kubeadm` 创建一个默认的集群配置文件。该配置文件描述了我们正在构建的 Kubernetes 集群的设置。我们将该文件命名为
    `k8s-config.yaml`：
- en: '[PRE34]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![Figure 16.11 – Modifying the advertiseAddress configuration parameter](img/B19682_16_11.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.11 – 修改 advertiseAddress 配置参数](img/B19682_16_11.jpg)'
- en: Figure 16.11 – Modifying the advertiseAddress configuration parameter
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11 – 修改 advertiseAddress 配置参数
- en: 'The next change we need to make is pointing the `nodeRegistration.criSocket`
    configuration parameter to the `containerd` socket `(/run/containerd/containerd.sock`)
    and the name (`k8s-cp1`):'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要进行的下一项更改是将 `nodeRegistration.criSocket` 配置参数指向 `containerd` 套接字 `(/run/containerd/containerd.sock)`
    和名称（`k8s-cp1`）：
- en: '![Figure 16.12 – Changing the criSocket configuration parameter](img/B19682_16_12.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.12 – 更改 criSocket 配置参数](img/B19682_16_12.jpg)'
- en: Figure 16.12 – Changing the criSocket configuration parameter
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12 – 更改 criSocket 配置参数
- en: 'Next, we change the `kubernetesVersion` parameter to match the version of our
    Kubernetes environment:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更改 `kubernetesVersion` 参数，以匹配我们的 Kubernetes 环境版本：
- en: '![Figure 16.13 – Changing the kubernetesVersion parameter](img/B19682_16_13.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.13 – 更改 kubernetesVersion 参数](img/B19682_16_13.jpg)'
- en: Figure 16.13 – Changing the kubernetesVersion parameter
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13 – 更改 kubernetesVersion 参数
- en: 'The default value is `1.28.0`, but our Kubernetes version, using the following
    command, is `1.28.2`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 `1.28.0`，但我们的 Kubernetes 版本，通过以下命令检查，实际为 `1.28.2`：
- en: '[PRE35]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Figure 16.14 – Retrieving the current version of Kubernetes](img/B19682_16_14.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.14 – 获取当前 Kubernetes 版本](img/B19682_16_14.jpg)'
- en: Figure 16.14 – Retrieving the current version of Kubernetes
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.14 – 获取当前 Kubernetes 版本
- en: 'Our final modification of the cluster configuration file sets the `cgroup`
    driver of `kubelet` to `systemd`, matching the `cgroup` driver of `containerd`.
    Please note that `systemd` is the underlying platform’s Service manager (in Ubuntu),
    hence the need to yield related Service control to the Kubernetes daemons. The
    corresponding configuration block is not yet present in `k8s-config.yaml`. We
    can add it manually to the end of the file or with the following command:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对集群配置文件的最终修改是将 `kubelet` 的 `cgroup` 驱动程序设置为 `systemd`，以匹配 `containerd` 的 `cgroup`
    驱动程序。请注意，`systemd` 是底层平台的服务管理器（在 Ubuntu 中），因此需要将相关的服务控制权限交给 Kubernetes 守护进程。此配置块尚未出现在
    `k8s-config.yaml` 中。我们可以手动将其添加到文件的末尾，或使用以下命令添加：
- en: '[PRE36]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: sudo kubeadm init --config=k8s-config.yaml
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: sudo kubeadm init --config=k8s-config.yaml
- en: '[PRE37]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Figure 16.15 – Successfully bootstrapping the Kubernetes cluster](img/B19682_16_15.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.15 – 成功启动 Kubernetes 集群](img/B19682_16_15.jpg)'
- en: Figure 16.15 – Successfully bootstrapping the Kubernetes cluster
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.15 – 成功启动 Kubernetes 集群
- en: 'At this point, our Kubernetes CP node is up and running. In the output, we
    highlighted the relevant excerpts for the following commands:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的 Kubernetes 控制平面节点已经启动并正常运行。在输出中，我们突出显示了以下命令相关的摘录：
- en: A successful message (**1**)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功信息（**1**）
- en: Configuring the current user as the Kubernetes cluster administrator (**2**)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前用户配置为 Kubernetes 集群管理员（**2**）
- en: Joining new nodes to the Kubernetes cluster (**3**)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新节点加入 Kubernetes 集群（**3**）
- en: We recommend taking the time to go over the complete output and identify the
    related information for each of the `kubeadm init` tasks, as captured in the *Introducing
    kubeadm* section earlier in this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议花时间仔细查看完整的输出，并根据本章前面 *介绍 kubeadm* 部分的描述，识别与每个 `kubeadm init` 任务相关的信息。
- en: 'Next, to configure the current user as the Kubernetes cluster administrator,
    we run the following commands:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了将当前用户配置为 Kubernetes 集群管理员，我们运行以下命令：
- en: '[PRE38]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With our cluster up and running, let’s deploy the Calico networking manifest
    to create the pod network:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集群正常运行后，让我们部署 Calico 网络清单，以创建 pod 网络：
- en: '[PRE39]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: kubectl get pods --all-namespaces
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl get pods --all-namespaces
- en: '[PRE40]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![Figure 16.16 – Retrieving the pods in the Kubernetes cluster](img/B19682_16_16.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.16 – 获取 Kubernetes 集群中的 pod](img/B19682_16_16.jpg)'
- en: Figure 16.16 – Retrieving the pods in the Kubernetes cluster
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.16 – 获取 Kubernetes 集群中的 pod
- en: The `--all-namespaces` option retrieves the pods across all resource groups
    in the cluster. Kubernetes uses **namespaces** to organize resources. For now,
    the only pods running in our cluster are **system pods**, as we haven’t deployed
    any **user** **pods** yet.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`--all-namespaces` 选项用于检索集群中所有资源组中的 pod。Kubernetes 使用 **命名空间** 来组织资源。目前，我们的集群中唯一运行的
    pod 是 **系统 pod**，因为我们还没有部署任何 **用户 pod**。'
- en: 'The following command retrieves the current nodes in the cluster:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令用于检索集群中的当前节点：
- en: '[PRE41]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure 16.17 – Listing the current nodes in the Kubernetes cluster](img/B19682_16_17.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.17 – 列出 Kubernetes 集群中的当前节点](img/B19682_16_17.jpg)'
- en: Figure 16.17 – Listing the current nodes in the Kubernetes cluster
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.17 – 列出 Kubernetes 集群中的当前节点
- en: 'You may recall that prior to bootstrapping the Kubernetes cluster, the `kubelet`
    Service was continually crashing (and attempting to restart). With the cluster
    up and running, the status of the `kubelet` daemon should be `active` and `running`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还记得，在初始化 Kubernetes 集群之前，`kubelet` 服务一直在崩溃（并试图重启）。在集群正常运行后，`kubelet` 守护进程的状态应为
    `active` 和 `running`：
- en: '[PRE42]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output shows the following:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示如下内容：
- en: '![Figure 16.18 – A healthy kubelet in the cluster](img/B19682_16_18.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.18 – 集群中的健康 kubelet](img/B19682_16_18.jpg)'
- en: Figure 16.18 – A healthy kubelet in the cluster
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18 – 集群中的健康 kubelet
- en: 'We encourage you to check out the manifests created in the `/etc/kubernetes/manifests/`
    directory for each cluster component using the following command:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们建议使用以下命令查看 `/etc/kubernetes/manifests/` 目录中为每个集群组件创建的清单：
- en: '[PRE43]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output shows the configuration files describing the static (system) pods,
    corresponding to the API server, controller manager, scheduler, and etcd:'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示了描述静态（系统）pod 的配置文件，分别对应 API 服务器、控制器管理器、调度器和 etcd：
- en: '![Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/](img/B19682_16_19.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.19 – /etc/kubernetes/manifests/ 中的静态 pod 配置文件](img/B19682_16_19.jpg)'
- en: Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.19 – /etc/kubernetes/manifests/ 中的静态 pod 配置文件
- en: 'You may also look at the kubeconfig files in `/etc/kubernetes`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以查看 `/etc/kubernetes` 中的 kubeconfig 文件：
- en: '[PRE44]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you may recall from the *Introducing kubeadm* section earlier in this chapter,
    the kubeconfig files are used by the cluster components to communicate and authenticate
    with the API server.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你可能还记得的，在本章前面 *介绍 kubeadm* 部分中，kubeconfig 文件被集群组件用于与 API 服务器通信和身份验证。
- en: 'As we have used the `kubectl` utility quite extensively in this section, you
    can visit the official documentation to find out more about the commands and options
    available for it at the following link: [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本节中广泛使用了 `kubectl` 工具，你可以访问以下链接，查看官方文档，了解更多关于该工具的命令和选项：[https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)。
- en: Next, let’s add the worker nodes to our Kubernetes cluster.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将工作节点添加到 Kubernetes 集群中。
- en: Joining a node to a Kubernetes cluster
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将节点加入 Kubernetes 集群
- en: As previously noted, before adding a node to the Kubernetes cluster, you’ll
    need to run the preliminary steps described in the *Preparing the lab environment*
    section earlier in this chapter.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在将节点加入 Kubernetes 集群之前，您需要执行本章前面 *准备实验环境* 部分中描述的初步步骤。
- en: To join a node to the cluster, we’ll need both the `kubeadm join` command were
    provided in the output at the end of the bootstrapping process with `kubeadm init`.
    Refer to the *Creating a Kubernetes CP node* section earlier in this chapter.
    Keep in mind that the bootstrap token expires in 24 hours. If you forget to copy
    the command, you can retrieve the related information by running the following
    commands in the CP node’s terminal (on `k8s-cp1`).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个节点加入集群，我们需要使用`kubeadm join`命令，该命令会在引导过程结束时由`kubeadm init`输出。请参考本章前面的*创建Kubernetes
    CP节点*部分。请注意，启动令牌在24小时后过期。如果忘记复制该命令，可以通过在CP节点（`k8s-cp1`）的终端中运行以下命令来检索相关信息。
- en: 'To proceed, follow these steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，按照以下步骤操作：
- en: 'Retrieve the current bootstrap tokens:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索当前的引导令牌：
- en: '[PRE45]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Figure 16.20 – Getting the current bootstrap tokens](img/B19682_16_20.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图16.20 – 获取当前的引导令牌](img/B19682_16_20.jpg)'
- en: Figure 16.20 – Getting the current bootstrap tokens
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20 – 获取当前的引导令牌
- en: 'Get the CA certificate hash:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取CA证书哈希值：
- en: '[PRE46]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 16.21 – Getting the CA certificate hash](img/B19682_16_21.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图16.21 – 获取CA证书哈希值](img/B19682_16_21.jpg)'
- en: Figure 16.21 – Getting the CA certificate hash
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 – 获取CA证书哈希值
- en: 'You may also generate a new bootstrap token with the following command:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以通过以下命令生成新的引导令牌：
- en: '[PRE47]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: kubeadm token create --print-join-command
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubeadm token create --print-join-command
- en: '[PRE48]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that the token has been created, we can proceed to the next bootstrapping
    steps.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在令牌已创建，我们可以继续执行接下来的引导步骤。
- en: 'In the following steps, we’ll use our initial tokens as displayed in the output
    at the end of the bootstrapping process. So, let’s switch to the node’s command-line
    terminal (on `k8s-n1`) and run the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将使用引导过程结束时显示的初始令牌。因此，让我们切换到节点的命令行终端（`k8s-n1`），并运行以下命令：
- en: 'Make sure to invoke `sudo`, or the command will fail with insufficient permissions:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保调用`sudo`，否则命令会因权限不足而失败：
- en: '[PRE49]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'k8s-n1) added to the cluster:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: k8s-n1) 已加入集群：
- en: '[PRE50]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 16.22 – The new node (k8s-n1) added to the cluster](img/B19682_16_22.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图16.22 – 新节点（k8s-n1）已加入集群](img/B19682_16_22.jpg)'
- en: Figure 16.22 – The new node (k8s-n1) added to the cluster
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 – 新节点（k8s-n1）已加入集群
- en: 'We encourage you to repeat the process of joining the other two cluster nodes
    (`k8s-n2` and `k8s-n3`). During the join, while the CP pods are being deployed
    on the new node, you may temporarily see a `NotReady` status for the new node
    if you query the nodes on the CP node (`k8s-cp1`) too fast. The process should
    take a while. In the end, we should have all three nodes showing `Ready` in the
    output of the `kubectl get nodes` command (on `k8s-cp1`):'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们建议你重复加入其他两个集群节点（`k8s-n2` 和 `k8s-n3`）的过程。在加入过程中，当新的节点正在部署CP pod时，如果你过快查询CP节点上的节点（`k8s-cp1`），你可能会暂时看到新的节点处于`NotReady`状态。这个过程需要一些时间。最终，所有三个节点应该在`kubectl
    get nodes`命令的输出中显示为`Ready`（在`k8s-cp1`上）：
- en: '![Figure 16.23 – The Kubernetes cluster with all nodes running](img/B19682_16_23.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23 – 所有节点运行中的Kubernetes集群](img/B19682_16_23.jpg)'
- en: Figure 16.23 – The Kubernetes cluster with all nodes running
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 – 所有节点运行中的Kubernetes集群
- en: We have now completed the installation of our Kubernetes cluster, with a CP
    node and three worker nodes. We used a local (on-premises) VM environment, but
    the same process would also apply to a hosted IaaS solution running in a private
    or public cloud.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已完成Kubernetes集群的安装，包含一个CP节点和三个工作节点。我们使用的是本地（本地虚拟机）环境，但相同的过程也适用于运行在私有或公共云中的托管IaaS解决方案。
- en: In the next section, we’ll explore the `kubectl` CLI to a certain extent and
    use it to create and manage Kubernetes resources. Then, we’ll look at deploying
    and scaling applications using the imperative and declarative deployment models
    in Kubernetes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨`kubectl`命令行工具，并使用它来创建和管理Kubernetes资源。然后，我们将研究如何使用命令式和声明式部署模型在Kubernetes中部署和扩展应用程序。
- en: Working with Kubernetes
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes
- en: In this section, we’ll use real-world examples of interacting with a Kubernetes
    cluster. Since we’ll be using the `kubectl` CLI to a considerable extent, we’re
    going to take a deep dive into some of its more common usage patterns. Then, we
    will turn our focus to deploying applications to a Kubernetes cluster. We’ll be
    using the on-premises environment we built in the *Installing Kubernetes on* *VMs*
    section.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用与Kubernetes集群交互的实际示例。由于我们将在很大程度上使用 `kubectl` CLI，我们将深入探讨其一些常见的使用模式。然后，我们将重点关注将应用程序部署到Kubernetes集群的过程。我们将使用在*安装Kubernetes到VM*部分中建立的本地环境。
- en: Let’s start by taking a closer look at `kubectl` and its usage.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先仔细看看 `kubectl` 及其使用方法。
- en: Using kubectl
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 kubectl
- en: '`kubectl` is the primary tool for managing a Kubernetes cluster and its resources.
    `kubectl` communicates with the cluster’s API server endpoint using the Kubernetes
    REST API. The general syntax of a `kubectl` command is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 是管理Kubernetes集群及其资源的主要工具。`kubectl` 使用Kubernetes的REST API与集群的API服务器端点进行通信。`kubectl`
    命令的一般语法如下：'
- en: '[PRE51]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In general, `kubectl` commands execute **CRUD operations** – CRUD stands for
    **Create**, **Read**, **Update**, and **Delete** – against Kubernetes resources,
    such as pods, Deployments, and Services.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`kubectl` 命令执行 **CRUD 操作** —— CRUD 代表 **创建**、**读取**、**更新** 和 **删除** —— 针对Kubernetes资源，例如Pod、Deployment和Service。
- en: 'One of the essential features of `kubectl` is the command output format, either
    in YAML, JSON, or plain text. The output format is handy when creating or editing
    application Deployment manifests. We can capture the YAML output of a `kubectl`
    command (such as create a resource) to a file. Later, we can reuse the manifest
    file to perform the same operation (or sequence of operations) in a declarative
    way. This brings us to the two basic Deployment paradigms of Kubernetes:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 的一个重要特性是命令输出格式，可以是 YAML、JSON 或纯文本。输出格式在创建或编辑应用程序部署清单时非常有用。我们可以将 `kubectl`
    命令（例如创建资源）的YAML输出捕获到一个文件中。稍后，我们可以重用该清单文件，以声明的方式执行相同的操作（或操作序列）。这将引出Kubernetes的两种基本部署模式：'
- en: '`kubectl` commands to operate on specific resources'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 命令用于操作特定资源'
- en: '`kubectl apply` command, usually targeting a set of resources with a single
    invocation'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl apply` 命令，通常是通过一次调用操作一组资源'
- en: 'We’ll look at these two Deployment models more closely in the *Deploying applications*
    section later in this chapter. For now, let’s get back to exploring the `kubectl`
    command further. Here’s a short list of some of the most common `kubectl` commands:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后的*应用程序部署*部分中，我们将更详细地探讨这两种部署模式。目前，让我们回到继续探索 `kubectl` 命令。以下是一些最常见的 `kubectl`
    命令的简短列表：
- en: '`create`, `apply`: These create resources imperatively/declaratively'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`, `apply`：这些命令以命令式/声明式方式创建资源'
- en: '`get`: This reads resources'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：此命令读取资源'
- en: '`edit`, `set`: These update resources or specific features of objects'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edit`, `set`：这些命令更新资源或对象的特定特性'
- en: '`delete`: This deletes resources'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete`：此命令删除资源'
- en: '`run`: This starts a pod'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：此命令启动一个Pod'
- en: '`exec`: This executes a command in a pod container'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：此命令在Pod容器中执行命令'
- en: '`describe`: This displays detailed information about resources'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`describe`：此命令显示有关资源的详细信息'
- en: '`explain`: This provides resource-related documentation'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`explain`：此命令提供资源相关的文档'
- en: '`logs`: This shows the logs in pod containers'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：此命令显示Pod容器中的日志'
- en: 'A couple of frequently used parameters of the `kubectl` command are also worth
    mentioning:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个常用的 `kubectl` 参数也值得一提：
- en: '`--dry-run`: This runs the command without modifying the system state while
    still providing the output as if it executed normally'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dry-run`：此选项在不修改系统状态的情况下运行命令，同时仍提供如同正常执行时的输出'
- en: '`--output`: This specifies various formats for the command output: `yaml`,
    `json`, and `wide` (additional information in plain text)'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output`：此选项指定命令输出的各种格式：`yaml`、`json` 和 `wide`（以纯文本形式显示附加信息）'
- en: 'In the following sections, we’ll look at multiple examples of using the `kubectl`
    command. Always keep in mind the general pattern of the command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将查看多个使用 `kubectl` 命令的示例。始终记住命令的一般模式：
- en: '![Figure 16.24 – The general usage pattern of kubectl](img/B19682_16_24.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图16.24 – kubectl的一般使用模式](img/B19682_16_24.jpg)'
- en: Figure 16.24 – The general usage pattern of kubectl
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24 – kubectl的一般使用模式
- en: 'We recommend that you check out the complete `kubectl` command reference at
    [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).
    While you are becoming proficient with `kubectl`, you may also want to keep the
    related cheat sheet at hand, which you can find at the following link: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你查看完整的`kubectl`命令参考文档，链接为[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)。在你熟悉`kubectl`的同时，你也可以随时查看相关的备忘单，链接在这里：[https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)。
- en: Now, let’s prepare our `kubectl` environment to interact with the Kubernetes
    cluster we built earlier with VMs. You may skip the next section if you prefer
    to use `kubectl` on the CP node.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们准备`kubectl`环境，以便与我们之前使用虚拟机构建的Kubernetes集群进行交互。如果你更倾向于在CP节点上使用`kubectl`，可以跳过下一节。
- en: Connecting to a Kubernetes cluster from a local machine
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从本地机器连接到Kubernetes集群
- en: In this section, we configure the `kubectl` CLI running locally on our Linux
    desktop to control a remote Kubernetes cluster. We are running Debian 12 on our
    local machine.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将配置在本地Linux桌面上运行的`kubectl` CLI，以便控制远程Kubernetes集群。我们的本地机器运行的是Debian 12。
- en: 'First, we will need to install `kubectl` on our system. We will observe the
    installation instructions at [https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/).
    We will download the latest `kubectl` release with the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在系统上安装`kubectl`。我们将参考[https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/)中的安装说明。我们将使用以下命令下载最新的`kubectl`版本：
- en: '[PRE52]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
- en: '[PRE53]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: kubectl version --client
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl version --client
- en: '[PRE54]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: scp packt@192.168.122.104:~/.kube/config /tmp/config.cp
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: scp packt@192.168.122.104:~/.kube/config /tmp/config.cp
- en: '[PRE55]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: mv /tmp/config.cp ~/.kube/config
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: mv /tmp/config.cp ~/.kube/config
- en: '[PRE56]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: rm ~/.kube/config.old /tmp/config.cp
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: rm ~/.kube/config.old /tmp/config.cp
- en: '[PRE57]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'kubernetes-admin@kubernetes) and cluster name (kubernetes):'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubernetes-admin@kubernetes) 和集群名称(kubernetes)：
- en: '[PRE58]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: kubectl config rename-context \
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl config rename-context \
- en: kubernetes-admin@kubernetes \
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubernetes-admin@kubernetes \
- en: k8s-local
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: k8s-local
- en: 'kubectl context becomes k8s-local, and we’re now interacting with our on-premises
    Kubernetes cluster (kubernetes). The output is shown in the following screenshot:'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl上下文变为k8s-local，我们现在正在与本地Kubernetes集群(kubernetes)交互。以下是输出截图：
- en: '[PRE59]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: kubectl cluster-info
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl cluster-info
- en: '[PRE60]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: kubectl cluster-info dump
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl cluster-info dump
- en: '[PRE61]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: kubectl get nodes --output=wide
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes --output=wide
- en: '[PRE62]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: kubectl get pods
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods
- en: '[PRE63]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: No resources found in default namespace.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 默认命名空间中未找到资源。
- en: '[PRE64]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: kubectl get pods --all-namespace
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods --all-namespace
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: kubectl get pods --namespace kube-system
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods --namespace kube-system
- en: '[PRE66]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: kubectl get all --all-namespaces
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get all --all-namespaces
- en: '[PRE67]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: kubectl api-resources
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl api-resources
- en: '[PRE68]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: kubectl explain nodes
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl explain nodes
- en: '[PRE69]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: kubectl explain nodes.apiVersion
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl explain nodes.apiVersion
- en: '[PRE70]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: kubectl describe nodes
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl describe nodes
- en: kubectl describe nodes k8s-n1
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl describe nodes k8s-n1
- en: '[PRE71]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: kubectl --help
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl --help
- en: kubectl config -h
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl config -h
- en: kubectl get pods -h
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pods -h
- en: '[PRE72]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: sudo apt-get install -y bash-completion
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get install -y bash-completion
- en: '[PRE73]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: echo "source <(kubectl completion bash)" >> ~/.bashrc
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: echo "source <(kubectl completion bash)" >> ~/.bashrc
- en: '[PRE74]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: source ~/.bashrc
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: source ~/.bashrc
- en: '[PRE75]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: kubectl create [Tab][Tab]
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl create [Tab][Tab]
- en: '[PRE76]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: kubectl create deployment packt --image=nginxdemos/hello
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl create deployment packt --image=nginxdemos/hello
- en: '[PRE77]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: deployment.apps/packt created
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.apps/packt 已创建
- en: '[PRE78]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'kubectl run pod/packt-web), is not part of a Deployment:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl run pod/packt-web), 不是Deployment的一部分：
- en: '[PRE79]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We’ll see later in this section that this pod is not part of a ReplicaSet and
    so is not managed by the controller manager.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到，这个Pod不是ReplicaSet的一部分，因此不会由控制器管理器管理。
- en: 'Let’s look at the state of our system by querying the pods for detailed information:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查询Pod的详细信息来查看系统的状态：
- en: '[PRE80]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Let’s analyze the output:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下输出：
- en: '![Figure 16.35 – Getting the application pods with detailed information](img/B19682_16_35.jpg)'
  id: totrans-435
  prefs: []
  type: TYPE_IMG
  zh: '![图16.35 – 获取具有详细信息的应用程序Pod](img/B19682_16_35.jpg)'
- en: Figure 16.35 – Getting the application pods with detailed information
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.35 – 获取具有详细信息的应用程序Pod
- en: 'In the preceding output, you can see the series of commands described, and
    we can also see that our pods are up and running and that Kubernetes deployed
    them on separate nodes:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，你可以看到一系列描述的命令，我们还可以看到Pod已启动并正在运行，且Kubernetes已将它们部署到不同的节点上：
- en: '`packt-579bb9c999-rtvzr`: On cluster node `k8s-n1`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packt-579bb9c999-rtvzr`：在集群节点`k8s-n1`上'
- en: '`packt-web`: On cluster node `k8s-n3`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packt-web`：在集群节点`k8s-n3`上'
- en: Running the pods on different nodes is due to internal load balancing and resource
    distribution in the Kubernetes cluster.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同节点上运行 pod 是由于 Kubernetes 集群内部的负载均衡和资源分配。
- en: The application pod managed by the controller is `packt-579bb9c999-rtvzr`. Kubernetes
    generates a unique name for our managed pod by appending a `579bb9c999`) and a
    `rtvzr`) to the name of the Deployment (`packt`). The pod template hash and pod
    ID are unique within a ReplicaSet.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 由控制器管理的应用程序 pod 是 `packt-579bb9c999-rtvzr`。Kubernetes 为我们管理的 pod 生成一个唯一的名称，将`579bb9c999`
    和 `rtvzr` 附加到部署名称（`packt`）后面。Pod 模板哈希和 pod ID 在 ReplicaSet 中是唯一的。
- en: 'In contrast, the standalone pod (`packt-web`) is left as is since it’s not
    part of an application Deployment. Let’s describe both pods to obtain more information
    about them. We’ll start with the managed pod first. Don’t forget to use the `kubectl`
    autocompletion (by pressing the *Tab* key twice):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，独立 pod（`packt-web`）保持原样，因为它不属于应用程序部署。让我们先描述两个 pod，以获取更多信息。我们先从托管的 pod 开始。别忘了使用
    `kubectl` 自动补全（通过按*Tab*键两次）：
- en: '[PRE81]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The related output is relatively large. Here are some relevant snippets:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 相关输出较大。以下是一些相关摘录：
- en: '![Figure 16.36 – Pod information](img/B19682_16_36.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图16.36 – Pod 信息](img/B19682_16_36.jpg)'
- en: Figure 16.36 – Pod information
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.36 – Pod 信息
- en: 'In contrast, the same command for the standalone pod (`packt-web`) would be
    slightly different without featuring the `Controlled` `By` field:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，独立 pod（`packt-web`）的相同命令会稍有不同，不包含`Controlled` `By`字段：
- en: '[PRE82]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here are the corresponding excerpts:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关摘录：
- en: '![Figure 16.37 – Relevant pod information](img/B19682_16_37.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![图16.37 – 相关的 pod 信息](img/B19682_16_37.jpg)'
- en: Figure 16.37 – Relevant pod information
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.37 – 相关的 pod 信息
- en: 'You can also venture out to any of the cluster nodes where our pods are running
    and take a closer look at the related containers. Let’s take node `k8s-n3` (`192.168.122.163`),
    for example, where our standalone pod (`packt-web`) is running. We’ll SSH into
    the node’s terminal first:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以去集群中我们 pod 正在运行的任何节点，仔细查看相关容器。以节点`k8s-n3`（`192.168.122.163`）为例，其中我们独立的 pod（`packt-web`）正在运行。我们首先通过
    SSH 连接到该节点的终端：
- en: '[PRE83]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then we’ll use the `containerd` runtime to query the containers in the system:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用 `containerd` 运行时来查询系统中的容器：
- en: '[PRE84]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output shows the following:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示如下：
- en: '![Figure 16.38 – Getting the containers running on a cluster node](img/B19682_16_38.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![图16.38 – 获取在集群节点上运行的容器](img/B19682_16_38.jpg)'
- en: Figure 16.38 – Getting the containers running on a cluster node
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.38 – 获取在集群节点上运行的容器
- en: Next, we’ll show you how to access processes running inside the pods.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何访问在 pod 内运行的进程。
- en: Accessing processes in pods
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 pod 中的进程
- en: 'Let’s switch back to our local (on our local machine, not the VM) `kubectl`
    environment and run the following command to access the shell in the container
    running the `packt-web` pod:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换回本地（在本地机器上，而非虚拟机）`kubectl`环境，并运行以下命令以访问运行`packt-web` pod的容器中的 shell：
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The command takes us inside the container to an interactive shell prompt. Here,
    we can run commands as if we were logged in to the `packt-web` host using the
    terminal. The interactive session is produced using the `-it` option – interactive
    terminal – or `--``interactive --tty`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会将我们带入容器内的交互式 shell 提示符。在这里，我们可以像通过终端登录到 `packt-web` 主机一样运行命令。该交互式会话是通过 `-it`
    选项——交互式终端——或`--interactive --tty`选项产生的。
- en: 'Let’s run a few commands, starting with the process explorer:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些命令，首先从进程探测器开始：
- en: '[PRE86]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here’s a relevant excerpt from the output, showing the processes running inside
    the `packt-web` container, and some commands running inside it:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自输出的相关摘录，显示了在`packt-web`容器内运行的进程，以及一些在其中运行的命令：
- en: '![Figure 16.39 – The processes running inside the packt-web container](img/B19682_16_39.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图16.39 – 在 packt-web 容器内运行的进程](img/B19682_16_39.jpg)'
- en: Figure 16.39 – The processes running inside the packt-web container
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.39 – 在 packt-web 容器内运行的进程
- en: 'We can also retrieve the IP address with the following command:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以下命令检索 IP 地址：
- en: '[PRE87]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output shows the pod’s IP address (as seen in *Figure 16**.39*):'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了 pod 的 IP 地址（如*图16.39*所示）：
- en: '[PRE88]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We can also retrieve the hostname with the following command:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过以下命令检索主机名：
- en: '[PRE89]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output shows the pod name (as seen in *Figure 16**.39*):'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了 pod 名称（如*图16.39*所示）：
- en: '[PRE90]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Let’s leave the container shell with the `exit` command (as shown in *Figure
    16**.39*) or by pressing *Ctrl* + *D*. With the `kubectl` `exec` command, we can
    run any process inside a pod, assuming that the related process exists.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`exit`命令（如*图16.39*所示）或按*Ctrl* + *D*离开容器shell。通过`kubectl`的`exec`命令，我们可以在Pod内部运行任何进程，前提是相关进程存在。
- en: 'We’ll experiment next by testing the `packt-web` application pod using `curl`.
    We should note that, at this time, the only way to access the web server endpoint
    of `packt-web` is via its internal IP address. Previously, we used the `kubectl`
    `get pods -o wide` and `describe` commands to retrieve detailed information regarding
    pods, including the pod’s IP address. You can also use the following one-liner
    to retrieve the pod’s IP:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将通过测试`packt-web`应用程序Pod来进行实验。我们应该注意，在此时，访问`packt-web`的Web服务器端点的唯一方式是通过其内部IP地址。之前，我们使用了`kubectl`的`get
    pods -o wide`和`describe`命令来检索有关Pod的详细信息，包括Pod的IP地址。你也可以使用以下单行命令来获取Pod的IP：
- en: '[PRE91]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In our case, the command returns `172.16.57.193`. We used the `-o jsonpath`
    output option to specify the JSON query for a specific field, `{.status.podIP}`.
    Remember that the pod’s IP is only accessible within the pod network (`172.16.0.0/16`)
    inside the cluster. Following is a screenshot showing the output:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，该命令返回`172.16.57.193`。我们使用了`-o jsonpath`输出选项来指定特定字段的JSON查询，`{.status.podIP}`。记住，Pod的IP地址仅在集群内的Pod网络（`172.16.0.0/16`）内可访问。以下是显示输出的截图：
- en: '![Figure 16.40 – Testing the application pod](img/B19682_16_40.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![图16.40 – 测试应用程序Pod](img/B19682_16_40.jpg)'
- en: Figure 16.40 – Testing the application pod
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.40 – 测试应用程序Pod
- en: 'Consequently, we need to probe the `packt-web` endpoint using a `curl` command
    that has originated within the pod network. An easy way to accomplish such a task
    is to run a test pod with the `curl` utility installed:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要使用`curl`命令探测`packt-web`端点，该命令需在Pod网络内运行。完成此任务的一个简便方法是运行一个安装了`curl`工具的测试Pod：
- en: 'The following command runs a pod named `test`, based on the `curlimages/curl`
    Docker image:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令运行一个名为`test`的Pod，基于`curlimages/curl`的Docker镜像：
- en: '[PRE92]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '![Figure 16.41 – Running a test with curl on the pod](img/B19682_16_41.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![图16.41 – 在Pod上使用curl进行测试](img/B19682_16_41.jpg)'
- en: Figure 16.41 – Running a test with curl on the pod
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.41 – 在Pod上使用curl进行测试
- en: 'Now, we can run a simple `curl` command using the `test` pod targeting the
    `packt-web` web server endpoint:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`test` Pod运行一个简单的`curl`命令，目标是`packt-web` Web服务器端点：
- en: '[PRE93]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '2.  We’ll get an HTTP response and a corresponding **access log trace** (from
    the Nginx server running in the pod) accounting for the request. A snippet of
    the output is as follows:'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 我们将获得一个HTTP响应以及一个相应的**访问日志追踪**（来自Pod中运行的Nginx服务器），记录该请求。输出的一个片段如下所示：
- en: '![Figure 16.42 – The response of running the curl test](img/B19682_16_42.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图16.42 – 运行curl测试的响应](img/B19682_16_42.jpg)'
- en: Figure 16.42 – The response of running the curl test
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.42 – 运行curl测试的响应
- en: 'To view the logs on the `packt-web` pod, we run the following command:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看`packt-web` Pod的日志，我们运行以下命令：
- en: '[PRE94]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output is as follows:'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 16.43 – Logs for packt-web pod](img/B19682_16_43.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![图16.43 – packt-web Pod的日志](img/B19682_16_43.jpg)'
- en: Figure 16.43 – Logs for packt-web pod
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.43 – packt-web Pod的日志
- en: 'The logs in the `packt-web` pod are produced by Nginx and redirected to `stdout`
    and `stderr`. We can easily verify this with the following command:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`packt-web` Pod中的日志是由Nginx生成的，并被重定向到`stdout`和`stderr`。我们可以使用以下命令轻松验证这一点：'
- en: '[PRE95]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output shows the related symlinks:'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出显示了相关的符号链接：
- en: '![Figure 16.44 – Related symlinks](img/B19682_16_44.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图16.44 – 相关的符号链接](img/B19682_16_44.jpg)'
- en: Figure 16.44 – Related symlinks
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.44 – 相关的符号链接
- en: 'When you’re done using the `test` pod, you can delete it with the following
    command:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用完`test` Pod后，可以通过以下命令删除它：
- en: '[PRE96]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Now that we have deployed our first application inside a Kubernetes cluster,
    let’s look at how to expose the related endpoint to the world. Next, we will expose
    Deployments via a Service.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Kubernetes集群内部署了第一个应用程序，让我们来看看如何将相关端点暴露给全世界。接下来，我们将通过服务暴露部署。
- en: Exposing Deployments as Services
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 将部署暴露为服务
- en: 'Now, let’s rewind to the command we used previously to create the `packt` Deployment.
    Don’t run it. Here it is just as a refresher:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下我们之前用来创建`packt`部署的命令。不要运行它，以下只是一个复习：
- en: '[PRE97]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The command carried out the following sequence:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令执行了以下序列：
- en: It created a Deployment (`packt`).
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建了一个部署（`packt`）。
- en: The Deployment created a ReplicaSet (`packt-579bb9c999`).
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署创建了一个ReplicaSet（`packt-579bb9c999`）。
- en: The ReplicaSet created the pod (`packt-579bb9c999-rtvzr`).
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet 创建了 pod（`packt-579bb9c999-rtvzr`）。
- en: 'We can verify that with the following commands:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令进行验证：
- en: '[PRE98]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the preceding commands, we used the `--label-columns (-l)` flag to filter
    results by the `app=packt` label, denoting the `packt` Deployment’s resources.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `--label-columns (-l)` 标志，通过 `app=packt` 标签过滤结果，表示 `packt` 部署的资源。
- en: 'We encourage you to take a closer look at each of these resources using the
    `kubectl describe` command. Don’t forget to use the `kubectl` autocomplete feature
    when typing in the commands:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您使用 `kubectl describe` 命令仔细查看这些资源。不要忘记在输入命令时使用 `kubectl` 自动完成功能：
- en: '[PRE99]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `kubectl` `describe` command could be very resourceful when troubleshooting
    applications or pod Deployments. Look inside the *Events* section in the related
    output for clues on pods failing to start, errors, if any, and possibly understand
    what went wrong.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` `describe` 命令在故障排除应用程序或 pod 部署时非常有用。检查相关输出中的 *Events* 部分，查找 pod 启动失败、错误（如果有的话）以及可能导致问题的线索。'
- en: Now that we have deployed our first application inside a Kubernetes cluster,
    let’s look at how to expose the related endpoint to the world.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Kubernetes 集群中部署了第一个应用程序，让我们看看如何将相关的端点暴露给全世界。
- en: 'So far, we have deployed an application (`packt`) with a single pod (`packt-579bb9c999-rtvzr`)
    running an Nginx web server listening on port `80`. As we explained earlier, at
    this time, we can only access the pod within the pod network, which is internal
    to the cluster. In this section, we’ll show you how to expose the application
    (or Deployment) to be accessible from the outside world. Kubernetes uses the Service
    API object, consisting of a **proxy** and a **selector** routing the network traffic
    to application pods in a Deployment. To proceed, you can follow these steps:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经部署了一个应用程序（`packt`），它在一个 pod（`packt-579bb9c999-rtvzr`）中运行 Nginx Web
    服务器，并在端口 `80` 上监听。如前所述，此时我们只能在 pod 网络内访问该 pod，这个网络仅对集群内部可见。在本节中，我们将展示如何将应用程序（或部署）暴露出去，以便外部世界能够访问。Kubernetes
    使用 Service API 对象，包括 **代理** 和 **选择器**，将网络流量路由到部署中的应用 pod。接下来，您可以按照以下步骤进行操作：
- en: 'The following command creates a Service for our Deployment (`packt`):'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令为我们的部署（`packt`）创建一个 Service：
- en: '[PRE100]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '2.  Let’s take a closer look at our Service (`packt`):'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 让我们更仔细地看一下我们的 Service（`packt`）：
- en: '[PRE101]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '![Figure 16.45 – The service exposing the packt deployment](img/B19682_16_45.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.45 – 暴露 packt 部署的服务](img/B19682_16_45.jpg)'
- en: Figure 16.45 – The Service exposing the packt Deployment
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.45 – 暴露 packt 部署的服务
- en: Also, `EXTERNAL-IP` (`<none>`) should not be mistaken for the cluster node’s
    IP address where our Service is accessible. The external IP is usually a load
    balancer IP address configured by a cloud provider hosting the Kubernetes cluster
    (configurable via the `--``external-ip` flag).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`EXTERNAL-IP`（`<none>`）不应与集群节点的 IP 地址混淆，后者是我们可以访问 Service 的位置。外部 IP 通常是由云提供商配置的负载均衡器的
    IP 地址（可通过 `--external-ip` 标志进行配置）。
- en: 'We should now be able to access our application outside the cluster by pointing
    a browser to any of the cluster nodes on port `32664`. To get a list of our cluster
    nodes with their respective IP addresses and hostnames, we can run the following
    command:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该能够通过将浏览器指向集群节点上的任何一个，访问集群外部的应用程序，端口为 `32664`。要获取集群节点的列表及其对应的 IP 地址和主机名，我们可以运行以下命令：
- en: '[PRE102]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 16.46 – List of cluster nodes](img/B19682_16_46.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.46 – 集群节点列表](img/B19682_16_46.jpg)'
- en: Figure 16.46 – List of cluster nodes
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.46 – 集群节点列表
- en: 'Let’s choose the CP node (`192.168.122.104/k8s-cp1`) and enter the following
    address in a browser: http://192.168.122.104:32664.'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们选择 CP 节点（`192.168.122.104/k8s-cp1`），并在浏览器中输入以下地址：http://192.168.122.104:32664。
- en: 'The web request from the browser is directed to the Service endpoint (`packt`),
    which routes the related network packets to the application pod (`packt-579bb9c999-rtvzr`).
    The `packt` web application responds with a simple Nginx `172.16.215.65`) and
    name (`packt-579bb9c999-rtvzr`):'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 浏览器发出的 Web 请求被定向到服务端点（`packt`），它将相关的网络数据包路由到应用 pod（`packt-579bb9c999-rtvzr`）。`packt`
    Web 应用响应一个简单的 Nginx `172.16.215.65`）和名称（`packt-579bb9c999-rtvzr`）：
- en: '![Figure 16.47 – Accessing the packt application service](img/B19682_16_47.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.47 – 访问 packt 应用服务](img/B19682_16_47.jpg)'
- en: Figure 16.47 – Accessing the packt application Service
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.47 – 访问 packt 应用服务
- en: 'To verify that the information on the web page is accurate, you may run the
    following `kubectl` command, retrieving similar information:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证网页上的信息是否准确，你可以运行以下 `kubectl` 命令，检索类似的信息：
- en: '[PRE103]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output of the command will be the internal IP address and the name of the
    pod, as shown in the following:'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命令的输出将是 pod 的内部 IP 地址和名称，如下所示：
- en: '![Figure 16.48 – Verify the information with the kubectl command](img/B19682_16_48.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.48 – 使用 kubectl 命令验证信息](img/B19682_16_48.jpg)'
- en: Figure 16.48 – Verify the information with the kubectl command
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.48 – 使用 kubectl 命令验证信息
- en: Suppose we have high traffic targeting our application, and we’d like to scale
    out the ReplicaSet controlling our pods. We’ll show you how to accomplish this
    task in the next section.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有大量流量访问我们的应用，我们希望扩展控制 pod 的 ReplicaSet。在下一节中，我们将展示如何完成此任务。
- en: Scaling application Deployments
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展应用部署
- en: 'Currently, we have a single pod in the `packt` Deployment. In order to scale
    the application Deployments, we have to obtain information about the running replicas,
    to scale them to the desired number and test it. Here are the steps to take:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，我们在 `packt` 部署中只有一个 pod。为了扩展应用部署，我们必须先获取运行副本的信息，以便将它们扩展到所需的数量并进行测试。以下是操作步骤：
- en: 'To retrieve the relevant details about the number of running replicas, we run
    the following command:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取关于运行副本数量的相关详细信息，我们运行以下命令：
- en: '[PRE104]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The relevant excerpt in the output is as follows:'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出中相关的摘录如下：
- en: '![Figure 16.49 – Pod details](img/B19682_16_49.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.49 – Pod 详情](img/B19682_16_49.jpg)'
- en: Figure 16.49 – Pod details
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.49 – Pod 详情
- en: 'Let’s scale up our `packt` Deployment to 10 replicas with the following command:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将 `packt` 部署扩展到 10 个副本，使用以下命令：
- en: '[PRE105]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: kubectl get pods -l app=packt
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl get pods -l app=packt
- en: '[PRE106]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '![Figure 16.50 – Scaling up the deployment replicas](img/B19682_16_50.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.50 – 扩展部署副本](img/B19682_16_50.jpg)'
- en: Figure 16.50 – Scaling up the Deployment replicas
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.50 – 扩展 Deployment 副本
- en: 'Incoming requests to our application Service endpoint (`http://192.168.122.104:32664`)
    will be load balanced between the pods. To illustrate this behavior, we can either
    use `curl` or a text-based browser at the command line to avoid the caching-related
    optimizations of a modern desktop browser. For a better illustration, we’ll use
    **Lynx**, a simple text-based browser. On our Debian 12 desktop, the package is
    already installed. You can install it with the following command:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传入的请求将通过负载均衡分配到我们的应用服务端点（`http://192.168.122.104:32664`）的各个 pod。为了说明这一行为，我们可以使用
    `curl` 或者命令行中的文本浏览器，以避免现代桌面浏览器的缓存优化。为了更好地展示，我们将使用**Lynx**，一个简单的文本浏览器。在我们的 Debian
    12 桌面上，已经安装了该软件包。你可以通过以下命令安装它：
- en: '[PRE107]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '2.  Next, we point Lynx to our application endpoint:'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 接下来，我们将 Lynx 指向我们的应用端点：
- en: '[PRE108]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If we refresh the page with *Ctrl* + *R* every few seconds, we observe that
    the server address and name change based on the current pod processing the request:'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们每隔几秒钟使用 *Ctrl* + *R* 刷新页面，我们会观察到服务器地址和名称会根据当前处理请求的 pod 发生变化：
- en: '![Figure 16.51 – Load balancing requests across pods](img/B19682_16_51.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.51 – 在各个 pod 之间负载均衡请求](img/B19682_16_51.jpg)'
- en: Figure 16.51 – Load balancing requests across pods
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.51 – 在各个 pod 之间负载均衡请求
- en: You can exit the Lynx browser by typing `Q` and then pressing *Enter*.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入 `Q` 然后按 *Enter* 来退出 Lynx 浏览器。
- en: 'We can scale back our Deployment (`packt`) to three replicas (or any other
    non-zero positive number) with the following command:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将我们的 Deployment（`packt`）缩减为三个副本（或任何其他非零正整数）：
- en: '[PRE109]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: kubectl get pods -l app=packt
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl get pods -l app=packt
- en: '[PRE110]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '![Figure 16.52 – Scaling back to three pods](img/B19682_16_52.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.52 – 缩减到三个 pod](img/B19682_16_52.jpg)'
- en: Figure 16.52 – Scaling back to three pods
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.52 – 缩减到三个 pod
- en: 'Before concluding our imperative Deployments, let’s clean up all the resources
    we have created thus far:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结束我们的命令式部署之前，让我们清理迄今为止创建的所有资源：
- en: '[PRE111]'
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '2.  The following command should reflect a clean slate:'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2. 下面的命令应显示一个干净的状态：
- en: '[PRE112]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output is as follows:'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 16.53 – The cluster in a default state](img/B19682_16_53.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.53 – 默认状态下的集群](img/B19682_16_53.jpg)'
- en: Figure 16.53 – The cluster in a default state
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.53 – 默认状态下的集群
- en: In the next section, we’ll look at how to deploy resources and applications
    declaratively in the Kubernetes cluster.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何在 Kubernetes 集群中声明性地部署资源和应用。
- en: Working with declarative Deployments
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式部署
- en: 'At the heart of a declarative Deployment is a manifest file. Manifest files
    are generally in YAML format and authoring them usually involves a mix of autogenerated
    code and manual editing. The manifest is then deployed using the `kubectl` `apply`
    command:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式部署的核心是清单文件。清单文件通常采用 YAML 格式，编写时通常会结合自动生成的代码和手动编辑。然后，使用 `kubectl` `apply`
    命令部署清单：
- en: '[PRE113]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Deploying resources declaratively in Kubernetes involves the following stages:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中声明式部署资源涉及以下阶段：
- en: Creating a manifest file
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建清单文件
- en: Updating the manifest
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新清单
- en: Validating the manifest
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证清单
- en: Deploying the manifest
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署清单
- en: Iterating between the preceding stages
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前述阶段之间进行迭代
- en: To illustrate the declarative model, we follow the example of deploying a simple
    Hello World web application to the cluster. The result will be similar to our
    previous approach of using the imperative method.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明声明式模型，我们以将一个简单的 Hello World web 应用程序部署到集群为例。结果将类似于我们之前使用命令式方法的做法。
- en: So, let’s start by creating a manifest for our Deployment.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从为我们的部署创建一个清单开始。
- en: Creating a manifest
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 创建清单
- en: 'When we created our `packt` Deployment imperatively, we used the following
    command (don’t run it just yet!):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们命令式地创建我们的 `packt` 部署时，我们使用了以下命令（先别运行！）：
- en: '[PRE114]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The following command will simulate the same process without changing the system
    state:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将模拟相同的过程，而不会改变系统状态：
- en: '[PRE115]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We used the following additional options (flags):'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下附加选项（标志）：
- en: '`--dry-run=client`: This runs the command in the local `kubectl` environment
    (*client*) without modifying the system state'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dry-run=client`：此命令在本地 `kubectl` 环境（*客户端*）中运行，不会修改系统状态'
- en: '`--output=yaml`: This formats the command output as YAML'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--output=yaml`：此选项将命令输出格式化为 YAML'
- en: 'The output of the command is as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '![Figure 16.54 – Simulating a manifest creation](img/B19682_16_54.jpg)'
  id: totrans-598
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.54 – 模拟清单创建](img/B19682_16_54.jpg)'
- en: Figure 16.54 – Simulating a manifest creation
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.54 – 模拟清单创建
- en: 'We can use the previous command’s output to analyze the changes to be made
    to the system. Then we can redirect it to a file (`packt.yaml`) serving as a draft
    of our Deployment manifest:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前一个命令的输出分析系统中需要做的更改。然后我们可以将其重定向到一个文件（`packt.yaml`），作为我们部署清单的草稿：
- en: '[PRE116]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: kubectl apply -f packt.yaml --dry-run=client
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl apply -f packt.yaml --dry-run=client
- en: '[PRE117]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: deployment.apps/packt created (dry run)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.apps/packt created (dry run)
- en: '[PRE118]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: kubectl apply -f packt.yaml
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl apply -f packt.yaml
- en: '[PRE119]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: deployment.apps/packt created
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.apps/packt created
- en: '[PRE120]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: kubectl get all -l app=packt
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get all -l app=packt
- en: '[PRE121]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: kubectl expose deployment packt \
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl expose deployment packt \
- en: --port=80 \
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --port=80 \
- en: --target-port=80 \
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --target-port=80 \
- en: --type=NodePort \
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --type=NodePort \
- en: --dry-run=client --output=yaml > packt-svc.yaml
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: --dry-run=client --output=yaml > packt-svc.yaml
- en: '[PRE122]'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: kubectl apply -f packt-svc.yaml --dry-run=client
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl apply -f packt-svc.yaml --dry-run=client
- en: '[PRE123]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'packt resources:'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: packt 资源：
- en: '[PRE124]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'spec:'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'replicas: 1'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'replicas: 1'
- en: '[PRE126]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'spec:'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'replicas: 10'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'replicas: 10'
- en: '[PRE127]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'packt Deployment has been reconfigured:'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: packt 部署已重新配置：
- en: '[PRE128]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'packt Deployment, including the additional pods deployed in the cluster:'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: packt 部署，包括在集群中部署的附加 pod：
- en: '[PRE129]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: kubectl edit deployment packt
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl edit deployment packt
- en: '[PRE131]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: kubectl edit will not be reflected in the Deployment manifest (packt.yaml).
    Nevertheless, the related configuration changes are persisted in the cluster (etcd).
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl edit 不会反映在部署清单（packt.yaml）中。不过，相关的配置更改会保存在集群（etcd）中。
- en: '[PRE132]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: kubectl get deployment packt
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl get deployment packt
- en: '[PRE133]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: kubectl delete service packt
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl delete service packt
- en: kubectl delete deployment packt
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: kubectl delete deployment packt
- en: '[PRE134]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
