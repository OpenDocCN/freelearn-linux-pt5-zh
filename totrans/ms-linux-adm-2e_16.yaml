- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying Applications with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are a seasoned system administrator managing containerized applications
    or a DevOps engineer automating app orchestration workflows, **Kubernetes** could
    be your platform of choice. This chapter will introduce you to Kubernetes and
    will guide you through the basic process of building and configuring a **Kubernetes
    cluster**. We’ll use Kubernetes to run and scale a simple application in a secure
    and highly available environment. You will also learn how to interact with Kubernetes
    using the **command-line** **interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll learn how to install, configure, and manage
    a Kubernetes cluster on-premises. We’ll also show you how to deploy and scale
    an application using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a brief outline of the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes architecture and the API object model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Kubernetes using the `kubectl` command-line tool and deploying
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be familiar with Linux and the CLI in general. A good grasp of **TCP/IP
    networking** and **Docker** containers would go a long way in making your journey
    of learning Kubernetes easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A local desktop machine with a Linux distribution of your choice to install
    and experiment with the CLI tools used in this chapter. We will use both Debian
    and Ubuntu LTS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A powerful desktop system with at least 8 CPU cores and at least 16 GB of RAM
    will allow you to replicate the necessary environment on your desktop as we’ll
    be devoting a relatively large section to building a Kubernetes cluster using
    VMs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A desktop hypervisor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s start our journey together to discover Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is an open source **container orchestrator** initially developed
    by Google. A container orchestrator is a piece of software that automatically
    manages (including provisioning, deployment, and scaling) containerized applications.
    Assuming an application uses containerized microservices, a container orchestration
    system provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Elastic orchestration (autoscaling)**: This involves automatically starting
    and stopping application services (containers) based on specific requirements
    and conditions – for example, launching multiple web server instances with an
    increasing number of requests and eventually terminating servers when the number
    of requests drops below a certain threshold'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workload management**: This involves optimally deploying and distributing
    application services across the underlying cluster to ensure mandatory dependencies
    and redundancy – for example, running a web server endpoint on each cluster node
    for high availability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure abstraction**: This involves providing container runtime,
    networking, and load-balancing capabilities – for example, distributing the load
    among multiple web server containers and autoconfiguring the underlying network
    connectivity with a database app container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative configuration**: This involves describing and ensuring the desired
    state of a multi-tiered application – for example, a web server should be ready
    for serving requests only when the database backend is up and running, and the
    underlying storage is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A classic example of workload orchestration is a video-on-demand streaming service.
    With a popular new TV show in high demand, the number of streaming requests would
    significantly exceed the average during a regular season. With **Kubernetes**,
    we could scale out the number of web servers based on the volume of streaming
    sessions. We could also control the possible scale-out of some of the middle-tier
    components, such as database instances (serving the authentication requests) and
    storage cache (serving the streams). When the TV show goes out of fashion, and
    the number of requests drops significantly, Kubernetes terminates the surplus
    instances, automatically reducing the application deployment’s footprint and,
    consequently, the underlying costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key benefits of deploying applications with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Speedy deployment**: Application containers are created and launched relatively
    fast, using either a **declarative** or **imperative** configuration model (as
    we’ll see in the *Introducing the Kubernetes object model* section later in this
    chapter)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick iterations**: Application upgrades are relatively straightforward,
    with the underlying infrastructure simply seamlessly replacing the related container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rapid recovery**: If an application crashes or becomes unavailable, Kubernetes
    automatically restores the application to the desired state by replacing the related
    container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced operation costs**: The containerized environment and infrastructure
    abstraction of Kubernetes yields minimal administration and maintenance efforts
    with relatively low resources for running applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have introduced Kubernetes, let’s look at its basic operating principles
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Kubernetes architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three major concepts at the core of the working model of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative configuration or desired state**: This concept describes the
    overall application state and microservices, deploying the required containers
    and related resources, including network, storage, and load balancers, to achieve
    a running functional state of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controllers or controller loops**: This monitors the desired state of the
    system and takes corrective action when needed, such as replacing a failed application
    container or adding additional resources for scale-out workloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API object model**: This model represents the actual implementation of the
    desired state, using various configuration objects and the interaction – the **application
    programming interface** (**API**) – between these objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a better grasp of the internals of Kubernetes, we need to take a closer
    look at the Kubernetes object model and related API. Also, you can check out *Figure
    16**.1* for a visual explanation of the Kubernetes (cluster) architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Kubernetes object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kubernetes architecture defines a collection of objects representing the
    desired state of a system. An **object**, in this context, is a programmatic term
    to describe the behavior of a subsystem. Multiple objects interact with one another
    via the API, shaping the desired state over time. In other words, the Kubernetes
    object model is the programmatic representation of the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are these objects in Kubernetes? We’ll briefly enumerate some of the
    more important ones and further elaborate on each in the following sections: API
    server, pods, controllers, services, and storage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use these API objects to configure the system’s state, using either a declarative
    or imperative model:'
  prefs: []
  type: TYPE_NORMAL
- en: With a **declarative configuration model**, we describe the state of the system,
    usually with a configuration file or manifest (in YAML or JSON format). Such a
    configuration may include and deploy multiple API objects and regard the system
    as a whole.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **imperative configuration model** uses individual commands to configure
    and deploy specific API objects, typically acting on a single target or subsystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the API server first – the central piece in the Kubernetes object
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the API server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The API server is the core hub of the Kubernetes object model, acting as a
    management endpoint for the desired state of the system. The API server exposes
    an HTTP REST interface using JSON payloads. It is accessible in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internally**: It is accessed internally by other API objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Externally**: It is accessed externally by configuration and management workflows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API server is essentially the gateway of interaction with the Kubernetes
    cluster, both from the outside and within. A Kubernetes cluster is a framework
    of different nodes that run containerized applications. The cluster is the basic
    running mode of Kubernetes itself. More on the Kubernetes cluster will be provided
    in the *Anatomy of a Kubernetes cluster* section. A system administrator connects
    to the API server endpoint to configure and manage a Kubernetes cluster, typically
    via a CLI. Internally, Kubernetes API objects connect to the API server to provide
    an update of their state. In return, the API server may further adjust the internal
    configuration of the API objects toward the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: The API objects are the building blocks of the internal configuration or desired
    state of a Kubernetes cluster. Let’s look at a few of these API objects next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing pods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **pod** represents the basic working unit in Kubernetes, running as a single-
    or multi-container application. A pod is also known as the **unit of scheduling**
    in Kubernetes. In other words, containers within the same pod are guaranteed to
    be deployed together on the same cluster node.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pod essentially represents a microservice (or a service) within the application’s
    service mesh. Considering the classic example of a web application, we may have
    the following pods running in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Web server (Nginx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication (Vault)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database (PostgreSQL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage (NAS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these services (or applications) runs within their pod. Multiple pods
    of the same application (for example, a web server) make up a **ReplicaSet**.
    We’ll look at ReplicaSets closer in the *Introducing* *controllers* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some essential features of pods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They have an **ephemeral nature**. Once a pod is terminated, it is gone for
    good. No pod ever gets redeployed in Kubernetes. Consequently, pods don’t persist
    in any state unless they use persistent storage or a local volume to save their
    data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods are an **atomic unit** – they are either deployed or not. For a single-container
    pod, atomicity is almost a given. For multi-container pods, atomicity means that
    a pod is deployed only when each of the constituent containers is deployed. If
    any of the containers fail to deploy, the pod will not be deployed, and hence
    there’s no pod. If one of the containers within a running multi-container pod
    fails, the whole pod is terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes uses **probes** (such as liveliness and readiness) to monitor the
    health of an application inside a pod. This is because a pod could be deployed
    and running, but that doesn’t necessarily mean the application or service within
    the pod is healthy. For example, a web server pod can have a probe that checks
    a specific URL and decides whether it’s healthy based on the response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes tracks the state of pods using controllers. Let’s look at controllers
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Controllers** in Kubernetes are control loops responsible for keeping the
    system in the desired state or bringing the system closer to the desired state
    by constantly watching the state of the cluster. For example, a controller may
    detect that a pod is not responding and request the deployment of a new pod while
    terminating the old one. Let’s look at two key types of controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: A controller may also add or remove pods of a specific type to and from a collection
    of pod replicas. Such controllers are called **ReplicaSets**, and their responsibility
    is to accommodate a particular number of pod replicas based on the current state
    of the application. For example, suppose an application requires three web server
    pods, and one of them becomes unavailable (due to a failed probe). In that case,
    the ReplicaSet controller ensures that the failed pod is deleted, and a new one
    takes its place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deploying applications in Kubernetes, we usually don’t use ReplicaSets
    directly to create pods. We use the `v1`) with several pods, all running version
    1 of our application, and we want to upgrade them to version 2\. Remember, pods
    cannot be regenerated or upgraded. Instead, we’ll define a second ReplicaSet (`v2`),
    creating the version 2 pods. The Deployment controller will tear down the `v1`
    ReplicaSet and bring up `v2`. Kubernetes performs the rollout seamlessly, with
    minimal to no disruption of service. The Deployment controller manages the transition
    between the `v1` and `v2` ReplicaSets and even rolls back the transition if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other controller types in Kubernetes, and we encourage you to
    explore them at [https://kubernetes.io/docs/concepts/workloads/controllers/](https://kubernetes.io/docs/concepts/workloads/controllers/).
  prefs: []
  type: TYPE_NORMAL
- en: As applications scale-out or terminate, the related pods are deployed or removed.
    Services provide access to the dynamic and transient world of pods. We’ll look
    at Services next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Services** provide persistent access to the applications running in pods.
    It is the Services’ responsibility to ensure that the pods are accessible by routing
    the traffic to the corresponding application endpoints. In other words, Services
    provide network abstraction for communicating with pods through IP addresses,
    routing, and DNS resolution. As pods are deployed or terminated based on the system’s
    desired state, Kubernetes dynamically updates the Service endpoint of the pods,
    with minimal to no disruption in terms of accessing the related applications.
    As users and applications access the Service endpoint’s persistent IP address,
    the Service will ensure that the routing information is up to date and traffic
    is exclusively routed to the running and healthy pods. Services can also be leveraged
    to load-balance the application traffic between pods and scale pods up or down
    based on demand.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at Kubernetes API objects controlling the deployment,
    access, and life cycle of application Services. What about the persistent data
    that applications require? We’ll look at the Kubernetes storage next.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes provides various storage types for applications running within the
    cluster. The most common are **volumes** and **persistent volumes**. Due to the
    ephemeral nature of pods, application data stored within a pod using volumes is
    lost when the pod is terminated. Persistent volumes are defined and managed at
    the Kubernetes cluster level, and they are independent of pods. Applications (pods)
    requiring a persistent state would reserve a persistent volume (of a specific
    size), using a **persistent volume claim**. When a pod using a persistent volume
    terminates, the new pod replacing the old one retrieves the current state from
    the persistent volume and will continue using the underlying storage.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Kubernetes storage types, please refer to [https://kubernetes.io/docs/concepts/storage/](https://kubernetes.io/docs/concepts/storage/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are familiar with the Kubernetes API object model, let’s quickly
    go through the architecture of a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Kubernetes cluster consists of one **Control Plane** (**CP**) **node** and
    one or more **worker nodes**. The following diagram presents a high-level view
    of the Kubernetes architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Kubernetes cluster architecture](img/B19682_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.1 – Kubernetes cluster architecture
  prefs: []
  type: TYPE_NORMAL
- en: The components of a Kubernetes cluster that are shown in the preceding figure
    are divided into the worker node and CP node as the two major components. The
    Worker nodes have different components, such as the container runtime, kubelet,
    and kube-proxy, and the CP node has the API server, the controller manager, and
    the scheduler. All of these components will be discussed in detail in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s look at the Kubernetes cluster nodes shown in the preceding image
    in some detail next, starting with the CP node.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Kubernetes CP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Kubernetes CP** provides essential Services for deploying and orchestrating
    application workloads, and it runs on a dedicated node in the Kubernetes cluster
    – the CP node. This node, also known as the **master node**, implements the core
    components of a Kubernetes cluster, such as resource scheduling and monitoring.
    It’s also the primary access point for cluster administration. Here are the key
    subsystems of a CP node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API server**: The central communication hub between Kubernetes API objects;
    it also provides the cluster’s management endpoint accessible either via CLI or
    the Kubernetes web administration console (dashboard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: This decides when and which nodes to deploy the pods on, depending
    on resource allocation and administrative policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller manager**: This maintains the control loops, monitoring and shaping
    the desired state of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**: Also known as the **cluster store**, this is a highly available persisted
    database, maintaining the state of the Kubernetes cluster and related API objects;
    the information in etcd is stored as key-value pairs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`: The primary administrative CLI for managing and interacting with
    the Kubernetes cluster; `kubectl` communicates directly with the API server, and
    it may connect remotely to a cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed architectural overview of the Kubernetes CP is beyond the scope of
    this chapter. You may explore the related concepts in more detail at [https://kubernetes.io/docs/concepts/architecture/](https://kubernetes.io/docs/concepts/architecture/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a brief look at the Kubernetes node – the workhorse of a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Kubernetes nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a Kubernetes cluster, the **nodes** – also referred to as **worker nodes**
    – run the actual application pods and maintain their full life cycle. Nodes provide
    the compute capacity of Kubernetes and ensure that the workloads are uniformly
    distributed across the cluster when deploying and running pods. Nodes can be configured
    either as physical (bare metal) or VMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s enumerate the key elements of a Kubernetes node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubelet**: This processes CP requests (from the scheduler) to deploy and
    start application pods; the kubelet also monitors the node and pod state, reporting
    the related changes to the API server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kube-Proxy**: Dynamically configures the virtual networking environment for
    the applications running in the pods; it routes the network traffic, provides
    load balancing, and maintains the IP addresses of Services and pods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containerd` and Docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding Services run on *each* node in the Kubernetes cluster, including
    the CP node. These components in the CP are required by special-purpose pods,
    providing specific CP Services, such as DNS, ingress (load balancing), and dashboard
    (web console).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Kubernetes nodes and related architectural concepts,
    please visit [https://kubernetes.io/docs/concepts/architecture/nodes/](https://kubernetes.io/docs/concepts/architecture/nodes/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have become familiar with some of the key concepts and cluster components,
    let’s get ready to install and configure Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before installing or using Kubernetes, you have to decide on the infrastructure
    you’ll use, whether that be on-premises or public cloud. Second, you’ll have to
    choose between an **Infrastructure-as-a-Service** (**IaaS**) or a **Platform-as-a-Service**
    (**PaaS**) model. With IaaS, you’ll have to install, configure, manage, and maintain
    the Kubernetes cluster yourself, either on physical (bare metal) or VMs. The related
    operation efforts are not straightforward and should be considered carefully.
    If you choose a PaaS solution, available from all major public cloud providers,
    you’ll be limited to only administrative tasks but saved from the burden of maintaining
    the underlying infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover only IaaS deployments of Kubernetes. For IaaS,
    we’ll use a local desktop environment running Ubuntu VMs.
  prefs: []
  type: TYPE_NORMAL
- en: For the on-premises installation, we may also choose between a lightweight desktop
    version of Kubernetes or a full-blown cluster with multiple nodes. Let’s look
    at some of the most common desktop versions of Kubernetes next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes on a desktop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re looking only to experiment with Kubernetes, a desktop version may
    fit the bill. Desktop versions of Kubernetes usually deploy a single-node cluster
    on your local machine. Depending on your platform of choice, whether it be Windows,
    macOS, or Linux, you have plenty of Kubernetes engines to select from. Here are
    just a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Desktop (macOS,** **Windows)**: [https://www.docker.com/products/docker-desktop](https://www.docker.com/products/docker-desktop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**minikube (Linux, macOS,** **Windows)**: [https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microk8s (Linux, macOS,** **Windows)**: [https://microk8s.io/](https://microk8s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**k3s (****Linux)**: [https://k3s.io/](https://k3s.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we’ll show you how to install Microk8s, one of the trending
    Kubernetes desktop engines at the time of writing. Microk8s is available to install
    via the Snap Store. We will use Debian 12 as the base operating system on our
    test computer, so we can install Microk8s from the Snap Store. If you don’t have
    `snapd` installed, you will have to first proceed and install it. You will have
    to use the following command to install the Snap daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have `snapd` installed, you can skip this first step. The following
    step will be to run the command to install the `snapd` core runtime environment
    needed to run the Snap Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Only after `snap` is installed, you can install `microk8s` by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A successful installation of Microk8s should yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – Installing Microk8s on Linux](img/B19682_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.2 – Installing Microk8s on Linux
  prefs: []
  type: TYPE_NORMAL
- en: As we already had `snapd` installed, we did not run the first of the commands
    listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the Microk8s CLI without `sudo` permissions, you’ll have to add the
    local user account to the `microk8s` group and also fix the permissions on the
    `~/.kube` directory with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes will take effect on the next login, and you can use the `microk8s`
    command-line utility with invocations that are not `sudo`. For example, the following
    command displays the help for the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the status of the local single-node Microk8s Kubernetes cluster, we
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the installation steps of Microk8s on Debian are straightforward
    and similar to the ones used in Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will show you how to install Microk8s on a VM. This
    time, we will use Ubuntu 22.04 LTS as the base operating system for the VM.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes on VMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll get closer to a real-world Kubernetes environment – though
    at a much smaller scale – by deploying a Kubernetes cluster on Ubuntu VMs. You
    can use any hypervisor, such as KVM, Oracle VirtualBox, or VMware Fusion. We will
    use KVM as our preferred hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: We will create four VMs, and we’ll provision each VM with 2 vCPU cores, 2 GB
    RAM, and 20 GB disk capacity. You may follow the steps described in the *Installing
    Ubuntu* section of [*Chapter 1*](B19682_01.xhtml#_idTextAnchor030), *Installing
    Linux*, using your hypervisor of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the Kubernetes cluster installation details, let’s take
    a quick look at our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the lab environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here are the specs of our VM environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypervisor**: VMware Fusion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes cluster**: One CP node and three worker nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s-cp1`: `192.168.122.104`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`k8s-n1`: `192.168.122.146`*   `k8s-n2`: `192.168.122.233`*   `k8s-n3`: `192.168.122.163`*   **VMs**:
    Ubuntu Server 22.04.3 LTS, 2 vCPUs, 2 GB RAM, 20 GB disk*   `packt` (on all nodes),
    with SSH access enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the username and hostname settings on each VM node on the Ubuntu Server
    installation wizard. Also, make sure to enable the OpenSSH server when prompted.
    Your VM IP addresses would most probably be different from those in the specs,
    but that shouldn’t matter. You may also choose to use static IP addresses for
    your VMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make hostname resolution simple within the cluster, edit the `/etc/hosts`
    file on each node and add the related records. For example, we have the following
    `/etc/hosts` file on the CP node (`k8s-cp1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)](img/B19682_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.3 – The /etc/hosts file on the CP node (k8s-cp1)
  prefs: []
  type: TYPE_NORMAL
- en: In production environments, with the firewall enabled on the cluster nodes,
    we have to make sure that the following rules are configured for accepting network
    traffic within the cluster (according to [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/):)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – The ports used by the Kubernetes cluster nodes](img/B19682_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.4 – The ports used by the Kubernetes cluster nodes
  prefs: []
  type: TYPE_NORMAL
- en: The following sections assume that you have the VMs provisioned and running
    according to the preceding specs. You may take some initial snapshots of your
    VMs before proceeding with the next steps. If anything goes wrong with the installation,
    you can revert to the initial state and start again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps we’ll follow to install the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Disable swapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `containerd.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `kubelet`, `kubeadm`, and Kubernetes packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll have to perform these steps on each cluster node. The related commands
    are also captured in the accompanying chapter source code on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the first step and disable the memory swap on each node.
  prefs: []
  type: TYPE_NORMAL
- en: Disable swapping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`swap` is a disk space used when the memory is full (refer to [https://github.com/kubernetes/kubernetes/issues/53533](https://github.com/kubernetes/kubernetes/issues/53533)
    for more details). The Kubernetes kubelet package doesn’t work with `swap` enabled
    on Linux platforms. This means that we will have to disable `swap` on all the
    nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable `swap` immediately, we run the following command on each VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To persist the disabled `swap` with system reboots, we need to comment out
    the `swap`-related entries in `/etc/fstab`. You can do this either manually, by
    editing `/etc/fstab`, or with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You may want to double-check that all `swap` entries in `/etc/fstab` are disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the `swap` mount point commented out in our `/``etc/fstab` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – Disabling swap entries in /etc/fstab](img/B19682_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.5 – Disabling swap entries in /etc/fstab
  prefs: []
  type: TYPE_NORMAL
- en: Remember to run the preceding commands on each node in the cluster. Next, we’ll
    look at installing the Kubernetes container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Installing containerd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`containerd` is the default container runtime in recent versions of Kubernetes.
    `containerd` implements the CRI required by the Kubernetes container engine abstraction
    layer. The related installation procedure is not straightforward, and we’ll follow
    the steps described in the official Kubernetes documentation in the following
    link at the time of this writing: [https://kubernetes.io/docs/setup/production-environment/container-runtimes/](https://kubernetes.io/docs/setup/production-environment/container-runtimes/).
    These steps may change at any time, so please make sure to check the latest procedure.
    The container runtime needs to be installed on each node of the cluster. We will
    proceed by installing the needed components on the CP node, the VM called `k8s-cp1`,
    and then on the other nodes as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by installing some `containerd` prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we enable the `br_netfilter` and `overlay` kernel modules using `modprobe`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also ensure that these modules are loaded upon system reboots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: cat <<EOF | sudo tee /etc/sysctl.d/containerd.conf
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: net.bridge.bridge-nf-call-iptables = 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: net.bridge.bridge-nf-call-ip6tables = 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: net.ipv4.ip_forward = 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: EOF
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want the preceding changes to take effect immediately, without a system
    reboot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a screenshot showing the preceding commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.6 – Setting containerd prerequisites](img/B19682_16_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.6 – Setting containerd prerequisites
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will verify if specific system variables are enabled in the `sysctl`
    configuration by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.7 – Verifying system variables in sysctl configuration](img/B19682_16_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.7 – Verifying system variables in sysctl configuration
  prefs: []
  type: TYPE_NORMAL
- en: Each variable should have a value of `1` in the output, just as shown in the
    previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make sure the `apt` repository is up to date before installing any
    new packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'containerd configuration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to slightly alter the default `containerd` configuration to use the
    `systemd` `cgroup` driver with the container runtime (`runc`). This change is
    required because the underlying platform (Ubuntu in our case) uses `systemd` as
    the Service manager. Open the `/etc/containerd/config.toml` file with your editor
    of choice, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the highlighted lines, adjusting the appropriate indentation (this
    is *very* important):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the resulting configuration stub:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.8 – Modifying the containerd configuration](img/B19682_16_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.8 – Modifying the containerd configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the `/etc/containerd/config.toml` file and restart `containerd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo systemctl status containerd
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `containerd` installed and configured, we can proceed with the installation
    of the Kubernetes packages next.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install the Kubernetes packages, we’ll follow the steps described at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/).
    This procedure may also change over time, so please make sure to check out the
    latest instructions. The steps presented next are applicable to Debian 12 and
    Ubuntu 22.04\. Let’s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first install the packages required by the Kubernetes `apt` repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'apt repository to our system:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s read the packages available in the new repository we just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re now ready to install the Kubernetes packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'containerd and kubelet Services are enabled upon system startup (reboot):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'containerd should be active and running. The following is a screenshot showing
    the output of the preceding commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd](img/B19682_16_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.9 – Pinning the Kubernetes packages and the running status of containerd
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s check the status of the `kubelet` Service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.10 – The kubelet crashing without cluster configuration](img/B19682_16_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.10 – The kubelet crashing without cluster configuration
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, `kubelet` is looking for the Kubernetes
    cluster, which is not set up yet. We can see that `kubelet` attempts to start
    and activate itself but keeps crashing, as it cannot locate the required configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please install the required Kubernetes packages on *all* cluster nodes following
    the previous steps before proceeding with the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll bootstrap (initialize) the Kubernetes cluster using `kubeadm`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing kubeadm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`kubeadm` is a helper tool for creating a Kubernetes cluster and essentially
    has two invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm init`: This bootstraps or initializes a Kubernetes cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubeadm join`: This adds a node to a Kubernetes cluster'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default invocation of `kubadm init [flags]` – with no flags – performs
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubeadm init` ensures that we have the minimum system resources in terms of
    CPU and memory, the required user permissions, and a supported CRI-compliant container
    runtime. If any of these checks fail, `kubeadm init` stops the execution of creating
    the cluster. If the checks succeed, `kubeadm` proceeds to the next step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubeadm init` creates a self-signed CA used by Kubernetes to generate the
    certificates required to authenticate and run trusted workloads within the cluster.
    The CA files are stored in the `/etc/kubernetes/pki`/ directory and are distributed
    on each node upon joining the cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubeadm init` creates a default set of kubeconfig files required to bootstrap
    the cluster. The kubeconfig files are stored in the `/``etc/kubernetes/` directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubelet` daemon. Examples of static pods are the API server, the controller
    manager, scheduler, and etcd. Static pod manifests are configuration files describing
    the CP pods. `kubeadm init` generates the static pod manifests during the cluster
    bootstrapping process. The manifest files are stored in the `/etc/kubernetes/manifests/`
    directory. The `kubelet` Service monitors this location and, when it finds a manifest,
    deploys the corresponding static pod.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubelet` daemon deploys the static pods, `kubeadm` queries `kubelet` for the
    static pods’ state. When the static pods are up and running, `kubeadm init` proceeds
    with the next stage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubeadm init` follows the Kubernetes best practice of tainting the CP to avoid
    user pods running on the CP node. The obvious reason is to preserve CP resources
    exclusively for system-specific workloads.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubeadm init` generates a bootstrap token that can be shared with a trusted
    node to join the cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`kubeadm init` creates and deploys the *DNS* and *kube-proxy* add-on pods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The stages of a Kubernetes cluster’s bootstrapping process are highly customizable.
    `kubeadm init`, when invoked without additional parameters, runs all the tasks
    in the preceding order. Alternatively, a system administrator may invoke the `kubeadm`
    command with different option parameters to control and run any of the stages
    mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about `kubeadm`, please refer to the utility’s help with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For more information about bootstrapping a Kubernetes cluster using `kubeadm`,
    including installing, troubleshooting, and customizing components, you may refer
    to the official Kubernetes documentation at [https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/](https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll bootstrap a Kubernetes cluster using `kubeadm` to
    generate a cluster configuration file and then invoke `kubeadm init` to use this
    configuration. We’ll bootstrap our cluster by creating the Kubernetes CP node
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes CP node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create the CP node, we will use a networking and security solution
    named `kubeadm`, and afterwards, we will use different tools to apply the configurations.
    The choice of Calico is purely subjective, but it is needed for managing communications
    between workloads and components. For more information about Calico, please visit
    the following link: [https://docs.tigera.io/calico/latest/about/](https://docs.tigera.io/calico/latest/about/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands are performed on the `k8s-cp1` host in our VM environment. As
    the hostname suggests, we choose `k8s-cp1` as the CP node of our Kubernetes cluster.
    Now, let’s get to work and configure our Kubernetes CP node:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by downloading the Calico manifest for **overlay networking**.
    The overlay network – also known as **software-defined network** (**SDN**) – is
    a logical networking layer that accommodates a secure and seamless network communication
    between the pods over a physical network that may not be accessible for configuration.
    Exploring the internals of cluster networking is beyond the scope of this chapter,
    but we encourage you to read more at [https://kubernetes.io/docs/concepts/cluster-administration/networking/](https://kubernetes.io/docs/concepts/cluster-administration/networking/).
    You’ll also find references to the Calico networking add-on. To download the related
    manifest, we run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s open the `calico.yaml` file using a text editor and look for the
    following lines (starting with *line 3672*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create a default cluster configuration file using `kubeadm`. The
    cluster configuration file describes the settings of the Kubernetes cluster we’re
    building. Let’s name this file `k8s-config.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.11 – Modifying the advertiseAddress configuration parameter](img/B19682_16_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.11 – Modifying the advertiseAddress configuration parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change we need to make is pointing the `nodeRegistration.criSocket`
    configuration parameter to the `containerd` socket `(/run/containerd/containerd.sock`)
    and the name (`k8s-cp1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.12 – Changing the criSocket configuration parameter](img/B19682_16_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.12 – Changing the criSocket configuration parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we change the `kubernetesVersion` parameter to match the version of our
    Kubernetes environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.13 – Changing the kubernetesVersion parameter](img/B19682_16_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.13 – Changing the kubernetesVersion parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value is `1.28.0`, but our Kubernetes version, using the following
    command, is `1.28.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14 – Retrieving the current version of Kubernetes](img/B19682_16_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.14 – Retrieving the current version of Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final modification of the cluster configuration file sets the `cgroup`
    driver of `kubelet` to `systemd`, matching the `cgroup` driver of `containerd`.
    Please note that `systemd` is the underlying platform’s Service manager (in Ubuntu),
    hence the need to yield related Service control to the Kubernetes daemons. The
    corresponding configuration block is not yet present in `k8s-config.yaml`. We
    can add it manually to the end of the file or with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo kubeadm init --config=k8s-config.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.15 – Successfully bootstrapping the Kubernetes cluster](img/B19682_16_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.15 – Successfully bootstrapping the Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our Kubernetes CP node is up and running. In the output, we
    highlighted the relevant excerpts for the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: A successful message (**1**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the current user as the Kubernetes cluster administrator (**2**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining new nodes to the Kubernetes cluster (**3**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We recommend taking the time to go over the complete output and identify the
    related information for each of the `kubeadm init` tasks, as captured in the *Introducing
    kubeadm* section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to configure the current user as the Kubernetes cluster administrator,
    we run the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With our cluster up and running, let’s deploy the Calico networking manifest
    to create the pod network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl get pods --all-namespaces
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.16 – Retrieving the pods in the Kubernetes cluster](img/B19682_16_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.16 – Retrieving the pods in the Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: The `--all-namespaces` option retrieves the pods across all resource groups
    in the cluster. Kubernetes uses **namespaces** to organize resources. For now,
    the only pods running in our cluster are **system pods**, as we haven’t deployed
    any **user** **pods** yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command retrieves the current nodes in the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.17 – Listing the current nodes in the Kubernetes cluster](img/B19682_16_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.17 – Listing the current nodes in the Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that prior to bootstrapping the Kubernetes cluster, the `kubelet`
    Service was continually crashing (and attempting to restart). With the cluster
    up and running, the status of the `kubelet` daemon should be `active` and `running`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output shows the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.18 – A healthy kubelet in the cluster](img/B19682_16_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.18 – A healthy kubelet in the cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to check out the manifests created in the `/etc/kubernetes/manifests/`
    directory for each cluster component using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output shows the configuration files describing the static (system) pods,
    corresponding to the API server, controller manager, scheduler, and etcd:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/](img/B19682_16_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.19 – The static pod configuration files in /etc/kubernetes/manifests/
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also look at the kubeconfig files in `/etc/kubernetes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you may recall from the *Introducing kubeadm* section earlier in this chapter,
    the kubeconfig files are used by the cluster components to communicate and authenticate
    with the API server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we have used the `kubectl` utility quite extensively in this section, you
    can visit the official documentation to find out more about the commands and options
    available for it at the following link: [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add the worker nodes to our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a node to a Kubernetes cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously noted, before adding a node to the Kubernetes cluster, you’ll
    need to run the preliminary steps described in the *Preparing the lab environment*
    section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To join a node to the cluster, we’ll need both the `kubeadm join` command were
    provided in the output at the end of the bootstrapping process with `kubeadm init`.
    Refer to the *Creating a Kubernetes CP node* section earlier in this chapter.
    Keep in mind that the bootstrap token expires in 24 hours. If you forget to copy
    the command, you can retrieve the related information by running the following
    commands in the CP node’s terminal (on `k8s-cp1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the current bootstrap tokens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.20 – Getting the current bootstrap tokens](img/B19682_16_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.20 – Getting the current bootstrap tokens
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the CA certificate hash:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.21 – Getting the CA certificate hash](img/B19682_16_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.21 – Getting the CA certificate hash
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also generate a new bootstrap token with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubeadm token create --print-join-command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the token has been created, we can proceed to the next bootstrapping
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we’ll use our initial tokens as displayed in the output
    at the end of the bootstrapping process. So, let’s switch to the node’s command-line
    terminal (on `k8s-n1`) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to invoke `sudo`, or the command will fail with insufficient permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'k8s-n1) added to the cluster:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.22 – The new node (k8s-n1) added to the cluster](img/B19682_16_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.22 – The new node (k8s-n1) added to the cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to repeat the process of joining the other two cluster nodes
    (`k8s-n2` and `k8s-n3`). During the join, while the CP pods are being deployed
    on the new node, you may temporarily see a `NotReady` status for the new node
    if you query the nodes on the CP node (`k8s-cp1`) too fast. The process should
    take a while. In the end, we should have all three nodes showing `Ready` in the
    output of the `kubectl get nodes` command (on `k8s-cp1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.23 – The Kubernetes cluster with all nodes running](img/B19682_16_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.23 – The Kubernetes cluster with all nodes running
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed the installation of our Kubernetes cluster, with a CP
    node and three worker nodes. We used a local (on-premises) VM environment, but
    the same process would also apply to a hosted IaaS solution running in a private
    or public cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore the `kubectl` CLI to a certain extent and
    use it to create and manage Kubernetes resources. Then, we’ll look at deploying
    and scaling applications using the imperative and declarative deployment models
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll use real-world examples of interacting with a Kubernetes
    cluster. Since we’ll be using the `kubectl` CLI to a considerable extent, we’re
    going to take a deep dive into some of its more common usage patterns. Then, we
    will turn our focus to deploying applications to a Kubernetes cluster. We’ll be
    using the on-premises environment we built in the *Installing Kubernetes on* *VMs*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by taking a closer look at `kubectl` and its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Using kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`kubectl` is the primary tool for managing a Kubernetes cluster and its resources.
    `kubectl` communicates with the cluster’s API server endpoint using the Kubernetes
    REST API. The general syntax of a `kubectl` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In general, `kubectl` commands execute **CRUD operations** – CRUD stands for
    **Create**, **Read**, **Update**, and **Delete** – against Kubernetes resources,
    such as pods, Deployments, and Services.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the essential features of `kubectl` is the command output format, either
    in YAML, JSON, or plain text. The output format is handy when creating or editing
    application Deployment manifests. We can capture the YAML output of a `kubectl`
    command (such as create a resource) to a file. Later, we can reuse the manifest
    file to perform the same operation (or sequence of operations) in a declarative
    way. This brings us to the two basic Deployment paradigms of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` commands to operate on specific resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl apply` command, usually targeting a set of resources with a single
    invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll look at these two Deployment models more closely in the *Deploying applications*
    section later in this chapter. For now, let’s get back to exploring the `kubectl`
    command further. Here’s a short list of some of the most common `kubectl` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create`, `apply`: These create resources imperatively/declaratively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`: This reads resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit`, `set`: These update resources or specific features of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: This deletes resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: This starts a pod'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: This executes a command in a pod container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`describe`: This displays detailed information about resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`explain`: This provides resource-related documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: This shows the logs in pod containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A couple of frequently used parameters of the `kubectl` command are also worth
    mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--dry-run`: This runs the command without modifying the system state while
    still providing the output as if it executed normally'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output`: This specifies various formats for the command output: `yaml`,
    `json`, and `wide` (additional information in plain text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following sections, we’ll look at multiple examples of using the `kubectl`
    command. Always keep in mind the general pattern of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.24 – The general usage pattern of kubectl](img/B19682_16_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.24 – The general usage pattern of kubectl
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend that you check out the complete `kubectl` command reference at
    [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).
    While you are becoming proficient with `kubectl`, you may also want to keep the
    related cheat sheet at hand, which you can find at the following link: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s prepare our `kubectl` environment to interact with the Kubernetes
    cluster we built earlier with VMs. You may skip the next section if you prefer
    to use `kubectl` on the CP node.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a Kubernetes cluster from a local machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we configure the `kubectl` CLI running locally on our Linux
    desktop to control a remote Kubernetes cluster. We are running Debian 12 on our
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to install `kubectl` on our system. We will observe the
    installation instructions at [https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/](https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/).
    We will download the latest `kubectl` release with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: kubectl version --client
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: scp packt@192.168.122.104:~/.kube/config /tmp/config.cp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: mv /tmp/config.cp ~/.kube/config
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: rm ~/.kube/config.old /tmp/config.cp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'kubernetes-admin@kubernetes) and cluster name (kubernetes):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl config rename-context \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: kubernetes-admin@kubernetes \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: k8s-local
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'kubectl context becomes k8s-local, and we’re now interacting with our on-premises
    Kubernetes cluster (kubernetes). The output is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl cluster-info
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: kubectl cluster-info dump
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get nodes --output=wide
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get pods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: No resources found in default namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get pods --all-namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get pods --namespace kube-system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get all --all-namespaces
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: kubectl api-resources
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: kubectl explain nodes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: kubectl explain nodes.apiVersion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: kubectl describe nodes
  prefs: []
  type: TYPE_NORMAL
- en: kubectl describe nodes k8s-n1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: kubectl --help
  prefs: []
  type: TYPE_NORMAL
- en: kubectl config -h
  prefs: []
  type: TYPE_NORMAL
- en: kubectl get pods -h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: sudo apt-get install -y bash-completion
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: echo "source <(kubectl completion bash)" >> ~/.bashrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: source ~/.bashrc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: kubectl create [Tab][Tab]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: kubectl create deployment packt --image=nginxdemos/hello
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: deployment.apps/packt created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'kubectl run pod/packt-web), is not part of a Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We’ll see later in this section that this pod is not part of a ReplicaSet and
    so is not managed by the controller manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the state of our system by querying the pods for detailed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.35 – Getting the application pods with detailed information](img/B19682_16_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.35 – Getting the application pods with detailed information
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding output, you can see the series of commands described, and
    we can also see that our pods are up and running and that Kubernetes deployed
    them on separate nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`packt-579bb9c999-rtvzr`: On cluster node `k8s-n1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packt-web`: On cluster node `k8s-n3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the pods on different nodes is due to internal load balancing and resource
    distribution in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The application pod managed by the controller is `packt-579bb9c999-rtvzr`. Kubernetes
    generates a unique name for our managed pod by appending a `579bb9c999`) and a
    `rtvzr`) to the name of the Deployment (`packt`). The pod template hash and pod
    ID are unique within a ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the standalone pod (`packt-web`) is left as is since it’s not
    part of an application Deployment. Let’s describe both pods to obtain more information
    about them. We’ll start with the managed pod first. Don’t forget to use the `kubectl`
    autocompletion (by pressing the *Tab* key twice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The related output is relatively large. Here are some relevant snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.36 – Pod information](img/B19682_16_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.36 – Pod information
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the same command for the standalone pod (`packt-web`) would be
    slightly different without featuring the `Controlled` `By` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the corresponding excerpts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.37 – Relevant pod information](img/B19682_16_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.37 – Relevant pod information
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also venture out to any of the cluster nodes where our pods are running
    and take a closer look at the related containers. Let’s take node `k8s-n3` (`192.168.122.163`),
    for example, where our standalone pod (`packt-web`) is running. We’ll SSH into
    the node’s terminal first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll use the `containerd` runtime to query the containers in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.38 – Getting the containers running on a cluster node](img/B19682_16_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.38 – Getting the containers running on a cluster node
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll show you how to access processes running inside the pods.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing processes in pods
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s switch back to our local (on our local machine, not the VM) `kubectl`
    environment and run the following command to access the shell in the container
    running the `packt-web` pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The command takes us inside the container to an interactive shell prompt. Here,
    we can run commands as if we were logged in to the `packt-web` host using the
    terminal. The interactive session is produced using the `-it` option – interactive
    terminal – or `--``interactive --tty`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a few commands, starting with the process explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a relevant excerpt from the output, showing the processes running inside
    the `packt-web` container, and some commands running inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.39 – The processes running inside the packt-web container](img/B19682_16_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.39 – The processes running inside the packt-web container
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve the IP address with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the pod’s IP address (as seen in *Figure 16**.39*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also retrieve the hostname with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the pod name (as seen in *Figure 16**.39*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Let’s leave the container shell with the `exit` command (as shown in *Figure
    16**.39*) or by pressing *Ctrl* + *D*. With the `kubectl` `exec` command, we can
    run any process inside a pod, assuming that the related process exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll experiment next by testing the `packt-web` application pod using `curl`.
    We should note that, at this time, the only way to access the web server endpoint
    of `packt-web` is via its internal IP address. Previously, we used the `kubectl`
    `get pods -o wide` and `describe` commands to retrieve detailed information regarding
    pods, including the pod’s IP address. You can also use the following one-liner
    to retrieve the pod’s IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the command returns `172.16.57.193`. We used the `-o jsonpath`
    output option to specify the JSON query for a specific field, `{.status.podIP}`.
    Remember that the pod’s IP is only accessible within the pod network (`172.16.0.0/16`)
    inside the cluster. Following is a screenshot showing the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.40 – Testing the application pod](img/B19682_16_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.40 – Testing the application pod
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, we need to probe the `packt-web` endpoint using a `curl` command
    that has originated within the pod network. An easy way to accomplish such a task
    is to run a test pod with the `curl` utility installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command runs a pod named `test`, based on the `curlimages/curl`
    Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.41 – Running a test with curl on the pod](img/B19682_16_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.41 – Running a test with curl on the pod
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run a simple `curl` command using the `test` pod targeting the
    `packt-web` web server endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  We’ll get an HTTP response and a corresponding **access log trace** (from
    the Nginx server running in the pod) accounting for the request. A snippet of
    the output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.42 – The response of running the curl test](img/B19682_16_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.42 – The response of running the curl test
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the logs on the `packt-web` pod, we run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.43 – Logs for packt-web pod](img/B19682_16_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.43 – Logs for packt-web pod
  prefs: []
  type: TYPE_NORMAL
- en: 'The logs in the `packt-web` pod are produced by Nginx and redirected to `stdout`
    and `stderr`. We can easily verify this with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output shows the related symlinks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.44 – Related symlinks](img/B19682_16_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.44 – Related symlinks
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re done using the `test` pod, you can delete it with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have deployed our first application inside a Kubernetes cluster,
    let’s look at how to expose the related endpoint to the world. Next, we will expose
    Deployments via a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Deployments as Services
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s rewind to the command we used previously to create the `packt` Deployment.
    Don’t run it. Here it is just as a refresher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The command carried out the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: It created a Deployment (`packt`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Deployment created a ReplicaSet (`packt-579bb9c999`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ReplicaSet created the pod (`packt-579bb9c999-rtvzr`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can verify that with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding commands, we used the `--label-columns (-l)` flag to filter
    results by the `app=packt` label, denoting the `packt` Deployment’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encourage you to take a closer look at each of these resources using the
    `kubectl describe` command. Don’t forget to use the `kubectl` autocomplete feature
    when typing in the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: The `kubectl` `describe` command could be very resourceful when troubleshooting
    applications or pod Deployments. Look inside the *Events* section in the related
    output for clues on pods failing to start, errors, if any, and possibly understand
    what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have deployed our first application inside a Kubernetes cluster,
    let’s look at how to expose the related endpoint to the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have deployed an application (`packt`) with a single pod (`packt-579bb9c999-rtvzr`)
    running an Nginx web server listening on port `80`. As we explained earlier, at
    this time, we can only access the pod within the pod network, which is internal
    to the cluster. In this section, we’ll show you how to expose the application
    (or Deployment) to be accessible from the outside world. Kubernetes uses the Service
    API object, consisting of a **proxy** and a **selector** routing the network traffic
    to application pods in a Deployment. To proceed, you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates a Service for our Deployment (`packt`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Let’s take a closer look at our Service (`packt`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.45 – The service exposing the packt deployment](img/B19682_16_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.45 – The Service exposing the packt Deployment
  prefs: []
  type: TYPE_NORMAL
- en: Also, `EXTERNAL-IP` (`<none>`) should not be mistaken for the cluster node’s
    IP address where our Service is accessible. The external IP is usually a load
    balancer IP address configured by a cloud provider hosting the Kubernetes cluster
    (configurable via the `--``external-ip` flag).
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now be able to access our application outside the cluster by pointing
    a browser to any of the cluster nodes on port `32664`. To get a list of our cluster
    nodes with their respective IP addresses and hostnames, we can run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.46 – List of cluster nodes](img/B19682_16_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.46 – List of cluster nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s choose the CP node (`192.168.122.104/k8s-cp1`) and enter the following
    address in a browser: http://192.168.122.104:32664.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The web request from the browser is directed to the Service endpoint (`packt`),
    which routes the related network packets to the application pod (`packt-579bb9c999-rtvzr`).
    The `packt` web application responds with a simple Nginx `172.16.215.65`) and
    name (`packt-579bb9c999-rtvzr`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.47 – Accessing the packt application service](img/B19682_16_47.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.47 – Accessing the packt application Service
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the information on the web page is accurate, you may run the
    following `kubectl` command, retrieving similar information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the command will be the internal IP address and the name of the
    pod, as shown in the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.48 – Verify the information with the kubectl command](img/B19682_16_48.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.48 – Verify the information with the kubectl command
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have high traffic targeting our application, and we’d like to scale
    out the ReplicaSet controlling our pods. We’ll show you how to accomplish this
    task in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling application Deployments
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we have a single pod in the `packt` Deployment. In order to scale
    the application Deployments, we have to obtain information about the running replicas,
    to scale them to the desired number and test it. Here are the steps to take:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the relevant details about the number of running replicas, we run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The relevant excerpt in the output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.49 – Pod details](img/B19682_16_49.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.49 – Pod details
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s scale up our `packt` Deployment to 10 replicas with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl get pods -l app=packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.50 – Scaling up the deployment replicas](img/B19682_16_50.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.50 – Scaling up the Deployment replicas
  prefs: []
  type: TYPE_NORMAL
- en: 'Incoming requests to our application Service endpoint (`http://192.168.122.104:32664`)
    will be load balanced between the pods. To illustrate this behavior, we can either
    use `curl` or a text-based browser at the command line to avoid the caching-related
    optimizations of a modern desktop browser. For a better illustration, we’ll use
    **Lynx**, a simple text-based browser. On our Debian 12 desktop, the package is
    already installed. You can install it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Next, we point Lynx to our application endpoint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we refresh the page with *Ctrl* + *R* every few seconds, we observe that
    the server address and name change based on the current pod processing the request:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.51 – Load balancing requests across pods](img/B19682_16_51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.51 – Load balancing requests across pods
  prefs: []
  type: TYPE_NORMAL
- en: You can exit the Lynx browser by typing `Q` and then pressing *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can scale back our Deployment (`packt`) to three replicas (or any other
    non-zero positive number) with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl get pods -l app=packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 16.52 – Scaling back to three pods](img/B19682_16_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.52 – Scaling back to three pods
  prefs: []
  type: TYPE_NORMAL
- en: 'Before concluding our imperative Deployments, let’s clean up all the resources
    we have created thus far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  The following command should reflect a clean slate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.53 – The cluster in a default state](img/B19682_16_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.53 – The cluster in a default state
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at how to deploy resources and applications
    declaratively in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Working with declarative Deployments
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of a declarative Deployment is a manifest file. Manifest files
    are generally in YAML format and authoring them usually involves a mix of autogenerated
    code and manual editing. The manifest is then deployed using the `kubectl` `apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploying resources declaratively in Kubernetes involves the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a manifest file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating the manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating between the preceding stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate the declarative model, we follow the example of deploying a simple
    Hello World web application to the cluster. The result will be similar to our
    previous approach of using the imperative method.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s start by creating a manifest for our Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a manifest
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created our `packt` Deployment imperatively, we used the following
    command (don’t run it just yet!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will simulate the same process without changing the system
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the following additional options (flags):'
  prefs: []
  type: TYPE_NORMAL
- en: '`--dry-run=client`: This runs the command in the local `kubectl` environment
    (*client*) without modifying the system state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output=yaml`: This formats the command output as YAML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.54 – Simulating a manifest creation](img/B19682_16_54.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16.54 – Simulating a manifest creation
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the previous command’s output to analyze the changes to be made
    to the system. Then we can redirect it to a file (`packt.yaml`) serving as a draft
    of our Deployment manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: kubectl apply -f packt.yaml --dry-run=client
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: deployment.apps/packt created (dry run)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: kubectl apply -f packt.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: deployment.apps/packt created
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: kubectl get all -l app=packt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: kubectl expose deployment packt \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --port=80 \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --target-port=80 \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --type=NodePort \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --dry-run=client --output=yaml > packt-svc.yaml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl apply -f packt-svc.yaml --dry-run=client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'packt resources:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'spec:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'replicas: 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'spec:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'replicas: 10'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'packt Deployment has been reconfigured:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'packt Deployment, including the additional pods deployed in the cluster:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl edit deployment packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl edit will not be reflected in the Deployment manifest (packt.yaml).
    Nevertheless, the related configuration changes are persisted in the cluster (etcd).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl get deployment packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kubectl delete service packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: kubectl delete deployment packt
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
