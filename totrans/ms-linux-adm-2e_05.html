<html><head></head><body>
<div id="_idContainer156">
<h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.2.1">Working with Processes, Daemons, and Signals</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Linux is a multitasking operating system. </span><span class="koboSpan" id="kobo.3.2">Multiple programs or tasks can run in parallel, each with its own identity, scheduling, memory space, permissions, and system resources. </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Processes</span></strong><span class="koboSpan" id="kobo.5.1"> encapsulate</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.6.1"> the execution context of any such program. </span><span class="koboSpan" id="kobo.6.2">Understanding how processes work and communicate with each other is an important skill for any seasoned Linux system administrator and developer </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">to have.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">This chapter explores the basic concepts behind Linux processes. </span><span class="koboSpan" id="kobo.8.2">We’ll look at different types of processes, such as </span><strong class="bold"><span class="koboSpan" id="kobo.9.1">foreground</span></strong><span class="koboSpan" id="kobo.10.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.11.1">background</span></strong><span class="koboSpan" id="kobo.12.1"> processes, with special emphasis being placed on </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">daemons</span></strong><span class="koboSpan" id="kobo.14.1"> as a particular type of background process. </span><span class="koboSpan" id="kobo.14.2">We’ll closely study the anatomy of a process and various inter-process communication mechanisms in Linux – </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">signals</span></strong><span class="koboSpan" id="kobo.16.1"> in particular. </span><span class="koboSpan" id="kobo.16.2">Along the way, we’ll learn about some of the essential command-line utilities for managing processes and daemons and working with signals. </span><span class="koboSpan" id="kobo.16.3">We will also introduce you to </span><strong class="bold"><span class="koboSpan" id="kobo.17.1">scripts</span></strong><span class="koboSpan" id="kobo.18.1"> for the first time in this book, which are described in detail later in </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Linux Shell Scripting</span></em><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">If you feel like you need more information when dealing with the scripts in this chapter, take a look at </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 8</span></em></span></a> <span class="No-Break"><span class="koboSpan" id="kobo.24.1">in advance.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.27.1">Introducing processes</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">with processes</span></span></li>
<li><span class="koboSpan" id="kobo.30.1">Working </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">with daemons</span></span></li>
<li><span class="koboSpan" id="kobo.32.1">Exploring </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">inter-process communication</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.34.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.35.1">As we navigate through the content, we will occasionally reference signals </span><em class="italic"><span class="koboSpan" id="kobo.36.1">before</span></em><span class="koboSpan" id="kobo.37.1"> their formal introduction in the second half of this chapter. </span><span class="koboSpan" id="kobo.37.2">In Linux, signals are almost exclusively used in association with processes, hence our approach of becoming familiar with processes first. </span><span class="koboSpan" id="kobo.37.3">Yet, leaving the signals out from some of the process’ internals would do a disservice to understanding how processes work. </span><span class="koboSpan" id="kobo.37.4">Where signals are mentioned, we’ll point to the related section for further reference. </span><span class="koboSpan" id="kobo.37.5">We hope that this approach provides you with a better grasp of the overall picture and the inner workings of processes </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">and daemons.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">Now, before we start, let’s look at the essential requisites for </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">our study.</span></span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.41.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.42.1">Practice makes perfect. </span><span class="koboSpan" id="kobo.42.2">Running the commands and examples in this chapter by hand would go a long way toward you learning about processes. </span><span class="koboSpan" id="kobo.42.3">As with any chapter in this book, we recommend that you have a working Linux distribution installed on a VM or PC desktop platform. </span><span class="koboSpan" id="kobo.42.4">We’ll be using Ubuntu or Fedora, but most of the commands and examples would be similar on any other </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Linux platform.</span></span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.44.1">Introducing processes</span></h1>
<p><span class="koboSpan" id="kobo.45.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">process</span></strong><span class="koboSpan" id="kobo.47.1"> represents the running instance of a program. </span><span class="koboSpan" id="kobo.47.2">In general, a program is a </span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.48.1">combination of instructions and data, compiled as an executable unit. </span><span class="koboSpan" id="kobo.48.2">When a program runs, a process is created. </span><span class="koboSpan" id="kobo.48.3">In other words, a process is simply a program in action. </span><span class="koboSpan" id="kobo.48.4">Processes execute specific tasks, and </span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.49.1">sometimes, they </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.50.1">are also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">jobs</span></strong><span class="koboSpan" id="kobo.52.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.54.1">tasks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">There are many ways to create or start a process. </span><span class="koboSpan" id="kobo.56.2">In Linux, every command starts a process. </span><span class="koboSpan" id="kobo.56.3">A command could be a user-initiated task in a Terminal session, a script, or a program (executable) that’s invoked manually </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">or automatically.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">Usually, the way a process is created and interacts with the system (or user) determines its process type. </span><span class="koboSpan" id="kobo.58.2">Let’s take a closer look at the different types of processes </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">in Linux.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.60.1">Understanding process types</span></h2>
<p><span class="koboSpan" id="kobo.61.1">At a high</span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.62.1"> level, there are two major types of </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.63.1">processes </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">in Linux:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.65.1">Foreground</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> (</span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.67.1">interactive</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Background</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.71.1">non-interactive</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.72.1">or </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">automated</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.75.1">Interactive processes assume some kind of user interaction during the lifetime of the process. </span><span class="koboSpan" id="kobo.75.2">Non-interactive </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.76.1">processes are unattended, which means that they are either automatically started (for example, on system boot) or are scheduled to run at a particular time and date via job schedulers (for example, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">at</span></strong><span class="koboSpan" id="kobo.78.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">cron</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.80.1">command-line utilities).</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">Our approach to exploring process types mainly pivots around the preceding classification. </span><span class="koboSpan" id="kobo.81.2">There are various other views or taxonomies surrounding process definitions, but they could ultimately be reduced to either foreground or </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">background processes.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">For example, batch processes </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.84.1">and daemons are essentially background processes. </span><span class="koboSpan" id="kobo.84.2">Batch processes are automated in the sense that they are not user-generated but</span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.85.1"> invoked by a scheduled task instead. </span><span class="koboSpan" id="kobo.85.2">Daemons are background processes that are usually started during system boot and </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">run indefinitely.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">There’s also the concept of parent and child processes. </span><span class="koboSpan" id="kobo.87.2">A parent process may create other subordinate </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">child processes.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">We’ll elaborate on these types (and beyond) in the following sections. </span><span class="koboSpan" id="kobo.89.2">Let’s start with the pivotal ones – foreground and </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">background processes.</span></span></p>
<h3><span class="koboSpan" id="kobo.91.1">Foreground processes</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.92.1">Foreground processes</span></strong><span class="koboSpan" id="kobo.93.1">, also </span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.94.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">interactive processes</span></strong><span class="koboSpan" id="kobo.96.1">, are started and controlled</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.97.1"> through a Terminal session. </span><span class="koboSpan" id="kobo.97.2">Foreground processes are usually initiated by a user via an interactive command-line interface. </span><span class="koboSpan" id="kobo.97.3">A foreground process may output results</span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.98.1"> to the console (</span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">stdout</span></strong><span class="koboSpan" id="kobo.100.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">stderr</span></strong><span class="koboSpan" id="kobo.102.1">) or accept user input. </span><span class="koboSpan" id="kobo.102.2">The lifetime of a foreground process is tightly coupled to the Terminal session (parent process). </span><span class="koboSpan" id="kobo.102.3">If the user who launched the foreground process exits the Terminal while the process is still running, the process will be abruptly terminated (via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">SIGHUP</span></strong><span class="koboSpan" id="kobo.104.1"> signal sent by the parent process; see </span><em class="italic"><span class="koboSpan" id="kobo.105.1">Signals</span></em><span class="koboSpan" id="kobo.106.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.107.1">Exploring inter-process communication</span></em><span class="koboSpan" id="kobo.108.1"> section for </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">more details).</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">A simple example of a foreground process is invocating the system reference manual (</span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">man</span></strong><span class="koboSpan" id="kobo.112.1">) for an arbitrary Linux command (for </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.116.1">
man ps</span></pre> <p><span class="koboSpan" id="kobo.117.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">ps</span></strong><span class="koboSpan" id="kobo.119.1"> command displays information about active processes. </span><span class="koboSpan" id="kobo.119.2">You will learn more about process management tools and command-line utilities in the </span><em class="italic"><span class="koboSpan" id="kobo.120.1">Working with </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.121.1">processes</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.122.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">Once a foreground process has been</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.124.1"> initiated, the user prompt is captured and controlled by the spawned </span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.125.1">process interface. </span><span class="koboSpan" id="kobo.125.2">The user can no longer interact with the initial command prompt until the interactive process relinquishes control to the </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">Terminal session.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">Let’s look at another example of a foreground process, this time invoking a long-lived task. </span><span class="koboSpan" id="kobo.127.2">The following command (one-liner) runs an infinite loop while displaying an arbitrary message every </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">few seconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
while true; do echo "Wait..."; sleep 5; done</span></pre> <p><span class="koboSpan" id="kobo.130.1">So long as the command runs without being interrupted, the user won’t have an interactive prompt in the Terminal. </span><span class="koboSpan" id="kobo.130.2">Using </span><em class="italic"><span class="koboSpan" id="kobo.131.1">Ctrl</span></em><span class="koboSpan" id="kobo.132.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.133.1">C</span></em><span class="koboSpan" id="kobo.134.1"> would stop (interrupt) the execution of the related foreground process and yield a responsive </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">command prompt:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer130">
<span class="koboSpan" id="kobo.136.1"><img alt="" role="presentation" src="image/Figure_05_01_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.137.1">Figure 5.1 – A long-lived foreground process</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.138.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.139.1">When you press </span><em class="italic"><span class="koboSpan" id="kobo.140.1">Ctrl</span></em><span class="koboSpan" id="kobo.141.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.142.1">C</span></em><span class="koboSpan" id="kobo.143.1"> while a foreground process is running, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">SIGINT</span></strong><span class="koboSpan" id="kobo.145.1"> signal is sent to the running process by the current (parent) Terminal session, and the foreground process is interrupted. </span><span class="koboSpan" id="kobo.145.2">For more information, see the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.146.1">Signals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">If we want to maintain an interactive command prompt in the Terminal session while running a specific command or script, we should use a </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">background process.</span></span></p>
<h3><span class="koboSpan" id="kobo.150.1">Background processes</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.151.1">Background processes</span></strong><span class="koboSpan" id="kobo.152.1"> – also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">non-interactive</span></strong><span class="koboSpan" id="kobo.154.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.155.1">automatic processes</span></strong><span class="koboSpan" id="kobo.156.1"> – run</span><a id="_idIndexMarker640"/><span class="koboSpan" id="kobo.157.1"> independently </span><a id="_idIndexMarker641"/><span class="koboSpan" id="kobo.158.1">of a Terminal session, without expecting any user interaction. </span><span class="koboSpan" id="kobo.158.2">A user may invoke </span><a id="_idIndexMarker642"/><span class="koboSpan" id="kobo.159.1">multiple background processes within the same Terminal</span><a id="_idIndexMarker643"/><span class="koboSpan" id="kobo.160.1"> session without waiting on any of them to complete </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">or exit.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Background processes are usually long-lived tasks that don’t require direct user supervision. </span><span class="koboSpan" id="kobo.162.2">The related process may still display its output in the Terminal console, but such background tasks typically write their results to different files instead (such as </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">log files).</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">The simplest invocation of a background process appends an ampersand (</span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">&amp;</span></strong><span class="koboSpan" id="kobo.166.1">) to the end of the related command. </span><span class="koboSpan" id="kobo.166.2">Building on our previous example (in the </span><em class="italic"><span class="koboSpan" id="kobo.167.1">Foreground processes</span></em><span class="koboSpan" id="kobo.168.1"> section), the following command creates a background process that runs an infinite loop, echoing an arbitrary message every </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">few seconds:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
while true; do echo "Wait..."; sleep 10; done &amp;</span></pre> <p><span class="koboSpan" id="kobo.171.1">Note the ampersand (</span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">&amp;</span></strong><span class="koboSpan" id="kobo.173.1">) at the end of the command. </span><span class="koboSpan" id="kobo.173.2">By default, a background process would still direct the output (</span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">stdout</span></strong><span class="koboSpan" id="kobo.175.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">stderr</span></strong><span class="koboSpan" id="kobo.177.1">) to the console when invoked with the ampersand (</span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">&amp;</span></strong><span class="koboSpan" id="kobo.179.1">), as shown previously. </span><span class="koboSpan" id="kobo.179.2">However, the Terminal session remains interactive. </span><span class="koboSpan" id="kobo.179.3">In the following figure, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">echo</span></strong><span class="koboSpan" id="kobo.181.1"> command while the previous process is </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">still running:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<span class="koboSpan" id="kobo.183.1"><img alt="Figure 5.2 – Running a background process" src="image/Figure_05_02_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.184.1">Figure 5.2 – Running a background process</span></p>
<p><span class="koboSpan" id="kobo.185.1">As shown in the preceding</span><a id="_idIndexMarker644"/><span class="koboSpan" id="kobo.186.1"> screenshot, the background process is given a </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">process ID</span></strong><span class="koboSpan" id="kobo.188.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.189.1">PID</span></strong><span class="koboSpan" id="kobo.190.1">) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">983</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">While the process is running, we can still control the Terminal session and run a different command, </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
echo "Interactive prompt..."</span></pre> <p><span class="koboSpan" id="kobo.195.1">Eventually, we can force the process to terminate with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">kill</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
kill -9 983</span></pre> <p><span class="koboSpan" id="kobo.199.1">The preceding command </span><em class="italic"><span class="koboSpan" id="kobo.200.1">kills</span></em><span class="koboSpan" id="kobo.201.1"> our background process (with PID </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">983</span></strong><span class="koboSpan" id="kobo.203.1">). </span><span class="koboSpan" id="kobo.203.2">The corresponding signal that’s sent by the parent Terminal session to terminate this process is </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.205.1"> (see the </span><em class="italic"><span class="koboSpan" id="kobo.206.1">Signals</span></em><span class="koboSpan" id="kobo.207.1"> section for more information) through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">-9</span></strong><span class="koboSpan" id="kobo.209.1"> argument in </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">our command.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">Both foreground and background processes are typically under the direct control of a user. </span><span class="koboSpan" id="kobo.211.2">In other words, these processes are created or started manually as a result of a command or script invocation. </span><span class="koboSpan" id="kobo.211.3">There are some exceptions to this rule, particularly when it comes to batch</span><a id="_idIndexMarker645"/><span class="koboSpan" id="kobo.212.1"> processes, which are launched automatically via </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">scheduled jobs.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">There’s also a select category of background processes that are automatically started during system boot and terminated at shutdown without user supervision. </span><span class="koboSpan" id="kobo.214.2">These background processes are also known </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">as daemons.</span></span></p>
<h3><span class="koboSpan" id="kobo.216.1">Introducing daemons</span></h3>
<p><span class="koboSpan" id="kobo.217.1">A</span><strong class="bold"><span class="koboSpan" id="kobo.218.1"> Daemon</span></strong><span class="koboSpan" id="kobo.219.1"> is a particular type of </span><a id="_idIndexMarker646"/><span class="koboSpan" id="kobo.220.1">background process that is usually started upon system</span><a id="_idIndexMarker647"/><span class="koboSpan" id="kobo.221.1"> boot and run indefinitely or until terminated (for example, during system shutdown). </span><span class="koboSpan" id="kobo.221.2">A daemon doesn’t have a user-controlled Terminal, even though it is associated with a system account (</span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">root</span></strong><span class="koboSpan" id="kobo.223.1"> or other) and runs with the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">related privileges.</span></span></p>
<p><span class="koboSpan" id="kobo.225.1">Daemons usually serve client requests or communicate with other foreground or background processes. </span><span class="koboSpan" id="kobo.225.2">Here are some common examples of daemons, all of which are generally available on most </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">Linux </span></span><span class="No-Break"><a id="_idIndexMarker648"/></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">platforms:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">systemd</span></strong><span class="koboSpan" id="kobo.229.1">: The parent of all processes (formerly known </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">crond</span></strong><span class="koboSpan" id="kobo.234.1">: A job scheduler that runs tasks in </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">the background</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">ftpd</span></strong><span class="koboSpan" id="kobo.237.1">: An FTP server that handles client </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">FTP requests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">httpd</span></strong><span class="koboSpan" id="kobo.240.1">: A web server (Apache) that handles client </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">HTTP requests</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">sshd</span></strong><span class="koboSpan" id="kobo.243.1">: A Secure Shell server that handles SSH </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">client requests</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.245.1">Typically, system daemons in Linux are named with </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">d</span></strong><span class="koboSpan" id="kobo.247.1"> at the end, denoting a daemon process. </span><span class="koboSpan" id="kobo.247.2">Daemons are controlled by shell scripts usually stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">/etc/init.d/</span></strong><span class="koboSpan" id="kobo.249.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">/lib/systemd/</span></strong><span class="koboSpan" id="kobo.251.1"> system directory, depending on the Linux platform. </span><span class="koboSpan" id="kobo.251.2">Ubuntu, for example, stores daemon script files in </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">/etc/init.d/</span></strong><span class="koboSpan" id="kobo.253.1">, while Fedora stores them in </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">/lib/systemd/</span></strong><span class="koboSpan" id="kobo.255.1">. </span><span class="koboSpan" id="kobo.255.2">The location of these daemon files depends on the platform implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">init</span></strong><span class="koboSpan" id="kobo.257.1">, a system-wide service manager for all </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Linux processes.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">The Linux init-style startup process generally invokes these shell scripts at system boot. </span><span class="koboSpan" id="kobo.259.2">But the same scripts can also be invoked via service control commands, usually run by privileged system users, to manage the lifetime of specific daemons. </span><span class="koboSpan" id="kobo.259.3">In other words, a privileged user or system </span><a id="_idIndexMarker649"/><span class="koboSpan" id="kobo.260.1">administrator can </span><em class="italic"><span class="koboSpan" id="kobo.261.1">stop</span></em><span class="koboSpan" id="kobo.262.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.263.1">start</span></em><span class="koboSpan" id="kobo.264.1"> a particular daemon through the command-line interface. </span><span class="koboSpan" id="kobo.264.2">Such commands would immediately return the user’s control to the Terminal while performing the related action in </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the background.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Let’s take a closer look at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">init</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.268.1"> process.</span></span></p>
<h3><span class="koboSpan" id="kobo.269.1">The init process</span></h3>
<p><span class="koboSpan" id="kobo.270.1">Throughout this</span><a id="_idIndexMarker650"/><span class="koboSpan" id="kobo.271.1"> chapter, we’ll refer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">init</span></strong><span class="koboSpan" id="kobo.273.1"> as the </span><em class="italic"><span class="koboSpan" id="kobo.274.1">generic</span></em><span class="koboSpan" id="kobo.275.1"> system initialization </span><a id="_idIndexMarker651"/><span class="koboSpan" id="kobo.276.1">engine and service manager on Linux platforms. </span><span class="koboSpan" id="kobo.276.2">Over the years, Linux distributions have evolved and gone through various </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">init</span></strong><span class="koboSpan" id="kobo.278.1"> system implementations, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">SysV</span></strong><span class="koboSpan" id="kobo.280.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">upstart</span></strong><span class="koboSpan" id="kobo.282.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">OpenRC</span></strong><span class="koboSpan" id="kobo.284.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">systemd</span></strong><span class="koboSpan" id="kobo.286.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">runit</span></strong><span class="koboSpan" id="kobo.288.1">. </span><span class="koboSpan" id="kobo.288.2">There’s an ongoing debate in the Linux community about the supremacy or advantages of one over the other. </span><span class="koboSpan" id="kobo.288.3">For now, we will simply regard </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">init</span></strong><span class="koboSpan" id="kobo.290.1"> as a system process, and we will briefly look at its relationship with </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">other processes.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">init</span></strong><span class="koboSpan" id="kobo.293.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">systemd</span></strong><span class="koboSpan" id="kobo.295.1">, and others) is essentially a system daemon, and it’s among the first process to start when Linux boots up. </span><span class="koboSpan" id="kobo.295.2">The related daemon process continues to run in the background until the system is shut down. </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">init</span></strong><span class="koboSpan" id="kobo.297.1"> is the root (parent) process of all other processes in Linux, in the overall process hierarchy tree. </span><span class="koboSpan" id="kobo.297.2">In other words, it is a direct or indirect ancestor of all the processes in </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">In Linux, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">pstree</span></strong><span class="koboSpan" id="kobo.301.1"> command displays the whole process tree, and it shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">init</span></strong><span class="koboSpan" id="kobo.303.1"> process at its root – in our case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">systemd</span></strong><span class="koboSpan" id="kobo.305.1"> (on Ubuntu </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">or Fedora).</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<span class="koboSpan" id="kobo.309.1"><img alt="Figure 5.3 – init (systemd), the parent of all processes" src="image/Figure_05_03_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.310.1">Figure 5.3 – init (systemd), the parent of all processes</span></p>
<p><span class="koboSpan" id="kobo.311.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">pstree</span></strong><span class="koboSpan" id="kobo.313.1"> command’s output illustrates a hierarchy tree representation of the processes, where some </span><a id="_idIndexMarker652"/><span class="koboSpan" id="kobo.314.1">appear as parent processes while others appear as child processes. </span><span class="koboSpan" id="kobo.314.2">Let’s </span><a id="_idIndexMarker653"/><span class="koboSpan" id="kobo.315.1">look at the parent and child process types and some of the dynamics </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">between them.</span></span></p>
<h3><span class="koboSpan" id="kobo.317.1">Parent and child processes</span></h3>
<p><span class="koboSpan" id="kobo.318.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.319.1">parent process</span></strong><span class="koboSpan" id="kobo.320.1"> creates other </span><a id="_idIndexMarker654"/><span class="koboSpan" id="kobo.321.1">subordinate processes, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.322.1">child processes</span></strong><span class="koboSpan" id="kobo.323.1">. </span><span class="koboSpan" id="kobo.323.2">Child processes belong to the</span><a id="_idIndexMarker655"/><span class="koboSpan" id="kobo.324.1"> parent process that spawned</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.325.1"> them and usually terminate when the parent process exits (stops execution). </span><span class="koboSpan" id="kobo.325.2">A child</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.326.1"> process may continue to run beyond the parent process’s lifetime if it’s been instructed to ignore the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">SIGHUP</span></strong><span class="koboSpan" id="kobo.328.1"> signal that’s invoked by the parent process upon termination (for example, via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">nohup</span></strong><span class="koboSpan" id="kobo.330.1"> command). </span><span class="koboSpan" id="kobo.330.2">See the </span><em class="italic"><span class="koboSpan" id="kobo.331.1">Signals</span></em><span class="koboSpan" id="kobo.332.1"> section for </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.334.1">In Linux, all processes except the </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">init</span></strong><span class="koboSpan" id="kobo.336.1"> process (with its variations) are children of a specific process. </span><span class="koboSpan" id="kobo.336.2">Terminating a child process won’t stop the related parent process from running. </span><span class="koboSpan" id="kobo.336.3">A good practice for terminating a parent process when the child is done processing is to exit from the parent process itself after the child </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">process completes.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">There are cases when processes run unattended, based on a specific schedule. </span><span class="koboSpan" id="kobo.338.2">Running a process without user interaction is known as batch processing. </span><span class="koboSpan" id="kobo.338.3">We’ll look at batch </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">processes next.</span></span></p>
<h3><span class="koboSpan" id="kobo.340.1">Batch processes</span></h3>
<p><span class="koboSpan" id="kobo.341.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.342.1">batch process</span></strong><span class="koboSpan" id="kobo.343.1"> is typically a script or </span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.344.1">a command that’s been scheduled to run at a specific date and time, usually in a </span><a id="_idIndexMarker659"/><span class="koboSpan" id="kobo.345.1">periodic fashion. </span><span class="koboSpan" id="kobo.345.2">In other words, batch processing is a background process that’s spawned by a </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">job scheduler</span></strong><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">In most </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.348.1">common cases, batch processes are resource-intensive tasks that are usually scheduled to run during less busy hours to avoid system overload. </span><span class="koboSpan" id="kobo.348.2">On Linux, the most commonly used tools for job scheduling are </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">at</span></strong><span class="koboSpan" id="kobo.350.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">cron</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">cron</span></strong><span class="koboSpan" id="kobo.354.1"> is better suited to scheduled task management complexities, </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">at</span></strong><span class="koboSpan" id="kobo.356.1"> is a more lightweight utility, better suited for one-off jobs. </span><span class="koboSpan" id="kobo.356.2">A detailed study of these commands is beyond the scope of this chapter. </span><span class="koboSpan" id="kobo.356.3">You may refer to the related system reference manuals for more information (</span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">man at</span></strong><span class="koboSpan" id="kobo.358.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">man cron</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">We’ll conclude our study of process types with orphan and </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">zombie processes.</span></span></p>
<h3><span class="koboSpan" id="kobo.363.1">Orphan and zombie processes</span></h3>
<p><span class="koboSpan" id="kobo.364.1">When a child process is terminated, the related parent process is notified with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">SIGCHILD</span></strong><span class="koboSpan" id="kobo.366.1"> signal. </span><span class="koboSpan" id="kobo.366.2">The parent can go on running other tasks or may choose to spawn another child process. </span><span class="koboSpan" id="kobo.366.3">However, there may be instances when the parent process is terminated before a related child process </span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.367.1">completes execution (or exits). </span><span class="koboSpan" id="kobo.367.2">In this case, the </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.368.1">child process becomes an </span><strong class="bold"><span class="koboSpan" id="kobo.369.1">orphan process</span></strong><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">In Linux, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">init</span></strong><span class="koboSpan" id="kobo.372.1"> process – the parent of all processes – automatically becomes the new parent of the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">orphan process.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.374.1">Zombie processes</span></strong><span class="koboSpan" id="kobo.375.1"> (also known as </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">defunct processes</span></strong><span class="koboSpan" id="kobo.377.1">) are references </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.378.1">to processes that have completed</span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.379.1"> execution (and exited) but are still lingering</span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.380.1"> in the system process table (according to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> command).</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">The main difference between the zombie and orphan processes is that a zombie process is dead (terminated), while an orphan process is </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">still running.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">As we differentiate between various process types and their behavior, a significant part of the related information is reflected in the composition or data structure of the process itself. </span><span class="koboSpan" id="kobo.385.2">In the next section, we’ll take a closer look at the makeup of a process, which is mostly echoed through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">ps</span></strong><span class="koboSpan" id="kobo.387.1"> command-line utility – an ordinary yet very useful process explorer on </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">Linux systems.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.389.1">The anatomy of a process</span></h2>
<p><span class="koboSpan" id="kobo.390.1">In this section, we will explore some of the common attributes of a Linux process through the lens of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">ps</span></strong><span class="koboSpan" id="kobo.392.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">top</span></strong><span class="koboSpan" id="kobo.394.1"> command-line utilities. </span><span class="koboSpan" id="kobo.394.2">We hope that taking a practical approach based on these tools will help</span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.395.1"> you gain a better understanding of process internals, at least from a Linux administrator’s perspective. </span><span class="koboSpan" id="kobo.395.2">Let’s start by taking a brief look at these commands. </span><span class="koboSpan" id="kobo.395.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">ps</span></strong><span class="koboSpan" id="kobo.397.1"> command displays a current snapshot of the system processes. </span><span class="koboSpan" id="kobo.397.2">This command has the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">following syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
ps [OPTIONS]</span></pre> <p><span class="koboSpan" id="kobo.400.1">The following command displays the processes owned by the current </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">Terminal session:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
ps</span></pre> <p><span class="koboSpan" id="kobo.403.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<span class="koboSpan" id="kobo.405.1"><img alt="Figure 5.4 – Displaying processes owned by the current shell" src="image/Figure_05_04_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.406.1">Figure 5.4 – Displaying processes owned by the current shell</span></p>
<p><span class="koboSpan" id="kobo.407.1">Let’s look at each field in the top (header) row of the output and explain their meaning in the context of our relevant process – that is, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">bash</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.409.1">Terminal session:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">PID</span></strong><span class="koboSpan" id="kobo.411.1">: Each process in Linux has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">PID</span></strong><span class="koboSpan" id="kobo.413.1"> value automatically assigned by the kernel when the process is created. </span><span class="koboSpan" id="kobo.413.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">PID</span></strong><span class="koboSpan" id="kobo.415.1"> value is a positive integer and is always guaranteed to </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">be unique.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.417.1">In our case, the relevant process is </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">bash</span></strong><span class="koboSpan" id="kobo.419.1"> (the current shell), with a PID </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">171233</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">.</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">TTY</span></strong><span class="koboSpan" id="kobo.424.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.425.1">TTY</span></strong><span class="koboSpan" id="kobo.426.1"> is short for </span><strong class="bold"><span class="koboSpan" id="kobo.427.1">teletype</span></strong><span class="koboSpan" id="kobo.428.1">, more</span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.429.1"> popularly known as a controlling Terminal or device for interacting with a system. </span><span class="koboSpan" id="kobo.429.2">In the context of a Linux process, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">TTY</span></strong><span class="koboSpan" id="kobo.431.1"> attribute denotes the type of Terminal the process interacts with. </span><span class="koboSpan" id="kobo.431.2">In our example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">bash</span></strong><span class="koboSpan" id="kobo.433.1"> process representing the Terminal session has </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">pts/0</span></strong><span class="koboSpan" id="kobo.435.1"> as its TTY type. </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">PTS</span></strong><span class="koboSpan" id="kobo.437.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">pts</span></strong><span class="koboSpan" id="kobo.439.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">pseudo terminal slave</span></strong><span class="koboSpan" id="kobo.441.1"> and indicates the input type – a </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.442.1">Terminal console – controlling the process. </span><strong class="source-inline"><span class="koboSpan" id="kobo.443.1">/0</span></strong><span class="koboSpan" id="kobo.444.1"> indicates the ordinal sequence of the related Terminal session. </span><span class="koboSpan" id="kobo.444.2">For example, an additional SSH session would have </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">pts/1</span></strong><span class="koboSpan" id="kobo.446.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">so on.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">TIME</span></strong><span class="koboSpan" id="kobo.449.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">TIME</span></strong><span class="koboSpan" id="kobo.451.1"> field represents the cumulative CPU utilization (or time) spent by the process (in </span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">[DD-]hh:mm:ss</span></strong><span class="koboSpan" id="kobo.453.1"> format). </span><span class="koboSpan" id="kobo.453.2">Why is it zero (</span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">00:00:00</span></strong><span class="koboSpan" id="kobo.455.1">) for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">bash</span></strong><span class="koboSpan" id="kobo.457.1"> process in our example? </span><span class="koboSpan" id="kobo.457.2">We may have run multiple commands in our Terminal session, yet the CPU utilization could still be zero. </span><span class="koboSpan" id="kobo.457.3">That’s because the CPU utilization</span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.458.1"> measures (and accumulates) the time spent for each command, and not the parent Terminal session overall. </span><span class="koboSpan" id="kobo.458.2">If the commands complete within a fraction of a second, they will not amount to a significant CPU utilization being shown in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">TIME</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.460.1"> field.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">CMD</span></strong><span class="koboSpan" id="kobo.462.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">CMD</span></strong><span class="koboSpan" id="kobo.464.1"> field stands for command and indicates the name or full path of the command (including the arguments) that created the process. </span><span class="koboSpan" id="kobo.464.2">For well-known system commands (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">bash</span></strong><span class="koboSpan" id="kobo.466.1">), </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">CMD</span></strong><span class="koboSpan" id="kobo.468.1"> displays the command’s name, including </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">its arguments.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.470.1">The process attributes we’ve explored thus far represent a relatively simple view of Linux processes. </span><span class="koboSpan" id="kobo.470.2">There are situations when we may need more information. </span><span class="koboSpan" id="kobo.470.3">For example, the following command provides additional details about the processes running in the current </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">Terminal session:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
ps -l</span></pre> <p><span class="koboSpan" id="kobo.473.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">-l</span></strong><span class="koboSpan" id="kobo.475.1"> option parameter invokes the so-called </span><em class="italic"><span class="koboSpan" id="kobo.476.1">long format</span></em><span class="koboSpan" id="kobo.477.1"> for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.479.1"> output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<span class="koboSpan" id="kobo.480.1"><img alt="Figure 5.5 – A more detailed view of processes" src="image/Figure_05_05_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.481.1">Figure 5.5 – A more detailed view of processes</span></p>
<p><span class="koboSpan" id="kobo.482.1">Here are just a few of the more relevant output fields of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.484.1"> command:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">F</span></strong><span class="koboSpan" id="kobo.486.1">: Process flags (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">0</span></strong><span class="koboSpan" id="kobo.488.1"> – none, </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">1</span></strong><span class="koboSpan" id="kobo.490.1"> – forked, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">4</span></strong><span class="koboSpan" id="kobo.492.1"> – </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">superuser privileges)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">S</span></strong><span class="koboSpan" id="kobo.495.1">: Process status code (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">R</span></strong><span class="koboSpan" id="kobo.497.1"> – running, </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">S</span></strong><span class="koboSpan" id="kobo.499.1"> – interruptible sleep, and </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">so on)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">UID</span></strong><span class="koboSpan" id="kobo.502.1">: The username or owner of the process (the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">user ID)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">PID</span></strong><span class="koboSpan" id="kobo.505.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">process ID</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">PPID</span></strong><span class="koboSpan" id="kobo.508.1">: The process ID of the </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">parent process</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">PRI</span></strong><span class="koboSpan" id="kobo.511.1">: The priority of the process (a higher number means </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">lower priority)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">SZ</span></strong><span class="koboSpan" id="kobo.514.1">: The virtual </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">memory usage</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.516.1">There are many more such attributes and exploring them all is beyond the scope of this book. </span><span class="koboSpan" id="kobo.516.2">For additional information, refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">ps</span></strong><span class="koboSpan" id="kobo.518.1"> system reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">man ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">ps</span></strong><span class="koboSpan" id="kobo.523.1"> command examples we’ve used so far have only displayed the processes that are owned by the current</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.524.1"> Terminal session. </span><span class="koboSpan" id="kobo.524.2">This approach, we thought, would add less complexity to analyzing </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">process attributes.</span></span></p>
<p><span class="koboSpan" id="kobo.526.1">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">ps</span></strong><span class="koboSpan" id="kobo.528.1">, another command that’s used is </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">top</span></strong><span class="koboSpan" id="kobo.530.1">, and it provides a live (real-time) view of all the running processes in a system. </span><span class="koboSpan" id="kobo.530.2">Its syntax is </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.532.1">
top [OPTIONS]</span></pre> <p><span class="koboSpan" id="kobo.533.1">Many of the process output fields displayed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">ps</span></strong><span class="koboSpan" id="kobo.535.1"> command are also reflected in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">top</span></strong><span class="koboSpan" id="kobo.537.1"> command, albeit some of them with slightly different notations. </span><span class="koboSpan" id="kobo.537.2">Let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">top</span></strong><span class="koboSpan" id="kobo.539.1"> command and the meaning of the output fields that are displayed. </span><span class="koboSpan" id="kobo.539.2">The following command displays a real-time view of </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">running processes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
top</span></pre> <p><span class="koboSpan" id="kobo.542.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<span class="koboSpan" id="kobo.544.1"><img alt="Figure 5.6 – A real-time view of the current processes" src="image/Figure_05_06_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.545.1">Figure 5.6 – A real-time view of the current processes</span></p>
<p><span class="koboSpan" id="kobo.546.1">Here are some of the </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.547.1">output fields, </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">briefly explained:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">USER</span></strong><span class="koboSpan" id="kobo.550.1">: The username or owner of </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the process</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">PR</span></strong><span class="koboSpan" id="kobo.553.1">: The priority of the process (a lower number means </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">higher priority)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">NI</span></strong><span class="koboSpan" id="kobo.556.1">: The nice value of the process (a sort of </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">dynamic/adaptive priority)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">VIRT</span></strong><span class="koboSpan" id="kobo.559.1">: The virtual memory size (in KB) – the total memory used by </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">the process</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">RES</span></strong><span class="koboSpan" id="kobo.562.1">: The resident memory size (in KB) – the physical (non-swapped) memory used by </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">the process</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">SHR</span></strong><span class="koboSpan" id="kobo.565.1">: The shared memory size (in KB) – a subset of the process memory shared with </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">other processes</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">S</span></strong><span class="koboSpan" id="kobo.568.1">: The process’ status (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">R</span></strong><span class="koboSpan" id="kobo.570.1"> – running, </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">S</span></strong><span class="koboSpan" id="kobo.572.1"> – interruptible sleep, </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">I</span></strong><span class="koboSpan" id="kobo.574.1"> – idle, and </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">so on)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.576.1">%CPU</span></strong><span class="koboSpan" id="kobo.577.1">: CPU </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">usage (percentage)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">%MEM</span></strong><span class="koboSpan" id="kobo.580.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">RES</span></strong><span class="koboSpan" id="kobo.582.1"> memory </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">usage (percentage)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.584.1">COMMAND</span></strong><span class="koboSpan" id="kobo.585.1">: Command name or </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">command line</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.587.1">Each of these fields (and many more) are explained in detail in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.588.1">top</span></strong><span class="koboSpan" id="kobo.589.1"> system reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">man top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">Every day, Linux administration tasks frequently use process-related queries based on the preceding presented fields. </span><span class="koboSpan" id="kobo.592.2">The </span><em class="italic"><span class="koboSpan" id="kobo.593.1">Working with processes</span></em><span class="koboSpan" id="kobo.594.1"> section will explore some of the more common usages of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">ps</span></strong><span class="koboSpan" id="kobo.596.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">top</span></strong><span class="koboSpan" id="kobo.598.1"> commands, </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">and beyond.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">An essential </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.601.1">aspect of a process’s lifetime is the </span><strong class="bold"><span class="koboSpan" id="kobo.602.1">status</span></strong><span class="koboSpan" id="kobo.603.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.604.1">state</span></strong><span class="koboSpan" id="kobo.605.1">) of the process at any given time and the</span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.606.1"> transition between these states. </span><span class="koboSpan" id="kobo.606.2">Both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">ps</span></strong><span class="koboSpan" id="kobo.608.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">top</span></strong><span class="koboSpan" id="kobo.610.1"> commands provide information about the status of the process via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">S</span></strong><span class="koboSpan" id="kobo.612.1"> field. </span><span class="koboSpan" id="kobo.612.2">Let’s take a closer look at </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">these states.</span></span></p>
<h3><span class="koboSpan" id="kobo.614.1">Process states</span></h3>
<p><span class="koboSpan" id="kobo.615.1">During its lifetime, a process may change states according to circumstances. </span><span class="koboSpan" id="kobo.615.2">According to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">S</span></strong><span class="koboSpan" id="kobo.617.1"> (status) field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">ps</span></strong><span class="koboSpan" id="kobo.619.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">top</span></strong><span class="koboSpan" id="kobo.621.1"> commands, a Linux process can have any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">following states:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">D</span></strong><span class="koboSpan" id="kobo.624.1">: </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">Uninterruptible sleep</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">I</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">: Idle</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">R</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">: Running</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">S</span></strong><span class="koboSpan" id="kobo.631.1">: Sleeping (</span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">interruptible sleep)</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">T</span></strong><span class="koboSpan" id="kobo.634.1">: Stopped by a job </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">control signal</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">t</span></strong><span class="koboSpan" id="kobo.637.1">: Stopped by the debugger during </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">a trace</span></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">Z</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">: Zombie</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.641.1">At a high level, any of these states</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.642.1"> can be identified with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">process states:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.644.1">Running</span></strong><span class="koboSpan" id="kobo.645.1">: The process is currently running (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">R</span></strong><span class="koboSpan" id="kobo.647.1"> state) or is an idle process (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">I</span></strong><span class="koboSpan" id="kobo.649.1"> state). </span><span class="koboSpan" id="kobo.649.2">In Linux, an idle process is a specific task that’s assigned to every processor (CPU) in the </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.650.1">system and is scheduled to run only when there’s no other process running on the related CPU. </span><span class="koboSpan" id="kobo.650.2">The time that’s spent on idle tasks accounts for the idle time that’s reported by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1"> command.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.653.1">Waiting</span></strong><span class="koboSpan" id="kobo.654.1">: The process is</span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.655.1"> waiting for a specific event or resource. </span><span class="koboSpan" id="kobo.655.2">There are two types of waiting states: interruptible sleep (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">S</span></strong><span class="koboSpan" id="kobo.657.1"> state) and uninterruptible sleep (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">D</span></strong><span class="koboSpan" id="kobo.659.1"> state). </span><span class="koboSpan" id="kobo.659.2">Interruptible sleep can be disturbed by specific process signals, yielding further process execution. </span><span class="koboSpan" id="kobo.659.3">On the other hand, uninterruptible </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.660.1">sleep is a state where the process is blocked in a system call (possibly waiting on some hardware conditions), and it cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">be interrupted.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.662.1">Stopped</span></strong><span class="koboSpan" id="kobo.663.1">: The process has</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.664.1"> stopped executing, usually due to a specific signal – a job control signal (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">T</span></strong><span class="koboSpan" id="kobo.666.1"> state) or a debugging signal (the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">t</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.668.1"> state).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.669.1">Zombie</span></strong><span class="koboSpan" id="kobo.670.1">: The process is </span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.671.1">defunct or dead (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">Z</span></strong><span class="koboSpan" id="kobo.673.1"> state) – it’s terminated without being reaped by its parent. </span><span class="koboSpan" id="kobo.673.2">A zombie process is essentially a dead reference for an already terminated process in the system’s process table. </span><span class="koboSpan" id="kobo.673.3">This will be discussed in more detail in the </span><em class="italic"><span class="koboSpan" id="kobo.674.1">Orphan and zombie </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.675.1">processes</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.676.1"> section.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.677.1">To conclude our analysis of</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.678.1"> process states, let’s look at the lifetime of a Linux process. </span><span class="koboSpan" id="kobo.678.2">Usually, a process starts with a running state (</span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">R</span></strong><span class="koboSpan" id="kobo.680.1">) and terminates once its parent has reaped it from the zombie state (</span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">Z</span></strong><span class="koboSpan" id="kobo.682.1">). </span><span class="koboSpan" id="kobo.682.2">The following diagram provides an abbreviated view of the process states and the possible transitions </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">between them:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<span class="koboSpan" id="kobo.684.1"><img alt="Figure 5.7 – The lifetime of a Linux process" src="image/Figure_05_07_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.685.1">Figure 5.7 – The lifetime of a Linux process</span></p>
<p><span class="koboSpan" id="kobo.686.1">Now that we’ve introduced processes and provided you with a preliminary idea of their type and structure, we’re ready to interact with them. </span><span class="koboSpan" id="kobo.686.2">In the following sections, we will explore some standard</span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.687.1"> command-line utilities for working with processes and daemons. </span><span class="koboSpan" id="kobo.687.2">Most of these tools operate with input and output data, which we covered in the </span><em class="italic"><span class="koboSpan" id="kobo.688.1">Anatomy of a process</span></em><span class="koboSpan" id="kobo.689.1"> section. </span><span class="koboSpan" id="kobo.689.2">We’ll look at working with </span><span class="No-Break"><span class="koboSpan" id="kobo.690.1">processes next.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.691.1">Working with processes</span></h1>
<p><span class="koboSpan" id="kobo.692.1">This section serves as </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.693.1">a practical guide to managing processes via resourceful command-line utilities that are used in everyday Linux administration tasks. </span><span class="koboSpan" id="kobo.693.2">Some of these tools were mentioned in previous sections (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">ps</span></strong><span class="koboSpan" id="kobo.695.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">top</span></strong><span class="koboSpan" id="kobo.697.1">) when we covered specific process internals. </span><span class="koboSpan" id="kobo.697.2">Here, we will summon most of the knowledge we’ve gathered so far and take it for a real-world spin by covering some </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">hands-on examples.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Let’s start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">ps</span></strong><span class="koboSpan" id="kobo.701.1"> command – the Linux </span><span class="No-Break"><span class="koboSpan" id="kobo.702.1">process explorer.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.703.1">Using the ps command</span></h2>
<p><span class="koboSpan" id="kobo.704.1">We described the </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">ps</span></strong><span class="koboSpan" id="kobo.706.1"> command </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.707.1">and its syntax in the </span><em class="italic"><span class="koboSpan" id="kobo.708.1">Anatomy of a process</span></em><span class="koboSpan" id="kobo.709.1"> section. </span><span class="koboSpan" id="kobo.709.2">The following </span><a id="_idIndexMarker684"/><span class="koboSpan" id="kobo.710.1">command displays a selection of the current processes running in </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">the system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.712.1">
ps -e | head</span></pre> <p><span class="koboSpan" id="kobo.713.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">-e</span></strong><span class="koboSpan" id="kobo.715.1"> option (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">-A</span></strong><span class="koboSpan" id="kobo.717.1">) selects </span><em class="italic"><span class="koboSpan" id="kobo.718.1">all</span></em><span class="koboSpan" id="kobo.719.1"> the processes in the system. </span><span class="koboSpan" id="kobo.719.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">head</span></strong><span class="koboSpan" id="kobo.721.1"> pipe invocation displays only the first few lines (10 </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">by default):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<span class="koboSpan" id="kobo.723.1"><img alt="Figure 5.8 – Displaying the first few processes" src="image/Figure_05_08_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.724.1">Figure 5.8 – Displaying the first few processes</span></p>
<p><span class="koboSpan" id="kobo.725.1">The preceding information may not always be particularly useful. </span><span class="koboSpan" id="kobo.725.2">Perhaps we’d like to know more about each process, beyond just the </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">PID</span></strong><span class="koboSpan" id="kobo.727.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">CMD</span></strong><span class="koboSpan" id="kobo.729.1"> fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">ps</span></strong><span class="koboSpan" id="kobo.731.1"> command’s output. </span><span class="koboSpan" id="kobo.731.2">(We described some of these process attributes in the </span><em class="italic"><span class="koboSpan" id="kobo.732.1">Anatomy of a </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.733.1">process</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.734.1"> section).</span></span></p>
<p><span class="koboSpan" id="kobo.735.1">The following command lists the processes owned by the current user </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">more elaborately:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.737.1">
ps -fU $(whoami)</span></pre> <p><span class="koboSpan" id="kobo.738.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">-f</span></strong><span class="koboSpan" id="kobo.740.1"> option specifies the full-format listing, which displays more detailed information for each process. </span><span class="koboSpan" id="kobo.740.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">-U $(whoami)</span></strong><span class="koboSpan" id="kobo.742.1"> option parameter specifies the current user (</span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">packt</span></strong><span class="koboSpan" id="kobo.744.1">) as the real user (owner) of the processes we’d like to retrieve. </span><span class="koboSpan" id="kobo.744.2">In other words, we want to list all the processes </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">we own:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 5.9 – Displaying the processes owned by the current user" src="image/Figure_05_09_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 5.9 – Displaying the processes owned by the current user</span></p>
<p><span class="koboSpan" id="kobo.748.1">There are situations when we may look for a specific process, either for monitoring purposes or to act upon them. </span><span class="koboSpan" id="kobo.748.2">Let’s </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.749.1">take a previous example, where we showcased a long-lived process and wrapped the related command into a simple script. </span><span class="koboSpan" id="kobo.749.2">The</span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.750.1"> command is a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">while</span></strong><span class="koboSpan" id="kobo.752.1"> loop that </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">runs indefinitely:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.754.1">
while true; do x=1; done</span></pre> <p><span class="koboSpan" id="kobo.755.1">Using an editor of our preference (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">nano</span></strong><span class="koboSpan" id="kobo.757.1">), we can create a script file (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">test.sh</span></strong><span class="koboSpan" id="kobo.759.1">) with the </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">following content:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<span class="koboSpan" id="kobo.761.1"><img alt="Figure 5.10 – A simple test script running indefinitely" src="image/Figure_05_10_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.762.1">Figure 5.10 – A simple test script running indefinitely</span></p>
<p><span class="koboSpan" id="kobo.763.1">We can make the test script executable and run it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">background process:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.765.1">
chmod +x test.sh
./test.sh &amp;</span></pre> <p><span class="koboSpan" id="kobo.766.1">Note the ampersand (</span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">&amp;</span></strong><span class="koboSpan" id="kobo.768.1">) at the end of the command, which invokes the </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">background process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<span class="koboSpan" id="kobo.770.1"><img alt="Figure 5.11 – Running a script as a background process" src="image/Figure_05_11_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.771.1">Figure 5.11 – Running a script as a background process</span></p>
<p><span class="koboSpan" id="kobo.772.1">The background process running our script has a process ID (</span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">PID</span></strong><span class="koboSpan" id="kobo.774.1">) of </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">1094</span></strong><span class="koboSpan" id="kobo.776.1">. </span><span class="koboSpan" id="kobo.776.2">Suppose we want to find our process by its name (</span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">test.sh</span></strong><span class="koboSpan" id="kobo.778.1">). </span><span class="koboSpan" id="kobo.778.2">For this, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">ps</span></strong><span class="koboSpan" id="kobo.780.1"> command with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">grep</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.782.1"> pipe:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
ps -ef | grep test.sh</span></pre> <p><span class="koboSpan" id="kobo.784.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<span class="koboSpan" id="kobo.786.1"><img alt=" Figure 5.12 – Finding a process by name using the ps command" src="image/Figure_05_12_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.787.1"> Figure 5.12 – Finding a process by name using the ps command</span></p>
<p><span class="koboSpan" id="kobo.788.1">The preceding output shows that our process has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">PID</span></strong><span class="koboSpan" id="kobo.790.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">1094</span></strong><span class="koboSpan" id="kobo.792.1"> and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">CMD</span></strong><span class="koboSpan" id="kobo.794.1"> value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">/bin/bash ./test.sh</span></strong><span class="koboSpan" id="kobo.796.1">. </span><span class="koboSpan" id="kobo.796.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">CMD</span></strong><span class="koboSpan" id="kobo.798.1"> field contains the full command invocation of our script, including the </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">command-line parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">We should note that the</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.801.1"> first line of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">test.sh</span></strong><span class="koboSpan" id="kobo.803.1"> script contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">#!/bin/bash</span></strong><span class="koboSpan" id="kobo.805.1">, which</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.806.1"> prompts the OS to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">bash</span></strong><span class="koboSpan" id="kobo.808.1"> for the script’s execution. </span><span class="koboSpan" id="kobo.808.2">This line is also known as the </span><strong class="bold"><span class="koboSpan" id="kobo.809.1">shebang</span></strong><span class="koboSpan" id="kobo.810.1"> line, and it has</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.811.1"> to be the first line in a bash script. </span><span class="koboSpan" id="kobo.811.2">To make more sense of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">CMD</span></strong><span class="koboSpan" id="kobo.813.1"> field, the command in our case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">/bin/bash</span></strong><span class="koboSpan" id="kobo.815.1"> (according to the shebang invocation), and the related command-line parameter is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">test.sh</span></strong><span class="koboSpan" id="kobo.817.1"> script. </span><span class="koboSpan" id="kobo.817.2">In other words, </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">bash</span></strong><span class="koboSpan" id="kobo.819.1"> executes the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">test.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.821.1"> script.</span></span></p>
<p><span class="koboSpan" id="kobo.822.1">The output of the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">ps</span></strong><span class="koboSpan" id="kobo.824.1"> command also includes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">ps | grep</span></strong><span class="koboSpan" id="kobo.826.1"> command’s invocation, which is somewhat irrelevant. </span><span class="koboSpan" id="kobo.826.2">A refined version of the same command is </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.828.1">
ps -ef | grep test.sh | grep -v grep</span></pre> <p><span class="koboSpan" id="kobo.829.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<span class="koboSpan" id="kobo.831.1"><img alt="Figure 5.13 – Finding a process by name using the ps command (refined)" src="image/Figure_05_13_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.832.1">Figure 5.13 – Finding a process by name using the ps command (refined)</span></p>
<p><span class="koboSpan" id="kobo.833.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">grep -v grep</span></strong><span class="koboSpan" id="kobo.835.1"> pipe filters out the unwanted </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">grep</span></strong><span class="koboSpan" id="kobo.837.1"> invocation from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">ps</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.839.1">command’s results.</span></span></p>
<p><span class="koboSpan" id="kobo.840.1">If we want to find a process based on a process ID (</span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">PID</span></strong><span class="koboSpan" id="kobo.842.1">), we can invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">ps</span></strong><span class="koboSpan" id="kobo.844.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.845.1">-p|--pid</span></strong><span class="koboSpan" id="kobo.846.1"> option parameter. </span><span class="koboSpan" id="kobo.846.2">For example, the following command displays detailed information about our process with </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">PID</span></strong><span class="koboSpan" id="kobo.848.1"> set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">1094</span></strong><span class="koboSpan" id="kobo.850.1"> (running the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">test.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.852.1"> script):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<span class="koboSpan" id="kobo.853.1"><img alt="Figure 5.14 – Finding a process by PID using the ps command" src="image/Figure_05_14_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.854.1">Figure 5.14 – Finding a process by PID using the ps command</span></p>
<p><span class="koboSpan" id="kobo.855.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.856.1">-f</span></strong><span class="koboSpan" id="kobo.857.1"> option displays the detailed (</span><em class="italic"><span class="koboSpan" id="kobo.858.1">long-format</span></em><span class="koboSpan" id="kobo.859.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.860.1">process information.</span></span></p>
<p><span class="koboSpan" id="kobo.861.1">There are numerous other use cases for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.862.1">ps</span></strong><span class="koboSpan" id="kobo.863.1"> command, and exploring them all is well beyond the scope </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.864.1">of this book. </span><span class="koboSpan" id="kobo.864.2">The invocations we’ve enumerated here </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.865.1">should provide a basic exploratory guideline for you. </span><span class="koboSpan" id="kobo.865.2">For more information, please refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">ps</span></strong><span class="koboSpan" id="kobo.867.1"> system reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.868.1">man ps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">).</span></span></p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.870.1">Using the pstree command</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">pstree</span></strong><span class="koboSpan" id="kobo.872.1"> shows the running</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.873.1"> processes in a hierarchical, tree-like view. </span><span class="koboSpan" id="kobo.873.2">In some respects, </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">pstree</span></strong><span class="koboSpan" id="kobo.875.1"> acts as a visualizer of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">ps</span></strong><span class="koboSpan" id="kobo.877.1"> command. </span><span class="koboSpan" id="kobo.877.2">The root of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">pstree</span></strong><span class="koboSpan" id="kobo.879.1"> command’s output is either the </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">init</span></strong><span class="koboSpan" id="kobo.881.1"> process or the process with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">PID</span></strong><span class="koboSpan" id="kobo.883.1"> value specified in the </span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.884.1">command. </span><span class="koboSpan" id="kobo.884.2">The syntax of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">pstree</span></strong><span class="koboSpan" id="kobo.886.1"> command is </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.888.1">
pstree [OPTIONS] [PID] [USER]</span></pre> <p><span class="koboSpan" id="kobo.889.1">The following command displays the process tree of our current </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">Terminal session:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.891.1">
pstree $(echo $$)</span></pre> <p><span class="koboSpan" id="kobo.892.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<span class="koboSpan" id="kobo.894.1"><img alt="Figure 5.15 – The process tree of the current Terminal session" src="image/Figure_05_15_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.895.1">Figure 5.15 – The process tree of the current Terminal session</span></p>
<p><span class="koboSpan" id="kobo.896.1">In the preceding command, </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">echo $$</span></strong><span class="koboSpan" id="kobo.898.1"> provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.899.1">PID</span></strong><span class="koboSpan" id="kobo.900.1"> value of the current Terminal session. </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">$$</span></strong><span class="koboSpan" id="kobo.902.1"> is a Bash built-in variable that contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">PID</span></strong><span class="koboSpan" id="kobo.904.1"> value of the shell that is running. </span><span class="koboSpan" id="kobo.904.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">PID</span></strong><span class="koboSpan" id="kobo.906.1"> value is wrapped as the argument for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">pstree</span></strong><span class="koboSpan" id="kobo.908.1"> command. </span><span class="koboSpan" id="kobo.908.2">To show the related PIDs, we can invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">pstree</span></strong><span class="koboSpan" id="kobo.910.1"> command with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">p|--show-pids</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.913.1"> option:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
pstree -p $(echo $$)</span></pre> <p><span class="koboSpan" id="kobo.915.1">The output of the preceding</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.916.1"> command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<span class="koboSpan" id="kobo.918.1"><img alt="Figure 5.16 – The process tree (along with its PIDs) of the current Terminal session" src="image/Figure_05_16_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.919.1">Figure 5.16 – The process tree (along with its PIDs) of the current Terminal session</span></p>
<p><span class="koboSpan" id="kobo.920.1">The following command</span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.921.1"> shows the processes owned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.922.1">current user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.923.1">
pstree $(whoami)</span></pre> <p><span class="koboSpan" id="kobo.924.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<span class="koboSpan" id="kobo.926.1"><img alt="Figure 5.17 – The process tree owned by the current user" src="image/Figure_05_17_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.927.1">Figure 5.17 – The process tree owned by the current user</span></p>
<p><span class="koboSpan" id="kobo.928.1">For more information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">pstree</span></strong><span class="koboSpan" id="kobo.930.1"> command, please refer to the related system reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">man pstree</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">).</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.933.1">Using the top command</span></h2>
<p><span class="koboSpan" id="kobo.934.1">When it comes to monitoring </span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.935.1">processes in real time, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">top</span></strong><span class="koboSpan" id="kobo.937.1"> utility is among the most common tool to be used by Linux administrators. </span><span class="koboSpan" id="kobo.937.2">The related command-line syntax is </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.939.1">
top [OPTIONS]</span></pre> <p><span class="koboSpan" id="kobo.940.1">The following command displays all the</span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.941.1"> processes currently running in the system, along with real-time updates (on memory, CPU usage, and </span><span class="No-Break"><span class="koboSpan" id="kobo.942.1">so on):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.943.1">
top</span></pre> <p><span class="koboSpan" id="kobo.944.1">Pressing </span><em class="italic"><span class="koboSpan" id="kobo.945.1">Q</span></em><span class="koboSpan" id="kobo.946.1"> will exit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">top</span></strong><span class="koboSpan" id="kobo.948.1"> command. </span><span class="koboSpan" id="kobo.948.2">By default, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">top</span></strong><span class="koboSpan" id="kobo.950.1"> command sorts the output by CPU usage (shown in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">%</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">CPU</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> field/column).</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">We can also choose to sort the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.955.1">top</span></strong><span class="koboSpan" id="kobo.956.1"> command by a different field. </span><span class="koboSpan" id="kobo.956.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">top</span></strong><span class="koboSpan" id="kobo.958.1"> is running, press </span><em class="italic"><span class="koboSpan" id="kobo.959.1">Shift</span></em><span class="koboSpan" id="kobo.960.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.961.1">F</span></em><span class="koboSpan" id="kobo.962.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">F</span></strong><span class="koboSpan" id="kobo.964.1">) to invoke </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">interactive mode.</span></span></p>
<p><span class="koboSpan" id="kobo.966.1">Using the arrow keys, we can select the desired field to sort by (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.967.1">%MEM</span></strong><span class="koboSpan" id="kobo.968.1">), then press </span><em class="italic"><span class="koboSpan" id="kobo.969.1">S</span></em><span class="koboSpan" id="kobo.970.1"> to set the new field, followed by </span><em class="italic"><span class="koboSpan" id="kobo.971.1">Q</span></em><span class="koboSpan" id="kobo.972.1"> to exit interactive mode. </span><span class="koboSpan" id="kobo.972.2">The alternative to interactive mode sorting is invoking the </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">-o</span></strong><span class="koboSpan" id="kobo.974.1"> option parameter of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">top</span></strong><span class="koboSpan" id="kobo.976.1"> command, which specifies the </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">sorting field.</span></span></p>
<p><span class="koboSpan" id="kobo.978.1">For example, the following </span><a id="_idIndexMarker698"/><span class="koboSpan" id="kobo.979.1">command lists the top 10 processes, sorted by </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">CPU usage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.981.1">
top -b -o %CPU | head -n 17</span></pre> <p><span class="koboSpan" id="kobo.982.1">Similarly, the following </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.983.1">command lists the top 10 processes, sorted by CPU and </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">memory usage:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.985.1">
top -b -o +%MEM | head -n 17</span></pre> <p><span class="koboSpan" id="kobo.986.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">-b</span></strong><span class="koboSpan" id="kobo.988.1"> option parameter specifies the batch mode operation (instead of the default interactive mode). </span><span class="koboSpan" id="kobo.988.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">-o +%MEM</span></strong><span class="koboSpan" id="kobo.990.1"> option parameter indicates the additional (</span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">+</span></strong><span class="koboSpan" id="kobo.992.1">) sorting field (</span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">%MEM</span></strong><span class="koboSpan" id="kobo.994.1">) in tandem with the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">%CPU</span></strong><span class="koboSpan" id="kobo.996.1"> field. </span><span class="koboSpan" id="kobo.996.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">head -n 17</span></strong><span class="koboSpan" id="kobo.998.1"> pipe selects the first 17 lines of the output, accounting for the seven-line header of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1"> command:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<span class="koboSpan" id="kobo.1001.1"><img alt="Figure 5.18 – The top 10 processes sorted by CPU and memory usage" src="image/Figure_05_18_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1002.1">Figure 5.18 – The top 10 processes sorted by CPU and memory usage</span></p>
<p><span class="koboSpan" id="kobo.1003.1">The following command lists the top five processes by CPU usage, owned by the current </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">user (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">packt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1006.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
top -u $(whoami) -b -o %CPU | head -n 12</span></pre> <p><span class="koboSpan" id="kobo.1008.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">-u $(whoami)</span></strong><span class="koboSpan" id="kobo.1010.1"> option parameter specifies the current user for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1"> command.</span></span></p>
<p><span class="koboSpan" id="kobo.1013.1">With the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">top</span></strong><span class="koboSpan" id="kobo.1015.1"> command, we </span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.1016.1">can also monitor specific processes using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">-p</span></strong><span class="koboSpan" id="kobo.1018.1"> PID option parameter. </span><span class="koboSpan" id="kobo.1018.2">For example, the following command monitors our test </span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.1019.1">process (with </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">PID </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">243436</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
top -p 1094</span></pre> <p><span class="koboSpan" id="kobo.1024.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<span class="koboSpan" id="kobo.1026.1"><img alt="Figure 5.19 – Monitoring a specific PID with the top command" src="image/Figure_05_19_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1027.1">Figure 5.19 – Monitoring a specific PID with the top command</span></p>
<p><span class="koboSpan" id="kobo.1028.1">We may choose to </span><em class="italic"><span class="koboSpan" id="kobo.1029.1">kill</span></em><span class="koboSpan" id="kobo.1030.1"> the process by pressing </span><em class="italic"><span class="koboSpan" id="kobo.1031.1">K</span></em><span class="koboSpan" id="kobo.1032.1"> while using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1033.1">top</span></strong><span class="koboSpan" id="kobo.1034.1"> command. </span><span class="koboSpan" id="kobo.1034.2">We’ll get prompted for this by the PID of the process we want </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">to terminate:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<span class="koboSpan" id="kobo.1036.1"><img alt="Figure 5.20 – Killing a process with the top command" src="image/Figure_05_20_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1037.1">Figure 5.20 – Killing a process with the top command</span></p>
<p><span class="koboSpan" id="kobo.1038.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">top</span></strong><span class="koboSpan" id="kobo.1040.1"> utility can be used in many creative ways. </span><span class="koboSpan" id="kobo.1040.2">We hope that the examples we’ve provided in this section have inspired you to explore further use cases based on specific needs. </span><span class="koboSpan" id="kobo.1040.3">For more information, please refer to the system reference manual for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">top</span></strong><span class="koboSpan" id="kobo.1042.1"> command (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">man top</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">).</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.1045.1">Using the kill and killall commands</span></h2>
<p><span class="koboSpan" id="kobo.1046.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">kill</span></strong><span class="koboSpan" id="kobo.1048.1"> command to terminate </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.1049.1">processes. </span><span class="koboSpan" id="kobo.1049.2">The command’s</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.1050.1"> syntax is </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1052.1">
kill [OPTIONS] [ -s SIGNAL | -SIGNAL ] PID [...]</span></pre> <p><span class="koboSpan" id="kobo.1053.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1054.1">kill</span></strong><span class="koboSpan" id="kobo.1055.1"> command sends a </span><em class="italic"><span class="koboSpan" id="kobo.1056.1">signal</span></em><span class="koboSpan" id="kobo.1057.1"> to a process, attempting to stop its execution. </span><span class="koboSpan" id="kobo.1057.2">When no signal is </span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.1058.1">specified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.1060.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">15</span></strong><span class="koboSpan" id="kobo.1062.1">) is sent. </span><span class="koboSpan" id="kobo.1062.2">A signal can either be specified by the signal’s name without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">SIG</span></strong><span class="koboSpan" id="kobo.1064.1"> prefix (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">KILL</span></strong><span class="koboSpan" id="kobo.1066.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1068.1">) or by value (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">9</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1070.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">SIGKILL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1073.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">kill -l</span></strong><span class="koboSpan" id="kobo.1075.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">kill -L</span></strong><span class="koboSpan" id="kobo.1077.1"> commands provide a full list of signals that can be used </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">in Linux:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<span class="koboSpan" id="kobo.1079.1"><img alt="Figure 5.21 – The Linux signals" src="image/Figure_05_21_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1080.1">Figure 5.21 – The Linux signals</span></p>
<p><span class="koboSpan" id="kobo.1081.1">Each signal has a numeric value, as </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.1082.1">shown in the preceding output. </span><span class="koboSpan" id="kobo.1082.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1084.1"> equals </span><strong class="source-inline"><span class="koboSpan" id="kobo.1085.1">9</span></strong><span class="koboSpan" id="kobo.1086.1">. </span><span class="koboSpan" id="kobo.1086.2">The following command will kill our test process (with </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">PID </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">243436</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1089.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1090.1">
kill -9 1094</span></pre> <p><span class="koboSpan" id="kobo.1091.1">The following command will also do the same as the </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">preceding command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1093.1">
kill -KILL 1094</span></pre> <p><span class="koboSpan" id="kobo.1094.1">In some scenarios, we may want to kill multiple processes in one go. </span><span class="koboSpan" id="kobo.1094.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">killall</span></strong><span class="koboSpan" id="kobo.1096.1"> command comes to the rescue here. </span><span class="koboSpan" id="kobo.1096.2">The syntax for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">killall</span></strong><span class="koboSpan" id="kobo.1098.1"> command is </span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1100.1">
killall [OPTIONS] [ -s SIGNAL | -SIGNAL ] NAME...</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.1101.1">killall</span></strong><span class="koboSpan" id="kobo.1102.1"> sends a signal to </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.1103.1">all the processes running any of the commands specified. </span><span class="koboSpan" id="kobo.1103.2">When no signal is specified, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.1105.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">15</span></strong><span class="koboSpan" id="kobo.1107.1">) is sent. </span><span class="koboSpan" id="kobo.1107.2">A signal can either be specified by the signal name without</span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.1108.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">SIG</span></strong><span class="koboSpan" id="kobo.1110.1"> prefix (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">TERM</span></strong><span class="koboSpan" id="kobo.1112.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.1114.1">) or by value (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">15</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1116.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">SIGTERM</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1119.1">For example, the </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.1120.1">following command terminates all the processes</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.1121.1"> running the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">test.sh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1"> script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1124.1">
killall -e -TERM test.sh</span></pre> <p><span class="koboSpan" id="kobo.1125.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<span class="koboSpan" id="kobo.1127.1"><img alt="Figure 5.22 – Terminating multiple processes with killall" src="image/Figure_05_22_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1128.1">Figure 5.22 – Terminating multiple processes with killall</span></p>
<p><span class="koboSpan" id="kobo.1129.1">Killing a process will usually remove the related reference from the system process table. </span><span class="koboSpan" id="kobo.1129.2">The terminated process won’t show up anymore in the output of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">ps</span></strong><span class="koboSpan" id="kobo.1131.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">top</span></strong><span class="koboSpan" id="kobo.1133.1">, or </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">similar commands.</span></span></p>
<p><span class="koboSpan" id="kobo.1135.1">For more information about the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">kill</span></strong><span class="koboSpan" id="kobo.1137.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">killall</span></strong><span class="koboSpan" id="kobo.1139.1"> commands, please refer to the related system reference manuals (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">man kill</span></strong><span class="koboSpan" id="kobo.1141.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">man killall</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">).</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.1144.1">Using the pgrep and pkill commands</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">pgrep</span></strong><span class="koboSpan" id="kobo.1146.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">pkill</span></strong><span class="koboSpan" id="kobo.1148.1"> are pattern-based lookup </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1149.1">commands for exploring and</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1150.1"> terminating running processes. </span><span class="koboSpan" id="kobo.1150.2">They </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1151.1">have the </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">following </span></span><span class="No-Break"><a id="_idIndexMarker713"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">syntax:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
pgrep [OPTIONS] PATTERN
pkill [OPTIONS] PATTERN</span></pre> <p><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">pgrep</span></strong><span class="koboSpan" id="kobo.1156.1"> iterates through the current processes and lists the PIDs that match the selection pattern or criteria. </span><span class="koboSpan" id="kobo.1156.2">Similarly, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">pkill</span></strong><span class="koboSpan" id="kobo.1158.1"> terminates the processes that match the </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">selection criteria.</span></span></p>
<p><span class="koboSpan" id="kobo.1160.1">The following command looks for our test process (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">test.sh</span></strong><span class="koboSpan" id="kobo.1162.1">) and displays the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">PID</span></strong><span class="koboSpan" id="kobo.1164.1"> value if the related process is found. </span><span class="koboSpan" id="kobo.1164.2">Start the process again before using the following command as we killed it in the previous </span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1165.1">section. </span><span class="koboSpan" id="kobo.1165.2">This will lead to a</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1166.1"> different </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1167.1">PID</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1"> value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
pgrep -f test.sh</span></pre> <p><span class="koboSpan" id="kobo.1170.1">The output of the preceding </span><a id="_idIndexMarker716"/><span class="koboSpan" id="kobo.1171.1">command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1172.1">following </span></span><span class="No-Break"><a id="_idIndexMarker717"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<span class="koboSpan" id="kobo.1174.1"><img alt="Figure 5.23 – Looking for a PID based on name using pgrep" src="image/Figure_05_23_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1175.1">Figure 5.23 – Looking for a PID based on name using pgrep</span></p>
<p><span class="koboSpan" id="kobo.1176.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">-f|--full</span></strong><span class="koboSpan" id="kobo.1178.1"> option enforces a full name match of the process we’re looking for. </span><span class="koboSpan" id="kobo.1178.2">We may use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">pgrep</span></strong><span class="koboSpan" id="kobo.1180.1"> in tandem with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">ps</span></strong><span class="koboSpan" id="kobo.1182.1"> command to get more detailed information about the process, </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1184.1">
pgrep -f test.sh | xargs ps -fp</span></pre> <p><span class="koboSpan" id="kobo.1185.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<span class="koboSpan" id="kobo.1187.1"><img alt="Figure 5.24 – Chaining pgrep and ps for more information" src="image/Figure_05_24_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1188.1">Figure 5.24 – Chaining pgrep and ps for more information</span></p>
<p><span class="koboSpan" id="kobo.1189.1">In the preceding one-liner, we piped the output of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">pgrep</span></strong><span class="koboSpan" id="kobo.1191.1"> command (with PID </span><strong class="source-inline"><span class="koboSpan" id="kobo.1192.1">243436</span></strong><span class="koboSpan" id="kobo.1193.1">) to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">ps</span></strong><span class="koboSpan" id="kobo.1195.1"> command, which has been invoked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">-f</span></strong><span class="koboSpan" id="kobo.1197.1"> (long-format) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">-p|--pid</span></strong><span class="koboSpan" id="kobo.1199.1"> options. </span><span class="koboSpan" id="kobo.1199.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1200.1">-p</span></strong><span class="koboSpan" id="kobo.1201.1"> option parameter gets the piped </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">PID value.</span></span></p>
<p><span class="koboSpan" id="kobo.1203.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1204.1">xargs</span></strong><span class="koboSpan" id="kobo.1205.1"> command takes the input from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1206.1">pgrep</span></strong><span class="koboSpan" id="kobo.1207.1"> command and converts it into an argument for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1208.1">ps</span></strong><span class="koboSpan" id="kobo.1209.1"> command. </span><span class="koboSpan" id="kobo.1209.2">Thus, when piping from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1210.1">pgrep</span></strong><span class="koboSpan" id="kobo.1211.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1212.1">ps</span></strong><span class="koboSpan" id="kobo.1213.1">, the output of the first command was automatically converted as the argument for the second command. </span><span class="koboSpan" id="kobo.1213.2">By default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1214.1">xargs</span></strong><span class="koboSpan" id="kobo.1215.1"> reads the </span><span class="No-Break"><span class="koboSpan" id="kobo.1216.1">standard input.</span></span></p>
<p><span class="koboSpan" id="kobo.1217.1">To terminate our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1218.1">test.sh</span></strong><span class="koboSpan" id="kobo.1219.1"> process, we </span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.1220.1">simply invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">pkill</span></strong><span class="koboSpan" id="kobo.1222.1"> command, </span><span class="No-Break"><span class="koboSpan" id="kobo.1223.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1224.1">
pkill -f test.sh</span></pre> <p><span class="koboSpan" id="kobo.1225.1">The preceding </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.1226.1">command will </span><em class="italic"><span class="koboSpan" id="kobo.1227.1">silently</span></em><span class="koboSpan" id="kobo.1228.1"> kill the related process, based on the full name lookup enforced by the -</span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">f|--full</span></strong><span class="koboSpan" id="kobo.1230.1"> option. </span><span class="koboSpan" id="kobo.1230.2">To get some feedback from the action of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">pkill</span></strong><span class="koboSpan" id="kobo.1232.1"> command, we</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.1233.1"> need to invoke the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">-e|--echo</span></strong><span class="koboSpan" id="kobo.1235.1"> option, </span><span class="No-Break"><span class="koboSpan" id="kobo.1236.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1237.1">
pkill -ef test.sh</span></pre> <p><span class="koboSpan" id="kobo.1238.1">The output of the preceding command can be seen in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<span class="koboSpan" id="kobo.1240.1"><img alt="Figure 5.25 – Killing a process by name using pkill" src="image/Figure_05_25_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1241.1">Figure 5.25 – Killing a process by name using pkill</span></p>
<p><span class="koboSpan" id="kobo.1242.1">For more information, please refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">pgrep</span></strong><span class="koboSpan" id="kobo.1244.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">pkill</span></strong><span class="koboSpan" id="kobo.1246.1"> system reference manuals (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1247.1">man pgrep</span></strong><span class="koboSpan" id="kobo.1248.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">man pkill</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1251.1">This section covered some command-line utilities that are frequently used in everyday Linux administration tasks involving </span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.1252.1">processes. </span><span class="koboSpan" id="kobo.1252.2">Keep in mind that in Linux, most of the time, there are many ways to accomplish a specific task. </span><span class="koboSpan" id="kobo.1252.3">We hope that the examples in this section will help you come up with creative methods and techniques for working </span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1">with processes.</span></span></p>
<p><span class="koboSpan" id="kobo.1254.1">Next, we’ll look at some common ways of interacting </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">with daemons.</span></span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.1256.1">Working with daemons</span></h1>
<p><span class="koboSpan" id="kobo.1257.1">As noted in the introductory sections, daemons</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.1258.1"> are a special breed of background process. </span><span class="koboSpan" id="kobo.1258.2">Consequently, the vast majority of methods and techniques for working with processes also apply to daemons. </span><span class="koboSpan" id="kobo.1258.3">However, there are specific commands that strictly operate on daemons when it comes to managing (or controlling) the lifetime of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">related processes.</span></span></p>
<p><span class="koboSpan" id="kobo.1260.1">As noted in the </span><em class="italic"><span class="koboSpan" id="kobo.1261.1">Introducing daemons</span></em><span class="koboSpan" id="kobo.1262.1"> section, daemon processes are controlled by shell scripts, usually stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">/etc/init.d/</span></strong><span class="koboSpan" id="kobo.1264.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1265.1">/lib/systemd/</span></strong><span class="koboSpan" id="kobo.1266.1"> system directories, depending on the Linux platform. </span><span class="koboSpan" id="kobo.1266.2">On legacy Linux systems (for example, RHEL 6) and Ubuntu (even in the latest distros), the daemon script files are stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">/etc/init.d/</span></strong><span class="koboSpan" id="kobo.1268.1">. </span><span class="koboSpan" id="kobo.1268.2">On RHEL 7/Ubuntu 18.04 and newer platforms, they are typically stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">/lib/systemd/</span></strong><span class="koboSpan" id="kobo.1270.1">. </span><span class="koboSpan" id="kobo.1270.2">Feel free to do a listing of those two directories to see </span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">the contents.</span></span></p>
<p><span class="koboSpan" id="kobo.1272.1">The location of the daemon files and the daemon command-line utilities largely depends on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">init</span></strong><span class="koboSpan" id="kobo.1274.1"> initialization system and service manager. </span><span class="koboSpan" id="kobo.1274.2">In </span><em class="italic"><span class="koboSpan" id="kobo.1275.1">The init process</span></em><span class="koboSpan" id="kobo.1276.1"> section, we briefly mentioned a variety of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">init</span></strong><span class="koboSpan" id="kobo.1278.1"> systems across Linux distributions. </span><span class="koboSpan" id="kobo.1278.2">To illustrate the use of daemon control commands, we will explore the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">init</span></strong><span class="koboSpan" id="kobo.1280.1"> system called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">systemd</span></strong><span class="koboSpan" id="kobo.1282.1">, which is extensively </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.1283.1">used across various </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">Linux platforms.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.1285.1">Working with systemd daemons</span></h2>
<p><span class="koboSpan" id="kobo.1286.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">init</span></strong><span class="koboSpan" id="kobo.1288.1"> system’s essential requirement is to initialize and orchestrate the launch and startup dependencies of various processes when the Linux kernel is booted. </span><span class="koboSpan" id="kobo.1288.2">These processes are also</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.1289.1"> known as </span><strong class="bold"><span class="koboSpan" id="kobo.1290.1">userland</span></strong><span class="koboSpan" id="kobo.1291.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.1292.1">user processes</span></strong><span class="koboSpan" id="kobo.1293.1">. </span><span class="koboSpan" id="kobo.1293.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1294.1">init</span></strong><span class="koboSpan" id="kobo.1295.1"> engine also controls the services and</span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.1296.1"> daemons while the system </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">is </span></span><span class="No-Break"><a id="_idIndexMarker726"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">running.</span></span></p>
<p><span class="koboSpan" id="kobo.1299.1">Over the last few years, most Linux platforms have</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.1300.1"> transitioned to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">systemd</span></strong><span class="koboSpan" id="kobo.1302.1"> as their default </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">init</span></strong><span class="koboSpan" id="kobo.1304.1"> engine. </span><span class="koboSpan" id="kobo.1304.2">Due to its extensive adoption, being familiar with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1305.1">systemd</span></strong><span class="koboSpan" id="kobo.1306.1"> and its related command-line tools is of paramount importance. </span><span class="koboSpan" id="kobo.1306.2">With that in mind, this section’s primary focus is on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">systemctl</span></strong><span class="koboSpan" id="kobo.1308.1"> – the central command-line utility for managing </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">systemd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1"> daemons.</span></span></p>
<p><span class="koboSpan" id="kobo.1311.1">The syntax of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1312.1">systemctl</span></strong><span class="koboSpan" id="kobo.1313.1"> command is </span><span class="No-Break"><span class="koboSpan" id="kobo.1314.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1315.1">
systemctl [OPTIONS] [COMMAND] [UNITS...]</span></pre> <p><span class="koboSpan" id="kobo.1316.1">The actions that are invoked by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">systemctl</span></strong><span class="koboSpan" id="kobo.1318.1"> command are directed at units, which are system resources that are managed by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">systemd</span></strong><span class="koboSpan" id="kobo.1320.1">. </span><span class="koboSpan" id="kobo.1320.2">Several unit types are defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">systemd</span></strong><span class="koboSpan" id="kobo.1322.1"> (for example, service, mount, socket, and so on). </span><span class="koboSpan" id="kobo.1322.2">Each of these units has a corresponding file. </span><span class="koboSpan" id="kobo.1322.3">These file types are inferred from the suffix of the related filename; for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1323.1">httpd.service</span></strong><span class="koboSpan" id="kobo.1324.1"> is the service unit file of the Apache web service (daemon). </span><span class="koboSpan" id="kobo.1324.2">For a comprehensive list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">systemd</span></strong><span class="koboSpan" id="kobo.1326.1"> units and detailed descriptions of them, please refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">systemd.unit</span></strong><span class="koboSpan" id="kobo.1328.1"> system reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">man systemd.unit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1331.1">The following command enables a daemon (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">httpd</span></strong><span class="koboSpan" id="kobo.1333.1">, the web server) to start </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">at boot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1335.1">
sudo systemctl enable httpd</span></pre> <p><span class="koboSpan" id="kobo.1336.1">Typically, invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">systemctl</span></strong><span class="koboSpan" id="kobo.1338.1"> commands requires superuser privileges. </span><span class="koboSpan" id="kobo.1338.2">We should note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">systemctl</span></strong><span class="koboSpan" id="kobo.1340.1"> does not require the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1341.1">.service</span></strong><span class="koboSpan" id="kobo.1342.1"> suffix when we’re targeting service units. </span><span class="koboSpan" id="kobo.1342.2">The following invocation is </span><span class="No-Break"><span class="koboSpan" id="kobo.1343.1">also acceptable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1344.1">
sudo systemctl enable httpd.service</span></pre> <p><span class="koboSpan" id="kobo.1345.1">The command to disable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">httpd</span></strong><span class="koboSpan" id="kobo.1347.1"> service from starting at boot is </span><span class="No-Break"><span class="koboSpan" id="kobo.1348.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1349.1">
sudo systemctl disable httpd</span></pre> <p><span class="koboSpan" id="kobo.1350.1">To query the status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1351.1">httpd</span></strong><span class="koboSpan" id="kobo.1352.1"> service, we can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.1353.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1354.1">
sudo systemctl status httpd</span></pre> <p><span class="koboSpan" id="kobo.1355.1">Alternatively, we</span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.1356.1"> can check the status of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1357.1">httpd</span></strong><span class="koboSpan" id="kobo.1358.1"> service with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1360.1">
sudo systemctl is-active httpd</span></pre> <p><span class="koboSpan" id="kobo.1361.1">The following commands </span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.1362.1">stop or start the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1363.1">httpd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1364.1"> service:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1365.1">
sudo systemctl stop httpd
sudo systemctl start httpd</span></pre> <p><span class="koboSpan" id="kobo.1366.1">For more information on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1367.1">systemctl</span></strong><span class="koboSpan" id="kobo.1368.1">, please refer to the related system reference manual (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">man systemctl</span></strong><span class="koboSpan" id="kobo.1370.1">). </span><span class="koboSpan" id="kobo.1370.2">For more information about </span><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">systemd</span></strong><span class="koboSpan" id="kobo.1372.1"> internals, please refer to the corresponding reference manual (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1373.1">man systemd</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1374.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1375.1">Working with processes and daemons is a constant theme of everyday Linux administration tasks. </span><span class="koboSpan" id="kobo.1375.2">Mastering the related command-line utilities is an essential skill for any seasoned user. </span><span class="koboSpan" id="kobo.1375.3">Yet, a running process or daemon should also be considered in relationships with other processes or daemons running either locally or on remote systems. </span><span class="koboSpan" id="kobo.1375.4">The way processes communicate with each other could be a slight mystery to some. </span><span class="koboSpan" id="kobo.1375.5">We will address this in the next section, in which we will explain how inter-process </span><span class="No-Break"><span class="koboSpan" id="kobo.1376.1">communication works.</span></span></p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.1377.1">Explaining inter-process communication</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.1378.1">Inter-process communication</span></strong><span class="koboSpan" id="kobo.1379.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1380.1">IPC</span></strong><span class="koboSpan" id="kobo.1381.1">) is a way of interacting between processes using a shared mechanism or </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.1382.1">interface. </span><span class="koboSpan" id="kobo.1382.2">In this section, we will take a short theoretical approach to exploring various communication mechanisms between processes. </span><span class="koboSpan" id="kobo.1382.3">For more details on this matter and some of the mechanisms used, head to </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1383.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1384.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1385.1">Linux </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1386.1">Shell Scripting</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1388.1">Linux processes can typically share data and synchronize their actions via the </span><span class="No-Break"><span class="koboSpan" id="kobo.1389.1">following interfaces:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1390.1">Shared storage</span></strong><span class="koboSpan" id="kobo.1391.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1392.1">files</span></strong><span class="koboSpan" id="kobo.1393.1">): In its simplest form, the shared storage of an IPC mechanism can be a simple file that’s been saved to disk. </span><span class="koboSpan" id="kobo.1393.2">The producer then writes to a file while the consumer </span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.1394.1">reads from the same file. </span><span class="koboSpan" id="kobo.1394.2">In this simple use case, the obvious challenge is the integrity of the read/write operations due to possible race conditions between the underlying operations. </span><span class="koboSpan" id="kobo.1394.3">To avoid race conditions, the file must be locked during write operations to prevent overlapping I/O with another read or write action. </span><span class="koboSpan" id="kobo.1394.4">To keep things simple, we’re not going to resolve this problem in our naive examples, but we thought it’s worth calling </span><span class="No-Break"><span class="koboSpan" id="kobo.1395.1">it out.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1396.1">Shared memory</span></strong><span class="koboSpan" id="kobo.1397.1">: Processes in Linux</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.1398.1"> typically have separate address spaces. </span><span class="koboSpan" id="kobo.1398.2">A process can only access data in the memory of another process if the two share a common memory segment where such data would be stored. </span><span class="koboSpan" id="kobo.1398.3">Linux provides at least a couple of </span><strong class="bold"><span class="koboSpan" id="kobo.1399.1">application programming interfaces</span></strong><span class="koboSpan" id="kobo.1400.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1401.1">APIs</span></strong><span class="koboSpan" id="kobo.1402.1">) to programmatically define and control shared memory between </span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.1403.1">processes: a legacy System V API and the more recent POSIX API, for example. </span><span class="koboSpan" id="kobo.1403.2">Both these APIs are written in C, though the implementation of the producer and consumer mockups is beyond the scope of this book. </span><span class="koboSpan" id="kobo.1403.3">However, we can closely match the shared memory approach by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1404.1">/dev/shm</span></strong><span class="koboSpan" id="kobo.1405.1"> temporary file storage system, which uses the system’s RAM as its backing store (that is, </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">RAM disk).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1407.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1408.1">/dev/shm</span></strong><span class="koboSpan" id="kobo.1409.1"> being used as shared memory, we can reuse our producer-consumer model from the example in the previous point on </span><em class="italic"><span class="koboSpan" id="kobo.1410.1">Shared storage</span></em><span class="koboSpan" id="kobo.1411.1">, where we simply point the storage file </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">/dev/shm/storage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1415.1">The shared memory and shared storage IPC models may not perform well with large amounts of data, especially massive data streams. </span><span class="koboSpan" id="kobo.1415.2">The alternative would be to use IPC channels, which can be enabled through the pipe, message queue, or socket </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">communication layers.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1417.1">Named and unnamed pipes</span></strong><span class="koboSpan" id="kobo.1418.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.1419.1">Unnamed</span></strong><span class="koboSpan" id="kobo.1420.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.1421.1">anonymous pipes</span></strong><span class="koboSpan" id="kobo.1422.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.1423.1">regular pipes</span></strong><span class="koboSpan" id="kobo.1424.1">, feed the output of a process to the input of another one. </span><span class="koboSpan" id="kobo.1424.2">Using our producer-consumer </span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.1425.1">model, the</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.1426.1"> simplest way to illustrate an unnamed pipe as an IPC mechanism between the two processes would be to do </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">the following:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1428.1">producer.sh | consumer.sh</span></strong></pre></li> </ul>
<p><span class="koboSpan" id="kobo.1429.1">The key element of the preceding code is the pipe (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1430.1">|</span></strong><span class="koboSpan" id="kobo.1431.1">) symbol. </span><span class="koboSpan" id="kobo.1431.2">The left-hand side of the pipe produces an output that’s fed directly to the right-hand side of the pipe </span><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">for consumption.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1433.1">Named pipes</span></strong><span class="koboSpan" id="kobo.1434.1">, also known as </span><strong class="bold"><span class="koboSpan" id="kobo.1435.1">First-In, First-Outs</span></strong><span class="koboSpan" id="kobo.1436.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1437.1">FIFOs</span></strong><span class="koboSpan" id="kobo.1438.1">), are similar to traditional (unnamed) pipes but substantially </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.1439.1">different in terms of their semantics. </span><span class="koboSpan" id="kobo.1439.2">An unnamed pipe only persists for as long as the related process is running. </span><span class="koboSpan" id="kobo.1439.3">However, a named pipe has backing storage and will last as long as the system is up, regardless of the running status of the processes attached to the related IPC channel. </span><span class="koboSpan" id="kobo.1439.4">Typically, a named pipe acts as a file, and it can be deleted when it’s no longer </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">being used.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1441.1">Message queues</span></strong><span class="koboSpan" id="kobo.1442.1">: A message</span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.1443.1"> queue is an asynchronous communication mechanism that’s typically used in a distributed system</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.1444.1"> architecture. </span><span class="koboSpan" id="kobo.1444.2">Messages are written and stored in a queue until they are processed and eventually deleted. </span><span class="koboSpan" id="kobo.1444.3">A message is written (published) by a producer and is processed only once, typically by a single consumer. </span><span class="koboSpan" id="kobo.1444.4">At a very high level, a message has a sequence, a payload, and a type. </span><span class="koboSpan" id="kobo.1444.5">Message queues can regulate the retrieval (order) of messages (for example, based on priority </span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">or type):</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer155">
<span class="koboSpan" id="kobo.1446.1"><img alt="" role="presentation" src="image/Figure_05_26_B19682.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1447.1">Figure 5.26 – Message queue (simplified view)</span></p>
<p><span class="koboSpan" id="kobo.1448.1">A detailed analysis of message queues or a mock implementation thereof is far from trivial, and it’s </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.1449.1">beyond this chapter’s scope. </span><span class="koboSpan" id="kobo.1449.2">There are numerous open source message queue implementations available for most Linux platforms (RabbitMQ, ActiveMQ, ZeroMQ, MQTT, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">so on).</span></span></p>
<p><span class="koboSpan" id="kobo.1451.1">IPC mechanisms based on </span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.1452.1">message queues and pipes are unidirectional. </span><span class="koboSpan" id="kobo.1452.2">One process writes the data; another one reads it. </span><span class="koboSpan" id="kobo.1452.3">There are bidirectional implementations of named pipes, but the complexities involved would negatively impact the underlying communication layer. </span><span class="koboSpan" id="kobo.1452.4">For bidirectional communication, you can think of using socket-based IPC channels (detailed in </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1453.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1454.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1455.1">Linux </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1456.1">Shell Scripting</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1457.1">).</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1458.1">Sockets</span></strong><span class="koboSpan" id="kobo.1459.1">: There are two types of IPC </span><a id="_idIndexMarker741"/><span class="No-Break"><span class="koboSpan" id="kobo.1460.1">socket-based</span></span><span class="No-Break"><a id="_idIndexMarker742"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1"> facilities:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.1462.1">IPC sockets</span></strong><span class="koboSpan" id="kobo.1463.1">: Also known as Unix domain sockets, IPC sockets use a local file as a socket address and enable </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.1464.1">bidirectional communication between processes on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1465.1">same host.</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.1466.1">Network sockets</span></strong><span class="koboSpan" id="kobo.1467.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.1468.1">Transport Control Protocol</span></strong><span class="koboSpan" id="kobo.1469.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1470.1">TCP</span></strong><span class="koboSpan" id="kobo.1471.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.1472.1">User Datagram Protocol</span></strong><span class="koboSpan" id="kobo.1473.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1474.1">UDP</span></strong><span class="koboSpan" id="kobo.1475.1">)</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.1476.1"> sockets. </span><span class="koboSpan" id="kobo.1476.2">They </span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.1477.1">extend the IPC data connectivity layer beyond the local machine via </span><span class="No-Break"><span class="koboSpan" id="kobo.1478.1">TCP/UDP networking.</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1479.1">Apart from the obvious implementation differences, the IPC socket’s and network socket’s data communication channels behave </span><span class="No-Break"><span class="koboSpan" id="kobo.1480.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.1481.1">Both sockets are configured as streams, support bidirectional communication, and emulate a client/server pattern. </span><span class="koboSpan" id="kobo.1481.2">The socket’s communication channel is active until it’s closed on</span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.1482.1"> either end, thereby breaking the </span><span class="No-Break"><span class="koboSpan" id="kobo.1483.1">IPC connection.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1484.1">Signals</span></strong><span class="koboSpan" id="kobo.1485.1">: In Linux, a signal is a one-way </span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.1486.1">asynchronous notification mechanism that’s used in response to a specific condition. </span><span class="koboSpan" id="kobo.1486.2">A signal can </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.1487.1">act in any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1488.1">following directions:</span></span><ul><li><span class="koboSpan" id="kobo.1489.1">From the Linux kernel to an </span><span class="No-Break"><span class="koboSpan" id="kobo.1490.1">arbitrary process</span></span></li><li><span class="koboSpan" id="kobo.1491.1">From process </span><span class="No-Break"><span class="koboSpan" id="kobo.1492.1">to process</span></span></li><li><span class="koboSpan" id="kobo.1493.1">From a process </span><span class="No-Break"><span class="koboSpan" id="kobo.1494.1">to itself</span></span></li></ul></li>
</ul>
<p><span class="koboSpan" id="kobo.1495.1">We mentioned at the beginning of this section that signals are yet another IPC mechanism. </span><span class="koboSpan" id="kobo.1495.2">Indeed, they are a somewhat limited form of IPC in the sense that through signals, processes can coordinate synchronization with each other. </span><span class="koboSpan" id="kobo.1495.3">But signals don’t carry any data payloads. </span><span class="koboSpan" id="kobo.1495.4">They simply notify processes about events, and processes may choose to take specific actions in response to </span><span class="No-Break"><span class="koboSpan" id="kobo.1496.1">these events.</span></span></p>
<p><span class="koboSpan" id="kobo.1497.1"> In the next section, we will detail working with signals </span><span class="No-Break"><span class="koboSpan" id="kobo.1498.1">in Linux.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.1499.1">Working with signals</span></h2>
<p><span class="koboSpan" id="kobo.1500.1">Signals typically alert a Linux process about a specific event, such as a segmentation fault (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">SIGSEGV</span></strong><span class="koboSpan" id="kobo.1502.1">) that’s raised by the kernel or</span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.1503.1"> execution being interrupted (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1504.1">SIGINT</span></strong><span class="koboSpan" id="kobo.1505.1">) by the user pressing </span><em class="italic"><span class="koboSpan" id="kobo.1506.1">Ctrl</span></em><span class="koboSpan" id="kobo.1507.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.1508.1">C</span></em><span class="koboSpan" id="kobo.1509.1">. </span><span class="koboSpan" id="kobo.1509.2">In Linux, processes are controlled via signals. </span><span class="koboSpan" id="kobo.1509.3">The Linux kernel defines a few dozen signals. </span><span class="koboSpan" id="kobo.1509.4">Each signal has a corresponding non-zero positive </span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">integer value.</span></span></p>
<p><span class="koboSpan" id="kobo.1511.1">The following command lists all the signals that have been registered in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1512.1">Linux system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1513.1">
kill -l</span></pre> <p><span class="koboSpan" id="kobo.1514.1">The output of the preceding command can be seen back in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1515.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1516.1">.21</span></em><span class="koboSpan" id="kobo.1517.1">. </span><span class="koboSpan" id="kobo.1517.2">From the output, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1518.1">SIGHUP</span></strong><span class="koboSpan" id="kobo.1519.1">, for example, has a signal value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1520.1">1</span></strong><span class="koboSpan" id="kobo.1521.1">, and it’s invoked by a Terminal session to all its child processes when</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.1522.1"> it exits. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1524.1"> has a signal value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">9</span></strong><span class="koboSpan" id="kobo.1526.1"> and is most commonly used for terminating processes. </span><span class="koboSpan" id="kobo.1526.2">Processes can typically control how signals are handled, except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1528.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1529.1">9</span></strong><span class="koboSpan" id="kobo.1530.1">) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1531.1">SIGSTOP</span></strong><span class="koboSpan" id="kobo.1532.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1533.1">19</span></strong><span class="koboSpan" id="kobo.1534.1">), which always end or stop a </span><span class="No-Break"><span class="koboSpan" id="kobo.1535.1">process, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.1536.1">Processes handle signals in either of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1537.1">following fashions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1538.1">Perform the default action implied by the signal; for example, stop, terminate, core-dump a process, or </span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1">do nothing.</span></span></li>
<li><span class="koboSpan" id="kobo.1540.1">Perform a custom action (except for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1541.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1542.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">SIGSTOP</span></strong><span class="koboSpan" id="kobo.1544.1">). </span><span class="koboSpan" id="kobo.1544.2">In this case, the process catches the signal and handles it in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1545.1">specific way.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1546.1">When a program implements a custom handler for a signal, it usually defines a signal handler function that alters the execution of the process, </span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1548.1">When the signal is</span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.1549.1"> received, the process’ execution is interrupted at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1550.1">current instruction</span></span></li>
<li><span class="koboSpan" id="kobo.1551.1">The process’ execution immediately jumps to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1552.1">signal-handler function</span></span></li>
<li><span class="koboSpan" id="kobo.1553.1">The signal handler </span><span class="No-Break"><span class="koboSpan" id="kobo.1554.1">function runs</span></span></li>
<li><span class="koboSpan" id="kobo.1555.1">When the signal handler function exits, the process resumes execution, starting from the previously </span><span class="No-Break"><span class="koboSpan" id="kobo.1556.1">interrupted instruction</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1557.1">Here’s some brief terminology related </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">to signals:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1559.1">A signal is raised by the process that </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">generates it</span></span></li>
<li><span class="koboSpan" id="kobo.1561.1">A signal is caught by the process that </span><span class="No-Break"><span class="koboSpan" id="kobo.1562.1">handles it</span></span></li>
<li><span class="koboSpan" id="kobo.1563.1">A signal is ignored if the process has a corresponding </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">no-operation</span></strong><span class="koboSpan" id="kobo.1565.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">no-op</span></strong><span class="koboSpan" id="kobo.1567.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1568.1">NOOP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1569.1">) handler</span></span></li>
<li><span class="koboSpan" id="kobo.1570.1">A signal is handled if the process implements a specific action when the signal </span><span class="No-Break"><span class="koboSpan" id="kobo.1571.1">is caught</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1572.1">Out of all the signals, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1573.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1574.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1575.1">SIGSTOP</span></strong><span class="koboSpan" id="kobo.1576.1"> are the only ones that cannot be caught </span><span class="No-Break"><span class="koboSpan" id="kobo.1577.1">or ignored.</span></span></p>
<p><span class="koboSpan" id="kobo.1578.1">Let’s explore a few use cases for </span><span class="No-Break"><span class="koboSpan" id="kobo.1579.1">handling signals:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1580.1">When the kernel raises a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">SIGKILL</span></strong><span class="koboSpan" id="kobo.1582.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">SIGFPE</span></strong><span class="koboSpan" id="kobo.1584.1"> (floating-point exception), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">SIGSEGV</span></strong><span class="koboSpan" id="kobo.1586.1"> (segmentation fault), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">SIGTERM</span></strong><span class="koboSpan" id="kobo.1588.1">, or similar signals, typically, the process that receives the signal immediately </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.1589.1">terminates execution and may generate a core dump – the image of the process that’s used for </span><span class="No-Break"><span class="koboSpan" id="kobo.1590.1">debugging purposes.</span></span></li>
<li><span class="koboSpan" id="kobo.1591.1">When a user types </span><em class="italic"><span class="koboSpan" id="kobo.1592.1">Ctrl</span></em><span class="koboSpan" id="kobo.1593.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.1594.1">C</span></em><span class="koboSpan" id="kobo.1595.1"> – otherwise known as an </span><strong class="bold"><span class="koboSpan" id="kobo.1596.1">interrupt character</span></strong><span class="koboSpan" id="kobo.1597.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1598.1">INTR</span></strong><span class="koboSpan" id="kobo.1599.1">) – while a foreground process is</span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.1600.1"> running, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1601.1">SIGINT</span></strong><span class="koboSpan" id="kobo.1602.1"> signal is sent to the process. </span><span class="koboSpan" id="kobo.1602.2">The process will terminate unless the underlying program implements a special handler </span><span class="No-Break"><span class="koboSpan" id="kobo.1603.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">SIGINT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1605.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1606.1">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1607.1">kill</span></strong><span class="koboSpan" id="kobo.1608.1"> command, we can send a signal to any process based on its PID. </span><span class="koboSpan" id="kobo.1608.2">The following command sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1609.1">SIGHUP</span></strong><span class="koboSpan" id="kobo.1610.1"> signal to a Terminal session with a PID </span><span class="No-Break"><span class="koboSpan" id="kobo.1611.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">3741</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1613.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1614.1">kill -HUP 3741</span></strong></pre></li> </ul>
<p><span class="koboSpan" id="kobo.1615.1">In the preceding command, we can either specify the signal value (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">1</span></strong><span class="koboSpan" id="kobo.1617.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">SIGHUP</span></strong><span class="koboSpan" id="kobo.1619.1">) or just the signal name without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">SIG</span></strong><span class="koboSpan" id="kobo.1621.1"> prefix (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">HUP</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1623.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">SIGHUP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1625.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.1626.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.1627.1">killall</span></strong><span class="koboSpan" id="kobo.1628.1">, we can signal that multiple processes are running a specific command (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1629.1">test.sh</span></strong><span class="koboSpan" id="kobo.1630.1">). </span><span class="koboSpan" id="kobo.1630.2">The following command terminates all processes running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1631.1">test.sh</span></strong><span class="koboSpan" id="kobo.1632.1"> script and outputs the result to the console (via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1633.1">-</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">e</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1635.1"> option):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1636.1">killall -e -TERM test.sh</span></strong></pre> <p><span class="koboSpan" id="kobo.1637.1">The output of this command can be seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1638.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1639.1">.22</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1640.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1641.1">Linux processes and signals are a vast domain. </span><span class="koboSpan" id="kobo.1641.2">The information we’ve provided here is far from a comprehensive guide on the topic. </span><span class="koboSpan" id="kobo.1641.3">We hope that this short spin and hands-on approach to presenting some common use cases has inspired you to take on and possibly master more </span><span class="No-Break"><span class="koboSpan" id="kobo.1642.1">challenging issues.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.1643.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1644.1">A detailed study of Linux processes and daemons could be a major undertaking. </span><span class="koboSpan" id="kobo.1644.2">Where worthy volumes on the topic have admirably succeeded, a relatively brief chapter may pale in comparison. </span><span class="koboSpan" id="kobo.1644.3">Yet in this chapter, we tried to put on a real-world, down-to-earth, practical coat on everything we’ve considered to make up for our possible shortcomings in the abstract or </span><span class="No-Break"><span class="koboSpan" id="kobo.1645.1">scholarly realm.</span></span></p>
<p><span class="koboSpan" id="kobo.1646.1">At this point, we hope you are comfortable working with processes and daemons. </span><span class="koboSpan" id="kobo.1646.2">The skills you’ve gathered so far should include a relatively good grasp of process types and internals, with a reasonable understanding of process attributes and states. </span><span class="koboSpan" id="kobo.1646.3">Special attention has been paid to inter-process communication mechanisms, and signals in particular. </span><span class="koboSpan" id="kobo.1646.4">For each of these topics, we will take a more detailed approach in </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1647.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1648.1">. </span><span class="koboSpan" id="kobo.1648.2">For now, we consider the information we’ve provided to be sufficient for understanding how inter-process </span><span class="No-Break"><span class="koboSpan" id="kobo.1649.1">communication works.</span></span></p>
<p><span class="koboSpan" id="kobo.1650.1">The next chapter will take our journey further into working with Linux disks and filesystems. </span><span class="koboSpan" id="kobo.1650.2">We’ll explore the Linux storage, disk partitioning, and </span><strong class="bold"><span class="koboSpan" id="kobo.1651.1">Logical Volume Management</span></strong><span class="koboSpan" id="kobo.1652.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1653.1">LVM</span></strong><span class="koboSpan" id="kobo.1654.1">) concepts. </span><span class="koboSpan" id="kobo.1654.2">Rest assured that everything we’ve learned so far will be immediately put to good use in the chapters </span><span class="No-Break"><span class="koboSpan" id="kobo.1655.1">that follow.</span></span></p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.1656.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1657.1">If you managed to skim through some parts of this chapter, you might want to recap a few essential details about Linux processes </span><span class="No-Break"><span class="koboSpan" id="kobo.1658.1">and daemons:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1659.1">Think of a few process types. </span><span class="koboSpan" id="kobo.1659.2">How would they compare to </span><span class="No-Break"><span class="koboSpan" id="kobo.1660.1">each other?</span></span></li>
<li><span class="koboSpan" id="kobo.1661.1">Think of the anatomy of a process. </span><span class="koboSpan" id="kobo.1661.2">Can you come up with a few essential process attributes (or fields in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1662.1">ps</span></strong><span class="koboSpan" id="kobo.1663.1"> command-line output) that you may look for when </span><span class="No-Break"><span class="koboSpan" id="kobo.1664.1">inspecting processes?</span></span></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.1665.1">Hint</span></strong><span class="koboSpan" id="kobo.1666.1">: What would be relevant for you, except CPU, RAM, or disk usage, </span><span class="No-Break"><span class="koboSpan" id="kobo.1667.1">for example?</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1668.1">Can you think of a few process states and some of the dynamics or possible transitions </span><span class="No-Break"><span class="koboSpan" id="kobo.1669.1">between them?</span></span></li>
<li><span class="koboSpan" id="kobo.1670.1">If you are looking for a process that takes up most of the CPU on your system, how would </span><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">you proceed?</span></span></li>
<li><span class="koboSpan" id="kobo.1672.1">Can you write a simple script and make it a long-lived </span><span class="No-Break"><span class="koboSpan" id="kobo.1673.1">background process?</span></span></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.1674.1">Hint</span></strong><span class="koboSpan" id="kobo.1675.1">: Take a peek at </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1676.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1677.1">, where we will teach you how to create and use </span><span class="No-Break"><span class="koboSpan" id="kobo.1678.1">shell scripts.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.1679.1">Enumerate at least four process signals that you can think of. </span><span class="koboSpan" id="kobo.1679.2">When or how would those signals </span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">be invoked?</span></span></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.1681.1">Hint</span></strong><span class="koboSpan" id="kobo.1682.1">: Use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">kill -l</span></strong><span class="koboSpan" id="kobo.1684.1"> command. </span><span class="koboSpan" id="kobo.1684.2">For more information, read </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">the manual.</span></span></p>
<ol>
<li value="7"><span class="koboSpan" id="kobo.1686.1">Think of a couple of IPC mechanisms. </span><span class="koboSpan" id="kobo.1686.2">Try to come up with some pros and cons </span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">for them.</span></span></li>
</ol>
<p><strong class="bold"><span class="koboSpan" id="kobo.1688.1">Hint</span></strong><span class="koboSpan" id="kobo.1689.1">: The information in </span><a href="B19682_08.xhtml#_idTextAnchor164"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1690.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.1691.1"> could </span><span class="No-Break"><span class="koboSpan" id="kobo.1692.1">help you.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.1693.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1694.1">For more information about what was covered in this chapter, you can refer to the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1695.1">Packt titles:</span></span></p>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1696.1">Linux Administration Best Practices</span></em><span class="koboSpan" id="kobo.1697.1">, by Scott </span><span class="No-Break"><span class="koboSpan" id="kobo.1698.1">Alan Miller</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1699.1">Linux Service Management Made Easy with systemd</span></em><span class="koboSpan" id="kobo.1700.1">, by Donald </span><span class="No-Break"><span class="koboSpan" id="kobo.1701.1">A. </span><span class="koboSpan" id="kobo.1701.2">Tevault</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer157">
<h1 id="_idParaDest-107" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.1.1">Part 2:Advanced Linux Administration</span></h1>
<p><span class="koboSpan" id="kobo.2.1">In this second part, you will learn about advanced Linux system administration tasks, including working with disks and configuring networking, hardening Linux security, and system-specific troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and diagnostics.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19682_06.xhtml#_idTextAnchor124"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 6</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Working with Disks and Filesystems</span></em></li>
<li><a href="B19682_07.xhtml#_idTextAnchor139"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Networking with Linux</span></em></li>
<li><a href="B19682_08.xhtml#_idTextAnchor164"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.13.1">, </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Linux Shell Scripting</span></em></li>
<li><a href="B19682_09.xhtml#_idTextAnchor194"><em class="italic"><span class="koboSpan" id="kobo.15.1">Chapter 9</span></em></a><span class="koboSpan" id="kobo.16.1">, </span><em class="italic"><span class="koboSpan" id="kobo.17.1">Securing Linux</span></em></li>
<li><a href="B19682_10.xhtml#_idTextAnchor212"><em class="italic"><span class="koboSpan" id="kobo.18.1">Chapter 10</span></em></a><span class="koboSpan" id="kobo.19.1">, </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Disaster Recovery, Diagnostics, and Troubleshooting</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer158">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer159">
</div>
</div>
</body></html>