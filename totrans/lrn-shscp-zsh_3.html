<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Advanced Editing</h1></div></div></div><p>In this chapter, we are taking a step forward from basic zsh usage and diving into the more advanced features of the command line. We will be getting close and personal with the zsh line editor, understanding how it works and why zsh needs it's very own input editor. We will discover new ways of accessing and tapping into the shell's history and learn some new command line editing tricks in order to speed up most of our regular tasks and avoid repeating ourselves to boredom. Finally, we will discover that there's really no need to be limited to a single line of text while using zsh.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Zsh line editor</h1></div></div></div><p>In the previous chapter, <a class="indexterm" id="id94"/>we learned how to access the shell's history and how to use some special escape sequences in order to access its records. Nevertheless, we assumed that the only way for us to review previous history entries was by using the arrow-up and down keys on the keyboard and loop through them sequentially. Well, as you can imagine, it's time we got acquainted with another of zsh's great features: the zsh line editor.</p><p>Unlike other shells—I'm looking at you, Bash—zsh does not depend on GNU's <code class="literal">readline</code> library, rolling instead with its own version of a command line editor that boasts most of the bells and whistles you'd expect to find in a full-fledged application. The zsh line editor, or ZLE in short, allows you to define your own key bindings (a combination of key presses) and set of custom keymaps (collections of key bindings) in addition to extending predefined entries. ZLE is also a key module of zsh, and is present in any interactive shell you use. Luckily, zsh is smart enough to know when not to load ZLE, thus avoiding extra resources if ZLE is not required.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Getting to know ZLE</h2></div></div></div><p>By now, you <a class="indexterm" id="id95"/>have been using zsh long enough to notice that some things just seem odd; like when you press a key, say <em>PageUp</em>, you are bound to see some arcane glyphs, same as trying to use the <em>Ctrl</em> + left-arrow shortcut to move the cursor between words. As it stands, ZLE is the one in charge of knowing what these symbols mean and what behavior is linked to them, a task we need to set up via key bindings. We can even group our collection of keybinds under the same name and use different collections for altogether different purposes such as <em>Home</em> to move to the beginning of the line when editing commands or selecting the first entry when searching through history. But first, let's take advantage of what's already defined in a default installation of zsh and the vanilla ZLE.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Working with keymaps</h2></div></div></div><p>On its own, <a class="indexterm" id="id96"/>ZLE comes with some handy bindings in order to cater to Emacs and vi users, some of the most popular editors out there. ZLE supports both vi <em>insert</em> and <em>read</em> modes, but defaults to Emacs as this seems to be the most user-friendly mapping for new users. </p><p>You can access it at any time by typing <code class="literal">bindkey</code> <code class="literal">-e</code> in the command line. We will be using the Emacs keybinds<a class="indexterm" id="id97"/> throughout this book, but feel free to roll with the vi mode if you feel more comfortable with it. You can always go back to Emacs mode by typing <code class="literal">bindkey</code> <code class="literal">-e</code> into your terminal. Whatever you choose, keep in mind that ZLE works only in interactive shell sessions, and that you will need to add your different configuration entries and bindings to your <code class="literal">.zshrc</code> file as they will be needed to be set for each session.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Zsh relies on your environment variables <code class="literal">$EDITOR</code> and <code class="literal">$VISUAL</code> in order to guess—make an educated guess, that is—which keybind it will default ZLE to. However, note that names such as <code class="literal">vile</code>, which contain the string <code class="literal">vi</code>, will trigger the use of vi keymap. You can add your own safety net of sorts, simply by adding <code class="literal">bindkey -e</code> in your <code class="literal">.zshrc</code> file to avoid possible conflicts and explicitly setting the layout.</p></div></div><p>For example, in order to default each new session to the Emacs mode, open up your <code class="literal">.zshrc</code> and append the following line:</p><div><pre class="programlisting">
<strong>bindkey -e</strong>
</pre></div><p>Having a default set in your startup files does not mean you have to commit to it at all times though. You can switch between vi and Emacs modes respectively, simply by typing the following line:</p><div><pre class="programlisting">
<strong>% bindkey -e</strong>
</pre></div><p>or</p><div><pre class="programlisting">
<strong>% bindkey -v</strong>
</pre></div><p>By using the <code class="literal">e</code> or <code class="literal">v</code> options, you are telling <code class="literal">bindkey</code> to link the provided <code class="literal">emacs</code> or <code class="literal">viins</code> keymaps to <a class="indexterm" id="id98"/>the <code class="literal">main</code> alias, which in turn gets loaded by default during startup. If anything goes awry, <a class="indexterm" id="id99"/>ZLE will default to <code class="literal">.safe</code>, which is a very constrained mode that provides you with the bare essentials. In such cases, your best shot at jumping out of the frying pan is by typing things such as <code class="literal">bindkey -e</code> and pressing <em>return</em> in order to switch keybinds. As you might expect then, using <code class="literal">.safe</code> spells trouble with your configuration and thus, is a binding you really don't want to see that often.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>As vi users might expect, zsh provides two keymaps for vi: <code class="literal">viins</code> and <code class="literal">vicmd</code>. Be careful when tinkering with those though, as defaulting to <code class="literal">vicmd</code> will leave you without the ability to insert any kind of text.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Basic editing</h2></div></div></div><p>Now that we have set our default key mapping to Emacs, we can start discussing some of its more interesting features such as keyboard shortcuts that speed up your tasks.</p><p>The following table contains some useful <a class="indexterm" id="id100"/>Emacs mappings:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>A</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the cursor to the beginning of the line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>E</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the cursor to the end of the line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>W</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes the whole word backwards from the cursor location</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>B</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the cursor backwards one word</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>F</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Moves the cursor forward one word</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>D</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes a character (moves forward) / lists completions / logs out</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>U</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes the whole line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>K</em> </p>
</td><td style="text-align: left" valign="top">
<p>Kills (or deletes) until the end of the line</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>D</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes one word on the right of the cursor</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>Backspace</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Deletes one word on the right of the cursor</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>Y</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Yanks the last killed word</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>Y</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Switches the last yanked word</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>T</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Transposes two characters</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Esc</em> + <em>T</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Transposes two words</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>R</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Incremental search backwards</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<em>Ctrl</em> + <em>S</em>
</p>
</td><td style="text-align: left" valign="top">
<p>Incremental search forwards (automatically enables <code class="literal">NO_FLOW_CONTROL</code> option)</p>
</td></tr></tbody></table></div><div><div><h3 class="title"><a id="note21"/>Note</h3><p>Depending on your keyboard and input configuration, you could replace the <em>Esc</em> + button sequences with what is commonly known as the Meta key. This is usually mapped to the <em>Alt</em> key; however, we'll refer to these kinds of mappings with the <em>Esc</em> + sequences throughout this text, since they sport the same behavior and are arguably more portable.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Going back and forth with words</h3></div></div></div><p>The <em>Esc</em> + <em>B</em> and <em>Esc</em> + <em>F</em> bindings are tightly related to the <code class="literal">WORDCHARS</code> shell variable<a class="indexterm" id="id101"/>. This is zsh's way of knowing where any given word begins, although the definition of "word" might be rather peculiar for those coming from other shells. Particularly, the <code class="literal">WORDCHARS</code> shell variable defaults to… well, see it for yourself:</p><div><pre class="programlisting">
<strong>% echo $WORDCHARS</strong>
<strong>&gt; *?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;</strong>
</pre></div><p>See those symbols? These are also considered as part of any given word (besides alphanumeric characters, that is). What's important to keep in mind here is the rather bipolar behavior of the shell; a character is either part of a word, or it isn't. Keep this in mind when using sequences such as <em>Esc</em> + <em>B</em> or <em>Esc</em> + <em>F</em>, and remember you can always override the <code class="literal">WORDCHARS</code> definition in those rare occasions where it might be required.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>Yanking and transposing text</h3></div></div></div><p>You might have noticed the terms <em>yanking</em> and <em>transposing</em><a class="indexterm" id="id102"/> in the shortcuts table and immediately addressed your thoughts with a healthy dose of what? So let's expand a bit more on that.</p><p>Transposing (<em>Ctrl</em> + <em>T</em>) might be a fancy name, but rest assured its functionality is nowhere near as complicated to understand as it sounds. Put simply, transposing a character will swap its place with the one immediately following it on the right, making it march valiantly towards the end of the line, one place at a time. Once there, it'll only swap positions with the character immediately before it. This might be a bit confusing, so let's get going with an example as follows:</p><div><pre class="programlisting">
<strong>% echo bca</strong>
<strong>&gt; bca</strong>
</pre></div><p>That's not right. Let's edit our previous history entry:</p><div><pre class="programlisting">
<strong>% echo bca</strong>
</pre></div><p>Now move your prompt on top of <code class="literal">a</code>—the more straightforward way of doing this is by hitting the end-of-the line shortcut, <em>Ctrl</em> + <em>E</em>—and hit the transpose shortcut, <em>Ctrl</em> + <em>T</em>.</p><div><pre class="programlisting">
<strong>% echo bac</strong>
</pre></div><p>
<code class="literal">a</code> and <code class="literal">c</code> switched places. Progress! Now go back one char to the left, placing your cursor on top of <code class="literal">a</code> again and, again hit the transpose shortcut.</p><div><pre class="programlisting">
<strong>% echo abc</strong>
</pre></div><p>Success! As we'll see in <a class="link" href="ch05.html" title="Chapter 5. Completion">Chapter 5</a>, <em>Completion</em>, automatic completion will amend most of these silly mistakes; however, transposing comes in really handy on those occasions when you mistype things like parameter flags or URLs.</p><div><pre class="programlisting">
<strong>% git psuh origin master</strong>
</pre></div><p>A mistyped <code class="literal">git push</code> sentence can be easily fixed by simply navigating to <code class="literal">u</code> in <code class="literal">psuh</code> and hitting transpose.</p><div><pre class="programlisting">
<strong>% git push origin master</strong>
</pre></div><p>The same rules apply to the word transposing mechanism (<em>Esc</em> + <em>T</em>). The only difference, as you might have guessed already, is that it works with whole words instead of just chars.</p><p>As the old saying goes, actions speak louder than words, so the following is another example, this time by transposing words:</p><div><pre class="programlisting">
<strong>% echo 'world hello,'</strong>
</pre></div><p>Whoops! Got that completely backwards, time for some <em>Esc</em> + <em>T</em>. Put your prompt's cursor right on top of <code class="literal">hello</code> and hit the transpose shortcut.</p><div><pre class="programlisting">
<strong>% echo 'hello, world'</strong>
</pre></div><p>Sure enough, this will give the <em>Backspace</em> key a much-deserved vacation.</p><p>Yanking<a class="indexterm" id="id103"/> seems a bit harder to explain, but basically boils down to inserting a word you previously deleted by any of the kill shortcuts (<em>Ctrl</em> + <em>W</em>, <em>Ctrl</em> + <em>U</em>, <em>Ctrl</em> + <em>K</em>, <em>Esc</em> + <em>D</em>, <em>Esc</em> + <em>Backspace</em>). It works as follows:</p><p>Start typing your command.</p><div><pre class="programlisting">
<strong>% echo world hello</strong>
</pre></div><p>Realize you made a mistake, and kill the offending part. In this example, we use <em>Esc</em> + <em>Backspace</em> to delete the <code class="literal">hello</code> string.</p><div><pre class="programlisting">
<strong>% echo world _</strong>
</pre></div><p>Now move the cursor one word backwards, using the <em>Esc</em> + <em>B</em> bind.</p><div><pre class="programlisting">
<strong>% echo _world</strong>
</pre></div><p>And yank the <code class="literal">hello</code> string into the line by pressing <em>Ctrl</em> + <em>Y</em> (note that in this particular case, you will need to add an extra space between both the words and the <code class="literal">_</code> character is there to show where the prompt cursor should be).</p><div><pre class="programlisting">
<strong>% echo hello_world</strong>
</pre></div><p>After using the <em>Ctrl</em> + <em>Y</em> shortcut for yanking, you can call the <em>Esc</em> + <em>Y</em> shortcut to swap between previously deleted words. The shell you see retains up to 10 deleted words in memory, in case you need to use them again. This sort of "deleted words clipboard" is popularly known as the kill ring due to its behavior—you will swap each of the killed words up to the last, and then start again from the very first by repeatedly pressing <em>Esc</em> + <em>Y</em>. However, note that pressing <em>Ctrl</em> + <em>Y</em> again will only insert a new previously yanked word.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Revisiting history</h2></div></div></div><p>As you might have noticed in the Emacs shortcuts table, there are quite a few shortcuts we can use to work with history. So let's put ZLE to better use and build on the <em>History expansion</em> section from <a class="link" href="ch02.html" title="Chapter 2. Alias and History">Chapter 2</a>, <em>Alias and History</em>, with our newly learned bindings.</p><p>Turns out we can use <em>Esc</em> + <em>&lt;</em> to go to the very beginning of our history file, that is, the first entry of our log. Likewise, pressing <em>Esc</em> + <em>&gt;</em> will deliver us to the end of the history file. However, that's hardly convenient for larger history logs<a class="indexterm" id="id104"/>. What we really need is to perform an incremental search. <em>Ctrl</em> + <em>R</em> is the default provided mechanism in zsh<a class="indexterm" id="id105"/>, and this will show us a prompt in which we can type to use as an immediate search filter. The more you type, the more precise the match is.</p><div><pre class="programlisting">
<strong>% # press Ctrl + R</strong>
<strong>bck-i-search: _</strong>
</pre></div><p>Start typing and once you have found the history entry you were looking for, you can either go ahead and press <em>return</em> to execute it, or the left-arrow/right-arrow key to edit the selected entry. You can exit this mode at any time by pressing <em>Ctrl</em> + <em>G</em>.</p><div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>The incremental search mode has its own keymap, conveniently called <code class="literal">isearch</code>.</p></div></div><p>It's very likely<a class="indexterm" id="id106"/> that your terminal is set to use the <em>Ctrl</em> + <em>Q</em> and <em>Ctrl</em> + <em>S</em> combinations for flow control, respectively stopping and resuming any output to the terminal. In order to avoid overlapping the default <code class="literal">history-search-forward</code> binding (also <em>Ctrl</em> + <em>S</em>), zsh offers the <code class="literal">NO_FLOW_CONTROL</code> option, which can be set in your startup files.</p><div><pre class="programlisting">
<strong>setopt NO_FLOW_CONTROL</strong>
</pre></div><p>This will safely disable such behavior within the shell (other programs can depend on flow control normally) and thus, is the recommended way of using <em>Ctrl</em> + <em>S</em>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Advanced editing</h1></div></div></div><p>So far we<a class="indexterm" id="id107"/> have <a class="indexterm" id="id108"/>discovered our way around the command line and started to get the hang of ZLE. It's time we kick it up a notch though, so we can see what the line editor is really capable of.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>ZLE-related options</h2></div></div></div><p>This chapter <a class="indexterm" id="id109"/>wouldn't be complete without some options<a class="indexterm" id="id110"/> for us to tinker with now, would it? The following are some things to try if you are looking to modify ZLE's default behavior:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NO_BEEP</code>: This option skips beeping on errors.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OVERSTRIKE</code>: This defaults the editor to the insert mode. The way it works is that each new character replaces the one to the immediate right, instead of displacing it one position to the right as default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SINGLELINEZLE</code>: It turns off multiline editing. No, I'm not on drugs. This could be used as a reminder of darker times.</li></ul></div><p>Sprinkle some of these on your startup files (namely, <code class="literal">.zshrc</code>) and you'll be all set.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Defining your own keymaps</h2></div></div></div><p>Besides<a class="indexterm" id="id111"/> the Emacs and vi mode-setting options, the <code class="literal">bindkey</code> built-in allows you to create your own keymaps and alias them by using a couple of simple options. Namely, the <code class="literal">-N</code> flag will let you define a new keymap on the fly.</p><div><pre class="programlisting">
<strong>% bindkey -N newmap # this creates a keybind named 'newmap'</strong>
</pre></div><p>Or even create one based on an existing one.</p><div><pre class="programlisting">
<strong>% bindkey -N mycoolmap emacs # this creates a new keymap based off the existing 'emacs'</strong>
</pre></div><p>You can then alias your new keymap with the <code class="literal">-A</code> option by simply issuing the following command:</p><div><pre class="programlisting">
<strong>% bindkey -A mycoolmap mymacs # this creates an alias 'mymacs' for 'mycoolmap'</strong>
</pre></div><p>Creating the alias <code class="literal">mymacs</code> for the existing <code class="literal">mycoolmap</code> keybind<a class="indexterm" id="id112"/> will allow you to eventually use <code class="literal">bindkey -D mycoolmap</code> to delete it without the fear of losing your settings. Turns out that both aliases are treated as separate keybinds; thus, deleting one does not affect the other. This proves useful during the time you are experimenting with bindings and wish to start from scratch, or just wish to have a backup of sorts for when things go awry. Be careful when naming your aliases though, as any existing keybind will be immediately replaced by the new alias if their names are the same!</p><div><div><h3 class="title"><a id="note22"/>Note</h3><p>You should avoid naming your own keymaps starting with the dot <code class="literal">.</code> character as future editions of zsh might eventually ship with conflicting namespaces.</p></div></div><p>The <code class="literal">bindkey</code> command<a class="indexterm" id="id113"/> also has quite a few other options at its disposal. Of particular interest when populating your startup files are the listing options. Namely, <code class="literal">l</code> and <code class="literal">L</code> allow you to list the available keymaps in different formats. By typing <code class="literal">bindkey -l</code>, you can quickly have a look at the currently available keymaps, while issuing <code class="literal">bindkey -lL</code> will format the output as a series of the <code class="literal">bindkey</code> commands.</p><div><pre class="programlisting">
<strong>% bindkey -lL</strong>
<strong>&gt; bindkey -N command</strong>
<strong>  bindkey -N emacs</strong>
<strong>  bindkey -N isearch</strong>
<strong>  bindkey -N listscroll</strong>
<strong>  bindkey -A emacs main</strong>
<strong>  bindkey -N menuselect</strong>
<strong>  bindkey -N vicmd</strong>
<strong>  bindkey -N viins</strong>
</pre></div><p>You can also use this option in order to check if a particular keymap is a link:</p><div><pre class="programlisting">
<strong>% bindkey -lL mymacs</strong>
<strong>&gt; bindkey -A mycoolmap mymacs</strong>
</pre></div><p>This tells you that, <a class="indexterm" id="id114"/>as expected, <code class="literal">mymacs</code> is an alias for the <code class="literal">mycoolmap</code> keymap we defined earlier on. By using the <code class="literal">-lL</code> option to check the <code class="literal">main</code> alias, you have a practical way of determining the keymap currently in use.</p><div><pre class="programlisting">
<strong>% bindkey -lL main</strong>
<strong>&gt; bindkey -A emacs main</strong>
</pre></div><p>Finally, you can use the <code class="literal">-L</code> option to have a list of all your current bindings, including those of a built-in keymap, formatted in a way you can use within your scripts:</p><div><pre class="programlisting">
<strong>% bindkey -L</strong>
<strong>  bindkey "^@" set-mark-command</strong>
<strong>  bindkey "^A" beginning-of-line</strong>
<strong>  bindkey "^B" backward-char</strong>
<strong>  bindkey "^D" delete-char-or-list</strong>
<strong>  bindkey "^E" end-of-line</strong>
<strong>  bindkey "^F" forward-char</strong>
<strong>  bindkey "^G" send-break</strong>
<strong>  bindkey "^H" backward-delete-char</strong>
<strong>  # [...] large list of bindings omitted</strong>
<strong>  bindkey -R "\M-^@"-"\M-^?" self-insert</strong>
</pre></div><p>Just copy and paste the output into your startup files and you have the foundation for your custom keymap. It's just a matter of replacing the action or shortcut keys with something that better suits your needs, and you are done. Handy, isn't it?</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>You can use the <code class="literal">read</code> utility in order to figure out the actual escape sequence your terminal emulator is sending to the shell; just call <code class="literal">read</code> and then input the sequence you want to try out. For example, the following is what <em>Ctrl</em> + back-arrow is sending on my system:</p><div><pre class="programlisting">% read
&gt; ^[[1;5D</pre></div><p>Some keys such as <em>Backspace</em> might require you to use the <code class="literal">-k</code> option, which allows you to specify the number of characters to read. Used by itself, it'll default to one.</p><div><pre class="programlisting">% read -k</pre></div><p>Now (press <em>Backspace</em>.)</p><div><pre class="programlisting">^?
% # and you are back to the prompt</pre></div><p>Keep in mind that you can exit the <code class="literal">read</code> command at any time by pressing <em>Ctrl</em> + <em>C</em>.</p></div></div><p>Emacs users will find themselves at home with the <em>Esc</em> + <em>X</em> sequence. By pressing <em>Esc</em> followed by the <a class="indexterm" id="id115"/>key <em>X</em>, ZLE greets you with an <code class="literal">execute</code> prompt. You can then start typing in your commands and even use the <em>Tab</em> key for auto-completion help. For example:</p><div><pre class="programlisting">
<strong># type in "hello" and navigate to the beginning of the line (Ctrl + A) followed by Esc + X</strong>
<strong>% _hello</strong>
<strong>execute:</strong>
<strong># ZLE waits for your command, type `ca` and press Tab key:</strong>
<strong>% _hello</strong>
<strong>execute: ca</strong>

<strong>% _hello</strong>
<strong>execute: capitalize-word</strong>
<strong># now press return and watch how the command is applied</strong>

<strong>% Hello</strong>
</pre></div><p>The reason we used <em>Ctrl</em> + <em>A</em> is for the prompt to be at the beginning of the line, just before the rest of the string.</p><div><div><h3 class="title"><a id="tip25"/>Tip</h3><p>Remember that you can exit the <code class="literal">execute</code> prompt at any time by using the <em>Ctrl</em> + <em>G</em> sequence.</p></div></div><p>As the astute reader might have noticed, there are quite a few ways of achieving the same behavior, but that's partially missing the point of the <code class="literal">execute</code> sequence. It is there simply to allow you to do things you would normally not do (either because of an awkward shortcut or lack of muscle memory); execute it and its completion mechanism will make recalling commands a snap.</p><p>In the same vein as <code class="literal">execute</code>, <code class="literal">where-is</code>—which is unbound to any sequence by default—will show you how to perform any given command. Just call <code class="literal">execute</code>, type <code class="literal">where-is</code> (you can use Tab for completion just as before) and press <em>return</em>. This time you will be greeted with the <code class="literal">Where is:</code> prompt, where you can also use completion to list any command you are after. Press <em>return</em> for ZLE to show you the sequence bound to the said command. For example, we can use <code class="literal">where-is</code> to find an alternative shortcut to our <code class="literal">capitalize-word</code> example as follows:</p><div><pre class="programlisting">
<strong>% # enter where-is mode via Esc + X</strong>
<strong>&gt; Where is: capitalize-word</strong>
<strong>&gt; capitalize-word is on "^[C" "^[c"</strong>
</pre></div><p>Well, look at that. Turns out we can capitalize the word immediately after the prompt by using the <em>Esc</em> + <em>C</em> combination.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Don't call them widgets</h1></div></div></div><p>There comes a time in the life of any eager zsh learner to talk about widgets. It's time you and me had that talk already.</p><p>Ever wondered <a class="indexterm" id="id116"/>how all those keybindings and special actions are put together and work marvelously? Well, we have widgets to thank for that. See, zsh likes to delegate responsibilities whenever it can, and widgets are a prime example of that; instead of having to deal with handling every little action performed by key sequences (similar to those defined in your keymaps), zsh relies on widgets to do the actual work. Think of them as small functions designed to carry out a simple mission. I, on the other hand, like to think of them as those sneaky gnomes that make magic happen in the kitchen whenever I'm not around.</p><p>ZLE comes with quite a few built-in widgets, each boasting two names, a vanilla name and a hidden name, which is simply defined as the normal name and preceded by a dot <code class="literal">.</code> character. Hidden names are there just to signal that they can't be rebound to a different widget (thus creating a backup copy that's always available in case your keybind definitions go awry).</p><p>As you might have guessed, that's not the whole deal; widgets can be user-defined or defined by other modules (such as ZLE or the built-in FTP client, <code class="literal">zftp</code>).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Defining your own widgets</h2></div></div></div><p>Defining your own widgets doesn't get more complicated than calling <code class="literal">zle -N</code> with your widget's name on it.</p><div><pre class="programlisting">autoload -Uz tetris
zle -N tetris
bindkey '\et' tetris</pre></div><p>The previous example, a slight variation from one of the suggestions available at the zsh wiki site (<a class="ulink" href="http://zshwiki.org">http://zshwiki.org</a>), binds the <em>Esc</em> + <em>T</em> combination to the built-in tetris module, so you can spend those idle times on the command line a bit more entertained.</p><p>Let's go over it, line by line:</p><div><pre class="programlisting">autoload -Uz tetris</pre></div><p>This is the good<a class="indexterm" id="id117"/> old <code class="literal">autoload</code> module, which handles the loading of different modules and functions across the shell. In this particular case, we're importing the <code class="literal">tetris</code> module for later use.</p><div><pre class="programlisting">zle -N tetris</pre></div><p>This is where the magic actually happens; we're defining the new widget by calling ZLE with the <code class="literal">-N</code> option and telling it that the name for our new widget is <code class="literal">tetris</code>.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>Keep in mind that hidden names are special for widgets, so refrain from using names starting with a dot (<code class="literal">.)</code>.</p></div></div><p>We wrap up the definition simply by binding our newly defined widget to the <em>Esc</em> + <em>T</em> shortcut on the keyboard:</p><div><pre class="programlisting">bindkey '\et' <strong>tetris</strong>
</pre></div><p>Notice that the bold <strong>tetris</strong> call there refers to the widget we defined and not the actual <code class="literal">tetris</code> module.</p><p>Now, to actually see this in action, you'll have to either add it to your <code class="literal">.zshrc</code> file or save it as a separate file and source it from <code class="literal">.zshrc</code>, just as we've done before. So go ahead and save this as <code class="literal">.zsh_tetris</code> in your <code class="literal">$HOME</code> folder, and source it from <code class="literal">.zshrc</code> by adding the following line:</p><div><pre class="programlisting">source .zsh_tetris</pre></div><p>Now go ahead and type <em>Esc</em> + <em>T</em> to enjoy your new widget.</p><div><img alt="Defining your own widgets" src="img/2937OS_03_01.jpg"/><div><p>Just some Tetris. Yes, I'm rusty.</p></div></div><div><div><div><div><h3 class="title"><a id="ch03lvl4sec08"/>Special variables</h3></div></div></div><p>Some special <a class="indexterm" id="id118"/>variables that are available in ZLE should come in handy when defining your own widgets for editing and/or manipulating the command line.</p><p>The following list contains some of the most commonly used references:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CURSOR</code>: This is the current position of the cursor on the command line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">BUFFER</code>: This contains the current editing buffer and can span multiple lines.</li><li class="listitem" style="list-style-type: disc"><code class="literal">LBUFFER</code>/<code class="literal">RBUFFER</code>: These are the contents to the left and right of the current cursor, respectively. They too can span multiple lines.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PREBUFFER</code>: This contains the buffer already read when editing a continuation line.</li><li class="listitem" style="list-style-type: disc"><code class="literal">WIDGET</code>: This gives the name of the widget currently in use by the editor.</li></ul></div><p>By using these variables you can, for example, know precisely which character is currently under the cursor by simply using the <code class="literal">${BUFFER[CURSOR]}</code> expression. This might as well read as "the value of the <code class="literal">BUFFER</code> array for the <code class="literal">CURSOR</code> position" (remember, <code class="literal">CURSOR</code> is just a number that tells which column the prompt is at).</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Your first function</h2></div></div></div><p>You can <a class="indexterm" id="id119"/>achieve even more complex behavior by defining your own functions. Each time the widget is executed, it'll call the corresponding function. Let's kick it up a notch with our second widget.</p><p>For the following example, we'll work with a variant of the excellent <code class="literal">rationalize-dot</code> widget, as presented on the ZSH-LOVERS' manpage (<a class="ulink" href="http://grml.org/zsh/zsh-lovers.html">http://grml.org/zsh/zsh-lovers.html</a>):</p><div><pre class="programlisting">function rationalize-dot {
  if [[ $LBUFFER = *.. ]]; then
    LBUFFER+=/..
  else
    LBUFFER+=.
  fi
}
zle -N rationalize-dot
bindkey . rationalize-dot</pre></div><p>And now let's go ahead and go over it line by line.</p><p>Firstly, we're defining our own function here, called <code class="literal">rationalize-dot</code>. The way we declare a function is simply a matter of giving it a special name, followed by parentheses as follows:</p><div><pre class="programlisting">
<strong>my_function() {</strong>
    my_code
}</pre></div><p>The curly braces <code class="literal">{}</code> you see there are the delimiters of the function body; whatever lays between them is considered part of the function, just like the <code class="literal">my_code</code> stub in the preceding example.</p><p>Alternatively, you can also define functions using the reserved keyword <code class="literal">function</code> and using a slight variation of the previous syntax as follows:</p><div><pre class="programlisting">    function my_function {
        my_code
    }</pre></div><p>As you can see, we trade the parentheses for the preceding function keyword. Otherwise, both syntaxes represent the same thing and are interchangeable. So pick whatever floats your boat.</p><p>Likewise, calling a function doesn't get any more complicated than explicitly writing its name; <code class="literal">my_function</code>, in this particular case.</p><p>Back to <a class="indexterm" id="id120"/>the <code class="literal">rationalize-dot</code> example, the second line there is an <code class="literal">if</code> statement, the most basic control flow mechanism provided by the shell. When used in its full glory, an <code class="literal">if</code> statement will resemble the following:</p><div><pre class="programlisting">
<strong>if</strong> condition; then
    my_code
<strong>elif</strong> another_condition; then
    more_code
<strong>else</strong>
    even_more_code
<strong>fi</strong>
</pre></div><p>In its most basic form, <code class="literal">if</code> statements test for a Boolean condition, an expression or command that resolves as either true or false (or has an exit status to indicate this), and takes action accordingly. Whatever is not suitable for the first clause, the <code class="literal">else</code> part will gladly take care of as follows:</p><div><pre class="programlisting">
<strong>if</strong> condition; then
    do_a_barrel_roll
<strong>else</strong>
    echo "can't do it"
<strong>fi</strong>
</pre></div><div><div><h3 class="title"><a id="tip26"/>Tip</h3><p>Notice the <code class="literal">fi</code> at the end? Think of the first <code class="literal">if</code> as an opening brace <code class="literal">{</code> character, and the <code class="literal">fi</code> as the closing one <code class="literal">}</code>.</p></div></div><p>The previous sample will test the condition <code class="literal">condition</code>, if it evaluates to something that is true, our mock function will call the <code class="literal">do_a_barrel_roll</code> code. If <code class="literal">condition</code> is not true (what is popularly known as false), then the <code class="literal">else</code> block gets called, and dutifully issues an <code class="literal">echo "can't do it"</code> command.</p><p>The <code class="literal">elif</code> statement simply means "else, if" and is used to evaluate further conditions. You can add as many <code class="literal">elif</code> clauses as the options you have, but be careful when traversing down that road; neat code becomes wild spaghetti in a matter of keystrokes if not properly tamed.</p><p>In the <code class="literal">rationalize-dot</code> example, the <code class="literal">if</code> statement tests whether the <code class="literal">LBUFFER</code> variable matches the expression <code class="literal">*..</code>, which actually means "has the user typed anything followed by two periods?". If that's the case, then append a <code class="literal">/..</code> expression to the buffer variable. Otherwise, just let the <code class="literal">else</code> statement handle it.</p><p>As per the <code class="literal">else</code> block, it'll just add an actual period to the buffer:</p><div><pre class="programlisting">else
    LBUFFER+=.
fi</pre></div><p>This might<a class="indexterm" id="id121"/> not seem a logical decision at first, until we move into the following lines:</p><div><pre class="programlisting">zle -N rationalize-dot
<strong>bindkey .</strong> rationalize-dot</pre></div><p>The first one is the standard widget declaration we've seen before, but the binding immediately after it is what makes the <code class="literal">rationalize-dot</code> function require the <code class="literal">else</code> statement to add a period. As it's called on each dot press (the keybinding it's being assigned), this requires you to behave as an actual period key if the user hasn't typed anything yet.</p><p>As before, you can go ahead and add this to your <code class="literal">.zshrc</code> (or any other module that gets sourced by it) and take it out for a spin; just type <code class="literal">...</code> and see what happens after that third dot gets pressed.</p><p>As we'll see later in <a class="link" href="ch05.html" title="Chapter 5. Completion">Chapter 5</a>, <em>Completion</em>, you can also let the shell source functions automatically by extending or adding them to your <code class="literal">$fpath</code> variable.</p><p>This is particularly useful in combination with the <code class="literal">cd</code> command and an unhealthy dose of nested folders.</p><p>Want to go further? You'll find tons of predefined built-in widgets for customizing your keybindings in the <code class="literal">zshzle(1)</code> manpage's <em>STANDARD WIDGETS</em> section. Just type <code class="literal">man zshzle</code> to get started.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Working with regions</h1></div></div></div><p>Continuing the<a class="indexterm" id="id122"/> legacy of Emacs' inherited behavior, you can set regions in the command line by holding <em>Ctrl</em> and pressing the Space bar. This will trigger a region selection mechanism that you can expand with the arrow keys, which works just as if you were clicking and dragging your mouse to highlight text.</p><p>So, why bother with regions? You could, for example, mark a region via the <em>Ctrl</em> + Space bar sequence and then perform a command on top of it (similar to <code class="literal">capitalize-word</code> we saw earlier), or even mix-in the previously mentioned <code class="literal">execute-command</code> to call a function that has no keybind. Overall, these few niceties straight from Emacs give ZLE (and of course, zsh) the versatility to behave almost like a full-fledged editor.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Multiline editing</h2></div></div></div><p>At this point,<a class="indexterm" id="id123"/> it should be no surprise to learn that zsh is smart enough to notice when you aren't done with a line. Unlike most other shells though, zsh is also capable of suggesting what might be missing, or even allowing you to use multiple rows of lines for entering your commands. Unlike traditional continuation where you put a <code class="literal">\</code> character<a class="indexterm" id="id124"/> at the end of the line and press <em>return</em> to continue on the one immediately below, ZLE will greet you with the <code class="literal">$PS2</code> prompt and add more of context information.</p><p>On most flavors of Bourne-derived shells, you can use the following line:</p><div><pre class="programlisting">
<strong>% ls \</strong>
</pre></div><p>Press <em>return</em> (notice there is absolutely nothing after the <code class="literal">\</code> char).</p><div><pre class="programlisting">
<strong>&gt; -a</strong>
</pre></div><p>Press <em>return</em> again, and it'll work just like the <code class="literal">ls -a</code> command. Zsh will give you a bit more context as follows:</p><div><pre class="programlisting">
<strong>% echo " # press return immediately after the double quotes</strong>
<strong>dquote&gt; _</strong>
</pre></div><p>The <code class="literal">$PS2</code> prompt (the alternative/second prompt) is called in order to signal that the shell is waiting for the rest of the double-quote assignment. Go ahead and wrap it up as follows:</p><div><pre class="programlisting">
<strong>dquote&gt; $HOME" # press return here</strong>
<strong>&gt; /home/gfestari</strong>
</pre></div><p>There's more to multiline editing than alternative prompts though. You can use the <em>Esc</em> + <em>return</em> shortcut to add a new continuation line:</p><div><pre class="programlisting">
<strong>% echo hello world # press Esc + return</strong>
<strong>echo goodbye world</strong>
</pre></div><p>And press <em>return</em> to see both the lines execute sequentially, just as though it were a script. Keep in mind that you are not limited to just two lines and can add as many lines as you want.</p><p>This sorcery owes its powers to the <code class="literal">self-insert-unmeta</code> command, whose job consists simply of inserting a carriage return character into the line. So now you know that each time you press <em>Esc</em> + <em>return</em>, you are actually using a shortcut to the <code class="literal">self-insert-unmeta</code> command.</p><p>Besides the obvious "being different" feeling, what's really convenient about the <em>Esc</em> + <em>return</em> method is that you can move across lines as you please by using the arrow keys. To top it off, each multiline entry is treated as a whole line. Just press the up-arrow and you will see the block you previously typed come back to life for you to edit. While we are at it, I'd like you to meet the <code class="literal">push-line-or-edit</code> command, which allows you to convert a previously typed block of lines into a single block whenever you are on a continuation (otherwise it'll behave like a normal push-line command). It works more or less as follows:</p><p>Start entering your function in the command line, pressing <em>return</em> after the first <code class="literal">if</code> line:</p><div><pre class="programlisting">
<strong>% if [[ true = false ]]; then # press return here</strong>
<strong>then&gt; echo _</strong>
</pre></div><p>And stop right there. Realize you have made a terrible mistake with the condition clause of the <code class="literal">if</code> statement (apart from the extremely simple logic… but hey, this is an example). Unfortunately, <a class="indexterm" id="id125"/>you can't scroll back to the previous line with the up-arrow button as you have already pressed <em>return</em> and that would trigger the history search behavior, so what's next? Well, <code class="literal">push-line-or-edit</code>, of course. Hit <em>Esc</em> + <em>X</em> in order to execute a command, and type <code class="literal">push-line-or-edit</code> (you can use the <em>Tab</em> key for completion) and press <em>return</em>.</p><p>The prompt will change to a traditional one (ditching the <code class="literal">then&gt;</code> indicator from the continuation line), and you will have a new buffer filled with all your previously typed lines which, of course, you can edit at will as follows:</p><div><pre class="programlisting">
<strong>% if [[ true = false ]]; then</strong>
<strong>echo_</strong>
</pre></div><p>Seeing how much better a push-line <code class="literal">push-line-or-edit</code> is, it's of course advisable to bind it to the default <code class="literal">push-line</code> shortcut, either <code class="literal">^q</code> or <code class="literal">\eq</code>:</p><div><pre class="programlisting">
<strong>bindkey '^Q' push-line-or-edit</strong>
<strong>bindkey '\eQ' push-line-or-edit</strong>
</pre></div><p>And now you can either use the <em>Ctrl</em> + <em>Q</em> or <em>Esc</em> + <em>Q</em> shortcuts to edit a whole block as if it were a single line. As with the <code class="literal">history-search-forward</code> binding we saw earlier (which defaulted to <em>Ctrl</em> + <em>S</em>), <em>Ctrl</em> + <em>Q</em> will require the <code class="literal">NO_FLOW_CONTROL</code> option to be set so as not to conflict with the terminal driver's behavior.</p><p>This whole thing started with <code class="literal">push-line-or-edit</code>,<code class="literal"> </code>so it seems fair we got to discuss the actual <code class="literal">push-line</code> bit. This will be the default behavior when you are not on a continuation line. Just type your commands as usual, but do not press <em>return</em>:</p><div><pre class="programlisting">
<strong>% ls -a</strong>
</pre></div><p>Realize you are in the wrong directory, call our newly bound <code class="literal">push-line-or-edit</code> command via <em>Ctrl</em> + <em>Q</em>, and the prompt will be cleared for you as follows:</p><div><pre class="programlisting">
<strong># push-line-or-edit</strong>
<strong>% _</strong>
</pre></div><p>Now use <code class="literal">cd</code> to go to the folder you were trying to list, and watch the buffer come back to life:</p><div><pre class="programlisting">
<strong>% cd myfolder</strong>
<strong>myfolder % ls -a</strong>
</pre></div><p>As soon as you execute a line, the prompt gets populated with the line you were editing prior to calling <code class="literal">push-line</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Putting it all together</h2></div></div></div><p>As we saw earlier, a peculiar aspect of ZLE is that it has access to the shell's history, which of course means we can use some of the niceties we have learned in order to further improve how we work with it.</p><p>A neat way of taking advantage of the up/down arrow keys is via the <code class="literal">history-beginning-search</code> commands. We could define our own mappings in order to add some extra kick to the default behavior as follows:</p><div><pre class="programlisting">
<strong>bindkey '\e[A' history-beginning-search-backward</strong>
<strong>bindkey '\e[B' history-beginning-search-forward</strong>
</pre></div><p>Note that the <code class="literal">\e</code> escape sequence could also be replaced by <code class="literal">^[</code>, thus leaving the bindings as <code class="literal">^[[A</code> and <code class="literal">^[[B</code> respectively.</p><p>Now, if you have an empty prompt and press the up-arrow key, it'll work by retrieving the most recent entry in the history as usual. However, as soon as you type something and press the up arrow key, it'll autocomplete with your most recent entry that matches with what's typed.</p><p>As an example, type the following pressing <em>return</em> after each line:</p><div><pre class="programlisting">
<strong>% echo hello world</strong>
<strong>% ls</strong>
<strong>% echo bye world</strong>
</pre></div><p>Now go ahead and press the up-arrow key. The natural backwards-scrolling sequence should be as follows:</p><div><pre class="programlisting">
<strong>&gt; echo bye world</strong>
<strong>&gt; ls</strong>
<strong>&gt; echo hello world</strong>
</pre></div><p>Press <em>Ctrl</em> + <em>G</em> to exit the search mode. Now type <code class="literal">ec</code> and press the up arrow key:</p><div><pre class="programlisting">
<strong>% ec</strong>
<strong>&gt; echo bye world</strong>
</pre></div><p>This comes in really handy during those times when you forget about a line mid-sentence and don't want to perform a search or discard the current line. Just remember to add your bindings into your startup files if you want to keep these kinds of changes between sessions!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter we took a deep dive into what goes on between the prompt and the shell by the time you press <em>return</em>. We discovered some new tricks to work with history and tamed the default shortcuts by creating our own keymaps and bindings. As if this wasn't enough, you now know we are no longer limited to just working with one line, and that mistakes and distractions can easily be solved by a couple of keystrokes without us re-typing the whole line.</p><p>Okay, I'll admit it, we have been pretty busy in this chapter. So here's a chance to catch your breath while we go over everything we've covered in this sprint. What we have done is:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learned that zsh is made out of various modules, and got acquainted with ZLE</li><li class="listitem" style="list-style-type: disc">Used key maps for editing text and learned about various shortcuts to improve our productivity in the command line</li><li class="listitem" style="list-style-type: disc">Defined our own custom keymaps and worked with various regions and multiline prompts</li><li class="listitem" style="list-style-type: disc">Learned about widgets, special functions that carry out every little task in the editor</li><li class="listitem" style="list-style-type: disc">Written our first sample widgets to further extend the functionality of the editor and improve our shell experience</li><li class="listitem" style="list-style-type: disc">Learned about functions and control flow via the <code class="literal">if</code> statements</li><li class="listitem" style="list-style-type: disc">Finally, we learned that both modules and functions have special access to different parts of the shell, and we can do things such as hooking up ZLE widgets to keybindings in order to search the history.</li></ul></div><p>Not a bad day I'd say. Now, let's head into the next chapter, where we'll learn about Globbing and filename generation, another of those features where zsh really shines. If you thought you had learned how to type less with ZLE in this chapter, wait until you see braces and qualifiers in action. Keep those elbows greased and that confidence up though, as there's still much more waiting for us to right around the corner.</p></div></body></html>