- en: Chapter 2. Alias and History
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 别名与历史
- en: In this chapter, we'll expand on the basics of zsh while focusing on aliases,
    one of the most time-saving features available. We'll take a closer look at how
    aliases work and learn to replace long, boring commands with our own short versions
    and automate the whole process within the startup files. We'll then move on to
    brace expansion, in order to avoid typing extra keystrokes whenever we can. Instead
    of typing the same things over again, we'll learn how to work with zsh's history
    and history expansion mechanisms and incorporate these new features into our workflow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展 zsh 的基础知识，并重点介绍别名，这是最节省时间的功能之一。我们将仔细研究别名如何工作，学习如何用简短的版本替代冗长且无聊的命令，并在启动文件中自动化整个过程。接下来，我们将学习大括号展开，以便在可以避免时减少输入的按键。我们将学会如何使用
    zsh 的历史记录和历史展开机制，并将这些新功能融入到工作流中。
- en: Working with aliases
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用别名
- en: An *alias* is an alternative way of saying the same thing. Think of it as a
    nickname for your commands. Though, unlike the embarrassing nicknames that you
    might get after a party, the alias mechanism provided by your shell is a handy
    shortcut to a series of commands and options under a friendlier name. The whole
    point of an alias is to do more and, preferably, type less.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*别名* 是一种替代说法，表示同样的意思。可以把它看作是命令的昵称。尽管与聚会后可能获得的尴尬绰号不同，shell 提供的别名机制是一个快捷方式，可以用更友好的名称执行一系列命令和选项。别名的核心目的就是做得更多，*最好是输入更少*。'
- en: 'I bet I got your attention with that last "type less" part. Allow me to explain:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌我刚刚用那个“输入更少”部分吸引了你的注意。让我解释一下：
- en: 'The `ls` command lists a directory''s contents. A quick look at its manpage
    (`man ls`) tells us that there are quite a few options there:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 命令用于列出目录的内容。快速查看它的手册页（`man ls`）告诉我们，这里有不少选项：'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using aliases we can go ahead and do something like the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名，我们可以像下面这样操作：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'No spaces are allowed around the equals (`=`) sign. If the right-hand side
    of the assignment (that is, the part that comes after the equals) contains spaces
    or tabs, then make sure you use quotation marks around it as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 等号（`=`）两侧不允许有空格。如果赋值的右侧（即等号后面的部分）包含空格或制表符，请确保使用引号将其括起来，如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now guess what happens if you type `la`? Go ahead and try it. The shell reads
    your alias—`la` in this particular case—and expands it. The whole process is similar
    to looking up the meaning of a word in the dictionary. Although here, once it's
    been found, the meaning is executed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在猜猜如果你输入 `la` 会发生什么？试试看。Shell 会读取你的别名——在这个例子中是 `la`——并展开它。整个过程类似于查字典一样查找单词的含义。只不过在这里，一旦找到，意义就会被执行。
- en: 'We can do basically the same for the `-l` option:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对 `-l` 选项做类似的操作：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or even mix and match as shown in the following line:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，甚至可以像下面这样混合搭配：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That last snippet uses both the `l` and `a` flags together with `F`, meaning
    it behaves just the same as the `–la` switch, with the added option to format
    the output so as to easily tell files and folders apart.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段代码同时使用了 `l` 和 `a` 标志与 `F`，意味着它的行为与 `–la` 开关相同，但增加了一个格式化输出的选项，可以轻松区分文件和文件夹。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Aliases apply only to interactive shells. Your shell will disable all of your
    existing aliases if it's being run in the non-interactive mode. Keep this in mind
    when creating your scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 别名仅适用于交互式 shell。如果你的 shell 以非交互模式运行，它会禁用所有现有的别名。创建脚本时请牢记这一点。
- en: 'You have two ways of declaring an alias. The first one is straight from the
    command line, as we have been doing so far. This nets you an alias which you can
    use instantly; the downside is that changes are only present temporarily for the
    duration of your current session. Close your terminal emulator or log out of the
    system and it goes the way of the dodo. The basic syntax for declaring an alias
    is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种声明别名的方法。第一种是直接在命令行中声明，正如我们到目前为止所做的那样。这会创建一个可以立即使用的别名；但缺点是，修改的别名只会在当前会话期间有效。一旦关闭终端模拟器或注销系统，它就会消失。声明别名的基本语法如下：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use this approach for something you'll be typing a lot but won't come
    back to it later. Most of the time though, we'll need something a bit more resilient.
    Something we can use every time we work with the command line.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种方法来处理一些你会频繁输入但之后不会再用到的内容。不过，大多数时候，我们需要一些更加持久的东西。需要的是每次在使用命令行时都能用到的东西。
- en: Enter the startup files; if you recall from the previous chapter, startup files
    are read every time the shell starts, and its configuration is loaded for the
    current session. Kind of what the doctor recommended.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入启动文件；如果你还记得上一章的内容，启动文件会在每次 shell 启动时读取，并为当前会话加载配置。就像医生推荐的一样。
- en: 'Let''s open up your `.zshrc` then, and add the aliases we''ve been working
    on so far:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的`.zshrc`文件，并添加我们到目前为止所做的别名：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save your changes, `source` (or use its alias, the dot (`.`)) your file, and
    aliases will be set for you to use on every future session of the shell. Despite
    their different behavior, both the ways of alias declaration sport the same syntax.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改，`source`（或者使用它的别名点（`.`））你的文件，别名将在每次未来的 shell 会话中设置并可用。尽管它们的行为不同，所有的别名声明方法使用的语法是相同的。
- en: Quoting characters
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引号字符
- en: 'Any given character can be quoted by adding a `\` character in front of it.
    This is particularly useful when dealing with "special characters" which have
    an additional meaning, such as `$`, and even an actual `\` character. Take, for
    example, the following `echo` sentence:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定字符都可以通过在其前面加上反斜杠（`\`）字符来引用。这个方法在处理具有额外含义的“特殊字符”时特别有用，比如`$`，甚至是实际的`\`字符。举个例子，考虑以下`echo`语句：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The shell prompt indicates it''s waiting for a quote character to be (properly)
    closed. The problem here is that we did not properly escape the apostrophe on
    "that''s":'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: shell 提示符表示它在等待一个引号字符（正确）闭合。这里的问题是我们没有正确地转义“that's”中的撇号：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's all nice and working, but what happens when we have a great number of
    escaping to do?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，且工作正常，但当我们需要做大量转义时，会发生什么呢？
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Luckily, zsh provides the `RCQUOTES` option as a workaround, which allows you
    to use double single quotes (`''''`) for escaping:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，zsh 提供了`RCQUOTES`选项作为解决方法，它允许你使用双单引号（`''`）进行转义：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What about double quotes then? Well, these are truly special and out of the
    bunch, as they allow you to perform parameter and command substitution as we'll
    see in no time. What you have to remember when using double quotes is that either
    `"`, `\`, `$`, and `` ` `` characters need to be escaped with a backslash.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么双引号呢？嗯，这些确实很特别，跟其他字符不同，因为它们允许你进行参数和命令替换，正如我们很快会看到的那样。使用双引号时你需要记住，`"`、`\`、`$`和``
    ` ``这些字符需要用反斜杠转义。
- en: 'Let''s give double quotes a try:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试双引号：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, the `$HOME` environment variable gets replaced by
    the actual value (`/Users/gfestari`) when the `$` character is not quoted.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当`$`字符没有被引用时，`$HOME`环境变量会被实际值（`/Users/gfestari`）替换。
- en: 'You can also use backquote within double quotes for executing programs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在双引号内使用反引号来执行程序：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The shell will first execute `locate zshenv` as if it were any other command,
    and substitute its output within the parameters being passed to `echo`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: shell 会首先执行`locate zshenv`，就像执行任何其他命令一样，并将其输出替换到传递给`echo`的参数中。
- en: As you can see, you can work around single quotes' limitations for most day-to-day
    usage, and turn to double quotes, escape sequences, and parameter expansions whenever
    you have a particular need for doing so.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在大多数日常使用中绕过单引号的限制，转而使用双引号、转义序列和参数扩展，只要在特定情况下需要这样做。
- en: Single and double quoting aliases
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单引号和双引号的别名
- en: Single quotes (`'`) are required when using spaces on your alias assignments;
    nevertheless, it's generally advisable to use them regardless of the spaces on
    your right-hand side. Granted, this is a "just to be safe" approach, but trust
    me when I say it will save you from a couple of avoidable headaches when declaring
    your aliases.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在别名赋值中使用空格时，需要使用单引号（`'`）；然而，通常建议无论右侧是否有空格，都使用单引号。确实，这是一个“为了安全起见”的方法，但相信我，这会帮助你避免在声明别名时遇到一些不必要的麻烦。
- en: 'On the other hand, if you wish to use things such as environment variables
    or parameter substitution within your assignment expression (think of the prompt
    escape sequences we saw in the previous chapter), double quotes (`"`) are required
    instead. Imagine you wish to output the current user''s name with an alias. As
    we saw earlier, the direct way of accessing it is via the environment variable
    `$USERNAME`. The first thing that comes to mind then is to use the following alias:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你希望在赋值表达式中使用像环境变量或参数替换这样的内容（想想我们在上一章看到的提示符转义序列），则需要使用双引号（`"`）。假设你想使用别名输出当前用户的名字。如我们之前所见，直接访问的方法是通过环境变量`$USERNAME`。那时，第一个想到的就是使用以下别名：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, this won''t work with single quotes. The correct way of doing
    this is with double quotation marks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这在单引号中不起作用。正确的方法是使用双引号，示例如下：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Complex expressions with variables generally need to be quoted, we use single
    quotation marks for that. If your alias requires variables to be expanded before
    the alias is used, go with double quotes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 带有变量的复杂表达式通常需要用引号括起来，我们使用单引号来实现这一点。如果你的别名需要在使用之前扩展变量，则使用双引号。
- en: 'As you can see, the `alias` mechanism is indeed a nifty powerful feature. If
    used properly, it even allows you to reshape a command''s meaning:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`alias`机制确实是一个非常强大的功能。如果使用得当，它甚至可以让你重新定义命令的意义：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or its equivalent on OS X:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在OS X上使用其等效命令：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can define aliases from another alias. Following the preceding example,
    if you do the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从另一个别名中定义别名。按照之前的示例，如果你执行以下操作：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `la` alias will behave just as if you typed `ls --color=auto –a`, there's
    no need to type `--color=auto` again on your definition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`la`别名的行为就像你输入了`ls --color=auto -a`一样，你不需要在定义时再次输入`--color=auto`。'
- en: This alias alters the behavior of `ls` by calling it with the `color` flag every
    time you type it, instead of using its more vanilla version. While this comes
    in handy for this particular scenario, it can be really dangerous for commands
    such as `rm` if not used with caution.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个别名通过每次调用时添加`color`标志来改变`ls`的行为，而不是使用它的更普通版本。虽然这对于特定场景很有用，但如果在像`rm`这样的命令中使用时，若不小心，可能会带来非常危险的后果。
- en: 'For example, imagine what would happen if you aliased a force removal of files
    to `rm`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你将文件强制删除的操作别名为`rm`：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here you are forcing the deletion of files without a warning. What will happen
    is that someone, unknowingly, will execute the wrong command and end up bashing
    their heads on the keyboard after a mistaken deletion. The takeaway message here
    is that the further you stay from overriding an existing command with your "l33t
    alias", the better. Think of all those broken keyboards. Don't be that guy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在强制删除文件而没有任何警告。结果是，有人可能在不知情的情况下执行了错误的命令，导致误删后碰撞键盘。这里的重点是，越是避免用你的“l33t别名”覆盖现有命令，越好。想想那些被砸坏的键盘，别做那个人。
- en: 'So, what if you don''t know whether you are bypassing any of the aliases''
    current set for your session? Well, there''s a command for that. Typing `alias`
    will list all the aliases for the current session:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你不确定自己是否绕过了当前会话中的任何别名设置怎么办？别担心，有一个命令可以查看。输入`alias`会列出当前会话中的所有别名：
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also get the information for a particular alias simply by specifying
    its name, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过简单地指定别名的名称来获取该别名的信息，示例如下：
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And you can disable, albeit temporarily, any existing alias by typing:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令来禁用任何现有的别名，尽管是暂时禁用：
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Simply replace `aliasname` with the name of the alias you want to turn off.
    This comes in really handy on those occasions when you're using a particularly
    strict program whose options, or even command-line syntax, is overridden by an
    alias.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将`aliasname`替换为你希望关闭的别名的名称。当你在使用某些特别严格的程序时，别名的选项，甚至是命令行语法，都可能会被覆盖，这时这个功能就非常有用了。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There are a few ways by which you can prevent the shell from executing an alias
    that is called just as another command. Single-quoted commands and commands prepended
    with a backslash (`\`) as well as those typed as relative or absolute paths are
    not treated as aliases by the shell.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方法可以防止shell执行仅作为其他命令调用的别名。单引号括起来的命令和以反斜杠（`\`）开头的命令，以及作为相对路径或绝对路径输入的命令，都不会被shell视为别名。
- en: 'For example, you could use either of the following if you wish to avoid a call
    to an alias:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望避免调用别名，可以使用以下任意一种方式：
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'or even:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以这样：
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Zsh also has `command` that will execute any argument as an external command
    instead of as a function or built in. Thus, you can also use it to avoid aliases.
    That would leave us with the following for the preceding example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Zsh还提供了`command`，它会将任何参数作为外部命令执行，而不是作为函数或内置命令。因此，你也可以使用它来避免使用别名。这将让我们得到如下的示例：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can get more information via `man zshbuiltins`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`man zshbuiltins`获取更多信息。
- en: 'As with many other things we''ll be discovering throughout this book, an alias
    is not a golden hammer and as such, you shouldn''t be aliasing willy-nilly throughout
    your terminal sessions. Here are a few simple considerations to keep in mind before
    you embark into your less-typing adventure with your pack o''aliases:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 和本书中许多其他内容一样，别名并不是万金油，因此，你不应该在终端会话中乱用别名。在你踏上“少输入”冒险之旅之前，以下是几个简单的考虑因素：
- en: Is my alias easier to remember? `echo -n` is way simpler than aliasing something
    like `echodontprinttrail`. Keep it simple, don't use aliases for the sake of it.
    The "Future You" will be really thankful two months from now.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的别名更容易记住吗？`echo -n`比类似`echodontprinttrail`的别名要简单得多。保持简单，不要为了别名而设置别名。两个月后，“未来的你”会非常感激。
- en: 'Is my alias easier to type? An awkward alias is an awful alias. Using `alias
    grepcola=''grep --color=auto''` instead of a simpler `grep`, really? Remember:
    clear, concise names are awesome, but something you can''t remember for the life
    of `ping` is not cool.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的别名更容易输入吗？一个别名如果让人觉得尴尬，那就是个糟糕的别名。比如用`alias grepcola='grep --color=auto'`替代一个简单的`grep`，真的吗？记住：简洁明了的名字很棒，但如果你连`ping`都记不住的名字就不酷了。
- en: Is my alias overriding some behavior just for the sake of it? Think of the previous
    `rm -f` example. Most of the time we would like to stay away from something like
    that; however, prompting the user each time seems like a sensible feature to add
    to our toolbox. Aliasing `rm='rm -i'` so the shell requires confirmation before
    deleting something seems a bit... nicer. Be careful with these kinds of tricks
    though, as relying too much on such an alias could lead to a false sense of security.
    That is, imagine what would happen if you get used to `rm` constantly waiting
    for confirmation and eventually use it recklessly on a different environment?
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的别名是否仅仅为了某种原因覆盖了一些行为？想想之前的`rm -f`例子。大多数时候我们希望避免类似的情况；然而，每次都提示用户似乎是一个值得添加到工具箱中的合理功能。将`rm='rm
    -i'`别名化，使得删除文件前需要确认，似乎更...好一些。不过要小心这些技巧，过度依赖这种别名可能会导致错误的安全感。试想，如果你习惯了`rm`总是等待确认，然后在不同的环境中不加思索地使用它会怎样？
- en: Global aliases
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局别名
- en: If you enjoyed the simplicity aliases brought to the table, then global aliases
    are the icing on the cake. As the name implies, *global aliases* are, well, aliases
    that can be used anywhere, allowing you to treat filters or certain commands as
    a simple suffix.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢别名带来的简便，那么全局别名就是锦上添花。顾名思义，*全局别名*就是可以在任何地方使用的别名，允许你将过滤器或某些命令作为简单的后缀处理。
- en: 'Let''s see some examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Pay particular attention to the `-g` option, as in a global alias.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意`-g`选项，它代表全局别名。
- en: 'Now you can append the `less` pager to any command''s output, just by adding
    the `L` suffix:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过添加`L`后缀将`less`分页器附加到任何命令的输出中：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another option that is frequently spotted in the wild is redirecting standard
    error (`stderr`) and standard output (`stdout`) to `/dev/null`, so any given command
    can run silently:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在实际中经常看到的做法是将标准错误输出（`stderr`）和标准输出（`stdout`）重定向到`/dev/null`，这样任何给定的命令都可以静默运行：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will allow you to call things such as `command NUL` without the need to
    pollute your current terminal window with thousands of log lines and messages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以调用类似`command NUL`的命令，而不需要让当前终端窗口充斥着成千上万的日志和信息。
- en: Just for the sake of clarity, never mind sticking to standards, it's advisable
    for you to try and define your global aliases just like your global variables,
    all in caps.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，别管是否符合标准，建议你像定义全局变量一样定义全局别名，全部使用大写字母。
- en: Hashes
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希
- en: 'You can use a hash to give a particular directory an alias. This is particularly
    convenient for your workspace:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用哈希给特定目录设置别名。这对于你的工作空间尤其方便：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I don't want to type `/Users/gfestari/workspace/go` each time I want to reach
    the `src` folder in my `$GOPATH` directory. So how about putting hash to a good
    use?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想每次都输入`/Users/gfestari/workspace/go`来访问`$GOPATH`目录中的`src`文件夹。那么，为什么不利用哈希呢？
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And now we can get there as quick as typing `cd ~gosrc` (pay attention to the
    leading `~` character).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像输入`cd ~gosrc`一样快速到达目的地（注意前导的`~`字符）。
- en: 'Here''s another example, this time using the `/var/www` directory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子，这次使用`/var/www`目录：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can go ahead and hash your most frequently visited directories. Just remember
    to add the required entries to your `.zshrc`, so you don't have to type the same
    thing over and over again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始为您最常访问的目录生成哈希值。只需记得将必要的条目添加到您的`.zshrc`中，这样您就不必反复输入相同的内容。
- en: 'For bonus points, set the `AUTO_CD` option, so you only need to input the directory''s
    name whenever you want to change the working directories:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 额外奖励：设置`AUTO_CD`选项，这样当您想要切换工作目录时，只需输入目录名称即可：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now go ahead and start showing off with your acquaintances, I'll wait here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，去展示给您的朋友们看吧，我会在这里等着。
- en: Putting it all together
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切结合起来
- en: Before we move on to the next topic, here's a couple of things to try with our
    newly found aliases.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一个话题之前，这里有一些事情可以尝试使用我们新发现的别名。
- en: Raise your hand if you found yourself typing `cd ..` more than a few times on
    a terminal session. I know, I feel your pain. How about making it simpler?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在终端会话中发现自己多次输入`cd ..`，请举手。我知道，我能感同身受。那我们来简化一下吧？
- en: 'We could try the following instead:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试以下方法：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now it''s just a matter of typing `.` to move your current working directory
    up one level`.` Not bad, uh? We can take it a bit further:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需输入`.`即可将当前工作目录向上移动一级`.` 不错吧？我们可以进一步优化：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: I'd argue that going more levels in for directory changing is pushing things
    a bit too far, but feel free to extend your aliases as you see fit.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，进行多级目录切换有些过于复杂，但可以根据需要扩展您的别名。
- en: 'What about creating directories? I bet that, like myself, more than once you
    saw the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，创建目录呢？我敢打赌，像我一样，您不止一次看到过以下情况：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This happens because `dir1` doesn''t exist. So what we do is—you guessed it—create
    an alias that allows us to automatically create the *parent* directory and also,
    be more verbose (as in, "list directories as they are created") about the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`dir1`不存在。所以我们做的是——你猜对了——创建一个别名，让我们能够自动创建*父*目录，并且更详细地（即，“在创建目录时列出目录”）显示输出：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now try to issue `mkdir dir1/dir2` and see what happens. You can also apply
    the same switch to commands such as `cp` and `mv`, just remember to quote your
    assignments!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试执行`mkdir dir1/dir2`并观察会发生什么。您也可以将相同的开关应用于`cp`和`mv`等命令，只需记得引用您的赋值！
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use the `COMPLETE_ALIASES` option in your startup files in order to
    force the shell to treat aliases as a distinct command for completion purposes.
    In other words, the alias won't get substituted before attempting completion.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在启动文件中使用`COMPLETE_ALIASES`选项，以强制 shell 将别名视为独立的命令进行补全。换句话说，别名不会在尝试补全之前被替换。
- en: Expansion
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: The shell allows you to perform different types of manipulations right before
    executing a line. In the following section we'll learn how to take advantage of
    each of the different forms of expansion and substitution available in zsh.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 允许您在执行一行命令之前进行不同类型的操作。在接下来的部分中，我们将学习如何利用 zsh 中的各种扩展和替换形式。
- en: Parameter expansion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数扩展
- en: 'Parameter expansion allows you to replace known variables in between the assignments
    of the command line. Simply put, parameter substitution is the mechanism by which
    the shell can change the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 参数扩展允许您在命令行的赋值过程中替换已知的变量。简单来说，参数替换是 shell 用来更改以下内容的机制：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It will be changed to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被更改为以下内容：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how the variable `foo` we declared in the previous line is replaced inside
    the arguments of `echo` with its actual value. You should be paying special attention
    to that peculiar `${}` construction. What happens is that when zsh reads the `${foo}`
    construction, it immediately knows it has to replace what's in it with whatever
    value it holds.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在前一行声明的变量`foo`被替换为`echo`参数中的实际值。您应该特别关注这个特殊的`${}`结构。发生的情况是，当 zsh 读取`${foo}`结构时，它立即知道要用它所持有的值替换其中的内容。
- en: The astute reader might also have taken notice of the double quotes that surround
    the `echo` arguments. It's important to remember that just like aliases and prompt
    sequences, parameter substitution will work for arguments passed between double
    quotes, just like every other variable out there.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能已经注意到围绕`echo`参数的双引号。重要的是要记住，就像别名和提示序列一样，参数替换对于传递给双引号中的参数有效，就像处理其他任何变量一样。
- en: Command substitution
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令替换
- en: Like parameter expansion, command substitution allows the shell to execute a
    command call and replace its output within a specially formed syntax. Command
    substitution usually takes the form of `` `command` ``, a program name wrapped
    around back quotes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像参数扩展一样，命令替换允许 shell 执行命令并将其输出替换到特殊的语法中。命令替换通常采取`` `command` ``的形式，即一个被反引号包围的程序名。
- en: There's another form of program substitution available in newer shells such
    as zsh, which takes the form of `$(command)`. Both forms of substitution, [PRE38]
    and `$()`, mean the same; however, back quotes are considered a bit more portable,
    as they are recognized on pretty much every other shell out there.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 zsh 这样的更新版 shell 中，还有另一种形式的程序替换，它的形式为`$(command)`。这两种替换形式，[PRE38]和`$()`，是一样的；不过，反引号被认为更加便携，因为几乎所有的
    shell 都能识别它们。
- en: 'In the wild, command substitution is frequently used to find out the full path
    to a command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际使用中，命令替换通常用于查找命令的完整路径：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Or, to make it more portable:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了让它更加便携：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Arithmetic expansion
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术扩展
- en: Don't let the name discourage you; just like parameter substitution, arithmetic
    expansion is yet another form of substitution to help us sail swiftly across the
    command line. As its name implies, you can expand your input into a series of
    elements that will otherwise require you to type a lot.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被名字吓倒；就像参数替换一样，算术扩展是另一种替换形式，帮助我们快速穿越命令行。顾名思义，你可以将输入扩展成一系列元素，否则你需要输入很多内容。
- en: 'Let''s try it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We started with some rather simple arithmetic expression (I know, I know; Math).
    But fret not, what just happened can be easily explained. We already know `echo`
    prints information into the standard output, so there are no mysteries there.
    What follows it is just an arithmetic expression using the `$(( ))` construct.
    Notice that, unlike parameter substitution, this kind of arithmetic substitution
    requires an extra set of parentheses. This is our way of letting zsh know that
    it needs to work with numbers, and that's why our `5 + 4` is treated as such.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一些相当简单的算术表达式开始（我知道，我知道；数学）。但是别担心，刚才发生的事情可以很容易地解释。我们已经知道，`echo`会将信息打印到标准输出，所以没有什么神秘的地方。接下来是一个使用`$((
    ))`构造的算术表达式。注意，与参数替换不同，这种算术替换需要额外一对括号。这是我们告诉 zsh 它需要处理数字的方式，这就是为什么我们的`5 + 4`会被当作算术运算来处理。
- en: 'The same rules apply to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下情况适用相同的规则：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Which leads us to realize we need more parentheses for operator precedence:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们意识到，我们需要更多的括号来设置运算符优先级：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Remember, the `$(( ))` construct is just a special construct, it's what tells
    zsh to treat what resides inside as arithmetic expressions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`$(( ))`构造只是一个特殊的构造，它告诉 zsh 将其内部的内容作为算术表达式来处理。
- en: 'Interestingly, we can invite parameter substitution to this party too. Looks
    like variables can also be substituted inside arithmetic expressions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们也可以邀请参数替换加入这个“派对”。看起来变量也可以在算术表达式中进行替换：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding snippet, we declare a variable to hold our `5 + 4` expression;
    this makes `num` a container that, when asked what''s up, will yell out our `5
    + 4` expression. An easy way to check this is:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个变量来保存我们的`5 + 4`表达式；这使得`num`成为一个容器，当询问它时，它会大喊出我们的`5 + 4`表达式。验证这一点的一个简单方法是：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note however, that by using `num` in the expression we did not require an extra
    set of parentheses in order to set operator precedence. This is because our `num`
    variable gets replaced on the following line with its value, which leaves us with
    an expression equivalent to `(5 + 4) * 3`. Expressions get evaluated before they
    are replaced, otherwise the result of the preceding call would have been `17`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而请注意，通过在表达式中使用`num`，我们不需要额外的一对括号来设置运算符优先级。这是因为我们的`num`变量在下一行被替换成它的值，最终我们得到的表达式等同于`(5
    + 4) * 3`。表达式在替换之前会被先计算，否则前一个调用的结果将是`17`。
- en: 'Let''s kick it up a notch with another handy arithmetic substitution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再加一把火，使用另一个实用的算术替换：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On this opportunity, we are leaving the `num` expression as something that
    resembles "add whatever follows to it". This is why when it is evaluated on the
    next line, it gets replaced for what you''d expect, in this case `5 +`. See that
    `$` right before the `num` variable? Remember parameter substitution from the
    beginning of this section? That''s what''s going on here. Without that `$num`
    there, zsh simply does not know how to deal with the `num` assignment:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将 `num` 表达式保留下来，类似于“将后续内容添加到其中”。这就是为什么在下一行进行求值时，它会被替换为你预期的内容，在这个例子中是
    `5 +`。你看到 `num` 变量前面的那个 `$` 吗？还记得本节开头提到的参数替换吗？这就是发生的情况。如果没有 `$num`，zsh 就无法处理 `num`
    赋值。
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Remember, if you wish to substitute a parameter, use `$`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你想替换一个参数，请使用 `$`：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can always have a look at all supported types of expansions by typing `man
    zshexpn` on your console.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以通过在控制台中输入 `man zshexpn` 来查看所有支持的扩展类型。
- en: Brace expansion
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花括号扩展
- en: 'Another useful type of expansion is known as brace expansion. As the name implies,
    its syntax has to do with the use of curly braces (`{}`)—I suppose "curly brace
    expansion" was a bit too verbose when they were picking a name for it. Brace expansion
    allows you to declare an array of entries as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有用的扩展类型叫做花括号扩展。顾名思义，它的语法涉及使用花括号（`{}`）——我猜“花括号扩展”在命名时有点过于冗长了。花括号扩展允许你像下面这样声明一个条目的数组：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'What happens then is that the `{eg,g}` construct gets expanded into an array
    containing the elements `eg` and `g`. The shell then loops through those elements,
    passing two arguments to the `echo` command, which basically has the same meaning
    as typing the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，`{eg,g}` 结构被扩展为一个包含元素 `eg` 和 `g` 的数组。Shell 然后循环遍历这些元素，将两个参数传递给 `echo`
    命令，这基本上等同于输入以下内容：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But you saved yourself from quite a few keystrokes and the accompanying boredom.
    Let''s try another example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你节省了不少按键和伴随而来的无聊。让我们试试另一个例子：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This time we are creating simple logfiles with the pattern `log_00<num>.txt`.
    The shell expands the `{1,2,3}` element into the elements `1`, `2`, and `3`, and
    then calls the `touch` command three times:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们创建简单的日志文件，模式为 `log_00<num>.txt`。Shell 会将 `{1,2,3}` 元素扩展为 `1`、`2` 和 `3`，然后调用
    `touch` 命令三次：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In case you didn''t notice, we use commas (`,`) in order to declare each of
    the elements inside curly braces. Now, you might be thinking "what happens when
    we use a longer array?" Here''s when it gets even more interesting; declare a
    range of values:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没注意到，我们使用了逗号（`,`）来声明大括号内的每个元素。现在，你可能会想，“如果我们使用更长的数组会怎样？”这就变得更加有趣了；声明一个值的范围：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It's worth noting a couple of things going on with the preceding example. I
    took the liberty to format the output of the list. But that (`…`) implies files
    `007` to `011` do exist. Firstly, we are now using brace expansion to extend a
    range, this time from nine up to eleven. The next thing that's also worth mentioning
    is that zsh is smart enough to notice the leading zeros and use it as a padding
    for the other values instead of replacing them with, say, vanilla integers. That
    is why you see the sequence starting with `log_007.nfo` and ending with `log_011.nfo`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，前面的例子有几个要点。我自行格式化了输出的列表。但那个（`…`）意味着文件 `007` 到 `011` 确实存在。首先，我们现在使用花括号扩展来扩展一个范围，这次是从九到十一。接下来值得一提的是，zsh
    足够聪明，能够注意到前导零并将其用作其他值的填充，而不是将它们替换为普通的整数。这就是为什么你看到序列从 `log_007.nfo` 开始，直到 `log_011.nfo`
    结束。
- en: On the second line, we use a pipe symbol (`|`) to link or redirect output between
    different commands on your shell. This way we are listing the contents of the
    file, and redirecting the output into the utility `grep`, so we can filter said
    output by the `.nfo` extension.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们使用管道符号（`|`）将不同命令之间的输出连接或重定向。这种方式我们列出了文件的内容，并将输出重定向到 `grep` 工具，以便通过 `.nfo`
    扩展名过滤该输出。
- en: 'Arrays can get even more interesting when we sparkle a bit more math in them:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在数组中加入一些数学运算时，它们会变得更加有趣：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding snippet, we declare two arrays, one containing the elements
    `A`, `B`, and `C`, and the other with the elements `1`, `2`, and `3`. The call
    to `echo` then passes the argument `${^foo}-${^bar}`. Notice the `^` operator
    (curly braces were implicit on the previous call, so I added them here for the
    sake of clarity). Again, we are telling zsh to expand the variables that come
    after the `$` character, only this time we get a **Cartesian product** instead
    of, say, `A B C-1 2 3`. This is because the `^` operator serves as the array expansion
    expression. So as far as zsh is concerned, we're using each element of the array
    independently.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了两个数组，一个包含元素`A`、`B`和`C`，另一个包含元素`1`、`2`和`3`。随后对`echo`命令的调用传递了参数`${^foo}-${^bar}`。注意`^`运算符（在前一个调用中大括号是隐式的，这里为了清晰起见我加上了它们）。再次强调，我们在告诉zsh扩展`$`后面的变量，不过这次我们得到的是**笛卡尔积**，而不是像`A
    B C-1 2 3`那样的结果。这是因为`^`运算符作为数组扩展表达式。因此，在zsh看来，我们在独立地使用数组中的每个元素。
- en: For a more detailed description of how array expansion and the `^` operator
    works, visit `man zshoptions` (particularly, the `RC_EXPAND_PARAM` section) and
    `man zshexpn`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组扩展和`^`运算符的更详细描述，请访问`man zshoptions`（特别是`RC_EXPAND_PARAM`部分）和`man zshexpn`。
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As with other sequences, some characters are considered "special" and need
    to be escaped. Commas and single quotes need to be escaped with a backslash:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他序列一样，某些字符被视为“特殊”字符，需要转义。逗号和单引号需要使用反斜杠进行转义：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Working with history
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用历史记录
- en: Like an elephant, many modern Unix shells tend to remember in great detail the
    copious amount of commands entered while working with them. As many others, zsh
    too boasts a history log and an even more convenient way of accessing each of
    its entries. Being able to glimpse at what you have been up to is not only practical
    from a work-log perspective, but also as a way to speed things up. Think about
    it; you could use `history` to see (and eventually edit) a previously typed command,
    get a bit of context as to what's going on with your system, or avoid retyping
    the same thing over and over. Being able to easily retrieve a command from the
    past sounds awesome, because it is indeed a really neat feature.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 像大象一样，许多现代Unix shell倾向于详细记录在使用它们时输入的大量命令。像许多其他shell一样，zsh也拥有历史日志，并提供一种更便捷的方式来访问其中的每一条记录。从工作日志的角度来看，能够查看你做过的事情不仅实用，而且也有助于提高效率。想想看；你可以使用`history`命令查看（并最终编辑）之前输入的命令，获得一些关于系统状态的上下文，或者避免反复输入相同的内容。能够轻松检索过去的命令听起来很棒，因为它确实是一个非常巧妙的功能。
- en: We'll now take a look at how to use zsh's history expansion to work with previous
    entries in the command line.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在来看看如何使用zsh的历史扩展来处理命令行中的以前条目。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Working with history**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用历史记录**'
- en: A more traditional approach to recalling history entries is by using the up
    arrow and down arrow keys on your keyboard to scroll through history entries.
    We'll have a closer look at how to alter this behavior when we examine the zsh
    line editor (ZLE) module in the next chapter. For now, we'll pretend that these
    are the only keys to move around history.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 更传统的回顾历史记录条目的方法是使用键盘上的上箭头和下箭头键来浏览历史记录条目。在下一章我们将深入研究如何修改这种行为，具体是在检查zsh行编辑器（ZLE）模块时。现在，我们假装这些是唯一可以在历史记录中移动的按键。
- en: History expansion
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史扩展
- en: 'One of the ways zsh provides for you to access your history is via the so-called
    history expansion. This works whenever your input begins with the bang `!` special
    character. As we saw in the previous chapter, the default behavior of the `!`
    character can be overridden by setting the `histchars` shell parameter to something
    different:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: zsh为您提供访问历史记录的方式之一是通过所谓的历史扩展。只要您的输入以感叹号`!`字符开头，这种方式就会生效。正如我们在上一章看到的，`!`字符的默认行为可以通过将`histchars`
    shell参数设置为不同的值来覆盖：
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Unlike other shells though, zsh accepts up to three parameters when setting
    `histchars`. In addition to expansion (changed to `@`), the other two are used
    for substitution (`^`) and comments (`#`) respectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他shell不同，zsh在设置`histchars`时最多接受三个参数。除了扩展（更改为`@`）之外，另外两个分别用于替换（`^`）和注释（`#`）。
- en: 'By replacing the default bang (`!`) with the `@` character, you can now do
    things like calling your last executed command line as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将默认的感叹号（`!`）替换为`@`字符，您现在可以执行类似于以下命令，调用上次执行的命令行：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By redefining `histchars` you'll be able to use commands that actually require
    special characters such as `!` without the need to escape them or worry about
    history substitution. You can choose any combination that you want, but, as a
    rule of thumb, try to stick with the less frequently used characters so that it
    is actually worth the effort.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新定义`histchars`，你可以使用那些实际上需要特殊字符的命令，比如`!`，而不需要转义它们或担心历史替换。你可以选择任何你想要的组合，但作为经验法则，尽量选择那些不太常用的字符，这样才值得花费精力去设置。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: History expansion will only work if you are running an interactive shell and
    the option `NO_BANG_HIST` is unset in your `.zshrc` file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 历史扩展仅在你运行交互式Shell并且`.zshrc`文件中的`NO_BANG_HIST`选项未设置时才会生效。
- en: 'Accessing your history entries is done via what we call *event designators*.
    Like escape sequences, designators are fancy names for constructs that the shell
    expands in order to know exactly what needs to be retrieved from history. One
    of the most popular and helpful event designators is the double bang (`!!`), which
    by itself refers to the most recent command entered:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 访问历史记录条目是通过我们称之为*事件标识符*的方式完成的。像转义序列一样，标识符是外壳扩展的构造的花哨名称，用于精确地知道从历史记录中需要检索什么。最常见和有用的事件标识符之一是双重感叹号（`!!`），它本身指的是最后一次输入的命令：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see, the `!!` character can be really useful for those occasions
    when you forget to run something on elevated privileges. What happens then is
    that zsh immediately expands the reference to the last command in history and
    replaces it in the line that contains the `sudo` call, saving you from entering
    the whole line again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`!!`字符对于那些忘记使用提升权限执行命令的情况非常有用。发生的情况是，zsh立即展开对历史中最后一个命令的引用，并将其替换为包含`sudo`调用的行，避免你再次输入整行命令。
- en: 'Having the shell making substitutions and automatically executing commands
    demands a bit more "blind faith" than most of us would like to deposit on their
    shell. Luckily, we can set the `HIST_VERIFY` option in `.zshrc` to force zsh into
    asking for confirmation every time you bang a command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让Shell进行替换并自动执行命令比我们大多数人愿意在Shell中投入的“盲目信任”要多一点。幸运的是，我们可以在`.zshrc`中设置`HIST_VERIFY`选项，强制zsh在每次你执行命令时要求确认：
- en: '[PRE59]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the shell completes the input in your prompt using the previous
    command, but does not execute it. This is really useful for things like elevated
    privileges or sudo commands. Feel free to go ahead and add `setopt HIST_VERIFY`
    to your `.zshrc` file, as we'll assume it is being used from now on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Shell会在你的提示符中使用之前的命令来完成输入，但不会执行它。这对像提升权限或使用sudo命令非常有用。请随意将`setopt HIST_VERIFY`添加到你的`.zshrc`文件中，因为从现在开始我们假设它会被使用。
- en: 'That''s really neat for the command we just typed, but what if the previous
    command is further back in the history timeline? Well, then we need to use the
    vanilla event bang:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们刚才输入的命令，这真是很方便，但如果前一个命令在历史记录中更久远呢？那么，我们需要使用普通的事件感叹号：
- en: '[PRE60]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here my last executed command that had `cat` in it was a printout of my `hosts`
    file (`cat /etc/hosts`), followed by a call to `grep` as I was looking for lines
    that have `127.0.1.1` on them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我最后执行的包含`cat`的命令是打印出我的`hosts`文件（`cat /etc/hosts`），随后调用了`grep`，因为我在寻找包含`127.0.1.1`的行。
- en: 'If you connect to a remote host using SSH, you could use something like the
    following to retrieve the last run connection:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过SSH连接到远程主机，你可以使用类似以下内容来检索上次运行的连接：
- en: '[PRE61]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, the syntax for history expansion is fairly easy to remember.
    Just put a `!` character together with the command you're looking for and let
    zsh work its magic.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，历史扩展的语法相当容易记住。只需将`!`字符与要查找的命令放在一起，让zsh发挥它的魔力。
- en: Tip
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '*Word designators* indicate the words of the command line that will be included
    in a history reference. What follows is a quick reference of the available designators:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*词设计符*表示将包含在历史引用中的命令行的单词。以下是可用设计符的快速参考：'
- en: '`^`: The first argument.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：第一个参数。'
- en: '`$`: The last argument.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：最后一个参数。'
- en: '`%`: The most recent match for a given word.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`：给定词语的最新匹配。'
- en: '`x-y`: A range of words. Negative indexes like `-i` mean `0-i`; thus, `-1`
    would mean "the penultimate entry".'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x-y`：一系列单词。负索引如`-i`表示`0-i`；因此，`-1`表示“倒数第二个条目”。'
- en: '`*`: All the arguments. Return null for events with just one word.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：所有参数。如果事件只有一个词，则返回null。'
- en: Note that a `%` word designator will only work when used as `!%`, `!:%`, or
    `!?str?:%`; anything else and you will be greeted with an error.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`%`单词指示符只有在用作`!%`、`!:%`或`!?str?:%`时才有效；其他任何用法都会导致错误。
- en: For a more in-depth look at word designators and history expansion semantics,
    please refer to `man zshexpn`, particularly the section titled "HISTORY EXPANSION".
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解单词指示符和历史扩展语义，请参考`man zshexpn`，特别是名为“HISTORY EXPANSION”的部分。
- en: 'Let''s kick it up a notch then; you can combine the special characters `^`
    and `$` in order to access the first and last arguments of a history entry respectively:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们来提高一下难度；你可以结合使用特殊字符`^`和`$`，分别访问历史记录条目的第一个和最后一个参数：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `^` character gets expanded into the first argument of the `mkdir` command,
    which in this particular case is `new folder`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`^`字符扩展为`mkdir`命令的第一个参数，在这个特定的例子中是`new folder`。'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here the same happens with `$`, only this time the last argument of the `touch`
    command is expanded so we can eventually edit it using `nano`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里同样使用了`$`，不过这次扩展了`touch`命令的最后一个参数，因此我们最终可以使用`nano`编辑它。
- en: 'If you are familiar with regular expressions, both of these designators'' behavior
    shouldn''t be too surprising. However, if what you need to do is access some string
    that is not located either at the beginning (`^`) or end (`$`) of the history,
    then you need the `?` designator:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉正则表达式，这两个指示符的行为应该不让你感到惊讶。然而，如果你需要访问的字符串既不在历史的开始（`^`）也不在末尾（`$`），那么你就需要使用`?`指示符：
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The preceding expression matches the most recent command containing `etc`.
    Generally speaking, the syntax for using the `?` event designator can then be
    summed up as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式匹配包含`etc`的最新命令。一般来说，使用`?`事件指示符的语法可以总结如下：
- en: '[PRE65]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The optional `?` you see there at the end is only necessary if the command
    is followed by any text that is not to be considered part of `str`; for example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的那个可选的`?`，只有在命令后面跟着一些不应被视为`str`一部分的文本时才是必要的；例如：
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Did you notice how both the `?` characters serve as delimiters for the `etc`
    keyword? Think of them as parentheses that wrap the expression you're trying to
    match. The caret operator (`^`) is there as we are interested in the first argument
    of that particular command line, which coincidentally is the `/etc/hosts` string.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到`?`字符是如何作为`etc`关键字的定界符吗？可以把它们想象成括号，包裹着你想要匹配的表达式。插入符号操作符（`^`）表示我们对该特定命令行的第一个参数感兴趣，而巧合的是，它正是`/etc/hosts`字符串。
- en: 'There''s lots more we can do with the history bang operator. Another neat trick
    is that it can refer to a particular line in your history. As before, the syntax
    is merely a tweak of what we already know:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用历史感叹号操作符，我们还能做很多其他的事情。另一个有趣的技巧是，它可以引用历史中的特定行。就像之前一样，语法只是对我们已经知道的内容做了些微的调整：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But what about knowing which line I want to use? Well, that''s a bit more complex,
    but not as much as using `grep`, `ack`, or whatever it is that kids are using
    these days to search within your history file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何确定我要使用哪一行呢？嗯，这要复杂一点，但也没有使用`grep`、`ack`或当今孩子们用来在历史文件中搜索的其他工具那么复杂：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Using `grep` and searching for entries that feature `nano`, I can see that
    I edited `/etc/hosts` with it, and that the record resides on line `2045` of my
    `$HISTFILE`. If we wanted to open the hosts file again, it''ll be a simple matter
    of calling:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grep`并搜索包含`nano`的条目，我可以看到我曾用它编辑过`/etc/hosts`，该记录位于我的`$HISTFILE`的第`2045`行。如果我们想再次打开hosts文件，只需简单地调用：
- en: '[PRE69]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And now for a bit of mix and match:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来一些混搭：
- en: '[PRE70]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'On this opportunity I''m looking for `git` entries. As you can see from the
    results, there are quite a few things I''ve been doing with it. Combine what we
    have learned so far, and we can accomplish quite a few things:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我在查找`git`条目。如你所见，结果中显示了我使用`git`做的很多事。结合我们目前学到的内容，我们能做很多事情：
- en: '[PRE71]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, we used the bang operator together with the `$` selector to
    refer to the last argument of line 1573 of our history.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将感叹号操作符与`$`选择器一起使用，以引用历史记录中第1573行的最后一个参数。
- en: 'Interestingly, you can also use a negative integer to refer to the nth-to-last
    entry:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你还可以使用负整数来引用倒数第n个条目：
- en: '[PRE72]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Negative indexes should be pretty familiar territory for some programmers (I'm
    looking at you, Python and Ruby developers).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对一些程序员来说，负索引应该是非常熟悉的（我在看着你们，Python和Ruby开发者）。
- en: History substitution
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史替换
- en: Another helpful feature of the history expansion on zsh is command substitution.
    Using this kind of substitution, you can avoid re-entering a whole line of your
    shell history just so you can edit a comparatively smaller section of it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: zsh 历史扩展的另一个有用功能是命令替换。通过这种替换方式，你可以避免重新输入整行 shell 历史记录，仅仅为了编辑其中一个较小的部分。
- en: 'Raise your hand if you have made something like the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做过类似以下操作，请举手：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'It seems I misspelled the `file.txt` name, so what now? Traditional history
    usage would suggest we just press the up arrow key to recall the previous line,
    navigate left to the `fiel` typo, re-type the correct name, and be done with it.
    The zsh approach however, is a bit more practical:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我拼错了 `file.txt` 文件名，那现在该怎么办？传统的历史记录使用方法会建议我们按上箭头键回忆上一行，左移光标到 `fiel` 错误拼写处，重新输入正确的名称，完成。可是
    zsh 的方法更实用一些：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'What sorcery is this? Put simply, the chained `^` operator allows you to match
    the first occurrence of a word and replace it with the word attached to the second
    `^` operator. A more general syntax would be:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么魔法？简单来说，链式 `^` 操作符允许你匹配一个单词的第一次出现并用附加到第二个 `^` 操作符的单词进行替换。更一般的语法是：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can prevent a command from being added to your history by setting `HIST_IGNORE_SPACE`
    in your startup options. This will make the shell ignore the lines that start
    with a space.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在启动选项中设置`HIST_IGNORE_SPACE`来防止命令被添加到历史记录中。这样，shell 会忽略以空格开头的行。
- en: '[PRE76]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: More useful options
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多有用的选项
- en: To round off this section, here are a couple of history-related options worth
    considering when populating your startup files, in addition to what we have already
    discussed throughout this chapter. Just put any (or all) of these on your `.zshrc`
    and remember to append `setopt` before each entry.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这一部分，以下是一些值得考虑在启动文件中填充的与历史记录相关的选项，除此之外，我们在本章中已经讨论过的内容。只需将其中的任何（或全部）选项添加到
    `.zshrc` 中，并记得在每个条目前加上 `setopt`。
- en: '`EXTENDED_HISTORY`: Saves a timestamp and duration for each history entry run.
    An excellent addition for the data analysis aficionado.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXTENDED_HISTORY`：为每个历史条目保存时间戳和持续时间。对于数据分析爱好者来说是一个非常棒的补充。'
- en: '`HIST_IGNORE_ALL_DUPS`: Ignores duplicate entries when showing results.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIST_IGNORE_ALL_DUPS`：在显示结果时忽略重复的条目。'
- en: '`HIST_FIND_NO_DUPS`: Does not display eventual duplicates of a line that has
    already been found.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIST_FIND_NO_DUPS`：不显示已经找到的行的重复项。'
- en: '`HIST_REDUCE_BLANKS`: Removes extra spaces and tabs from history entries.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HIST_REDUCE_BLANKS`：移除历史记录中的多余空格和制表符。'
- en: '`INC_APPEND_HISTORY`: Adds entries to the history as they are typed, that is,
    doesn''t wait until the shell exits. Probably one of the most awesome features
    of zsh. You know you want this.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INC_APPEND_HISTORY`：在输入时将条目添加到历史记录中，也就是说，不等到 shell 退出后再添加。可能是 zsh 最棒的功能之一。你知道你想要这个。'
- en: '`SHARE_HISTORY`: Shares history between different zsh processes. Another great
    option to compliment the previous entry.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SHARE_HISTORY`：在不同的 zsh 进程之间共享历史记录。另一个非常棒的选项，可以与前一个选项相得益彰。'
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we had a look at some of the most prominent time-saving features
    of zsh. The purpose of this entry in our shell adventure was to start accomplishing
    more by typing less. Thus, this chapter focused on understanding aliases, how
    they work, and how to roll our own keystroke-saving definitions in a way that
    won't cause more trouble than what they attempt to solve.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仔细研究了 zsh 的一些最显著的节省时间的功能。我们在 shell 冒险中的目标是通过减少输入来实现更多的操作。因此，本章重点介绍了理解别名、它们的工作原理，以及如何以一种不会带来更多麻烦的方式来编写我们自己的节省敲击的定义。
- en: We then moved onto expansions, learning the ways of arithmetic and brace expansion
    in order to make command-line related chores feel more like a breeze. Finally,
    we took a closer look at how to work with history, going beyond the keyboard arrow-mashing
    approach and learning history expansion and event designators in order to avoid
    repeating ourselves into oblivion.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们学习了扩展功能，了解了算术扩展和大括号扩展，目的是让与命令行相关的工作变得更加轻松。最后，我们仔细研究了如何使用历史记录，超越了键盘上下箭头疯狂按压的方法，学习了历史扩展和事件设计符，以避免重复自己进入无尽的循环。
- en: 'By now you should have a fairly solid notion regarding the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该对以下内容有了相当清晰的了解：
- en: '**Aliases**: We learned what an alias is and how to define a useful shortcut
    for our commands together with a handful of tips to start your collection.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别名**：我们了解了什么是别名以及如何为我们的命令定义一个有用的快捷方式，并且掌握了一些开始构建别名集合的小技巧。'
- en: '**Parameter expansion, command substitution, and arithmetic and brace expansion**:
    How to replace entries on the command line with the output of any given program,
    the result of an arithmetic expression, and even how to expand arrays so you don''t
    have to type the same thing more than once.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数扩展、命令替换、算术和大括号扩展**：如何用任意给定程序的输出、算术表达式的结果来替换命令行中的条目，甚至如何扩展数组，以便不必重复输入相同的内容。'
- en: '**History expansion and substitution**: How to apply all of the above, together
    with some more specific constructs such as the double bang (`!!`) to the shell''s
    history and avoid repeating yourself to boredom.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史扩展和替换**：如何将以上所有内容应用到 shell 的历史记录中，以及避免无聊地重复自己，特别是双感叹号（`!!`）等特定结构。'
- en: Not bad at all. Pat yourself on the back or go grab a beer, by now you should
    feel confident enough to work your way around zsh without problems. That's great,
    but there's still much more left for us to discover, so don't slack! Next in store
    for us is ZLE, the zsh line editor. We'll get to know another of zsh's cooler
    features and discover that we don't actually require a dedicated program in order
    to perform some of the more advanced text processing on the command line. Besides
    saving us hundreds of hours of mind-numbing repeated keystrokes, we'll also learn
    how to customize the editor's shortcuts and key bindings so we don't have to rely
    on guesswork anymore.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一点也不错。可以自豪地给自己一个鼓励，或者去喝杯啤酒，现在你应该对 zsh 的使用感到足够自信了。这很棒，但是我们还有更多待探索，所以不要懈怠！接下来是
    ZLE，即 zsh 的行编辑器。我们将了解 zsh 的另一个很酷的特性，并发现在命令行上执行一些更高级的文本处理并不需要专门的程序。除了节省我们数百小时重复无聊的击键外，我们还将学习如何定制编辑器的快捷键和绑定，这样就不必再靠猜测了。
