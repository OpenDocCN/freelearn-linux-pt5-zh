- en: Chapter 3. Adding Hardware Security with the CryptoCape
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用CryptoCape添加硬件安全
- en: This chapter continues our custom security hardware journey by using a **BeagleBone
    Black (BBB) cape**. In BeagleBone parlance, a **cape** is a daughterboard that
    attaches to the BBB. We'll briefly introduce hardware cryptographic devices and
    then explore the CryptoCape, which is a BBB cape containing numerous security
    features. We'll describe the process of creating your own cape using the CryptoCape
    as an example. This chapter introduces the crypto chips on the cape and shows
    you how to implement a biometric authentication device using the CryptoCape and
    a fingerprint scanner.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续我们的定制安全硬件之旅，使用**BeagleBone Black（BBB）cape**。在BeagleBone术语中，**cape**是一个附加到BBB的子板。我们将简要介绍硬件加密设备，然后探索CryptoCape，这是一个包含众多安全特性的BBB
    cape。我们将描述如何以CryptoCape为例创建自己的cape。本章介绍了cape上的加密芯片，并展示了如何使用CryptoCape和指纹扫描仪实现生物识别认证设备。
- en: 'This chapter will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下主题：
- en: The pros and cons of hardware-based cryptography
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于硬件的加密技术的利与弊
- en: An overview of the CryptoCape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CryptoCape概述
- en: How cape EEPROMs enable automatic hardware configuration on the BBB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过Cape EEPROM实现BBB的自动硬件配置
- en: How to use the CryptoCape's real-time clock
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用CryptoCape的实时钟表
- en: How to program an ATmega328p from BBB
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从BBB编程ATmega328p
- en: How to implement a biometric authentication system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现生物识别认证系统
- en: Exploring the differences between hardware and software cryptography
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索硬件加密和软件加密的差异
- en: In the following sections, we'll discuss the advantages and disadvantages of
    using hardware-based cryptography. The remaining projects in the book will use
    embedded hardware cryptographic devices, so it's important to know their capabilities
    and their limitations. Refer to [Chapter 1](part0015_split_000.html#page "Chapter 1. Creating
    Your BeagleBone Black Development Environment"), *Creating Your BeagleBone Black
    Development Environment*, for additional resources on cryptography and terms used
    in this section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论使用基于硬件的加密技术的优缺点。本书中的其余项目将使用嵌入式硬件加密设备，因此了解它们的功能和局限性非常重要。有关加密技术和本节中使用的术语的更多资源，请参考[第1章](part0015_split_000.html#page
    "第1章. 创建您的BeagleBone Black开发环境")，*创建您的BeagleBone Black开发环境*。
- en: Understanding the advantages of hardware-based cryptography
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解基于硬件的加密技术的优势
- en: 'For the advantages of hardware cryptography, we''ll focus on the embedded environment
    since that is the target use case of BBB. While chip manufacturers may provide
    a laundry list of advantages, there are two main categories: cryptographic acceleration
    and key isolation features.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于硬件加密的优点，我们将重点讨论嵌入式环境，因为这正是BBB的目标使用场景。虽然芯片制造商可能提供一长串优点，但主要有两个类别：加密加速和密钥隔离功能。
- en: Offloading computation to a separate processor
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将计算任务卸载到独立的处理器上
- en: One advantage of using a dedicated cryptographic co-processor is to offload
    computation to reduce CPU usage. A typical example is using hardware to perform
    the **Advanced Encryption Standard** (**AES**) encryption and decryption operations
    in a **Transport Layer Security** (**TLS**) session.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用加密协处理器的一个优势是可以卸载计算任务，从而减少CPU使用率。一个典型的例子是使用硬件执行**高级加密标准**（**AES**）的加密和解密操作，在**传输层安全协议**（**TLS**）会话中进行。
- en: TLS is most commonly used in conjunction with the **Hypertext Transfer Protocol
    Secure** (**HTTPS**) protocol. You use HTTPS every time you buy something online
    to protect your credit card information. Depending on your browser, you may notice
    a lock icon or a green bar to indicate when a web page is served over HTTPS. In
    a TLS session, the client, your browser, and the server will negotiate to use
    the same symmetric key. While there are several symmetric ciphers that can be
    negotiated, AES is one of the preferred choices.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TLS通常与**超文本传输安全协议**（**HTTPS**）一起使用。每次在线购物时，您都会使用HTTPS来保护您的信用卡信息。根据您的浏览器设置，您可能会注意到锁形图标或绿色条，以指示网页是否通过HTTPS传输。在TLS会话中，客户端（即您的浏览器）和服务器将协商使用相同的对称密钥。虽然可以协商多种对称加密算法，但AES是其中一个常用的选择。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: While some sites automatically redirect you to the HTTPS version of the site,
    often you must manually specify this. Remembering to type `https://` is often
    annoying but fortunately there is a cross-browser plugin that will automatically
    redirect you to the HTTPS site, if there is one. The plugin is called **HTTPS
    Everywhere** and it is maintained by the Electronic Frontier Foundation. Information
    and links to download the free software are located at [https://www.eff.org/https-everywhere](https://www.eff.org/https-everywhere).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些网站会自动将你重定向到HTTPS版本的站点，但通常你必须手动指定。记得输入`https://`往往让人感到麻烦，但幸运的是，有一个跨浏览器插件可以自动将你重定向到HTTPS站点（如果有的话）。这个插件叫做**HTTPS
    Everywhere**，由电子前沿基金会（Electronic Frontier Foundation）维护。有关信息和软件下载链接请访问：[https://www.eff.org/https-everywhere](https://www.eff.org/https-everywhere)。
- en: In the crypto accelerator role, a cryptographic co-processor would perform the
    encryption and decryption of each TLS record. This offloads the main CPU to handle
    the processing of the network traffic and perform the intended application. The
    BBB actually has such a cryptographic co-processor. **Texas Instruments** (**TI**)
    crypto performance page for the AM335x, the processor on the BBB, shows the results
    of their benchmark tests with OpenSSL. Using AES with a 256 bit key size and operating
    on blocks of 8192 bytes, the measured throughput of data was 8129.19 kB/sec without
    using crypto acceleration. This test resulted in a CPU usage of 69 percent. However,
    using the crypto co-processor on the AM335x, they measured a throughput of 24376.66
    kB/sec with a CPU usage of 41 percent. That's almost a 200 percent gain in throughput
    performance and a 40 percent drop in CPU usage!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密加速器角色中，一个加密协处理器会执行每个TLS记录的加密和解密。这将主CPU的负担转移到处理网络流量和执行预定应用程序上。BBB实际上具有这样一个加密协处理器。**德州仪器**（**TI**）为AM335x处理器提供的加密性能页面显示了他们使用OpenSSL进行基准测试的结果。使用256位密钥大小的AES，并对8192字节的块进行操作，未使用加密加速时，测得的数据吞吐量为8129.19
    kB/sec。此测试导致CPU使用率为69%。然而，使用AM335x上的加密协处理器时，测得的数据吞吐量为24376.66 kB/sec，CPU使用率降至41%。这几乎是吞吐量性能的200%的提升，同时CPU使用率下降了40%！
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on the crypto accelerators on the AM335x can be found on TI
    Crypto Performance page at [http://processors.wiki.ti.com/index.php/AM335x_Crypto_Performance](http://processors.wiki.ti.com/index.php/AM335x_Crypto_Performance).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于AM335x上加密加速器的信息可以在TI的加密性能页面找到：[http://processors.wiki.ti.com/index.php/AM335x_Crypto_Performance](http://processors.wiki.ti.com/index.php/AM335x_Crypto_Performance)。
- en: If your embedded application's purpose is to perform a computationally intense
    calculation, using a cryptographic co-processor designed to offload the crypto
    processing can save your CPU cycles for your main program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的嵌入式应用程序的目的是执行计算密集型的计算，使用一个旨在卸载加密处理的加密协处理器，可以将CPU周期节省给你的主程序。
- en: Protecting keys through physical isolation
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过物理隔离保护密钥
- en: A major advantage of using hardware cryptography devices is that keys can be
    generated internal to the device and are designed to be difficult to remove. In
    the web server world, these devices are called **Hardware Security Modules** (**HSMs**).
    In April 2014, a major vulnerability was announced that affected the OpenSSL software,
    colloquially called **heartbleed**. The vulnerability was not a cryptographic
    one *per se*, but rather the result of a programming error called a **buffer overrun**.
    This vulnerability is unfortunately common in the C programming language, in which
    OpenSSL is written, because of the lack of automatic array bounds checking. It
    was possible for a client to exploit this error and view internal memory of the
    server, potentially discovering sensitive information. The code to fix this problem
    was shorter than this paragraph.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬件加密设备的一个主要优势是，密钥可以在设备内部生成，并且设计上难以被移除。在Web服务器的世界中，这些设备被称为**硬件安全模块**（**HSMs**）。在2014年4月，宣布了一个影响OpenSSL软件的重大漏洞，通俗地称为**Heartbleed**。这个漏洞本身并不是加密漏洞*本身*，而是由于一种叫做**缓冲区溢出**的编程错误造成的。不幸的是，这种漏洞在C语言中比较常见，而OpenSSL正是用C语言编写的，因为C语言没有自动的数组边界检查。攻击者可以利用这个错误，查看服务器的内部内存，可能会发现敏感信息。修复这个问题的代码比这个段落还要短。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following `xkcd` comic provides a succinct and amusing explanation of the
    heartbleed bug:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`xkcd`漫画简明且有趣地解释了Heartbleed漏洞：
- en: '[https://xkcd.com/1354/](https://xkcd.com/1354/)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://xkcd.com/1354/](https://xkcd.com/1354/)'
- en: The scale and severity of this vulnerability cannot be overstated. The most
    damaging attack is if the server's private key was leaked. Knowing the private
    key, an attacker can impersonate the server, and clients could willingly disclose
    private information to the impostor. However, on a server with a HSM, the heartbleed
    vulnerability was more limited. Sensitive information, such as session cookies,
    would still have leaked via the software exploit. Yet the server's private key,
    which remains in the HSM, would not have leaked.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个漏洞的规模和严重性是无法过分强调的。最具破坏性的攻击是如果服务器的私钥被泄露。知道私钥后，攻击者可以冒充服务器，客户端可能会不知不觉地向伪造者披露私人信息。然而，在配备硬件安全模块（HSM）的服务器上，心脏出血漏洞的影响则更为有限。像会话
    cookie 这样的敏感信息依然可能通过软件漏洞泄露，但服务器的私钥由于保存在 HSM 中，则不会泄露。
- en: Since the hardware cryptographic co-processor runs as a physically separate
    machine, it is very difficult for software exploits running on the main processor
    to disclose secrets in the hardware module. In the embedded world, there are several
    chips that perform this key isolation feature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于硬件加密协处理器作为一个物理上独立的机器运行，软件漏洞很难通过主处理器泄露硬件模块中的秘密。在嵌入式世界中，有几种芯片执行了这种密钥隔离功能。
- en: Understanding the disadvantages of hardware crypto devices
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解硬件加密设备的缺点
- en: Adding hardware cryptographic devices doesn't automatically make your project
    *secure*. In the following sections, we'll discuss some of the downsides to using
    cryptographic hardware and some of the concerns you would need to resolve when
    using them in your project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 添加硬件加密设备并不自动让你的项目变得*安全*。在接下来的章节中，我们将讨论使用加密硬件的一些缺点以及在项目中使用它们时需要解决的一些问题。
- en: Lacking cryptographic flexibility
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺乏加密灵活性
- en: A hardware cryptographic device is generally not configurable. This is usually
    by design but the implication is that it is difficult, if not impossible, to alter
    the cryptographic behavior of the device. If you select a chip that performs encryption
    with a limited key size, you will not be able to upgrade the device with a stronger
    key size later. It is generally easier to update software-based encryption systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件加密设备通常不可配置。通常这是设计使然，但其含义是很难（如果不是不可能的话）改变设备的加密行为。如果你选择了一款采用有限密钥大小进行加密的芯片，你将无法以后将设备升级为更强的密钥大小。相较而言，更新基于软件的加密系统通常更容易。
- en: Exposing hardware-specific attack vectors
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 暴露硬件特定的攻击向量
- en: 'While an isolated crypto processor may reduce attacks or exploits from the
    software, it often allows more sophisticated hardware-based attacks. There are
    three categories of hardware-based attacks: noninvasive, invasive, and semi-invasive
    (Skoroboga, 2011). Noninvasive attacks treat the chip as a black box and attempt
    to manipulate the surrounding environment to perform an exploit. Successful non-invasive
    attacks include performing a **Differential Power Analysis** (**DPA**) to monitor
    the chip as it performs an encryption algorithm. By measuring the power usage
    during the encryption operation, it is possible to see the key through distinct
    power signatures. An invasive attack usually involves physically destroying the
    chip in some manner to gain access to its internals. Semi-invasive attacks may
    involve some sort of laser imaging to observe or interfere with the chip.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然独立的加密处理器可能减少软件攻击或漏洞，但它往往允许更复杂的基于硬件的攻击。硬件攻击分为三类：非侵入性、侵入性和半侵入性（Skoroboga，2011）。非侵入性攻击将芯片视为黑箱，并试图操控周围的环境以进行攻击。成功的非侵入性攻击包括执行**差分功率分析**（**DPA**），以监控芯片在执行加密算法时的行为。通过测量加密操作中的功率使用情况，可以通过不同的功率特征看到密钥。侵入性攻击通常涉及以某种方式物理破坏芯片，以访问其内部。半侵入性攻击可能涉及某种激光成像技术来观察或干扰芯片。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To perform a glitch attack, an attack attempts to manipulate the executing
    instruction by injecting a fault (Bar-El, 2004). Colin O''Flynn, a security researcher,
    has a concise and clear example of how a glitch attack can cause a password-checking
    microprocessor to fail: [https://www.youtube.com/watch?v=Ruphw9-8JWE&list=UUqc9MJwX_R1pQC6A353JmJg](https://www.youtube.com/watch?v=Ruphw9-8JWE&list=UUqc9MJwX_R1pQC6A353JmJg).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行故障攻击，攻击者尝试通过注入故障来操控执行指令（Bar-El，2004）。安全研究员 Colin O'Flynn 提供了一个简洁明了的示例，展示了故障攻击如何导致密码验证微处理器失败：[https://www.youtube.com/watch?v=Ruphw9-8JWE&list=UUqc9MJwX_R1pQC6A353JmJg](https://www.youtube.com/watch?v=Ruphw9-8JWE&list=UUqc9MJwX_R1pQC6A353JmJg)。
- en: Obfuscating implementation details
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆实现细节
- en: A final consideration is that while chip vendors may publish the interface to
    their device, the internals are often proprietary. This is similar to a software
    vendor who publishes the software programming interface, but provides only the
    compiled binary and not the source code. In this case, the chip is treated as
    a black box, and without a mechanism to verify the device, you have to trust that
    it is operating correctly. As cryptographic libraries are ported to unique microcontrollers
    by the open source community, this situation will hopefully improve.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个最终因素是，尽管芯片供应商可能会发布其设备的接口，内部细节通常是专有的。这类似于软件供应商发布软件编程接口，但仅提供已编译的二进制文件，而不提供源代码。在这种情况下，芯片被视为黑盒子，且没有验证设备的机制，你只能信任它正确运行。随着开源社区将加密库移植到独特的微控制器上，这种情况希望能够得到改善。
- en: Summarizing the hardware versus software debate
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结硬件与软件的争论
- en: 'So, which is the better route? As with most complex technologies the correct
    answer is: *it depends*. For a truly embedded system, one that can''t spare even
    a few extra bytes, a hardware security chip may be your only option if you can''t
    upgrade your microprocessor. Also, if there is a high threat of leaking your key
    due to a software vulnerability, then the separate crypto co-processor might help
    you. However, if an attacker can gain physical access to your device, then they
    might be able to extract the key with hardware-based attacks. Lastly, if transparency
    is paramount for you to verify the lack or existence of backdoors, then only fully
    open source software and hardware devices will satisfy you.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪个选择更好呢？像大多数复杂的技术一样，正确的答案是：*这取决于具体情况*。对于一个真正嵌入式系统，即使是几个字节也不能浪费，如果你不能升级你的微处理器，那么硬件安全芯片可能是唯一的选择。另外，如果由于软件漏洞导致密钥泄露的风险较高，那么独立的加密协处理器可能会有所帮助。然而，如果攻击者能够物理接触你的设备，他们可能会通过硬件攻击提取密钥。最后，如果你非常注重透明度，想要验证是否存在后门，那么只有完全开源的软件和硬件设备才能满足你的需求。
- en: Touring the CryptoCape
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游览 CryptoCape
- en: 'The CryptoCape is BeagleBone''s first dedicated security daughterboard. As
    the BBB already has cryptographic accelerations, the chips on the CryptoCape provide
    the *key isolation* features discussed in the previous section. In the BeagleBone
    community, daughterboards are called *capes* which are analogous to Arduino *shields*.
    The CryptoCape contains several crypto ICs that you may use in your projects.
    The design is open source hardware, so you may also visit the SparkFun website
    to retrieve the design files. The CryptoCape contains the following major components:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: CryptoCape 是 BeagleBone 的首个专用安全子板。由于 BBB 已经具备了加密加速功能，CryptoCape 上的芯片提供了上一节讨论的*密钥隔离*特性。在
    BeagleBone 社区中，子板被称为 *capes*，类似于 Arduino 的 *shields*。CryptoCape 包含了几个可以在项目中使用的加密
    IC。其设计为开源硬件，因此你也可以访问 SparkFun 网站来获取设计文件。CryptoCape 包含以下主要组件：
- en: '| Component | Manufacturer | Features |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 制造商 | 特性 |'
- en: '| --- | --- | --- |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| AT97SC3205T | Atmel | TPM—RSA 2048 encryption and SHA1 hashing |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| AT97SC3205T | Atmel | TPM—RSA 2048 加密和 SHA1 哈希 |'
- en: '| ATAES132 | Atmel | Encrypted EEPROM with AES-128-CCM |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| ATAES132 | Atmel | 带有 AES-128-CCM 的加密 EEPROM |'
- en: '| ATSHA204 | Atmel | SHA-2 hashing (SHA-256, HMAC-256) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| ATSHA204 | Atmel | SHA-2 哈希（SHA-256，HMAC-256） |'
- en: '| ATECC108 | Atmel | ECDSA with NIST curves |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| ATECC108 | Atmel | 使用 NIST 曲线的 ECDSA |'
- en: '| ATmega328p | Atmel | Microcontroller |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ATmega328p | Atmel | 微控制器 |'
- en: '| DS3231M | Maxim integrated | Real-time clock with battery |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| DS3231M | Maxim 集成 | 带电池的实时时钟 |'
- en: '| CAT24C256 | ON semiconductor | EEPROM |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| CAT24C256 | ON 半导体 | EEPROM |'
- en: If you imagine the BBB's Ethernet connector as a neck, then it appears that
    the cutouts of the attached daughterboard seem to wrap around it as if it were
    wearing a cape, hence the name. Also, Boris, the beagle mascot of [BeagleBoard.org](http://BeagleBoard.org),
    looks more adorable in a cape.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把 BBB 的以太网连接器想象成脖子，那么附加的子板的切口就像围绕着它一样，仿佛它穿着一件披风，因此得名“CryptoCape”。另外，[BeagleBoard.org](http://BeagleBoard.org)
    的比格犬吉祥物 Boris，穿上披风后看起来更加可爱。
- en: 'Each of these chips and the associated circuits are clearly labeled on the
    CryptoCape board:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些芯片及其相关电路在 CryptoCape 板上都有清晰的标记：
- en: '![Touring the CryptoCape](img/00011.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Touring the CryptoCape](img/00011.jpeg)'
- en: In the following sections, we'll briefly introduce each component and provide
    some example project ideas.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将简要介绍每个组件，并提供一些示例项目想法。
- en: Discovering the I2C protocol
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 I2C 协议
- en: Every chip on the CryptoCape uses the **Inter-Integrated Circuit** (**I2C**)
    Bus. I2C was developed by Phillips Semiconductor over 20 years ago, but it is
    still very prevalent in electronics design today. I2C requires two signal lines,
    one for a **Serial Clock** (**SCL**) and the other for **Serial Data** (**SDA**).
    Devices attached to the bus are either classified as master or slave. Each slave
    device has an address and there can be more than one master. The I2C protocol
    supports collision detection and is a true multimaster protocol.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CryptoCape 上的每个芯片都使用 **集成电路互联** (**I2C**) 总线。I2C 是由飞利浦半导体公司在 20 多年前开发的，但它今天仍在电子设计中广泛应用。I2C
    需要两条信号线，一条用于 **串行时钟** (**SCL**)，另一条用于 **串行数据** (**SDA**)。连接到总线的设备可以是主设备或从设备。每个从设备都有一个地址，且可以有多个主设备。I2C
    协议支持碰撞检测，并且是真正的多主协议。
- en: The SDA and SCL lines are *pulled up* to the system voltage, VCC, typically
    with resistors connected from VCC to SDA and VCC to SCL. The processor on the
    BBB, the AM335x, contains internal pull-up resistors for the bus. Data is encoded
    to the bus by manipulating the logic levels of the SDA and SCL lines. For example,
    to start sending data, the master pulls SDA low while holding SCL at a logic high.
    The stop condition is sent with a low to high transition of SDA while holding
    SCL high.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SDA 和 SCL 线被 *上拉* 到系统电压 VCC，通常通过连接从 VCC 到 SDA 和 VCC 到 SCL 的电阻来实现。BBB 上的处理器 AM335x
    包含总线的内部上拉电阻。数据通过操控 SDA 和 SCL 线的逻辑电平来编码到总线上。例如，开始发送数据时，主设备将 SDA 拉低，同时将 SCL 保持在逻辑高电平。停止条件是通过将
    SDA 从低电平拉到高电平，同时保持 SCL 高电平来发送。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Revision 6 of the I2C bus specification can be found on NXP semiconductors (previously
    Phillips) website at [http://www.nxp.com/documents/user_manual/UM10204.pdf](http://www.nxp.com/documents/user_manual/UM10204.pdf).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 总线规范的第六版可以在 NXP 半导体（前身为飞利浦）的网站上找到，网址为 [http://www.nxp.com/documents/user_manual/UM10204.pdf](http://www.nxp.com/documents/user_manual/UM10204.pdf)。
- en: The following screenshot shows a normal I2C operation as captured by a logic
    analyzer. A **logic analyzer** is an instrument that can sample electrical connections
    and often decode the signals to produce a human readable format.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了逻辑分析仪捕获的正常 I2C 操作。**逻辑分析仪** 是一种可以采样电气连接并且常常解码信号以生成人类可读格式的仪器。
- en: '![Discovering the I2C protocol](img/00012.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![发现 I2C 协议](img/00012.jpeg)'
- en: Understanding the benefit of cape EEPROMs
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解扩展板 EEPROM 的好处
- en: At a glance, the CAT24C256 **Electrically Erasable Programmable Read Only Memory**
    (**EEPROM**) doesn't appear to add much value to the board. After all, the BeagleBone
    has a 2GB eMMC on the early revisions and a 4GB eMMC on revision C. An extra 256
    kB of memory is hardly food scraps for the beagle. However, it serves a greater
    purpose; it's what enables automatic cape detection by the BBB.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，CAT24C256 **电可擦可编程只读存储器** (**EEPROM**) 似乎并没有为主板带来太多的价值。毕竟，BeagleBone 在早期版本上配备了
    2GB eMMC，在 C 版本中配备了 4GB eMMC。额外的 256 kB 内存对比格尔狗来说几乎不值一提。然而，它却有着更重要的作用；它使得 BBB
    能够自动检测扩展板。
- en: The BBB has two 46 pin female expansion ports offering much more I/O capabilities
    than any other hobbyist board on the market. Certain pins can actually support
    eight different modes, mode 0 through mode 7\. The mapping of pin features to
    a mode is known as **pin muxing**, short for pin multiplexing. To use a pin in
    a certain mode, the software must enable and configure this pin through the kernel's
    interface. This can be manually performed or scripted, but the easiest method
    is to use a BeagleBone cape.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: BBB 配备了两个 46 针女性扩展端口，提供比市场上任何其他爱好者开发板更强大的 I/O 能力。某些引脚实际上可以支持八种不同的模式，从模式 0 到模式
    7。引脚功能与模式的映射被称为 **引脚复用**，即引脚多路复用。为了在某个模式下使用引脚，软件必须通过内核接口启用并配置该引脚。这可以手动执行或通过脚本进行，但最简单的方法是使用
    BeagleBone 扩展板。
- en: During the kernel startup, the software will probe the I2C bus looking for cape
    EEPROMs. There are four valid addresses for Cape EEPROMs, 0x54 through 0x57\.
    Therefore, the BBB supports up to four attached capes. The BBB will read the cape
    EEPROM, which must be programmed using the format in the BBB **System Reference
    Manual** (**SRM**). The BBB, using a software package called the **capemgr**,
    short for **Cape Manager**, will read the board name and revision from the Cape
    EEPROM. It will then try to match the name and revision to a compiled device tree
    fragment on your BBB. If there is a match, it will load that fragment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核启动过程中，软件会探测 I2C 总线，查找 Cape EEPROM。Cape EEPROM 有四个有效地址，范围是 0x54 到 0x57。因此，BBB
    支持最多连接四个 Cape。BBB 会读取 Cape EEPROM，EEPROM 必须使用 **BBB 系统参考手册**（**SRM**）中的格式进行编程。BBB
    使用一个名为 **capemgr** 的软件包，**capemgr** 是 **Cape Manager** 的简称，来读取 Cape EEPROM 中的板卡名称和版本信息。然后，它会尝试将名称和版本与
    BBB 上编译的设备树片段进行匹配。如果匹配成功，它会加载该片段。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The latest production files for the BBB including the schematics and the SRM
    are located on the BBB wiki at [http://elinux.org/Beagleboard:BeagleBoneBlack](http://elinux.org/Beagleboard:BeagleBoneBlack).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: BBB 的最新生产文件，包括原理图和 SRM，位于 BBB Wiki 上：[http://elinux.org/Beagleboard:BeagleBoneBlack](http://elinux.org/Beagleboard:BeagleBoneBlack)。
- en: This automatic configuration provides two benefits. The first is that the pins
    on the BBB are automatically configured for a cape. The second is that the device
    tree can specify the kernel driver for the hardware on the cape, which means that
    the drivers for your hardware can be automatically loaded. The `capemgr` provides
    a plug-and-play like experience for embedded Linux.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动配置提供了两个好处。第一个是 BBB 上的引脚会自动为 Cape 配置。第二个是设备树可以指定用于 Cape 硬件的内核驱动，这意味着你的硬件驱动可以被自动加载。`capemgr`
    提供了一种类似即插即用的体验，适用于嵌入式 Linux。
- en: If you are developing a BeagleBone cape, you should consider the process to
    have your cape supported in the BeagleBone images. This is a three-step process.
    First, you need to create a cape EEPROM file. This file should be written to your
    cape at manufacturing time. Second, you need to create a **Device Tree Source**
    (**DTS**) file, following the cape naming convention previously discussed, and
    submit a pull request on GitHub to BeagleBoard.org. Lastly, you need to create
    an eLinux wiki site discussing your cape. In the next sections, we'll briefly
    describe the software and hardware required to build a BeagleBone cape using the
    CryptoCape as an example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个 BeagleBone Cape，你应该考虑将你的 Cape 纳入 BeagleBone 镜像的支持中。这是一个三步过程。首先，你需要创建一个
    Cape EEPROM 文件。该文件应该在制造时写入到你的 Cape 中。第二，你需要创建一个 **设备树源文件**（**DTS**），遵循之前讨论的 Cape
    命名规范，并在 GitHub 上向 BeagleBoard.org 提交拉取请求。最后，你需要创建一个 eLinux Wiki 网站，讨论你的 Cape。在接下来的章节中，我们将简要描述构建
    BeagleBone Cape 所需的软件和硬件，并以 CryptoCape 为例。
- en: Creating a cape EEPROM
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 Cape EEPROM
- en: 'If you have any semi-complicated hardware for the BeagleBone, you will benefit
    by adding a cape-compatible EEPROM. The essential reference to populating the
    EEPROM is the BeagleBone SRM''s section on *Cape Board Support*. This section
    contains the EEPROM format. To jumpstart your EEPROM file creation, you can use
    a tool called the **EEPROM cape generator** available at: [https://github.com/picoflamingo/BBCape_EEPROM](https://github.com/picoflamingo/BBCape_EEPROM).
    This tool with its simple command-line interface will provide the skeleton for
    your cape EEPROM. Currently, it does not completely implement the cape specification,
    so you must use a binary editor to set the remaining values of the EEPROM. The
    process to create the EEPROM binary involves reading through the SRM and writing
    the appropriate values, at the correct offsets, in a binary file.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 BeagleBone 开发了任何半复杂的硬件，增加一个支持 Cape 的 EEPROM 会带来好处。填充 EEPROM 的基本参考是 BeagleBone
    SRM 中的 *Cape 板卡支持* 部分。该部分包含 EEPROM 格式。为了快速开始创建你的 EEPROM 文件，你可以使用一个名为 **EEPROM
    Cape 生成器** 的工具，访问地址是：[https://github.com/picoflamingo/BBCape_EEPROM](https://github.com/picoflamingo/BBCape_EEPROM)。这个工具具有简单的命令行界面，会为你的
    Cape EEPROM 提供一个框架。目前，它还没有完全实现 Cape 规格，因此你需要使用二进制编辑器设置 EEPROM 的其余值。创建 EEPROM 二进制文件的过程涉及阅读
    SRM，并在正确的偏移量处写入适当的值。
- en: 'You can view the CryptoCape''s EEPROM by executing the following command as
    root:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以 root 身份执行以下命令来查看 CryptoCape 的 EEPROM：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, the CryptoCape EEPROM is located at address 0x57 on the I2C bus.
    If you have multiple capes, you can change the address of the CryptoCape EEPROM
    by placing a solder jumper or solder *blob* on the A0 or A1 address pads next
    to the EEPROM. The results of reading the EEPROM with the previous command will
    produce the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CryptoCape EEPROM位于I2C总线的地址0x57。如果你有多个cape，你可以通过在EEPROM旁边的A0或A1地址垫上放置焊接跳线或焊接*球*来更改CryptoCape
    EEPROM的地址。使用之前命令读取EEPROM的结果将产生以下内容：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you walk through the SRM EEPROM data format, you should be able to match
    the fields with those in the CryptoCape EEPROM. The two most important fields
    are the `Board Name`, which starts at offset 6 and is 32 bytes in length and the
    `Version`, which starts at byte 38 and is 4 bytes in length. From the previous
    example, the board name is `BB-BONE-CRYPTO` and the version is `00A0`. These two
    components are needed to name the DTS file in the next section. Starting at offset
    244, the manufacturer can place any nonvolatile information. The CryptoCape contains
    the **GNU Privacy Guard** (**GPG**) fingerprint of the author's GPG public key,
    which is used to sign software packages and e-mail. In your cape, you could populate
    this with initial values for software or something similar.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浏览SRM EEPROM数据格式，你应该能够将字段与CryptoCape EEPROM中的字段对应起来。两个最重要的字段是`Board Name`，它从偏移量6开始，长度为32字节，以及`Version`，它从字节38开始，长度为4字节。从之前的示例来看，板载名称是`BB-BONE-CRYPTO`，版本是`00A0`。这两个组件在下一节中命名DTS文件时是必需的。从偏移量244开始，制造商可以放置任何非易失性信息。CryptoCape包含了**GNU隐私保护**（**GPG**）指纹，它是作者的GPG公钥，用于签署软件包和电子邮件。在你的cape中，你可以使用软件的初始值或类似的内容来填充它。
- en: Creating the cape DTS file
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建cape DTS文件
- en: 'Besides the EEPROM, you will also need to create a DTS file. This file defines
    attributes of your hardware to the Linux kernel. The DTS file for the CryptoCape
    Revision 00A0 is located on GitHub at: [https://github.com/beagleboard/linux/blob/3.8/firmware/capes/BB-BONE-CRYPTO-00A0.dts](https://github.com/beagleboard/linux/blob/3.8/firmware/capes/BB-BONE-CRYPTO-00A0.dts).
    When creating a new DTS for your hardware, it''s best to review the existing BeagleBone
    DTS files. With the growing number of capes, there is a good chance that there
    exists an approved DTS file with the hardware configuration you seek.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了EEPROM，你还需要创建一个DTS文件。该文件向Linux内核定义你的硬件属性。CryptoCape版本00A0的DTS文件位于GitHub：[https://github.com/beagleboard/linux/blob/3.8/firmware/capes/BB-BONE-CRYPTO-00A0.dts](https://github.com/beagleboard/linux/blob/3.8/firmware/capes/BB-BONE-CRYPTO-00A0.dts)。在为你的硬件创建新的DTS文件时，最好先查看现有的BeagleBone
    DTS文件。随着cape数量的增加，很可能已经存在一个符合你硬件配置的批准DTS文件。
- en: The BBB device tree overlay system is one of the areas undergoing active development,
    and important technical nuances change rapidly. If you need to build your own
    DTS file, it's best to check in with the BeagleBoard.org mailing list available
    at [https://groups.google.com/forum/#!forum/beagleboard](https://groups.google.com/forum/#!forum/beagleboard).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: BBB设备树覆盖系统是正在积极开发的领域之一，重要的技术细节迅速变化。如果你需要构建自己的DTS文件，最好查看BeagleBoard.org的邮件列表：[https://groups.google.com/forum/#!forum/beagleboard](https://groups.google.com/forum/#!forum/beagleboard)。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A detailed introduction to the device tree system in the Linux kernel was presented
    by Thomas Petazzoni at the Embedded Linux Conference Europe in November 2013\.
    The presentation is available on YouTube at [https://www.youtube.com/watch?v=m_NyYEBxfn8](https://www.youtube.com/watch?v=m_NyYEBxfn8).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年11月，Thomas Petazzoni在欧洲嵌入式Linux大会上详细介绍了Linux内核中的设备树系统。该演讲可以在YouTube上观看，链接：[https://www.youtube.com/watch?v=m_NyYEBxfn8](https://www.youtube.com/watch?v=m_NyYEBxfn8)。
- en: 'Let''s briefly look at a portion of the CryptoCape''s DTS file. The `capemgr`
    will load the compiled version of this file to configure the hardware. The drivers
    for some of the chips on the CryptoCape are also loaded automatically since they
    are specified in the DTS file, as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下CryptoCape的DTS文件的一部分。`capemgr`将加载该文件的已编译版本以配置硬件。由于DTS文件中指定了部分芯片的驱动程序，这些驱动程序也会自动加载，如以下代码所示：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you have your DTS file completed and want it included in the official BBB
    image, you can submit a pull request to the previously mentioned repository that
    contains the CryptoCape DTS file. Since this repository contains the existing
    DTS files for the BeagleBone firmware, it is well worth studying if you are building
    your own cape.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成了DTS文件，并希望将其包含在官方BBB镜像中，你可以向之前提到的包含CryptoCape DTS文件的仓库提交一个pull请求。由于这个仓库包含了BeagleBone固件的现有DTS文件，如果你正在构建自己的cape，研究它是非常值得的。
- en: Creating an eLinux wiki site
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个eLinux wiki网站
- en: The last step is to create a Wiki site on [eLinux.org](http://eLinux.org) and
    e-mail `<[support@circuitco.com](mailto:support@circuitco.com)>` to let them know
    to link it to the main BeagleBone Capes page. The page is the main site for all
    BeagleBone capes and it is where the community expects to find cape information.
    The CryptoCape page, with links to all the supporting software and datasheet is
    located at [http://elinux.org/Cryptotronix:CryptoCape](http://elinux.org/Cryptotronix:CryptoCape).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在[eLinux.org](http://eLinux.org)上创建一个Wiki网站，并通过电子邮件`<[support@circuitco.com](mailto:support@circuitco.com)>`通知他们将其链接到主BeagleBone
    Cape页面。该页面是所有BeagleBone capes的主站点，也是社区期望查找cape信息的地方。CryptoCape页面，包含所有支持软件和数据表的链接，位于[http://elinux.org/Cryptotronix:CryptoCape](http://elinux.org/Cryptotronix:CryptoCape)。
- en: The EEPROM is the defining cape component. Even if you don't manufacture a cape,
    you can still benefit from adding the EEPROM and creating the DTS files for your
    own design to take advantage of the BeagleBone's automatic hardware configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: EEPROM是定义cape组件的关键。即使你没有制造cape，仍然可以通过添加EEPROM并为自己的设计创建DTS文件，从而利用BeagleBone的自动硬件配置功能。
- en: Keeping time with a real-time clock
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用实时钟保持时间
- en: Having all clocks synchronized throughout a system is often an assumption that
    doesn't hold for embedded devices. Specialized devices may not need to know the
    time to perform their function. However, in security protocols, accurate time
    keeping is often important. For example, in TLS, the X.509 certificates that are
    used to prove the identity of web servers contain a validity range. There is a
    *not before* and *not after* time that specifies when that certificate is valid.
    Without an accurate time keeping system, a device can't enforce this date range
    allowing it to possibly accept expired or not yet valid certificates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中同步所有时钟通常是一个假设，这对嵌入式设备来说并不成立。专用设备可能不需要知道时间来执行它们的功能。然而，在安全协议中，准确的时间保持往往是非常重要的。例如，在TLS中，用于证明Web服务器身份的X.509证书包含一个有效期范围。证书中有一个*not
    before*和*not after*时间，指定了该证书的有效时间。如果没有准确的时间保持系统，设备无法强制执行这个日期范围，可能会接受过期或尚未生效的证书。
- en: If you use your BBB in an offline environment, but still need accurate time,
    then you can insert a coin cell battery into the battery compartment of the CryptoCape.
    When the BBB is disconnected from power, the RTC will receive enough power from
    the battery to maintain accurate time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在离线环境中使用BBB，但仍需要准确的时间，那么你可以将一个纽扣电池插入CryptoCape的电池仓。当BBB断开电源时，RTC将从电池获得足够的电力以保持准确的时间。
- en: The BBB already contains an RTC; however, it lacks a dedicated battery. It is
    possible to power the entire BBB from a battery using the battery access pads
    located near the DC barrel plug adapter; however, a greater capacity battery would
    be needed since the entire board is powered from these pads.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: BBB已经包含一个RTC；然而，它缺少专用电池。虽然可以通过位于DC插座适配器附近的电池接入垫为整个BBB供电，但由于整个板子都从这些垫供电，因此需要一个更大容量的电池。
- en: 'The RTC driver is loaded automatically, which you can verify by running:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: RTC驱动程序会自动加载，你可以通过运行以下命令进行验证：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should result in the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会导致以下结果：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The previous example shows the BBB's RTC, `omap_rtc`, registered as `rtc0` and
    the not-so-accurate-time of 2000-01-01 being set. The CryptoCape's RTC is `rtc1`
    and the time value is not manipulated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例展示了BBB的RTC，`omap_rtc`，注册为`rtc0`，并且设置了一个不太准确的时间2000-01-01。CryptoCape的RTC是`rtc1`，而时间值没有被修改。
- en: 'You will have to set the RTC time initially after installing the CryptoCape.
    First, you''ll need an accurate system time. Refer to the project from [Chapter
    2](part0019_split_000.html#page "Chapter 2. Circumventing Censorship with a Tor
    Bridge"), *Circumventing Censorship with a Tor Bridge*, on how this is done. Set
    the RTC from the system time with the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 安装CryptoCape后，你需要首先设置RTC时间。首先，你需要一个准确的系统时间。请参考[第2章](part0019_split_000.html#page
    "第2章. 绕过审查与Tor桥接")中的项目，*绕过审查与Tor桥接*，了解如何操作。使用以下命令从系统时间设置RTC时间：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Cross-check the time to ensure it was set properly:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉检查时间，以确保其设置正确：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should produce something like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似于以下的结果：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you use the coin cell battery from SparkFun Electronics, it has a stated
    capacity of 47mAh. The DS3231m draws 2 *micro* Amps when on the battery. Ideally,
    this would result in 23,500 hours of run time on the battery or about 2.7 *years*.
    In actuality, you see much less run time from your battery, but even if the battery
    dies in half of the ideal time, you should still see plenty of battery life from
    your RTC.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是SparkFun电子产品的纽扣电池，它的标称容量为47mAh。DS3231m在电池工作时会消耗2 *微* 安培的电流。理想情况下，这将使电池有23,500小时的运行时间，约为2.7
    *年*。实际上，你会看到电池的运行时间远低于理想时间，但即使电池的寿命只有理想时间的一半，你仍然能从RTC中获得足够的电池续航。
- en: Trusting computing devices with a Trusted Platform Module
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用受信计算设备与受信平台模块
- en: The **Trusted Platform Module** (**TPM**) performs the RSA algorithm on the
    chip. However, it is much more capable than just an encryption chip. The TPM specification
    is developed and maintained by the **Trusted Computing Group** (**TCG**), an international
    industry standards body.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**受信平台模块**（**TPM**）在芯片上执行RSA算法。然而，它的功能远不止是一个加密芯片。TPM规范由**受信计算组织**（**TCG**）制定和维护，这是一个国际行业标准机构。'
- en: TPMs are included on several major vendor laptops including Dell, HP, and even
    Google Chromebooks. On laptops, TPMs are normally found in the **Low Pin Count**
    (**LPC**) package and are enabled via the BIOS. Embedded devices typically don't
    support the LPC bus; the TPM on the CryptoCape communicates over the I2C bus.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多家主要厂商的笔记本电脑都包含TPM，包括戴尔、惠普，甚至是谷歌Chromebook。笔记本电脑上的TPM通常位于**低引脚计数**（**LPC**）封装中，并通过BIOS启用。嵌入式设备通常不支持LPC总线；CryptoCape上的TPM通过I2C总线进行通信。
- en: The software interface to the TPM is via the **Trusted Computing Group Software
    Stack** (**TSS**). In Linux, the TSS is provided by the TrouSerS package. In the
    next chapter, we'll be using the TPM and also take a closer look at the TPM on
    the CryptoCape.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与TPM的软件下载接口是通过**受信计算组织软件栈**（**TSS**）。在Linux中，TSS由TrouSerS软件包提供。在下一章中，我们将使用TPM并进一步探讨CryptoCape上的TPM。
- en: Providing hardware authentication with ATSHA204 and ATECC108
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ATSHA204和ATECC108提供硬件身份验证
- en: Both ATSHA204 and ATECC108 are authentication devices. **Authentication** is
    the process of guaranteeing the identity of communicating parties and ensuring
    data integrity. Each chip uses a different approach to authentication. The ATECC108
    device uses elliptical curve cryptography to provide the **Elliptical Curve Digital
    Signature Algorithm** (**ECDSA**). The ATSHA024 device uses a hash algorithm,
    SHA-256, to provide **Hash Based Message Authentication Codes** (**HMAC**).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ATSHA204和ATECC108都是身份验证设备。**身份验证**是保证通信双方身份并确保数据完整性的过程。每个芯片采用不同的身份验证方法。ATECC108设备使用椭圆曲线加密提供**椭圆曲线数字签名算法**（**ECDSA**）。ATSHA024设备使用哈希算法SHA-256提供**基于哈希的消息认证码**（**HMAC**）。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These two devices are not used in this book, but you can download the software
    from [https://github.com/cryptotronix/hashlet](https://github.com/cryptotronix/hashlet)
    and [https://github.com/cryptotronix/eclet](https://github.com/cryptotronix/eclet)
    and see the example usage for ATSHA204 and ATECC108 respectively.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中没有使用这两种设备，但你可以从[https://github.com/cryptotronix/hashlet](https://github.com/cryptotronix/hashlet)和[https://github.com/cryptotronix/eclet](https://github.com/cryptotronix/eclet)下载软件，查看ATSHA204和ATECC108的示例用法。
- en: Encrypting EEPROM data with the ATAES132
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ATAES132加密EEPROM数据
- en: The ATAES132 is a 32kb EEPROM that can be encrypted with AES using a 128-bit
    key using the **Counter with CBC-MAC** (**CCM**) mode. CCM provides an authenticated
    encryption mode. With an encrypted EEPROM, you can store small amounts of data-at-rest
    more securely. The ATAES132 also has the ability to encrypt and decrypt small
    packets of up to 32 bytes and return the result over the bus. The AES key remains
    in the device at all times.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ATAES132 是一个 32kb 的 EEPROM，可以使用 128 位密钥通过 AES 加密，采用 **Counter with CBC-MAC**
    (**CCM**) 模式。CCM 提供了一种经过认证的加密模式。通过加密的 EEPROM，你可以更安全地存储少量静态数据。ATAES132 还具有加密和解密最大
    32 字节的小数据包的能力，并通过总线返回结果。AES 密钥始终保存在设备中。
- en: At the time of writing this, there isn't a Linux driver for the ATAES132 device,
    but Atmel provides full documentation and an AVR-based library on their website
    at [http://www.atmel.com/devices/ataes132.aspx](http://www.atmel.com/devices/ataes132.aspx).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 写这篇文章时，ATAES132 设备还没有 Linux 驱动程序，但 Atmel 在他们的网站上提供了完整的文档和基于 AVR 的库，地址是 [http://www.atmel.com/devices/ataes132.aspx](http://www.atmel.com/devices/ataes132.aspx)。
- en: Combining the BBB with an ATmega328p
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 BBB 与 ATmega328p 结合
- en: Lastly, the CryptoCape contains an independent microcontroller. This microcontroller
    is the **ATmega328p**, which is the same microcontroller on the Arduino UNO. However,
    because the supply voltage is 3.3V and not 5V like the Arduino UNO, the processor
    runs at a clock speed of 8MHz versus 16Mhz. In this sense, it is more like the
    3.3V Arduino Pro Mini. Shipped from SparkFun, the CryptoCape contains the 3.3V
    Arduino Pro Mini bootloader. Like any other Arduino-based board, you can reflash
    the bootloader by attaching an **In-System Programming** (**ISP**) programmer
    to the ISP headers next to the ATmega328p. SparkFun's pocket programmer is an
    inexpensive tool to perform this task. Just be sure to set the switch to *no power
    target* since the CryptoCape is powered from the BBB.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，CryptoCape 包含一个独立的微控制器。这个微控制器是 **ATmega328p**，它与 Arduino UNO 上的微控制器相同。然而，由于供电电压是
    3.3V，而不是像 Arduino UNO 那样的 5V，处理器的时钟速度为 8MHz，而不是 16MHz。从这个角度来看，它更像是 3.3V 的 Arduino
    Pro Mini。CryptoCape 由 SparkFun 出货，包含 3.3V 的 Arduino Pro Mini 启动加载程序。像其他任何基于 Arduino
    的板子一样，你可以通过将 **In-System Programming** (**ISP**) 编程器连接到 ATmega328p 旁边的 ISP 头部来重新烧录启动加载程序。SparkFun
    的口袋编程器是执行此任务的廉价工具。只需确保将开关设置为 *无电源目标*，因为 CryptoCape 是由 BBB 提供电源的。
- en: While you can use an ISP programmer, you can also use the BBB as a programmer.
    The BBB contains both serial UART and SPI; however, only the serial UART, UART
    4, is connected to the onboard ATmega328p. Like the Arduino UNO, if the microprocessor
    is reset, it will accept uploaded programs over the serial line.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用 ISP 编程器，也可以使用 BBB 作为编程器。BBB 包含串行 UART 和 SPI；然而，只有串行 UART，UART 4，连接到板载的
    ATmega328p。就像 Arduino UNO 一样，如果微处理器被重置，它会接受通过串行线路上传的程序。
- en: 'A simple script that toggles the BBB GPIO connected to ATmega''s reset line,
    which is GPIO 49 for the CryptoCape, and then uploads the hex file using `avrdude`
    will do the trick. The script is part of a GitHub repository which can be cloned
    with the command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的脚本，切换连接到 ATmega 复位线的 BBB GPIO（对于 CryptoCape 是 GPIO 49），然后使用 `avrdude` 上传
    hex 文件，便能完成任务。该脚本是 GitHub 仓库的一部分，可以使用以下命令进行克隆：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this repository, there is an `upload.sh` script, the main logic of which
    contains the following code snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码库中，有一个 `upload.sh` 脚本，其主要逻辑包含以下代码片段：
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first part toggles the ATmega reset line low and sleeps for `$tts`, which
    is currently defined to be .9 seconds. Then the script sets the reset line back
    to high to let the ATmega run. The next line is the `avrdude` command to upload
    your hex file. You''ll need to install `avrdude` with the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分将 ATmega 的复位线拉低并睡眠 `$tts`，目前定义为 0.9 秒。然后，脚本将复位线设置回高电平，允许 ATmega 运行。接下来的这一行是用于上传
    hex 文件的 `avrdude` 命令。你需要使用以下命令安装 `avrdude`：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, to run the script, perform the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行脚本，执行以下操作：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Prior to flashing an Arduino sketch, you must have a sketch to flash. Depending
    on your development preference, there are several options. You can build your
    AVR program on the BBB with a makefile and `gcc-avr`. Or you can build your program
    with Atmel's free AVR Studio or the Arduino IDE. Whichever way you choose, you
    need to find the compiled `hex` file and download it to the BBB using `sftp` or
    a similar tool.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在烧录 Arduino 草图之前，你必须拥有一个要烧录的草图。根据你的开发偏好，有几种选择。你可以在 BBB 上使用 makefile 和 `gcc-avr`
    构建 AVR 程序，或者你可以使用 Atmel 的免费 AVR Studio 或 Arduino IDE 构建程序。无论你选择哪种方式，你都需要找到编译后的
    `hex` 文件，并使用 `sftp` 或类似的工具将其下载到 BBB 上。
- en: 'Before you upload sketches to the CryptoCape''s ATmega, you''ll need to perform
    one very important step: you need to attach jumpers to the two *Program Jumper*
    pins. Without the jumpers, the ATmega is not electrically connected to the BBB
    serial lines. This is a security feature. Using the Arduino bootloader, it is
    possible to upload `hex` files using serial UART. Thus, with the jumpers installed,
    the sketch on the CryptoCape''s ATmega can always be modified. Now imagine if
    the BBB was inflicted with malware, but had the jumpers removed. This malware
    can''t change the software on the ATmega. It can still do lots of other nasty
    things including resetting the ATmega, but it can''t upload new firmware unless
    the jumpers are attached.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在将草图上传到 CryptoCape 的 ATmega 之前，你需要执行一个非常重要的步骤：你需要将跳线连接到两个 *Program Jumper* 引脚。如果没有跳线，ATmega
    将无法与 BBB 串行线路电气连接。这是一个安全功能。使用 Arduino 启动加载程序，可以通过串行 UART 上传 `hex` 文件。因此，在安装跳线后，CryptoCape
    上 ATmega 的草图可以随时进行修改。现在想象一下，如果 BBB 被感染了恶意软件，但跳线被拆除了，这个恶意软件就无法更改 ATmega 上的软件。它仍然可以做很多其他恶意事情，包括重置
    ATmega，但除非跳线连接，否则无法上传新的固件。
- en: Building a two-factor biometric system
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个双重身份验证的生物识别系统
- en: With an independent processor on the CryptoCape, we can create some interesting
    applications. Since the ATmega cannot be flashed from the BeagleBone unless the
    physical jumpers are attached to the board, we can consider this to be a *trusted*
    processor. In this project, we'll implement a biometric authentication system
    with a fingerprint sensor and the CryptoCape. We'll use the ATmega to prevent
    access to the security ICs on the CryptoCape until you have authenticated yourself
    *to the ATmega* with your fingerprint.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CryptoCape 上有独立的处理器，我们可以创建一些有趣的应用程序。由于 ATmega 只有在物理跳线连接到板上时才能从 BeagleBone
    刷写，我们可以将其视为 *受信任* 处理器。在本项目中，我们将实现一个带指纹传感器和 CryptoCape 的生物识别身份验证系统。我们将使用 ATmega
    来防止在你用指纹 *向 ATmega* 进行身份验证之前访问 CryptoCape 上的安全 IC。
- en: A notable example of fingerprint biometrics in consumer devices is Apple's Touch
    ID technology on the iPhone 5s. The sensor used on the iPhone is much more sophisticated
    and expensive than the sensor we will use in this project. But by performing this
    project, you should appreciate the capabilities and challenges of using biometric
    technologies. On the Touch ID support page, Apple motivates the use of the technology
    with the argument that unlocking the phone with your fingerprint is more secure
    than having no passcode and easier than entering a code each time. In a later
    section, we'll discuss the weakness of biometric systems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费电子设备中，指纹生物识别的一个著名例子是苹果在 iPhone 5s 上的 Touch ID 技术。iPhone 上使用的传感器比我们在本项目中使用的传感器更为复杂且昂贵。但通过完成本项目，你应该能够理解使用生物识别技术的能力与挑战。在
    Touch ID 支持页面上，苹果通过以下论点说明了该技术的使用理由：用指纹解锁手机比没有密码更安全，而且比每次输入密码更为便捷。在后续章节中，我们将讨论生物识别系统的弱点。
- en: The major components needed for this project are listed in the following table.
    The SparkFun parts are listed as they were the ones used, but feel free to substitute
    equivalent components. The CryptoCape, which is only manufactured by SparkFun
    Electronics, is open source hardware and the board design files are licensed under
    a Creative Commons license, so you could also make your own CryptoCape if you
    wish. You will also need a basic soldering station and appropriate accessories.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目所需的主要组件列在下表中。列出的 SparkFun 零件是实际使用的零件，但你可以自由替换为等效的组件。CryptoCape 仅由 SparkFun
    Electronics 生产，是开源硬件，其板卡设计文件采用 Creative Commons 许可协议，因此你也可以根据需要制作自己的 CryptoCape。你还需要一个基本的焊接工具和相关配件。
- en: '| Component | SparkFun SKU |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | SparkFun SKU |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Fingerprint sensor | SEN-11792 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 指纹传感器 | SEN-11792 |'
- en: '| CryptoCape | DEV-12773 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| CryptoCape | DEV-12773 |'
- en: '| JST jumper wire assembly | PRT-10359 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| JST 跳线连接线 | PRT-10359 |'
- en: '| Female jumper wires | PRT-11710 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 母头跳线 | PRT-11710 |'
- en: '| Male breakaway headers | PRT-00116 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 公头断开头排 | PRT-00116 |'
- en: '| 2-pin jumpers | PRT-09044 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 2 针跳线 | PRT-09044 |'
- en: 'The following components are optional, but are nice to have:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下组件是可选的，但有的话会更好：
- en: '| Component | SparkFun SKU |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | SparkFun SKU |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Heat shrink kit | PRT-09353 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 热缩套件 | PRT-09353 |'
- en: '| Third hand | TOL-09317 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 第三只手 | TOL-09317 |'
- en: '| Heaterizer XL-3000 | TOL-10326 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| Heaterizer XL-3000 | TOL-10326 |'
- en: The fingerprint sensor overview
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指纹传感器概述
- en: 'The Fingerprint sensor is the GT-511C3 device from ADH Technology. This device
    contains an optical sensor for reading the fingerprints but also an ARM Cortex
    M3 processor for computing the image recognition. The interface to this device
    is via serial UART, using 3.3V level logic, and at a baud rate of 9600 bps. There
    are four wires to connect from the JST connector: transmit, receive, GND, and
    power.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 指纹传感器是来自ADH科技的GT-511C3设备。该设备包含一个光学传感器用于读取指纹，还配备了一个ARM Cortex M3处理器用于进行图像识别。与该设备的接口是通过串行UART连接，使用3.3V电平逻辑，波特率为9600
    bps。通过JST连接器有四根线需要连接：发送、接收、GND和电源。
- en: The datasheet states that the false acceptance rate is less than .001 percent
    and the false rejection rate is less than .1 percent. In short, this is a very
    capable fingerprint sensor. The fingerprint data is analyzed and stored on this
    device. We will use an existing library to communicate with this hardware.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表中指出，误接受率小于0.001%，误拒绝率小于0.1%。简而言之，这是一个非常强大的指纹传感器。指纹数据被分析并存储在该设备上。我们将使用现有的库与此硬件进行通信。
- en: Appreciating the limitations of fingerprint biometrics
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解指纹生物识别的局限性
- en: Realize that this fingerprint sensor authentication mechanism is only as strong
    as your fingerprint. A common critic against using fingerprint sensors centers
    around the fact that it is difficult for you to change your fingerprint. Once
    your fingerprint is copied you can't revoke or change it as you can with a password.
    Using a fingerprint as a two-factor mechanism slightly reduces the risk of an
    authentication breach since a pin or password is still required. You can also
    mitigate the risk of a fake fingerprint attack on your sensor by stationing an
    armed guard to watch the sensor as Bruce Schneier, a security technologist, stated
    in a September 2013 opinion article in WIRED magazine. Such luxuries are often
    limited to deep-pocketed governments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种指纹传感器认证机制的安全性仅与您的指纹强度相关。关于使用指纹传感器的常见批评集中在这样一个事实：指纹一旦被复制，您就无法像更改密码一样撤销或更改它。使用指纹作为两因素认证机制稍微降低了认证漏洞的风险，因为仍然需要输入PIN码或密码。您还可以通过安排一名武装警卫守卫传感器来降低假指纹攻击的风险，正如安全技术专家布鲁斯·施奈尔（Bruce
    Schneier）在2013年9月《WIRED》杂志的一篇评论文章中所指出的那样。这样的奢侈措施通常只限于资金雄厚的政府。
- en: Note
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '*Mythbusters*, a popular science and engineering program on the Discovery Channel,
    busted the myth that fingerprints could not be copied and showed how to defeat
    fingerprint sensors: [https://www.youtube.com/watch?v=3Hji3kp_i9k](https://www.youtube.com/watch?v=3Hji3kp_i9k).
    Also, days after the Apple iPhone 5s was released, the biometrics hacking team
    of the **Chaos Computer Club** (**CCC**) showed how to bypass the fingerprint
    sensor: [http://www.ccc.de/en/updates/2013/ccc-breaks-apple-touchid](http://www.ccc.de/en/updates/2013/ccc-breaks-apple-touchid).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*科学突破者*，一档在探索频道播出的流行科学和工程节目，揭穿了指纹无法复制的神话，并展示了如何绕过指纹传感器：[https://www.youtube.com/watch?v=3Hji3kp_i9k](https://www.youtube.com/watch?v=3Hji3kp_i9k)。此外，在苹果iPhone
    5s发布几天后，**混乱计算机俱乐部**（**CCC**）的生物识别黑客团队展示了如何绕过指纹传感器：[http://www.ccc.de/en/updates/2013/ccc-breaks-apple-touchid](http://www.ccc.de/en/updates/2013/ccc-breaks-apple-touchid)。'
- en: Perhaps the greatest danger of biometric systems is the potential for a grave
    privacy breach. A database of fingerprints should be well protected since once
    the fingerprints are exposed they are no longer useful for any other biometric
    system, *ever*. In August 2014, Hold Security, an information security forensics
    company, reported to the *New York Times* that over 1.2 billion usernames and
    passwords were acquired by a Russian crime organization. While incredibly damaging,
    this breach would be irrecoverable if fingerprint biometrics were used. Hopefully,
    companies aren't storing fingerprints directly but representations of the fingerprint
    similar to a hash digest. However, if implemented poorly, the results can be as
    disastrous as storing the raw fingerprint.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 也许生物识别系统最大的危险是可能引发严重的隐私泄露。一旦指纹数据被暴露，它们将不再对任何其他生物识别系统有用，*永远*。2014年8月，信息安全取证公司Hold
    Security向*纽约时报*报告称，一家俄罗斯犯罪组织窃取了超过12亿个用户名和密码。虽然这个泄露事件造成了极大的损害，但如果使用指纹生物识别，数据将无法恢复。希望公司不会直接存储指纹，而是存储类似哈希摘要的指纹表示。然而，如果实现不当，结果可能像存储原始指纹一样灾难性。
- en: With these warnings in mind, we will continue with using a fingerprint sensor
    for this project. You'll gain insight on how a fingerprint sensor works and how
    to it fits into an authentication system. When you are finished with this project,
    however, you should probably delete your fingerprint from the sensor's database.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些警告，我们将继续在本项目中使用指纹传感器。你将了解指纹传感器如何工作以及它如何融入身份验证系统中。然而，完成此项目后，你可能需要从传感器的数据库中删除你的指纹。
- en: Preparing the CryptoCape
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备CryptoCape
- en: In order to make the CryptoCape more *hackable*, we need to populate the pads
    attached to the I/O signals with male headers. This will allow us to connect various
    external components. While you could directly solder to the pads, it's best if
    you solder a male 0.1" pin, which will allow you to easily connect a female terminated
    wire for your project, which can then be reused.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使CryptoCape更具*可破解性*，我们需要将I/O信号的焊盘焊接上公头插针。这将使我们能够连接各种外部组件。虽然你可以直接焊接到焊盘，但最好是焊接一个0.1英寸的公头引脚，这样你就可以轻松连接带母端的跳线，以便你的项目使用，之后还能重复使用。
- en: A fully populated CryptoCape will look like the following image. A strip of
    breakaway headers of 31 pins or more will be enough to populate each pad. Technically,
    you don't need to populate the EEPROM write protect pads unless you want to write
    to the EEPROM. However, if you overwrite the EEPROM cape information, the BBB
    might not load the correct drivers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完全焊接好的CryptoCape应如下图所示。31个引脚或更多的断开式插针足以填充每个焊盘。从技术上讲，除非你打算写入EEPROM，否则不需要填充EEPROM写保护焊盘。不过，如果你覆盖了EEPROM的外设信息，BBB可能无法加载正确的驱动程序。
- en: '![Preparing the CryptoCape](img/00013.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![准备CryptoCape](img/00013.jpeg)'
- en: Preparing the connections
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备连接
- en: 'Before attaching any connections, we physically need a method to attach the
    ends of the JST cable to the CryptoCape. The CryptoCape has 0.1" pads, which will
    fit 0.1" male headers and female-to-female jumper wires fit nicely to that connection.
    One end of the JST connector is simply four bare wires. If you solder each of
    these wires to a 4x1 0.1" male header, you can make a simple connector. Using
    a third hand, you can solder the JST wires to the headers and for a finishing
    touch, add heat-shrink around the wire and the male pin. Just remember to put
    your heat shrink on before you solder! The completed connector should look something
    like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接任何线缆之前，我们需要物理方法将JST电缆的端连接到CryptoCape。CryptoCape具有0.1英寸的焊盘，可以容纳0.1英寸的公头插针，并且母对母的跳线也能完美匹配该连接。JST连接器的一端是四根裸线。如果你将每根线焊接到一个4x1
    0.1英寸的公头插针上，你就能制作一个简单的连接器。使用第三只手，你可以将JST电缆焊接到插针上，最后在电线和公头引脚周围加热缩管。记住，在焊接前一定要先把热缩管套上！完成的连接器应该像这样：
- en: '![Preparing the connections](img/00014.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![准备连接](img/00014.jpeg)'
- en: Connecting the Scanner to the CryptoCape
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将扫描仪连接到CryptoCape
- en: 'We''ll attach the fingerprint scanner to the CryptoCape. The Arduino compatible
    library for this sensor was developed by Josh Hawley. This library is configured
    to use digital pin 4 for the receive pin on the ATmega and digital pin 5 as the
    transmit pin from the ATmega. These pins are appropriately labeled *D4* and *D5*
    on the CryptoCape, just under the ATmega. The remaining two pins are 3.3V power
    and ground which are also on the same row as the D4 and D5 pins. Attach the female
    ends of the jumper wires to these pins. If you are using the SparkFun JST connector,
    the pins from the fingerprint scanner are in the following order, starting with
    the black wire: D4, D5, GND, Power.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把指纹扫描仪连接到CryptoCape。该传感器的Arduino兼容库由Josh Hawley开发。该库配置为使用数字引脚4作为ATmega的接收引脚，数字引脚5作为ATmega的发送引脚。这些引脚在CryptoCape上被标记为*D4*和*D5*，位于ATmega下方。剩余的两个引脚分别是3.3V电源和地，它们也与D4和D5引脚在同一排。将跳线的母端连接到这些引脚。如果你使用SparkFun的JST连接器，指纹扫描仪的引脚顺序如下，从黑色线开始：D4、D5、GND、电源。
- en: Preparing the fingerprint sensor
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备指纹传感器
- en: 'The fingerprint sensor must be trained to recognize your fingerprint through
    a process called **enrollment**. There are several methods to enroll your fingerprint.
    The SparkFun website has instructions on how to use the ADH-Tech provided Windows-based
    software to program the sensor. However, you''ll need an extra component, that
    is, the FTDI Basic Breakout board to convert USB from your computer to serial
    for the scanner. You could also use an Arduino directly, but you must also use
    logic level converters if you are using a 5V Arduino. Since the CryptoCape has
    an Arduino compatible processor, we will show you how to do this with your BBB
    and CryptoCape. The repository that contains the ATmega firmware can be cloned
    on your BBB with the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过一个叫做 **注册** 的过程来训练指纹传感器识别您的指纹。有几种方法可以注册您的指纹。SparkFun 网站提供了如何使用 ADH-Tech
    提供的基于 Windows 的软件来编程传感器的说明。然而，您需要额外的组件，即 FTDI 基本分离板，将电脑的 USB 转换为扫描仪所需的串口。您也可以直接使用
    Arduino，但如果使用 5V 的 Arduino，还必须使用逻辑电平转换器。由于 CryptoCape 配备了兼容 Arduino 的处理器，我们将展示如何在
    BBB 和 CryptoCape 上执行此操作。包含 ATmega 固件的仓库可以通过以下命令克隆到您的 BBB 上：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this repository, the `FPS_Enroll.ino` file will enroll, or add, a fingerprint
    to the sensor's database. As previously mentioned, you'll need to compile this
    file out of band. Alternatively, you can use the pre-compiled version in the repository
    above.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个仓库中，`FPS_Enroll.ino` 文件将会将指纹注册到传感器的数据库中。正如之前提到的，您需要单独编译此文件。或者，您也可以使用仓库中的预编译版本。
- en: 'Upload the enroll script:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上传注册脚本：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see text scroll by that looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似下面的文字滚动：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If there is a problem, first check to see whether the jumpers are attached and
    then try again.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，首先检查跳线是否连接好，然后再试一次。
- en: 'This script will output to the serial port at `9600` baud, so we need to change
    `/dev/ttyO4` to reflect this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将在 `9600` 波特率下输出到串口，因此我们需要将 `/dev/ttyO4` 更改为反映此波特率：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, let''s display the output of the serial port with:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过以下命令显示串口的输出：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The script is patiently waiting for you to enroll a finger. Place your finger
    on the reader and watch the output of the serial port and follow the instructions.
    A successful enrollment looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会耐心地等待您注册指纹。将您的指纹放在读卡器上，查看串口输出并按照提示操作。成功注册的输出看起来是这样的：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If there is a problem, and the enrollment process can be a bit finicky, you'll
    need to reset the ATmega and re-attempt enrollment. In the same repository is
    a script, `reset.sh`, that simply toggles the ATmega reset line. If you have troubles,
    reset your ATmega and try again.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，且注册过程有些挑剔，您需要重置 ATmega 并重新尝试注册。在同一个仓库中有一个脚本，`reset.sh`，它简单地切换 ATmega
    的复位线。如果您遇到问题，请重置您的 ATmega 并重新尝试。
- en: Uploading the biometric detection sketch
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上传生物识别检测草图
- en: With the sensor now trained to recognize your fingerprint, we'll upload a sketch
    that will lock out the CryptoCape until you present your fingerprint. Specifically,
    it will prevent access to the chips on the CryptoCape from the BBB. We'll accomplish
    this by *jamming* the SCL line on the I2C bus.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在传感器已经训练好识别您的指纹，我们将上传一个草图，该草图将在您出示指纹之前锁定 CryptoCape。具体来说，它将防止 BBB 访问 CryptoCape
    上的芯片。我们将通过*干扰* I2C 总线上的 SCL 线来实现这一点。
- en: One weakness of I2C is that one misaligned device can disrupt the entire bus.
    On the CryptoCape, every IC is connected to the same I2C bus. We'll exploit this
    for this project. The ATmega will hold the SCL low until a successful fingerprint
    is received. This essentially jams the bus since the master, the BBB, can't generate
    the start condition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 的一个弱点是，一个未对齐的设备就能干扰整个总线。在 CryptoCape 上，每个 IC 都连接到同一条 I2C 总线上。我们将在此项目中利用这一点。ATmega
    将保持 SCL 低电平，直到成功接收到指纹。这实际上会干扰总线，因为主设备 BBB 无法生成启动条件。
- en: The software running on the BBB will hang until the ATmega releases the lock.
    Typically, this is a very undesirable effect. For this project, however, it illustrates
    how two microprocessors can interact and even interfere with one another. In the
    following screenshot, you can see the effect of this jamming of Salee Logic Analyzer
    software. Once the SCL is released, the BBB is finally able to send a start condition.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 BBB 上运行的软件会暂停，直到 ATmega 释放锁定。通常来说，这种效果是非常不希望出现的。然而，对于这个项目来说，它展示了两个微处理器如何相互作用甚至干扰对方。在下图中，您可以看到
    Salee 逻辑分析软件中这种干扰的效果。一旦 SCL 被释放，BBB 就终于能够发送启动条件。
- en: '![Uploading the biometric detection sketch](img/00015.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![上传生物识别检测草图](img/00015.jpeg)'
- en: In the `FPS_CryptoCape.ino` file, this is accomplished by setting digital output
    2 as an output and then pulling the line low. When a fingerprint is recognized,
    the pin is configured as an input, which prevents the ATmega from pulling the
    line either high or low and allows normal I2C operation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `FPS_CryptoCape.ino` 文件中，这是通过将数字输出 2 设置为输出并拉低线路来实现的。当识别到指纹时，针脚被配置为输入，这防止了
    ATmega 拉高或拉低线路，并允许正常的 I2C 操作。
- en: 'Add a jumper wire from *D2* on the ATmega breakout pads to the *SCL* pad near
    the TPM on the CryptoCape. This is that one extra wire that will allow the ATmega
    to lock out the BBB''s access to the I2C bus. Once you add that wire, upload the
    `FPS_CryptoCape.cpp.hex`, which you can either compile yourself or use the pre-compiled
    version. The wires on your CryptoCape should look like the following image:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ATmega 引脚板上的 *D2* 到 CryptoCape 上靠近 TPM 的 *SCL* 引脚添加一根跳线。这是唯一的一根额外线路，它将允许 ATmega
    锁定 BBB 对 I2C 总线的访问。一旦添加了该线路，上传 `FPS_CryptoCape.cpp.hex` 文件，你可以自己编译或使用预编译版本。你 CryptoCape
    上的线路应该如下图所示：
- en: '![Uploading the biometric detection sketch](img/00016.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![上传生物识别检测草图](img/00016.jpeg)'
- en: 'Upload the sketch as before and then listen to the serial port with the same
    `cat /dev/ttyO4` command. You will see the ATmega waiting for the sensor''s fingerprint.
    Present your fingerprint to the sensor and it will then print a verification when
    complete:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样上传草图，然后使用相同的 `cat /dev/ttyO4` 命令监听串口。你将看到 ATmega 正在等待传感器的指纹。将你的指纹放到传感器上，完成后它会打印出验证结果：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will also notice that the green LED on the CryptoCape will turn off. While
    the LED is on, the ATmega is locking out your BBB from accessing the CryptoCape.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，CryptoCape 上的绿色 LED 会熄灭。当 LED 点亮时，ATmega 正在阻止你的 BBB 访问 CryptoCape。
- en: Security analysis of the biometric system
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生物识别系统的安全分析
- en: How secure is our biometric system? While it does prevent software on the BBB
    from using the CryptoCape until a valid fingerprint is accepted, the system is
    easily defeated by pulling (or cutting) the line from D2 to SCL. Without the electrical
    connection, the ATmega can't interfere with the I2C bus. However, depending on
    your installation, an attacker may have a difficult time physically accessing
    the hardware. The process of assessing vulnerabilities and mitigations to those
    vulnerabilities is known as **threat modeling**. In the previous chapter, the
    Tor design stated that it can't defend against a global passive adversary. In
    your implementation of our biometric system, maybe access to the jamming line
    is not a threat because you've placed your BBB in an adamantium box. There is
    no perfectly secure system so a threat model helps us understand the strengths,
    weaknesses, and assumptions of our system. We'll see more threat modeling in our
    final two chapters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生物识别系统有多安全？虽然它确实阻止 BBB 上的软件在接受有效指纹之前使用 CryptoCape，但通过拉断（或切断）D2 到 SCL 线路，系统可以很容易被攻破。没有电气连接，ATmega
    无法干扰 I2C 总线。然而，根据你的安装情况，攻击者可能很难物理接触到硬件。评估漏洞及其缓解措施的过程被称为 **威胁建模**。在上一章中，Tor 的设计指出它无法防御全球被动对手。在你实施我们的生物识别系统时，可能访问干扰线路并不是威胁，因为你已经把
    BBB 放进了一个金刚石盒子。没有完美的安全系统，所以威胁模型帮助我们理解系统的优缺点和假设。在最后两章中，我们将看到更多的威胁建模内容。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter provided a close look at BeagleBone capes and the CryptoCape. We
    introduced the idea of trusted computing and built a biometric authentication
    system. We've shown the normal use case for I2C devices and illustrated how one
    rogue device can corrupt the entire bus.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了对 BeagleBone cape 和 CryptoCape 的深入了解。我们介绍了可信计算的概念，并建立了一个生物识别认证系统。我们展示了
    I2C 设备的正常使用场景，并说明了一个恶意设备如何破坏整个总线。
- en: 'In the next chapter, we''ll use the BBB to protect e-mail encryption and signing
    keys for **Pretty Good Privacy** (**PGP**) and its free software implementation:
    GPG.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将使用 BBB 来保护 **Pretty Good Privacy** (**PGP**) 及其免费软件实现 GPG 的电子邮件加密和签名密钥。
