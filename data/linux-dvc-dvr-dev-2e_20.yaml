- en: '*Chapter 16*: Getting the Most Out of the Pin Controller and GPIO Subsystems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：最大化利用引脚控制器和GPIO子系统'
- en: '**System-on-chips** (**SoCs**) are becoming more and more complex and feature-rich.
    These features are mostly exposed through electrical lines originating from the
    SoC and are called pins. Most of these pins are routed to or multiplexed with
    several functional blocks (for instance, UART, SPI, RGMI, **General-Purpose Input
    Output** (**GPIO**), and so on), and the underlying device responsible for configuring
    these pins and switching between operating modes (switching between functional
    blocks) is called the **pin controller**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统芯片**（**SoC**）变得越来越复杂，功能越来越丰富。这些功能大多通过来自SoC的电气线路暴露出来，并被称为引脚。这些引脚大多数被路由到或与多个功能模块复用（例如，UART、SPI、RGMI、**通用输入输出**（**GPIO**）等），负责配置这些引脚并在操作模式之间切换（在功能模块之间切换）的底层设备被称为**引脚控制器**。'
- en: One mode in which such pins can be configured is **GPIO**. Then comes the Linux
    GPIO subsystem, which enables drivers to read signals on GPIO configured pins
    as high or low and to drive the signal high/low on GPIO configured pins. On the
    other hand, the **pin control** (abbreviated **pinctrl**) subsystem enables multiplexing
    of some pin/pin groups for different functions, and the capability to configure
    the electrical properties of pins, such as slew rate, pull up/down resistor, hysteresis,
    and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种配置这些引脚的模式是**GPIO**。接着是Linux GPIO子系统，它使驱动程序能够读取GPIO配置引脚的高低电平信号，并且能够在GPIO配置的引脚上驱动信号的高/低电平。另一方面，**引脚控制**（简称**pinctrl**）子系统使得一些引脚/引脚组可以用于不同的功能，并能够配置引脚的电子属性，如上升/下降速率、上拉/下拉电阻、滞后等。
- en: 'To summarize, the pin controller mainly does two things: pin multiplexing,
    that is, reusing the same pin for different purposes, and pin configuration, that
    is, configuring electronic properties of pins. Then, the GPIO subsystem allows
    driving pins, provided these pins are configured to work in GPIO mode by the pin
    controller.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，引脚控制器主要做两件事：引脚复用，即将相同的引脚用于不同的目的，以及引脚配置，即配置引脚的电子属性。然后，GPIO子系统允许驱动引脚，前提是这些引脚已经通过引脚控制器配置为GPIO模式。
- en: 'In this chapter, pin controller and GPIO subsystems will be introduced via
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将通过以下主题介绍引脚控制器和GPIO子系统：
- en: Introduction to some hardware terms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些硬件术语介绍
- en: Introduction to the pin control subsystem
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚控制子系统简介
- en: Dealing with the GPIO controller interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理GPIO控制器接口
- en: Getting the most out of the GPIO consumer interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化利用GPIO消费者接口
- en: Learning how not to write GPIO client drivers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何不编写GPIO客户端驱动
- en: Introduction to some hardware terms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些硬件术语介绍
- en: 'The Linux kernel GPIO subsystem is not just about GPIO toggling. It is tightly
    coupled to the pin controller subsystem; they share some terms and concepts that
    we need to introduce:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核GPIO子系统不仅仅是GPIO翻转。它与引脚控制子系统紧密耦合；它们共享一些术语和概念，我们需要在此介绍：
- en: '**Pin** and **pad**: A pin is a physical input or output wire/line that transports
    an electrical signal from or to a component. In schematics, the term "pin" is
    widely used. Contact pads, on the other hand, are the contact surface areas of
    a printed circuit board or an integrated circuit. As a result, a pin comes from
    a pad, and a pin is a pad by default.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引脚**和**接触点**：引脚是一个物理输入或输出线/导线，用于传输电信号到或来自一个组件。在电路图中，“引脚”这一术语被广泛使用。另一方面，接触点是印刷电路板或集成电路的接触面区域。因此，引脚来源于接触点，且默认情况下，引脚即为接触点。'
- en: '**GPIO**: Most MCUs and CPUs can share one pad among several functional blocks.
    This is accomplished by multiplexing the input and output signals of the pad.
    The different modes the pin/pad can operate in are known as **ALT modes** (or
    alternate modes), and it is common for CPUs to support up to eight settings (or
    modes) per pad. GPIO is one of these modes. It allows changing the pin direction
    and reading its value when it is configured as input or setting its value when
    it is configured as output. Other modes are ADC, UART Tx, UART Rx, SPI MOSI, SPI
    MISO, PWM, and so on.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO**：大多数MCU和CPU可以在多个功能模块之间共享一个接触点。这是通过对接触点的输入和输出信号进行复用来实现的。引脚/接触点可以操作的不同模式被称为**ALT模式**（或备用模式），通常CPU支持每个接触点最多八种设置（或模式）。GPIO就是其中一种模式。它允许在配置为输入时改变引脚方向并读取其值，或在配置为输出时设置其值。其他模式包括ADC、UART
    Tx、UART Rx、SPI MOSI、SPI MISO、PWM等。'
- en: '**Pin controller**: This is the underlying device or controller (or rather,
    a group of registers) allowing you to perform **pin multiplexing** (also referred
    to as **pinmux** or **pinmuxing**) to reuse the same pin for different purposes.
    Apart from pinmuxing, it allows pin configuration, that is, configuring electronic
    properties of pins. The following are some of these properties:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引脚控制器**：这是底层设备或控制器（或者更确切地说，是一组寄存器），允许你执行**引脚复用**（也称为**pinmux**或**pinmuxing**），以便将同一个引脚用于不同的目的。除了引脚复用，它还允许引脚配置，即配置引脚的电子属性。以下是这些属性的一些示例：'
- en: '**Biasing**, that is, setting the initial operating conditions, for example,
    grounding the pins or connecting them to Vdd. This is not to be confused with
    pull up and pull down, which is another property.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏置**，即设置初始工作条件，例如将引脚接地或连接到Vdd。这与上拉和下拉有所不同，后者是另一种属性。'
- en: '**Pin debounce**, which is the time after which a state should be considered
    valid. This, for example, prevents multiple key pushes on keypads attached to
    GPIO lines.'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引脚去抖动**，即应在此时间后认为状态有效。例如，这可以防止按键盘上附着在GPIO线上的多个按键。'
- en: '**Slew rate**, which determines how fast the pin toggles between the two logic
    states. It allows us to control the rise and fall time for the output signals.
    A trade-off has to be found because rapidly changing states consume more power
    and generate spikes, thus low slew rates are preferred, except for quick control
    signals such as parallel interfaces: EIM, EB&, SPI, or SDRAM, which need fast
    toggling.'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切换速率**，它决定了引脚在两个逻辑状态之间切换的速度。它使我们能够控制输出信号的上升和下降时间。必须找到一个权衡，因为快速切换状态会消耗更多的电力并产生尖峰，因此，除非是快速控制信号（如并行接口：EIM、EB&、SPI或SDRAM等需要快速切换的信号），否则应偏好较低的切换速率。'
- en: Pull Up/Down resistors
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上拉/下拉电阻
- en: '**GPIO controller**: This is the device allowing you to drive pins when they
    are put in GPIO mode. It allows changing the GPIO direction and value.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPIO控制器**：这是当引脚处于GPIO模式时，允许你驱动引脚的设备。它允许更改GPIO的方向和值。'
- en: 'Following the previous definitions, certain general rules have been established
    for writing pin controllers or GPIO controller drivers, and they are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的定义，已经为编写引脚控制器或GPIO控制器驱动程序建立了一些通用规则，它们如下所示：
- en: If your GPIO/pin controller can only do simple GPIO, implement just `struct
    gpio_chip` in `drivers/gpio/gpio-foo.c` and leave it there. Do not use the generic
    or old-style number-based GPIO.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的GPIO/引脚控制器仅能执行简单的GPIO操作，只需在`drivers/gpio/gpio-foo.c`中实现`struct gpio_chip`并留在那里。不要使用通用的或旧式的基于数字的GPIO。
- en: Keep your GPIO/pin controller in `drivers/gpio` if it can generate interrupts
    in addition to GPIO capabilities; simply fill in `struct irq_chip` and register
    it with the IRQ subsystem.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果GPIO/引脚控制器除了GPIO功能外还能生成中断，请将其保存在`drivers/gpio`中；只需填写`struct irq_chip`并将其注册到IRQ子系统中。
- en: Implement composite pin controller drivers in `drivers/pinctrl/pinctrl-foo.c`
    if this controller supports pinmuxing, advanced pin driver strength, complicated
    biasing, and so on.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该控制器支持引脚复用、高级引脚驱动强度、复杂的偏置等，请在`drivers/pinctrl/pinctrl-foo.c`中实现复合引脚控制器驱动程序。
- en: Maintain the `struct gpio_chip`, `struct irq_chip`, and `struct pinctrl_desc`
    interfaces.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护`struct gpio_chip`、`struct irq_chip`和`struct pinctrl_desc`接口。
- en: Now that we are familiar with the terms related to the underlying hardware devices,
    let's introduce the Linux implementation, starting with the pin control subsystem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了与底层硬件设备相关的术语，让我们介绍Linux实现，从引脚控制子系统开始。
- en: Introduction to the pin control subsystem
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引脚控制子系统介绍
- en: The pin controller allows gathering pins, the modes these pins should operate
    in, and their configurations. The driver is responsible for providing the appropriate
    set of callbacks according to the features that are to be implemented, provided
    the underlying hardware supports these features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚控制器允许收集引脚、这些引脚应该操作的模式及其配置。驱动程序负责根据要实现的功能提供适当的回调集，前提是底层硬件支持这些功能。
- en: 'The pin controller descriptor data structure is defined as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚控制器描述符数据结构定义如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In that pin controller data structure, only relevant elements have been listed,
    and the following are their meanings:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在该引脚控制器数据结构中，仅列出了相关元素，以下是它们的含义：
- en: '`name` is the name of the pin controller.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是引脚控制器的名称。'
- en: '`pins`: An array of pin descriptors that describe all the pins that this controller
    can handle. It has to be noted that the controller side represents each pin/pad
    as an instance of `struct pinctrl_pin_desc`, defined as follows:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pins`: 描述此控制器可以处理的所有引脚的引脚描述符数组。需要注意的是，控制器方将每个引脚/垫片表示为`struct pinctrl_pin_desc`的实例，定义如下：'
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding data structure, `number` represents the unique pin number from
    the global pin number space of the pin controller, and `name` is the name of this
    pin.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述数据结构中，`number`表示来自引脚控制器全局引脚号空间的唯一引脚编号，`name`是该引脚的名称。
- en: '`npins`: The number of descriptors in the `pins` array, usually obtained using
    `ARRAY_SIZE()` in the `pins` field.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npins`: `pins`数组中的描述符数量，通常通过`ARRAY_SIZE()`在`pins`字段中获得。'
- en: '`pctlops` stores the pin control operation table, to support global concepts
    such as the grouping of pins. This is optional.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pctlops`存储引脚控制操作表，用于支持引脚分组等全局概念。这是可选的。'
- en: '`pmxops` represents the **pinmux** operations table if you support pinmuxing
    in your driver.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pmxops`表示如果您的驱动程序支持引脚多路复用，则为**pinmux**操作表。'
- en: '`confops`: The pin configuration operations table if you support pin configuration
    in your driver.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confops`: 如果您的驱动程序支持引脚配置，这是引脚配置操作表。'
- en: 'Once the appropriate callbacks are defined and this data structure has been
    initialized, it can be passed to `devm_pinctrl_register()`, defined as the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦适当的回调被定义，并且此数据结构已经初始化，它可以被传递给`devm_pinctrl_register()`，定义如下：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding function will register the pin controller with the system, returning
    in the meantime a pointer to an instance of `struct pinctrl_dev`, representing
    the pin controller device, passed as a parameter to most (if not all) of the callback
    operations exposed by the pin controller driver. On error, the function returns
    an error pointer, which can be handled with `PTR_ERR`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将把引脚控制器注册到系统，并同时返回一个指向`struct pinctrl_dev`实例的指针，表示引脚控制器设备，作为参数传递给引脚控制器驱动暴露的绝大多数（如果不是所有）回调操作。出现错误时，函数返回一个错误指针，可以通过`PTR_ERR`进行处理。
- en: 'The controller''s control, multiplexing, and configuration operation tables
    are to be set up according to the features supported by the underlying hardware.
    Their respective data structures are defined in the header files that must also
    be included in the driver, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的控制、多路复用和配置操作表应根据底层硬件支持的特性进行设置。它们各自的数据结构在头文件中定义，这些头文件必须包含在驱动程序中，具体如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When it comes to the pin control consumer interface, the following header must
    be used instead:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到引脚控制消费者接口时，必须使用以下头文件：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Before being accessed by consumer drivers, pins must be assigned to the devices
    that need to control them. The recommended way to assign pins to devices is from
    the **device tree** (**DT**). How pins groups are assigned in the DT closely depends
    on the platform, thus the pin controller driver and its binding.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在消费者驱动程序访问引脚之前，必须将引脚分配给需要控制它们的设备。推荐的引脚分配方式是通过**设备树**（**DT**）。引脚组如何在设备树中分配，密切依赖于平台，因此也与引脚控制器驱动程序及其绑定有关。
- en: 'Every pin control state is assigned a contiguous integer ID that starts at
    0\. A `name` property list can be used to map strings on top of these IDs to ensure
    that the same name always points to the same ID. It goes without saying that the
    set of states that must be defined in each device''s DT node is determined by
    the binding of this device. This binding also determines whether to define the
    set of state IDs that must be provided, or whether to define the set of state
    names that must be provided. In any case, two properties can be used to assign
    a pin configuration node to a device:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个引脚控制状态都会分配一个连续的整数ID，从0开始。可以使用`name`属性列表将字符串映射到这些ID上，以确保相同的名称始终指向相同的ID。不言而喻，必须在每个设备的设备树节点（DT节点）中定义的状态集由该设备的绑定决定。这个绑定还决定是否定义必须提供的状态ID集，或者是否定义必须提供的状态名称集。在任何情况下，都可以使用两个属性将引脚配置节点分配给设备：
- en: '`pinctrl-<ID>`: This allows you to provide the list of pin configurations needed
    for particular states of the device. It is a list of `phandles` identified by
    `<ID>`, each of which points to a pin configuration node. These referenced pin
    configuration nodes must be child nodes of (or nested in) the pin controller node
    they belong to. This property can accept multiple entries so that multiple groups
    of pins may be configured and used for a particular device state, allowing in
    the meantime to specify pins from different pin controllers.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinctrl-<ID>`：此项允许为设备的特定状态提供所需的引脚配置列表。它是一个由`<ID>`标识的`phandle`列表，每个`phandle`指向一个引脚配置节点。这些引用的引脚配置节点必须是它们所属引脚控制器节点的子节点（或嵌套节点）。该属性可以接受多个条目，以便为特定设备状态配置和使用多个引脚组，同时允许指定来自不同引脚控制器的引脚。'
- en: '`pinctrl-names`: This allows giving names to `pinctrl-<ID>` properties according
    to the state of the device owning the group(s) of pins. List entry 0 defines the
    name for the state whose ID is 0, list entry 1 for state ID 1, and so on. State
    ID 0 is commonly given the name `default`. A list of standardized states can be
    found in `include/linux/pinctrl/pinctrl-state.h`. However, clients or consumer
    drivers are free to implement any state they need, provided this state is documented
    in the device binding description.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinctrl-names`：此项允许根据设备拥有引脚组的状态为`pinctrl-<ID>`属性命名。列表条目0为ID为0的状态定义名称，条目1为ID为1的状态定义名称，以此类推。状态ID
    0通常命名为`default`。标准化状态的列表可以在`include/linux/pinctrl/pinctrl-state.h`中找到。然而，客户端或消费者驱动程序可以根据需要实现任何状态，只要该状态在设备绑定描述中有所记录。'
- en: 'Here is an excerpt of the DT, showing some device nodes, along with their pin
    control nodes. Let''s name this excerpt `pinctrl-excerpt`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是设备树的摘录，展示了一些设备节点以及它们的引脚控制节点。我们将此摘录命名为`pinctrl-excerpt`：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, a pin configuration is given in the form `<PIN_FUNCTION>
    <PIN_SETTING>`, where `<PIN_FUNCTION>` can be seen as the pin function or pin
    mode, and `<PIN_SETTING>` represents the pin''s electrical properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，引脚配置以`<PIN_FUNCTION> <PIN_SETTING>`的形式给出，其中`<PIN_FUNCTION>`可以看作是引脚功能或引脚模式，而`<PIN_SETTING>`表示引脚的电气特性：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the excerpt, `MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09` represents the pin function/mode,
    which is GPIO in this case, and `0x80000000` represents the pin settings or electrical
    properties.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个摘录中，`MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09`表示引脚功能/模式，在此情况下为GPIO，而`0x80000000`表示引脚设置或电气特性。
- en: 'Let''s consider another example as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个新的例子，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In that excerpt, `MX6QDL_PAD_EIM_D25__UART3_RX_DATA` represents the pin function,
    which is the RX line of UART3, and `0x1b0b1` represents its electrical settings.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个摘录中，`MX6QDL_PAD_EIM_D25__UART3_RX_DATA`表示引脚功能，是UART3的RX线路，而`0x1b0b1`表示其电气设置。
- en: 'The pin function is a macro whose value is meaningful for the pin controller
    driver only. These are generally defined in header files located in `arch/<arch>/boot/dts/`.
    If you use an UDOO quad, for example, which has an i.MX6 quad core (32-bit ARM),
    the pin function header would be `arch/arm/boot/dts/imx6q-pinfunc.h`. The following
    is the macro corresponding to the fifth line of the GPIO5 controller:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚功能是一个宏，其值对引脚控制器驱动程序有意义。通常，这些宏在`arch/<arch>/boot/dts/`目录下的头文件中定义。例如，如果使用的是UDOO
    quad，它具有i.MX6四核（32位ARM），那么引脚功能头文件为`arch/arm/boot/dts/imx6q-pinfunc.h`。以下是GPIO5控制器第五行对应的宏：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`<PIN_SETTING>` can be used to set up things such as pull-ups, pull-downs,
    keepers, drive strength, and so on. How it should be specified depends on the
    pin controller binding, and the meaning of its value depends on the SoC datasheet,
    generally in the IOMUX section. On i.MX6 IOMUXC, only the lower 17 bits are used
    for this purpose.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`<PIN_SETTING>`可用于设置诸如上拉、下拉、保持器、驱动强度等功能。如何指定这些设置取决于引脚控制器绑定，且其值的含义依赖于SoC数据手册，通常在IOMUX部分中可以找到。在i.MX6
    IOMUXC中，仅使用最低17位来实现此目的。'
- en: Back to `pinctrl-excerpt`, prior to selecting a pin group and applying its configuration,
    the driver must first obtain a handle to this group of pins using the `devm_inctrl_get()`
    function and then select the appropriate state using `pinctrl_lookup_state()`
    before finally applying the corresponding configuration state to hardware thanks
    to `pinctrl_select_state()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`pinctrl-excerpt`，在选择引脚组并应用其配置之前，驱动程序必须首先通过`devm_inctrl_get()`函数获取该引脚组的句柄，然后使用`pinctrl_lookup_state()`选择合适的状态，最后通过`pinctrl_select_state()`将相应的配置状态应用于硬件。
- en: 'The following is an example that shows how to grab a pin control group and
    apply its default configuration:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了如何抓取一个引脚控制组并应用其默认配置：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Like other resources (such as memory regions, clocks, and so on), it is a good
    practice to grab pins and apply their configuration from within the `probe()`
    function. However, this operation is so common that it has been integrated into
    the Linux device core as a step while probing devices. Thus, when a device is
    being probed, the device core will do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他资源（如内存区域、时钟等）一样，从 `probe()` 函数中抓取引脚并应用其配置是一个良好的实践。然而，这一操作如此常见，以至于它已被集成到 Linux
    设备核心中，作为设备探测过程中的一个步骤。因此，在设备探测时，设备核心会执行以下操作：
- en: Grab the pins assigned to the device that is just about to probe using `devm_pinctrl_get()`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `devm_pinctrl_get()` 抓取即将被探测的设备分配的引脚。
- en: Look for the default pin state (`PINCTRL_STATE_DEFAULT`) using `pinctrl_lookup_state()`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pinctrl_lookup_state()` 查找默认引脚状态（`PINCTRL_STATE_DEFAULT`）。
- en: Look in the meantime for an init (which means during the device initialization)
    pin state (`PINCTRL_STATE_INIT`) using the same API.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时使用相同的 API 查找初始化（即设备初始化期间）引脚状态（`PINCTRL_STATE_INIT`）。
- en: Apply the init pin state if any, otherwise apply the default pin state.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有初始化引脚状态，则应用它，否则应用默认引脚状态。
- en: If power management is enabled, look for the optional sleep (`PINCTRL_STATE_SLEEP`)
    and idle (`PINCTRL_STATE_IDLE`) pin states for later use, during power management
    related operations.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了电源管理，则查找可选的休眠（`PINCTRL_STATE_SLEEP`）和空闲（`PINCTRL_STATE_IDLE`）引脚状态，以便在后续的电源管理相关操作中使用。
- en: See the `pinctrl_bind_pins()` function (defined in `drivers/base/pinctrl.c`),
    and the `really_probe()` function (defined in `drivers/base/dd.c`), which calls
    the former. These functions will help you understand how pins are bound to the
    device on its probing path.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 `pinctrl_bind_pins()` 函数（定义在 `drivers/base/pinctrl.c` 中）和 `really_probe()`
    函数（定义在 `drivers/base/dd.c` 中），后者调用了前者。这些函数将帮助您了解如何在设备探测过程中将引脚绑定到设备。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`pinctrl_select_state()` internally calls `pinmux_enable_setting()`, which
    in turn calls `pin_request()` on each pin in the pin control (group of pins) node.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinctrl_select_state()` 内部调用 `pinmux_enable_setting()`，后者又在引脚控制（引脚组）节点中的每个引脚上调用
    `pin_request()`。'
- en: 'The `pinctrl_put()` function can be used to release a pin control that has
    been requested using the non-managed API, that is, `pinctrl_get()`. That said,
    you can use `devm_pinctrl_get_select()`, given the name of the state to select,
    in order to configure pinmux in a single shot. This function is defined in `include/linux/pinctrl/consumer.h`
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinctrl_put()` 函数可用于释放通过非管理 API，即 `pinctrl_get()` 请求的引脚控制。也就是说，您可以使用 `devm_pinctrl_get_select()`，给定要选择的状态名称，以便一次性配置引脚复用。此函数在
    `include/linux/pinctrl/consumer.h` 中定义，如下所示：'
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous prototype, `name` is the name of the state as written in the
    `pinctrl-name` property. If the name of the state is `default`, the helper `devm_pinctr_get_select_default()`
    can be used, which is a wrapper around `devm_pinctl_get_select()` as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`name` 是在 `pinctrl-name` 属性中编写的状态名称。如果状态名称是 `default`，可以使用辅助函数 `devm_pinctr_get_select_default()`，它是
    `devm_pinctrl_get_select()` 的一个封装，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we are familiar with the pin control subsystem (with both controller
    and consumer interfaces), we can learn how to deal with GPIO controllers, knowing
    that GPIO is an operating mode that a pin can work in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了引脚控制子系统（包括控制器和消费者接口），我们可以学习如何处理 GPIO 控制器，了解 GPIO 是引脚可以工作的操作模式。
- en: Dealing with the GPIO controller interface
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 GPIO 控制器接口
- en: The GPIO controller interface is designed around a single data structure, `struct
    gpio_chip`. This data structure provides a set of functions, among which are methods
    to establish GPIO direction (input and output), methods used to access GPIO values
    (get and set), methods to map a given GPIO to IRQ and return the associated Linux
    interrupt number, and the `debugfs` dump method (showing extra state like pull-up
    config). Apart from these functions, that data structure provides a flag to determine
    the nature of the controller, that is, to allow checking whether this controller's
    accessors may sleep or not. Still from within this data structure, the driver
    can set the GPIO base number, from which GPIO numbering should start.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 控制器接口围绕一个单一的数据结构 `struct gpio_chip` 设计。这个数据结构提供了一组函数，其中包括设置 GPIO 方向（输入和输出）的方法、用于访问
    GPIO 值（获取和设置）的方法、将特定 GPIO 映射到 IRQ 并返回相关 Linux 中断号的方法，以及 `debugfs` 转储方法（显示如拉高配置等附加状态）。除了这些函数外，该数据结构还提供了一个标志，用于确定控制器的性质，即允许检查该控制器的访问器是否可能进入休眠状态。在这个数据结构内，驱动程序还可以设置
    GPIO 基础编号，从此编号开始 GPIO 编号。
- en: 'Back to the code, a GPIO controller is represented as an instance of `struct
    gpio_chip`, defined in `<linux/gpio/driver.h>` as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码，GPIO 控制器表示为 `struct gpio_chip` 的一个实例，该结构体在 `<linux/gpio/driver.h>` 中定义如下：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the meanings of each element in the structure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构体中各个元素的含义：
- en: '`label`: This is the GPIO controller''s functional name. It could be a part
    number or the name of the SoC IP block implementing it.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是 GPIO 控制器的功能名称。它可以是一个零件编号，或者是实现该功能的 SoC IP 块的名称。'
- en: '`gpiodev`: This is the internal state container of the GPIO controller. It
    is also the structure through which the character device associated with this
    GPIO controller will be exposed.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpiodev`：这是 GPIO 控制器的内部状态容器。它也是通过该结构体暴露与该 GPIO 控制器相关联的字符设备。'
- en: '`request` is an optional hook for chip-specific activation. If provided, it
    is executed prior to allocating GPIO whenever you call `gpio_request()` or `gpiod_get()`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request` 是一个可选的挂钩，用于芯片特定的激活。如果提供，它会在每次调用 `gpio_request()` 或 `gpiod_get()`
    时，在分配 GPIO 之前执行。'
- en: '`free` is an optional hook for chip-specific deactivation. If provided, it
    is executed before the GPIO is deallocated whenever you call `gpiod_put()` or
    `gpio_free()`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free` 是一个可选的挂钩，用于芯片特定的停用。如果提供，它会在你调用 `gpiod_put()` 或 `gpio_free()` 时，在 GPIO
    被释放之前执行。'
- en: '`get_direction` is executed whenever you need to know the direction of the
    GPIO offset. The return value should be `0` to mean out, and `1` to mean in (the
    same as `GPIOF_DIR_XXX`) or a negative error.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_direction` 每当你需要知道 GPIO 偏移量的方向时执行。返回值应为 `0` 表示输出，`1` 表示输入（与 `GPIOF_DIR_XXX`
    相同），或者返回负错误码。'
- en: '`direction_input` configures the signal offset as input, or returns an error.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction_input` 将信号偏移量配置为输入，或者返回一个错误。'
- en: '`get` returns the value of the GPIO offset; for output signals, this returns
    either the value actually sensed or zero.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get` 返回 GPIO 偏移量的值；对于输出信号，这返回的是实际感测到的值，或者返回零。'
- en: '`set` assigns an output value to the GPIO offset.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set` 将输出值分配给 GPIO 偏移量。'
- en: '`set_multiple` is called when you need to assign output values for multiple
    signals defined by `mask`. If not provided, the kernel will install a generic
    hook that will walk through mask bits and execute `chip->set(i)` on each bit set.
    See here how you can implement this function:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_multiple` 在需要为由 `mask` 定义的多个信号分配输出值时调用。如果未提供，内核将安装一个通用挂钩，遍历掩码位，并在每个设置的位上执行
    `chip->set(i)`。请参见这里如何实现此功能：'
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`set_debounce` if supported by the controller, this hook is an optional callback
    provided to set the debounce time for the specified GPIO.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_debounce` 如果控制器支持，此挂钩是一个可选的回调函数，用于设置指定 GPIO 的去抖动时间。'
- en: '`to_irq` is an optional hook to provide GPIO to IRQ mapping. This is called
    whenever you want to execute the `gpio_to_irq()` or `gpiod_to_irq()` function.
    This implementation may not sleep.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_irq` 是一个可选的挂钩，用于提供 GPIO 到 IRQ 的映射。每当你想执行 `gpio_to_irq()` 或 `gpiod_to_irq()`
    函数时，它都会被调用。此实现可能不会进入休眠状态。'
- en: '`base` indicates the first GPIO number handled by this chip; or, if negative
    during registration, the kernel will automatically (dynamically) assign one.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base` 指示该芯片处理的第一个 GPIO 编号；或者，如果在注册时为负数，内核将自动（动态）分配一个编号。'
- en: '`ngpio` is the number of GPIOs this controller provides, starting from base
    to (`base` + `ngpio - 1`).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngpio` 是该控制器提供的 GPIO 数量，从 base 开始到（`base` + `ngpio - 1`）。'
- en: '`names`, if not `NULL`, must be a list (an array) of strings to use as alternative
    names for the GPIOs in this chip. The array must be `ngpio` sized, and any GPIO
    that does not need an alias may have its entry set to `NULL` in the array.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`names`，如果不是 `NULL`，必须是一个字符串数组，用作此芯片中 GPIO 的替代名称。该数组必须与 `ngpio` 的大小一致，任何不需要别名的
    GPIO 可以在数组中将其条目设置为 `NULL`。'
- en: '`can_sleep` is a Boolean flag to be set if `get()`/`set()` methods may sleep.
    It is the case for GPIO controllers (also known as GPIO expanders) sitting on
    buses such as I2C or SPI, whose accesses may lead to sleep. This means that if
    the chip supports IRQs, these IRQs must be threaded because the chip access may
    sleep when, for example, reading out the IRQ status registers. For a GPIO controller
    mapped to memory (part of SoC), this can be set to `false`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`can_sleep` 是一个布尔标志，表示 `get()`/`set()` 方法是否可能会使系统进入休眠状态。这对于那些位于 I2C 或 SPI 总线上的
    GPIO 控制器（也称为 GPIO 扩展器）来说是必需的，因为它们的访问可能会导致休眠。这意味着，如果芯片支持 IRQ，则这些 IRQ 必须使用线程处理，因为芯片访问可能会在读取
    IRQ 状态寄存器时导致休眠。对于映射到内存的 GPIO 控制器（SoC 的一部分），此值可以设置为 `false`。'
- en: Elements that are conditioned by the enabling of `CONFIG_GPIO_GENERIC` are related
    to a generic memory-mapped GPIO controller, with a standard register set.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `CONFIG_GPIO_GENERIC` 启用的元素与通用内存映射的 GPIO 控制器有关，具有标准寄存器集。
- en: '`irq`: The IRQ chip of this GPIO controller if the controller can map GPIOs
    to IRQs. In such cases, this field must be set up before the GPIO chip is registered.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`：如果该 GPIO 控制器可以将 GPIO 映射到 IRQ，则为该控制器的 IRQ 芯片。在这种情况下，必须在注册 GPIO 控制器之前设置此字段。'
- en: '`valid_mask`: If not `NULL`, this element contains a bitmask of GPIOs that
    are valid to be used from the chip.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid_mask`：如果不是 `NULL`，则此元素包含一个 GPIO 的位掩码，表示该芯片中哪些 GPIO 是有效的。'
- en: '`of_node` is a pointer to the device tree node representing this GPIO controller.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_node` 是指向表示该 GPIO 控制器的设备树节点的指针。'
- en: '`of_gpio_n_cells` is the number of cells used to form the GPIO specifier.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_gpio_n_cells` 是用于形成 GPIO 说明符的单元数量。'
- en: '`of_xlate` is a callback to translate a device tree GPIO specifier into a chip
    relative GPIO number and flags. This hook is invoked when a GPIO line from this
    controller is specified in the device tree and must be parsed. If not provided,
    the GPIO core will set it to `of_gpio_simple_xlate()` by default, which is a generic
    GPIO core helper that supports two cell specifiers. The first cell identifies
    the GPIO number, and the second one, the GPIO flags. Additionally, when setting
    the default callback, `of_gpio_n_cells` will be set to `2`. If the GPIO controller
    needs one or more than two cell specifiers, you''ll have to implement the corresponding
    translation callback.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_xlate` 是一个回调函数，用于将设备树中的 GPIO 说明符转换为与芯片相关的 GPIO 编号和标志。当设备树中指定此控制器的 GPIO
    引脚时，将调用此钩子进行解析。如果未提供此回调，GPIO 核心将默认设置为 `of_gpio_simple_xlate()`，这是一个通用的 GPIO 核心助手，支持两单元说明符。第一个单元表示
    GPIO 编号，第二个单元表示 GPIO 标志。此外，在设置默认回调时，`of_gpio_n_cells` 将设置为 `2`。如果 GPIO 控制器需要一个或多个单元说明符，则必须实现相应的翻译回调。'
- en: Each GPIO controller exposes a number of signals that are identified in function
    calls by offset values in the range of `0` to (`ngpio - 1`). When those GPIO lines
    are referenced through calls such as `gpio_get_value(gpio)`, the offset is determined
    by subtracting `base` from the GPIO number and passed to the underlying driver
    function (`gpio_chip->get()` for example). The controller driver should then have
    the logic to map this offset to the control/status register associated with the
    GPIO.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 GPIO 控制器都会暴露多个信号，这些信号在函数调用中通过 `0` 到 (`ngpio - 1`) 范围内的偏移值来标识。当通过 `gpio_get_value(gpio)`
    等调用引用这些 GPIO 引脚时，偏移量由将 `base` 从 GPIO 编号中减去得到，并传递给底层驱动程序函数（例如 `gpio_chip->get()`）。然后，控制器驱动程序应具有将此偏移量映射到与
    GPIO 相关的控制/状态寄存器的逻辑。
- en: Writing a GPIO controller driver
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 GPIO 控制器驱动程序
- en: 'A GPIO controller needs nothing but the set of callbacks that correspond to
    the features it supports. After every callback of interest has been defined and
    other fields set, the driver should call `devm_gpiochip_add_data()` on the configured
    `struct gpio_chip` structure in order to register the controller with the kernel.
    You have probably guessed that you''d better use the managed API (the `devm_`
    prefix) since it takes care of chip removal when necessary and releasing resources.
    If, however, you used the classical method, you will have to use `gpiochip_remove()`
    to remove the chip if necessary:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 GPIO 控制器只需要与其支持的功能相对应的一组回调。定义完所有感兴趣的回调并设置其他字段后，驱动程序应在配置的`struct gpio_chip`结构上调用`devm_gpiochip_add_data()`，以便将控制器注册到内核中。你可能已经猜到，最好使用托管
    API（以`devm_`为前缀），因为它会在必要时处理芯片移除和资源释放。如果你使用了传统方法，则必须使用`gpiochip_remove()`在必要时移除芯片：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding prototypes, `gc` is the chip to register and `data` is the
    driver's private data associated with this chip. They both return a negative error
    code if the chip can't be registered, such as because `gc->base` is invalid or
    already associated with a different chip. Otherwise, they return zero as a success
    code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`gc`是要注册的芯片，`data`是与该芯片相关的驱动程序私有数据。如果芯片无法注册（例如，`gc->base`无效或已与其他芯片关联），它们将返回一个负的错误代码。否则，它们将返回零作为成功代码。
- en: There are, however, pin controllers that are tightly coupled to the GPIO chip,
    and both are implemented in the same driver, much of which being in `drivers/pinctrl/pinctrl-*.c`.
    In such drivers, when `gpiochip_add_data()` is invoked, for device-tree-supported
    systems, the GPIO core will check the pin control's device node for the `gpio-ranges`
    property. If it is present, it will take care of adding the pin ranges for the
    driver.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也有一些引脚控制器与 GPIO 芯片紧密耦合，二者在同一个驱动程序中实现，很多代码都在`drivers/pinctrl/pinctrl-*.c`中。在这样的驱动程序中，当调用`gpiochip_add_data()`时，对于支持设备树的系统，GPIO
    核心将检查引脚控制的设备节点是否具有`gpio-ranges`属性。如果存在，它将负责为驱动程序添加引脚范围。
- en: 'However, the driver must call `gpiochip_add_pin_range()` in order to be compatible
    with older, existing device tree files that don''t set the `gpio-ranges` attribute
    or systems that use ACPI. The following is an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，驱动程序必须调用`gpiochip_add_pin_range()`，以便与不设置`gpio-ranges`属性的旧设备树文件或使用 ACPI 的系统兼容。以下是一个示例：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once more, it must be noted that the preceding is used just for backward compatibility
    for these old `pinctrl` nodes without the `gpio-ranges` property. Otherwise, calling
    `gpiochip_add_pin_range()` directly from a device tree-supported pin controller
    driver is deprecated. Please see *Section 2.1* of `Documentation/devicetree/bindings/gpio/gpio.txt`
    on how to bind pin controller and GPIO drivers via the `gpio-ranges` property.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，前述内容仅用于向后兼容那些没有`gpio-ranges`属性的旧`pinctrl`节点。否则，从支持设备树的引脚控制器驱动程序直接调用`gpiochip_add_pin_range()`已被弃用。请参阅`Documentation/devicetree/bindings/gpio/gpio.txt`中的*第2.1节*，了解如何通过`gpio-ranges`属性绑定引脚控制器和
    GPIO 驱动程序。
- en: We can see how easy it is to write a GPIO controller driver. In the book sources
    repository, you will find a working GPIO controller driver, for the MCP23016 I2C
    I/O expander from microchip, whose datasheet is available at [http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到编写一个 GPIO 控制器驱动程序是多么容易。在本书的源码仓库中，你将找到一个功能正常的 GPIO 控制器驱动程序，适用于来自 Microchip
    的 MCP23016 I2C I/O 扩展器，其数据手册可以在[http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/20090C.pdf)找到。
- en: 'To write such drivers, the following header should be included:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写此类驱动程序，应该包含以下头文件：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Following is an excerpt from the driver we have written for our controller:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们为控制器编写的驱动程序的摘录：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding excerpt, the GPIO chip data structure has been set up before
    being passed to `devm_gpiochip_get_data()`, which is called to register the GPIO
    controller with the system. As a result, a GPIO character device node will appear
    under `/dev`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，GPIO 芯片数据结构在传递给`devm_gpiochip_get_data()`之前已经设置好，该函数用于将 GPIO 控制器注册到系统中。结果，GPIO
    字符设备节点将出现在`/dev`下。
- en: IRQ chip enabled GPIO controllers
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 IRQ 芯片的 GPIO 控制器
- en: 'IRQ chip support can be enabled in a GPIO controller by setting up the `struct
    gpio_irq_chip` structure embedded into this GPIO controller data structure. This
    `struct gpio_irq_chip` structure is used to group all fields related to interrupt
    handling in a GPIO chip and is defined as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置嵌入到 GPIO 控制器数据结构中的 `struct gpio_irq_chip` 结构来启用 IRQ 芯片支持。这个 `struct gpio_irq_chip`
    结构用于将与 GPIO 芯片的中断处理相关的所有字段进行分组，定义如下：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There are architectures that may be multiple interrupt controllers involved
    in delivering an interrupt from the device to the target CPU. This feature is
    enabled in the kernel by setting the `CONFIG_IRQ_DOMAIN_HIERARCHY` config option.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些架构可能涉及多个中断控制器，负责将设备的中断传递到目标 CPU。这个功能可以通过设置内核中的 `CONFIG_IRQ_DOMAIN_HIERARCHY`
    配置选项来启用。
- en: 'In the previous data structure, some elements have been omitted. These are
    elements conditioned by `CONFIG_IRQ_DOMAIN_HIERARCHY`, that is, IRQ domain hierarchy
    related fields, which we won''t discuss in this chapter. For the remaining elements,
    the following are their definitions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，一些元素被省略了。这些是由 `CONFIG_IRQ_DOMAIN_HIERARCHY` 条件控制的元素，即 IRQ 域层次结构相关的字段，本章不会讨论这些内容。对于剩余的元素，以下是它们的定义：
- en: '`chip` is the IRQ chip implementation.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip` 是 IRQ 芯片的实现。'
- en: '`domain` is the IRQ interrupt translation domain associated with `chip`; it
    is responsible for mapping between the GPIO hardware IRQ number and Linux IRQ
    number.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain` 是与 `chip` 相关的 IRQ 中断转换域；它负责在 GPIO 硬件 IRQ 编号和 Linux IRQ 编号之间进行映射。'
- en: '`domain_ops` represents the set of interrupt domain operations associated with
    the IRQ domain.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain_ops` 表示与 IRQ 域相关联的一组中断域操作。'
- en: '`handler` is the high-level interrupt flow handler (typically a predefined
    IRQ core function) for GPIO IRQs. There is a note on this field later in the section.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler` 是 GPIO IRQ 的高级中断流处理程序（通常是预定义的 IRQ 核心函数）。本节稍后会对该字段进行说明。'
- en: '`default_type` is the default IRQ triggering type applied during GPIO driver
    initialization.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_type` 是在 GPIO 驱动程序初始化期间应用的默认 IRQ 触发类型。'
- en: '`parent_handler` is the interrupt handler for the GPIO chip''s parent interrupts.
    It may be `NULL` if the parent interrupts are nested rather than chained. Moreover,
    setting this element to `NULL` will allow handling the parent IRQ in the driver.
    `gpio_chip.can_sleep` cannot be set to `true` if this handler is supplied because
    you cannot have chained interrupts on a chip that may sleep.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_handler` 是 GPIO 芯片父中断的中断处理程序。如果父中断是嵌套的而不是链式的，这个字段可能为 `NULL`。此外，将此元素设置为
    `NULL` 将允许在驱动程序中处理父 IRQ。如果提供了该处理程序，则 `gpio_chip.can_sleep` 不能设置为 `true`，因为无法在可能休眠的芯片上处理链式中断。'
- en: '`parent_handler_data` and `parent_handler_data_array` are data associated with,
    and passed to, the handler for the parent interrupt. This can either be a single
    pointer if `per_parent_data` is `false`, or an array of `num_parents` pointers
    otherwise. If `per_parent_data` is `true`, `parent_handler_data_array` cannot
    be `NULL`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_handler_data` 和 `parent_handler_data_array` 是与父中断关联的数据，并传递给父中断的处理程序。如果
    `per_parent_data` 为 `false`，则它可以是一个单一的指针；如果为 `true`，则是一个包含 `num_parents` 指针的数组。若
    `per_parent_data` 为 `true`，则 `parent_handler_data_array` 不能为 `NULL`。'
- en: '`num_parents` is the number of interrupt parents for the GPIO chip.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_parents` 是 GPIO 芯片的中断父级数量。'
- en: '`parents` is a list of interrupt parents of the GPIO chip. Because the driver
    owns this list, the core will only refer to it, not edit it.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parents` 是 GPIO 芯片的中断父级列表。由于驱动程序拥有这个列表，核心只会引用它，而不会修改它。'
- en: '`map` is a list of interrupt parents for each line of the GPIO chip.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map` 是每个 GPIO 芯片引脚的中断父级列表。'
- en: '`threaded` indicates whether the interrupt handling is threaded (uses nested
    threads).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded` 表示中断处理是否是线程化的（使用嵌套线程）。'
- en: '`per_parent_data` tells whether `parent_handler_data_array` describes a `num_parents`
    sized array to be used as parent data.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`per_parent_data` 指示 `parent_handler_data_array` 是否描述一个 `num_parents` 大小的数组，用作父数据。'
- en: '`init_hw` is an optional routine for initializing hardware before an IRQ chip
    will be added. This is extremely beneficial when a driver has to clear IRQ-related
    registers in order to avoid unwanted events.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_hw` 是一个可选的例程，用于在添加 IRQ 芯片之前初始化硬件。当驱动程序需要清除与 IRQ 相关的寄存器，以避免不必要的事件时，这非常有用。'
- en: '`init_valid_mask` is an optional callback that can be used to initialize `valid_mask`,
    which is used if not all GPIO lines are valid interrupts. There might be lines
    that just cannot fire interrupts, and this callback, when defined, is passed a
    bitmap in `valid_mask`, which will have `ngpios` bits from `0..(ngpios-1)` set
    to `1` as valid. The callback can then directly set some bits to `0` if they cannot
    be used for interrupts.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_valid_mask`是一个可选的回调函数，可以用于初始化`valid_mask`，如果并非所有GPIO线路都可以作为有效的中断源，则使用此回调。可能存在一些无法触发中断的线路，当定义此回调时，它会接收到`valid_mask`中的位图，该位图会将`ngpios`个比特位（从`0..(ngpios-1)`）设置为`1`，表示有效。回调函数可以直接将一些位设置为`0`，如果这些线路不能用于中断。'
- en: '`valid_mask`, if not `NULL`, contains a bitmask of GPIOs that are valid for
    inclusion in the IRQ domain of the chip.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid_mask` 如果不是 `NULL`，则包含一个GPIO位掩码，表示哪些GPIO是有效的，可以包含在芯片的IRQ域中。'
- en: '`first` is necessary in the case of static IRQ allocation. If set, `irq_domain_add_simple()`
    will allocate (starting from this value) and map all IRQs during initialization.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first` 在静态IRQ分配的情况下是必需的。如果设置了此选项，`irq_domain_add_simple()`将在初始化期间分配（从该值开始）并映射所有IRQ。'
- en: '`irq_enable`, `irq_disable`, `irq_unmask`, and `irq_mask` respectively store
    old `irq_chip.irq_enable`, `irq_chip.irq_disable`, `irq_chip.irq_unmask`, and
    `irq_chip.irq_mask` callbacks. See [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*, for a detailed explanation.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_enable`、`irq_disable`、`irq_unmask` 和 `irq_mask` 分别存储了旧的 `irq_chip.irq_enable`、`irq_chip.irq_disable`、`irq_chip.irq_unmask`
    和 `irq_chip.irq_mask` 回调函数。详细说明请参见 [*第13章*](B17934_13_Epub.xhtml#_idTextAnchor194)，*揭开内核IRQ框架的神秘面纱*。'
- en: Under the premise that your interrupts are 1-to-1 mapped to the GPIO line index,
    `gpiolib` will handle a significant portion of overhead code. In this 1-to-1 mapping,
    GPIO line offset 0 maps to hardware IRQ 0, GPIO line offset `1` maps to hardware
    IRQ `1`, and so on until GPIO line offset `ngpio-1`, which maps to hardware IRQ
    `ngpio-1`. The bitmask `valid_mask` and the flag `need_valid_mask` in `gpio_irq_chip`
    can be used to mask off some lines as invalid for associating with IRQs, provided
    some GPIO lines do not have corresponding IRQs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设你的中断是1对1映射到GPIO线路索引的前提下，`gpiolib`将处理大量的开销代码。在这种1对1映射中，GPIO线路偏移量0映射到硬件IRQ
    0，GPIO线路偏移量`1`映射到硬件IRQ `1`，以此类推，直到GPIO线路偏移量`ngpio-1`，它映射到硬件IRQ `ngpio-1`。位掩码`valid_mask`和`gpio_irq_chip`中的`need_valid_mask`标志可以用来屏蔽掉一些无效的GPIO线路，防止它们与IRQ关联，前提是某些GPIO线路没有对应的IRQ。
- en: 'We can divide GPIO IRQ chips into two broad categories:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将GPIO IRQ芯片分为两大类：
- en: '**Cascaded interrupt chips**: This indicates that the GPIO chip has a single
    common interrupt output line that is triggered by any enabled GPIO line on that
    chip. The interrupt output line is subsequently routed to a parent interrupt controller
    one level up, which in the simplest case is the system''s primary interrupt controller.
    An IRQ chip implements this by inspecting bits inside the GPIO controller to determine
    which line fired it. To figure this out, the IRQ chip part of the driver will
    need to inspect registers, and it will almost certainly need to acknowledge that
    it is handling the interrupt by clearing some bits (sometimes implicitly, by simply
    reading a status register), as well as setting up configurations such as edge
    sensitivity (rising or falling edge or a high/low level interrupt, for example).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**级联中断芯片**：这表示GPIO芯片具有一条公共的中断输出线路，该线路会被该芯片上任何启用的GPIO线路触发。该中断输出线路随后会被路由到上一级的父中断控制器，在最简单的情况下就是系统的主中断控制器。IRQ芯片通过检查GPIO控制器内部的位来实现此功能，以确定是哪一条线路触发了中断。为了弄清楚这一点，驱动程序中的IRQ芯片部分需要检查寄存器，几乎肯定需要通过清除一些位来确认它正在处理该中断（有时通过简单地读取状态寄存器来隐式完成），并且还需要设置诸如边缘敏感性（例如上升沿、下降沿或高/低电平中断等）等配置。'
- en: '**Hierarchical interrupt chips**: This means that each GPIO line is connected
    to a parent interrupt controller one level up by a dedicated IRQ line. It is not
    necessary to query the GPIO hardware to determine which line has fired, but you
    might need to acknowledge the interrupt and configure edge sensitivity.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次化中断芯片**：这意味着每条GPIO线路通过一条专用的IRQ线路连接到上一级的父中断控制器。无需查询GPIO硬件即可确定哪条线路触发了中断，但你可能需要确认中断并配置边缘敏感性。'
- en: 'Cascaded GPIO IRQ chips usually fall in one of three categories:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 级联GPIO IRQ芯片通常可以分为以下三类：
- en: '**Chained cascaded GPIO IRQ chips**: These are the types that are usually seen
    on SoCs. This means that the GPIOs have a fast IRQ flow handler that is called
    in a chain from the parent IRQ handler, which is usually the system interrupt
    controller. This means that the parent IRQ chip will immediately call the GPIO
    IRQ chip handler while holding the IRQs disabled. In its interrupt handler, the
    GPIO IRQ chip will then call something similar to this:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链式级联 GPIO IRQ 芯片**：这类芯片通常出现在 SoC 上。也就是说，GPIO 有一个快速的 IRQ 流量处理程序，该处理程序会在父 IRQ
    处理程序（通常是系统中断控制器）的链式调用下被调用。这意味着父 IRQ 芯片会立即调用 GPIO IRQ 芯片的处理程序，同时禁用 IRQ。在其中断处理程序中，GPIO
    IRQ 芯片将调用类似如下的内容：'
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because everything happens directly in the callback, chained GPIO IRQ chips
    cannot set the `.can_sleep` flag on `struct gpio_chip` to `true`. In this case,
    no slow bus traffic like I2C can be used.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都发生在回调中，链式 GPIO IRQ 芯片无法将 `.can_sleep` 标志设置为 `true`。因此，不能使用像 I2C 这样的慢速总线流量。
- en: '`CHAINED GPIO IRQCHIPS`, but they don''t use chained IRQ handlers. GPIO IRQs
    are instead dispatched via a generic IRQ handler, which is specified using `request_irq()`.
    In this IRQ handler, the GPIO IRQ chip will then end up calling something similar
    to the following sequence:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`链式 GPIO IRQCHIPS`，但它们不使用链式 IRQ 处理程序。GPIO IRQ 会通过通用的 IRQ 处理程序进行分发，该处理程序是通过
    `request_irq()` 指定的。在这个 IRQ 处理程序中，GPIO IRQ 芯片最终会调用类似以下的代码：'
- en: '[PRE20]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Nested thread GPIO IRQ chips**: Off-chip GPIO expanders and any other GPIO
    IRQ chip sitting on a sleeping bus, such as I2C or SPI, fall under this category.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套线程 GPIO IRQ 芯片**：离芯片的 GPIO 扩展器以及任何其他处于睡眠总线上的 GPIO IRQ 芯片，如 I2C 或 SPI，均属于此类别。'
- en: 'Of course, such drivers who require sluggish bus traffic to read out IRQ status
    and other information, traffic which may result in further IRQs, cannot be accommodated
    in a rapid IRQ handler with IRQs disabled. Instead, they must create a thread
    and then mask the parent IRQ line until the interrupt is handled by the driver.
    This driver''s distinguishing feature is that it calls something like the following
    in its interrupt handler:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这类驱动程序需要通过缓慢的总线流量来读取 IRQ 状态和其他信息，这些流量可能会导致进一步的 IRQ，因此不能在禁用 IRQ 的快速 IRQ 处理程序中处理。相反，它们必须创建一个线程，并在中断被驱动程序处理之前屏蔽父
    IRQ 线。此类驱动程序的显著特点是它在中断处理程序中会调用类似以下的代码：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Threaded GPIO IRQ chips are distinguished by the fact that they set the `.can_sleep`
    flag on `struct gpio_chip` to `true`, indicating that the chip can sleep when
    accessing the GPIOs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 线程化 GPIO IRQ 芯片的特点在于，它们将 `.can_sleep` 标志设置为 `true`，表示在访问 GPIO 时该芯片可以进入休眠状态。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is worth recalling that `gpio_irq_chip.handler` is the interrupt flow handler.
    It is the high-level IRQ-events handler, the one that calls the underlying handlers
    registered by client drivers using `request_irq()` or `request_threaded_irq()`.
    Its value depends on the IRQ being edge- or level-triggered. It is most often
    a predefined IRQ core function, one between `handle_simple_irq`, `handle_edge_irq`,
    and `handle_level_irq`. These are all kernel helper functions that do some operations
    before and after calling the real IRQ handler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 值得回顾的是，`gpio_irq_chip.handler` 是中断流量处理程序。它是高级的 IRQ 事件处理程序，用于调用客户端驱动程序通过 `request_irq()`
    或 `request_threaded_irq()` 注册的底层处理程序。其值取决于 IRQ 是否是边缘触发或电平触发。它通常是一个预定义的 IRQ 核心函数，介于
    `handle_simple_irq`、`handle_edge_irq` 和 `handle_level_irq` 之间。这些都是内核助手函数，它们在调用真正的
    IRQ 处理程序之前和之后执行一些操作。
- en: When the parent IRQ handler calls `generic_handle_irq()` or `handle_nested_irq()`,
    the IRQ core will look for the IRQ descriptor structure (Linux's view of an interrupt)
    corresponding to the Linux IRQ number passed as an argument (`struct irq_desc
    *desc = irq_to_desc(irq)`) and calling `generic_handle_irq_desc()` on this descriptor,
    which will result in `desc->handle_irq(desc)`. You should note that `desc->handle_irq`
    corresponds to the high-level IRQ handler supplied earlier, which has been assigned
    to the IRQ descriptor using `irq_set_chip_and_handler()` during the mapping of
    this IRQ. Guess what, the mapping of these GPIO IRQs is done in `gpiochip_irq_map`,
    which is the `.map` callback of the default IRQ domain operation table (`gpiochip_domain_ops`)
    assigned by the GPIO core to the GPIO IRQ chip if not provided by the driver.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当父中断处理程序调用 `generic_handle_irq()` 或 `handle_nested_irq()` 时，中断核心将查找与传递的 Linux
    IRQ 编号对应的 IRQ 描述符结构（Linux 对中断的视图，`struct irq_desc *desc = irq_to_desc(irq)`），并在该描述符上调用
    `generic_handle_irq_desc()`，这将导致 `desc->handle_irq(desc)`。你应该注意，`desc->handle_irq`
    对应的是之前提供的高级 IRQ 处理程序，该处理程序在通过 `irq_set_chip_and_handler()` 映射此 IRQ 时已分配给 IRQ 描述符。猜猜看，这些
    GPIO IRQ 的映射是通过 `gpiochip_irq_map` 完成的，这是默认 IRQ 域操作表（`gpiochip_domain_ops`）的 `.map`
    回调，如果驱动程序未提供，它将由 GPIO 核心分配给 GPIO IRQ 芯片。
- en: To summarize, `desc->handle_irq = gpio_irq_chip.handler`, which may be `handle_level_irq`,
    `handle_simple_irq`, `handle_edge_irq`, or (rarely) a driver-provided function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`desc->handle_irq = gpio_irq_chip.handler`，它可能是 `handle_level_irq`、`handle_simple_irq`、`handle_edge_irq`
    或（很少）由驱动程序提供的函数。
- en: Example of adding IRQ chip support in a GPIO chip
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 GPIO 芯片中添加 IRQ 芯片支持的示例
- en: In this section, we will demonstrate how to add the support of an IRQ chip into
    a GPIO controller driver. To do that, we will update our initial driver, more
    precisely, the probe method, as well as implementing an interrupt handler, which
    will hold the IRQ handling logic.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何将 IRQ 芯片的支持添加到 GPIO 控制器驱动程序中。为此，我们将更新我们最初的驱动程序，更具体地说，是更新探测方法，并实现一个中断处理程序，该处理程序将包含
    IRQ 处理逻辑。
- en: 'Let''s consider the following figure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图示：
- en: '![Figure 16.1 – Multiplexing IRQs'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 16.1 – 中断复用'
- en: '](img/B17934_16_001.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_16_001.jpg)'
- en: Figure 16.1 – Multiplexing IRQs
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 中断复用
- en: In the previous figure, let's consider that we have configured `io_0` and `io_1`
    as interrupt lines (this is what `DeviceA` and `deviceB` see).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的图示中，假设我们已经将 `io_0` 和 `io_1` 配置为中断线（这是 `DeviceA` 和 `deviceB` 所看到的）。
- en: Whether an interrupt happens on `io_0` or `io_1`, the same parent interrupt
    line will be raised on the GPIO chip. At this step, the GPIO chip driver must
    figure out, by reading the GPIO status register of the GPIO controller, which
    GPIO line (`io_0` or `io_1`) has really fired the interrupt. This is how, in the
    case of the MCP23016 chip, a single interrupt line (the parent actually) can be
    a multiplex for 16 GPIO interrupts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 无论中断是否发生在 `io_0` 或 `io_1`，相同的父中断线将在 GPIO 芯片上被触发。在此步骤中，GPIO 芯片驱动程序必须通过读取 GPIO
    控制器的 GPIO 状态寄存器，找出哪个 GPIO 线路（`io_0` 或 `io_1`）真正触发了中断。就像在 MCP23016 芯片的案例中一样，单一的中断线（实际是父中断线）可以用于复用
    16 个 GPIO 中断。
- en: Now let's update the initial GPIO controller driver. It must be noted that because
    the device sits on a slow bus, we have no choice but to implement nested (threaded)
    interrupt flow handling.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新最初的 GPIO 控制器驱动程序。必须注意的是，由于该设备位于一个较慢的总线上，我们别无选择，只能实现嵌套（线程化）中断流处理。
- en: 'We start by defining our IRQ chip data structure, with a set of callbacks that
    can be used by the IRQ core. The following is an excerpt:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义 IRQ 芯片数据结构开始，其中包含 IRQ 核心可以使用的一组回调函数。以下是摘录：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding, the callbacks that have been defined depend on the need. In
    our case, we have only implemented interrupt (un)masking related callbacks, as
    well as the callback allowing you to set the IRQ type. To see the full description
    of a `struct irq_chip` structure, you can refer to [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述内容中，已定义的回调函数取决于需要。在我们的案例中，我们只实现了与中断（取消）屏蔽相关的回调函数，以及允许设置 IRQ 类型的回调函数。要查看 `struct
    irq_chip` 结构的完整描述，您可以参考 [*第13章*](B17934_13_Epub.xhtml#_idTextAnchor194)，*揭开内核
    IRQ 框架的面纱*。
- en: 'Now that the IRQ chip data structure has been set up, we can modify the probe
    method as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 IRQ 芯片数据结构已经设置完成，我们可以按照以下方式修改探测方法：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous probe method update, we first initialized the `struct gpio_irq_chip`
    data structure embedded into `struct gpio_chip`, and then we registered an IRQ
    handler, which will act as the parent IRQ handler, responsible for enquiring the
    underlying GPIO chip for any IRQ-enabled GPIOs that have changed, and then running
    their IRQ handlers, if any.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的探测方法更新中，我们首先初始化了嵌入到`struct gpio_chip`中的`struct gpio_irq_chip`数据结构，然后注册了一个IRQ处理程序，该处理程序作为父级IRQ处理程序，负责查询底层GPIO芯片，检查任何启用了IRQ的GPIO是否发生变化，并在有变化时运行其IRQ处理程序。
- en: 'Finally, the following is our IRQ handler, which must have been implemented
    before the `probe` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是我们的IRQ处理程序，必须在`probe`函数之前实现：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our interrupt handler, we simply read the current GPIO, and we compare it
    with the old status to determine GPIOs that have changes. All the tricks are handled
    by `handle_nested_irq()`, which is explained in [*Chapter 13*](B17934_13_Epub.xhtml#_idTextAnchor194),
    *Demystifying the Kernel IRQ Framework*, as well.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的中断处理程序中，我们简单地读取当前GPIO，并将其与旧状态进行比较，以确定发生变化的GPIO。所有的技巧都由`handle_nested_irq()`处理，具体说明请参见[*第13章*](B17934_13_Epub.xhtml#_idTextAnchor194)，*揭秘内核IRQ框架*。
- en: Now that we are done and are familiar with the implementation of IRQ chips in
    GPIO controller drivers, we can learn about the binding of these GPIO controllers,
    which will allow declaring the GPIO chip hardware in the device tree in a way
    the driver understands.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了并且熟悉了GPIO控制器驱动程序中IRQ芯片的实现，我们可以学习这些GPIO控制器的绑定，这将允许在设备树中声明GPIO芯片硬件，驱动程序可以理解。
- en: GPIO controller bindings
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO控制器绑定
- en: The device tree is the de facto standard to declare and describe devices on
    embedded platforms, especially on ARM architectures. It this then recommended
    for new drivers to provide the associated device bindings.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是嵌入式平台上声明和描述设备的事实标准，特别是在ARM架构中。因此，建议新的驱动程序提供相关的设备绑定。
- en: 'Back to GPIO controllers, there are mandatory properties that need to be provided:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 回到GPIO控制器，有一些强制性的属性需要提供：
- en: '`compatible`: This is the list of strings to match the driver(s) that will
    handle this device.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compatible`：这是一个字符串列表，用于匹配将处理该设备的驱动程序。'
- en: '`gpio-controller`: This is a property that indicates to the device tree core
    that this node represents a GPIO controller.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpio-controller`：这是一个属性，表示此节点代表一个GPIO控制器，告知设备树核心。'
- en: '`gpio-cells`: Tells how many cells are used to describe a GPIO specifier. It
    should correspond to `gpio_chip.of_gpio_n_cells`, or to a value that `gpio_chip.of_xlate`
    can deal with. It is typically `<2>` for a less complex controller, with the first
    cell identifying the GPIO number, and the second defining the flags.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpio-cells`：表示用于描述GPIO说明符的单元数。它应与`gpio_chip.of_gpio_n_cells`对应，或者与`gpio_chip.of_xlate`可以处理的值相匹配。对于一个不太复杂的控制器，通常是`<2>`，第一个单元表示GPIO编号，第二个单元定义标志位。'
- en: 'There are additional mandatory properties to define if the GPIO controller
    has IRQ chip support, that is, if this controller allows mapping its GPIO lines
    to IRQs. With such GPIO controllers, the following mandatory properties must be
    provided:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果GPIO控制器支持IRQ芯片功能，则还需要定义额外的强制性属性，即该控制器是否允许将其GPIO线路映射到IRQ。对于这样的GPIO控制器，必须提供以下强制性属性：
- en: '`interrupt-controller`: Some controllers provide IRQs mapped to the GPIOs.
    In that case, the property `#interrupt-cells` should be set too and usually you
    use `2`, but it depends on your needs. The first cell is the pin number, and the
    second represents the interrupt flags.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-controller`：某些控制器提供映射到GPIO的IRQ。在这种情况下，属性`#interrupt-cells`也应该设置，通常使用`2`，但这取决于您的需求。第一个单元是引脚编号，第二个单元表示中断标志。'
- en: '`#interrupt-cells`: This must be defined as a value supported by the `xlate`
    hook of the IRQ domain, that is, `irq_domain_ops.xlate`. It is common for this
    hook to be set with `irq_domain_xlate_twocell`, which is a generic kernel IRQ
    core helper able to handle a two-cell specifier.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#interrupt-cells`：必须定义为IRQ域的`xlate`钩子支持的值，即`irq_domain_ops.xlate`。通常，`irq_domain_xlate_twocell`会作为这个钩子的设置，这是一个通用的内核IRQ核心辅助程序，能够处理一个二元单元说明符。'
- en: 'From the properties listed, we can declare our GPIO controller under its bus
    node, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从列出的属性中，我们可以在其总线节点下声明GPIO控制器，如下所示：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is all for the controller side. In order to demonstrate how clients can
    consume resources provided by the MCP23016, let''s consider the following scenario:
    we have two devices, device A, named `foo`, and device B, named `bar`. The `bar`
    device consumes two GPIO lines from our controller (they will be used in output
    mode), and the `foo` device would like to map a GPIO to IRQ. This configuration
    could be declared in the device tree as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是控制器端的所有内容。为了展示客户端如何使用MCP23016提供的资源，假设我们有两个设备，设备A，名为`foo`，设备B，名为`bar`。`bar`设备从我们的控制器中消耗了两个GPIO线（它们将用于输出模式），而`foo`设备希望将一个GPIO映射到IRQ。这个配置可以在设备树中声明如下：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding excerpt, `parent_node` is given `simple-bus` as a `compatible`
    string in order to instruct the device tree core and the platform core to instantiate
    two platform devices, which correspond to our nodes. In that excerpt, we have
    also demonstrated how GPIOs, as well as IRQs from our controller, are specified.
    The number of cells used for each property matches the declaration in the controller
    binding.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，`parent_node`被赋予了`simple-bus`作为`compatible`字符串，以指示设备树核心和平台核心实例化两个平台设备，它们对应我们的节点。在该摘录中，我们还展示了如何指定GPIO以及来自我们控制器的IRQ。每个属性使用的单元数与控制器绑定中的声明相匹配。
- en: GPIO- and pin-controller interaction
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPIO与针脚控制器的交互
- en: These two subsystems are closely related. A pin controller can route some or
    all of the GPIOs provided by a GPIO controller to pins on the package. This allows
    those pins to be muxed (also known as pinmuxing) between GPIO and other functions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个子系统是紧密相关的。针脚控制器可以将GPIO控制器提供的部分或所有GPIO路由到封装上的引脚。这允许这些引脚在GPIO和其他功能之间进行复用（也称为引脚复用）。
- en: It may then be useful to know which GPIOs correspond to which pins on which
    pin controllers. The `gpio-ranges` property, which will be described below, represents
    this correspondence with a discrete set of ranges that map pins from the pin controller
    local number space to pins in the GPIO controller local number space.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可能需要了解哪些GPIO与哪些针脚控制器上的引脚对应。`gpio-ranges`属性，下面将描述，表示通过一组离散的范围，映射从针脚控制器本地编号空间到GPIO控制器本地编号空间的引脚。
- en: 'The `gpio-ranges` format is the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio-ranges`格式如下：'
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The GPIO controller offset refers to the GPIO controller node containing the
    range definition. The bindings defined in `Documentation/pinctrl/pinctrl-bindings.txt`
    must be followed by the pin controller node referenced by `phandle`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO控制器的偏移量指的是包含范围定义的GPIO控制器节点。必须遵循`Documentation/pinctrl/pinctrl-bindings.txt`中定义的绑定规则，这些绑定规则由`phandle`引用的针脚控制器节点来实现。
- en: Each offset is a number between 0 and N. It is possible to stack any number
    of ranges with just one pin-to-GPIO line mapping if the ranges are concocted,
    but in practice, these ranges are generally gathered together as discrete sets.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个偏移量是一个介于0和N之间的数字。如果范围构造得当，理论上可以将任意数量的范围叠加起来，仅需一个引脚到GPIO线的映射，但在实际中，这些范围通常作为离散集一起收集。
- en: 'The following is an example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下内容：
- en: Ten pins (`20..29`) on pin controller `foo` are mapped to GPIO lines `0..9`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针脚控制器`foo`上的十个引脚（`20..29`）被映射到GPIO线`0..9`。
- en: Twenty pins ( `50..69` ) on pin controller `bar` are mapped to GPIO lines `10..29`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针脚控制器`bar`上的二十个引脚（`50..69`）被映射到GPIO线`10..29`。
- en: It must be noted that GPIOs have a global number space and the pin controller
    has a local number space, so we need to define a way to cross-reference them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，GPIO有一个全局编号空间，而针脚控制器有一个本地编号空间，因此我们需要定义一种方法来交叉引用它们。
- en: 'We want to map PIN `GPIO_5_29` with PIN number `89` in the pin controller number
    space. The following is the device tree property to define the mapping between
    the GPIO and pin control subsystem:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将引脚`GPIO_5_29`与针脚控制器编号空间中的引脚编号`89`进行映射。以下是定义GPIO与引脚控制子系统之间映射的设备树属性：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous excerpt, 1 GPIO line from the 29th GPIO line of GPIO bank5 will
    be mapped to pin ranges from 89 on pin controller `pinctrl`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，来自GPIO银行5的第29条GPIO线的1条GPIO线将被映射到针脚控制器`pinctrl`上从89开始的引脚范围。
- en: 'To illustrate this on a real platform, let''s consider the i.MX6 SoC, which
    has 32 GPIOs per bank. The following is an excerpt from the pin controller node
    of i.MX6 SoCs, declared in `arch/arm/boot/dts/imx6qdl.dtsi`, and whose driver
    is `drivers/pinctrl/freescale/pinctrl-imx6dl.c`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实际平台上说明这一点，假设我们有i.MX6 SoC，它每个银行有32个GPIO。以下是来自i.MX6 SoC的针脚控制器节点摘录，声明在`arch/arm/boot/dts/imx6qdl.dtsi`中，其驱动程序是`drivers/pinctrl/freescale/pinctrl-imx6dl.c`：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that the pin controller has been declared, a GPIO controller (bank3) is
    declared in the same base device tree, `arch/arm/boot/dts/imx6qdl.dtsi`, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在引脚控制器已声明，在相同的基础设备树`arch/arm/boot/dts/imx6qdl.dtsi`中声明了一个GPIO控制器（bank3），如下所示：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For information, the driver of this GPIO controller is `drivers/gpio/gpio-mxc.c`.
    After the GPIO controller node has been declared in the base device tree, this
    same GPIO controller node is overridden in a SoC-specific base device tree, `arch/arm/boot/dts/imx6q.dtsi`,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，这个GPIO控制器的驱动程序是`drivers/gpio/gpio-mxc.c`。在基础设备树中声明GPIO控制器节点后，类似的GPIO控制器节点将在SoC特定的基础设备树`arch/arm/boot/dts/imx6q.dtsi`中被覆盖，如下所示：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding override of the GPIO controller node means the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对GPIO控制器节点的覆盖意味着以下内容：
- en: '`<&iomuxc 0 69 16>` means that 16 pins, from pin 69 (to 84) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 0 (to 15).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<&iomuxc 0 69 16>`表示，从引脚控制器`iomuxc`上的引脚69（到84）开始的16个引脚被映射到从索引0（到15）开始的GPIO线路。'
- en: '`<&iomuxc 16 36 8>` means that 8 pins, from pin 36 (to 43) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 16 (to 23).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<&iomuxc 16 36 8>`表示，从引脚控制器`iomuxc`上的引脚36（到43）开始的8个引脚被映射到从索引16（到23）开始的GPIO线路。'
- en: '`<&iomuxc 24 45 8>` means that 8 pins, from pin 45 (to 52) on pin controller
    `iomuxc`, are mapped to GPIO lines starting from index 24 (to 31).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<&iomuxc 24 45 8>`表示，从引脚控制器`iomuxc`上的引脚45（到52）开始的8个引脚被映射到从索引24（到31）开始的GPIO线路。'
- en: As expected, we have a 32-line GPIO bank, `16 + 8 + 8`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们有一个32线的GPIO银行，`16 + 8 + 8`。
- en: As of now, we are able to both understand existing and instantiate new GPIO
    controllers from the device tree that interact with one or more pin controllers.
    As the last step in this GPIO controller binding learning curve, let's learn how
    to hog GPIOs in order to avoid writing a particular driver (or prevent existing
    ones) to control them.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们能够理解现有的GPIO控制器，并实例化与一个或多个引脚控制器交互的GPIO控制器。从GPIO控制器绑定学习曲线的最后一步开始，让我们学习如何占用GPIO，以避免编写特定的驱动程序（或防止使用现有的驱动程序）来控制它们。
- en: Pin hogging
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引脚占用（Pin hogging）
- en: The GPIO chip can contain GPIO hog definitions. GPIO hogging is a mechanism
    providing automatic GPIO requests and configuration as part of the GPIO controller's
    driver probe function. This means that as soon as the pin control device is registered,
    the GPIO core will attempt to call `devm_pinctrl_get()`, `lookup_state()`, and
    `select_state()` on it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO芯片可以包含GPIO hog定义。GPIO占用是一种机制，提供自动GPIO请求和配置，作为GPIO控制器驱动程序探测功能的一部分。这意味着，一旦引脚控制设备注册，GPIO核心将尝试在其上调用`devm_pinctrl_get()`、`lookup_state()`和`select_state()`。
- en: 'The following are properties required for each GPIO hog definition, which is
    represented as a child node of the GPIO controller:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个GPIO hog定义所需的属性，这些属性表示为GPIO控制器的子节点：
- en: '`gpio-hog`: A property that indicates whether or not this child node represents
    a GPIO hog.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpio-hog`：一个属性，指示该子节点是否代表一个GPIO hog。'
- en: '`gpios`: Contains the GPIO information (ID, flags, ...) for each GPIO to affect.
    Will contain an integer multiple of the number of cells specified in its parent
    node (GPIO controller node).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpios`：包含每个GPIO的GPIO信息（ID、标志等）。将包含其父节点（GPIO控制器节点）指定的单元数的整数倍。'
- en: 'Only one of the following properties can be specified, scanned in the order
    they are listed. This means that when multiple properties are present, they will
    be searched in the order they are presented here, with the first match being considered
    as the intended configuration:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能指定以下属性之一，按列出的顺序扫描。这意味着，当多个属性存在时，它们将按此顺序搜索，第一个匹配的将被视为预期配置：
- en: '`input`: A property that specifies that the GPIO direction should be set to
    input.'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`：一个属性，指定GPIO方向应设置为输入。'
- en: '`output-low`: A property that specifies that the GPIO should be configured
    as output, with an initial low state value.'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output-low`：一个属性，指定GPIO应配置为输出，且初始状态为低。'
- en: '`output-high`: A property that specifies that the GPIO direction should be
    set to output with an initial high value.'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output-high`：一个属性，指定GPIO方向应设置为输出，并且初始值为高。'
- en: 'An optional property is `line-name`: the GPIO label name. If it''s not present,
    the node name is used.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选的属性是`line-name`：GPIO标签名称。如果没有该属性，将使用节点名称。
- en: 'The following is an excerpt, where we first declare (as GPIO) the pins we are
    interested in in the pin controller node:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个摘录，其中我们首先在引脚控制器节点中声明（作为GPIO）我们感兴趣的引脚：
- en: '[PRE33]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After the pins of interest are declared, we can hog each GPIO under the node
    of the GPIO controller this GPIO belongs to, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了相关引脚之后，我们可以在GPIO控制器所在节点下占用每个GPIO，如下所示：
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It must be noted that hogging pins should be used for those pins that are not
    controlled by any particular driver.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，GPIO占用应仅用于那些没有被特定驱动程序控制的引脚。
- en: GPIO hogging was the last part on the GPIO controller side. Now that controllers
    have no more secrets for us, let's switch to the consumer interface.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO占用是GPIO控制器端的最后一部分。现在控制器已经没有什么秘密可言，让我们切换到消费者接口。
- en: Getting the most out of the GPIO consumer interface
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大限度地利用GPIO消费者接口
- en: 'The GPIO is a feature, or a mode in which a pin can operate, in terms of hardware.
    It is nothing more than a digital line that may be used as an input or output
    and has just two values (or states): 1 for high or 0 for low. The kernel''s GPIO
    subsystem includes all of the functions you''ll need to set up and manage GPIO
    lines from within your driver.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO是一种功能或模式，指的是引脚在硬件中的操作方式。它不过是一个数字线路，可以作为输入或输出，只有两个值（或状态）：1表示高，0表示低。内核的GPIO子系统包含了你需要的所有功能，以便在驱动程序中设置和管理GPIO线路。
- en: Before using a GPIO from within the driver, it must first be claimed by the
    kernel. It's a means to take control of a GPIO and prohibit other drivers from
    using it, as well as preventing the controller driver from being unloaded.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序中使用GPIO之前，必须首先由内核声明它。这是一种控制GPIO并禁止其他驱动程序使用它的手段，同时也防止控制器驱动程序被卸载。
- en: 'After claiming control of the GPIO, you can do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明GPIO的控制权后，可以执行以下操作：
- en: Set the direction and, if needed, set the GPIO configuration.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方向，并根据需要设置GPIO配置。
- en: If it's being used as an output, start toggling its output state (driving the
    line high or low).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果作为输出使用，开始切换其输出状态（驱动线路为高或低）。
- en: If used as input, set the debounce-interval if needed and read the state. For
    a GPIO line mapped to an IRQ, configure at what edge/level the interrupt should
    be triggered, and register a handler that will be run when the interrupt occurs.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果作为输入使用，设置防抖时间间隔（如果需要）并读取状态。对于映射到IRQ的GPIO线路，配置中断应在何种边缘/电平触发，并注册一个处理程序，当中断发生时该处理程序将被执行。
- en: 'In the Linux kernel, there are two different ways to deal with GPIOs:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，有两种不同的方式来处理GPIO：
- en: The legacy and deprecated integer-based interface, which uses integers to represent
    GPIOs.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的、已弃用的基于整数的接口，使用整数来表示GPIO。
- en: The new descriptor-based interface, where a GPIO is represented and described
    by an opaque structure, with a dedicated API. This is the recommended way to go.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的基于描述符的接口，其中GPIO由一个不透明的结构表示和描述，并提供专用的API。这是推荐的方式。
- en: While we will discuss the two approaches in this chapter, let's start with the
    legacy interface.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在本章中讨论这两种方法，但我们从传统接口开始。
- en: Integer-based GPIO interface – now deprecated
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于整数的GPIO接口——现在已被弃用
- en: 'The integer-based interface is the most known usage of GPIOs in Linux systems,
    either in the kernel or in the user space. In this mode, the GPIO is identified
    by an integer, which is used for every operation that needs to be performed on
    this GPIO. The following is the header that contains the legacy GPIO access function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 基于整数的接口是Linux系统中最常见的GPIO使用方式，无论是在内核中还是在用户空间中。在这种模式下，GPIO由一个整数标识，该整数用于每个需要在此GPIO上执行的操作。以下是包含传统GPIO访问函数的头文件：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The integer-based interface relies on a set of functions, defined as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 基于整数的接口依赖于一组函数，定义如下：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All the preceding functions are mapped to a set of callbacks provided by the
    GPIO controller through its `struct gpio_chip` structure, thanks to which it exposes
    a generic set of callback functions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述功能都映射到由GPIO控制器通过其`struct gpio_chip`结构提供的一组回调函数，正是通过这些回调函数，它暴露了一个通用的回调函数集。
- en: In all these functions, `gpio` represents the GPIO number we are interested
    in. Before using a GPIO, client drivers must call `gpio_request()` in order to
    take ownership of the line and, very importantly, to prevent this GPIO controller
    driver from being unloaded. In the same function, `label` is the label used by
    the kernel for labeling/describing the GPIO in sysfs as we can see in `/sys/kernel/debug/gpio`.
    `gpio_request``()` returns `0` on success, and a negative error code on error.
    If in doubt, before requesting the GPIO, you can use the `gpio_is_valid()` function
    to check whether the specified GPIO number is valid on the system prior to it
    being requested.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些函数中，`gpio`表示我们感兴趣的GPIO编号。在使用GPIO之前，客户端驱动程序必须调用`gpio_request()`来获取该线的所有权，并且非常重要的是，防止此GPIO控制器驱动程序被卸载。在同一个函数中，`label`是内核用于标记/描述GPIO的标签，它会出现在/sys/kernel/debug/gpio中。`gpio_request()`在成功时返回`0`，在出错时返回负的错误代码。如果不确定，在请求GPIO之前，你可以使用`gpio_is_valid()`函数检查指定的GPIO编号在系统中是否有效。
- en: Once a driver owes the GPIO, it can change its direction, depending on the need,
    whether it should be an input or output, using the `gpio_direction_input()` or
    `gpio_direction_output()` functions. In these functions, `gpio` is the GPIO number
    the driver needs to set the direction, which should have already been requested.
    There is a second parameter when it comes to configuring the GPIO as output, `value`,
    which is the initial state the GPIO should be in once the output direction is
    effective. Here again, in both functions, the return value is `0` on success or
    a negative error code on failure. Internally, these functions are mapped to lower-level
    callback functions exported by the driver of the GPIO chip that provides the GPIO
    line `gpio`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦驱动程序拥有了GPIO，它就可以根据需要改变方向，判断是应该设置为输入还是输出，可以使用`gpio_direction_input()`或`gpio_direction_output()`函数。在这些函数中，`gpio`是驱动程序需要设置方向的GPIO编号，这个编号应该已经被请求过。当配置GPIO为输出时，还会有第二个参数`value`，它是GPIO在输出方向生效后应该处于的初始状态。再次强调，这两个函数的返回值在成功时是`0`，失败时则返回一个负的错误代码。从内部来看，这些函数会映射到由GPIO芯片驱动程序导出的低级回调函数，这些回调函数提供了GPIO线`gpio`。
- en: Some GPIO controllers allow you to adjust the GPIO debounce-interval (this is
    only useful when the GPIO line is configured as input). This parameter can be
    set using `gpio_set_debounce()`. In this function, the `debounce` argument is
    the debounce time in milliseconds.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GPIO控制器允许你调整GPIO的去抖动间隔（这只有在GPIO线配置为输入时才有用）。这个参数可以通过`gpio_set_debounce()`函数来设置。在这个函数中，`debounce`参数是去抖动时间，单位是毫秒。
- en: As it is a good practice to grab and configure resources in the driver's probing
    method, GPIO lines must respect this rule.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在驱动程序的探测方法中抓取和配置资源是一个好的实践，GPIO线必须遵循这一规则。
- en: It has to be noticed that GPIO management (either configuration or getting/setting
    values) is not context agnostic; that is, there are memory-mapped GPIO controllers
    that can be accessed from any context (process and atomic contexts). On the other
    hand, there are GPIOs provided by discrete chips sitting on slow buses (such as
    I2C or SPI) that can sleep (because sending/receiving commands on such buses requires
    waiting to get to the head of a queue to transmit a command and get its response).
    Such GPIOs must be manipulated from a process context exclusively. A well-designed
    controller driver must be able to inform clients whether calls to its GPIO driving
    methods may sleep or not. This can be checked with the `gpio_cansleep()` function.
    This function returns `true` for GPIO lines whose controller sits on a slow bus,
    and `false` for GPIOs that belong to a memory-mapped controller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，GPIO管理（无论是配置还是获取/设置值）并不是与上下文无关的；也就是说，有一些内存映射的GPIO控制器可以在任何上下文（进程和原子上下文）中访问。另一方面，也有一些GPIO是由位于慢总线（如I2C或SPI）的离散芯片提供的，这些GPIO可能会进入休眠状态（因为在这些总线上发送/接收命令需要等待进入队列的首位才能传输命令并获取响应）。这些GPIO必须仅能在进程上下文中操作。一个设计良好的控制器驱动程序必须能够告知客户端它的GPIO驱动方法是否可能会休眠。这可以通过`gpio_cansleep()`函数进行检查。该函数对于那些控制器位于慢总线上的GPIO线返回`true`，而对于属于内存映射控制器的GPIO返回`false`。
- en: Now that the GPIOs are requested and configured, we can set/get their values
    using the appropriate APIs. Here again, the APIs to use are context-dependent.
    For memory-mapped GPIO controllers, their GPIO lines can be accessed using `gpio_get_value()`
    or `gpio_set_value()`. The first function returns a value that represents the
    GPIO state, and the second one will set the value of the GPIO, which should have
    been configured as an output using `gpio_direction_output()`. `value` can be considered
    as Boolean for both functions, with zero indicating a low level and a non-zero
    value indicating a high level.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GPIO已经请求并配置完毕，我们可以使用适当的API来设置/获取它们的值。这里再次提到，使用的API取决于上下文。对于内存映射的GPIO控制器，可以使用`gpio_get_value()`或`gpio_set_value()`来访问其GPIO线路。第一个函数返回一个表示GPIO状态的值，第二个函数将设置GPIO的值，该GPIO应该通过`gpio_direction_output()`配置为输出。对于这两个函数，`value`可以视为布尔值，零表示低电平，非零值表示高电平。
- en: In case of doubt about the kind of GPIO controller from where the GPIO originates,
    the driver should use the context agnostic APIs, `gpio_get_value_cansleep()` and
    `gpio_set_value_cansleep()`. These APIs are safe to use in threaded contexts but
    also work in an atomic context.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定GPIO来源的GPIO控制器类型，驱动程序应该使用与上下文无关的API，`gpio_get_value_cansleep()`和`gpio_set_value_cansleep()`。这些API在多线程上下文中安全使用，同时也能在原子上下文中工作。
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The legacy (that is, integer-based) interface supports specifying GPIOs from
    the device tree, in which case the APIs to be used to grab those GPIOs will be
    `of_get_gpio()`, `of_get_named_gpio()`, or similar APIs. These are mentioned here
    for studying purposes and won't be discussed in this chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的（即基于整数的）接口支持通过设备树指定GPIO，在这种情况下，用于获取这些GPIO的API是`of_get_gpio()`、`of_get_named_gpio()`或类似的API。这里只是为了学习目的提及这些，本文将不再讨论。
- en: GPIO mapped to IRQ
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射到IRQ的GPIO
- en: There are GPIO controllers that allow their GPIO lines to be mapped to IRQs.
    These IRQs can be either edge- or level-triggered. The configuration depends on
    the needs. The GPIO controller is responsible for providing the mapping between
    the GPIO and its IRQ.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有些GPIO控制器允许将它们的GPIO线路映射到IRQ。这些IRQ可以是边缘触发或电平触发。配置取决于需求。GPIO控制器负责提供GPIO与其IRQ之间的映射。
- en: If the IRQ has been specified in the device tree and the underlying device is
    an I2C or SPI device, the consumer driver must just request the IRQ normally,
    since upon the device tree parsing, the GPIO mapped to IRQ specified in the device
    tree will be translated by the device tree core and assigned to your device structure,
    that is, `i2c_client.irq` or `spi_device.irq`. This is the case in `foo_device`
    from the example we have seen in the *GPIO controller bindings* section. For another
    device type, you'll have to call `irq_of_parse_and_map()` or a similar API.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IRQ已经在设备树中指定，并且底层设备是I2C或SPI设备，那么消费者驱动程序只需要正常请求IRQ，因为在设备树解析时，设备树中映射到IRQ的GPIO将由设备树核心转换并分配给你的设备结构，即`i2c_client.irq`或`spi_device.irq`。在我们在*GPIO控制器绑定*章节中看到的`foo_device`示例中就是这种情况。对于其他设备类型，你需要调用`irq_of_parse_and_map()`或类似的API。
- en: 'If, however, the driver is given a GPIO (from module parameters, for example)
    or specified from the device tree without being mapped to IRQ there, the driver
    must use `gpio_to_irq()` to map the given GPIO number to its IRQ number:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果驱动程序收到一个GPIO（例如来自模块参数）或从设备树中指定但没有映射到IRQ，那么驱动程序必须使用`gpio_to_irq()`将给定的GPIO编号映射到其IRQ编号：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This function returns the corresponding Linux IRQ number, which can be passed
    to `request_irq()` (or the threaded counterpart, `request_threaded_irq()`) to
    register a handler for this IRQ:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回相应的Linux IRQ号，可以将其传递给`request_irq()`（或其线程版本`request_threaded_irq()`）来注册该IRQ的处理程序：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`request_any_context_irq()` is smart enough to identify the underlying context
    supported by the IRQ chip integrated into the GPIO controller. If this controller''s
    accessors can sleep, `request_any_context_irq()` will request a threaded IRQ,
    otherwise, it will request an atomic-context IRQ.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_any_context_irq()`足够智能，可以识别GPIO控制器中IRQ芯片支持的底层上下文。如果该控制器的访问者可以休眠，`request_any_context_irq()`将请求一个线程IRQ，否则将请求一个原子上下文IRQ。'
- en: 'The following is a short example demonstrating what we have discussed so far:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简短的示例，演示到目前为止我们所讨论的内容：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous excerpt, we have demonstrated how to use a legacy integer-based
    interface to grab a GPIO specified in the device tree, as well as the old API
    to translate this GPIO into a valid Linux IRQ number. These were the main points
    to highlight.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，我们演示了如何使用基于整数的传统接口来获取设备树中指定的GPIO，以及如何使用旧的API将该GPIO转换为有效的Linux IRQ号。这些是需要强调的主要内容。
- en: Though deprecated, we briefly introduced the legacy GPIO APIs. As is recommended,
    in the next section, we will deal with the new descriptor-based GPIO interface.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经废弃，但我们简要介绍了传统的GPIO API。如推荐的那样，在下一节中，我们将讨论新的基于描述符的GPIO接口。
- en: 'Descriptor-based GPIO interface: the new and recommended way'
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于描述符的GPIO接口：新的推荐方式
- en: 'With the new descriptor-based GPIO interface, the subsystem has been oriented
    to the producer/consumer. The header required for the descriptor-based GPIO interface
    is the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的基于描述符的GPIO接口后，子系统已面向生产者/消费者。基于描述符的GPIO接口所需的头文件如下：
- en: '[PRE40]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'With the descriptor-based interface, a GPIO is described and characterized
    by a coherent data structure, `struct gpio_desc`, which is defined as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于描述符的接口时，GPIO通过一个一致的数据结构`struct gpio_desc`进行描述和表征，该结构定义如下：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding data structure, `chip` is the controller providing this GPIO
    line; `flags` are the flags characterizing the GPIO and `label` is the name describing
    the GPIO.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述数据结构中，`chip`是提供该GPIO线路的控制器；`flags`是描述GPIO特性的标志，`label`是描述GPIO名称的标签。
- en: Prior to requesting and acquiring ownership of GPIOs with the descriptor-based
    interface, these GPIOs must have been specified or mapped somewhere. It means
    they should be allocated to a driver, whereas with the legacy integer-based interface,
    a driver could just obtain a number from anywhere and request it as GPIO. Since
    descriptor-based GPIOs are represented by an opaque structure, such a method is
    not possible anymore.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求和获取GPIO的所有权之前，这些GPIO必须已经在某个地方被指定或映射。也就是说，它们应该分配给驱动程序，而在传统的基于整数的接口中，驱动程序可以直接从任何地方获取一个数字并将其请求为GPIO。由于基于描述符的GPIO由不透明结构表示，因此不再可能使用这种方法。
- en: 'With the new interface, GPIOs must exclusively be mapped to names or indexes,
    specifying at the same time the GPIO chips providing the GPIOs of interest. This
    gives us three ways to specify and assign GPIOs to drivers:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的接口时，GPIO必须专门映射到名称或索引，并同时指定提供相关GPIO的GPIO芯片。这为我们提供了三种方式来指定和分配GPIO给驱动程序：
- en: '**Platform data mapping**: In such cases, for example, the mapping is done
    in the board file.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台数据映射**：在这种情况下，例如，映射是在板文件中完成的。'
- en: '**Device tree**: The mapping is done in the device tree. This is the mapping
    we will discuss in this book.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备树**：映射是在设备树中完成的。这是本书中我们将讨论的映射。'
- en: '**Advanced Configuration and Power Interface mapping (ACPI)**: This is ACPI-style
    mapping. On x86-based systems, this is the most common configuration.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级配置和电源接口映射（ACPI）**：这是ACPI风格的映射。在基于x86的系统中，这是最常见的配置。'
- en: Now that we are done with the GPIO descriptor interface introduction, let's
    learn how it is mapped and assigned to devices.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了GPIO描述符接口的介绍，让我们学习如何将其映射并分配给设备。
- en: GPIO descriptor mapping in the device tree and its APIs
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备树中的GPIO描述符映射及其API
- en: GPIO descriptor mappings are defined in the device tree node of the consumer
    device. The GPIO descriptor mapping property must be named `<name>-gpios` or `<name>-gpio`,
    where `<name>` is meaningful enough to describe the function for which the GPIO(s)
    will be used. This is mandatory.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO描述符映射在消费者设备的设备树节点中定义。GPIO描述符映射属性必须命名为`<name>-gpios`或`<name>-gpio`，其中`<name>`应足够有意义，能够描述GPIO将用于的功能。这是强制性的。
- en: 'The reason is that descriptor-based GPIO lookup relies on the `gpio_suffixes[]`
    variable, a `gpiolib` variable defined in `drivers/gpio/gpiolib.h` as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因在于，基于描述符的GPIO查找依赖于`gpio_suffixes[]`变量，这是一个在`drivers/gpio/gpiolib.h`中定义的`gpiolib`变量，定义如下：
- en: '[PRE42]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This variable is used in both device tree lookup and ACPI-based lookup. To
    see how it works, let''s see how it is used in `of_find_gpio()`, the device tree''s
    low-level GPIO lookup function defined as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 该变量在设备树查找和基于ACPI的查找中都会使用。为了查看它如何工作，我们来看它是如何在`of_find_gpio()`中使用的，这是设备树的低级GPIO查找函数，定义如下：
- en: '[PRE43]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let''s consider the following node, which is an excerpt of `Documentation/gpio/board.txt`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看以下节点，这是`Documentation/gpio/board.txt`的一个摘录：
- en: '[PRE44]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is what a mapping should look like, with meaningful names, corresponding
    to the functions assigned to the GPIOs. This excerpt will be used as the basis
    for the rest of this section to demonstrate the use of the descriptor-based GPIO
    interface.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是映射应如何显示的样子，包含有意义的名称，对应于分配给 GPIO 的功能。这个摘录将作为本节其余部分的基础，用于演示基于描述符的 GPIO 接口的使用。
- en: 'Now that the GPIOs have been specified in the device tree, the first thing
    to be done is to allocate GPIO descriptors and take the ownership of these GPIOs.
    This can be done using `gpiod_get()`, `gpiod_getindex()`, or `gpiod_get_optional()`,
    defined as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然 GPIO 已在设备树中指定，首先要做的是分配 GPIO 描述符并获得这些 GPIO 的所有权。这可以通过使用 `gpiod_get()`、`gpiod_getindex()`
    或 `gpiod_get_optional()` 来完成，定义如下：
- en: '[PRE45]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It must be noted that we can also use the device-managed variant of these APIs,
    defined as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，我们还可以使用这些 API 的设备管理变体，定义如下：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Both non `_optional` functions will return `-ENOENT` if no GPIO with the given
    function is assigned or a negative error if another error occurred. On success,
    the GPIO descriptor corresponding to the GPIO is returned. The first method returns
    the GPIO descriptor structure for the GPIO at a particular index (useful when
    the specifier is a list of GPIOs), whereas the second function always returns
    the GPIO at index `0` (single GPIO mapping). The `_optional` variant is useful
    for drivers that need to deal with optional GPIOs; it's the same as `gpiod_get()`,
    except that it returns `NULL` when no GPIO has been assigned to the device (that
    is, specified in the device tree).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 两个非 `_optional` 函数如果未分配指定功能的 GPIO，或者出现其他错误，将返回 `-ENOENT` 或负数错误。如果成功，将返回对应 GPIO
    的 GPIO 描述符。第一种方法返回某个特定索引的 GPIO 的 GPIO 描述符（当规范器是 GPIO 列表时很有用），而第二个函数始终返回索引为 `0`
    的 GPIO（单一 GPIO 映射）。`_optional` 变体对于需要处理可选 GPIO 的驱动程序很有用；它与 `gpiod_get()` 相同，只是当没有
    GPIO 被分配给设备（即未在设备树中指定）时，返回 `NULL`。
- en: 'In parameters, `dev` is the device to which the GPIO descriptor will belong.
    It is the underlying `device` structure the driver is responsible for; for example,
    `i2c_client.dev`, `spi_device.dev`, or `platform_device.dev`. `con_id` is the
    function of the GPIO within the consumer interface. It corresponds to the `<name>`
    prefix of the GPIO specifier property name in the device tree. `idx` is the index
    (starting from `0`) of the GPIO in case the specifier contains a list of GPIOs.
    `flags` is an optional parameter that determines the GPIO initialization flags,
    to configure the direction and/or the initial output value. It is an instance
    of `enum gpiod_flags`, defined in `include/linux/gpio/consumer.h` as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数中，`dev` 是 GPIO 描述符所属的设备。它是驱动程序负责的底层 `device` 结构；例如，`i2c_client.dev`、`spi_device.dev`
    或 `platform_device.dev`。`con_id` 是 GPIO 在消费者接口中的功能，它对应于设备树中 GPIO 规范器属性名称的 `<name>`
    前缀。`idx` 是 GPIO 的索引（从 `0` 开始），当规范器包含 GPIO 列表时使用。`flags` 是一个可选参数，用于确定 GPIO 初始化标志，以配置方向和/或初始输出值。它是
    `enum gpiod_flags` 的一个实例，定义在 `include/linux/gpio/consumer.h` 中，如下所示：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s demonstrate in the following how these APIs can be used in drivers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下面将演示如何在驱动程序中使用这些 API：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For the sake of readability, the preceding code does not perform error checking.
    The LED GPIOs will be active-high, but the power GPIO will be active-low (that
    is, `gpiod_is_active_low(power)` returns `true` in this case).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，前面的代码没有执行错误检查。LED GPIO 将为高电平有效，但电源 GPIO 将为低电平有效（也就是说，`gpiod_is_active_low(power)`
    在这种情况下返回 `true`）。
- en: 'Since the `flags` argument is optional, there might be situations where either
    the initial flags are not specified or when the initial function of the GPIO needs
    to be changed. To address this, drivers can use `gpiod_direction_input()` or `gpiod_direction_output()`
    to change the GPIO direction. These APIs are defined as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `flags` 参数是可选的，可能存在未指定初始标志的情况，或者在需要更改 GPIO 初始功能时。为了解决这个问题，驱动程序可以使用 `gpiod_direction_input()`
    或 `gpiod_direction_output()` 来更改 GPIO 方向。这些 API 定义如下：
- en: '[PRE49]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding APIs, `desc` is the GPIO descriptor of the GPIO of interest,
    and `value` is the initial value to apply to this GPIO when it is configured as
    output.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 API 中，`desc` 是相关 GPIO 的 GPIO 描述符，而 `value` 是当 GPIO 配置为输出时要应用的初始值。
- en: 'It must be noted that the same attention must be paid as with the integer-based
    interface. In other words, the driver must take care of whether the underlying
    GPIO chip is memory-mapped (and thus can be accessed in any context) or sits on
    a slow bus (which would require accessing the chip in process or threaded context
    exclusively). This can be achieved using the `gpiod_cansleep()` function, defined
    as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，与基于整数的接口一样，必须给予同样的关注。换句话说，驱动程序必须关注底层GPIO芯片是否是内存映射的（因此可以在任何上下文中访问），或者是否位于慢速总线上（这将要求仅在进程或线程上下文中访问芯片）。这可以通过使用`gpiod_cansleep()`函数来实现，定义如下：
- en: '[PRE50]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This function returns `true` if the underlying hardware can put the caller to
    sleep while it is accessed. In such cases, drivers should use dedicated APIs.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层硬件可以在访问期间将调用者置于休眠状态，则此函数返回`true`。在这种情况下，驱动程序应该使用专用API。
- en: 'The following are APIs to get or set the GPIO value on a controller that sits
    on a slow bus, that is, a GPIO descriptor for which `gpiod_cansleep()` returned
    `true`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于获取或设置位于慢速总线上的控制器上的GPIO值的API，即对于`gpiod_cansleep()`返回`true`的GPIO描述符：
- en: '[PRE51]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If the underlying chip is memory mapped, the following APIs can be used instead:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果底层芯片是内存映射的，则可以使用以下API：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The context must be considered only if the driver is intended to access the
    GPIO(s) from within an interrupt handler or from within any other atomic context.
    Otherwise, you can just use the normal APIs, that is, the ones without the `_cansleep`
    suffix.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在驱动程序打算从中断处理程序或任何其他原子上下文中访问GPIO时，才需要考虑上下文。否则，您可以直接使用常规API，即没有`_cansleep`后缀的API。
- en: '`gpiod_to_irq()` can be used to get the IRQ number that corresponds to a GPIO
    descriptor mapped to IRQ:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiod_to_irq()`可用于获取与映射到IRQ的GPIO描述符对应的IRQ号：'
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The resulting IRQ number can be used with the `request_irq()` function (or the
    threaded variant `request_threaded_irq()`). If the driver does not need to bother
    with the context supported by the underlying hardware chip, `request_any_context_irq()`
    can be used instead. That said, the driver can use the device managed variant
    of these functions, that is, `devm_request_irq()`, `devm_request_threaded_irq()`,
    or `devm_request_any_context_irq()`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的IRQ号可以与`request_irq()`函数（或者线程化版本`request_threaded_irq()`）一起使用。如果驱动程序不需要关心底层硬件芯片所支持的上下文，则可以改用`request_any_context_irq()`。也就是说，驱动程序可以使用这些函数的设备管理变体，即`devm_request_irq()`、`devm_request_threaded_irq()`或`devm_request_any_context_irq()`。
- en: 'If for any reason the module needs to switch back and forth between the descriptor-based
    interface and the legacy integer-based interface, the APIs `desc_to_gpio()` and
    `gpio_to_desc()` can be used for translations. They are defined as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因模块需要在基于描述符的接口和基于整数的传统接口之间切换，可以使用`desc_to_gpio()`和`gpio_to_desc()`API进行转换。它们的定义如下：
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding, `gpio_to_desc()` takes a legacy GPIO number in the parameter
    and returns the associated GPIO descriptor, while `desc_to_gpio()` does the opposite.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内容中，`gpio_to_desc()`接受一个传统的GPIO编号作为参数，并返回关联的GPIO描述符，而`desc_to_gpio()`则执行相反操作。
- en: 'The advantage of using the device-managed APIs is that drivers need not care
    about releasing the GPIO at all, since it will be handled by the GPIO core. If,
    however, non-managed APIs were used to request a GPIO descriptor, this descriptor
    must explicitly be released with `gpiod_put()`, defined as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备管理的API的优势在于，驱动程序无需关心释放GPIO，因为这将由GPIO核心处理。如果使用的是非管理的API请求GPIO描述符，则必须显式地使用`gpiod_put()`释放该描述符，定义如下：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we are done with the consumer side's descriptor-based APIs, let's summarize
    what we have learned in a concrete example, from the mapping from the device tree
    to the consumer code based on consumer APIs.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了消费者端的描述符接口API，接下来让我们通过一个具体的示例总结所学内容，从设备树的映射到基于消费者API的消费者代码。
- en: Putting it all together
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容汇总
- en: 'The following driver summarizes the concepts introduced in the descriptor-based
    interface. In this example, we need four GPIOs split as follows: two for LEDs
    (red and green, which are then configured as output) and two for buttons (thus
    configured as input). The logic to implement is that pushing button 1 toggles
    both LEDs only when button 2 is pushed as well.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下驱动程序总结了描述符接口中介绍的概念。在这个示例中，我们需要四个GPIO，分配如下：两个用于LED（红色和绿色，然后配置为输出），两个用于按钮（因此配置为输入）。要实现的逻辑是，只有当按钮2被按下时，按下按钮1才会切换两个LED。
- en: 'To achieve that, let''s consider the following mapping in the device tree:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，让我们考虑设备树中的以下映射：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now that the GPIOs have been mapped in the device tree, let''s write the platform
    driver that will leverage these GPIOs:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GPIO已经在设备树中映射完毕，让我们编写一个将利用这些GPIO的平台驱动程序：
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding, we have started with the IRQ handler. The toggling logic
    is implemented by `led_state = 1 – led_state`. Next, we implement the driver''s
    `probe` method, as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从IRQ处理程序开始。切换逻辑由`led_state = 1 – led_state`实现。接下来，我们实现驱动程序的`probe`方法，如下所示：
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding probe method is quite simple. We first start requesting the GPIOs,
    then we translate the button 1 GPIO line into a valid IRQ number, and then we
    register a handler for this IRQ. You should pay attention to the fact that we
    have exclusively used device-managed APIs in that method.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`probe`方法相当简单。我们首先请求GPIO，然后将按钮1的GPIO线转换为有效的IRQ号，接着为该IRQ注册一个处理程序。需要注意的是，我们在该方法中只使用了设备管理API。
- en: 'Finally, we set up a device ID table before filling and registering our platform
    device driver, as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在填充和注册平台设备驱动程序之前，设置一个设备ID表，如下所示：
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We may wonder why neither GPIO descriptors nor interrupts were released. This
    is because we exclusively used device-managed APIs in the `probe` function. Thanks
    to these, we do not need to release anything explicitly, thus we can get rid of
    the `remove` method of the platform driver.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会想，为什么没有释放GPIO描述符或中断。原因是我们在`probe`函数中只使用了设备管理API。多亏了这些API，我们不需要显式地释放任何内容，因此我们可以省略平台驱动程序中的`remove`方法。
- en: 'If we use non-managed APIs, the `remove` method could look like the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用非管理API，`remove`方法可能如下所示：
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding, we can notice the use of regular `gpiod_put()` and `free_irq()`
    APIs to release GPIO descriptors and the IRQ line.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们注意到使用了常规的`gpiod_put()`和`free_irq()`API来释放GPIO描述符和IRQ线路。
- en: In this section, we have done with the kernel side of GPIO management, both
    on the controller and client sides. As we have learned all through this book,
    there are situations where we might want to avoid writing specific kernel code.
    Regarding GPIOs, the next section will teach us how not to write GPIO client drivers
    to control these GPIOs.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们完成了GPIO管理的内核部分，包括控制器端和客户端端。如本书所述，有时我们可能希望避免编写特定的内核代码。关于GPIO，下一节将教我们如何避免编写GPIO客户端驱动程序来控制这些GPIO。
- en: Learning how not to write GPIO client drivers
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习如何避免编写GPIO客户端驱动程序
- en: There are situations where writing user space code would achieve the same goals
    as writing kernel drivers. Moreover, the GPIO framework is one of the most used
    frameworks in the user space. It then goes without saying that there are several
    possibilities to deal with it in the user space, some of which we will introduce
    in this chapter.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，编写用户空间代码可以实现与编写内核驱动程序相同的目标。此外，GPIO框架是用户空间中最常用的框架之一。因此，不言而喻，处理它的方式在用户空间中有多种可能性，其中一些我们将在本章中介绍。
- en: Goodbye to the legacy GPIO sysfs interface
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 告别传统的GPIO sysfs接口
- en: 'Sysfs has ruled GPIO management from the user space for quite a long time now.
    Though it is scheduled for removal, the sysfs GPIO interface still has a few days
    ahead of it. `CONFIG_GPIO_SYSFS` can still enable it, but its use is discouraged,
    and it will be removed from mainline Linux. This interface allows managing and
    controlling GPIOs through a set of files. It is located at `/sys/class/gpio/`,
    and the following are the common directory paths and attributes that are involved:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Sysfs已经在用户空间中管理GPIO很长时间了。尽管它计划被移除，但sysfs GPIO接口仍然有几天的使用时间。`CONFIG_GPIO_SYSFS`仍然可以启用它，但不推荐使用，并且它将从主线Linux中移除。该接口允许通过一组文件来管理和控制GPIO。它位于`/sys/class/gpio/`，以下是涉及的常见目录路径和属性：
- en: '`/sys/class/gpio/`: This is where it all starts. There are two special files
    in this directory, `export` and `unexport`, and as many directories as there are
    GPIO controllers registered with the system:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/class/gpio/`：这一切从这里开始。该目录下有两个特殊文件，`export`和`unexport`，以及与系统中注册的每个GPIO控制器相对应的多个目录：'
- en: '`export`: By writing the number of a GPIO to this file, we ask the kernel to
    export control of that GPIO to the user space. For example, typing `echo 21 >
    export` will create a `gpio21` node (resulting in a subdirectory of the same name)
    for GPIO `#21`, if this GPIO is not already requested by the kernel code.'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export`：通过将GPIO的编号写入此文件，我们请求内核将该GPIO的控制权导出到用户空间。例如，输入`echo 21 > export`将为GPIO`#21`创建一个`gpio21`节点（并创建一个相同名称的子目录），前提是该GPIO尚未被内核代码请求。'
- en: '`unexport`: The effect of exporting to the user space is reversed by writing
    the same GPIO number to this file. For example, the `gpio21` node exported using
    the `export` file will be removed by typing `echo 21 > unexport`.'
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unexport`：通过将相同的GPIO编号写入此文件，可以撤销导出到用户空间的效果。例如，通过`export`文件导出的`gpio21`节点，将通过输入`echo
    21 > unexport`删除。'
- en: 'On successful `gpio_chip` registration, a directory entry with a path such
    as `/sys/class/gpio/gpiochipX/` will be created, where `X` is the GPIO controller
    base (the controller providing GPIOs starting at `#X`), having the following attributes:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功注册`gpio_chip`后，将创建一个目录项，其路径类似于`/sys/class/gpio/gpiochipX/`，其中`X`是GPIO控制器的基础（从`#X`开始提供GPIO的控制器），并具有以下属性：
- en: '`base`, whose value is the same as `X`, and which corresponds to `gpio_chip.base`
    (if assigned statically), and being the first GPIO managed by this chip.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`，其值与`X`相同，且对应于`gpio_chip.base`（如果是静态分配），并且是该芯片管理的第一个GPIO。'
- en: '`label`, which is provided for diagnostics (not always unique).'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`，用于诊断（不一定唯一）。'
- en: '`ngpio`, which tells us how many GPIOs this controller provides (`N` to `N
    + ngpio - 1`). This is the same as defined in `gpio_chip.ngpios`.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngpio`，告诉我们此控制器提供多少个GPIO（从`N`到`N + ngpio - 1`）。这与`gpio_chip.ngpios`中定义的相同。'
- en: '`/sys/class/gpio/gpioN/`: This directory corresponds to the GPIO line `N`,
    exported either using the `export` file or directly from the kernel. `/sys/class/gpio/gpio42/`
    (for GPIO `#42`) is an example. The following read/write attributes are contained
    in such directories:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/class/gpio/gpioN/`：此目录对应于GPIO线路`N`，该线路通过`export`文件或直接从内核导出。`/sys/class/gpio/gpio42/`（用于GPIO`#42`）是一个示例。此类目录包含以下读/写属性：'
- en: '`direction`: Use this file to get/set GPIO direction. Acceptable values are
    either `in` or `out` strings. This attribute will normally be written and writing
    the `out` value will initialize the GPIO value as `low` by default. To ensure
    glitch-free operation, values low and high may be written to configure the GPIO
    as an output with that initial value. If, however, the GPIO has been exported
    from the kernel (see the `gpiod_export()` or `gpio_export()` functions), then
    this attribute will be missing, disabling at the same time direction change.'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`：使用此文件来获取/设置GPIO方向。可接受的值是`in`或`out`字符串。该属性通常是可写的，写入`out`值将默认将GPIO初始化为低电平。为了确保无故障操作，可以写入低电平和高电平，以配置GPIO为输出并设置初始值。如果GPIO已从内核导出（请参阅`gpiod_export()`或`gpio_export()`函数），则该属性将缺失，同时禁用方向更改。'
- en: '`value`: This attribute can be used to get or set the state of the GPIO line
    based on its direction, input, or output. If the GPIO is configured as an output,
    any non-zero value written will set the output high, while writing `0` will set
    this output low. If the pin can be set up as an interrupt-generating line and
    is set to do so, then the `poll()` system function can be used on that file and
    will return when an interrupt occurs. Setting the events `POLLPRI` and `POLLERR`
    is required when using `poll()`. If, however, `select()` is used instead, the
    file descriptor should be set in `exceptfds`. After `poll()` returns, the user
    code should either `lseek()` to the beginning of the sysfs file and read the new
    value or close the file and re-open it to read the value. It is the same principle
    as we discussed for the pollable sysfs attribute.'
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：该属性可用于根据GPIO线路的方向、输入或输出状态来获取或设置GPIO的状态。如果GPIO配置为输出，写入任何非零值将设置输出为高电平，而写入`0`将设置输出为低电平。如果该引脚可以设置为中断生成线路，并且已设置为这样，那么可以在该文件上使用`poll()`系统函数，并且当中断发生时会返回。使用`poll()`时，必须设置事件`POLLPRI`和`POLLERR`。如果使用的是`select()`，则应将文件描述符设置在`exceptfds`中。`poll()`返回后，用户代码应使用`lseek()`将光标移到sysfs文件的开头并读取新值，或者关闭文件并重新打开以读取值。这与我们讨论过的可轮询sysfs属性原理相同。'
- en: '`edge` determines the signal edge that will let the `poll()` or `select()`
    functions return. `none`, `rising`, `failing`, or `both` are acceptable values.
    This readable and writable file exists only if the GPIO can be configured as an
    interrupt generating input pin.'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge` 决定信号的边缘，决定何时返回 `poll()` 或 `select()` 函数。可接受的值有：`none`、`rising`、`falling`
    或 `both`。此可读可写的文件仅在 GPIO 可配置为中断生成输入引脚时才会存在。'
- en: '`active_low`: When it is read, this attribute either returns `0` (for `false`)
    or `1` (meaning `true`). Writing any nonzero value will invert the `value` attribute
    for both reading and writing. Existing and subsequent `poll()`/`select()` support
    configuration through the `edge` attribute for rising and falling edges will follow
    this setting.'
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_low`：读取时，属性值返回 `0`（表示 `false`）或 `1`（表示 `true`）。写入任何非零值将反转 `value` 属性的读取和写入值。现有的以及后续的
    `poll()`/`select()` 函数支持通过 `edge` 属性来配置上升沿和下降沿的事件。'
- en: 'The following is a short sequence of commands demonstrating the use of the
    sysfs interface to drive GPIOs from the user space:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简短的命令序列，演示了如何使用 sysfs 接口从用户空间驱动 GPIO：
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Let's not spend more time on this legacy interface. Without delay, let's switch
    to what kernel developers have provided as a new GPIO management interface from
    the user space, the `Libgpiod` library.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再花时间讨论这个遗留接口了。现在，马上切换到内核开发者提供的新 GPIO 管理接口——`Libgpiod` 库。
- en: Welcome to the Libgpiod GPIO library
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 欢迎使用 Libgpiod GPIO 库
- en: 'The Kernel Linux GPIO user space sysfs is deprecated and has been discontinued.
    That said, it was suffering from many ailments, some of which are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 内核 Linux GPIO 用户空间 sysfs 已被弃用并且已停止维护。也就是说，它曾经面临许多问题，其中一些如下：
- en: State not tied to processes.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态不再与进程绑定。
- en: A lack of concurrent access management to sysfs attributes.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏对 sysfs 属性的并发访问管理。
- en: A lack of support for bulk GPIO operations, that is, performing operations on
    a set of GPIOs with a single command (in a single shot).
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏对批量 GPIO 操作的支持，也就是无法通过单个命令（一次性）对一组 GPIO 执行操作。
- en: A lot of operations were needed just to set a GPIO value (opening and writing
    into the export file, opening and writing into the direction file, opening and
    writing into the value file).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 GPIO 值时需要进行大量操作（打开并写入 export 文件，打开并写入 direction 文件，打开并写入 value 文件）。
- en: Unreliable polling – user code had to poll on `/sys/class/gpio/gpioX/`value,
    and on each event, it was necessary to `close/re-open` or `lseek` in the file
    before re-reading the new value. This could lead to events being lost.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可靠的轮询——用户代码必须在 `/sys/class/gpio/gpioX/value` 上轮询，每次事件发生时，必须 `close/re-open`
    或 `lseek` 文件后再重新读取新值，这可能导致事件丢失。
- en: It was not possible to set GPIO electrical properties.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法设置 GPIO 电气属性。
- en: If the process crashed, the GPIOs remained exported; there was no context concept.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程崩溃，GPIO 会保持已导出状态；没有上下文概念。
- en: 'To address the limits of the sysfs interface, a new GPIO interface has been
    developed, the descriptor-based GPIO interface. It comes with GPIO character devices
    – a new user API, merged in Linux v4.8\. This new interface has introduced the
    following improvements:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决 sysfs 接口的局限性，已经开发了新的 GPIO 接口，基于描述符的 GPIO 接口。它包含 GPIO 字符设备——一种新的用户 API，合并在
    Linux v4.8 中。这个新接口引入了以下改进：
- en: 'One device file per GPIO chip: `/dev/gpiochip0`, `/dev/gpiochip1`, `/dev/gpiochipX`
    ….'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 GPIO 芯片一个设备文件：`/dev/gpiochip0`、`/dev/gpiochip1`、`/dev/gpiochipX` 等。
- en: 'It''s similar to other kernel interfaces: `open()` + `ioctl()` + `poll()` +
    `read()` + `close()`.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这类似于其他内核接口：`open()` + `ioctl()` + `poll()` + `read()` + `close()`。
- en: It's possible to request multiple lines at once (for reading/setting values)
    using bulk-related APIs.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过批量相关 API，可以一次请求多个线路（用于读取/设置值）。
- en: It's possible to find GPIO lines and chips by name, which is much more reliable.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过名称查找 GPIO 线路和芯片，这样会更可靠。
- en: Open source and open-drain flags, user/consumer strings, and uevents.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源和开漏标志，用户/消费者字符串，以及 uevents。
- en: Reliable polling, preventing the loss of events.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠的轮询，防止事件丢失。
- en: '`Libgpiod` is shipped with a C API allowing you to get the most out of any
    GPIO chip registered on the system. That said, the C++ and Python languages are
    supported as well. The API is well documented, and too extensive to fully cover
    here. The basic use cases usually follow these steps:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`Libgpiod` 配备了 C API，允许你充分利用系统上注册的任何 GPIO 芯片。并且也支持 C++ 和 Python 语言。该 API 文档齐全，内容广泛，无法在这里完全覆盖。基本的使用案例通常遵循以下步骤：'
- en: Open the desired GPIO chip character device by calling one of the `gpiod_chip_open*`
    functions, such as `gpiod_chip_open_by_name()` or `gpiod_chip_open_lookup()`.
    This returns a pointer to `struct gpiod_chip`, which is used by subsequent API
    calls.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`gpiod_chip_open*`函数之一来打开所需的GPIO芯片字符设备，例如`gpiod_chip_open_by_name()`或`gpiod_chip_open_lookup()`。此函数将返回指向`struct
    gpiod_chip`的指针，该指针将在后续的API调用中使用。
- en: Retrieve the handle to the desired GPIO line by calling `gpiod_chip_get_line()`,
    which will return a pointer to an instance of `struct gpiod_line`. While the previous
    API returns the handle to a single GPIO line, the function `gpiod_chip_get_lines()`
    can be used if several GPIO lines are needed in a single shot. `gpiod_chip_get_lines()`
    will return a pointer to an instance of `struct gpiod_line_bulk`, which can be
    used later for bulk operations. The other API that can return a set of GPIO handles
    is `gpiod_chip_get_all_lines()`, which returns all the lines of a given GPIO chip
    in `struct gpiod_line_bulk`. When you have such a set of GPIO objects, you can
    request a GPIO line at a specific index local to this bulk object by using the
    `gpiod_line_bulk_get_line()` API.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`gpiod_chip_get_line()`来获取所需GPIO线路的句柄，该函数将返回指向`struct gpiod_line`实例的指针。虽然之前的API返回的是单个GPIO线路的句柄，但如果需要一次获取多个GPIO线路，可以使用`gpiod_chip_get_lines()`函数。`gpiod_chip_get_lines()`将返回指向`struct
    gpiod_line_bulk`实例的指针，该实例可用于后续的批量操作。另一个可以返回一组GPIO句柄的API是`gpiod_chip_get_all_lines()`，它会返回给定GPIO芯片的所有线路，存储在`struct
    gpiod_line_bulk`中。当你拥有这样的GPIO对象集时，可以使用`gpiod_line_bulk_get_line()`API来请求特定索引位置的GPIO线路。
- en: Request the use of the line as an input or output by calling `gpiod_line_request_input()`
    or `gpiod_line_request_output()`. For bulk operations on a set of GPIO lines,
    `gpiod_line_request_bulk_input()` or `gpiod_line_request_bulk_output()` can be
    used instead.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`gpiod_line_request_input()`或`gpiod_line_request_output()`来请求将线路用作输入或输出。对于一组GPIO线路的批量操作，可以改为使用`gpiod_line_request_bulk_input()`或`gpiod_line_request_bulk_output()`。
- en: Read the value of input GPIO lines by calling `gpiod_line_get_value()` for a
    single GPIO or `gpiod_line_get_value_bulk()` in the case of a set of GPIOs. For
    output GPIO lines, the level can be set by calling `gpiod_line_set_value()` for
    a single GPIO line or `gpiod_line_set_value_bulk()` on a set of output GPIOs.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`gpiod_line_get_value()`来读取单个GPIO线路的输入值，或者在处理一组GPIO时，使用`gpiod_line_get_value_bulk()`。对于输出GPIO线路，可以通过调用`gpiod_line_set_value()`来设置单个GPIO线路的电平，或者使用`gpiod_line_set_value_bulk()`来设置一组输出GPIO的电平。
- en: When done, release the lines by calling `gpiod_line_release()` or `gpiod_line_release_bulk()`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，通过调用`gpiod_line_release()`或`gpiod_line_release_bulk()`来释放线路。
- en: Once all the GPIO lines have been released, the associated chips can be released
    using `gpiod_chip_close()` on each.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有GPIO线路被释放，可以通过对每个GPIO芯片调用`gpiod_chip_close()`来释放相关芯片。
- en: '`gpiod_line_release()` is to be called once done with a GPIO line. The GPIO
    line to release is passed as a parameter. If it is, however, a set of GPIOs that
    needs to be released, `gpiod_line_release_bulk()` should be used instead. It has
    to be noted that if the lines were not previously requested together (were not
    requested with `gpiod_line_request_bulk()`), the behavior of `gpiod_line_release_bulk()`
    is undefined.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后应调用`gpiod_line_release()`来释放GPIO线路。释放的GPIO线路作为参数传入。然而，如果需要释放的是一组GPIO，应该改为使用`gpiod_line_release_bulk()`。需要注意的是，如果这些线路之前没有一起请求过（没有使用`gpiod_line_request_bulk()`进行请求），那么调用`gpiod_line_release_bulk()`的行为是未定义的。
- en: 'There are sanity APIs it might worth mentioning, which are defined as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些可能值得一提的健全性API，定义如下：
- en: '[PRE62]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding APIs, `gpiod_line_is_requested()` can be used to check if the
    calling user owns this GPIO line. This function returns `true` if `line` was already
    requested, or `false` otherwise. It is different from `gpiod_line_is_free()`,
    which is used to check if the calling user has neither requested ownership `line`
    nor set up any event notifications on it. It returns `true` if `line` is free,
    and `false` otherwise.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的API中，`gpiod_line_is_requested()`可用于检查调用的用户是否拥有该GPIO线路。此函数如果`line`已经被请求，则返回`true`，否则返回`false`。它不同于`gpiod_line_is_free()`，后者用于检查调用的用户是否既没有请求该`line`的所有权，也没有在其上设置任何事件通知。它如果`line`是空闲的，则返回`true`，否则返回`false`。
- en: Other APIs are available for more advanced functions such as configuring pin
    modes for pullup or pulldown resistors or registering a callback function to be
    called when an event occurs, such as the level of an input pin changing, as we
    will see in the next section.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 其他API可用于实现更高级的功能，如为上拉或下拉电阻配置引脚模式，或注册回调函数，在事件发生时调用该函数，例如输入引脚电平变化的情况，正如我们将在下一节中看到的。
- en: Event- (interrupt-) driven GPIO
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动（中断驱动）GPIO
- en: Interrupt-driven GPIO handling consists of grabbing one (`struct gpiod_line`)
    or more (`struct gpiod_line_bulk`) GPIO handles and listening for events on these
    GPIO lines, either infinitely or in a timed manner.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 中断驱动的GPIO处理包括获取一个（`struct gpiod_line`）或多个（`struct gpiod_line_bulk`）GPIO句柄，并监听这些GPIO线路上的事件，事件监听可以是无限期的或定时的。
- en: 'A GPIO line event is abstracted by a `struct gpiod_line_event` object, defined
    as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO线路事件通过一个`struct gpiod_line_event`对象进行抽象，定义如下：
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding data structure, `ts` is the time specifier data structure to
    represent the wait event timeout, and `event_type` is the type of event, which
    can be either `GPIOD_LINE_EVENT_RISING_EDGE` or `GPIOD_LINE_EVENT_FALLING_EDGE`,
    respectively for a rising edge event or a falling edge event.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述数据结构中，`ts`是表示等待事件超时的时间规范数据结构，`event_type`是事件类型，它可以是`GPIOD_LINE_EVENT_RISING_EDGE`或`GPIOD_LINE_EVENT_FALLING_EDGE`，分别表示上升沿事件或下降沿事件。
- en: 'After the GPIO handle(s) has been obtained using `gpiod_chip_get_line()` or
    `gpiod_chip_get_lines()` or `gpiod_chip_get_all_lines()`, the user code should
    request events of interest on these GPIO handles using one of the following APIs:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`gpiod_chip_get_line()`、`gpiod_chip_get_lines()`或`gpiod_chip_get_all_lines()`获取GPIO句柄后，用户代码应使用以下API之一请求在这些GPIO句柄上发生感兴趣的事件：
- en: '[PRE64]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The preceding APIs request either rising edge, falling edge, or both edge events,
    respectively on a single GPIO line or on a set of GPIO (the bulk-related API).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 上述API分别请求单个GPIO线路或一组GPIO线路上的上升沿、下降沿或双沿事件（即与批量相关的API）。
- en: 'After the events have been requested, the user code can wait on the GPIO lines
    of interest, waiting for the requested events to occur using one of the following
    APIs:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求了事件之后，用户代码可以使用以下API之一，等待感兴趣的GPIO线路上的事件发生：
- en: '[PRE65]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding, `gpiod_line_event_wait()` waits for event(s) on a single GPIO
    line, while `gpiod_line_event_wait_bulk()` will wait on a set of GPIOs. In parameters,
    `line` is the GPIO line on which to wait events in the case of single GPIO monitoring,
    while `bulk` is the set of GPIO lines in the case of bulk monitoring. Finally,
    `event_bulk` is an output parameter, holding the set of GPIO lines on which the
    GPIO events of interest have occurred. These are all blocking APIs, which will
    continue execution flow only after the events of interest have occurred or after
    a timeout.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，`gpiod_line_event_wait()`用于等待单个GPIO线路上的事件，而`gpiod_line_event_wait_bulk()`则会等待一组GPIO线路上的事件。在参数中，`line`是用于单个GPIO监控时等待事件的GPIO线路，而`bulk`是用于批量监控时的一组GPIO线路。最后，`event_bulk`是一个输出参数，保存着发生感兴趣事件的GPIO线路集合。这些都是阻塞API，只有在感兴趣的事件发生或超时后，才会继续执行流程。
- en: 'Once the blocking function returns, `gpiod_line_event_read()` must be used
    to read the events that occurred on the GPIO line(s) returned by the previously
    mentioned monitoring functions. This API has the following prototype:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦阻塞函数返回，必须使用`gpiod_line_event_read()`来读取在之前提到的监控函数返回的GPIO线路上发生的事件。此API的原型如下：
- en: '[PRE66]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: On error, this API returns `-1`, otherwise, it returns `0`. In parameters, `line`
    is the GPIO line to read the events on, and `event` is an output parameter, the
    event buffer to which the event data will be copied.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出错，API返回`-1`，否则返回`0`。在参数中，`line`是要读取事件的GPIO线路，`event`是输出参数，事件数据将被复制到该事件缓冲区。
- en: 'The following is an example of requesting an event and reading and processing
    that event:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是请求事件、读取和处理该事件的示例：
- en: '[PRE67]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the preceding snippet, we first look up the GPIO chip by its name and use
    the returned GPIO chip handle to grab a handle on GPIO line #25\. Next, we request
    a rising events notification (interrupt-driven) on the GPIO line. After that,
    we loop on waiting for events to happen, read which event it was, and validate
    that it''s a rising event.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们首先通过名称查找GPIO芯片，并使用返回的GPIO芯片句柄获取GPIO线路#25的句柄。接下来，我们请求在该GPIO线路上触发上升沿事件通知（中断驱动）。然后，我们进入循环，等待事件的发生，读取发生了什么事件，并验证它是否是上升沿事件。
- en: 'Apart from the previous code example, let''s now imagine a much complex example,
    where we monitor five GPIO lines, and let''s start by feeding the required headers:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的代码示例外，假设现在有一个更复杂的例子，我们监控五个GPIO线，首先需要引入必要的头文件：
- en: '[PRE68]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, let''s provide the static variables we will use in the program:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，让我们提供程序中使用的静态变量：
- en: '[PRE69]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the previous snippet, `chip` will hold the handle to the GPIO chip that we
    are interested in. `gpio_lines` will hold the handles of the event-driven GPIO
    lines, that is, the GPIO lines to be monitored. Finally, `gpio_events` will be
    given to the library so that upon monitoring, it is filled with the handles of
    GPIO lines on which events have occurred.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`chip`将持有我们感兴趣的GPIO芯片的句柄。`gpio_lines`将持有事件驱动的GPIO线的句柄，即需要被监控的GPIO线。最后，`gpio_events`将传递给库函数，监控过程中，该参数会被填充为发生事件的GPIO线的句柄。
- en: 'Finally, let''s start implementing our `main` method:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们开始实现`main`方法：
- en: '[PRE70]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the previous snippet, we have simply opened the GPIO chip device and kept
    a pointer to it. Next, we will have to grab handles of the GPIO lines of interest
    and store them in `gpio_lines`:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们仅仅是打开了GPIO芯片设备并保持了指向它的指针。接下来，我们需要获取感兴趣的GPIO线句柄，并将它们存储在`gpio_lines`中：
- en: '[PRE71]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, we use these GPIO line handles to request event monitoring on their underlying
    GPIO lines. Because we are interested in more than one GPIO, we use the `bulk`
    API variant, as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这些GPIO线句柄来请求它们底层GPIO线的事件监控。因为我们感兴趣的是多个GPIO线，所以我们使用`bulk` API变体，如下所示：
- en: '[PRE72]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the previous snippet, `gpiod_line_request_bulk_rising_edge_events()` will
    request rising edge event notifications. Now that we have requested event-driven
    monitoring for our GPIO, we can call the blocking monitoring API on these GPIO
    lines, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`gpiod_line_request_bulk_rising_edge_events()`将请求上升沿事件通知。现在我们已经为GPIO请求了事件驱动的监控，可以在这些GPIO线上的阻塞监控API如下调用：
- en: '[PRE73]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In the previous excerpt, since we need time-bounded event polling, we set up
    a `struct timespec` data structure with the desired timeout and we pass it to
    `gpiod_line_event_wait_bulk()`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，由于我们需要时间限制的事件轮询，我们设置了一个`struct timespec`数据结构，其中包含期望的超时值，并将其传递给`gpiod_line_event_wait_bulk()`。
- en: That said, reaching this step (passing the polling function) would mean that
    either the blocking monitoring API has timed out or that an event occurred on
    at least one of the GPIO lines that are monitored. The GPIO handles on which events
    occurred are stored in `gpio_events`, which is an output argument, and the list
    of monitored GPIO lines is passed in `gpio_lines`. It must be noted that both
    `gpio_lines` and `gpio_events` are bulk GPIO data structures.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，达到这一步（通过轮询函数）意味着要么阻塞监控API超时，要么至少有一个被监控的GPIO线上发生了事件。发生事件的GPIO句柄存储在`gpio_events`中，这是一个输出参数，而被监控的GPIO线列表则通过`gpio_lines`传递。需要注意的是，`gpio_lines`和`gpio_events`都是批量GPIO数据结构。
- en: 'If ever we are interested in reading the values of the GPIO lines on which
    events have occurred, we could do the following:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有兴趣读取发生事件的GPIO线的值，可以按如下方式进行操作：
- en: '[PRE74]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If instead of reading the values of GPIO lines on which events occurred we needed
    to read the value of all the monitored GPIO lines, we would have replaced `gpio_events`
    with `gpio_lines` in the previous code.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想读取发生事件的GPIO线的值，而是需要读取所有被监控GPIO线的值，我们可以将前面的代码中的`gpio_events`替换为`gpio_lines`。
- en: 'Next, if we are interested in the type of event that occurred on each GPIO
    line in `gpio_events`, we can do the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们对`gpio_events`中每个GPIO线发生的事件类型感兴趣，可以按如下方式操作：
- en: '[PRE75]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In the preceding code, we iterate over each GPIO line in `gpio_events`, which
    represents the list of GPIO lines on which events have occurred. `gpiod_line_bulk_num_lines()`
    retrieves the number of GPIO lines held by the line bulk object, and `gpiod_line_bulk_get_line()`
    retrieves the line handle from a line bulk object at the given offset, local to
    this line bulk object. You should, however, note that to achieve the same goal,
    we could have used the `gpiod_line_bulk_foreach_line()` macro.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们遍历了`gpio_events`中的每个GPIO线，该列表表示已发生事件的GPIO线。`gpiod_line_bulk_num_lines()`函数获取线批量对象中所持有的GPIO线数量，`gpiod_line_bulk_get_line()`函数根据给定的偏移量，从线批量对象中获取对应的线句柄，这个偏移量是本地的。需要注意的是，为了实现相同的目标，我们本可以使用`gpiod_line_bulk_foreach_line()`宏。
- en: Then, on each GPIO line in the line bulk object, we invoke `gpiod_line_event_read()`,
    `gpiod_line_name()`, and `gpiod_line_offset()`. The first function will retrieve
    the event data structure corresponding to the event that occurred on that line.
    We could have then checked that the event type that occurred (especially when
    monitoring for both event types) is what we expected using something such as `if
    (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)`, for example. The second function
    is a helper that will retrieve the GPIO line name, while the third one, `gpiod_line_offset()`,
    will retrieve the GPIO line offset, global to the running system.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在每个批量对象中的 GPIO 引脚上，我们调用 `gpiod_line_event_read()`、`gpiod_line_name()` 和 `gpiod_line_offset()`。第一个函数将检索与该引脚上发生的事件对应的事件数据结构。接下来，我们可以使用类似
    `if (event.event_type != GPIOD_LINE_EVENT_RISING_EDGE)` 这样的代码检查发生的事件类型（尤其是在同时监控两种事件类型时）是否符合预期。第二个函数是一个辅助函数，用于检索
    GPIO 引脚名称，而第三个函数 `gpiod_line_offset()` 则检索 GPIO 引脚的偏移量，这是全局于运行中的系统的。
- en: If we were interested in monitoring these GPIO lines infinitely or for a certain
    number of rounds, we could have wrapped the code between the `marker1` and `marker2`
    labels into a `while()` or a `for()` loop.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要无限期地或在特定轮次内监控这些 GPIO 引脚，我们可以将 `marker1` 和 `marker2` 标签之间的代码包裹在 `while()`
    或 `for()` 循环中。
- en: 'At the end of the execution flow, we do some cleaning, like the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行流程结束时，我们进行一些清理工作，例如：
- en: '[PRE76]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The previous cleaning code snippet first releases all the GPIO lines that we
    have requested, and then closes the associated GPIO chip.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的清理代码片段首先释放我们请求的所有 GPIO 引脚，然后关闭相关的 GPIO 芯片。
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It must be noted that bulk GPIO monitoring must be done on a per GPIO chip basis.
    That is, it is not recommended to embed GPIO lines from different GPIO chips in
    the same line bulk object.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，批量 GPIO 监控必须按每个 GPIO 芯片进行。也就是说，不建议将来自不同 GPIO 芯片的 GPIO 引脚嵌入到同一批量对象中。
- en: Now that we are done with API usage and have demonstrated it in a practical
    example, we can switch to command-line tools shipped with the `libgpiod` library.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 API 的使用并在实践中演示了它，我们可以切换到与 `libgpiod` 库一起提供的命令行工具。
- en: Command-line tools
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行工具
- en: 'If you simply need to perform simple GPIO operations, the `Gpiod` library includes
    a collection of command-line tools that are particularly handy for interactively
    exploring GPIO functions and can be used in shell scripts to avoid the need to
    write C or C++ code. There are the following commands available:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要执行简单的 GPIO 操作，`Gpiod` 库包括一组特别方便的命令行工具，这些工具可以用于交互式地探索 GPIO 功能，并可以在 shell
    脚本中使用，避免编写 C 或 C++ 代码。以下是可用的命令：
- en: '`gpiodetect`: Displays the list of all GPIO chips on the system, together with
    their names, labels, and the number of GPIO lines.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpiodetect`: 显示系统上所有 GPIO 芯片的列表，包括它们的名称、标签和 GPIO 引脚的数量。'
- en: '`gpioinfo`: Displays the names, consumers, direction, active status, and other
    flags for all lines of the selected GPIO chips. `gpioinfo gpiochip6` is an example.
    If no GPIO chip is given, the command will iterate through all GPIO chips on the
    system and list their associated lines.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpioinfo`: 显示所选 GPIO 芯片所有引脚的名称、使用者、方向、活动状态和其他标志。`gpioinfo gpiochip6` 是一个示例。如果未指定
    GPIO 芯片，命令将遍历系统中的所有 GPIO 芯片并列出其相关引脚。'
- en: '`gpioget`: Gets the values of GPIO lines specified.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpioget`: 获取指定的 GPIO 引脚的值。'
- en: '`gpioset`: Sets the values of specified GPIO lines, and potentially keeps them
    exported until a timeout, user input, or signal occurs.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpioset`: 设置指定 GPIO 引脚的值，并可能将其保持导出，直到发生超时、用户输入或信号。'
- en: '`gpiofind`: Given a line name, this command finds the associated GPIO chip
    name and line offset.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpiofind`: 给定一个引脚名称，找到相关的 GPIO 芯片名称和引脚偏移量。'
- en: '`gpiomon`: Monitors GPIOs by waiting for events on these lines. This command
    allows you to specify which events to watch and how many of them should be processed
    before exiting or whether the events should be reported to the console.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gpiomon`: 通过等待这些引脚上的事件来监控 GPIO。此命令允许你指定要监控的事件以及在退出前应处理多少个事件，或者是否将事件报告到控制台。'
- en: Now that we have listed the available command-line tools, we can go on to learn
    about another mechanism offered by the GPIO subsystem, and that can be leveraged
    from the user space, thanks to which we can use the aforementioned tools.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们列出了可用的命令行工具，我们可以继续了解 GPIO 子系统提供的另一种机制，这使得我们可以在用户空间中利用这些工具。
- en: The GPIO aggregator
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO 聚合器
- en: GPIO access control now uses permissions on `/dev/gpiochip*` with the new interface.
    The typical Unix filesystem permissions enable all-or-nothing access control to
    these character devices. Compared to the earlier `/sys/class/gpio` interface,
    this new interface provides a number of advantages, which we listed at the beginning
    of the *Welcome to the Libgpiod GPIO library* section. One disadvantage, however,
    is that it creates one device file per GPIO chip, implying that access privileges
    are defined on a per GPIO chip basis, rather than per GPIO line.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GPIO访问控制使用新接口上的`/dev/gpiochip*`权限。典型的Unix文件系统权限使得这些字符设备的访问控制采用全有或全无的方式。与早期的`/sys/class/gpio`接口相比，这种新接口提供了许多优点，我们在*欢迎使用Libgpiod
    GPIO库*章节的开头列出了这些优点。然而，一个缺点是，它为每个GPIO芯片创建了一个设备文件，这意味着访问权限是在每个GPIO芯片的基础上定义的，而不是每个GPIO线路。
- en: As a result, the `/dev/gpiochip*` device.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`/dev/gpiochip*`设备。
- en: This feature is handy for designating a set of GPIOs to a certain user and implementing
    access control. Furthermore, exporting GPIOs to a virtual machine is simplified
    and hardened because the virtual machine can just grab the entire GPIO controller
    and no longer has to worry about which GPIOs to grab and which not to, decreasing
    the attack surface. `Documentation/admin-guide/gpio/gpio-aggregator.rst` is where
    you'll find its documentation.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能对于将一组GPIO指定给特定用户并实施访问控制非常有用。此外，将GPIO导出到虚拟机也变得更加简化和安全，因为虚拟机只需获取整个GPIO控制器，不再需要担心哪些GPIO需要获取，哪些不需要，从而减少了攻击面。其文档可以在`Documentation/admin-guide/gpio/gpio-aggregator.rst`中找到。
- en: To have GPIO aggregator support in your kernel, you must have `CONFIG_GPIO_AGGREGATOR=y`
    in your kernel configuration. This feature can be configured either via sysfs
    or the device tree, as we will see in the next sections.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要在内核中支持GPIO聚合器，必须在内核配置中启用`CONFIG_GPIO_AGGREGATOR=y`。此功能可以通过sysfs或设备树配置，正如我们将在接下来的章节中看到的那样。
- en: Aggregating GPIOs using sysfs
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sysfs聚合GPIO
- en: Aggregated GPIO controllers are instantiated and destroyed by writing to write-only
    attribute files in sysfs, mainly from the `/sys/bus/platform/drivers/gpio-aggregator/`
    directory.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的GPIO控制器通过向sysfs中的只写属性文件写入进行实例化和销毁，主要来自`/sys/bus/platform/drivers/gpio-aggregator/`目录。
- en: 'This directory contains the followings attributes:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录包含以下属性：
- en: '`new_device`: Used to ask the kernel to instantiate an aggregated GPIO controller
    by writing a string describing the GPIOs to aggregate. The `new_device` file understands
    the format `[<gpioA>] [<gpiochipB> <offsets>] ...`:'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_device`：用于通过写入描述要聚合的GPIO的字符串来请求内核实例化一个聚合的GPIO控制器。`new_device`文件理解格式`[<gpioA>]
    [<gpiochipB> <offsets>] ...`：'
- en: '`<gpioA>` is a GPIO line name.'
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<gpioA>`是GPIO线路名称。'
- en: '`<gpiochipB>` is a GPIO chip label.'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<gpiochipB>`是GPIO芯片标签。'
- en: '`<offsets>` is a comma-separated list of GPIO offsets and/or GPIO offset ranges
    denoted by dashes.'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<offsets>`是一个用逗号分隔的GPIO偏移量和/或GPIO偏移量范围（以破折号表示）的列表。'
- en: '`delete_device`: Used to ask the kernel to destroy an aggregated GPIO controller
    after use.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_device`：用于请求内核在使用后销毁聚合的GPIO控制器。'
- en: 'The following is an example that instantiated a new GPIO aggregator by aggregating
    GPIO line 19 of `e6052000.gpio` and GPIO lines 20-21 of `e6050000.gpio` into a
    new `gpio_chip`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，通过将`e6052000.gpio`的GPIO线路19与`e6050000.gpio`的GPIO线路20-21聚合到一个新的`gpio_chip`中来实例化一个新的GPIO聚合器：
- en: '[PRE77]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After use, the previously created aggregated GPIO controller can be destroyed
    using the following command, assuming it is named `gpio-aggregator.0`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后，可以通过以下命令销毁先前创建的聚合GPIO控制器，假设其名称为`gpio-aggregator.0`：
- en: '[PRE78]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: From the previous example, the GPIO chip that resulted from the aggregation
    was `gpiochip12`, having three GPIO lines. Instead of `gpioinfo gpio-aggregator.0`,
    we could have used `gpioinfo gpiochip12`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的示例来看，聚合后的GPIO芯片是`gpiochip12`，其拥有三条GPIO线路。我们本可以使用`gpioinfo gpiochip12`，而不是`gpioinfo
    gpio-aggregator.0`。
- en: Aggregating GPIOs from the device tree
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从设备树中聚合GPIO
- en: The device tree can also be used to aggregate GPIOs. To do so, simply define
    a node with `gpio-aggregator` as a compatible string and set the `gpios` property
    to the list of GPIOs that you want to be part of the new GPIO chip. A unique feature
    of this technique is that, like any other GPIO controller, the GPIO lines can
    be named and subsequently queried by user-space applications using the `libgpiod`
    library.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树也可以用来聚合GPIO。为此，只需定义一个节点，使用`gpio-aggregator`作为兼容字符串，并将`gpios`属性设置为希望成为新GPIO芯片一部分的GPIO列表。此技术的一个独特之处在于，像任何其他GPIO控制器一样，GPIO线路可以被命名，并随后通过使用`libgpiod`库的用户空间应用程序查询。
- en: 'In the following, we will demonstrate the use of the GPIO aggregator with several
    GPIO lines from the device tree. First, we enumerate the pins we need to use GPIOs
    in our new GPIO chip. We do this under the pin controller node as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示如何使用来自设备树的多个 GPIO 线路与 GPIO 聚合器。首先，我们列出在新 GPIO 芯片中需要使用的引脚。我们在引脚控制器节点下进行如下操作：
- en: '[PRE79]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now that our pins have been configured, we can declare our GPIO aggregator
    as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了引脚，可以按如下方式声明我们的 GPIO 聚合器：
- en: '[PRE80]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: In this example, `pinctrl_aggregator_pins` is the GPIO pin node, which must
    have been instantiated under the pin controller node. `gpios` contains the list
    of GPIO lines the new GPIO chip must be made of. At the end, the meaning of `gpio-line-names`
    is line 30 of GPIO controller `gpio3` is used and is named `line_a`, line 23 of
    GPIO controller `gpio3` is used and is named `line_b`, line 29 of GPIO controller
    `gpio1` is used and named `line_c`, and so on up to line 1 of GPIO controller
    `gpio7`, which is named `line_h`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`pinctrl_aggregator_pins`是 GPIO 引脚节点，它必须已经在引脚控制器节点下实例化。`gpios`包含了新 GPIO
    芯片必须由哪些 GPIO 线路组成的列表。最后，`gpio-line-names`的意思是：GPIO 控制器`gpio3`的第 30 号引脚被使用并命名为`line_a`，GPIO
    控制器`gpio3`的第 23 号引脚被使用并命名为`line_b`，GPIO 控制器`gpio1`的第 29 号引脚被使用并命名为`line_c`，依此类推，到
    GPIO 控制器`gpio7`的第 1 号引脚，命名为`line_h`。
- en: 'From the user space, we can see the GPIO chip and its aggregated lines:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间，我们可以看到 GPIO 芯片及其聚合的线路：
- en: '[PRE81]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can search a GPIO chip and a line number by the line name:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过线路名称搜索 GPIO 芯片和线路号：
- en: '[PRE82]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We can access a GPIO line by its name:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引脚名称访问 GPIO 线路：
- en: '[PRE83]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can change the GPIO chip device file ownership to allow user or group to
    access the attached lines:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改 GPIO 芯片设备文件的所有权，以允许用户或组访问附加的线路：
- en: '[PRE84]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The GPIO chip created by the aggregator can be retrieved from sysfs in `/sys/bus/platform/devices/gpio-aggregator/`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由聚合器创建的 GPIO 芯片可以从 sysfs 中获取，路径为`/sys/bus/platform/devices/gpio-aggregator/`。
- en: Aggregating GPIOs using a generic GPIO driver
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通用 GPIO 驱动程序聚合 GPIO
- en: Without a particular in-kernel driver, the GPIO aggregator can be used as a
    generic driver for a simple GPIO-operated device described in the device tree.
    Modifying the `gpio-aggregator` driver or writing to the `driver_override` file
    in sysfs are both options for binding a device to the GPIO aggregator.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有特定的内核驱动程序，GPIO 聚合器可以作为一个通用驱动程序，用于设备树中描述的简单 GPIO 操作设备。修改`gpio-aggregator`驱动程序或在
    sysfs 中写入`driver_override`文件都是将设备绑定到 GPIO 聚合器的选项。
- en: Before we go further, let's talk about the `driver_override` file; this file
    is more precisely located in `/sys/bus/platform/devices/.../driver_override`.
    This file specifies the driver for a device, which will override the standard
    device tree, ACPI, ID table, and name matching, as we have seen in [*Chapter 6*](B17934_06_Epub.xhtml#_idTextAnchor095),
    *Introduction to Devices, Drivers, and Platform Abstraction*. It has to be noted
    that only a driver whose name matches the value written to `driver_override` will
    be able to bind to the device. The override is set by writing a string to the
    `driver_override` file (`echo vfio-platform > driver_override`), and it can be
    cleared by writing an empty string to the file (`echo > driver_override`). This
    reverts the device to its default binding of matching rules. It must, however,
    be noted that writing to driver override does not unbind the device from its existing
    driver or attempt to load the supplied driver automatically. The device will not
    bind to any driver if no driver with a matching name is currently loaded in the
    kernel. Devices can also use a `driver_override` name such as `none` to opt out
    of driver binding. There is no support for parsing delimiters, and only a single
    driver can be given in the override.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们先讨论一下`driver_override`文件；该文件位于`/sys/bus/platform/devices/.../driver_override`。此文件指定设备的驱动程序，将覆盖标准设备树、ACPI、ID
    表和名称匹配，正如我们在[*第6章*](B17934_06_Epub.xhtml#_idTextAnchor095)《设备、驱动程序与平台抽象介绍》中所见。需要注意的是，只有名称与写入`driver_override`的值匹配的驱动程序才能绑定到该设备。覆盖操作通过向`driver_override`文件写入一个字符串来设置（`echo
    vfio-platform > driver_override`），并且可以通过向文件写入空字符串来清除（`echo > driver_override`）。这将设备恢复到默认的匹配规则绑定。然而，必须注意，写入`driver_override`并不会解除设备与现有驱动程序的绑定，也不会自动加载提供的驱动程序。如果没有加载具有匹配名称的驱动程序，设备将不会绑定到任何驱动程序。设备还可以使用`driver_override`名称，如`none`，来选择不进行驱动程序绑定。`driver_override`不支持解析分隔符，并且只能提供一个驱动程序。
- en: 'For example, given a `door` device, which is a GPIO-operated device described
    in the device tree, use its own compatible value as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个`door`设备，它是一个由GPIO操作的设备，描述在设备树中，使用其自己的兼容值，如下所示：
- en: '[PRE85]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'It can be bound to the GPIO aggregator with either of the following methods:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过以下任一方法绑定到GPIO聚合器：
- en: Adding its compatible value to `gpio_aggregator_dt_ids[]` in `drivers/gpio/gpio-aggregator.c`
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其兼容值添加到`drivers/gpio/gpio-aggregator.c`中的`gpio_aggregator_dt_ids[]`
- en: Binding manually using `driver_override`
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`driver_override`手动绑定
- en: 'The first method is quite straightforward:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法非常直接：
- en: '[PRE86]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the previous commands, we have written the driver's name (`gpio-aggregator`
    in this case) in the `driver_override` file present in the device directory, `/sys/bus/platform/devices/<device-name>/`.
    After that, we have bound the device to the driver by writing the device name
    in the `bind` file present in the driver's directory, `/sys/bus/<bus-name>/drivers/<driver-name>/`.
    It has to be noted that `<bus-name>` corresponds to the bus framework the driver
    belongs to. It could be `i2c`, `spi`, `platform`, `pci`, `isa`, `usb`, and so
    on.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的命令中，我们已将驱动程序的名称（此处为`gpio-aggregator`）写入设备目录`/sys/bus/platform/devices/<device-name>/`中的`driver_override`文件。之后，我们通过将设备名称写入驱动目录`/sys/bus/<bus-name>/drivers/<driver-name>/`中的`bind`文件，将设备绑定到驱动程序。需要注意的是，`<bus-name>`对应于驱动程序所属的总线框架。它可以是`i2c`、`spi`、`platform`、`pci`、`isa`、`usb`等。
- en: 'After the binding, a new GPIO chip, `door`, will be created. Its information
    can then be carried out as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定后，将创建一个新的GPIO芯片`door`。然后，可以如下操作获取其信息：
- en: '[PRE87]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Next, the library APIs can be used on this GPIO chip like any other normal (non-virtual)
    GPIO chip.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，可以像任何其他正常（非虚拟）GPIO芯片一样，使用库API在这个GPIO芯片上进行操作。
- en: We are now done with GPIO aggregation from the user space in particular, and
    with GPIO management from the user space in general. We have learned how to create
    virtual GPIO chips to isolate a set of GPIOs, and we have learned how to use the
    GPIO library to drive these GPIOs.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了特别是从用户空间的GPIO聚合，以及一般的用户空间GPIO管理。我们已经学会了如何创建虚拟GPIO芯片以隔离一组GPIO，并且学会了如何使用GPIO库来驱动这些GPIO。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the pin control framework and described its interaction
    with the GPIO subsystem. We learned how to deal with GPIOs, either as a controller
    or consumer, from both the kernel and the user space. Though the legacy integer-based
    interface is deprecated, it was introduced because it is still widely used. Additionally,
    we introduced some advanced topics such as IRQ chip support in the GPIO chip and
    the mapping of GPIOs to IRQs. We ended this chapter by learning how to deal with
    GPIOs from the user space, by writing C code or by using dedicated command-line
    tools provided by the standard Linux GPIO library, `libgpiod`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了引脚控制框架，并描述了它与GPIO子系统的交互。我们学习了如何从内核和用户空间处理GPIO，无论是作为控制器还是消费者。尽管遗留的基于整数的接口已被弃用，但由于它仍然被广泛使用，因此我们介绍了它。此外，我们还介绍了一些高级话题，如GPIO芯片中的IRQ芯片支持以及GPIO与IRQ的映射。本章的结尾，我们学习了如何通过编写C代码或使用标准Linux
    GPIO库`libgpiod`提供的专用命令行工具，从用户空间处理GPIO。
- en: In the next chapter, we deal with input devices, which can be implemented using
    GPIOs.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论输入设备，它们可以通过GPIO实现。
