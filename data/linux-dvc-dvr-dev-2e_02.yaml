- en: '*Chapter 1*: Introduction to Kernel Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：内核开发简介'
- en: '**Linux** started as a hobby project in 1991 by a Finnish student, Linus Torvalds.
    The project has gradually grown and continues to do so, with roughly a thousand
    contributors around the world. Nowadays, Linux is a must, in embedded systems
    as well as on servers. A **kernel** is a central part of an operating system,
    and its development is not straightforward. Linux offers many advantages over
    other operating systems; it is free of charge, well documented with a large community,
    is portable across different platforms, provides access to the source code, and
    has a lot of free open source software.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux** 起初是芬兰学生 Linus Torvalds 于 1991 年发起的一个兴趣项目。该项目逐渐发展壮大，目前全球约有千名贡献者。如今，Linux
    已成为嵌入式系统以及服务器中不可或缺的一部分。**内核**是操作系统的核心部分，其开发并非简单。Linux 相对于其他操作系统有许多优势；它是免费的，文档完善并拥有庞大的社区，能够跨平台移植，提供源代码访问，并且有大量免费的开源软件。'
- en: This book will try to be as generic as possible. There is a special topic, known
    as the device tree, that is not a full **x86** feature yet. This topic will be
    dedicated to ARM processors, especially those that fully support the device tree.
    Why those architectures? Because they are mostly used on desktops and servers
    (for x86), as well as embedded systems (ARM).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将尽量保持通用性。有一个特殊的主题，称为设备树，尚未完全成为**x86**特性。该主题将专门讨论 ARM 处理器，特别是那些完全支持设备树的 ARM
    处理器。为什么选择这些架构？因为它们主要用于桌面和服务器（x86）以及嵌入式系统（ARM）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the development environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Understanding the kernel configuration process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内核配置过程
- en: Building your kernel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建内核
- en: Setting up the development environment
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: 'When you''re working in embedded system fields, there are terms you must be
    familiar with, before even setting up your environment. They are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从事嵌入式系统领域工作时，有一些术语你必须熟悉，甚至在设置环境之前。它们如下：
- en: '**Target**: This is the machine that the binaries resulting from the build
    process are produced for. This is the machine that is going to run the binary.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：这是构建过程生成二进制文件的机器。这个机器将运行该二进制文件。'
- en: '**Host**: This is the machine where the build process takes place.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宿主**：这是构建过程发生的机器。'
- en: '**Compilation**: This is also called native compilation or a **native build**.
    This happens when the target and the host are the same; that is, when you''re
    building on machine A (the host) a binary that is going to be executed on the
    same machine (A, the target) or a machine of the same kind. Native compilation
    requires a native compiler. Therefore, a native compiler is one where the target
    and the host are the same.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：这也叫做本地编译或**本地构建**。当目标和宿主相同，即你在机器 A（宿主）上构建一个将在同一台机器（A，目标）或相同类型的机器上执行的二进制文件时，就会发生本地编译。本地编译需要本地编译器。因此，本地编译器是指目标和宿主相同的编译器。'
- en: '**Cross-compilation**: Here, the target and the host are different. It is where
    you build a binary from machine A (the host) that is going to be executed on machine
    B (the target). In this case, the host (machine A) must have installed the cross-compiler
    that supports the target architecture. Thus, a cross-compiler is a compiler where
    the target is different from the host.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉编译**：在这里，目标和宿主是不同的。它是指你从机器 A（宿主）构建一个二进制文件，最终将在机器 B（目标）上执行。在这种情况下，宿主（机器
    A）必须安装支持目标架构的交叉编译器。因此，交叉编译器是一个目标和宿主不同的编译器。'
- en: Because embedded computers have limited or reduced resources (CPU, RAM, disk,
    and so on), it is common for the hosts to be x86 machines, which are much more
    powerful and have far more resources to speed up the development process. However,
    over the past few years, embedded computers have become more powerful, and they
    tend to be used for native compilation (thus used as the host). A typical example
    is the Raspberry Pi 4, which has a powerful quad-core CPU and up to 8 GB of RAM.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于嵌入式计算机资源有限或减少（如 CPU、RAM、磁盘等），通常宿主机为 x86 机器，这些机器更强大，资源更多，有助于加速开发过程。然而，在过去几年中，嵌入式计算机变得更强大，越来越倾向于用于本地编译（因此作为宿主）。一个典型的例子是
    Raspberry Pi 4，它配备了强大的四核 CPU 和最高 8 GB 的 RAM。
- en: In this chapter, we will be using an x86 machine as the host, either to create
    a native build or for cross-compilation. So, any "native build" term will refer
    to an "x86 native build." Due to this, I'm running **Ubuntu 18.04**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用x86机器作为主机，进行本地构建或交叉编译。因此，任何“本地构建”的术语都将指“x86本地构建”。基于此，我正在运行**Ubuntu
    18.04**。
- en: 'To quickly check this information, you can use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速检查这些信息，你可以使用以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: My computer is an `lscpu` command to pull this information out), 16 GB of RAM,
    256 GB of SSD, and a 1 TB magnetic hard drive (information that you can obtain
    using the `df -h` command). That said, a quad-core CPU and 4 or 8 GB of RAM could
    be enough, but at the cost of an increased build duration. My favorite editor
    is **Vim**, but you are free to use the one you are most comfortable with. If
    you are using a desktop machine, you could use **Visual Studio Code** (**VS Code**),
    which is becoming widely used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我的计算机是一个`lscpu`命令提取的信息，16 GB内存，256 GB SSD，和一个1 TB的机械硬盘（这些信息可以通过`df -h`命令获得）。也就是说，一个四核CPU和4或8
    GB的内存就足够了，但构建时间会相应增加。我的最爱编辑器是**Vim**，不过你可以使用你最习惯的编辑器。如果你使用的是台式机，可以使用**Visual Studio
    Code**（**VS Code**），它正在变得越来越流行。
- en: Now that we are familiar with the compilation-related keywords we will be using,
    we can start preparing the host machine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经熟悉了将要使用的与编译相关的关键字，接下来可以开始准备主机机器了。
- en: Setting up the host machine
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置主机机器
- en: Before you can start the development process, you need to set up an **environment**.
    The environment that's dedicated to Linux development is quite simple – on **Debian**-based
    systems, at least (which is our case).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始开发过程之前，你需要设置一个**环境**。专门用于Linux开发的环境是相当简单的——至少在**基于Debian**的系统上（这是我们的情况）。
- en: 'On the host machine, you need to install a few packages, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机机器上，你需要安装以下几个包：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, we installed a few development tools and some mandatory
    libraries so that we have a nice user interface when we're configuring the Linux
    kernel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们安装了一些开发工具和一些必需的库，以便在配置Linux内核时能拥有一个良好的用户界面。
- en: Now, we need to install the compiler and the tools (linker, assembler, and so
    on) for the build process to work properly and produce the executable for the
    target. This set of tools is called **Binutils**, and the compiler + Binutils
    (+ other build-time dependency libraries if any) combo is called **toolchain**.
    So, you need to understand what is meant by *"I need a toolchain for <this> architecture"*
    or similar sentences.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要安装编译器和工具（链接器、汇编器等），以便构建过程能够正常工作并生成目标的可执行文件。这一套工具被称为**Binutils**，而编译器
    + Binutils（如果有其他构建时依赖库的话）组合称为**工具链**。所以，你需要理解*“我需要一个针对<此>架构的工具链”*或类似句子的意思。
- en: Understanding and installing toolchains
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解并安装工具链
- en: Before we can start compiling, we need to install the necessary packages and
    tools for native or ARM cross-compiling; that is, the toolchains. GCC is the compiler
    that's supported by the Linux kernel. A lot of macros that are defined in the
    kernel are GCC-related. Due to this, we will use GCC as our (cross-)compiler.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编译之前，我们需要安装本地编译或ARM交叉编译所需的必要包和工具；也就是说，工具链。GCC是Linux内核支持的编译器。内核中定义的许多宏都是与GCC相关的。因此，我们将使用GCC作为我们的（交叉）编译器。
- en: 'For a native compilation, you can use the following toolchain installation
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地编译，你可以使用以下工具链安装命令：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you need to cross-compile, you must identify and install the right toolchain.
    Compared to a native compiler, cross-compiler executables are prefixed by the
    name of the target operating system, architecture, and (sometimes) library. Thus,
    to identify architecture-specific toolchains, a naming convention has been defined:
    `arch[-vendor][-os]-abi`. Let''s look at what the fields in the pattern mean:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要进行交叉编译时，必须识别并安装正确的工具链。与本地编译器相比，交叉编译器的可执行文件会以目标操作系统、架构和（有时）库的名称为前缀。因此，为了识别特定架构的工具链，定义了一个命名约定：`arch[-vendor][-os]-abi`。让我们来看看这个模式中各个字段的含义：
- en: '`arch` identifies the architecture; that is, `arm`, `mips`, `x86`, `i686`,
    and so on.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch` 用于识别架构；也就是说，`arm`、`mips`、`x86`、`i686`等。'
- en: '`vendor` is the toolchain supplier (company); that is, `Bootlin`, `Linaro`,
    `none` (if there is no provider) or simply omitting the field, and so on.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor` 是工具链供应商（公司）；也就是说，`Bootlin`、`Linaro`、`none`（如果没有供应商）或干脆省略该字段，等等。'
- en: '`os` is for the target operating system; that is, `linux` or `none` (bare metal).
    If omitted, bare metal is assumed.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os`是目标操作系统，即`linux`或`none`（裸机）。如果省略，则假定为裸机。'
- en: '`abi` stands for application binary interface. It refers to what the underlying
    binary is going to look like, the function call convention, how parameters are
    passed, and more. Possible conventions include `eabi`, `gnueabi`, and `gnueabihf`.
    Let''s look at these in more detail:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abi`代表应用二进制接口。它指的是底层二进制文件的外观、函数调用约定、参数传递方式等。可能的约定包括`eabi`、`gnueabi`和`gnueabihf`。让我们更详细地了解这些：'
- en: '`eabi` means that the code that will be compiled will run on a bare metal ARM
    core.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eabi`表示将编译的代码将在裸机ARM核心上运行。'
- en: '`gnueabi` means that the code for Linux will be compiled.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnueabi`表示将为Linux编译代码。'
- en: '`gnueabihf` is the same as `gnueabi`, but `hf` at the end means `hard float`,
    which indicates that the compiler and its underlying libraries are using hardware
    floating-point instructions rather than a software implementation of floating-point
    instructions, such as fixed-point software implementations. If no floating-point
    hardware is available, the instructions will be trapped and performed by a floating-point
    emulation module instead. When you''re using software emulation, the only actual
    difference in functionality is slower execution.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gnueabihf`与`gnueabi`相同，但末尾的`hf`表示`硬浮点`，这意味着编译器及其底层库使用硬件浮点指令，而不是使用软件实现的浮点指令（例如定点软件实现）。如果没有浮点硬件，指令将被拦截并由浮点仿真模块执行。当使用软件仿真时，功能上的唯一实际差异是执行速度较慢。'
- en: 'The following are some toolchain names to illustrate the use of the pattern:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些工具链名称，用来说明此命名模式的使用：
- en: '`arm-none-eabi`: This is a toolchain that targets the ARM architecture. It
    has no vendor, targets a bare-metal system (does not target an operating system),
    and complies with the ARM EABI.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-eabi`：这是一个针对ARM架构的工具链。它没有供应商，目标是裸机系统（不面向操作系统），并符合ARM EABI规范。'
- en: '`arm-none-linux-gnueabi` or `arm-linux-gnueabi`: This is a toolchain that produces
    objects for the ARM architecture to be run on Linux with the default configuration
    (ABI) provided by the toolchain. Note that `arm-none-linux-gnueabi` is the same
    as `arm-linux-gnueabi` because, as we have seen, when no vendor is specified,
    we assume there isn''t one. The variant of this toolchain supporting hardware
    floating point would be `arm-linux-gnueabihf` or `arm-none-linux-gnueabihf`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arm-none-linux-gnueabi` 或 `arm-linux-gnueabi`：这是一个工具链，用于为ARM架构生成可在Linux上运行的对象文件，且使用工具链提供的默认配置（ABI）。请注意，`arm-none-linux-gnueabi`与`arm-linux-gnueabi`相同，因为正如我们所见，当没有指定供应商时，假定没有供应商。该工具链的硬件浮点版本为`arm-linux-gnueabihf`或`arm-none-linux-gnueabihf`。'
- en: Now that we are familiar with toolchain naming conventions, we can determine
    which toolchain can be used to cross-compile for our target architecture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了工具链命名约定，我们可以确定哪个工具链可以用于为我们的目标架构进行交叉编译。
- en: 'To cross-compile for a 32-bit ARM machine, we would install the toolchain using
    the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要为32位ARM机器进行交叉编译，我们将使用以下命令安装工具链：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that the 64-bit ARM backend/support in the Linux tree and GCC is called
    `gcc-aarch64-linux-gnu*`, while Binutils must be called something like `binutils-aarch64-linux-gnu*`.
    Thus, for a 64-bit ARM toolchain, we would use the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Linux树和GCC中的64位ARM后端/支持被称为`gcc-aarch64-linux-gnu*`，而Binutils必须被命名为类似`binutils-aarch64-linux-gnu*`的名称。因此，对于64位ARM工具链，我们将使用以下命令：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that aarch64 only supports/provides hardware float aarch64 toolchains.
    Thus, there is no need to specify `hf` at the end.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，aarch64只支持/提供硬件浮点的aarch64工具链。因此，无需在末尾指定`hf`。
- en: Note that not all versions of the compiler can compile a given Linux kernel
    version. Thus, it is important to take care of both the Linux kernel version and
    the compiler (GCC) version. While the previous commands installed the latest version
    that's supported by your distribution, it is possible to target a particular version.
    To achieve this, you can use `gcc-<version>-<arch>-linux-gnu*`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有版本的编译器都可以编译特定的Linux内核版本。因此，处理Linux内核版本和编译器（GCC）版本非常重要。虽然前面的命令安装了由你的发行版支持的最新版本，但也可以指定某个特定版本。为此，可以使用`gcc-<version>-<arch>-linux-gnu*`。
- en: 'For example, to install version 8 of GCC for aarch64, you can use the following
    command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为aarch64安装GCC 8版本，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that our toolchain has been installed, we can look at the version that
    was picked by our distribution package manager. For example, to check which version
    of the aarch64 cross-compiler was installed, we can use the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的工具链已安装完毕，我们可以查看由我们的发行版包管理器选定的版本。例如，要检查安装的aarch64交叉编译器版本，我们可以使用以下命令：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For the 32-bit ARM variant, we can use the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于32位ARM变体，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, for the native version, we can use the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于本地版本，我们可以使用以下命令：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have set up our environment and made sure we are using the right
    tool versions, we can start downloading the Linux kernel sources and dig into
    them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了环境，并确保使用了正确的工具版本，我们可以开始下载Linux内核源代码并深入研究它们。
- en: Getting the sources
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'In the early kernel days (until 2003), odd-even versioning styles were used,
    where odd numbers were stable and even numbers were unstable. When the 2.6 version
    was released, the versioning scheme switched to **X.Y.Z**. Let''s look at this
    in more detail:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的内核时代（直到2003年），使用奇偶版本控制风格，其中奇数版本为稳定版，偶数版本为不稳定版。当2.6版本发布时，版本控制方案改为**X.Y.Z**。我们来详细看看这个：
- en: '**X**: This was the actual kernel''s version, also called major. It was incremented
    when there were backward-incompatible API changes.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X**：这是实际的内核版本，也叫主版本。当发生向后不兼容的API变更时，它会递增。'
- en: '**Y**: This was the minor revision. It was incremented after functionality
    was added in a backward-compatible manner.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Y**：这是次要修订。在以向后兼容的方式添加功能后，它会递增。'
- en: '**Z**: This is also called PATCH and represented versions related to bug fixes.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**：也叫PATCH，代表与修复BUG相关的版本。'
- en: This is called *semantic versioning* and was used until version *2.6.39*, when
    Linus Torvalds decided to bump the version to 3.0, which also meant the end of
    semantic versioning in 2011\. At that point, an X.Y scheme was adopted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这叫做*语义版本控制*，直到版本*2.6.39*，当时林纳斯·托瓦兹决定将版本号提升到3.0，这也意味着2011年语义版本控制的结束。此时，采用了X.Y的版本方案。
- en: When it came to version 3.20, Linus argued that he could no longer increase
    Y. Therefore, he decided to switch to an arbitrary versioning scheme, incrementing
    X whenever Y got so big that he ran out of fingers and toes to count it. This
    is the reason why the version has moved from 3.20 to 4.0 directly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当版本达到3.20时，林纳斯认为他再也无法增加Y了。因此，他决定切换到一个任意的版本控制方案，每当Y变得足够大，导致他用完了手指和脚趾来计数时，就递增X。这就是为什么版本直接从3.20跳跃到4.0的原因。
- en: Now, the kernel uses an arbitrary **X.Y** versioning scheme, which has nothing
    to do with semantic versioning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，内核使用一个任意的**X.Y**版本控制方案，这与语义版本控制无关。
- en: 'According to the Linux kernel release model, there are always two latest releases
    of the kernel out there: the stable release and the **long-term support** (**LTS**)
    release. All bug fixes and new features are collected and prepared by subsystem
    maintainers and then submitted to Linus Torvalds for inclusion into his Linux
    tree, which is called the mainline Linux tree, also known as the *master* Git
    repository. This is where every stable release originates from.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux内核发布模型，内核始终有两个最新版本：稳定版本和**长期支持**（**LTS**）版本。所有的BUG修复和新特性由子系统维护者收集并准备好，然后提交给林纳斯·托瓦兹以纳入他的Linux树，这棵树被称为主线Linux树，也叫做*主*Git仓库。这是每个稳定版本的起点。
- en: Before each new kernel version is released, it is submitted to the community
    through *release candidate* tags so that developers can test and polish all the
    new features. Based on the feedback he receives during this cycle, Linus decides
    whether the final version is ready to go. When Linus is convinced that the new
    kernel is ready to go, he makes the final release. We call this release "stable"
    to indicate that it's not a "release candidate:" those releases are *vX.Y* versions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新内核版本发布之前，它会通过*发布候选*标签提交到社区，以便开发人员可以测试和完善所有的新特性。根据他在此周期中收到的反馈，林纳斯决定最终版本是否准备好发布。当林纳斯确信新内核准备好发布时，他会做出最终发布。我们称这个发布为“稳定版”，表示它不是“发布候选版”：这些版本是*vX.Y*版本。
- en: There is no strict timeline for making releases, but new mainline kernels are
    generally released every 2-3 months. Stable kernel releases are based on Linus
    releases; that is, the mainline tree releases.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 没有严格的发布时间表，但新的主线内核一般每2-3个月发布一次。稳定的内核发布基于林纳斯的发布；也就是说，基于主线树的发布。
- en: Once a stable kernel is released by Linus, it also appears in the *linux-stable*
    tree (available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    where it becomes a branch. Here, it can receive bug fixes. This tree is called
    a stable tree because it is used to track previously released stable kernels.
    It is maintained and curated by *Greg Kroah-Hartman*. However, all fixes must
    go into Linus's tree first, which is the mainline repository. Once the bug has
    been fixed in the mainline repository, it can be applied to previously released
    kernels that are still maintained by the kernel development community. All the
    fixes that have been backported to stable releases must meet a set of important
    criteria before they are considered – one of them is that they "must already exist
    in Linus's tree."
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Linus 发布了稳定内核，它也会出现在 *linux-stable* 树中（可通过 [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)
    获取），并成为一个分支。在这里，它可以接收 bug 修复。这个树被称为稳定树，因为它用于跟踪以前发布的稳定内核。它由 *Greg Kroah-Hartman*
    维护和管理。然而，所有的修复必须首先进入 Linus 的树，即主线代码库。一旦主线代码库中的 bug 被修复，它可以应用于先前发布且仍由内核开发社区维护的内核。所有回溯到稳定版本的修复必须满足一套重要的标准才能被考虑——其中之一就是它们“必须已经存在于
    Linus 的树中”。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Bugfix kernel releases** are considered stable.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bugfix 内核版本**被认为是稳定的。'
- en: For example, when the 4.9 kernel is released by Linus, the stable kernel is
    released based on the kernel's numbering scheme; that is, 4.9.1, 4.9.2, 4.9.3,
    and so on. Such releases are called **bugfix kernel releases**, and the sequence
    is usually shortened with the number "4.9.y" when referring to their branch in
    the stable kernel release tree. Each stable kernel release tree is maintained
    by a single kernel developer, who is responsible for picking the necessary patches
    for the release and going through the review/release process. Usually, there are
    only a few bugfix kernel releases until the next mainline kernel becomes available
    – unless it is designated as a *long-term maintenance kernel*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 Linus 发布 4.9 内核时，稳定内核会根据内核的版本编号方案发布；即 4.9.1、4.9.2、4.9.3 等。这些版本被称为 **bugfix
    内核版本**，在提到其分支时，通常用 “4.9.y” 来简化。每个稳定内核发布树由单一的内核开发者维护，负责选择所需的补丁并经过审核/发布过程。通常，直到下一个主线内核发布之前，只有少数几个
    bugfix 内核版本——除非它被指定为 *长期维护内核*。
- en: 'Every subsystem and kernel maintainer repository is hosted here: [https://git.kernel.org/pub/scm/linux/kernel/git/](https://git.kernel.org/pub/scm/linux/kernel/git/).
    Here, we can also find either a Linus or a stable tree. In the Linus tree ([https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/)),
    there is only one branch; that is, the **master branch**. Its tags are either
    stable releases or release candidates. In the stable tree ([https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/)),
    there is one branch per stable kernel release (named *<A.B>.y*, where *<A.B>*
    is the release version in the Linus tree) and each branch contains its bugfix
    kernel releases.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子系统和内核维护者的代码库都托管在这里：[https://git.kernel.org/pub/scm/linux/kernel/git/](https://git.kernel.org/pub/scm/linux/kernel/git/)。在这里，我们还可以找到
    Linus 或稳定树。在 Linus 树中 ([https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/))，只有一个分支，即**主分支**。其标签要么是稳定版本，要么是发布候选版本。在稳定树中
    ([https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/))，每个稳定内核版本都有一个分支（命名为
    *<A.B>.y*，其中 *<A.B>* 是 Linus 树中的发布版本），每个分支包含其修复内核版本。
- en: Downloading the source and organizing it
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载源代码并进行组织
- en: 'In this book, we will be using Linus''s tree, which can be downloaded using
    the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 Linus 的树，可以使用以下命令进行下载：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding commands we used `--depth 1` to avoid downloading the history
    (or rather, picking only the last commit history), which may considerably reduce
    the download size and save time. Since Git supports branching and tagging, the
    `checkout` command allows you to switch to a specific tag or branch. In this example,
    we are switching to the `v5.10` tag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了 `--depth 1` 来避免下载历史记录（或者说，只挑选最后一次提交的历史），这可以显著减少下载的大小并节省时间。由于 Git
    支持分支和标签，`checkout` 命令允许你切换到特定的标签或分支。在这个例子中，我们切换到了 `v5.10` 标签。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will be dealing with Linux kernel v5.10.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将处理 Linux 内核 v5.10。
- en: 'Let''s look at the content of the main source directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看主源代码目录的内容：
- en: '`arch/`: To be as generic as possible, architecture-specific code is separated
    from the rest. This directory contains processor-specific code that''s organized
    in a subdirectory per architecture, such as `alpha/`, `arm/`, `mips/`, `arm64/`,
    and so on.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch/`：为了尽可能地通用，架构特定的代码与其他代码分开。该目录包含按架构组织的处理器特定代码，如 `alpha/`、`arm/`、`mips/`、`arm64/`
    等。'
- en: '`block/`: This directory contains codes for block storage devices.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block/`：该目录包含块存储设备的代码。'
- en: '`crypto/`: This directory contains the cryptographic API and the encryption
    algorithm''s code.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto/`：该目录包含加密 API 和加密算法的代码。'
- en: '`certs/`: This directory contains certificates and sign files to enable a module
    signature to make the kernel load signed modules.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`certs/`：该目录包含证书和签名文件，以启用模块签名，使内核加载已签名的模块。'
- en: '`documentation/`: This directory contains the descriptions of the APIs that
    are used for different kernel frameworks and subsystems. You should look here
    before asking any questions on the public forums.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`documentation/`：该目录包含用于不同内核框架和子系统的 API 描述。在向公共论坛提问之前，你应该查看这里。'
- en: '`drivers/`: This is the heaviest directory since it is continuously growing
    as device drivers get merged. It contains every device driver, organized into
    various subdirectories.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/`：这是最大的目录，因为随着设备驱动的合并，它不断增长。它包含每个设备驱动，并按子目录进行组织。'
- en: '`fs/`: This directory contains the implementations of different filesystems
    that the kernel supports, such as NTFS, FAT, ETX{2,3,4}, sysfs, procfs, NFS, and
    so on.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs/`：该目录包含内核支持的不同文件系统的实现，例如 NTFS、FAT、ETX{2,3,4}、sysfs、procfs、NFS 等。'
- en: '`include/`: This directory contains kernel header files.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include/`：该目录包含内核头文件。'
- en: '`init/`: This directory contains the initialization and startup code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init/`：该目录包含初始化和启动代码。'
- en: '`ipc/`: This directory contains the implementation of the **inter-process communication**
    (**IPC**) mechanisms, such as message queues, semaphores, and shared memory.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipc/`：该目录包含**进程间通信**（**IPC**）机制的实现，如消息队列、信号量和共享内存。'
- en: '`kernel/`: This directory contains architecture-independent portions of the
    base kernel.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel/`：该目录包含与架构无关的基本内核部分。'
- en: '`lib/`: Library routines and some helper functions live here. This includes
    generic **kernel object** (**kobject**) handlers and **cyclic redundancy code**
    (**CRC**) computation functions.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/`：此目录包含库例程和一些辅助函数，包括通用**内核对象**（**kobject**）处理程序和**循环冗余码**（**CRC**）计算函数。'
- en: '`mm/`: This directory contains memory management code.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm/`：该目录包含内存管理代码。'
- en: '`net/`: This directory contains networking (whatever network type it is) protocol
    code.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net/`：该目录包含网络（无论是哪种网络类型）协议代码。'
- en: '`samples/`: This directory contains device driver samples for various subsystems.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples/`：该目录包含用于各种子系统的设备驱动示例。'
- en: '`scripts/`: This directory contains scripts and tools that are used alongside
    the kernel. There are other useful tools here.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts/`：该目录包含与内核一起使用的脚本和工具。这里还有一些其他有用的工具。'
- en: '`security/`: This directory contains the security framework code.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security/`：该目录包含安全框架代码。'
- en: '`sound/`: Guess what falls here: audio subsystem code.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sound/`：你猜这里有什么：音频子系统代码。'
- en: '`tools/`: This directory contains Linux kernel development and testing tools
    for various subsystems, such as USB, vhost test modules, GPIO, IIO, and SPI, among
    others.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools/`：该目录包含用于各种子系统的 Linux 内核开发和测试工具，例如 USB、vhost 测试模块、GPIO、IIO 和 SPI 等。'
- en: '`usr/`: This directory currently contains the initramfs implementation.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/`：该目录目前包含 initramfs 实现。'
- en: '`virt/`: This is the virtualization directory, which contains the **kernel
    virtual machine** (**KVM**) module for a hypervisor.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt/`：这是虚拟化目录，包含用于虚拟机监控器的**内核虚拟机**（**KVM**）模块。'
- en: To enforce portability, any architecture-specific code should be in the `arch`
    directory. Moreover, the kernel code that's related to the user space API does
    not change (system calls, `/proc`, `/sys`, and so on) as it would break the existing
    programs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制可移植性，任何架构特定的代码应放在 `arch` 目录中。此外，与用户空间 API 相关的内核代码（如系统调用、`/proc`、`/sys` 等）不会改变，因为修改它会破坏现有的程序。
- en: In this section, we have familiarized ourselves with the Linux kernel's source
    content. After going through all the sources, it seems quite natural to configure
    them to be able to compile a kernel. In the next section, we will learn how kernel
    configuration works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经熟悉了 Linux 内核的源代码内容。经过所有源代码的学习后，配置它们以编译内核似乎是很自然的事情。在下一节中，我们将学习内核配置是如何工作的。
- en: Configuring and building the Linux kernel
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和构建 Linux 内核
- en: There are numerous drivers/features and build options available in the Linux
    kernel sources. The configuration process consists of choosing what features/drivers
    are going to be part of the compilation process. Depending on whether we are going
    to perform native compilation or cross-compilation, there are environment variables
    that must be defined, even before the configuration process takes place.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核源码中有大量的驱动程序/特性和构建选项。配置过程包括选择哪些特性/驱动程序将成为编译过程的一部分。根据我们是否进行本地编译或交叉编译，有一些环境变量必须在配置过程之前定义。
- en: Specifying compilation options
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定编译选项
- en: The compiler that's invoked by the kernel's `Makefile` is `$(CROSS_COMPILE)gcc`.
    That said, `CROSS_COMPILE` is the prefix of the cross-compiling tools (`gcc`,
    `as`, `ld`, `objcopy`, and so on) and must be specified when you're invoking `make`
    or must have been exported before any `make` command is executed. Only `gcc` and
    its related Binutils executables will be prefixed with `$(CROSS_COMPILE)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的 `Makefile` 调用的编译器是 `$(CROSS_COMPILE)gcc`。也就是说，`CROSS_COMPILE` 是交叉编译工具的前缀（如
    `gcc`、`as`、`ld`、`objcopy` 等），在调用 `make` 时必须指定，或者在执行任何 `make` 命令之前已经被导出。只有 `gcc`
    及其相关的 Binutils 可执行文件会以 `$(CROSS_COMPILE)` 为前缀。
- en: Note that various assumptions are made and options/features/flags are enabled
    by the Linux kernel build infrastructure based on the target architecture. To
    achieve that, in addition to the cross-compiler prefix, the architecture of the
    target must be specified as well. This can be done through the `ARCH` environment
    variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Linux 内核构建基础设施会根据目标架构做出各种假设，并启用选项/特性/标志。为了实现这一点，除了交叉编译器前缀外，还必须指定目标的架构。这可以通过
    `ARCH` 环境变量来完成。
- en: 'Thus, a typical Linux configuration or build command would look as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个典型的 Linux 配置或构建命令看起来如下所示：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can also look as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以如下所示：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you don''t wish to specify these environment variables when you launch a
    command, you can export them into your current shell. The following is an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在启动命令时指定这些环境变量，可以将它们导出到当前 shell 中。以下是一个示例：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember that if these variables are not specified, the native host machine
    is going to be targeted; that is, if `CROSS_COMPILE` is omitted or not set, `$(CROSS_COMPILE)gcc`
    will result in `gcc`, and it will be the same for other tools that will be invoked
    (for example, `$(CROSS_COMPILE)ld` will result in `ld`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果没有指定这些变量，默认将以本地主机作为目标；也就是说，如果省略或未设置 `CROSS_COMPILE`，那么 `$(CROSS_COMPILE)gcc`
    将变为 `gcc`，其他被调用的工具也会是相同的（例如，`$(CROSS_COMPILE)ld` 会变成 `ld`）。
- en: In the same manner, if `ARCH` (the target architecture) is omitted or not set,
    it will default to the host where `make` is executed. It will default to `$(uname
    -m)`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果 `ARCH`（目标架构）被省略或未设置，它将默认为执行 `make` 的主机架构。它将默认设置为 `$(uname -m)`。
- en: As a result, you should leave `CROSS_COMPILE` and `ARCH` undefined to have the
    kernel natively compiled for the host architecture using `gcc`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，你应该保持 `CROSS_COMPILE` 和 `ARCH` 未定义，以便使用 `gcc` 本地编译内核以适应主机架构。
- en: Understanding the kernel configuration process
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内核配置过程
- en: 'The Linux kernel is a *Makefile-based* project that contains thousands of options
    and drivers. Each option that''s enabled can make another one available or can
    pull specific code into the build. To configure the kernel, you can use `make
    menuconfig` for a ncurses-based interface or `make xconfig` for an X-based interface.
    The ncurses-based interface looks as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核是一个 *基于 Makefile* 的项目，包含成千上万的选项和驱动程序。每个启用的选项可能会使另一个选项可用，或者将特定代码引入构建中。为了配置内核，你可以使用
    `make menuconfig` 进行基于 ncurses 的界面配置，或者使用 `make xconfig` 进行基于 X 的界面配置。基于 ncurses
    的界面如下所示：
- en: '![Figure 1.1 – Kernel configuration screen'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 内核配置界面](img/B17934_Fig_1.1.jpg)'
- en: '](img/B17934_Fig_1.1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17934_Fig_1.1.jpg)'
- en: Figure 1.1 – Kernel configuration screen
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 内核配置界面
- en: 'For most options, you have three choices. However, we can enumerate five types
    of options while configuring the Linux kernel:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数选项，您有三个选择。然而，在配置 Linux 内核时，我们可以列出五种类型的选项：
- en: 'Boolean options, for which you have two choices:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔选项，您可以选择两种状态：
- en: '`(blank)`, which leaves this feature out. Once this option is highlighted in
    the configuration menu, you can press the `<n>` key to leave the feature out.
    It is equivalent to false. When it''s disabled, the resulting configuration option
    is commented out in the configuration file.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(blank)`，表示跳过此功能。一旦在配置菜单中高亮显示此选项，您可以按`<n>`键跳过该功能。这相当于 false。当禁用时，配置文件中的相应配置选项会被注释掉。'
- en: '`(*)`, which compiles it statically in the kernel. This means it will always
    be there when the kernel first loads. It is equivalent to true. You can enable
    a feature in the configuration menu by selecting it and pressing the `<y>` key.
    The resulting option will appear as `CONFIG_<OPTION>=y` in the configuration file;
    for example, `CONFIG_INPUT_EVDEV=y`.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(*)`，表示将其静态编译到内核中。这意味着在内核首次加载时，它将始终存在。这相当于 true。您可以通过选择此功能并按下 `<y>` 键来启用该功能。生成的选项将在配置文件中显示为
    `CONFIG_<OPTION>=y`；例如，`CONFIG_INPUT_EVDEV=y`。'
- en: Tristate options, which, in addition to being able to take Boolean states, can
    take a third state, marked as `(M)` in the configuration windows. This results
    in `CONFIG_<OPTION>=m` in the configuration file; for example, `CONFIG_INPUT_EVDEV=m`.
    To produce a loadable module (provided that this option allows it), you can select
    the feature and press the `M` key.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三态选项，除了可以取布尔状态外，还可以取第三种状态，这在配置窗口中标记为 `(M)`。这将在配置文件中生成 `CONFIG_<OPTION>=m`；例如，`CONFIG_INPUT_EVDEV=m`。为了生成可加载模块（前提是该选项允许），您可以选择该功能并按下
    `M` 键。
- en: String options, which expect string values; for example, `CONFIG_CMDLINE="noinitrd
    console=ttymxc0,115200"`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串选项，期望字符串值；例如，`CONFIG_CMDLINE="noinitrd console=ttymxc0,115200"`。
- en: Hex options, which expect hexadecimal values; for example, `CONFIG_PAGE_OFFSET=0x80000000`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制选项，期望十六进制值；例如，`CONFIG_PAGE_OFFSET=0x80000000`。
- en: Int options, which expect integer values; for example, `CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数选项，期望整数值；例如，`CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7`。
- en: The selected options will be stored in a `.config` file, at the root of the
    source tree.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 选定的选项将被存储在源代码树根目录下的 `.config` 文件中。
- en: 'It is very difficult to know which configuration is going to work on your platform.
    In most cases, there will be no need to start a configuration from scratch. There
    are default and functional configuration files available in each arch directory
    that you can use as a starting point (it is important to start with a configuration
    that already works):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很难知道哪个配置在您的平台上能够正常工作。在大多数情况下，您无需从头开始配置。每个架构目录中都有默认且有效的配置文件，您可以将其作为起点（重要的是要从一个已经工作的配置开始）：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For 32-bit ARM-based CPUs, these config files can be found in `arch/arm/configs/`.
    In this architecture, there is usually one default configuration per CPU family.
    For instance, for i.MX6-7 processors, the default config file is `arch/arm/configs/imx_v6_v7_defconfig`.
    However, on ARM 64-bit CPUs, there is only one big default configuration to customize;
    it is located in `arch/arm64/configs/` and is called `defconfig`. Similarly, for
    x86 processors, we can find the files in `arch/x86/configs/`. There will be two
    default configuration files here – `i386_defconfig` and `x86_64_defconfig`, for
    32- and 64-bit x86 architectures, respectively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 32 位 ARM 的 CPU，这些配置文件可以在 `arch/arm/configs/` 中找到。在该架构中，通常每个 CPU 系列都有一个默认配置文件。例如，对于
    i.MX6-7 处理器，默认配置文件是 `arch/arm/configs/imx_v6_v7_defconfig`。然而，在 ARM 64 位 CPU 上，只有一个大默认配置文件可供定制；它位于
    `arch/arm64/configs/` 中，文件名为 `defconfig`。类似地，对于 x86 处理器，我们可以在 `arch/x86/configs/`
    中找到文件。这里将有两个默认配置文件——`i386_defconfig` 和 `x86_64_defconfig`，分别对应 32 位和 64 位 x86
    架构。
- en: 'The kernel configuration command, given a default configuration file, is as
    follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配置命令，给定默认的配置文件，格式如下：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will generate a new `.config` file in the main (root) directory, while
    the old `.config` will be renamed `.config.old`. This can be useful to revert
    the previous configuration changes. Then, to customize the configuration, you
    can use the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新的 `.config` 文件到主（根）目录，而旧的 `.config` 文件将被重命名为 `.config.old`。这样可以方便地恢复之前的配置更改。然后，您可以使用以下命令来定制配置：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Saving your changes will update your `.config` file. While you could share
    this config with your teammates, you are better off creating a default configuration
    file in the same minimal format as those shipped with the Linux kernel sources.
    To do that, you can use the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 保存你的更改将更新你的`.config`文件。虽然你可以与队友共享此配置，但最好是创建一个与Linux内核源代码中提供的最小格式相同的默认配置文件。为此，你可以使用以下命令：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This command will create a minimal (since it won''t store non-default settings)
    configuration file. The generated default configuration file will be called `defconfig`
    and stored at the root of the source tree. You can store it in another location
    using the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建一个最小化的（因为它不会存储非默认设置）配置文件。生成的默认配置文件将被命名为`defconfig`并存储在源代码树的根目录下。你可以使用以下命令将其存储在其他位置：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This way, you can share a reference configuration inside the kernel sources
    and other developers can now get the same `.config` file as you by running the
    following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，你可以在内核源代码中共享一个参考配置，其他开发者现在可以通过运行以下命令获取与你相同的`.config`文件：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Note that, for cross-compilation, `ARCH` and `CROSS_COMPILE` must be set before
    you execute any `make` command, even for kernel configuration. Otherwise, you'll
    have unexpected changes in your configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于交叉编译，`ARCH`和`CROSS_COMPILE`必须在执行任何`make`命令之前设置，即使是内核配置也是如此。否则，你的配置可能会发生意外变化。
- en: 'The followings are the various configuration commands you can use, depending
    on the target system:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以使用的各种配置命令，具体取决于目标系统：
- en: 'For a 64-bit x86 native compilation, it is quite straightforward (the compilation
    options can be omitted):'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于64位x86本地编译，过程相当简单（可以省略编译选项）：
- en: '[PRE19]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Given a 32-bit ARM i.MX6-based board, you can execute the following command:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个32位ARM i.MX6基础板，你可以执行以下命令：
- en: '[PRE20]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the first command, you store the default options in the `.config` file,
    while with the latter, you can update (add/remove) various options, depending
    on your needs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令时，你会将默认选项存储在`.config`文件中，而使用后者，你可以根据需要更新（添加/删除）各种选项。
- en: 'For 64-bit ARM boards, you can execute the following commands:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于64位ARM板，你可以执行以下命令：
- en: '[PRE21]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may run into a Qt4 error with `xconfig`. In such a case, you should just
    use the following command to install the missing packages:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`xconfig`时，你可能会遇到Qt4错误。在这种情况下，你应该使用以下命令安装缺失的软件包：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: You may be switching from an old kernel to a new one. Given the old `.config`
    file, you can copy it into the new kernel source tree and run `make oldconfig`.
    If there are new options in the new kernel, you'll be prompted to include them
    or not. However, you may want to use the default values for those options. In
    this case, you should run `make olddefconfig`. Finally, to say no to every new
    option, you should run `make oldnoconfig`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从旧内核切换到新内核。给定旧的`.config`文件，你可以将其复制到新的内核源代码树中并运行`make oldconfig`。如果新内核中有新选项，你将被提示是否包括这些选项。不过，你可能想使用这些选项的默认值。在这种情况下，你应该运行`make
    olddefconfig`。最后，为了对每个新选项说“不”，你应该运行`make oldnoconfig`。
- en: 'There may be a better option to find an initial configuration file, especially
    if your machine is already running. Debian and Ubuntu Linux distributions save
    the `.config` file in the `/boot` directory, so you can use the following command
    to copy this configuration file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有更好的方法来找到初始配置文件，特别是如果你的机器已经在运行的情况下。Debian和Ubuntu Linux发行版将`.config`文件保存在`/boot`目录中，因此你可以使用以下命令复制此配置文件：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The other distributions may not do this. So, I can recommend that you always
    enable the `IKCONFIG` and `IKCONFIG_PROC` kernel configuration options, which
    will enable access to `.config` through `/proc/configs.gz`. This is a standard
    method that also works with embedded distributions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其他发行版可能不会这样做。因此，我建议你始终启用`IKCONFIG`和`IKCONFIG_PROC`内核配置选项，这将通过`/proc/configs.gz`启用对`.config`的访问。这是一种标准方法，也适用于嵌入式发行版。
- en: Some useful kernel configuration features
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些有用的内核配置功能
- en: 'Now that we can configure the kernel, let''s enumerate some useful configuration
    features that may be worth enabling in your kernel:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以配置内核了，下面列举一些可能值得在你的内核中启用的有用配置功能：
- en: '`IKCONFIG` and `IKCONFIG_PROC`: These are the most important to me. It makes
    your kernel configuration available at runtime, in `/proc/config.gz`. It can be
    useful either to reuse this config on another system or simply look for the enabled
    state of a particular feature; for example:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IKCONFIG` 和 `IKCONFIG_PROC`：这些是对我来说最重要的选项。它使得你的内核配置在运行时可用，并可以在 `/proc/config.gz`
    中查看。它非常有用，可以在其他系统上重用此配置，或者简单地查看某个特性是否启用；例如：'
- en: '[PRE24]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`CMDLINE_EXTEND` and `CMDLINE`: The first option is a Boolean that allows you
    to extend the kernel command line from within the configuration, while the second
    option is a string containing the actual command-line extension value; for example,
    `CMDLINE="noinitrd usbcore.authorized_default=0"`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMDLINE_EXTEND` 和 `CMDLINE`：第一个选项是一个布尔值，它允许你在配置中扩展内核命令行，而第二个选项是一个字符串，包含实际的命令行扩展值；例如，`CMDLINE="noinitrd
    usbcore.authorized_default=0"`。'
- en: '`CONFIG_KALLSYMS`: This is a Boolean option that makes the kernel symbol table
    (the mapping between symbols and their addresses) available in `/proc/kallsyms`.
    This is very useful for tracers and other tools that need to map kernel symbols
    to addresses. It is used while you''re printing oops messages. Without this, oops
    listings would produce hexadecimal output, which is difficult to interpret.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KALLSYMS`：这是一个布尔选项，它使得内核符号表（符号与地址之间的映射）可以在`/proc/kallsyms`中查看。这对于跟踪工具和其他需要将内核符号映射到地址的工具非常有用。在打印`oops`消息时会使用此选项。如果没有它，`oops`列表将输出十六进制数据，难以解读。'
- en: '`CONFIG_PRINTK_TIME`: This option shows timing information while printing messages
    from the kernel. It may be helpful to timestamp events that occurred at runtime.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PRINTK_TIME`：此选项在打印内核消息时显示时间信息。它可能有助于为运行时发生的事件添加时间戳。'
- en: '`CONFIG_INPUT_EVBUG`: This allows you to debug input devices.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_INPUT_EVBUG`：此选项允许你调试输入设备。'
- en: '`CONFIG_MAGIC_SYSRQ`: This allows you to have some control (such as rebooting,
    dumping some status information, and so on) over the system, even after a crash,
    by simply using some combination keys.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_MAGIC_SYSRQ`：此选项允许你在系统崩溃后，通过按组合键来控制系统（如重启、转储一些状态信息等）。'
- en: '`DEBUG_FS`: This enables support for debug filesystems, where `GPIO`, `CLOCK`,
    `DMA`, `REGMAP`, `IRQs`, and many other subsystems can be debugged from.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG_FS`：此选项启用对调试文件系统的支持，`GPIO`、`CLOCK`、`DMA`、`REGMAP`、`IRQs` 和其他多个子系统可以从中进行调试。'
- en: '`FTRACE` and `DYNAMIC_FTRACE`: These options enable the powerful `ftrace` tracer,
    which can trace the whole system. Once `ftrace` has been enabled, some of its
    enumeration options can be enabled as well:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FTRACE` 和 `DYNAMIC_FTRACE`：这些选项启用强大的 `ftrace` 跟踪器，可以跟踪整个系统。一旦启用 `ftrace`，还可以启用一些枚举选项：'
- en: '`FUNCTION_TRACER`: This allows you to trace any non-inline function in the
    kernel.'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FUNCTION_TRACER`：此选项允许你跟踪内核中的任何非内联函数。'
- en: '`FUNCTION_GRAPH_TRACER`: This does the same thing as the previous command,
    but it shows a call graph (the caller and the callee functions).'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FUNCTION_GRAPH_TRACER`：此选项与前一个命令相同，但它显示一个调用图（调用者和被调用者函数）。'
- en: '`IRQSOFF_TRACER`: This allows you to track off periods of IRQs in the kernel.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQSOFF_TRACER`：此选项允许你跟踪内核中 IRQ 关闭的时段。'
- en: '`PREEMPT_TRACER`: This allows you to measure preemption off latency.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PREEMPT_TRACER`：此选项允许你测量抢占关闭的延迟。'
- en: '`SCHED_TRACER`: This allows you to schedule latency tracing.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_TRACER`：此选项允许你跟踪调度延迟。'
- en: Now that the kernel has been configured, it must be built to generate a runnable
    kernel. In the next section, we will describe the kernel building process, as
    well as the expected build artifacts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核配置完成后，必须构建内核以生成可运行的内核。在下一节中，我们将描述内核构建过程以及预期的构建产物。
- en: Building the Linux kernel
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Linux 内核
- en: This step requires you to be in the same shell where you were during the configuration
    step; otherwise, you'll have to redefine the `ARCH` and `CROSS_COMPILE` environment
    variables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤要求你在配置步骤时所在的同一 shell 中执行；否则，你需要重新定义 `ARCH` 和 `CROSS_COMPILE` 环境变量。
- en: Linux is a Makefile-based project. Building such a project requires using the
    `make` tool and executing the `make` command. Regarding the Linux kernel, this
    command must be executed from the main kernel source directory, as a normal user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 是一个基于 Makefile 的项目。构建此类项目需要使用 `make` 工具并执行 `make` 命令。对于 Linux 内核，此命令必须从主内核源目录以普通用户身份执行。
- en: By default, if not specified, the make target is `all`. In the Linux kernel
    sources, for x86 architectures, this target points to (or depends on) `vmlinux
    bzImage modules` targets; for ARM or aarch64 architectures, it corresponds to
    `vmlinux zImage modules dtbs` targets.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果未指定，make 目标是 `all`。在 Linux 内核源代码中，对于 x86 架构，此目标指向（或依赖于）`vmlinux bzImage
    modules` 目标；对于 ARM 或 aarch64 架构，它对应于 `vmlinux zImage modules dtbs` 目标。
- en: In these targets, `bzImage` is an x86-specific make target that produces a binary
    with the same name, `bzImage`. `vmlinux` is a make target that produces a Linux
    image called `vmlinux`. `zImage` and `dtbs` are both ARM- and aarch64-specific
    make targets. The first produces a Linux image with the same name, while the second
    builds the device tree sources for the target CPU variant. `modules` is a make
    target that will build all the selected modules (marked with `m` in the configuration).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些目标中，`bzImage` 是一个特定于 x86 的 make 目标，它会生成一个名为 `bzImage` 的二进制文件。`vmlinux` 是一个
    make 目标，它会生成一个名为 `vmlinux` 的 Linux 镜像。`zImage` 和 `dtbs` 都是特定于 ARM 和 aarch64 的
    make 目标。第一个生成一个与其同名的 Linux 镜像，而第二个则构建目标 CPU 变体的设备树源文件。`modules` 是一个 make 目标，它会构建所有选中的模块（在配置中标记为
    `m` 的模块）。
- en: 'While building, you can leverage the host''s CPU performance by running multiple
    jobs in parallel thanks to the `-j` make options. The following is an example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，你可以通过运行多个并行任务来利用主机的 CPU 性能，这得益于 `-j` make 选项。以下是一个示例：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Most people define their `-j` number as 1.5x the number of cores. In my case,
    I always use `ncpus * 2`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人将他们的 `-j` 数量定义为核心数的 1.5 倍。就我而言，我总是使用 `ncpus * 2`。
- en: 'You can build the Linux kernel like so:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样构建 Linux 内核：
- en: 'For a native compilation, use the following command:'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于本地编译，使用以下命令：
- en: '[PRE26]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For a 32-bit ARM cross-compilation, use the following command:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 32 位 ARM 交叉编译，使用以下命令：
- en: '[PRE27]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Each make target can be invoked separately, like so:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 make 目标都可以单独调用，如下所示：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can also do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样做：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, you can also do the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以这样做：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have used `-j16` in my commands because my host has an 8-core CPU. This number
    of jobs must be adapted according to your host configuration.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我在命令中使用了 `-j16`，因为我的主机有一个 8 核 CPU。此任务数量必须根据你的主机配置进行调整。
- en: 'At the end of your 32-bit ARM cross-compilation jobs, you will see something
    like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 32 位 ARM 交叉编译工作结束时，你会看到类似以下内容：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By using the default targets, various binaries will result from the build process,
    depending on the architecture. These are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用默认目标，构建过程中会生成多个二进制文件，具体取决于架构。这些文件如下所示：
- en: '`arch/<arch>/boot/Image`: An uncompressed kernel image that can be booted'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch/<arch>/boot/Image`：一个未压缩的内核镜像，可以用来启动'
- en: '`arch/<arch>/boot/*Image*`: A compressed kernel image that can also be booted:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch/<arch>/boot/*Image*`：一个压缩的内核镜像，也可以用来启动：'
- en: This is `bzImage` (which means "big zImage") for x86, `zImage` for ARM or aarch64,
    and `vary` for other architectures.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 x86 的 `bzImage`（即 "big zImage"），ARM 或 aarch64 的 `zImage`，以及其他架构的 `vary`。
- en: '`arch/<arch>/boot/dts/*.dtb`: This provides compiled device tree blobs for
    the selected CPU variant.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch/<arch>/boot/dts/*.dtb`：为所选的 CPU 变体提供已编译的设备树二进制文件。'
- en: '`vmlinux`: This is a raw, uncompressed, and unstripped kernel image in ELF
    format. It''s useful for debugging purposes but generally not used for booting
    purposes.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmlinux`：这是一个原始的、未压缩和未剥离的 ELF 格式内核镜像。它通常用于调试，但通常不用于启动。'
- en: Now that we know how to (cross-)compile the Linux kernel, let's learn how to
    install it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何（交叉）编译 Linux 内核了，接下来学习如何安装它。
- en: Installing the Linux kernel
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Linux 内核
- en: 'The Linux kernel installation process differs in terms of native compilation
    or cross-compilation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核安装过程在本地编译和交叉编译方面有所不同：
- en: 'In native installation (that is, you''re installing host), you can simply run
    `sudo make install`. You must use `sudo` because the installation will take place
    in the `/boot` directory. If you''re doing an x86 native installation, the following
    files are shipped:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地安装（即你正在安装主机）时，你可以简单地运行 `sudo make install`。你必须使用 `sudo`，因为安装将发生在 `/boot`
    目录下。如果你进行的是 x86 本地安装，以下文件会被安装：
- en: '`/boot/vmlinuz-<version>`: This is the compressed and stripped variant of `vmlinux`.
    It is the same kernel image as the one in `arch/<arch>/boot`.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot/vmlinuz-<version>`：这是 `vmlinux` 的压缩和剥离版本。它与 `arch/<arch>/boot` 中的内核镜像相同。'
- en: '`/boot/System.map-<version>`: This stores the kernel symbol table (the mapping
    between the kernel symbols and their addresses), not just for debugging, but also
    to allow some kernel modules to resolve their symbols and load properly. This
    file only contains a static kernel symbol table, while `/proc/kallsyms` (provided
    that `CONFIG_KALLSYMS` is enabled in the config) on the running kernel contains
    `System.map` and the loaded kernel module symbols.'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot/System.map-<version>`：存储内核符号表（内核符号与其地址之间的映射），不仅用于调试，还允许某些内核模块解析它们的符号并正确加载。此文件仅包含静态的内核符号表，而运行中内核的`/proc/kallsyms`（前提是配置文件中启用了`CONFIG_KALLSYMS`）包含`System.map`和已加载的内核模块符号。'
- en: '`/boot/config-<version>`: This corresponds to the kernel configuration for
    the version that''s been built.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot/config-<version>`：这对应于已构建版本的内核配置。'
- en: An embedded installation usually uses a single file kernel. Moreover, the target
    is not accessible, which makes manual installation preferred. Thus, embedded Linux
    build systems (such as Yocto or Buildroot) use internal scripts to make the kernel
    image available in the target root filesystem. While embedded installation may
    be straightforward thanks to the use of build systems, native installation (especially
    x86 native installation) can require running additional bootloader-related commands
    (such as `update-grub2`) to make the new kernel visible to the system.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式安装通常使用单个文件内核。此外，目标设备无法访问，因此更倾向于手动安装。因此，嵌入式Linux构建系统（如Yocto或Buildroot）会使用内部脚本将内核映像放置在目标根文件系统中。虽然嵌入式安装由于使用了构建系统可能较为简单，但本地安装（尤其是x86本地安装）可能需要运行额外的引导加载程序相关命令（如`update-grub2`），使新内核对系统可见。
- en: Now that we are familiar with the kernel configuration, including the build
    and installation processes, let's look at kernel modules, which allow you to extend
    the kernel at runtime.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了内核配置，包括构建和安装过程，让我们来看一下内核模块，它们允许你在运行时扩展内核。
- en: Building and installing modules
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和安装模块
- en: 'Modules can be built separately using the `modules` target. You can install
    them using the `modules_install` target. Modules are built in the same directory
    as their corresponding source. Thus, the resulting kernel objects are spread over
    the kernel source tree:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`modules`目标单独构建模块。使用`modules_install`目标可以安装它们。模块会在与其源代码相对应的同一目录中构建。因此，生成的内核对象会分散在内核源树中：
- en: 'For a native build and installation, you can use the following commands:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于本地构建和安装，你可以使用以下命令：
- en: '[PRE32]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The resulting modules will be installed in `/lib/modules/$(uname -r)/kernel/`,
    in the same directory structure as their corresponding source. A custom install
    path can be specified using the `INSTALL_MOD_PATH` environment variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块将安装在`/lib/modules/$(uname -r)/kernel/`中，目录结构与其源代码相应。可以使用`INSTALL_MOD_PATH`环境变量指定自定义安装路径。
- en: 'When you''re cross-compiling for embedded systems, as with all `make` commands,
    `ARCH` and `CROSS_COMPILE` must be specified. As it is not possible to install
    a directory in the target device filesystem, embedded Linux build systems (such
    as Yocto or Buildroot) set `INSTALL_MOD_PATH` to a path that corresponds to the
    target root filesystem so that the final root filesystem image contains the modules
    that have been built; otherwise, the modules will be installed on the host. The
    following is an example of a 32-bit ARM architecture:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你为嵌入式系统进行交叉编译时，和所有`make`命令一样，必须指定`ARCH`和`CROSS_COMPILE`。由于无法将目录安装到目标设备的文件系统中，嵌入式Linux构建系统（如Yocto或Buildroot）会将`INSTALL_MOD_PATH`设置为对应目标根文件系统的路径，以便最终的根文件系统镜像包含已构建的模块；否则，模块将安装在主机上。以下是32位ARM架构的示例：
- en: '[PRE33]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In addition to the `kernel` directory that is shipped with modules, the following
    files are installed in `/lib/modules/<version>` as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 除了随模块一起提供的`kernel`目录外，以下文件也会安装在`/lib/modules/<version>`目录中：
- en: '`modules.builtin`: This lists all the kernel objects (`.ko`) that are built
    into the kernel. It is used by the module loading utility (`modprobe`, for example)
    so that it does not fail when it''s trying to load something that''s already built
    in. `modules.builtin.bin` is its binary counterpart.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules.builtin`：列出了所有内核对象（`.ko`），这些对象是内核构建时包含的。它被模块加载工具（如`modprobe`）使用，以确保在加载已经构建进内核的模块时不会失败。`modules.builtin.bin`是它的二进制版本。'
- en: '`modules.alias`: This contains the aliases for module loading utilities, which
    are used to match drivers and devices. This concept of module aliases will be
    explained in [*Chapter 6*](B17934_06_Epub.xhtml#_idTextAnchor095), *Introduction
    to Devices, Drivers, and Platform Abstraction*. `modules.alias.bin` is its binary
    equivalent.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules.alias`：这个文件包含了模块加载工具的别名，这些工具用于匹配驱动程序和设备。模块别名的概念将在[*第6章*](B17934_06_Epub.xhtml#_idTextAnchor095)《设备、驱动程序和平台抽象介绍》中进行解释。`modules.alias.bin`是它的二进制等效文件。'
- en: '`modules.dep`: This lists modules, along with their dependencies. `modules.dep.bin`
    is its binary counterpart.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules.dep`：这个文件列出了模块及其依赖关系。`modules.dep.bin`是它的二进制版本。'
- en: '`modules.symbols`: This tells us which module a given symbol belongs to. They
    are in the form of `alias symbol:<symbol> <modulename>`. An example is `alias
    symbol:v4l2_async_notifier_register videodev`. `modules.symbols.bin` is the binary
    counterpart of this file.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules.symbols`：这个文件告诉我们一个给定符号属于哪个模块。它们的形式为 `alias symbol:<symbol> <modulename>`。例如，`alias
    symbol:v4l2_async_notifier_register videodev`。`modules.symbols.bin`是这个文件的二进制版本。'
- en: With that, we have installed the necessary modules. We've finished learning
    how to build and install Linux kernels and modules. We've also finished learning
    how to configure the Linux kernel and add the features we need.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经安装了必要的模块，学习了如何构建和安装Linux内核和模块。我们也学会了如何配置Linux内核并添加所需的功能。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to download the Linux source and process your
    first build. We also covered some common operations, such as configuring or selecting
    the appropriate toolchain. That said, this chapter was quite brief; it was just
    an introduction. This is why, in the next chapter, we will cover the kernel building
    process, how to compile a driver (either externally or as part of the kernel),
    and some basics that you should learn before you start the long journey that kernel
    development represents. Let's take a look!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何下载Linux源代码并进行第一次构建。我们还介绍了一些常见操作，比如配置或选择合适的工具链。也就是说，这一章内容较为简短，主要是一个介绍。因此，在下一章中，我们将详细讲解内核构建过程、如何编译驱动程序（无论是外部编译还是作为内核的一部分），以及一些在开始长时间的内核开发之前你应该掌握的基础知识。让我们来看看吧！
