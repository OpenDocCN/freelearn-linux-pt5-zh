- en: Chapter 5. Completion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 补全
- en: 'This is what most users switch to zsh for: completion. In this chapter, we''ll
    meet one of the best features of zsh: `compsys`. Known as "the new" completion
    mechanism, this chapter focuses on its various functions and configuration. We
    will learn to tweak the completion behavior so that it''s no longer restricted
    to filenames and bump it up using styles and our own functions. When we''re done,
    you should be able to read most zsh scripts as well as tweak many of the existing
    functions.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大多数用户切换到zsh的原因：补全。在这一章中，我们将介绍zsh的最佳功能之一：`compsys`。被称为“新”的补全机制，本章将重点讲解它的各种功能和配置。我们将学习如何调整补全行为，使其不再仅限于文件名，并通过样式和我们自己的函数进一步提升它。完成后，你应该能够阅读大多数zsh脚本，并调整许多现有的函数。
- en: Getting started with completion
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用补全
- en: Nobody really likes to type boring filenames, and that's what got completion
    started back in the day—type a few letters of a filename, press *Tab*, and the
    shell will do the rest for you. Zsh goes the extra mile though and actually allows
    you to complete almost anything. By default, the *Tab* key is bound to a completion
    command in zsh.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人真正喜欢输入枯燥的文件名，这也是补全功能最初出现的原因——输入几个字母，按下*Tab*，然后Shell会帮你完成其余部分。不过zsh更进一步，实际上允许你补全几乎任何东西。默认情况下，*Tab*键在zsh中绑定到补全命令。
- en: Like Bash, zsh defaults to filename completion. Unlike anything else, however,
    zsh can enable the completion for practically everything that dares to rear its
    head in the command line—paths, external and built-in commands, aliases, functions,
    and options; you name it. And even if you can't name it, you can program it, as
    we will learn shortly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 和Bash一样，zsh默认启用文件名补全。不过与其他任何东西不同，zsh可以启用几乎所有在命令行中出现的内容的补全——路径、外部和内建命令、别名、函数和选项，应有尽有。即使你说不出它的名字，你也可以编程来补全它，稍后我们将会学习这一点。
- en: Originally, zsh used a built-in module with a special syntax in order to provide
    completion. Luckily for us, this was eventually replaced by an even simpler mechanism.
    We'll focus on the new completion system that is entirely based on shell functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，zsh使用内建模块和特殊语法来提供自动补全。幸运的是，这最终被一个更加简单的机制所替代。我们将重点介绍这个完全基于Shell函数的新补全系统。
- en: 'Go ahead and pop open that `.zshrc` file of yours, and add the following in
    order to activate shell completion:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`.zshrc`文件，添加以下内容以激活Shell补全功能：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This addition will make the shell load the completion system and start it automatically.
    The `-U` flag tells the shell to avoid expanding any aliases. This will make double
    tapping *Tab* trigger the completion mode.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新增功能将使Shell加载并自动启动补全系统。`-U`标志告诉Shell避免展开任何别名。这将使双击*Tab*键触发补全模式。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`compinit` is an essential part of the completion system. As such, you won''t
    be able to test anything from here on until you have updated and sourced your
    `.zshrc` file or at least run `autoload -U compinit && compinit` in your terminal.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`compinit`是补全系统的核心部分。因此，直到你更新并引用了你的`.zshrc`文件，或者至少在终端中运行了`autoload -U compinit
    && compinit`，你无法进行任何测试。'
- en: 'Remember to source your files, and then let''s go ahead and try our newly enabled
    completion. Type `ec` and press *Tab*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 记得给你的文件加上源文件引用，然后让我们尝试一下新启用的补全功能。输入`ec`并按下*Tab*：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The shell automatically completes the external command as `echo`. How nice of
    zsh, isn't it?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Shell会自动补全外部命令，如`echo`。zsh真是太贴心了，不是吗？
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we have previously noted, zsh has two ways of performing completions in the
    command line. You can learn more about "the old way" of doing things by typing
    `man zshcompctl`, for academic purposes, of course.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，zsh有两种方式来执行命令行补全。你可以通过输入`man zshcompctl`来了解“旧方式”是如何工作的，当然，这只是为了学术目的。
- en: 'Completion can also be applied to environment variables, for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 补全也可以应用于环境变量，例如：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By default, zsh enables the `AUTO_LIST` option that handles the resolution
    of ambiguous matches, providing you with all the possible completions. To see
    this in action, let''s go back to the previous example; only this time, we will
    make the completion less obvious by typing only `HO` as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，zsh启用`AUTO_LIST`选项，用于处理歧义匹配的解析，向你提供所有可能的补全。为了演示这一点，让我们回到之前的例子，这次我们只输入`HO`，看看补全是如何工作的：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The shell doesn't know for sure what we mean, so it presents us with a list
    of possible matches below the prompt instead. This list will be updated if the
    criteria changes, so we need to only worry about hitting the *Tab* key.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Shell并不完全知道我们想要的是什么，所以它会在提示符下方展示一份可能匹配的列表。当标准发生变化时，这个列表会被更新，因此我们只需担心按下*Tab*键。
- en: 'Now, let''s try option completion with `ls`, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`ls`进行选项补全，如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows you how completion is triggered for the `ls`
    command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下方的截图展示了如何触发`ls`命令的补全：
- en: '![Getting started with completion](img/2937OS_05_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用补全](img/2937OS_05_01.jpg)'
- en: Menu selection in action
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单选择演示
- en: Seeing that there are actually a couple of viable options to pick from, zsh
    presents you with a menu that you can cycle through by repeatedly hitting the
    *Tab* key or using the arrow keys.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 看到有几个可选项可以选择，zsh会为你展示一个菜单，你可以通过反复按*Tab*键或使用箭头键来浏览。
- en: 'Finally, you can also use completion for expanding commands as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还可以使用补全来扩展命令，如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see where this is going—completion is awesome enough for us to want
    it to be applied everywhere, and not just in the word that's being typed. Before
    we start writing our own functions however, we will take a look at zsh styles,
    the options by which we can configure the behavior of the `zstyle` built-in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到补全的效果——它足够强大，让我们希望能在所有地方都能使用，而不仅仅是输入的单词上。然而，在我们开始编写自己的函数之前，我们先来看看zsh样式，即我们用来配置`zstyle`内建行为的选项。
- en: Getting assertive with zstyle
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与zstyle打交道
- en: Unlike the shell options that we have been setting—and unsetting—throughout
    this book, zstyles demand a bit more complex syntax as a trade-off for enabling
    a context-sensitive completion.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在本书中设置和取消设置的Shell选项不同，zstyle要求更复杂的语法作为启用上下文敏感补全的交换条件。
- en: 'Zstyles are defined via the `zstyle` keyword, followed by a colon-delimited
    list of arguments:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: zstyle是通过`zstyle`关键字来定义的，后面跟着一个以冒号分隔的参数列表：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first argument, `completion`, is used for defining a context, as any given
    style could behave differently in different contexts. Nothing to write home about
    though, as we'll get to see in no time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`completion`用于定义一个上下文，因为在不同的上下文中，某个样式的行为可能会有所不同。不过这并不复杂，我们很快就会看到。
- en: The second argument is the name of the style by which it will be referenced
    by the built-in. The remainder of the arguments are what give the style their
    unique behavior for completion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是样式的名称，用来供内建引用。其余的参数则赋予该样式独特的补全行为。
- en: Patterns make a comeback here as well, so you can use them as tokens for each
    of the subsequent arguments when defining a style. As usual, order matters when
    you want to define your styles, so try to put the less-specific or general-purpose
    styles at the bottom of your definitions, otherwise you'll end up overriding your
    more-specific functions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里模式也会回归，你可以将它们用作每个后续参数的标记。当你定义样式时，顺序非常重要，因此尽量将不太具体或通用的样式放在定义的底部，否则你会覆盖掉更具体的功能。
- en: The most general type of style you can define is `:completion:*`, which will
    apply to almost anything, so be careful when ordering something that resembles
    it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义的最通用的样式类型是`:completion:*`，它几乎适用于所有情况，因此在定义时要小心，避免错误地将其排在前面。
- en: 'As you might have imagined, zsh has a few tricks up its sleeve, such as being
    capable of displaying some useful messages with the list of matches. For this
    to work though, we need to enable the following style:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，zsh有一些技巧，比如能够在匹配列表中显示一些有用的消息。不过，为了使这个功能生效，我们需要启用以下样式：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By adding this to your `.zshrc` file, you can now get a bit more information
    whenever zsh is performing a completion. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个添加到你的`.zshrc`文件中，每当zsh执行补全时，你现在可以获取更多的信息。例如：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The astute reader might have noticed the `%d` pattern lying within the style
    format. That's right, we can use the same escape sequences as that we used when
    defining our prompts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能已经注意到样式格式中有`%d`模式。没错，我们可以使用与定义提示符时相同的转义序列。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Tired of hearing beeps already? That''s zsh''s way of telling us that an ambiguous
    completion was attempted. You can put off this rather annoying attitude towards
    ambiguity by unsetting the `LIST_BEEP` option in your `.zshrc` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 已经厌烦听到提示音了吗？那是zsh在告诉我们，尝试了一个模糊的补全。你可以通过在`.zshrc`文件中取消设置`LIST_BEEP`选项，来避免这种烦人的模糊提示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we mentioned earlier, you can also narrow down the behavior of your styles
    to a more specific context. For example, you could use any of the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，你还可以将你的样式行为缩小到更具体的上下文。例如，你可以使用以下任意一个：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is just to set a custom pattern for the messages belonging to `warnings`,
    `messages`, and `descriptions` groups. As you can see, `warnings` will now be
    reported as `No matches for: <argument>`, which is a bit less dronish.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是为了为属于`warnings`、`messages`和`descriptions`组的消息设置一个自定义模式。正如你所看到的，`warnings`现在将报告为`No
    matches for: <argument>`，这就不那么单调了。'
- en: 'You could also add a little more flair to your results with something along
    the following lines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为结果增加一点点装饰，像这样：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will display all the different types of matches separately. If no tag or
    group is defined for a particular match, it'll get displayed under the `default`
    group.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将单独显示所有不同类型的匹配项。如果没有为某个特定匹配项定义标签或组，它将显示在`default`组下。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Did the menu selection tickle your fancy? Here''s how we make it available
    for all of your matches:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单选择让你心动了吗？下面是如何让它对你所有的匹配项都可用：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting comfortable with the styles? Glad to hear. As you can see from the examples,
    there's no arcane magic involved here—just some documentation and creativity to
    fill the gap between you and your custom styles.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对样式感觉舒服了吗？很高兴听到这个。正如从这些示例中可以看到的，这里没有神秘的魔法——只有一些文档和创造力，填补你和自定义样式之间的空白。
- en: Command correction
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令更正
- en: 'Completion can also correct any misspelled commands that you might have typed.
    We''ll use the following format for our style:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 补全也可以更正你可能输入的任何拼写错误的命令。我们将使用以下格式来定义样式：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And we''ll test the autocorrect functionality with the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用以下命令来测试自动更正功能：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Zstyle noticed that we misspelled `print` and is being quite verbose regarding
    this. Remember you can use the *Tab* key to cycle through the list of available
    options.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Zstyle注意到我们拼错了`print`，并对此进行了详细说明。记住，你可以使用*Tab*键在可用选项之间切换。
- en: 'Alternatively, you could use the `correct` option if you want a more "hold
    me by the hand" approach. Specifically, this option will make zsh ask you for
    confirmation every time it suggests a correction:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想要一个更“手把手指导”的方式，你可以使用`correct`选项。具体来说，这个选项会让zsh在每次建议更正时都要求你确认：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This peculiar `nyae` acronym stands for *No*, *Yes*, *Abort*, and *Edit*, and
    works in the following way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的`nyae`首字母缩写代表*No*、*Yes*、*Abort*和*Edit*，其工作方式如下：
- en: '`n`: This will force the shell to execute whatever you typed in the command
    line (`prnti` in this particular case).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：这将强制shell执行你在命令行中输入的内容（在这个例子中是`prnti`）。'
- en: '`y`: This will execute the correction (effectively, changing `prnti` to **print**
    in this example).'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：这将执行更正（在此示例中，将`prnti`更正为**print**）。'
- en: '`a`: This will abort and allow you to type a completely different command.
    Think of it as a panic button.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：这将中止并允许你输入一个完全不同的命令。可以把它当作一个紧急按钮。'
- en: '`e`: This will allow you to edit the current text in the command line. Use
    this for a more fine-grained control in case suggestions made by the shell are
    completely off.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`：这将允许你编辑命令行中的当前文本。如果你觉得shell提供的建议完全不对劲，可以使用此选项进行更精细的控制。'
- en: 'What about command options? You know, those flags we pass around all the time?
    Well, turns out there is a style for that too. The following will make the commands
    show the descriptions for their options:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 命令选项呢？你知道的，那些我们经常传递的标志？结果，竟然也有样式可以处理这个。以下内容将使命令显示它们选项的描述：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'These can be easily accounted for; now, go ahead and type the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以很容易地解释清楚；现在，继续输入以下内容：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Not too shabby, right? Remember how I mentioned we wouldn't be in such a dire
    need for manpages after we learned some styles? No? Well, we won't be in such...
    never mind.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错吧？记得我提过在我们学会一些样式后，就不那么依赖man页面了吗？没有？没关系，反正我们不会那么...算了。
- en: Completers
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补全器
- en: The third entry on the zstyle is reserved for completers. These are the functions
    that handle the different types of completions available. By default, the list
    of completers consists of a single function, `_complete`, but each member of the
    completers family will add its own unique behavior to your styles.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: zstyle中的第三个条目是为补全器保留的。这些是处理不同类型补全的函数。默认情况下，补全器列表包含一个函数，`_complete`，但补全器家族中的每个成员都会为你的样式添加独特的行为。
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Used in your `.zshrc` file, this completer will use globbing for expanding the
    input and match it against the `_complete` and `_correct` completers. The `_correct`
    completer is used here for correcting any typos and spelling mistakes. We're leaving
    it at the end of the argument list so that `_complete` takes precedence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`.zshrc`文件中使用时，这个补全器将使用通配符扩展输入并与`_complete`和`_correct`补全器进行匹配。这里使用`_correct`补全器来修正任何打字错误和拼写错误。我们将其放在参数列表的最后，这样`_complete`就可以优先使用。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When used within a style, completer names omit the leading underscore:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当在样式中使用时，补全器名称会省略前导的下划线：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This style configures the `_complete` completer by enabling a cache layer for
    any completions that require it, improving the overall responsiveness of such
    functions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个样式通过为任何需要的补全启用缓存层，来配置`_complete`补全器，从而提高此类功能的整体响应速度。
- en: Similar to `_correct`, `_approximate` will carry out the same tasks with the
    added benefit of allowing a few extra characters to be misspelled at the cursor
    position. Notice that you will need to put `_approximate` before `_correct`, should
    you need to use both in your style.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与`_correct`类似，`_approximate`将执行相同的任务，额外的好处是允许在光标位置输入一些额外的错误字符。请注意，如果你需要同时使用这两者，`_approximate`需要放在`_correct`之前。
- en: 'As a function, zstyle also uses flags. Of particular interest to us is the
    `-e` option, which tells zstyle to evaluate the final string as an argument on
    each call. This allows us to use more dynamic styles such as the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个函数，zstyle也使用标志。我们特别关心的是`-e`选项，它告诉zstyle在每次调用时将最终的字符串作为一个参数进行评估。这使得我们可以使用更加动态的样式，例如以下：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This configures the `approximate` completer to evaluate the argument for the
    `max-errors` parameter dynamically, each time it is invoked. The `reply=( $((
    ($#PREFIX+$#SUFFIX)/3 )) numeric )` string uses the `reply` hook for displaying
    the results within the line editor and sets its value as the expression, `(PREFIX
    + SUFFIX)/3`. This is our way of saying "one error for every three characters".
    Both `PREFIX` and `SUFFIX` are variables that contain the values before and after
    the cursor position, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这会配置`approximate`补全器，动态地评估`max-errors`参数的每个调用的参数。`reply=( $(( ($#PREFIX+$#SUFFIX)/3
    )) numeric )`字符串使用`reply`钩子在行编辑器中显示结果，并将其值设置为表达式`(PREFIX + SUFFIX)/3`。这意味着“每三个字符一个错误”。`PREFIX`和`SUFFIX`分别是包含光标位置之前和之后的值的变量。
- en: Ignoring matches
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略匹配项
- en: Sometimes, some matching suggestions jump out at you as being completely out
    of place. Luckily for us, the developers of zsh have included an `_ignore` completer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些匹配建议会让你感觉完全不合适。幸运的是，zsh的开发者们为我们提供了一个`_ignore`补全器。
- en: 'Take the following directory tree as an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下目录树为例：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When working on any of the subdirectories mentioned previously—for example,
    the `Completion` folder—see what happens when we try to change directory, using
    `cd`, to another at the same level:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面提到的任何子目录中工作时——例如，`Completion`文件夹——看一下我们尝试使用`cd`命令更改目录到同一级别的其他目录时发生了什么：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Having the `Completion` mechanism display the folder we''re currently located
    in is a bit awkward, and it makes the whole `cd` deal a bit pointless. In order
    to make the shell a bit more context-sensitive, we can alter the completion behavior
    for the `cd` command using the `ignore-parents`, `parent`, and `pwd` options:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让`Completion`机制显示我们当前所在的文件夹有点尴尬，而且这让整个`cd`命令显得有些没必要。为了让shell变得更具上下文敏感性，我们可以使用`ignore-parents`、`parent`和`pwd`选项来修改`cd`命令的补全行为：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following will remove the respective matches from the completion results.
    Notice how `Completion` is now missing from the results:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将从补全结果中移除相应的匹配项。注意，现在`Completion`已经从结果中消失：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While we''re at it, you can use the following style to remove the trailing
    slash when using a directory as an argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，你可以使用以下样式，当使用目录作为参数时，去除末尾的斜杠：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Function definitions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数定义
- en: Finally, we will turn our attention to `compsys`, zsh's completion system. This
    is one of the most complex parts of the shell for users and developers alike.
    Before we dive into `compsys`, however, we need to make a quick stop and meet
    an actual function in the wild.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将关注`compsys`，即zsh的补全系统。这是shell中最复杂的部分之一，对于用户和开发者来说都不容易。然后，在我们深入了解`compsys`之前，我们需要稍微停一下，见见一个实际的函数。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As usual, you can learn more about `compsys` via the manpages. Of particular
    interest are `man zshcompsys` and `man zshcompwid`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以通过 man 页面了解更多关于 `compsys` 的信息，特别值得关注的是 `man zshcompsys` 和 `man zshcompwid`。
- en: 'Here''s what one of these looks like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是其中一个例子：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we have defined the `hi` function, which is how we'll call it again later
    when we need it. This will, in turn, print `Hello, world` every time we use it.
    So let's get to it, shall we?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `hi` 函数，这就是我们以后需要时调用它的方式。每次使用时，它都会打印 `Hello, world`。那我们就开始吧，怎么样？
- en: 'Open your terminal emulator of choice, and type the following (one line at
    a time):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你选择的终端模拟器，逐行输入以下内容：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how zsh realized this was indeed a function we were trying to define
    and immediately used the continuation prompt (`function>`), allowing you to continue
    working on it? How nice of zsh to wait for us until we properly close our curly
    braces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 zsh 是如何识别出我们正在定义一个函数，并立即使用继续提示符（`function>`），让我们可以继续操作吗？真是太好了，zsh 等着我们直到我们正确关闭花括号。
- en: 'Now, go ahead and test your first function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，来测试你的第一个函数吧：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: They grow so fast!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 它们增长得如此之快！
- en: And, now for the sad part—this was defined for your current session only, just
    like when we defined aliases back in [Chapter 2](ch02.html "Chapter 2. Alias and
    History"), *Alias and History*, at the beginning of our zsh adventure. If you
    want `hi()`, or any other function to tag along in each interactive session of
    yours, you'll need to add it to your startup files.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是让人遗憾的部分——这个函数只在你当前的会话中有效，就像我们在[第2章](ch02.html "第2章. 别名和历史")，*别名和历史*中定义别名时一样，这是我们
    zsh 冒险的开始。如果你希望 `hi()` 或其他任何函数在每个交互会话中都能使用，你需要把它添加到启动文件中。
- en: 'A word of advice though: once you start with the completion and functions,
    these startup files will get pretty crowded. So, it''s probably best that you
    start relocating your functions into a more comfy space like their own `.zsh_functions`
    file. Fret not, as the process is easy.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提醒的是：一旦你开始使用补全和函数，这些启动文件会变得相当拥挤。因此，最好是将函数移到一个更合适的地方，比如它们自己的 `.zsh_functions`
    文件。别担心，这个过程非常简单。
- en: First, we create a hidden file; you can name it whatever you fancy, but we'll
    go with `.zsh_functions` (see the leading dot, so we can tell the system that
    it can hide it).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个隐藏文件；你可以随意命名，但我们这里使用 `.zsh_functions`（注意前面的点，这样系统就会把它隐藏起来）。
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you have created the file in your `$HOME` directory, it''s simply a matter
    of adding your functions in here. You can use your favorite editor; we''ll just
    roll with `cat` here for convenience:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 `$HOME` 目录中创建了文件，接下来就是在其中添加你的函数。你可以使用你最喜欢的编辑器；我们这里为了方便，就用 `cat`：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Press *Ctrl* + *D* to close the file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *D* 关闭文件。
- en: 'Now, as we learned previously, this wouldn''t do anything by itself unless
    we source the file. And since sourcing the file manually in each session would
    be a pain in the neck, we just need to go a step further and add the `.zsh_functions`
    sourcing to our startup files. So, go ahead and open your `.zshrc` file, and add
    the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们之前所学，这个文件本身不会执行任何操作，除非我们让它生效。因为每次手动加载文件会很麻烦，所以我们只需再往前一步，把 `.zsh_functions`
    的加载过程添加到启动文件中。接下来，打开你的 `.zshrc` 文件，添加以下内容：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a conditional statement. The double square braces (`[[`) shown here
    are known as the `test` command (or *new test* if you have been around the command
    line for a while), and they help you compare strings and test for file attributes.
    The `-f` switch is for regular files and succeeds only if the file exists. So
    we're literally trying to say "test whether the `~/.zsh_functions` file exists".
    If the test passes, the following part of the command will get chained and we'll
    finally source our functions file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个条件语句。这里使用的双中括号（`[[`）是 `test` 命令（或者说是*新测试*，如果你已经使用命令行一段时间了），它帮助你比较字符串并测试文件属性。`-f`
    选项用于常规文件，只有在文件存在时才会成功。所以我们实际上是在说“测试 `~/.zsh_functions` 文件是否存在”。如果测试通过，接下来的命令部分会被执行，我们最终就能加载我们的函数文件。
- en: As a side note, this expression supports filename globbing, so all the tricks
    we learned in [Chapter 4](ch04.html "Chapter 4. Globbing"), *Globbing*, still
    apply here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这个表达式支持文件名通配符，因此我们在[第4章](ch04.html "第4章. 通配符")中学到的所有技巧，*通配符*，仍然适用。
- en: You can source as many files as you like with this same mechanism; just remember
    to add the line into your `.zshrc` file, and don't forget about the test fail-switch,
    which will avoid sourcing files that do not exist in the system (and of course,
    errors).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用相同的机制来源代码多个文件；只需要记得在 `.zshrc` 文件中添加这行，别忘了测试失败开关，这样就能避免加载系统中不存在的文件（当然也避免错误）。
- en: As always, you can scuba dive into the `test` command simply by typing `man
    [` in your terminal. For more details regarding the `[[` compound command, check
    the *CONDITIONAL EXPRESSIONS* section under the `zshmisc(1)` manual entry.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以通过在终端中输入 `man [` 来深入了解 `test` 命令。关于 `[[` 复合命令的更多细节，请参阅 `zshmisc(1)`
    手册中的 *条件表达式* 部分。
- en: 'Okay, I hear you. So what do functions have to do with completion? Well, everything!
    See, `compsys` is entirely made out of functions: functions that will be called
    automatically whenever you hit the *Tab* key. The difference lies in how these
    set of functions use some other special commands to interact with our old pal,
    ZLE, in order to show the available completions. Don''t worry though; contrary
    to popular belief, there''s no arcane magic in here.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我明白了。那么，函数和补全有什么关系呢？其实，关系很大！看，`compsys` 完全是由函数组成的：每当你按下 *Tab* 键时，函数会自动被调用。区别在于，这些函数如何利用一些其他特殊命令与我们的老朋友
    ZLE 进行交互，从而展示可用的补全项。不过别担心；与广泛的看法相反，这里没有任何神秘的魔法。
- en: The path of the function
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的路径
- en: 'So, functions. A truckload of them to be more precise (well, you be the judge
    of this). How does zsh know where to look? It is easier than it sounds; the shell
    will load anything that belongs to its function path or `$fpath`, a series of
    directories that contain the files with the functions required for completion.
    Go ahead and have a look at it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，函数。更准确地说，是一堆函数（嗯，这个你可以自己判断）。zsh 怎么知道该去哪里找呢？其实比听起来要简单；shell 会加载属于其函数路径或 `$fpath`
    的任何东西，这是一系列包含补全所需函数文件的目录。去看看吧：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the directories that show up in your function path list will be scanned
    and loaded by the shell during startup, provided you call `compinit` first. So
    remember to call `autoload –U compinit` in your `.zshrc` file. Note, however,
    that call will load anything that resides in your `$fpath`. If you happen to have
    a special requirement for a single function, you could call it explicitly via
    `autoload`. If you save the previous function as a file named `_greet` and put
    it into one of the directories within your `$fpath`, you could then use the following
    inside your startup files for loading the function into the shell automatically:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，shell 会扫描并加载函数路径列表中出现的所有目录，前提是你首先调用了 `compinit`。所以记得在 `.zshrc` 文件中调用 `autoload
    –U compinit`。不过需要注意的是，这个调用会加载 `$fpath` 中的所有内容。如果你有单独的函数需求，可以通过 `autoload` 显式地调用它。如果你将之前的函数保存为名为
    `_greet` 的文件，并将其放入 `$fpath` 中的某个目录，那么你可以在启动文件中使用以下内容，自动将该函数加载到 shell 中：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: See that `-Uz` flag? The `-U` flag works by telling the shell to use the name
    `_greet` to refer to the function we just created, whereas the `-z` flag tells
    zsh to load the function in the native mode. Both `-U` and `-z` flags are always
    added implicitly whenever you call `autoload`, but I'm leaving it there for you
    to be aware of them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看那个 `-Uz` 标志吗？`-U` 标志的作用是告诉 shell 使用名称 `_greet` 来引用我们刚创建的函数，而 `-z` 标志则告诉 zsh
    以原生模式加载该函数。每次调用 `autoload` 时，`-U` 和 `-z` 标志都会隐式地添加，但我留着它们是为了让你注意到。
- en: 'Okay, so it''s all fun and single-line functions until someone needs something
    a bit more complex. Single functions within a file will be loaded without any
    problem whatsoever. So, how do we use helper functions (auxiliary methods for
    our main functionality) in our files? The zsh way states that we should define
    a function and name it just like the file and call it in the last line of the
    file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，单行函数很有趣，直到有人需要一些更复杂的东西。文件中的单个函数会毫无问题地加载。那么，我们如何在文件中使用辅助函数（用于我们主要功能的辅助方法）呢？zsh
    的方式是我们应该定义一个函数，命名和文件名相同，并在文件的最后一行调用它：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That last line in the file takes care of calling the function named `_foo` inside
    the file, and passing it the same arguments used. So if you called it `meet John`,
    the arguments will be passed to the `meet` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的最后一行负责调用文件中的 `_foo` 函数，并传递相同的参数。如果你调用的是 `meet John`，那么这些参数就会传递给 `meet` 函数。
- en: 'Save the file as `meet` (no extension) inside any of your `$fpath` folders;
    restart your shell and call the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`meet`（没有扩展名），并将其放置在任何一个`$fpath`文件夹内；重新启动你的shell并调用以下命令：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Extending your fpath**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展你的fpath**'
- en: 'If you don''t want to be messing around with copies or links to your functions,
    you can easily extend `fpath` with more folders by setting the variable as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想对函数的副本或链接进行修改，可以通过如下设置变量，轻松地使用更多的文件夹扩展`fpath`：
- en: '[PRE37]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will prepend the folder, `my_folder`, to the shell's `fpath`, effectively
    extending it with whatever lies inside your folders. This is particularly useful
    for those times when you lack the appropriate permissions on a given system. Note
    that we are using the absolute path to the folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文件夹`my_folder`添加到shell的`fpath`，有效地扩展了其内容。这在你缺乏某些系统权限时特别有用。请注意，我们使用的是文件夹的绝对路径。
- en: 'So let''s take a look at a formal completion function. Don''t worry, we''ll
    start with an easy one, such as `_md5sum`, which is typically located under your
    `$ZSH_INSTALL_DIR/functions/` folder. Here it lies in all its glory:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看一个正式的完成函数。别担心，我们从一个简单的开始，比如`_md5sum`，它通常位于`$ZSH_INSTALL_DIR/functions/`文件夹下。它在这里显现出它的全部光辉：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Go ahead and test this by typing `md5sum -` followed by pressing the *Tab* key,
    and you'll be prompted with the options from `arguments`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过输入`md5sum -`，然后按下*Tab*键，你将看到来自`arguments`的选项。
- en: Your very first line of code in any completion function must be the `#compdef`
    clause, followed by the name of the program to be completed by the function (`md5sum`,
    in this particular case).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任何完成函数的第一行代码必须是`#compdef`语句，后跟由该函数完成的程序的名称（在本例中是`md5sum`）。
- en: Next up is a call to the internal `_arguments` function, which does the actual
    handling of the options to be formatted and displayed on screen. This function
    is typically used when specifying the completion of commands whose arguments follow
    standard Unix conventions in their options and arguments' lists. Using the `-S`
    option, we declare that no option will be completed after `--` shows up on the
    line. This is the delimiter used to end the parsing of the option, so this argument
    would be typically ignored unless we explicitly say otherwise.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是对内部`_arguments`函数的调用，该函数实际上处理格式化并显示在屏幕上的选项。此函数通常在指定符合标准Unix约定的命令完成时使用，选项和参数列表遵循这些约定。通过使用`-S`选项，我们声明在`--`出现在行上时，不会再完成任何选项。`--`是用于结束选项解析的分隔符，因此，除非我们明确指定，否则此参数通常会被忽略。
- en: 'If you look closely though, you''ll notice that each of the argument entries
    (split into continuation lines via `\`) follows the same pattern:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现每个参数项（通过`\`分割为续行）遵循相同的模式：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that the curly braces around the option and its verbose variant are there
    to group them together, otherwise they are optional.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，选项及其详细版本周围的花括号是用来将它们分组的，否则它们是可选的。
- en: 'The exclusion list works by explicitly telling zsh what should not be included
    in the results. In other words, whenever the `option` parameter is typed, hide
    all the other options from `(exclusions)`. Take for example the following line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 排除列表通过明确告诉zsh哪些内容不应包含在结果中来工作。换句话说，每当输入`option`参数时，隐藏所有来自`(exclusions)`的其他选项。以下这一行就是一个例子：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If `-t` or `--text` appears in the command line, do not show the `-t` or `--text`
    options as completions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令行中出现了`-t`或`--text`，则不要显示`-t`或`--text`选项作为完成项。
- en: 'This makes even more sense for commands such as `ln`, where you want to avoid
    offering some potentially misguiding options:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这对像`ln`这样的命令更有意义，你可能想避免提供一些可能误导的选项：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Hide the options `-L` and `-P` if `-H` is being used; this is because both the
    options are used for "always follow symbolic links" and "never follow symbolic
    links", respectively.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`-H`选项，则隐藏`-L`和`-P`选项；这是因为这两个选项分别用于“始终跟随符号链接”和“永不跟随符号链接”。
- en: 'Finally, there''s the last line of the `_md5sum` function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`_md5sum`函数的最后一行：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This uses the `_files` helper function that is somewhat the standard tool for
    completing filenames. With this line, we make sure that filenames are completed
    even if no other options' flags are suggested.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了`_files`助手函数，这是一个完成文件名的标准工具。通过这一行，我们确保即使没有建议其他选项标志，文件名仍然会被完成。
- en: Moreover, `_files` uses an additional function, `_path_files`, and passes its
    arguments to the latter. On its own, `_path_files` is the de facto function for
    completing filenames within the completion system. As if it wasn't enough, `_path_files`
    has some really handy tricks up its sleeve such as completion of partial paths,
    which enables things such as `/u/bi/zs` to be completed to `/usr/bin/zsh`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`_files` 使用了一个额外的函数`_path_files`，并将其参数传递给后者。单独看，`_path_files` 是补全系统中用于完成文件名的事实标准函数。如果这还不够，`_path_files`
    还有一些非常实用的技巧，例如部分路径的补全，这使得像`/u/bi/zs`这样的路径可以补全为`/usr/bin/zsh`。
- en: Then, there are also helper functions such as `_call_program`, which are used
    to execute any kind of commands available to the system. A common practice when
    using `_call_program` is to redirect the standard error to `/dev/null` (this is
    a nice way of saying it's silencing any error-induced screams) and allows us to
    save the output of the command into a variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还有一些辅助函数，如`_call_program`，用于执行系统可用的任何命令。使用`_call_program`的常见做法是将标准错误重定向到`/dev/null`（这是一种婉转的方式，表示它会抑制任何由错误引发的错误信息），并允许我们将命令的输出保存到一个变量中。
- en: And that's all there's to it. Well, at least for getting started with the completion
    mechanism and custom-made functions. Although, on some occasions, getting your
    hands dirty and extending the completion system with your own functions will only
    get you so far, this quick fly-by should be enough to get you excited about the
    possibilities lying there. Again, it's advisable that you try not to reinvent
    the wheel—as we'll see in the next chapter, there are many other projects out
    there that can give you a nice boost in the completion department.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样了。嗯，至少对于开始使用补全机制和自定义函数来说是这样的。虽然在某些情况下，亲自动手扩展补全系统和编写自己的函数只会让你走得更远，但这次快速浏览应该足以让你对那些可能性感到兴奋。再说一次，建议你尽量避免重复造轮子——正如我们将在下一章看到的那样，外面有许多其他项目可以在补全方面给你带来很大的帮助。
- en: You can now go ahead and take a deep dive into the `functions` folder of your
    zsh installation to start getting familiarized with the thousands of lines of
    code there. Who knows? Perhaps the starting template for the next completion function
    is just waiting there for you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以深入`functions`文件夹，开始熟悉你 zsh 安装中的成千上万行代码了。谁知道呢？也许下一个补全函数的起始模板就在那里等着你。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We are almost done with this adventure, and it seems you are now more ready
    than ever to start tackling major annoyances like your favorite program not having
    a set of completion definitions. Even better, you can tweak and improve the existing
    functionality, which otherwise would make your work really frustrating.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了这段旅程，现在看起来你比以往任何时候都更准备好应对一些常见的麻烦，比如你最喜欢的程序没有一组补全定义。更棒的是，你还可以调整并改善现有的功能，否则这些问题会让你的工作变得非常让人沮丧。
- en: Besides writing your own functions, we also learned how to tweak the shell behavior
    and go a step above filename completion. With a bit of practice and further tweaking,
    you can now become a real speed demon of the command line. Best of all, it only
    takes a couple of *Tab* presses to get there.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写自己的函数，我们还学习了如何调整 shell 行为，并进一步提升文件名补全功能。通过一些练习和进一步的调整，你现在可以成为命令行的真正高手。最棒的是，只需要按下几次*Tab*键就能达到这个水平。
- en: 'Summing it up, here''s what''s covered in this chapter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，本章涉及的内容如下：
- en: The types of completion available to zsh—zstyles and functions, which allow
    you to customize the behavior of the completion mechanism and extend its functionality
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: zsh 提供的补全类型——zstyles 和函数，允许你自定义补全机制的行为并扩展其功能
- en: The different types of completers (particularly `correct`, `approximate` & `ignore`)
    and their role when defining zstyles
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的补全器（特别是`correct`、`approximate` 和 `ignore`）及其在定义 zstyles 时的作用
- en: A few tips for creating and extending your our own completion functions
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和扩展你自己的补全函数的小贴士
- en: Okay then, before I get sentimental, we should hurry to the next chapter that
    has a few suggestions before we're done with this journey of ours.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么在我开始变得感性之前，我们应该赶紧进入下一章，那里有一些建议，在我们结束这段旅程之前。
