- en: Chapter 2. Cold Starts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。冷启动
- en: In the Northern Hemisphere, I think we can all relate to the analogy of the
    cold start; those bleak January mornings where you are frantically trying to start
    your car. When it does finally splutter into some form of life, we then have to
    contend with a steering wheel too cold to hold. Thankfully, starting up a Linux
    system is not so unpleasant; perhaps air-conditioned server rooms have something
    to do with this, I am not sure…
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在北半球，我想我们都能理解冷启动的比喻：那些寒冷的1月早晨，你拼命尝试启动汽车。当它最终勉强发动时，我们还得忍受方向盘冰冷得无法握住。幸运的是，启动Linux系统并不那么不愉快；或许空调服务器房间与此有关系，我也不太确定……
- en: 'Working through this chapter, we are going to build upon what you have already
    mastered—helping you understand your Linux systems. You will learn about the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的学习过程中，我们将基于你已掌握的内容，帮助你更好地理解你的Linux系统。你将学习以下主题：
- en: '**The GRUB and the MBR**: In this section, you will learn about the relationship
    that the **GRand Unified Bootloader** (**GRUB**) enjoys with the **Master Boot
    Record** (**MBR**), being able to slip its slender 466 bytes easily inside the
    512-byte limit.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRUB与MBR**：在这一节中，你将学习**GRand Unified Bootloader**（**GRUB**）与**主引导记录**（**MBR**）之间的关系，GRUB能够轻松地将它那仅有的466字节放入512字节的限制内。'
- en: '**When is the root filesystem not the root filesystem?**: In this section,
    we will understand the term *root* when used as a directive within a GRUB stanza,
    which is a little hurdle we shall overcome.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当根文件系统不是根文件系统时？**：在这一节中，我们将理解在GRUB配置段中使用的*root*指令的含义，这是我们需要克服的小障碍。'
- en: '**Working on the** **GRUB console**: In this section, you will learn how to
    enable some powerful recovery tools.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在GRUB控制台工作**：在这一节中，你将学习如何启用一些强大的恢复工具。'
- en: '**Protecting the GRUB menu with passwords**: In this section, you will learn
    how to enforce physical security of your systems: desktops or servers.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用密码保护GRUB菜单**：在这一节中，你将学习如何加强系统的物理安全性：无论是桌面还是服务器。'
- en: '**Boot splashing with plymouth**: A little fun to finish the section with,
    we will look at the range of boot splash screens that we can use with CentOS.
    By the end of this chapter, your Linux system will never have been so well dressed.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过plymouth进行启动界面显示**：为了让本节内容更加有趣，我们将看看可以在CentOS中使用的启动界面。到本章结束时，你的Linux系统将变得前所未有地“华丽”。'
- en: The GRUB and MBR
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GRUB与MBR
- en: 'This is not just a competition to see how many acronyms we can fit into a chapter
    heading, although, out of four words, having used two already is not a bad start.
    The **GRUB** is the system-supplied bootloader that ships with CentOS and Red
    Hat Enterprise Linux 6\. This tiny piece of bootstrap code is used to load the
    kernel and allows us to dual boot different Linux versions or even with Microsoft
    Windows operating systems. The GRUB has been the bootloader of choice for many
    years, although other bootloaders do exist. These include:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅仅是一场比赛，看看我们能在章节标题中塞进多少个首字母缩略词，尽管在四个单词中，已经用了两个也算是一个不错的开始。**GRUB**是CentOS和Red
    Hat Enterprise Linux 6自带的引导加载程序。这个小小的启动代码用来加载内核，并允许我们双启动不同的Linux版本，甚至是与Microsoft
    Windows操作系统的双启动。GRUB多年来一直是首选的引导加载程序，尽管也存在其他引导加载程序。这些包括：
- en: '**Lilo**: This is the original Linux loader'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lilo**：这是最早的Linux加载程序'
- en: '**EXTLinux**: This is part of the SYSLinux family that includes the following:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXTLinux**：这是SYSLinux家族的一部分，包括以下内容：'
- en: EXTLinux to boot from fixed drives
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用EXTLinux从固定磁盘启动
- en: ISOLinux to boot from CDs and DVDs
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ISOLinux从CD和DVD启动
- en: SYSLinux to boot from a USB device
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SYSLinux从USB设备启动
- en: PXELinux to boot from the network
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PXELinux从网络启动
- en: '**GRUB2**: More recently, this is making its appearance as a replacement to
    GRUB, or what is now referred to as the legacy GRUB. GRUB2 is likely to debut
    in CentOS 7 in 2014.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRUB2**：最近，GRUB2开始作为GRUB的替代品出现，或者说作为现在所称的传统GRUB的替代。预计GRUB2将在2014年的CentOS
    7中首次亮相。'
- en: The GRUB bootloader is most commonly stored in the MBR of the bootable drive.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB引导加载程序通常存储在可启动磁盘的MBR中。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although generally stored within the MBR, it is possible to install GRUB into
    the superblock, or the first 512 bytes, of a partition.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常存储在MBR中，但也可以将GRUB安装到分区的超级块中，或分区的前512字节中。
- en: The MBR makes up the first 512 bytes of the disk, allowing up to 466 bytes of
    storage for the bootloader; the additional space will be used to store the partition
    table for that drive.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MBR构成了磁盘的前512字节，允许最多存储466字节的引导加载程序；其余的空间将用来存储该驱动器的分区表。
- en: 'We can back up the MBR to a file using the `dd` command as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `dd` 命令将 MBR 备份到文件中，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `dd` command is used to duplicate a disk. In the previous command, we read
    from the first disk, `/dev/sda`, and backed it up to the `/tmp/sda.mbr` file.
    Rather than duplicating the entire disk, we limit the backup to a count of one
    block of 512 bytes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd` 命令用于复制磁盘。在前面的命令中，我们从第一个磁盘 `/dev/sda` 读取数据，并将其备份到 `/tmp/sda.mbr` 文件中。我们没有复制整个磁盘，而是将备份限制为一个
    512 字节大小的块。'
- en: 'Now that we have a backup for the MBR, we can investigate this fact a little
    more by running the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 MBR 的备份，可以通过运行以下命令进一步调查此事实：
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The following commands can be destructive, in that they will destroy the MBR,
    so please take care if you will be running commands on your own system, and I
    would recommend running only the following demonstration commands on a test system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可能会有破坏性，因为它们将销毁 MBR，所以如果你将在自己的系统上运行这些命令，请小心。我建议仅在测试系统上运行以下演示命令。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the preceding command, we have wiped the data stored within the first
    512 bytes of the disk `/dev/sda`. The MBR now is effectively cleared. We can verify
    this by using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述命令，我们已清除了磁盘 `/dev/sda` 中前 512 字节存储的数据。现在，MBR 已有效清除。我们可以使用以下命令来验证这一点：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output should display an empty partition table. The system remains usable
    as the partition table is resident to the RAM on the running system; however,
    until we are able to restore the MBR, a reboot will soon identify how much of
    a disaster we are in. Never fear, we can restore the MBR from the backup. What
    `dd` takes away, `dd` can return, simply by using the `dd` command as follows.
    Quickly, before someone notices!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该显示一个空的分区表。系统仍然可以使用，因为分区表驻留在运行系统的 RAM 中；然而，直到我们能够恢复 MBR，重新启动时将很快显示出我们面临的灾难。别担心，我们可以从备份中恢复
    MBR。`dd` 删除的东西，`dd` 也能恢复，只需使用如下的 `dd` 命令。赶快，在别人注意到之前！
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We do not need to limit the amount of data to be read from the specified file.
    Remember, it only contains the 512 bytes that make up the MBR. With a little luck,
    using the `fdisk` command will now show the partition table correctly as it was
    before, and you can begin to breathe easy again:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要限制从指定文件读取的数据量。请记住，它仅包含组成 MBR 的 512 字节。稍微幸运一些，使用 `fdisk` 命令现在应该能正确显示以前的分区表，你可以开始松一口气了：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using the `dd` command to wipe a disk completely with the `/dev/zero` input
    file is useful should you wish to wipe a disk before selling a computer, ensuring
    that the operating system, applications, and most importantly, the data is not
    sold with the device. We use `fdisk` in the second example as `lsblk` reads from
    memory and not the disk.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dd` 命令将磁盘完全擦除，并使用 `/dev/zero` 输入文件是非常有用的，尤其是当你希望在出售计算机之前清除磁盘，确保操作系统、应用程序，以及最重要的数据不随设备一起出售时。我们在第二个示例中使用
    `fdisk`，因为 `lsblk` 从内存读取数据，而不是从磁盘。
- en: Once we have booted into GRUB, a menu will be shown allowing the user to select
    the **operating system** (**OS**) to enter. In general, the default selection
    is loaded without user interaction. We can configure the menu choices using the
    `/boot/grub/menu.lst` file. You will learn more about this file later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入 GRUB，菜单将会显示，允许用户选择要进入的**操作系统**（**OS**）。通常，默认选择会在没有用户交互的情况下加载。我们可以使用 `/boot/grub/menu.lst`
    文件来配置菜单选项。稍后你将了解更多关于此文件的信息。
- en: When is the root filesystem not the root filesystem?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统何时不是根文件系统？
- en: We now need to break down the menu entries within the file, identifying the
    core components so that we can understand how they relate to the system and, most
    importantly, how we can correct errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要分解文件中的菜单条目，识别出核心组件，以便理解它们如何与系统相关联，最重要的是，如何修正错误。
- en: Editing stanzas in GRUB
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑 GRUB 诗句
- en: 'Each entry in the GRUB menu is known as a **stanza**, and each stanza will
    start with the `title` word, containing three directives as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 菜单中的每个条目被称为**诗句**，每个诗句将以 `title` 单词开头，包含以下三个指令：
- en: '`root`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`'
- en: '`kernel`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`'
- en: '`initd`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initd`'
- en: 'The title of the stanza also becomes the displayed item in the menu. Let''s
    consider a stanza that begins with the following title:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 诗句的标题也将成为菜单中显示的项目。我们来考虑一个以以下标题开始的诗句：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The menu will display `CentOS 6.5 OS` as the selectable item, and it is important
    to note that we do not add quotes around the text as they will also be displayed
    to the user. This is unless, of course, you want or need to display these quotes;
    we are most certainly not quote unfriendly at Packt Publishing!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单将显示`CentOS 6.5 OS`作为可选择项，重要的是要注意，我们不会在文本周围添加引号，因为它们也会显示给用户。当然，除非你希望或需要显示这些引号；在Packt
    Publishing，我们绝对不反对使用引号！
- en: Adding a root entry to a stanza
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向节中添加根分区条目
- en: Directly following the stanza title will be a line that starts with the `root`
    directive. This identifies the root filesystem to GRUB and not the OS root; in
    simple terms, this should point to the partition that is marked as bootable in
    the partition table.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着节标题后面会有一行以`root`指令开始。这会告诉GRUB根文件系统的位置，而不是操作系统的根文件系统；简单来说，这应该指向分区表中被标记为可启动的分区。
- en: 'We can use the `fdisk` or `parted` command to display the bootable partition.
    If you are using the `fdisk` command to display the partition information, the
    command would be similar to the following where we want to list the partitions
    of the first hard drive within the system:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fdisk`或`parted`命令显示可启动分区。如果你使用`fdisk`命令显示分区信息，命令会类似于以下内容，我们希望列出系统中第一块硬盘的分区：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The partition marked as bootable will be identified with an asterisk mark.
    If you are using the `parted` command to display the partition table, you will
    be able to identify the bootable partition by the boot flag by executing the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为可启动的分区会用星号（`*`）表示。如果你使用`parted`命令显示分区表，你可以通过执行以下命令，按照启动标志来识别可启动的分区：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `fdisk` shows the bootable partition with `*` and parted with the word `boot`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`fdisk`会用`*`标记可启动分区，而`parted`则会标记为`boot`。'
- en: The bootable partition can be `/boot` or the actual root filesystem itself `/`.
    This relates to how the system was configured as it was installed. It might often
    be the case that `/boot` will have its own partition to ease access by the bootloader.
    The legacy GRUB, for example, cannot access a filesystem built on **Logical Volume
    Management** (**LVM**); this is the default partitioning proposal in CentOS 6\.
    The same applies to software **Redundant Array of Inexpensive Disks** (**RAID**)
    arrays.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可启动的分区可以是`/boot`，也可以是实际的根文件系统`/`。这与系统在安装时的配置方式有关。通常情况下，`/boot`会有自己的分区，以便引导加载程序更方便地访问。例如，传统的GRUB无法访问基于**逻辑卷管理**（**LVM**）构建的文件系统；这是CentOS
    6中的默认分区方案。**冗余阵列的廉价磁盘**（**RAID**）阵列也适用相同的情况。
- en: 'Consider the following stanza:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下节：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From this, we can determine that GRUB should mount the first partition on the
    first drive (both the drive and partition numbering starts at 0) as the bootable
    partition.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以确定，GRUB应该将第一块硬盘上的第一个分区（驱动器和分区编号都从0开始）作为可启动分区。
- en: To summarize, the `root` directive in a GRUB stanza indicates the partition
    that the MBR marks as bootable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，GRUB节中的`root`指令指示MBR标记为可启动的分区。
- en: Adding a kernel entry to a stanza
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向节（stanza）中添加内核条目
- en: The directive, `kernel`, directs the bootloader to the target operating system
    kernel. The path to that kernel will be related to the GRUB root partition, or
    the bootable partition. If the path reads `/vmlinuz.version`, then this would
    be an indication that the kernel is located at the root of the bootable partition,
    whereas the path `/boot/vmlinuz.version` would indicate that the bootable partition
    is the Linux or OS root partition. The path has to include the `/boot` directory
    to be able to locate the kernel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernel`指令将引导加载程序指向目标操作系统内核。该内核的路径将与GRUB根分区或可启动分区相关。如果路径是`/vmlinuz.version`，则表示内核位于可启动分区的根目录下，而路径`/boot/vmlinuz.version`则表示可启动分区是Linux或操作系统根分区。路径必须包含`/boot`目录，才能找到内核。'
- en: Following the filename of the kernel are the arguments used when loading the
    kernel, or more simply referred to as the kernel options. These options include,
    among others, the device name where the real root filesystem is located and the
    device name for the swap filesystem, which can be used to suspend the system,
    perhaps on a laptop build. An example of the OS root option would be `root=/dev/sda2`;
    this being the second partition on the first hard drive or `root=/dev/mapper/vg_centos-vg_root`.
    This indicates that the operating system root is built upon an LVM. The swap filesystem
    to be suspended is indicated by the `resume` option.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核文件名之后是加载内核时使用的参数，通常被称为内核选项。这些选项包括：真实根文件系统所在的设备名称和交换文件系统的设备名称，这些选项可以用于挂起系统，例如在笔记本电脑上构建。操作系统根的一个例子是
    `root=/dev/sda2`；这是第一块硬盘上的第二个分区，或者 `root=/dev/mapper/vg_centos-vg_root`。这表示操作系统根是基于
    LVM 构建的。需要挂起的交换文件系统通过 `resume` 选项进行指示。
- en: 'The following extract from a stanza indicates that the boot partition is `/dev/sda1
    (hd0,0)` and the operating system root is `/dev/sda2`, with the swap located on
    `/dev/sda3`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个条目的摘录，表示启动分区是 `/dev/sda1 (hd0,0)`，操作系统根是 `/dev/sda2`，交换分区位于 `/dev/sda3`：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the OS root is also the bootable partition, the corresponding GRUB stanza
    would read similar to the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作系统根分区同时也是可启动分区，则相应的 GRUB 条目将类似如下：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that the path to the kernel is now the full operating system path
    and both the GRUB root and the OS root correspond to the same partition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，现在内核的路径是完整的操作系统路径，GRUB 根和操作系统根对应的是同一个分区。
- en: 'Given a running system where the boot process is completed and we are logged
    in, it is possible to view the version of the kernel with either of the following
    commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程完成并且我们已登录的运行系统中，可以使用以下任一命令查看内核版本：
- en: '`$ cat /proc/version`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ cat /proc/version`'
- en: '`$ uname –r`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ uname -r`'
- en: You should look at both commands and see which one best suits your needs; the
    `/proc/version` file will give a little more information. However, the `uname
    -r` command summarizes the information well. This is your system and it is your
    choice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该查看这两个命令，看看哪个最适合你的需求；`/proc/version` 文件会提供更多信息。不过，`uname -r` 命令总结了信息。这个系统是属于你的，你可以做出选择。
- en: 'Should we need to list the options with which the kernel was booted, we can
    display those options with the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要列出内核启动时使用的选项，可以通过以下命令显示这些选项：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By this stage, I am hoping you have a little more understanding of when the
    root filesystem may not actually be the root filesystem and when it can be the
    root filesystem. You are now ready to use this riddle anytime that you wish to
    confuse your colleagues. It really is a simple matter of knowing where the partition
    that holds the kernel is; this then becomes the root of the bootable partition.
    The OS root is what we normally think as of the root filesystem but this happens
    only once the system has completed the boot process. The kernel directive simply
    points to the kernel file with a path relative to the root of the boot partition
    along with any options that we may wish to pass through to the kernel when it
    is loaded.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个阶段，我希望你对什么时候根文件系统实际上并不是真正的根文件系统，以及什么时候它可以是根文件系统有了更多的理解。现在，你准备好随时使用这个谜题来困惑你的同事了。实际上，这只是知道存储内核的分区在哪儿的问题；它将成为可启动分区的根。操作系统根是我们通常认为的根文件系统，但只有当系统完成启动过程后，才会这样认为。内核指令简单地指向内核文件，其路径是相对于启动分区根的路径，可能还包括我们希望在加载内核时传递给内核的任何选项。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `/proc` directory is a pseudo filesystem, meaning that it is transient and
    resides only in the RAM. It contains up-to-date information for the currently
    running system. This directory is worth becoming acquainted with.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc` 目录是一个伪文件系统，这意味着它是临时的，只存在于内存中。它包含当前运行系统的最新信息。这个目录值得你去熟悉。'
- en: Adding an initrd entry to a stanza
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向一个条目中添加 initrd
- en: Similar to the `kernel` directive, the `initrd` directive will point to the
    initialization RAM disk; a mini OS that is compiled with the drivers needed to
    access the OS root filesystem. The RAM disk loads prior to the kernel and mounts
    the OS root filesystem as read-only. Filesystem integrity checks are performed
    before handing it to the kernel to continue with the boot process and mounting
    as read/write. This means that the kernel does not have to have the drivers for
    the root filesystem internally compiled, allowing more flexibility in changes
    to the OS root and a more lean kernel. The RAM disk can be recompiled if the root
    filesystem changes or the drivers need to access the hardware change with the
    `mkinitrd` command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`kernel`指令类似，`initrd`指令将指向初始化RAM磁盘；它是一个与访问操作系统根文件系统所需的驱动程序一起编译的迷你操作系统。RAM磁盘在内核之前加载，并将操作系统根文件系统以只读模式挂载。在将其交给内核继续启动过程并挂载为读写之前，会执行文件系统完整性检查。这意味着内核不必将根文件系统的驱动程序内部编译，从而允许对操作系统根目录进行更多灵活的更改，并且内核更加精简。如果根文件系统发生变化或需要访问硬件的驱动程序发生变化，可以使用`mkinitrd`命令重新编译RAM磁盘。
- en: 'Continuing with our example stanza, we can insert a line for the `initrd` directive
    to read as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的示例配置段，我们可以插入一行`initrd`指令，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Not wishing to be out performed by the preceding simple text, the following
    screenshot shows an extract from a real GRUB stanza on my CentOS 6.5 system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不被前面简单的文本超越，以下截图展示了我的CentOS 6.5系统中一个实际GRUB配置段的摘录。
- en: '![Adding an initrd entry to a stanza](img/5902OS_02_01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![将initrd条目添加到配置段](img/5902OS_02_01.jpg)'
- en: Working on the GRUB console
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GRUB控制台工作
- en: 'When presented with the GRUB menu, as well as selecting the entry we wish to
    boot, we can either edit existing entries or shell out to the GRUB console. Working
    on the GRUB console enables us to enter our own sets of commands. Remember the
    trilogy that should accompany each stanza:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当看到GRUB菜单时，除了选择我们希望启动的项外，我们还可以编辑现有项或进入GRUB控制台。通过在GRUB控制台工作，我们可以输入自己的一组命令。记住每个配置段应伴随的三部曲：
- en: root
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: root
- en: kernel
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kernel
- en: initrd
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: initrd
- en: 'We can enter these commands, but also reinstall GRUB if required. More simply,
    in the console, we can also edit or append to the exiting entries; using the *e*
    key, we can edit an entry, and *a* can be used to append an option to the kernel
    line. From the following screenshot, we can view these options:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输入这些命令，但如果需要，也可以重新安装GRUB。更简单地说，在控制台中，我们还可以编辑或附加到现有条目；使用*e*键，我们可以编辑一个条目，*a*键可以用来将选项附加到内核行。从以下截图中，我们可以查看这些选项：
- en: '![Working on the GRUB console](img/5902OS_02_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![在GRUB控制台工作](img/5902OS_02_02.jpg)'
- en: Editing the kernel arguments allows you to specify the runlevel target to boot
    to; using this method, it is possible to reset the password of the root user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑内核参数允许你指定要启动的运行级别目标；使用此方法，可以重置root用户的密码。
- en: To recover a forgotten root password, we can boot the system to runlevel 1;
    by default, this will log you in directly as root.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复忘记的root密码，我们可以将系统启动到运行级别1；默认情况下，这将直接以root身份登录。
- en: Firstly, we must select the entry in the menu to boot to. If there is more than
    one, do not use the *Enter* key.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须选择菜单中要启动的项。如果有多个选项，请不要按*Enter*键。
- en: With the menu entry highlighted, choose the letter *a*.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮菜单项后，选择字母*a*。
- en: This will take you directly to the end of the kernel line where you can add
    the number 1 to boot to runlevel 1.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将直接带你到内核行的末尾，在那里你可以添加数字1以启动到运行级别1。
- en: Note
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that *CentOS System Administration Essentials* assumes
    that no prior runlevel has already been specified in the kernel arguments.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要注意的是，*CentOS系统管理要点*假设内核参数中尚未指定先前的运行级别。
- en: With the number added, just hit the *Enter* key, and the system will boot to
    the single user mode and logged in as root. Once the system has been booted, you
    can effectively change a password using the `passwd` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 添加数字后，只需按*Enter*键，系统将启动到单用户模式并以root身份登录。一旦系统启动后，你可以使用`passwd`命令有效地更改密码。
- en: 'It is possible to prevent this behavior; we have to be cautious to avoiding
    the prevention genuine recovery mechanisms of our server. If there is enough physical
    protection of the server, then perhaps we do not need to make any changes. However,
    if we cannot ensure physical security of the server, we can edit the `/etc/sysconfig/init`
    file by changing the `SINGLE=/sbin/sushell` line to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 是可以防止这种行为的；我们必须小心，以避免阻止服务器的真正恢复机制。如果服务器有足够的物理保护，或许我们不需要做任何修改。然而，如果我们无法确保服务器的物理安全性，我们可以编辑`/etc/sysconfig/init`文件，将`SINGLE=/sbin/sushell`行更改为以下内容：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `sulogin` command will prompt for the root user's password.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`sulogin`命令将提示输入root用户的密码。'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If `sulogin` has been set and you still need emergency access as root, it is
    possible by specifying `init=/bin/bash` instead of 1 as the runlevel.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已设置`sulogin`并且你仍然需要以root身份进行紧急访问，可以通过将运行级别指定为`init=/bin/bash`而不是1来实现。
- en: 'If our boot situation is a little more serious, or in human terms, it won''t
    boot, then we can enter the GRUB command prompt using the option `c`. Using the
    command `help`, we can determine what commands are available from the minimal
    shell. To reinstall GRUB with the correct drivers to access the boot partition,
    execute the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的启动情况有点严重，或者用人话说，系统无法启动，那么我们可以使用选项`c`进入GRUB命令提示符。通过使用`help`命令，我们可以确定在最小化的shell中可以使用哪些命令。要重新安装GRUB并正确加载驱动程序以访问启动分区，可以执行以下命令：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command will check to see if `/boot/grub/stage1` or `/grub/stage1`
    exists on the bootable partition. This way, it determines which partition to use
    as root and copies the `stage1` file to the MBR complete with the drivers needed
    to access the bootable partition. We can then choose to restart the system with
    the `reboot` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将检查`/boot/grub/stage1`或`/grub/stage1`是否存在于可启动分区上。通过这种方式，它确定要使用哪个分区作为根，并将`stage1`文件复制到MBR中，并附带访问可启动分区所需的驱动程序。然后，我们可以选择通过`reboot`命令重新启动系统。
- en: Not only can we use the GRUB console to repair GRUB, we can use it to boot the
    system and verify the menu items. By specifying the root filesystem to be used
    for booting, we can check the path required to access the kernel and `initrd`.
    We can use the normal tab completion on the GRUB shell to see directories and
    filenames.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以使用GRUB控制台来修复GRUB，还可以用它来启动系统并验证菜单项。通过指定用于启动的根文件系统，我们可以检查访问内核和`initrd`所需的路径。我们可以在GRUB
    shell中使用正常的Tab键补全来查看目录和文件名。
- en: Protecting the GRUB menu with passwords
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用密码保护GRUB菜单
- en: Now I can imagine that all of this talk to gain root access from the physical
    server can be quite alarming; the truth is that it really shouldn't be, as securing
    physical access to the server is normally not difficult or onerous. However, where
    there is a desire or need to take the security further, it can easily be implemented
    through GRUB passwords. Any password settings will normally be added to the global
    section that precedes any stanza. Firstly, let's review some of the GRUB global
    options before setting some passwords.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以想象，所有关于从物理服务器获取root访问权限的谈话可能会让人感到相当震惊；事实是，这其实不应该让人担心，因为保护物理服务器的访问通常并不难或繁重。然而，如果希望或需要进一步加强安全性，可以通过GRUB密码轻松实现。任何密码设置通常会添加到在任何小节之前的全局部分。首先，让我们在设置密码之前回顾一些GRUB的全局选项。
- en: On visiting the `/boot/grub/menu.lst` file on CentOS, we will see that the first
    lines are commented out and generated by the installer **anaconda**, and that
    the file is named as `grub.conf`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问CentOS中的`/boot/grub/menu.lst`文件时，我们会看到文件的第一行是被注释掉的，并且是由安装程序**anaconda**生成的，文件名为`grub.conf`。
- en: The `menu.lst` file does exist in Red Hat and CentOS but is in the guise of
    a symbolic link to `/boot/grub/grub.conf`. From the legacy GRUB documentation,
    the file should be `menu.lst`; CentOS provides this with the link, but I feel
    that the file is more logically named `grub.conf`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu.lst`文件确实存在于Red Hat和CentOS中，但它是作为指向`/boot/grub/grub.conf`的符号链接。根据传统GRUB文档，文件应该是`menu.lst`；CentOS提供了这个链接，但我认为这个文件更合理的名称应该是`grub.conf`。'
- en: 'For ease of access, a symbolic link `/etc/grub.conf` links through the `/boot/grub/grub.conf`
    file. The single file can then be accessed as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便访问，符号链接`/etc/grub.conf`通过`/boot/grub/grub.conf`文件链接。然后，可以按如下方式访问该文件：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `default` directive will direct GRUB to the default stanza or entry if no
    choice is made before the timeout.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`指令将在超时前如果没有做出选择时，指引GRUB到默认的小节或条目。'
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we will select the first stanza, stanza 0, if no selection has been made
    within 5 seconds of the menu loading. The directive, `hiddenmenu`, prevents the
    menu from showing unless the *Esc* key is pressed. This is especially helpful
    where there is only one entry in the menu, which is often the case, making good
    and practical sense.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，如果菜单加载后 5 秒内没有做出选择，我们将选择第一个段落，即段落 0。指令 `hiddenmenu` 会阻止菜单显示，除非按下 *Esc* 键。这在菜单中只有一个条目时尤为有用，这种情况很常见，因此非常合理且实用。
- en: 'If you need to prevent users from selecting anything other than what is provided
    via the menu, then we can add a password to the global settings. This will ensure
    that, unless the password is entered, only the menu items provided by the menu
    are available and the option to enter the GRUB shell or append or edit the entries
    is restricted. The following snippet of code illustrates how this is possible:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要防止用户选择菜单以外的选项，那么我们可以在全局设置中添加密码。这将确保，除非输入密码，否则只能选择菜单中提供的条目，且进入 GRUB shell
    或附加、编辑条目的选项将被限制。以下代码片段演示了如何实现这一点：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you do not like the idea of a clear text password in the GRUB menu file,
    then you can use the `grub-md5-crypt` command. You can add the encrypted password
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢在 GRUB 菜单文件中看到明文密码，那么可以使用 `grub-md5-crypt` 命令。你可以按如下方式添加加密的密码：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also add a password directly to a stanza. Adding a password to a stanza
    ensures that users can only choose that selection from the menu if they know the
    password. In this way, should you want, you can always have a runlevel 1 entry
    in the menu but protected by the password as follows
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接为某个段落添加密码。为段落添加密码确保用户只有在知道密码的情况下才能从菜单中选择该选项。这样，如果你愿意，你总可以在菜单中设置一个运行级别
    1 的条目，但可以通过密码进行保护，如下所示。
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Boot splashing with plymouth
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 plymouth 启动画面
- en: 'As soon as we have begun the boot process and just prior to handing control
    to the kernel, a boot splash screen can be displayed. This, as the name suggests,
    controls the splash screen you may see during the boot process. In CentOS, this
    defaults to the plymouth theme: rings. Plymouth is the boot splash manager; we
    can use other themes should we wish. Some of these are installed as standard,
    while others are included in the standard repositories. Yet, more themes can be
    found in third-party repositories.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始引导过程，并在将控制权交给内核之前，就可以显示启动画面。如其名所示，这控制了你在启动过程中可能看到的启动画面。在 CentOS 中，默认使用的是
    plymouth 主题：rings。Plymouth 是启动画面管理器；如果需要，我们可以使用其他主题。部分主题是作为标准预装的，其他则包含在标准仓库中。更多主题可以在第三方仓库中找到。
- en: You can, of course, build your own theme. Essentially, a minimal theme is just
    a wallpaper.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以构建自己的主题。实际上，一个最小的主题仅仅是一个壁纸。
- en: Applying different themes
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用不同的主题
- en: Most of the time during the boot process, you will not see the splash screen
    unless CentOS is your desktop machine. However, I would recommend still working
    with plymouth to change the default splash from rings to basic. With the basic
    theme, we can see the services loading during the boot process rather than the
    rings that merely show the boot progress. I would humbly suggest that if you are
    looking at the server during the boot process, then there are issues and you might
    want to see the services loading and messages they report back. If you want to
    be a little more relaxed in your approach, try the theme solar. This shows a planet
    and some asteroids whizzing around it to illustrate the boot process.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数启动过程中，除非 CentOS 是你的桌面机器，否则你不会看到启动画面。然而，我仍然建议使用 plymouth 将默认启动画面从 rings 更改为
    basic。使用 basic 主题时，我们可以看到在启动过程中加载的服务，而不是仅仅显示启动进度的圆环。我谦虚地建议，如果你在启动过程中看到服务器界面，可能表示有问题，你可能希望看到加载的服务及其返回的消息。如果你想采取更轻松的方式，可以尝试
    solar 主题。这个主题展示了一个行星和一些绕行的陨石，以说明启动过程。
- en: 'On the command line, we display the default theme as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，我们显示默认主题如下所示：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To display the available themes on the system, we can use the command as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示系统上可用的主题，我们可以使用如下命令：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'CentOS, by default, provides three themes as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CentOS 默认提供三个主题，如下所示：
- en: '**details**: This shows us the services as they load'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**details**：此主题显示我们加载的服务'
- en: '**rings**: This is the default theme and includes the CentOS logo with a spinning
    ring below the logo'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rings**：这是默认主题，包含 CentOS 标志，标志下方有一个旋转的圆环'
- en: '**text**: This is a blank splash screen with just the horizontal progress bar
    at the base of the display'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**text**：这是一个空白启动画面，只有显示器底部的水平进度条'
- en: 'These themes are all located in sub directories under the path: `/usr/share/plymouth/themes`.
    Should we want to change the theme to `details`, we can do so by using the following
    command. Please note that the command does take a few minutes to run as the process
    rebuilds the RAM disk to include the new theme.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题都位于路径 `/usr/share/plymouth/themes` 的子目录中。如果我们想要将主题更改为`details`，可以使用以下命令进行。请注意，此命令需要几分钟来运行，因为该过程会重新构建
    RAM 磁盘以包含新主题。
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With this done, you can reboot and even see the difference as the system shuts
    down. Instead of the infernal rings, we see meaningful messages from our services
    as they close down.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，您可以重新启动系统，看到系统关闭时的不同之处。不再是无尽的环形进度条，我们将看到来自服务的有意义的关闭消息。
- en: 'If we want to be a little more adventurous, then standard CentOS repositories
    include the additional themes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更加冒险，那么标准的 CentOS 软件仓库中还包括额外的主题：
- en: fade-in
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐显
- en: solar
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太阳
- en: spinfinity
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: spinfinity
- en: 'In order to install and set the theme `spinfinity`, execute the following commands:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装并设置主题`spinfinity`，请执行以下命令：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A partial screenshot from the spinfinity theme is as shown in the following
    screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从 spinfinity 主题的部分截图如下所示：
- en: '![Applying different themes](img/5902OS_02_03.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![应用不同主题](img/5902OS_02_03.jpg)'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, here we are, we have made it to the end of another glorious chapter! You,
    my dear reader, yes you (there is only one of you), are a little closer to stardom
    in the Linux Hall of Fame.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们到了又一个辉煌章节的结尾！你，我亲爱的读者，是的，就是你（这里只有你一个人），离进入 Linux 名人堂又近了一步。
- en: We should now have been able to understand that GRUB is the bootloader commonly
    used in Enterprise Linux, and it will consist of stanzas to boot operating systems.
    Each stanza consists of three commands. The triumvirate of commands being root,
    kernel, and initrd. We also made sure we could edit the GRUB menu and solidly
    protect the GRUB console using passwords that are encrypted and unencrypted.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该已经能够理解，GRUB 是企业版 Linux 中常用的引导加载程序，它将包含用于启动操作系统的各种段落。每个段落包括三个命令。这三个命令组成的三巨头分别是
    root、kernel 和 initrd。我们还确保能够编辑 GRUB 菜单并通过加密和非加密的密码牢固保护 GRUB 控制台。
- en: Finally, we ended up in the paddling pool, the watery shallows of Linux on a
    summer evening, learning to boot splash with plymouth. This decorated the dawn
    and dusk of a Linux day with a little color, or a lot of red in the case of spinfinity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了浅水池，一个夏日傍晚的 Linux 水上游泳池，在这里，学习使用 plymouth 启动画面。这为 Linux 一天的黎明和黄昏增添了一抹色彩，或者在
    spinfinity 的情况下增添了大量红色。
- en: In the next section, we are going to walk into the Linux filesystems within
    CentOS, gaining an understanding of their makeup and structure. Starting with
    traditional systems based on disks or logical volumes, we will investigate how
    filenames relate to inodes and inodes relate to data. We will then move through
    to links, pipes, and sockets, and finally, finish off by taking a look at the
    **Better FS** (**btrfs**).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将进入 CentOS 中的 Linux 文件系统，了解它们的组成和结构。从基于磁盘或逻辑卷的传统系统开始，我们将调查文件名与索引节点之间的关系，以及索引节点与数据之间的关系。然后，我们将深入研究链接、管道和套接字，最后，以查看**Better
    FS**（**btrfs**）结束。
